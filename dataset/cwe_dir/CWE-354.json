[
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/journal_file_append_tag",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "int journal_file_append_tag(JournalFile *f) {\n        Object *o;\n        uint64_t p;\n        int r;\n\n        assert(f);\n\n        if (!JOURNAL_HEADER_SEALED(f->header))\n                return 0;\n\n        if (!f->hmac_running)\n                return 0;\n\n        assert(f->hmac);\n\n        r = journal_file_append_object(f, OBJECT_TAG, sizeof(struct TagObject), &o, &p);\n        if (r < 0)\n                return r;\n\n        o->tag.seqnum = htole64(journal_file_tag_seqnum(f));\n        o->tag.epoch = htole64(FSPRG_GetEpoch(f->fsprg_state));\n\n        log_debug(\"Writing tag %\"PRIu64\" for epoch %\"PRIu64\"\",\n                  le64toh(o->tag.seqnum),\n                  FSPRG_GetEpoch(f->fsprg_state));\n\n        /* Add the tag object itself, so that we can protect its\n         * header. This will exclude the actual hash value in it */\n        r = journal_file_hmac_put_object(f, OBJECT_TAG, o, p);\n        if (r < 0)\n                return r;\n\n        /* Get the HMAC tag and store it in the object */\n        memcpy(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH);\n        f->hmac_running = false;\n\n        return 0;\n}",
        "func": "int journal_file_append_tag(JournalFile *f) {\n        Object *o;\n        uint64_t p;\n        int r;\n\n        assert(f);\n\n        if (!JOURNAL_HEADER_SEALED(f->header))\n                return 0;\n\n        if (!f->hmac_running) {\n                r = journal_file_hmac_start(f);\n                if (r < 0)\n                        return r;\n        }\n\n        assert(f->hmac);\n\n        r = journal_file_append_object(f, OBJECT_TAG, sizeof(struct TagObject), &o, &p);\n        if (r < 0)\n                return r;\n\n        o->tag.seqnum = htole64(journal_file_tag_seqnum(f));\n        o->tag.epoch = htole64(FSPRG_GetEpoch(f->fsprg_state));\n\n        log_debug(\"Writing tag %\"PRIu64\" for epoch %\"PRIu64\"\",\n                  le64toh(o->tag.seqnum),\n                  FSPRG_GetEpoch(f->fsprg_state));\n\n        /* Add the tag object itself, so that we can protect its\n         * header. This will exclude the actual hash value in it */\n        r = journal_file_hmac_put_object(f, OBJECT_TAG, o, p);\n        if (r < 0)\n                return r;\n\n        /* Get the HMAC tag and store it in the object */\n        memcpy(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH);\n        f->hmac_running = false;\n\n        return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,11 @@\n         if (!JOURNAL_HEADER_SEALED(f->header))\n                 return 0;\n \n-        if (!f->hmac_running)\n-                return 0;\n+        if (!f->hmac_running) {\n+                r = journal_file_hmac_start(f);\n+                if (r < 0)\n+                        return r;\n+        }\n \n         assert(f->hmac);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!f->hmac_running)",
                "                return 0;"
            ],
            "added_lines": [
                "        if (!f->hmac_running) {",
                "                r = journal_file_hmac_start(f);",
                "                if (r < 0)",
                "                        return r;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/journal_file_fsprg_evolve",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "int journal_file_fsprg_evolve(JournalFile *f, uint64_t realtime) {\n        uint64_t goal, epoch;\n        int r;\n\n        assert(f);\n\n        if (!JOURNAL_HEADER_SEALED(f->header))\n                return 0;\n\n        r = journal_file_get_epoch(f, realtime, &goal);\n        if (r < 0)\n                return r;\n\n        epoch = FSPRG_GetEpoch(f->fsprg_state);\n        if (epoch < goal)\n                log_debug(\"Evolving FSPRG key from epoch %\"PRIu64\" to %\"PRIu64\".\", epoch, goal);\n\n        for (;;) {\n                if (epoch > goal)\n                        return -ESTALE;\n                if (epoch == goal)\n                        return 0;\n\n                FSPRG_Evolve(f->fsprg_state);\n                epoch = FSPRG_GetEpoch(f->fsprg_state);\n        }\n}",
        "func": "int journal_file_fsprg_evolve(JournalFile *f, uint64_t realtime) {\n        uint64_t goal, epoch;\n        int r;\n\n        assert(f);\n\n        if (!JOURNAL_HEADER_SEALED(f->header))\n                return 0;\n\n        r = journal_file_get_epoch(f, realtime, &goal);\n        if (r < 0)\n                return r;\n\n        epoch = FSPRG_GetEpoch(f->fsprg_state);\n        if (epoch < goal)\n                log_debug(\"Evolving FSPRG key from epoch %\"PRIu64\" to %\"PRIu64\".\", epoch, goal);\n\n        for (;;) {\n                if (epoch > goal)\n                        return -ESTALE;\n                if (epoch == goal)\n                        return 0;\n\n                FSPRG_Evolve(f->fsprg_state);\n                epoch = FSPRG_GetEpoch(f->fsprg_state);\n                if (epoch < goal) {\n                        r = journal_file_append_tag(f);\n                        if (r < 0)\n                                return r;\n                }\n        }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,5 +23,10 @@\n \n                 FSPRG_Evolve(f->fsprg_state);\n                 epoch = FSPRG_GetEpoch(f->fsprg_state);\n+                if (epoch < goal) {\n+                        r = journal_file_append_tag(f);\n+                        if (r < 0)\n+                                return r;\n+                }\n         }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if (epoch < goal) {",
                "                        r = journal_file_append_tag(f);",
                "                        if (r < 0)",
                "                                return r;",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/journal_file_init_header",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "static int journal_file_init_header(\n                JournalFile *f,\n                JournalFileFlags file_flags,\n                JournalFile *template) {\n\n        bool seal = false;\n        ssize_t k;\n        int r;\n\n        assert(f);\n\n#if HAVE_GCRYPT\n        /* Try to load the FSPRG state, and if we can't, then just don't do sealing */\n        seal = FLAGS_SET(file_flags, JOURNAL_SEAL) && journal_file_fss_load(f) >= 0;\n#endif\n\n        Header h = {\n                .header_size = htole64(ALIGN64(sizeof(h))),\n                .incompatible_flags = htole32(\n                                FLAGS_SET(file_flags, JOURNAL_COMPRESS) * COMPRESSION_TO_HEADER_INCOMPATIBLE_FLAG(compression_requested()) |\n                                keyed_hash_requested() * HEADER_INCOMPATIBLE_KEYED_HASH |\n                                compact_mode_requested() * HEADER_INCOMPATIBLE_COMPACT),\n                .compatible_flags = htole32(\n                                (seal * HEADER_COMPATIBLE_SEALED) |\n                                HEADER_COMPATIBLE_TAIL_ENTRY_BOOT_ID),\n        };\n\n        assert_cc(sizeof(h.signature) == sizeof(HEADER_SIGNATURE));\n        memcpy(h.signature, HEADER_SIGNATURE, sizeof(HEADER_SIGNATURE));\n\n        r = sd_id128_randomize(&h.file_id);\n        if (r < 0)\n                return r;\n\n        r = sd_id128_get_machine(&h.machine_id);\n        if (r < 0 && !ERRNO_IS_MACHINE_ID_UNSET(r))\n                return r; /* If we have no valid machine ID (test environment?), let's simply leave the\n                           * machine ID field all zeroes. */\n\n        if (template) {\n                h.seqnum_id = template->header->seqnum_id;\n                h.tail_entry_seqnum = template->header->tail_entry_seqnum;\n        } else\n                h.seqnum_id = h.file_id;\n\n        k = pwrite(f->fd, &h, sizeof(h), 0);\n        if (k < 0)\n                return -errno;\n        if (k != sizeof(h))\n                return -EIO;\n\n        return 0;\n}",
        "func": "static int journal_file_init_header(\n                JournalFile *f,\n                JournalFileFlags file_flags,\n                JournalFile *template) {\n\n        bool seal = false;\n        ssize_t k;\n        int r;\n\n        assert(f);\n\n#if HAVE_GCRYPT\n        /* Try to load the FSPRG state, and if we can't, then just don't do sealing */\n        seal = FLAGS_SET(file_flags, JOURNAL_SEAL) && journal_file_fss_load(f) >= 0;\n#endif\n\n        Header h = {\n                .header_size = htole64(ALIGN64(sizeof(h))),\n                .incompatible_flags = htole32(\n                                FLAGS_SET(file_flags, JOURNAL_COMPRESS) * COMPRESSION_TO_HEADER_INCOMPATIBLE_FLAG(compression_requested()) |\n                                keyed_hash_requested() * HEADER_INCOMPATIBLE_KEYED_HASH |\n                                compact_mode_requested() * HEADER_INCOMPATIBLE_COMPACT),\n                .compatible_flags = htole32(\n                                (seal * (HEADER_COMPATIBLE_SEALED | HEADER_COMPATIBLE_SEALED_CONTINUOUS) ) |\n                                HEADER_COMPATIBLE_TAIL_ENTRY_BOOT_ID),\n        };\n\n        assert_cc(sizeof(h.signature) == sizeof(HEADER_SIGNATURE));\n        memcpy(h.signature, HEADER_SIGNATURE, sizeof(HEADER_SIGNATURE));\n\n        r = sd_id128_randomize(&h.file_id);\n        if (r < 0)\n                return r;\n\n        r = sd_id128_get_machine(&h.machine_id);\n        if (r < 0 && !ERRNO_IS_MACHINE_ID_UNSET(r))\n                return r; /* If we have no valid machine ID (test environment?), let's simply leave the\n                           * machine ID field all zeroes. */\n\n        if (template) {\n                h.seqnum_id = template->header->seqnum_id;\n                h.tail_entry_seqnum = template->header->tail_entry_seqnum;\n        } else\n                h.seqnum_id = h.file_id;\n\n        k = pwrite(f->fd, &h, sizeof(h), 0);\n        if (k < 0)\n                return -errno;\n        if (k != sizeof(h))\n                return -EIO;\n\n        return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n                                 keyed_hash_requested() * HEADER_INCOMPATIBLE_KEYED_HASH |\n                                 compact_mode_requested() * HEADER_INCOMPATIBLE_COMPACT),\n                 .compatible_flags = htole32(\n-                                (seal * HEADER_COMPATIBLE_SEALED) |\n+                                (seal * (HEADER_COMPATIBLE_SEALED | HEADER_COMPATIBLE_SEALED_CONTINUOUS) ) |\n                                 HEADER_COMPATIBLE_TAIL_ENTRY_BOOT_ID),\n         };\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                                (seal * HEADER_COMPATIBLE_SEALED) |"
            ],
            "added_lines": [
                "                                (seal * (HEADER_COMPATIBLE_SEALED | HEADER_COMPATIBLE_SEALED_CONTINUOUS) ) |"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/warn_wrong_flags",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "static bool warn_wrong_flags(const JournalFile *f, bool compatible) {\n        const uint32_t any = compatible ? HEADER_COMPATIBLE_ANY : HEADER_INCOMPATIBLE_ANY,\n                supported = compatible ? HEADER_COMPATIBLE_SUPPORTED : HEADER_INCOMPATIBLE_SUPPORTED;\n        const char *type = compatible ? \"compatible\" : \"incompatible\";\n        uint32_t flags;\n\n        assert(f);\n        assert(f->header);\n\n        flags = le32toh(compatible ? f->header->compatible_flags : f->header->incompatible_flags);\n\n        if (flags & ~supported) {\n                if (flags & ~any)\n                        log_debug(\"Journal file %s has unknown %s flags 0x%\"PRIx32,\n                                  f->path, type, flags & ~any);\n                flags = (flags & any) & ~supported;\n                if (flags) {\n                        const char* strv[6];\n                        size_t n = 0;\n                        _cleanup_free_ char *t = NULL;\n\n                        if (compatible) {\n                                if (flags & HEADER_COMPATIBLE_SEALED)\n                                        strv[n++] = \"sealed\";\n                        } else {\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_XZ)\n                                        strv[n++] = \"xz-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_LZ4)\n                                        strv[n++] = \"lz4-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_ZSTD)\n                                        strv[n++] = \"zstd-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_KEYED_HASH)\n                                        strv[n++] = \"keyed-hash\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPACT)\n                                        strv[n++] = \"compact\";\n                        }\n                        strv[n] = NULL;\n                        assert(n < ELEMENTSOF(strv));\n\n                        t = strv_join((char**) strv, \", \");\n                        log_debug(\"Journal file %s uses %s %s %s disabled at compilation time.\",\n                                  f->path, type, n > 1 ? \"flags\" : \"flag\", strnull(t));\n                }\n                return true;\n        }\n\n        return false;\n}",
        "func": "static bool warn_wrong_flags(const JournalFile *f, bool compatible) {\n        const uint32_t any = compatible ? HEADER_COMPATIBLE_ANY : HEADER_INCOMPATIBLE_ANY,\n                supported = compatible ? HEADER_COMPATIBLE_SUPPORTED : HEADER_INCOMPATIBLE_SUPPORTED;\n        const char *type = compatible ? \"compatible\" : \"incompatible\";\n        uint32_t flags;\n\n        assert(f);\n        assert(f->header);\n\n        flags = le32toh(compatible ? f->header->compatible_flags : f->header->incompatible_flags);\n\n        if (flags & ~supported) {\n                if (flags & ~any)\n                        log_debug(\"Journal file %s has unknown %s flags 0x%\"PRIx32,\n                                  f->path, type, flags & ~any);\n                flags = (flags & any) & ~supported;\n                if (flags) {\n                        const char* strv[6];\n                        size_t n = 0;\n                        _cleanup_free_ char *t = NULL;\n\n                        if (compatible) {\n                                if (flags & HEADER_COMPATIBLE_SEALED)\n                                        strv[n++] = \"sealed\";\n                                if (flags & HEADER_COMPATIBLE_SEALED_CONTINUOUS)\n                                        strv[n++] = \"sealed-continuous\";\n                        } else {\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_XZ)\n                                        strv[n++] = \"xz-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_LZ4)\n                                        strv[n++] = \"lz4-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPRESSED_ZSTD)\n                                        strv[n++] = \"zstd-compressed\";\n                                if (flags & HEADER_INCOMPATIBLE_KEYED_HASH)\n                                        strv[n++] = \"keyed-hash\";\n                                if (flags & HEADER_INCOMPATIBLE_COMPACT)\n                                        strv[n++] = \"compact\";\n                        }\n                        strv[n] = NULL;\n                        assert(n < ELEMENTSOF(strv));\n\n                        t = strv_join((char**) strv, \", \");\n                        log_debug(\"Journal file %s uses %s %s %s disabled at compilation time.\",\n                                  f->path, type, n > 1 ? \"flags\" : \"flag\", strnull(t));\n                }\n                return true;\n        }\n\n        return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,8 @@\n                         if (compatible) {\n                                 if (flags & HEADER_COMPATIBLE_SEALED)\n                                         strv[n++] = \"sealed\";\n+                                if (flags & HEADER_COMPATIBLE_SEALED_CONTINUOUS)\n+                                        strv[n++] = \"sealed-continuous\";\n                         } else {\n                                 if (flags & HEADER_INCOMPATIBLE_COMPRESSED_XZ)\n                                         strv[n++] = \"xz-compressed\";",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                                if (flags & HEADER_COMPATIBLE_SEALED_CONTINUOUS)",
                "                                        strv[n++] = \"sealed-continuous\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/journal_file_print_header",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "void journal_file_print_header(JournalFile *f) {\n        struct stat st;\n\n        assert(f);\n        assert(f->header);\n\n        printf(\"File path: %s\\n\"\n               \"File ID: %s\\n\"\n               \"Machine ID: %s\\n\"\n               \"Boot ID: %s\\n\"\n               \"Sequential number ID: %s\\n\"\n               \"State: %s\\n\"\n               \"Compatible flags:%s%s%s\\n\"\n               \"Incompatible flags:%s%s%s%s%s%s\\n\"\n               \"Header size: %\"PRIu64\"\\n\"\n               \"Arena size: %\"PRIu64\"\\n\"\n               \"Data hash table size: %\"PRIu64\"\\n\"\n               \"Field hash table size: %\"PRIu64\"\\n\"\n               \"Rotate suggested: %s\\n\"\n               \"Head sequential number: %\"PRIu64\" (%\"PRIx64\")\\n\"\n               \"Tail sequential number: %\"PRIu64\" (%\"PRIx64\")\\n\"\n               \"Head realtime timestamp: %s (%\"PRIx64\")\\n\"\n               \"Tail realtime timestamp: %s (%\"PRIx64\")\\n\"\n               \"Tail monotonic timestamp: %s (%\"PRIx64\")\\n\"\n               \"Objects: %\"PRIu64\"\\n\"\n               \"Entry objects: %\"PRIu64\"\\n\",\n               f->path,\n               SD_ID128_TO_STRING(f->header->file_id),\n               SD_ID128_TO_STRING(f->header->machine_id),\n               SD_ID128_TO_STRING(f->header->tail_entry_boot_id),\n               SD_ID128_TO_STRING(f->header->seqnum_id),\n               f->header->state == STATE_OFFLINE ? \"OFFLINE\" :\n               f->header->state == STATE_ONLINE ? \"ONLINE\" :\n               f->header->state == STATE_ARCHIVED ? \"ARCHIVED\" : \"UNKNOWN\",\n               JOURNAL_HEADER_SEALED(f->header) ? \" SEALED\" : \"\",\n               JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) ? \" TAIL_ENTRY_BOOT_ID\" : \"\",\n               (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_ANY) ? \" ???\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_XZ(f->header) ? \" COMPRESSED-XZ\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_LZ4(f->header) ? \" COMPRESSED-LZ4\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_ZSTD(f->header) ? \" COMPRESSED-ZSTD\" : \"\",\n               JOURNAL_HEADER_KEYED_HASH(f->header) ? \" KEYED-HASH\" : \"\",\n               JOURNAL_HEADER_COMPACT(f->header) ? \" COMPACT\" : \"\",\n               (le32toh(f->header->incompatible_flags) & ~HEADER_INCOMPATIBLE_ANY) ? \" ???\" : \"\",\n               le64toh(f->header->header_size),\n               le64toh(f->header->arena_size),\n               le64toh(f->header->data_hash_table_size) / sizeof(HashItem),\n               le64toh(f->header->field_hash_table_size) / sizeof(HashItem),\n               yes_no(journal_file_rotate_suggested(f, 0, LOG_DEBUG)),\n               le64toh(f->header->head_entry_seqnum), le64toh(f->header->head_entry_seqnum),\n               le64toh(f->header->tail_entry_seqnum), le64toh(f->header->tail_entry_seqnum),\n               FORMAT_TIMESTAMP_SAFE(le64toh(f->header->head_entry_realtime)), le64toh(f->header->head_entry_realtime),\n               FORMAT_TIMESTAMP_SAFE(le64toh(f->header->tail_entry_realtime)), le64toh(f->header->tail_entry_realtime),\n               FORMAT_TIMESPAN(le64toh(f->header->tail_entry_monotonic), USEC_PER_MSEC), le64toh(f->header->tail_entry_monotonic),\n               le64toh(f->header->n_objects),\n               le64toh(f->header->n_entries));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data))\n                printf(\"Data objects: %\"PRIu64\"\\n\"\n                       \"Data hash table fill: %.1f%%\\n\",\n                       le64toh(f->header->n_data),\n                       100.0 * (double) le64toh(f->header->n_data) / ((double) (le64toh(f->header->data_hash_table_size) / sizeof(HashItem))));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields))\n                printf(\"Field objects: %\"PRIu64\"\\n\"\n                       \"Field hash table fill: %.1f%%\\n\",\n                       le64toh(f->header->n_fields),\n                       100.0 * (double) le64toh(f->header->n_fields) / ((double) (le64toh(f->header->field_hash_table_size) / sizeof(HashItem))));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags))\n                printf(\"Tag objects: %\"PRIu64\"\\n\",\n                       le64toh(f->header->n_tags));\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays))\n                printf(\"Entry array objects: %\"PRIu64\"\\n\",\n                       le64toh(f->header->n_entry_arrays));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, field_hash_chain_depth))\n                printf(\"Deepest field hash chain: %\" PRIu64\"\\n\",\n                       f->header->field_hash_chain_depth);\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, data_hash_chain_depth))\n                printf(\"Deepest data hash chain: %\" PRIu64\"\\n\",\n                       f->header->data_hash_chain_depth);\n\n        if (fstat(f->fd, &st) >= 0)\n                printf(\"Disk usage: %s\\n\", FORMAT_BYTES((uint64_t) st.st_blocks * 512ULL));\n}",
        "func": "void journal_file_print_header(JournalFile *f) {\n        struct stat st;\n\n        assert(f);\n        assert(f->header);\n\n        printf(\"File path: %s\\n\"\n               \"File ID: %s\\n\"\n               \"Machine ID: %s\\n\"\n               \"Boot ID: %s\\n\"\n               \"Sequential number ID: %s\\n\"\n               \"State: %s\\n\"\n               \"Compatible flags:%s%s%s%s\\n\"\n               \"Incompatible flags:%s%s%s%s%s%s\\n\"\n               \"Header size: %\"PRIu64\"\\n\"\n               \"Arena size: %\"PRIu64\"\\n\"\n               \"Data hash table size: %\"PRIu64\"\\n\"\n               \"Field hash table size: %\"PRIu64\"\\n\"\n               \"Rotate suggested: %s\\n\"\n               \"Head sequential number: %\"PRIu64\" (%\"PRIx64\")\\n\"\n               \"Tail sequential number: %\"PRIu64\" (%\"PRIx64\")\\n\"\n               \"Head realtime timestamp: %s (%\"PRIx64\")\\n\"\n               \"Tail realtime timestamp: %s (%\"PRIx64\")\\n\"\n               \"Tail monotonic timestamp: %s (%\"PRIx64\")\\n\"\n               \"Objects: %\"PRIu64\"\\n\"\n               \"Entry objects: %\"PRIu64\"\\n\",\n               f->path,\n               SD_ID128_TO_STRING(f->header->file_id),\n               SD_ID128_TO_STRING(f->header->machine_id),\n               SD_ID128_TO_STRING(f->header->tail_entry_boot_id),\n               SD_ID128_TO_STRING(f->header->seqnum_id),\n               f->header->state == STATE_OFFLINE ? \"OFFLINE\" :\n               f->header->state == STATE_ONLINE ? \"ONLINE\" :\n               f->header->state == STATE_ARCHIVED ? \"ARCHIVED\" : \"UNKNOWN\",\n               JOURNAL_HEADER_SEALED(f->header) ? \" SEALED\" : \"\",\n               JOURNAL_HEADER_SEALED_CONTINUOUS(f->header) ? \" SEALED_CONTINUOUS\" : \"\",\n               JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) ? \" TAIL_ENTRY_BOOT_ID\" : \"\",\n               (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_ANY) ? \" ???\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_XZ(f->header) ? \" COMPRESSED-XZ\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_LZ4(f->header) ? \" COMPRESSED-LZ4\" : \"\",\n               JOURNAL_HEADER_COMPRESSED_ZSTD(f->header) ? \" COMPRESSED-ZSTD\" : \"\",\n               JOURNAL_HEADER_KEYED_HASH(f->header) ? \" KEYED-HASH\" : \"\",\n               JOURNAL_HEADER_COMPACT(f->header) ? \" COMPACT\" : \"\",\n               (le32toh(f->header->incompatible_flags) & ~HEADER_INCOMPATIBLE_ANY) ? \" ???\" : \"\",\n               le64toh(f->header->header_size),\n               le64toh(f->header->arena_size),\n               le64toh(f->header->data_hash_table_size) / sizeof(HashItem),\n               le64toh(f->header->field_hash_table_size) / sizeof(HashItem),\n               yes_no(journal_file_rotate_suggested(f, 0, LOG_DEBUG)),\n               le64toh(f->header->head_entry_seqnum), le64toh(f->header->head_entry_seqnum),\n               le64toh(f->header->tail_entry_seqnum), le64toh(f->header->tail_entry_seqnum),\n               FORMAT_TIMESTAMP_SAFE(le64toh(f->header->head_entry_realtime)), le64toh(f->header->head_entry_realtime),\n               FORMAT_TIMESTAMP_SAFE(le64toh(f->header->tail_entry_realtime)), le64toh(f->header->tail_entry_realtime),\n               FORMAT_TIMESPAN(le64toh(f->header->tail_entry_monotonic), USEC_PER_MSEC), le64toh(f->header->tail_entry_monotonic),\n               le64toh(f->header->n_objects),\n               le64toh(f->header->n_entries));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data))\n                printf(\"Data objects: %\"PRIu64\"\\n\"\n                       \"Data hash table fill: %.1f%%\\n\",\n                       le64toh(f->header->n_data),\n                       100.0 * (double) le64toh(f->header->n_data) / ((double) (le64toh(f->header->data_hash_table_size) / sizeof(HashItem))));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields))\n                printf(\"Field objects: %\"PRIu64\"\\n\"\n                       \"Field hash table fill: %.1f%%\\n\",\n                       le64toh(f->header->n_fields),\n                       100.0 * (double) le64toh(f->header->n_fields) / ((double) (le64toh(f->header->field_hash_table_size) / sizeof(HashItem))));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags))\n                printf(\"Tag objects: %\"PRIu64\"\\n\",\n                       le64toh(f->header->n_tags));\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays))\n                printf(\"Entry array objects: %\"PRIu64\"\\n\",\n                       le64toh(f->header->n_entry_arrays));\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, field_hash_chain_depth))\n                printf(\"Deepest field hash chain: %\" PRIu64\"\\n\",\n                       f->header->field_hash_chain_depth);\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, data_hash_chain_depth))\n                printf(\"Deepest data hash chain: %\" PRIu64\"\\n\",\n                       f->header->data_hash_chain_depth);\n\n        if (fstat(f->fd, &st) >= 0)\n                printf(\"Disk usage: %s\\n\", FORMAT_BYTES((uint64_t) st.st_blocks * 512ULL));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n                \"Boot ID: %s\\n\"\n                \"Sequential number ID: %s\\n\"\n                \"State: %s\\n\"\n-               \"Compatible flags:%s%s%s\\n\"\n+               \"Compatible flags:%s%s%s%s\\n\"\n                \"Incompatible flags:%s%s%s%s%s%s\\n\"\n                \"Header size: %\"PRIu64\"\\n\"\n                \"Arena size: %\"PRIu64\"\\n\"\n@@ -33,6 +33,7 @@\n                f->header->state == STATE_ONLINE ? \"ONLINE\" :\n                f->header->state == STATE_ARCHIVED ? \"ARCHIVED\" : \"UNKNOWN\",\n                JOURNAL_HEADER_SEALED(f->header) ? \" SEALED\" : \"\",\n+               JOURNAL_HEADER_SEALED_CONTINUOUS(f->header) ? \" SEALED_CONTINUOUS\" : \"\",\n                JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) ? \" TAIL_ENTRY_BOOT_ID\" : \"\",\n                (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_ANY) ? \" ???\" : \"\",\n                JOURNAL_HEADER_COMPRESSED_XZ(f->header) ? \" COMPRESSED-XZ\" : \"\",",
        "diff_line_info": {
            "deleted_lines": [
                "               \"Compatible flags:%s%s%s\\n\""
            ],
            "added_lines": [
                "               \"Compatible flags:%s%s%s%s\\n\"",
                "               JOURNAL_HEADER_SEALED_CONTINUOUS(f->header) ? \" SEALED_CONTINUOUS\" : \"\","
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/server_archive_offline_user_journals",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "static int server_archive_offline_user_journals(Server *s) {\n        _cleanup_closedir_ DIR *d = NULL;\n        int r;\n\n        assert(s);\n\n        d = opendir(s->system_storage.path);\n        if (!d) {\n                if (errno == ENOENT)\n                        return 0;\n\n                return log_ratelimit_error_errno(errno, JOURNAL_LOG_RATELIMIT,\n                                                 \"Failed to open %s: %m\", s->system_storage.path);\n        }\n\n        for (;;) {\n                _cleanup_free_ char *full = NULL;\n                _cleanup_close_ int fd = -EBADF;\n                struct dirent *de;\n                JournalFile *f;\n                uid_t uid;\n\n                errno = 0;\n                de = readdir_no_dot(d);\n                if (!de) {\n                        if (errno != 0)\n                                log_ratelimit_warning_errno(errno, JOURNAL_LOG_RATELIMIT,\n                                                            \"Failed to enumerate %s, ignoring: %m\",\n                                                            s->system_storage.path);\n                        break;\n                }\n\n                r = journal_file_parse_uid_from_filename(de->d_name, &uid);\n                if (r < 0) {\n                        /* Don't warn if the file is not an online or offline user journal. */\n                        if (r != -EREMOTE)\n                                log_warning_errno(r, \"Failed to parse UID from file name '%s', ignoring: %m\", de->d_name);\n                        continue;\n                }\n\n                /* Already rotated in the above loop? i.e. is it an open user journal? */\n                if (ordered_hashmap_contains(s->user_journals, UID_TO_PTR(uid)))\n                        continue;\n\n                full = path_join(s->system_storage.path, de->d_name);\n                if (!full)\n                        return log_oom();\n\n                fd = openat(dirfd(d), de->d_name, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NOFOLLOW|O_NONBLOCK);\n                if (fd < 0) {\n                        log_ratelimit_full_errno(IN_SET(errno, ELOOP, ENOENT) ? LOG_DEBUG : LOG_WARNING,\n                                                 errno, JOURNAL_LOG_RATELIMIT,\n                                                 \"Failed to open journal file '%s' for rotation: %m\", full);\n                        continue;\n                }\n\n                /* Make some room in the set of deferred close()s */\n                server_vacuum_deferred_closes(s);\n\n                /* Open the file briefly, so that we can archive it */\n                r = journal_file_open(\n                                fd,\n                                full,\n                                O_RDWR,\n                                (s->compress.enabled ? JOURNAL_COMPRESS : 0) |\n                                (s->seal ? JOURNAL_SEAL : 0), /* strict order does not matter here */\n                                0640,\n                                s->compress.threshold_bytes,\n                                &s->system_storage.metrics,\n                                s->mmap,\n                                /* template= */ NULL,\n                                &f);\n                if (r < 0) {\n                        log_ratelimit_warning_errno(r, JOURNAL_LOG_RATELIMIT,\n                                                    \"Failed to read journal file %s for rotation, trying to move it out of the way: %m\",\n                                                    full);\n\n                        r = journal_file_dispose(dirfd(d), de->d_name);\n                        if (r < 0)\n                                log_ratelimit_warning_errno(r, JOURNAL_LOG_RATELIMIT,\n                                                            \"Failed to move %s out of the way, ignoring: %m\",\n                                                            full);\n                        else\n                                log_debug(\"Successfully moved %s out of the way.\", full);\n\n                        continue;\n                }\n\n                TAKE_FD(fd); /* Donated to journal_file_open() */\n\n                r = journal_file_archive(f, NULL);\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to archive journal file '%s', ignoring: %m\", full);\n\n                journal_file_initiate_close(TAKE_PTR(f), s->deferred_closes);\n        }\n\n        return 0;\n}",
        "func": "static int server_archive_offline_user_journals(Server *s) {\n        _cleanup_closedir_ DIR *d = NULL;\n        int r;\n\n        assert(s);\n\n        d = opendir(s->system_storage.path);\n        if (!d) {\n                if (errno == ENOENT)\n                        return 0;\n\n                return log_ratelimit_error_errno(errno, JOURNAL_LOG_RATELIMIT,\n                                                 \"Failed to open %s: %m\", s->system_storage.path);\n        }\n\n        for (;;) {\n                _cleanup_free_ char *full = NULL;\n                _cleanup_close_ int fd = -EBADF;\n                struct dirent *de;\n                JournalFile *f;\n                uid_t uid;\n\n                errno = 0;\n                de = readdir_no_dot(d);\n                if (!de) {\n                        if (errno != 0)\n                                log_ratelimit_warning_errno(errno, JOURNAL_LOG_RATELIMIT,\n                                                            \"Failed to enumerate %s, ignoring: %m\",\n                                                            s->system_storage.path);\n                        break;\n                }\n\n                r = journal_file_parse_uid_from_filename(de->d_name, &uid);\n                if (r < 0) {\n                        /* Don't warn if the file is not an online or offline user journal. */\n                        if (r != -EREMOTE)\n                                log_warning_errno(r, \"Failed to parse UID from file name '%s', ignoring: %m\", de->d_name);\n                        continue;\n                }\n\n                /* Already rotated in the above loop? i.e. is it an open user journal? */\n                if (ordered_hashmap_contains(s->user_journals, UID_TO_PTR(uid)))\n                        continue;\n\n                full = path_join(s->system_storage.path, de->d_name);\n                if (!full)\n                        return log_oom();\n\n                fd = openat(dirfd(d), de->d_name, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NOFOLLOW|O_NONBLOCK);\n                if (fd < 0) {\n                        log_ratelimit_full_errno(IN_SET(errno, ELOOP, ENOENT) ? LOG_DEBUG : LOG_WARNING,\n                                                 errno, JOURNAL_LOG_RATELIMIT,\n                                                 \"Failed to open journal file '%s' for rotation: %m\", full);\n                        continue;\n                }\n\n                /* Make some room in the set of deferred close()s */\n                server_vacuum_deferred_closes(s);\n\n                /* Open the file briefly, so that we can archive it */\n                r = journal_file_open(\n                                fd,\n                                full,\n                                O_RDWR,\n                                (s->compress.enabled ? JOURNAL_COMPRESS : 0) |\n                                (s->seal ? JOURNAL_SEAL : 0), /* strict order does not matter here */\n                                0640,\n                                s->compress.threshold_bytes,\n                                &s->system_storage.metrics,\n                                s->mmap,\n                                /* template= */ NULL,\n                                &f);\n                if (r < 0) {\n                        log_ratelimit_warning_errno(r, JOURNAL_LOG_RATELIMIT,\n                                                    \"Failed to read journal file %s for rotation, trying to move it out of the way: %m\",\n                                                    full);\n\n                        r = journal_file_dispose(dirfd(d), de->d_name);\n                        if (r < 0)\n                                log_ratelimit_warning_errno(r, JOURNAL_LOG_RATELIMIT,\n                                                            \"Failed to move %s out of the way, ignoring: %m\",\n                                                            full);\n                        else\n                                log_debug(\"Successfully moved %s out of the way.\", full);\n\n                        continue;\n                }\n\n                TAKE_FD(fd); /* Donated to journal_file_open() */\n\n                journal_file_write_final_tag(f);\n                r = journal_file_archive(f, NULL);\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to archive journal file '%s', ignoring: %m\", full);\n\n                journal_file_initiate_close(TAKE_PTR(f), s->deferred_closes);\n        }\n\n        return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -88,6 +88,7 @@\n \n                 TAKE_FD(fd); /* Donated to journal_file_open() */\n \n+                journal_file_write_final_tag(f);\n                 r = journal_file_archive(f, NULL);\n                 if (r < 0)\n                         log_debug_errno(r, \"Failed to archive journal file '%s', ignoring: %m\", full);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                journal_file_write_final_tag(f);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/journal_file_verify",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "int journal_file_verify(\n                JournalFile *f,\n                const char *key,\n                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,\n                bool show_progress) {\n        int r;\n        Object *o;\n        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n\n        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;\n        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;\n        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n        usec_t last_usec = 0;\n        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;\n        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;\n        unsigned i;\n        bool found_last = false;\n        const char *tmp_dir = NULL;\n        MMapCache *m;\n\n#if HAVE_GCRYPT\n        uint64_t last_tag = 0;\n#endif\n        assert(f);\n\n        if (key) {\n#if HAVE_GCRYPT\n                r = journal_file_parse_verification_key(f, key);\n                if (r < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return r;\n                }\n#else\n                return -EOPNOTSUPP;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(f->header))\n                return -ENOKEY;\n\n        r = var_tmp_dir(&tmp_dir);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (data_fd < 0) {\n                r = log_error_errno(data_fd, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_fd < 0) {\n                r = log_error_errno(entry_fd, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_array_fd < 0) {\n                r = log_error_errno(entry_array_fd,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        m = mmap_cache_fd_cache(f->cache_fd);\n        r = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE, &cache_data_fd);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to cache data file: %m\");\n                goto fail;\n        }\n\n        r = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE, &cache_entry_fd);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to cache entry file: %m\");\n                goto fail;\n        }\n\n        r = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE, &cache_entry_array_fd);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to cache entry array file: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&data_fd, \"w+\", &data_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_fd, \"w+\", &entry_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_array_fd, \"w+\", &entry_array_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                r = -EOPNOTSUPP;\n                goto fail;\n        }\n\n        for (i = 0; i < sizeof(f->header->reserved); i++)\n                if (f->header->reserved[i] != 0) {\n                        error(offsetof(Header, reserved[i]), \"Reserved field is non-zero\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n        /* First iteration: we go through all objects, verify the\n         * superficial structure, headers, hashes. */\n\n        p = le64toh(f->header->header_size);\n        for (;;) {\n                /* Early exit if there are no objects in the file, at all */\n                if (le64toh(f->header->tail_object_offset) == 0)\n                        break;\n\n                if (show_progress)\n                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);\n\n                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (p > le64toh(f->header->tail_object_offset)) {\n                        error(offsetof(Header, tail_object_offset),\n                              \"Invalid tail object pointer (%\"PRIu64\" > %\"PRIu64\")\",\n                              p,\n                              le64toh(f->header->tail_object_offset));\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                n_objects++;\n\n                r = journal_file_object_verify(f, p, o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {\n                        error(p, \"Object has multiple compression flags set (flags: 0x%x)\", o->object.flags);\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {\n                        error(p, \"XZ compressed object in file without XZ compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {\n                        error(p, \"LZ4 compressed object in file without LZ4 compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {\n                        error(p, \"ZSTD compressed object in file without ZSTD compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                switch (o->object.type) {\n\n                case OBJECT_DATA:\n                        r = write_uint64(data_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        n_data++;\n                        break;\n\n                case OBJECT_FIELD:\n                        n_fields++;\n                        break;\n\n                case OBJECT_ENTRY:\n                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {\n                                error(p, \"First entry before first tag\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        r = write_uint64(entry_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (le64toh(o->entry.realtime) < last_tag_realtime) {\n                                error(p,\n                                      \"Older entry after newer tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      last_tag_realtime);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (!entry_seqnum_set &&\n                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {\n                                error(p,\n                                      \"Head entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.seqnum),\n                                      le64toh(f->header->head_entry_seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (entry_seqnum_set &&\n                            entry_seqnum >= le64toh(o->entry.seqnum)) {\n                                error(p,\n                                      \"Entry sequence number out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                      entry_seqnum,\n                                      le64toh(o->entry.seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_seqnum = le64toh(o->entry.seqnum);\n                        entry_seqnum_set = true;\n\n                        if (entry_monotonic_set &&\n                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&\n                            entry_monotonic > le64toh(o->entry.monotonic)) {\n                                error(p,\n                                      \"Entry timestamp out of synchronization (%\"PRIu64\" > %\"PRIu64\")\",\n                                      entry_monotonic,\n                                      le64toh(o->entry.monotonic));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_monotonic = le64toh(o->entry.monotonic);\n                        entry_boot_id = o->entry.boot_id;\n                        entry_monotonic_set = true;\n\n                        if (!entry_realtime_set &&\n                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {\n                                error(p,\n                                      \"Head entry realtime timestamp incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      le64toh(f->header->head_entry_realtime));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_realtime = le64toh(o->entry.realtime);\n                        entry_realtime_set = true;\n\n                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));\n                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));\n\n                        n_entries++;\n                        break;\n\n                case OBJECT_DATA_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_data_hash_tables,\n                                              le64toh(f->header->data_hash_table_offset),\n                                              le64toh(f->header->data_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n                        break;\n\n                case OBJECT_FIELD_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_field_hash_tables,\n                                              le64toh(f->header->field_hash_table_offset),\n                                              le64toh(f->header->field_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n\n                        break;\n\n                case OBJECT_ENTRY_ARRAY:\n                        r = write_uint64(entry_array_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (p == le64toh(f->header->entry_array_offset)) {\n                                if (found_main_entry_array) {\n                                        error(p, \"More than one main entry array\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                found_main_entry_array = true;\n                        }\n\n                        n_entry_arrays++;\n                        break;\n\n                case OBJECT_TAG:\n                        if (!JOURNAL_HEADER_SEALED(f->header)) {\n                                error(p, \"Tag object in file without sealing\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.seqnum) != n_tags + 1) {\n                                error(p,\n                                      \"Tag sequence number out of synchronization (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->tag.seqnum),\n                                      n_tags + 1);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.epoch) < last_epoch) {\n                                error(p,\n                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->tag.epoch),\n                                      last_epoch);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n#if HAVE_GCRYPT\n                        if (JOURNAL_HEADER_SEALED(f->header)) {\n                                uint64_t q, rt, rt_end;\n\n                                debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n\n                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n                                rt_end = usec_add(rt, f->fss_interval_usec);\n                                if (entry_realtime_set && entry_realtime >= rt_end) {\n                                        error(p,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (max_entry_realtime >= rt_end) {\n                                        error(p,\n                                              \"Entry realtime (%\"PRIu64\", %s) is too late with respect to tag (%\"PRIu64\", %s)\",\n                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),\n                                              rt_end, FORMAT_TIMESTAMP(rt_end));\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (min_entry_realtime < rt) {\n                                        error(p,\n                                              \"Entry realtime (%\"PRIu64\", %s) is too early with respect to tag (%\"PRIu64\", %s)\",\n                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),\n                                              rt, FORMAT_TIMESTAMP(rt));\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                min_entry_realtime = USEC_INFINITY;\n\n                                /* OK, now we know the epoch. So let's now set\n                                 * it, and calculate the HMAC for everything\n                                 * since the last tag. */\n                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));\n                                if (r < 0)\n                                        goto fail;\n\n                                r = journal_file_hmac_start(f);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (last_tag == 0) {\n                                        r = journal_file_hmac_put_header(f);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = le64toh(f->header->header_size);\n                                } else\n                                        q = last_tag;\n\n                                while (q <= p) {\n                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = q + ALIGN64(le64toh(o->object.size));\n                                }\n\n                                /* Position might have changed, let's reposition things */\n                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {\n                                        error(p, \"Tag failed verification\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                f->hmac_running = false;\n                                last_tag_realtime = rt;\n                                last_sealed_realtime = entry_realtime;\n                        }\n\n                        last_tag = p + ALIGN64(le64toh(o->object.size));\n#endif\n\n                        last_epoch = le64toh(o->tag.epoch);\n\n                        n_tags++;\n                        break;\n                }\n\n                if (p == le64toh(f->header->tail_object_offset)) {\n                        found_last = true;\n                        break;\n                }\n\n                p = p + ALIGN64(le64toh(o->object.size));\n        };\n\n        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {\n                error(le64toh(f->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"PRIu64\" != 0)\",\n                      le64toh(f->header->tail_object_offset));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_objects != le64toh(f->header->n_objects)) {\n                error(offsetof(Header, n_objects),\n                      \"Object number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_objects,\n                      le64toh(f->header->n_objects));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_entries != le64toh(f->header->n_entries)) {\n                error(offsetof(Header, n_entries),\n                      \"Entry number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entries,\n                      le64toh(f->header->n_entries));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&\n            n_data != le64toh(f->header->n_data)) {\n                error(offsetof(Header, n_data),\n                      \"Data number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_data,\n                      le64toh(f->header->n_data));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&\n            n_fields != le64toh(f->header->n_fields)) {\n                error(offsetof(Header, n_fields),\n                      \"Field number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_fields,\n                      le64toh(f->header->n_fields));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&\n            n_tags != le64toh(f->header->n_tags)) {\n                error(offsetof(Header, n_tags),\n                      \"Tag number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_tags,\n                      le64toh(f->header->n_tags));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&\n            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {\n                error(offsetof(Header, n_entry_arrays),\n                      \"Entry array number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entry_arrays,\n                      le64toh(f->header->n_entry_arrays));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_seqnum_set &&\n            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {\n                error(offsetof(Header, tail_entry_seqnum),\n                      \"Tail entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_seqnum,\n                      le64toh(f->header->tail_entry_seqnum));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_monotonic_set &&\n            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&\n             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_monotonic,\n                      le64toh(f->header->tail_entry_monotonic));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_realtime,\n                      le64toh(f->header->tail_entry_realtime));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (fflush(data_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_array_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* Second iteration: we follow all objects referenced from the\n         * two entry points: the object hash table and the entry\n         * array. We also check that everything referenced (directly\n         * or indirectly) in the data hash table also exists in the\n         * entry array, and vice versa. Note that we do not care for\n         * unreferenced objects. We only care that everything that is\n         * referenced is consistent. */\n\n        r = verify_entry_array(f,\n                               cache_data_fd, n_data,\n                               cache_entry_fd, n_entries,\n                               cache_entry_array_fd, n_entry_arrays,\n                               &last_usec,\n                               show_progress);\n        if (r < 0)\n                goto fail;\n\n        r = verify_data_hash_table(f,\n                                   cache_data_fd, n_data,\n                                   cache_entry_fd, n_entries,\n                                   cache_entry_array_fd, n_entry_arrays,\n                                   &last_usec,\n                                   show_progress);\n        if (r < 0)\n                goto fail;\n\n        if (show_progress)\n                flush_progress();\n\n        mmap_cache_fd_free(cache_data_fd);\n        mmap_cache_fd_free(cache_entry_fd);\n        mmap_cache_fd_free(cache_entry_array_fd);\n\n        if (first_contained)\n                *first_contained = le64toh(f->header->head_entry_realtime);\n        if (last_validated)\n                *last_validated = last_sealed_realtime;\n        if (last_contained)\n                *last_contained = le64toh(f->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (show_progress)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"PRIu64\" (of %\"PRIu64\" bytes, %\"PRIu64\"%%).\",\n                  f->path,\n                  p,\n                  (uint64_t) f->last_stat.st_size,\n                  100U * p / (uint64_t) f->last_stat.st_size);\n\n        if (cache_data_fd)\n                mmap_cache_fd_free(cache_data_fd);\n\n        if (cache_entry_fd)\n                mmap_cache_fd_free(cache_entry_fd);\n\n        if (cache_entry_array_fd)\n                mmap_cache_fd_free(cache_entry_array_fd);\n\n        return r;\n}",
        "func": "int journal_file_verify(\n                JournalFile *f,\n                const char *key,\n                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,\n                bool show_progress) {\n        int r;\n        Object *o;\n        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0;\n\n        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;\n        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;\n        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n        usec_t last_usec = 0;\n        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;\n        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;\n        unsigned i;\n        bool found_last = false;\n        const char *tmp_dir = NULL;\n        MMapCache *m;\n\n#if HAVE_GCRYPT\n        uint64_t last_tag = 0;\n#endif\n        assert(f);\n\n        if (key) {\n#if HAVE_GCRYPT\n                r = journal_file_parse_verification_key(f, key);\n                if (r < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return r;\n                }\n#else\n                return -EOPNOTSUPP;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(f->header))\n                return -ENOKEY;\n\n        r = var_tmp_dir(&tmp_dir);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (data_fd < 0) {\n                r = log_error_errno(data_fd, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_fd < 0) {\n                r = log_error_errno(entry_fd, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_array_fd < 0) {\n                r = log_error_errno(entry_array_fd,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        m = mmap_cache_fd_cache(f->cache_fd);\n        r = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE, &cache_data_fd);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to cache data file: %m\");\n                goto fail;\n        }\n\n        r = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE, &cache_entry_fd);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to cache entry file: %m\");\n                goto fail;\n        }\n\n        r = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE, &cache_entry_array_fd);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to cache entry array file: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&data_fd, \"w+\", &data_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_fd, \"w+\", &entry_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_array_fd, \"w+\", &entry_array_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                r = -EOPNOTSUPP;\n                goto fail;\n        }\n\n        for (i = 0; i < sizeof(f->header->reserved); i++)\n                if (f->header->reserved[i] != 0) {\n                        error(offsetof(Header, reserved[i]), \"Reserved field is non-zero\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n        if (!JOURNAL_HEADER_SEALED_CONTINUOUS(f->header))\n                warning(p,\n                        \"This log file was sealed with an old journald version where the sequence of seals might not be continuous. We cannot guarantee completeness.\");\n\n        /* First iteration: we go through all objects, verify the\n         * superficial structure, headers, hashes. */\n\n        p = le64toh(f->header->header_size);\n        for (;;) {\n                /* Early exit if there are no objects in the file, at all */\n                if (le64toh(f->header->tail_object_offset) == 0)\n                        break;\n\n                if (show_progress)\n                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);\n\n                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (p > le64toh(f->header->tail_object_offset)) {\n                        error(offsetof(Header, tail_object_offset),\n                              \"Invalid tail object pointer (%\"PRIu64\" > %\"PRIu64\")\",\n                              p,\n                              le64toh(f->header->tail_object_offset));\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                n_objects++;\n\n                r = journal_file_object_verify(f, p, o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {\n                        error(p, \"Object has multiple compression flags set (flags: 0x%x)\", o->object.flags);\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {\n                        error(p, \"XZ compressed object in file without XZ compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {\n                        error(p, \"LZ4 compressed object in file without LZ4 compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {\n                        error(p, \"ZSTD compressed object in file without ZSTD compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                switch (o->object.type) {\n\n                case OBJECT_DATA:\n                        r = write_uint64(data_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        n_data++;\n                        break;\n\n                case OBJECT_FIELD:\n                        n_fields++;\n                        break;\n\n                case OBJECT_ENTRY:\n                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {\n                                error(p, \"First entry before first tag\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        r = write_uint64(entry_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (le64toh(o->entry.realtime) < last_tag_realtime) {\n                                error(p,\n                                      \"Older entry after newer tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      last_tag_realtime);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (!entry_seqnum_set &&\n                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {\n                                error(p,\n                                      \"Head entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.seqnum),\n                                      le64toh(f->header->head_entry_seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (entry_seqnum_set &&\n                            entry_seqnum >= le64toh(o->entry.seqnum)) {\n                                error(p,\n                                      \"Entry sequence number out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                      entry_seqnum,\n                                      le64toh(o->entry.seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_seqnum = le64toh(o->entry.seqnum);\n                        entry_seqnum_set = true;\n\n                        if (entry_monotonic_set &&\n                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&\n                            entry_monotonic > le64toh(o->entry.monotonic)) {\n                                error(p,\n                                      \"Entry timestamp out of synchronization (%\"PRIu64\" > %\"PRIu64\")\",\n                                      entry_monotonic,\n                                      le64toh(o->entry.monotonic));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_monotonic = le64toh(o->entry.monotonic);\n                        entry_boot_id = o->entry.boot_id;\n                        entry_monotonic_set = true;\n\n                        if (!entry_realtime_set &&\n                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {\n                                error(p,\n                                      \"Head entry realtime timestamp incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      le64toh(f->header->head_entry_realtime));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_realtime = le64toh(o->entry.realtime);\n                        entry_realtime_set = true;\n\n                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));\n                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));\n\n                        n_entries++;\n                        break;\n\n                case OBJECT_DATA_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_data_hash_tables,\n                                              le64toh(f->header->data_hash_table_offset),\n                                              le64toh(f->header->data_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n                        break;\n\n                case OBJECT_FIELD_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_field_hash_tables,\n                                              le64toh(f->header->field_hash_table_offset),\n                                              le64toh(f->header->field_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n\n                        break;\n\n                case OBJECT_ENTRY_ARRAY:\n                        r = write_uint64(entry_array_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (p == le64toh(f->header->entry_array_offset)) {\n                                if (found_main_entry_array) {\n                                        error(p, \"More than one main entry array\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                found_main_entry_array = true;\n                        }\n\n                        n_entry_arrays++;\n                        break;\n\n                case OBJECT_TAG:\n                        if (!JOURNAL_HEADER_SEALED(f->header)) {\n                                error(p, \"Tag object in file without sealing\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.seqnum) != n_tags + 1) {\n                                error(p,\n                                      \"Tag sequence number out of synchronization (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->tag.seqnum),\n                                      n_tags + 1);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (JOURNAL_HEADER_SEALED_CONTINUOUS(f->header)) {\n                                if (!(n_tags == 0 || (n_tags == 1 && le64toh(o->tag.epoch) == last_epoch)\n                                      || le64toh(o->tag.epoch) == last_epoch + 1)) {\n                                        error(p,\n                                              \"Epoch sequence not continuous (%\"PRIu64\" vs %\"PRIu64\")\",\n                                              le64toh(o->tag.epoch),\n                                              last_epoch);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                        } else {\n                                if (le64toh(o->tag.epoch) < last_epoch) {\n                                        error(p,\n                                              \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n                                              le64toh(o->tag.epoch),\n                                              last_epoch);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                        }\n\n#if HAVE_GCRYPT\n                        if (JOURNAL_HEADER_SEALED(f->header)) {\n                                uint64_t q, rt, rt_end;\n\n                                debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n\n                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n                                rt_end = usec_add(rt, f->fss_interval_usec);\n                                if (entry_realtime_set && entry_realtime >= rt_end) {\n                                        error(p,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (max_entry_realtime >= rt_end) {\n                                        error(p,\n                                              \"Entry realtime (%\"PRIu64\", %s) is too late with respect to tag (%\"PRIu64\", %s)\",\n                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),\n                                              rt_end, FORMAT_TIMESTAMP(rt_end));\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (min_entry_realtime < rt) {\n                                        error(p,\n                                              \"Entry realtime (%\"PRIu64\", %s) is too early with respect to tag (%\"PRIu64\", %s)\",\n                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),\n                                              rt, FORMAT_TIMESTAMP(rt));\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                min_entry_realtime = USEC_INFINITY;\n\n                                /* OK, now we know the epoch. So let's now set\n                                 * it, and calculate the HMAC for everything\n                                 * since the last tag. */\n                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));\n                                if (r < 0)\n                                        goto fail;\n\n                                r = journal_file_hmac_start(f);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (last_tag == 0) {\n                                        r = journal_file_hmac_put_header(f);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = le64toh(f->header->header_size);\n                                } else\n                                        q = last_tag;\n\n                                while (q <= p) {\n                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = q + ALIGN64(le64toh(o->object.size));\n                                }\n\n                                /* Position might have changed, let's reposition things */\n                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {\n                                        error(p, \"Tag failed verification\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                f->hmac_running = false;\n                                last_tag_realtime = rt;\n                        }\n\n                        last_tag = p + ALIGN64(le64toh(o->object.size));\n#endif\n\n                        last_epoch = le64toh(o->tag.epoch);\n\n                        n_tags++;\n                        break;\n                }\n\n                if (p == le64toh(f->header->tail_object_offset)) {\n                        found_last = true;\n                        break;\n                }\n\n                p = p + ALIGN64(le64toh(o->object.size));\n        };\n\n        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {\n                error(le64toh(f->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"PRIu64\" != 0)\",\n                      le64toh(f->header->tail_object_offset));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_objects != le64toh(f->header->n_objects)) {\n                error(offsetof(Header, n_objects),\n                      \"Object number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_objects,\n                      le64toh(f->header->n_objects));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_entries != le64toh(f->header->n_entries)) {\n                error(offsetof(Header, n_entries),\n                      \"Entry number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entries,\n                      le64toh(f->header->n_entries));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&\n            n_data != le64toh(f->header->n_data)) {\n                error(offsetof(Header, n_data),\n                      \"Data number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_data,\n                      le64toh(f->header->n_data));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&\n            n_fields != le64toh(f->header->n_fields)) {\n                error(offsetof(Header, n_fields),\n                      \"Field number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_fields,\n                      le64toh(f->header->n_fields));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&\n            n_tags != le64toh(f->header->n_tags)) {\n                error(offsetof(Header, n_tags),\n                      \"Tag number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_tags,\n                      le64toh(f->header->n_tags));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&\n            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {\n                error(offsetof(Header, n_entry_arrays),\n                      \"Entry array number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entry_arrays,\n                      le64toh(f->header->n_entry_arrays));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_seqnum_set &&\n            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {\n                error(offsetof(Header, tail_entry_seqnum),\n                      \"Tail entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_seqnum,\n                      le64toh(f->header->tail_entry_seqnum));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_monotonic_set &&\n            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&\n             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_monotonic,\n                      le64toh(f->header->tail_entry_monotonic));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_realtime,\n                      le64toh(f->header->tail_entry_realtime));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (fflush(data_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_array_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* Second iteration: we follow all objects referenced from the\n         * two entry points: the object hash table and the entry\n         * array. We also check that everything referenced (directly\n         * or indirectly) in the data hash table also exists in the\n         * entry array, and vice versa. Note that we do not care for\n         * unreferenced objects. We only care that everything that is\n         * referenced is consistent. */\n\n        r = verify_entry_array(f,\n                               cache_data_fd, n_data,\n                               cache_entry_fd, n_entries,\n                               cache_entry_array_fd, n_entry_arrays,\n                               &last_usec,\n                               show_progress);\n        if (r < 0)\n                goto fail;\n\n        r = verify_data_hash_table(f,\n                                   cache_data_fd, n_data,\n                                   cache_entry_fd, n_entries,\n                                   cache_entry_array_fd, n_entry_arrays,\n                                   &last_usec,\n                                   show_progress);\n        if (r < 0)\n                goto fail;\n\n        if (show_progress)\n                flush_progress();\n\n        mmap_cache_fd_free(cache_data_fd);\n        mmap_cache_fd_free(cache_entry_fd);\n        mmap_cache_fd_free(cache_entry_array_fd);\n\n        if (first_contained)\n                *first_contained = le64toh(f->header->head_entry_realtime);\n#if HAVE_GCRYPT\n        if (last_validated)\n                *last_validated = last_tag_realtime + f->fss_interval_usec;\n#endif\n        if (last_contained)\n                *last_contained = le64toh(f->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (show_progress)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"PRIu64\" (of %\"PRIu64\" bytes, %\"PRIu64\"%%).\",\n                  f->path,\n                  p,\n                  (uint64_t) f->last_stat.st_size,\n                  100U * p / (uint64_t) f->last_stat.st_size);\n\n        if (cache_data_fd)\n                mmap_cache_fd_free(cache_data_fd);\n\n        if (cache_entry_fd)\n                mmap_cache_fd_free(cache_entry_fd);\n\n        if (cache_entry_array_fd)\n                mmap_cache_fd_free(cache_entry_array_fd);\n\n        return r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n                 bool show_progress) {\n         int r;\n         Object *o;\n-        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n+        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0;\n \n         uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n         usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;\n@@ -114,6 +114,10 @@\n                         goto fail;\n                 }\n \n+        if (!JOURNAL_HEADER_SEALED_CONTINUOUS(f->header))\n+                warning(p,\n+                        \"This log file was sealed with an old journald version where the sequence of seals might not be continuous. We cannot guarantee completeness.\");\n+\n         /* First iteration: we go through all objects, verify the\n          * superficial structure, headers, hashes. */\n \n@@ -317,13 +321,25 @@\n                                 goto fail;\n                         }\n \n-                        if (le64toh(o->tag.epoch) < last_epoch) {\n-                                error(p,\n-                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n-                                      le64toh(o->tag.epoch),\n-                                      last_epoch);\n-                                r = -EBADMSG;\n-                                goto fail;\n+                        if (JOURNAL_HEADER_SEALED_CONTINUOUS(f->header)) {\n+                                if (!(n_tags == 0 || (n_tags == 1 && le64toh(o->tag.epoch) == last_epoch)\n+                                      || le64toh(o->tag.epoch) == last_epoch + 1)) {\n+                                        error(p,\n+                                              \"Epoch sequence not continuous (%\"PRIu64\" vs %\"PRIu64\")\",\n+                                              le64toh(o->tag.epoch),\n+                                              last_epoch);\n+                                        r = -EBADMSG;\n+                                        goto fail;\n+                                }\n+                        } else {\n+                                if (le64toh(o->tag.epoch) < last_epoch) {\n+                                        error(p,\n+                                              \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n+                                              le64toh(o->tag.epoch),\n+                                              last_epoch);\n+                                        r = -EBADMSG;\n+                                        goto fail;\n+                                }\n                         }\n \n #if HAVE_GCRYPT\n@@ -405,7 +421,6 @@\n \n                                 f->hmac_running = false;\n                                 last_tag_realtime = rt;\n-                                last_sealed_realtime = entry_realtime;\n                         }\n \n                         last_tag = p + ALIGN64(le64toh(o->object.size));\n@@ -578,8 +593,10 @@\n \n         if (first_contained)\n                 *first_contained = le64toh(f->header->head_entry_realtime);\n+#if HAVE_GCRYPT\n         if (last_validated)\n-                *last_validated = last_sealed_realtime;\n+                *last_validated = last_tag_realtime + f->fss_interval_usec;\n+#endif\n         if (last_contained)\n                 *last_contained = le64toh(f->header->tail_entry_realtime);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;",
                "                        if (le64toh(o->tag.epoch) < last_epoch) {",
                "                                error(p,",
                "                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",",
                "                                      le64toh(o->tag.epoch),",
                "                                      last_epoch);",
                "                                r = -EBADMSG;",
                "                                goto fail;",
                "                                last_sealed_realtime = entry_realtime;",
                "                *last_validated = last_sealed_realtime;"
            ],
            "added_lines": [
                "        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0;",
                "        if (!JOURNAL_HEADER_SEALED_CONTINUOUS(f->header))",
                "                warning(p,",
                "                        \"This log file was sealed with an old journald version where the sequence of seals might not be continuous. We cannot guarantee completeness.\");",
                "",
                "                        if (JOURNAL_HEADER_SEALED_CONTINUOUS(f->header)) {",
                "                                if (!(n_tags == 0 || (n_tags == 1 && le64toh(o->tag.epoch) == last_epoch)",
                "                                      || le64toh(o->tag.epoch) == last_epoch + 1)) {",
                "                                        error(p,",
                "                                              \"Epoch sequence not continuous (%\"PRIu64\" vs %\"PRIu64\")\",",
                "                                              le64toh(o->tag.epoch),",
                "                                              last_epoch);",
                "                                        r = -EBADMSG;",
                "                                        goto fail;",
                "                                }",
                "                        } else {",
                "                                if (le64toh(o->tag.epoch) < last_epoch) {",
                "                                        error(p,",
                "                                              \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",",
                "                                              le64toh(o->tag.epoch),",
                "                                              last_epoch);",
                "                                        r = -EBADMSG;",
                "                                        goto fail;",
                "                                }",
                "#if HAVE_GCRYPT",
                "                *last_validated = last_tag_realtime + f->fss_interval_usec;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/journal_file_rotate",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "int journal_file_rotate(\n                JournalFile **f,\n                MMapCache *mmap_cache,\n                JournalFileFlags file_flags,\n                uint64_t compress_threshold_bytes,\n                Set *deferred_closes) {\n\n        _cleanup_free_ char *path = NULL;\n        JournalFile *new_file = NULL;\n        int r;\n\n        assert(f);\n        assert(*f);\n\n        r = journal_file_archive(*f, &path);\n        if (r < 0)\n                return r;\n\n        set_clear_with_destructor(deferred_closes, journal_file_offline_close);\n\n        r = journal_file_open(\n                        /* fd= */ -1,\n                        path,\n                        (*f)->open_flags,\n                        file_flags,\n                        (*f)->mode,\n                        compress_threshold_bytes,\n                        /* metrics= */ NULL,\n                        mmap_cache,\n                        /* template= */ *f,\n                        &new_file);\n\n        journal_file_initiate_close(*f, deferred_closes);\n        *f = new_file;\n\n        return r;\n}",
        "func": "int journal_file_rotate(\n                JournalFile **f,\n                MMapCache *mmap_cache,\n                JournalFileFlags file_flags,\n                uint64_t compress_threshold_bytes,\n                Set *deferred_closes) {\n\n        _cleanup_free_ char *path = NULL;\n        JournalFile *new_file = NULL;\n        int r;\n\n        assert(f);\n        assert(*f);\n\n        journal_file_write_final_tag(*f);\n        r = journal_file_archive(*f, &path);\n        if (r < 0)\n                return r;\n\n        set_clear_with_destructor(deferred_closes, journal_file_offline_close);\n\n        r = journal_file_open(\n                        /* fd= */ -1,\n                        path,\n                        (*f)->open_flags,\n                        file_flags,\n                        (*f)->mode,\n                        compress_threshold_bytes,\n                        /* metrics= */ NULL,\n                        mmap_cache,\n                        /* template= */ *f,\n                        &new_file);\n\n        journal_file_initiate_close(*f, deferred_closes);\n        *f = new_file;\n\n        return r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n         assert(f);\n         assert(*f);\n \n+        journal_file_write_final_tag(*f);\n         r = journal_file_archive(*f, &path);\n         if (r < 0)\n                 return r;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        journal_file_write_final_tag(*f);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31438",
        "func_name": "systemd/journal_file_offline_close",
        "description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/8d7b0958cdb505047e5a66029468b8d12b8a7add",
        "commit_title": "journalctl: verify sealed log epochs are continuous",
        "commit_text": " Currently empty epochs are not sealed. This allows an attacker to truncate a sealed log and continue it without any problems showing when verifying the log.  This partially addresses CVE-2023-31438. One way to extend this change to address CVE-2023-31438 completely, would be to verify that there is exactly one seal per epoch (and not sealing when the epoch has not ended yet).  the change also adds a journal-file flag: HEADER_COMPATIBLE_SEALED_CONTINUOUS this flag indicates that a journal file is sealed continuously and decides whether any missing crypto epochs should trigger a warning or an error.",
        "func_before": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n#if HAVE_GCRYPT\n        /* Write the final tag */\n        if (JOURNAL_HEADER_SEALED(f->header) && journal_file_writable(f)) {\n                int r;\n\n                r = journal_file_append_tag(f);\n                if (r < 0)\n                        log_error_errno(r, \"Failed to append tag when closing journal: %m\");\n        }\n#endif\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "func": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n        journal_file_write_final_tag(f);\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,16 +2,7 @@\n         if (!f)\n                 return NULL;\n \n-#if HAVE_GCRYPT\n-        /* Write the final tag */\n-        if (JOURNAL_HEADER_SEALED(f->header) && journal_file_writable(f)) {\n-                int r;\n-\n-                r = journal_file_append_tag(f);\n-                if (r < 0)\n-                        log_error_errno(r, \"Failed to append tag when closing journal: %m\");\n-        }\n-#endif\n+        journal_file_write_final_tag(f);\n \n         if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                 journal_file_post_change(f);",
        "diff_line_info": {
            "deleted_lines": [
                "#if HAVE_GCRYPT",
                "        /* Write the final tag */",
                "        if (JOURNAL_HEADER_SEALED(f->header) && journal_file_writable(f)) {",
                "                int r;",
                "",
                "                r = journal_file_append_tag(f);",
                "                if (r < 0)",
                "                        log_error_errno(r, \"Failed to append tag when closing journal: %m\");",
                "        }",
                "#endif"
            ],
            "added_lines": [
                "        journal_file_write_final_tag(f);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31439",
        "func_name": "systemd/journal_file_verify",
        "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/540e35ef8ae259744ce18d272a232d56c2445279",
        "commit_title": "journalctl: verify that old entries are not sealed with too recent key",
        "commit_text": " When verifying seals produced with forward secure sealing, the verification currently does not check that old entries are only sealed with the key for their epoch and not a more recent one. This missing check allows an attacker to remove seals, and create new ones with the currently available key, and verify will claim everything is in order, although all entries could have been modified.  This resolves CVE-2023-31439.",
        "func_before": "int journal_file_verify(\n                JournalFile *f,\n                const char *key,\n                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,\n                bool show_progress) {\n        int r;\n        Object *o;\n        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n\n        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;\n        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n        usec_t last_usec = 0;\n        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;\n        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;\n        unsigned i;\n        bool found_last = false;\n        const char *tmp_dir = NULL;\n        MMapCache *m;\n\n#if HAVE_GCRYPT\n        uint64_t last_tag = 0;\n#endif\n        assert(f);\n\n        if (key) {\n#if HAVE_GCRYPT\n                r = journal_file_parse_verification_key(f, key);\n                if (r < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return r;\n                }\n#else\n                return -EOPNOTSUPP;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(f->header))\n                return -ENOKEY;\n\n        r = var_tmp_dir(&tmp_dir);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (data_fd < 0) {\n                r = log_error_errno(data_fd, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_fd < 0) {\n                r = log_error_errno(entry_fd, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_array_fd < 0) {\n                r = log_error_errno(entry_array_fd,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        m = mmap_cache_fd_cache(f->cache_fd);\n        cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);\n        if (!cache_data_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_array_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&data_fd, \"w+\", &data_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_fd, \"w+\", &entry_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_array_fd, \"w+\", &entry_array_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                r = -EOPNOTSUPP;\n                goto fail;\n        }\n\n        for (i = 0; i < sizeof(f->header->reserved); i++)\n                if (f->header->reserved[i] != 0) {\n                        error(offsetof(Header, reserved[i]), \"Reserved field is non-zero\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n        /* First iteration: we go through all objects, verify the\n         * superficial structure, headers, hashes. */\n\n        p = le64toh(f->header->header_size);\n        for (;;) {\n                /* Early exit if there are no objects in the file, at all */\n                if (le64toh(f->header->tail_object_offset) == 0)\n                        break;\n\n                if (show_progress)\n                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);\n\n                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (p > le64toh(f->header->tail_object_offset)) {\n                        error(offsetof(Header, tail_object_offset),\n                              \"Invalid tail object pointer (%\"PRIu64\" > %\"PRIu64\")\",\n                              p,\n                              le64toh(f->header->tail_object_offset));\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                n_objects++;\n\n                r = journal_file_object_verify(f, p, o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {\n                        error(p, \"Object has multiple compression flags set (flags: 0x%x)\", o->object.flags);\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {\n                        error(p, \"XZ compressed object in file without XZ compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {\n                        error(p, \"LZ4 compressed object in file without LZ4 compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {\n                        error(p, \"ZSTD compressed object in file without ZSTD compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                switch (o->object.type) {\n\n                case OBJECT_DATA:\n                        r = write_uint64(data_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        n_data++;\n                        break;\n\n                case OBJECT_FIELD:\n                        n_fields++;\n                        break;\n\n                case OBJECT_ENTRY:\n                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {\n                                error(p, \"First entry before first tag\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        r = write_uint64(entry_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (le64toh(o->entry.realtime) < last_tag_realtime) {\n                                error(p,\n                                      \"Older entry after newer tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      last_tag_realtime);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (!entry_seqnum_set &&\n                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {\n                                error(p,\n                                      \"Head entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.seqnum),\n                                      le64toh(f->header->head_entry_seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (entry_seqnum_set &&\n                            entry_seqnum >= le64toh(o->entry.seqnum)) {\n                                error(p,\n                                      \"Entry sequence number out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                      entry_seqnum,\n                                      le64toh(o->entry.seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_seqnum = le64toh(o->entry.seqnum);\n                        entry_seqnum_set = true;\n\n                        if (entry_monotonic_set &&\n                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&\n                            entry_monotonic > le64toh(o->entry.monotonic)) {\n                                error(p,\n                                      \"Entry timestamp out of synchronization (%\"PRIu64\" > %\"PRIu64\")\",\n                                      entry_monotonic,\n                                      le64toh(o->entry.monotonic));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_monotonic = le64toh(o->entry.monotonic);\n                        entry_boot_id = o->entry.boot_id;\n                        entry_monotonic_set = true;\n\n                        if (!entry_realtime_set &&\n                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {\n                                error(p,\n                                      \"Head entry realtime timestamp incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      le64toh(f->header->head_entry_realtime));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_realtime = le64toh(o->entry.realtime);\n                        entry_realtime_set = true;\n\n                        n_entries++;\n                        break;\n\n                case OBJECT_DATA_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_data_hash_tables,\n                                              le64toh(f->header->data_hash_table_offset),\n                                              le64toh(f->header->data_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n                        break;\n\n                case OBJECT_FIELD_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_field_hash_tables,\n                                              le64toh(f->header->field_hash_table_offset),\n                                              le64toh(f->header->field_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n\n                        break;\n\n                case OBJECT_ENTRY_ARRAY:\n                        r = write_uint64(entry_array_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (p == le64toh(f->header->entry_array_offset)) {\n                                if (found_main_entry_array) {\n                                        error(p, \"More than one main entry array\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                found_main_entry_array = true;\n                        }\n\n                        n_entry_arrays++;\n                        break;\n\n                case OBJECT_TAG:\n                        if (!JOURNAL_HEADER_SEALED(f->header)) {\n                                error(p, \"Tag object in file without sealing\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.seqnum) != n_tags + 1) {\n                                error(p,\n                                      \"Tag sequence number out of synchronization (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->tag.seqnum),\n                                      n_tags + 1);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.epoch) < last_epoch) {\n                                error(p,\n                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->tag.epoch),\n                                      last_epoch);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n#if HAVE_GCRYPT\n                        if (JOURNAL_HEADER_SEALED(f->header)) {\n                                uint64_t q, rt;\n\n                                debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n\n                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {\n                                        error(p,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                /* OK, now we know the epoch. So let's now set\n                                 * it, and calculate the HMAC for everything\n                                 * since the last tag. */\n                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));\n                                if (r < 0)\n                                        goto fail;\n\n                                r = journal_file_hmac_start(f);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (last_tag == 0) {\n                                        r = journal_file_hmac_put_header(f);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = le64toh(f->header->header_size);\n                                } else\n                                        q = last_tag;\n\n                                while (q <= p) {\n                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = q + ALIGN64(le64toh(o->object.size));\n                                }\n\n                                /* Position might have changed, let's reposition things */\n                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {\n                                        error(p, \"Tag failed verification\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                f->hmac_running = false;\n                                last_tag_realtime = rt;\n                                last_sealed_realtime = entry_realtime;\n                        }\n\n                        last_tag = p + ALIGN64(le64toh(o->object.size));\n#endif\n\n                        last_epoch = le64toh(o->tag.epoch);\n\n                        n_tags++;\n                        break;\n                }\n\n                if (p == le64toh(f->header->tail_object_offset)) {\n                        found_last = true;\n                        break;\n                }\n\n                p = p + ALIGN64(le64toh(o->object.size));\n        };\n\n        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {\n                error(le64toh(f->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"PRIu64\" != 0)\",\n                      le64toh(f->header->tail_object_offset));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_objects != le64toh(f->header->n_objects)) {\n                error(offsetof(Header, n_objects),\n                      \"Object number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_objects,\n                      le64toh(f->header->n_objects));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_entries != le64toh(f->header->n_entries)) {\n                error(offsetof(Header, n_entries),\n                      \"Entry number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entries,\n                      le64toh(f->header->n_entries));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&\n            n_data != le64toh(f->header->n_data)) {\n                error(offsetof(Header, n_data),\n                      \"Data number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_data,\n                      le64toh(f->header->n_data));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&\n            n_fields != le64toh(f->header->n_fields)) {\n                error(offsetof(Header, n_fields),\n                      \"Field number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_fields,\n                      le64toh(f->header->n_fields));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&\n            n_tags != le64toh(f->header->n_tags)) {\n                error(offsetof(Header, n_tags),\n                      \"Tag number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_tags,\n                      le64toh(f->header->n_tags));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&\n            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {\n                error(offsetof(Header, n_entry_arrays),\n                      \"Entry array number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entry_arrays,\n                      le64toh(f->header->n_entry_arrays));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_seqnum_set &&\n            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {\n                error(offsetof(Header, tail_entry_seqnum),\n                      \"Tail entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_seqnum,\n                      le64toh(f->header->tail_entry_seqnum));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_monotonic_set &&\n            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&\n             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_monotonic,\n                      le64toh(f->header->tail_entry_monotonic));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_realtime,\n                      le64toh(f->header->tail_entry_realtime));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (fflush(data_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_array_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* Second iteration: we follow all objects referenced from the\n         * two entry points: the object hash table and the entry\n         * array. We also check that everything referenced (directly\n         * or indirectly) in the data hash table also exists in the\n         * entry array, and vice versa. Note that we do not care for\n         * unreferenced objects. We only care that everything that is\n         * referenced is consistent. */\n\n        r = verify_entry_array(f,\n                               cache_data_fd, n_data,\n                               cache_entry_fd, n_entries,\n                               cache_entry_array_fd, n_entry_arrays,\n                               &last_usec,\n                               show_progress);\n        if (r < 0)\n                goto fail;\n\n        r = verify_data_hash_table(f,\n                                   cache_data_fd, n_data,\n                                   cache_entry_fd, n_entries,\n                                   cache_entry_array_fd, n_entry_arrays,\n                                   &last_usec,\n                                   show_progress);\n        if (r < 0)\n                goto fail;\n\n        if (show_progress)\n                flush_progress();\n\n        mmap_cache_fd_free(cache_data_fd);\n        mmap_cache_fd_free(cache_entry_fd);\n        mmap_cache_fd_free(cache_entry_array_fd);\n\n        if (first_contained)\n                *first_contained = le64toh(f->header->head_entry_realtime);\n        if (last_validated)\n                *last_validated = last_sealed_realtime;\n        if (last_contained)\n                *last_contained = le64toh(f->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (show_progress)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"PRIu64\" (of %\"PRIu64\" bytes, %\"PRIu64\"%%).\",\n                  f->path,\n                  p,\n                  (uint64_t) f->last_stat.st_size,\n                  100U * p / (uint64_t) f->last_stat.st_size);\n\n        if (cache_data_fd)\n                mmap_cache_fd_free(cache_data_fd);\n\n        if (cache_entry_fd)\n                mmap_cache_fd_free(cache_entry_fd);\n\n        if (cache_entry_array_fd)\n                mmap_cache_fd_free(cache_entry_array_fd);\n\n        return r;\n}",
        "func": "int journal_file_verify(\n                JournalFile *f,\n                const char *key,\n                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,\n                bool show_progress) {\n        int r;\n        Object *o;\n        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n\n        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;\n        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;\n        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n        usec_t last_usec = 0;\n        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;\n        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;\n        unsigned i;\n        bool found_last = false;\n        const char *tmp_dir = NULL;\n        MMapCache *m;\n\n#if HAVE_GCRYPT\n        uint64_t last_tag = 0;\n#endif\n        assert(f);\n\n        if (key) {\n#if HAVE_GCRYPT\n                r = journal_file_parse_verification_key(f, key);\n                if (r < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return r;\n                }\n#else\n                return -EOPNOTSUPP;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(f->header))\n                return -ENOKEY;\n\n        r = var_tmp_dir(&tmp_dir);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (data_fd < 0) {\n                r = log_error_errno(data_fd, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_fd < 0) {\n                r = log_error_errno(entry_fd, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_array_fd < 0) {\n                r = log_error_errno(entry_array_fd,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        m = mmap_cache_fd_cache(f->cache_fd);\n        cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);\n        if (!cache_data_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_array_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&data_fd, \"w+\", &data_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_fd, \"w+\", &entry_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_array_fd, \"w+\", &entry_array_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                r = -EOPNOTSUPP;\n                goto fail;\n        }\n\n        for (i = 0; i < sizeof(f->header->reserved); i++)\n                if (f->header->reserved[i] != 0) {\n                        error(offsetof(Header, reserved[i]), \"Reserved field is non-zero\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n        /* First iteration: we go through all objects, verify the\n         * superficial structure, headers, hashes. */\n\n        p = le64toh(f->header->header_size);\n        for (;;) {\n                /* Early exit if there are no objects in the file, at all */\n                if (le64toh(f->header->tail_object_offset) == 0)\n                        break;\n\n                if (show_progress)\n                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);\n\n                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (p > le64toh(f->header->tail_object_offset)) {\n                        error(offsetof(Header, tail_object_offset),\n                              \"Invalid tail object pointer (%\"PRIu64\" > %\"PRIu64\")\",\n                              p,\n                              le64toh(f->header->tail_object_offset));\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                n_objects++;\n\n                r = journal_file_object_verify(f, p, o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {\n                        error(p, \"Object has multiple compression flags set (flags: 0x%x)\", o->object.flags);\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {\n                        error(p, \"XZ compressed object in file without XZ compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {\n                        error(p, \"LZ4 compressed object in file without LZ4 compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {\n                        error(p, \"ZSTD compressed object in file without ZSTD compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                switch (o->object.type) {\n\n                case OBJECT_DATA:\n                        r = write_uint64(data_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        n_data++;\n                        break;\n\n                case OBJECT_FIELD:\n                        n_fields++;\n                        break;\n\n                case OBJECT_ENTRY:\n                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {\n                                error(p, \"First entry before first tag\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        r = write_uint64(entry_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (le64toh(o->entry.realtime) < last_tag_realtime) {\n                                error(p,\n                                      \"Older entry after newer tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      last_tag_realtime);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (!entry_seqnum_set &&\n                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {\n                                error(p,\n                                      \"Head entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.seqnum),\n                                      le64toh(f->header->head_entry_seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (entry_seqnum_set &&\n                            entry_seqnum >= le64toh(o->entry.seqnum)) {\n                                error(p,\n                                      \"Entry sequence number out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                      entry_seqnum,\n                                      le64toh(o->entry.seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_seqnum = le64toh(o->entry.seqnum);\n                        entry_seqnum_set = true;\n\n                        if (entry_monotonic_set &&\n                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&\n                            entry_monotonic > le64toh(o->entry.monotonic)) {\n                                error(p,\n                                      \"Entry timestamp out of synchronization (%\"PRIu64\" > %\"PRIu64\")\",\n                                      entry_monotonic,\n                                      le64toh(o->entry.monotonic));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_monotonic = le64toh(o->entry.monotonic);\n                        entry_boot_id = o->entry.boot_id;\n                        entry_monotonic_set = true;\n\n                        if (!entry_realtime_set &&\n                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {\n                                error(p,\n                                      \"Head entry realtime timestamp incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      le64toh(f->header->head_entry_realtime));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_realtime = le64toh(o->entry.realtime);\n                        entry_realtime_set = true;\n\n                        if (max_entry_realtime < le64toh(o->entry.realtime))\n                                max_entry_realtime = le64toh(o->entry.realtime);\n                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {\n                                min_entry_realtime = le64toh(o->entry.realtime);\n                                min_entry_realtime_set = true;\n                        }\n\n                        n_entries++;\n                        break;\n\n                case OBJECT_DATA_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_data_hash_tables,\n                                              le64toh(f->header->data_hash_table_offset),\n                                              le64toh(f->header->data_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n                        break;\n\n                case OBJECT_FIELD_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_field_hash_tables,\n                                              le64toh(f->header->field_hash_table_offset),\n                                              le64toh(f->header->field_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n\n                        break;\n\n                case OBJECT_ENTRY_ARRAY:\n                        r = write_uint64(entry_array_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (p == le64toh(f->header->entry_array_offset)) {\n                                if (found_main_entry_array) {\n                                        error(p, \"More than one main entry array\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                found_main_entry_array = true;\n                        }\n\n                        n_entry_arrays++;\n                        break;\n\n                case OBJECT_TAG:\n                        if (!JOURNAL_HEADER_SEALED(f->header)) {\n                                error(p, \"Tag object in file without sealing\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.seqnum) != n_tags + 1) {\n                                error(p,\n                                      \"Tag sequence number out of synchronization (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->tag.seqnum),\n                                      n_tags + 1);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.epoch) < last_epoch) {\n                                error(p,\n                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->tag.epoch),\n                                      last_epoch);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n#if HAVE_GCRYPT\n                        if (JOURNAL_HEADER_SEALED(f->header)) {\n                                uint64_t q, rt;\n\n                                debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n\n                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {\n                                        error(p,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (max_entry_realtime >= rt + f->fss_interval_usec) {\n                                        error(p,\n                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                              max_entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (min_entry_realtime_set && min_entry_realtime < rt) {\n                                        error(p,\n                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              min_entry_realtime,\n                                              rt);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                min_entry_realtime_set = false;\n\n                                /* OK, now we know the epoch. So let's now set\n                                 * it, and calculate the HMAC for everything\n                                 * since the last tag. */\n                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));\n                                if (r < 0)\n                                        goto fail;\n\n                                r = journal_file_hmac_start(f);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (last_tag == 0) {\n                                        r = journal_file_hmac_put_header(f);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = le64toh(f->header->header_size);\n                                } else\n                                        q = last_tag;\n\n                                while (q <= p) {\n                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = q + ALIGN64(le64toh(o->object.size));\n                                }\n\n                                /* Position might have changed, let's reposition things */\n                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {\n                                        error(p, \"Tag failed verification\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                f->hmac_running = false;\n                                last_tag_realtime = rt;\n                                last_sealed_realtime = entry_realtime;\n                        }\n\n                        last_tag = p + ALIGN64(le64toh(o->object.size));\n#endif\n\n                        last_epoch = le64toh(o->tag.epoch);\n\n                        n_tags++;\n                        break;\n                }\n\n                if (p == le64toh(f->header->tail_object_offset)) {\n                        found_last = true;\n                        break;\n                }\n\n                p = p + ALIGN64(le64toh(o->object.size));\n        };\n\n        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {\n                error(le64toh(f->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"PRIu64\" != 0)\",\n                      le64toh(f->header->tail_object_offset));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_objects != le64toh(f->header->n_objects)) {\n                error(offsetof(Header, n_objects),\n                      \"Object number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_objects,\n                      le64toh(f->header->n_objects));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_entries != le64toh(f->header->n_entries)) {\n                error(offsetof(Header, n_entries),\n                      \"Entry number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entries,\n                      le64toh(f->header->n_entries));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&\n            n_data != le64toh(f->header->n_data)) {\n                error(offsetof(Header, n_data),\n                      \"Data number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_data,\n                      le64toh(f->header->n_data));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&\n            n_fields != le64toh(f->header->n_fields)) {\n                error(offsetof(Header, n_fields),\n                      \"Field number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_fields,\n                      le64toh(f->header->n_fields));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&\n            n_tags != le64toh(f->header->n_tags)) {\n                error(offsetof(Header, n_tags),\n                      \"Tag number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_tags,\n                      le64toh(f->header->n_tags));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&\n            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {\n                error(offsetof(Header, n_entry_arrays),\n                      \"Entry array number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entry_arrays,\n                      le64toh(f->header->n_entry_arrays));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_seqnum_set &&\n            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {\n                error(offsetof(Header, tail_entry_seqnum),\n                      \"Tail entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_seqnum,\n                      le64toh(f->header->tail_entry_seqnum));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_monotonic_set &&\n            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&\n             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_monotonic,\n                      le64toh(f->header->tail_entry_monotonic));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_realtime,\n                      le64toh(f->header->tail_entry_realtime));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (fflush(data_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_array_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* Second iteration: we follow all objects referenced from the\n         * two entry points: the object hash table and the entry\n         * array. We also check that everything referenced (directly\n         * or indirectly) in the data hash table also exists in the\n         * entry array, and vice versa. Note that we do not care for\n         * unreferenced objects. We only care that everything that is\n         * referenced is consistent. */\n\n        r = verify_entry_array(f,\n                               cache_data_fd, n_data,\n                               cache_entry_fd, n_entries,\n                               cache_entry_array_fd, n_entry_arrays,\n                               &last_usec,\n                               show_progress);\n        if (r < 0)\n                goto fail;\n\n        r = verify_data_hash_table(f,\n                                   cache_data_fd, n_data,\n                                   cache_entry_fd, n_entries,\n                                   cache_entry_array_fd, n_entry_arrays,\n                                   &last_usec,\n                                   show_progress);\n        if (r < 0)\n                goto fail;\n\n        if (show_progress)\n                flush_progress();\n\n        mmap_cache_fd_free(cache_data_fd);\n        mmap_cache_fd_free(cache_entry_fd);\n        mmap_cache_fd_free(cache_entry_array_fd);\n\n        if (first_contained)\n                *first_contained = le64toh(f->header->head_entry_realtime);\n        if (last_validated)\n                *last_validated = last_sealed_realtime;\n        if (last_contained)\n                *last_contained = le64toh(f->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (show_progress)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"PRIu64\" (of %\"PRIu64\" bytes, %\"PRIu64\"%%).\",\n                  f->path,\n                  p,\n                  (uint64_t) f->last_stat.st_size,\n                  100U * p / (uint64_t) f->last_stat.st_size);\n\n        if (cache_data_fd)\n                mmap_cache_fd_free(cache_data_fd);\n\n        if (cache_entry_fd)\n                mmap_cache_fd_free(cache_entry_fd);\n\n        if (cache_entry_array_fd)\n                mmap_cache_fd_free(cache_entry_array_fd);\n\n        return r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,9 @@\n         Object *o;\n         uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n \n-        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n+        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;\n         sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n-        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;\n+        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;\n         uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n         usec_t last_usec = 0;\n         _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n@@ -259,6 +259,13 @@\n                         entry_realtime = le64toh(o->entry.realtime);\n                         entry_realtime_set = true;\n \n+                        if (max_entry_realtime < le64toh(o->entry.realtime))\n+                                max_entry_realtime = le64toh(o->entry.realtime);\n+                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {\n+                                min_entry_realtime = le64toh(o->entry.realtime);\n+                                min_entry_realtime_set = true;\n+                        }\n+\n                         n_entries++;\n                         break;\n \n@@ -337,6 +344,23 @@\n                                         r = -EBADMSG;\n                                         goto fail;\n                                 }\n+                                if (max_entry_realtime >= rt + f->fss_interval_usec) {\n+                                        error(p,\n+                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",\n+                                              max_entry_realtime,\n+                                              rt + f->fss_interval_usec);\n+                                        r = -EBADMSG;\n+                                        goto fail;\n+                                }\n+                                if (min_entry_realtime_set && min_entry_realtime < rt) {\n+                                        error(p,\n+                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n+                                              min_entry_realtime,\n+                                              rt);\n+                                        r = -EBADMSG;\n+                                        goto fail;\n+                                }\n+                                min_entry_realtime_set = false;\n \n                                 /* OK, now we know the epoch. So let's now set\n                                  * it, and calculate the HMAC for everything",
        "diff_line_info": {
            "deleted_lines": [
                "        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;",
                "        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;"
            ],
            "added_lines": [
                "        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;",
                "        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;",
                "                        if (max_entry_realtime < le64toh(o->entry.realtime))",
                "                                max_entry_realtime = le64toh(o->entry.realtime);",
                "                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {",
                "                                min_entry_realtime = le64toh(o->entry.realtime);",
                "                                min_entry_realtime_set = true;",
                "                        }",
                "",
                "                                if (max_entry_realtime >= rt + f->fss_interval_usec) {",
                "                                        error(p,",
                "                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",",
                "                                              max_entry_realtime,",
                "                                              rt + f->fss_interval_usec);",
                "                                        r = -EBADMSG;",
                "                                        goto fail;",
                "                                }",
                "                                if (min_entry_realtime_set && min_entry_realtime < rt) {",
                "                                        error(p,",
                "                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",",
                "                                              min_entry_realtime,",
                "                                              rt);",
                "                                        r = -EBADMSG;",
                "                                        goto fail;",
                "                                }",
                "                                min_entry_realtime_set = false;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31439",
        "func_name": "systemd/journal_file_verify",
        "description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
        "git_url": "https://github.com/systemd/systemd/commit/3c896258067991832a1e896093b748aebfc873e1",
        "commit_title": "journalctl: address review comments",
        "commit_text": "",
        "func_before": "int journal_file_verify(\n                JournalFile *f,\n                const char *key,\n                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,\n                bool show_progress) {\n        int r;\n        Object *o;\n        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n\n        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;\n        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;\n        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n        usec_t last_usec = 0;\n        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;\n        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;\n        unsigned i;\n        bool found_last = false;\n        const char *tmp_dir = NULL;\n        MMapCache *m;\n\n#if HAVE_GCRYPT\n        uint64_t last_tag = 0;\n#endif\n        assert(f);\n\n        if (key) {\n#if HAVE_GCRYPT\n                r = journal_file_parse_verification_key(f, key);\n                if (r < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return r;\n                }\n#else\n                return -EOPNOTSUPP;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(f->header))\n                return -ENOKEY;\n\n        r = var_tmp_dir(&tmp_dir);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (data_fd < 0) {\n                r = log_error_errno(data_fd, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_fd < 0) {\n                r = log_error_errno(entry_fd, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_array_fd < 0) {\n                r = log_error_errno(entry_array_fd,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        m = mmap_cache_fd_cache(f->cache_fd);\n        cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);\n        if (!cache_data_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_array_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&data_fd, \"w+\", &data_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_fd, \"w+\", &entry_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_array_fd, \"w+\", &entry_array_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                r = -EOPNOTSUPP;\n                goto fail;\n        }\n\n        for (i = 0; i < sizeof(f->header->reserved); i++)\n                if (f->header->reserved[i] != 0) {\n                        error(offsetof(Header, reserved[i]), \"Reserved field is non-zero\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n        /* First iteration: we go through all objects, verify the\n         * superficial structure, headers, hashes. */\n\n        p = le64toh(f->header->header_size);\n        for (;;) {\n                /* Early exit if there are no objects in the file, at all */\n                if (le64toh(f->header->tail_object_offset) == 0)\n                        break;\n\n                if (show_progress)\n                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);\n\n                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (p > le64toh(f->header->tail_object_offset)) {\n                        error(offsetof(Header, tail_object_offset),\n                              \"Invalid tail object pointer (%\"PRIu64\" > %\"PRIu64\")\",\n                              p,\n                              le64toh(f->header->tail_object_offset));\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                n_objects++;\n\n                r = journal_file_object_verify(f, p, o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {\n                        error(p, \"Object has multiple compression flags set (flags: 0x%x)\", o->object.flags);\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {\n                        error(p, \"XZ compressed object in file without XZ compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {\n                        error(p, \"LZ4 compressed object in file without LZ4 compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {\n                        error(p, \"ZSTD compressed object in file without ZSTD compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                switch (o->object.type) {\n\n                case OBJECT_DATA:\n                        r = write_uint64(data_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        n_data++;\n                        break;\n\n                case OBJECT_FIELD:\n                        n_fields++;\n                        break;\n\n                case OBJECT_ENTRY:\n                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {\n                                error(p, \"First entry before first tag\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        r = write_uint64(entry_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (le64toh(o->entry.realtime) < last_tag_realtime) {\n                                error(p,\n                                      \"Older entry after newer tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      last_tag_realtime);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (!entry_seqnum_set &&\n                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {\n                                error(p,\n                                      \"Head entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.seqnum),\n                                      le64toh(f->header->head_entry_seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (entry_seqnum_set &&\n                            entry_seqnum >= le64toh(o->entry.seqnum)) {\n                                error(p,\n                                      \"Entry sequence number out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                      entry_seqnum,\n                                      le64toh(o->entry.seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_seqnum = le64toh(o->entry.seqnum);\n                        entry_seqnum_set = true;\n\n                        if (entry_monotonic_set &&\n                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&\n                            entry_monotonic > le64toh(o->entry.monotonic)) {\n                                error(p,\n                                      \"Entry timestamp out of synchronization (%\"PRIu64\" > %\"PRIu64\")\",\n                                      entry_monotonic,\n                                      le64toh(o->entry.monotonic));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_monotonic = le64toh(o->entry.monotonic);\n                        entry_boot_id = o->entry.boot_id;\n                        entry_monotonic_set = true;\n\n                        if (!entry_realtime_set &&\n                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {\n                                error(p,\n                                      \"Head entry realtime timestamp incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      le64toh(f->header->head_entry_realtime));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_realtime = le64toh(o->entry.realtime);\n                        entry_realtime_set = true;\n\n                        if (max_entry_realtime < le64toh(o->entry.realtime))\n                                max_entry_realtime = le64toh(o->entry.realtime);\n                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {\n                                min_entry_realtime = le64toh(o->entry.realtime);\n                                min_entry_realtime_set = true;\n                        }\n\n                        n_entries++;\n                        break;\n\n                case OBJECT_DATA_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_data_hash_tables,\n                                              le64toh(f->header->data_hash_table_offset),\n                                              le64toh(f->header->data_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n                        break;\n\n                case OBJECT_FIELD_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_field_hash_tables,\n                                              le64toh(f->header->field_hash_table_offset),\n                                              le64toh(f->header->field_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n\n                        break;\n\n                case OBJECT_ENTRY_ARRAY:\n                        r = write_uint64(entry_array_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (p == le64toh(f->header->entry_array_offset)) {\n                                if (found_main_entry_array) {\n                                        error(p, \"More than one main entry array\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                found_main_entry_array = true;\n                        }\n\n                        n_entry_arrays++;\n                        break;\n\n                case OBJECT_TAG:\n                        if (!JOURNAL_HEADER_SEALED(f->header)) {\n                                error(p, \"Tag object in file without sealing\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.seqnum) != n_tags + 1) {\n                                error(p,\n                                      \"Tag sequence number out of synchronization (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->tag.seqnum),\n                                      n_tags + 1);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.epoch) < last_epoch) {\n                                error(p,\n                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->tag.epoch),\n                                      last_epoch);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n#if HAVE_GCRYPT\n                        if (JOURNAL_HEADER_SEALED(f->header)) {\n                                uint64_t q, rt;\n\n                                debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n\n                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {\n                                        error(p,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (max_entry_realtime >= rt + f->fss_interval_usec) {\n                                        error(p,\n                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                              max_entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (min_entry_realtime_set && min_entry_realtime < rt) {\n                                        error(p,\n                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              min_entry_realtime,\n                                              rt);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                min_entry_realtime_set = false;\n\n                                /* OK, now we know the epoch. So let's now set\n                                 * it, and calculate the HMAC for everything\n                                 * since the last tag. */\n                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));\n                                if (r < 0)\n                                        goto fail;\n\n                                r = journal_file_hmac_start(f);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (last_tag == 0) {\n                                        r = journal_file_hmac_put_header(f);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = le64toh(f->header->header_size);\n                                } else\n                                        q = last_tag;\n\n                                while (q <= p) {\n                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = q + ALIGN64(le64toh(o->object.size));\n                                }\n\n                                /* Position might have changed, let's reposition things */\n                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {\n                                        error(p, \"Tag failed verification\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                f->hmac_running = false;\n                                last_tag_realtime = rt;\n                                last_sealed_realtime = entry_realtime;\n                        }\n\n                        last_tag = p + ALIGN64(le64toh(o->object.size));\n#endif\n\n                        last_epoch = le64toh(o->tag.epoch);\n\n                        n_tags++;\n                        break;\n                }\n\n                if (p == le64toh(f->header->tail_object_offset)) {\n                        found_last = true;\n                        break;\n                }\n\n                p = p + ALIGN64(le64toh(o->object.size));\n        };\n\n        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {\n                error(le64toh(f->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"PRIu64\" != 0)\",\n                      le64toh(f->header->tail_object_offset));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_objects != le64toh(f->header->n_objects)) {\n                error(offsetof(Header, n_objects),\n                      \"Object number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_objects,\n                      le64toh(f->header->n_objects));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_entries != le64toh(f->header->n_entries)) {\n                error(offsetof(Header, n_entries),\n                      \"Entry number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entries,\n                      le64toh(f->header->n_entries));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&\n            n_data != le64toh(f->header->n_data)) {\n                error(offsetof(Header, n_data),\n                      \"Data number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_data,\n                      le64toh(f->header->n_data));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&\n            n_fields != le64toh(f->header->n_fields)) {\n                error(offsetof(Header, n_fields),\n                      \"Field number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_fields,\n                      le64toh(f->header->n_fields));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&\n            n_tags != le64toh(f->header->n_tags)) {\n                error(offsetof(Header, n_tags),\n                      \"Tag number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_tags,\n                      le64toh(f->header->n_tags));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&\n            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {\n                error(offsetof(Header, n_entry_arrays),\n                      \"Entry array number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entry_arrays,\n                      le64toh(f->header->n_entry_arrays));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_seqnum_set &&\n            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {\n                error(offsetof(Header, tail_entry_seqnum),\n                      \"Tail entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_seqnum,\n                      le64toh(f->header->tail_entry_seqnum));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_monotonic_set &&\n            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&\n             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_monotonic,\n                      le64toh(f->header->tail_entry_monotonic));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_realtime,\n                      le64toh(f->header->tail_entry_realtime));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (fflush(data_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_array_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* Second iteration: we follow all objects referenced from the\n         * two entry points: the object hash table and the entry\n         * array. We also check that everything referenced (directly\n         * or indirectly) in the data hash table also exists in the\n         * entry array, and vice versa. Note that we do not care for\n         * unreferenced objects. We only care that everything that is\n         * referenced is consistent. */\n\n        r = verify_entry_array(f,\n                               cache_data_fd, n_data,\n                               cache_entry_fd, n_entries,\n                               cache_entry_array_fd, n_entry_arrays,\n                               &last_usec,\n                               show_progress);\n        if (r < 0)\n                goto fail;\n\n        r = verify_data_hash_table(f,\n                                   cache_data_fd, n_data,\n                                   cache_entry_fd, n_entries,\n                                   cache_entry_array_fd, n_entry_arrays,\n                                   &last_usec,\n                                   show_progress);\n        if (r < 0)\n                goto fail;\n\n        if (show_progress)\n                flush_progress();\n\n        mmap_cache_fd_free(cache_data_fd);\n        mmap_cache_fd_free(cache_entry_fd);\n        mmap_cache_fd_free(cache_entry_array_fd);\n\n        if (first_contained)\n                *first_contained = le64toh(f->header->head_entry_realtime);\n        if (last_validated)\n                *last_validated = last_sealed_realtime;\n        if (last_contained)\n                *last_contained = le64toh(f->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (show_progress)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"PRIu64\" (of %\"PRIu64\" bytes, %\"PRIu64\"%%).\",\n                  f->path,\n                  p,\n                  (uint64_t) f->last_stat.st_size,\n                  100U * p / (uint64_t) f->last_stat.st_size);\n\n        if (cache_data_fd)\n                mmap_cache_fd_free(cache_data_fd);\n\n        if (cache_entry_fd)\n                mmap_cache_fd_free(cache_entry_fd);\n\n        if (cache_entry_array_fd)\n                mmap_cache_fd_free(cache_entry_array_fd);\n\n        return r;\n}",
        "func": "int journal_file_verify(\n                JournalFile *f,\n                const char *key,\n                usec_t *first_contained, usec_t *last_validated, usec_t *last_contained,\n                bool show_progress) {\n        int r;\n        Object *o;\n        uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n\n        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;\n        sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;\n        uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n        usec_t last_usec = 0;\n        _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n        _cleanup_fclose_ FILE *data_fp = NULL, *entry_fp = NULL, *entry_array_fp = NULL;\n        MMapFileDescriptor *cache_data_fd = NULL, *cache_entry_fd = NULL, *cache_entry_array_fd = NULL;\n        unsigned i;\n        bool found_last = false;\n        const char *tmp_dir = NULL;\n        MMapCache *m;\n\n#if HAVE_GCRYPT\n        uint64_t last_tag = 0;\n#endif\n        assert(f);\n\n        if (key) {\n#if HAVE_GCRYPT\n                r = journal_file_parse_verification_key(f, key);\n                if (r < 0) {\n                        log_error(\"Failed to parse seed.\");\n                        return r;\n                }\n#else\n                return -EOPNOTSUPP;\n#endif\n        } else if (JOURNAL_HEADER_SEALED(f->header))\n                return -ENOKEY;\n\n        r = var_tmp_dir(&tmp_dir);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to determine temporary directory: %m\");\n                goto fail;\n        }\n\n        data_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (data_fd < 0) {\n                r = log_error_errno(data_fd, \"Failed to create data file: %m\");\n                goto fail;\n        }\n\n        entry_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_fd < 0) {\n                r = log_error_errno(entry_fd, \"Failed to create entry file: %m\");\n                goto fail;\n        }\n\n        entry_array_fd = open_tmpfile_unlinkable(tmp_dir, O_RDWR | O_CLOEXEC);\n        if (entry_array_fd < 0) {\n                r = log_error_errno(entry_array_fd,\n                                    \"Failed to create entry array file: %m\");\n                goto fail;\n        }\n\n        m = mmap_cache_fd_cache(f->cache_fd);\n        cache_data_fd = mmap_cache_add_fd(m, data_fd, PROT_READ|PROT_WRITE);\n        if (!cache_data_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_fd = mmap_cache_add_fd(m, entry_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        cache_entry_array_fd = mmap_cache_add_fd(m, entry_array_fd, PROT_READ|PROT_WRITE);\n        if (!cache_entry_array_fd) {\n                r = log_oom();\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&data_fd, \"w+\", &data_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open data file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_fd, \"w+\", &entry_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry file stream: %m\");\n                goto fail;\n        }\n\n        r = take_fdopen_unlocked(&entry_array_fd, \"w+\", &entry_array_fp);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to open entry array file stream: %m\");\n                goto fail;\n        }\n\n        if (le32toh(f->header->compatible_flags) & ~HEADER_COMPATIBLE_SUPPORTED) {\n                log_error(\"Cannot verify file with unknown extensions.\");\n                r = -EOPNOTSUPP;\n                goto fail;\n        }\n\n        for (i = 0; i < sizeof(f->header->reserved); i++)\n                if (f->header->reserved[i] != 0) {\n                        error(offsetof(Header, reserved[i]), \"Reserved field is non-zero\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n        /* First iteration: we go through all objects, verify the\n         * superficial structure, headers, hashes. */\n\n        p = le64toh(f->header->header_size);\n        for (;;) {\n                /* Early exit if there are no objects in the file, at all */\n                if (le64toh(f->header->tail_object_offset) == 0)\n                        break;\n\n                if (show_progress)\n                        draw_progress(scale_progress(0x7FFF, p, le64toh(f->header->tail_object_offset)), &last_usec);\n\n                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object: %m\");\n                        goto fail;\n                }\n\n                if (p > le64toh(f->header->tail_object_offset)) {\n                        error(offsetof(Header, tail_object_offset),\n                              \"Invalid tail object pointer (%\"PRIu64\" > %\"PRIu64\")\",\n                              p,\n                              le64toh(f->header->tail_object_offset));\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                n_objects++;\n\n                r = journal_file_object_verify(f, p, o);\n                if (r < 0) {\n                        error_errno(p, r, \"Invalid object contents: %m\");\n                        goto fail;\n                }\n\n                if (!!(o->object.flags & OBJECT_COMPRESSED_XZ) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_LZ4) +\n                    !!(o->object.flags & OBJECT_COMPRESSED_ZSTD) > 1) {\n                        error(p, \"Object has multiple compression flags set (flags: 0x%x)\", o->object.flags);\n                        r = -EINVAL;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_XZ) && !JOURNAL_HEADER_COMPRESSED_XZ(f->header)) {\n                        error(p, \"XZ compressed object in file without XZ compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_LZ4) && !JOURNAL_HEADER_COMPRESSED_LZ4(f->header)) {\n                        error(p, \"LZ4 compressed object in file without LZ4 compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                if ((o->object.flags & OBJECT_COMPRESSED_ZSTD) && !JOURNAL_HEADER_COMPRESSED_ZSTD(f->header)) {\n                        error(p, \"ZSTD compressed object in file without ZSTD compression\");\n                        r = -EBADMSG;\n                        goto fail;\n                }\n\n                switch (o->object.type) {\n\n                case OBJECT_DATA:\n                        r = write_uint64(data_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        n_data++;\n                        break;\n\n                case OBJECT_FIELD:\n                        n_fields++;\n                        break;\n\n                case OBJECT_ENTRY:\n                        if (JOURNAL_HEADER_SEALED(f->header) && n_tags <= 0) {\n                                error(p, \"First entry before first tag\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        r = write_uint64(entry_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (le64toh(o->entry.realtime) < last_tag_realtime) {\n                                error(p,\n                                      \"Older entry after newer tag (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      last_tag_realtime);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (!entry_seqnum_set &&\n                            le64toh(o->entry.seqnum) != le64toh(f->header->head_entry_seqnum)) {\n                                error(p,\n                                      \"Head entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.seqnum),\n                                      le64toh(f->header->head_entry_seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (entry_seqnum_set &&\n                            entry_seqnum >= le64toh(o->entry.seqnum)) {\n                                error(p,\n                                      \"Entry sequence number out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                      entry_seqnum,\n                                      le64toh(o->entry.seqnum));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_seqnum = le64toh(o->entry.seqnum);\n                        entry_seqnum_set = true;\n\n                        if (entry_monotonic_set &&\n                            sd_id128_equal(entry_boot_id, o->entry.boot_id) &&\n                            entry_monotonic > le64toh(o->entry.monotonic)) {\n                                error(p,\n                                      \"Entry timestamp out of synchronization (%\"PRIu64\" > %\"PRIu64\")\",\n                                      entry_monotonic,\n                                      le64toh(o->entry.monotonic));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_monotonic = le64toh(o->entry.monotonic);\n                        entry_boot_id = o->entry.boot_id;\n                        entry_monotonic_set = true;\n\n                        if (!entry_realtime_set &&\n                            le64toh(o->entry.realtime) != le64toh(f->header->head_entry_realtime)) {\n                                error(p,\n                                      \"Head entry realtime timestamp incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->entry.realtime),\n                                      le64toh(f->header->head_entry_realtime));\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        entry_realtime = le64toh(o->entry.realtime);\n                        entry_realtime_set = true;\n\n                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));\n                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));\n\n                        n_entries++;\n                        break;\n\n                case OBJECT_DATA_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_data_hash_tables,\n                                              le64toh(f->header->data_hash_table_offset),\n                                              le64toh(f->header->data_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n                        break;\n\n                case OBJECT_FIELD_HASH_TABLE:\n                        r = verify_hash_table(o, p, &n_field_hash_tables,\n                                              le64toh(f->header->field_hash_table_offset),\n                                              le64toh(f->header->field_hash_table_size));\n                        if (r < 0)\n                                goto fail;\n\n                        break;\n\n                case OBJECT_ENTRY_ARRAY:\n                        r = write_uint64(entry_array_fp, p);\n                        if (r < 0)\n                                goto fail;\n\n                        if (p == le64toh(f->header->entry_array_offset)) {\n                                if (found_main_entry_array) {\n                                        error(p, \"More than one main entry array\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                found_main_entry_array = true;\n                        }\n\n                        n_entry_arrays++;\n                        break;\n\n                case OBJECT_TAG:\n                        if (!JOURNAL_HEADER_SEALED(f->header)) {\n                                error(p, \"Tag object in file without sealing\");\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.seqnum) != n_tags + 1) {\n                                error(p,\n                                      \"Tag sequence number out of synchronization (%\"PRIu64\" != %\"PRIu64\")\",\n                                      le64toh(o->tag.seqnum),\n                                      n_tags + 1);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n                        if (le64toh(o->tag.epoch) < last_epoch) {\n                                error(p,\n                                      \"Epoch sequence out of synchronization (%\"PRIu64\" < %\"PRIu64\")\",\n                                      le64toh(o->tag.epoch),\n                                      last_epoch);\n                                r = -EBADMSG;\n                                goto fail;\n                        }\n\n#if HAVE_GCRYPT\n                        if (JOURNAL_HEADER_SEALED(f->header)) {\n                                uint64_t q, rt, rt_end;\n\n                                debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n\n                                rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n                                rt_end = usec_add(rt, f->fss_interval_usec);\n                                if (entry_realtime_set && entry_realtime >= rt_end) {\n                                        error(p,\n                                              \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                              entry_realtime,\n                                              rt + f->fss_interval_usec);\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (max_entry_realtime >= rt_end) {\n                                        error(p,\n                                              \"Entry realtime (%\"PRIu64\", %s) is too late with respect to tag (%\"PRIu64\", %s)\",\n                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),\n                                              rt_end, FORMAT_TIMESTAMP(rt_end));\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                if (min_entry_realtime < rt) {\n                                        error(p,\n                                              \"Entry realtime (%\"PRIu64\", %s) is too early with respect to tag (%\"PRIu64\", %s)\",\n                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),\n                                              rt, FORMAT_TIMESTAMP(rt));\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n                                min_entry_realtime = USEC_INFINITY;\n\n                                /* OK, now we know the epoch. So let's now set\n                                 * it, and calculate the HMAC for everything\n                                 * since the last tag. */\n                                r = journal_file_fsprg_seek(f, le64toh(o->tag.epoch));\n                                if (r < 0)\n                                        goto fail;\n\n                                r = journal_file_hmac_start(f);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (last_tag == 0) {\n                                        r = journal_file_hmac_put_header(f);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = le64toh(f->header->header_size);\n                                } else\n                                        q = last_tag;\n\n                                while (q <= p) {\n                                        r = journal_file_move_to_object(f, OBJECT_UNUSED, q, &o);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        r = journal_file_hmac_put_object(f, OBJECT_UNUSED, o, q);\n                                        if (r < 0)\n                                                goto fail;\n\n                                        q = q + ALIGN64(le64toh(o->object.size));\n                                }\n\n                                /* Position might have changed, let's reposition things */\n                                r = journal_file_move_to_object(f, OBJECT_UNUSED, p, &o);\n                                if (r < 0)\n                                        goto fail;\n\n                                if (memcmp(o->tag.tag, gcry_md_read(f->hmac, 0), TAG_LENGTH) != 0) {\n                                        error(p, \"Tag failed verification\");\n                                        r = -EBADMSG;\n                                        goto fail;\n                                }\n\n                                f->hmac_running = false;\n                                last_tag_realtime = rt;\n                                last_sealed_realtime = entry_realtime;\n                        }\n\n                        last_tag = p + ALIGN64(le64toh(o->object.size));\n#endif\n\n                        last_epoch = le64toh(o->tag.epoch);\n\n                        n_tags++;\n                        break;\n                }\n\n                if (p == le64toh(f->header->tail_object_offset)) {\n                        found_last = true;\n                        break;\n                }\n\n                p = p + ALIGN64(le64toh(o->object.size));\n        };\n\n        if (!found_last && le64toh(f->header->tail_object_offset) != 0) {\n                error(le64toh(f->header->tail_object_offset),\n                      \"Tail object pointer dead (%\"PRIu64\" != 0)\",\n                      le64toh(f->header->tail_object_offset));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_objects != le64toh(f->header->n_objects)) {\n                error(offsetof(Header, n_objects),\n                      \"Object number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_objects,\n                      le64toh(f->header->n_objects));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (n_entries != le64toh(f->header->n_entries)) {\n                error(offsetof(Header, n_entries),\n                      \"Entry number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entries,\n                      le64toh(f->header->n_entries));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_data) &&\n            n_data != le64toh(f->header->n_data)) {\n                error(offsetof(Header, n_data),\n                      \"Data number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_data,\n                      le64toh(f->header->n_data));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_fields) &&\n            n_fields != le64toh(f->header->n_fields)) {\n                error(offsetof(Header, n_fields),\n                      \"Field number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_fields,\n                      le64toh(f->header->n_fields));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_tags) &&\n            n_tags != le64toh(f->header->n_tags)) {\n                error(offsetof(Header, n_tags),\n                      \"Tag number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_tags,\n                      le64toh(f->header->n_tags));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (JOURNAL_HEADER_CONTAINS(f->header, n_entry_arrays) &&\n            n_entry_arrays != le64toh(f->header->n_entry_arrays)) {\n                error(offsetof(Header, n_entry_arrays),\n                      \"Entry array number mismatch (%\"PRIu64\" != %\"PRIu64\")\",\n                      n_entry_arrays,\n                      le64toh(f->header->n_entry_arrays));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (!found_main_entry_array && le64toh(f->header->entry_array_offset) != 0) {\n                error(0, \"Missing main entry array\");\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_seqnum_set &&\n            entry_seqnum != le64toh(f->header->tail_entry_seqnum)) {\n                error(offsetof(Header, tail_entry_seqnum),\n                      \"Tail entry sequence number incorrect (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_seqnum,\n                      le64toh(f->header->tail_entry_seqnum));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_monotonic_set &&\n            (sd_id128_equal(entry_boot_id, f->header->tail_entry_boot_id) &&\n             JOURNAL_HEADER_TAIL_ENTRY_BOOT_ID(f->header) &&\n             entry_monotonic != le64toh(f->header->tail_entry_monotonic))) {\n                error(0,\n                      \"Invalid tail monotonic timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_monotonic,\n                      le64toh(f->header->tail_entry_monotonic));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (entry_realtime_set && entry_realtime != le64toh(f->header->tail_entry_realtime)) {\n                error(0,\n                      \"Invalid tail realtime timestamp (%\"PRIu64\" != %\"PRIu64\")\",\n                      entry_realtime,\n                      le64toh(f->header->tail_entry_realtime));\n                r = -EBADMSG;\n                goto fail;\n        }\n\n        if (fflush(data_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush data file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry file stream: %m\");\n                goto fail;\n        }\n\n        if (fflush(entry_array_fp) != 0) {\n                r = log_error_errno(errno, \"Failed to flush entry array file stream: %m\");\n                goto fail;\n        }\n\n        /* Second iteration: we follow all objects referenced from the\n         * two entry points: the object hash table and the entry\n         * array. We also check that everything referenced (directly\n         * or indirectly) in the data hash table also exists in the\n         * entry array, and vice versa. Note that we do not care for\n         * unreferenced objects. We only care that everything that is\n         * referenced is consistent. */\n\n        r = verify_entry_array(f,\n                               cache_data_fd, n_data,\n                               cache_entry_fd, n_entries,\n                               cache_entry_array_fd, n_entry_arrays,\n                               &last_usec,\n                               show_progress);\n        if (r < 0)\n                goto fail;\n\n        r = verify_data_hash_table(f,\n                                   cache_data_fd, n_data,\n                                   cache_entry_fd, n_entries,\n                                   cache_entry_array_fd, n_entry_arrays,\n                                   &last_usec,\n                                   show_progress);\n        if (r < 0)\n                goto fail;\n\n        if (show_progress)\n                flush_progress();\n\n        mmap_cache_fd_free(cache_data_fd);\n        mmap_cache_fd_free(cache_entry_fd);\n        mmap_cache_fd_free(cache_entry_array_fd);\n\n        if (first_contained)\n                *first_contained = le64toh(f->header->head_entry_realtime);\n        if (last_validated)\n                *last_validated = last_sealed_realtime;\n        if (last_contained)\n                *last_contained = le64toh(f->header->tail_entry_realtime);\n\n        return 0;\n\nfail:\n        if (show_progress)\n                flush_progress();\n\n        log_error(\"File corruption detected at %s:%\"PRIu64\" (of %\"PRIu64\" bytes, %\"PRIu64\"%%).\",\n                  f->path,\n                  p,\n                  (uint64_t) f->last_stat.st_size,\n                  100U * p / (uint64_t) f->last_stat.st_size);\n\n        if (cache_data_fd)\n                mmap_cache_fd_free(cache_data_fd);\n\n        if (cache_entry_fd)\n                mmap_cache_fd_free(cache_entry_fd);\n\n        if (cache_entry_array_fd)\n                mmap_cache_fd_free(cache_entry_array_fd);\n\n        return r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,10 @@\n         Object *o;\n         uint64_t p = 0, last_epoch = 0, last_tag_realtime = 0, last_sealed_realtime = 0;\n \n-        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;\n+        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;\n+        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;\n         sd_id128_t entry_boot_id = {};  /* Unnecessary initialization to appease gcc */\n-        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;\n+        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;\n         uint64_t n_objects = 0, n_entries = 0, n_data = 0, n_fields = 0, n_data_hash_tables = 0, n_field_hash_tables = 0, n_entry_arrays = 0, n_tags = 0;\n         usec_t last_usec = 0;\n         _cleanup_close_ int data_fd = -EBADF, entry_fd = -EBADF, entry_array_fd = -EBADF;\n@@ -259,12 +260,8 @@\n                         entry_realtime = le64toh(o->entry.realtime);\n                         entry_realtime_set = true;\n \n-                        if (max_entry_realtime < le64toh(o->entry.realtime))\n-                                max_entry_realtime = le64toh(o->entry.realtime);\n-                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {\n-                                min_entry_realtime = le64toh(o->entry.realtime);\n-                                min_entry_realtime_set = true;\n-                        }\n+                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));\n+                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));\n \n                         n_entries++;\n                         break;\n@@ -331,12 +328,13 @@\n \n #if HAVE_GCRYPT\n                         if (JOURNAL_HEADER_SEALED(f->header)) {\n-                                uint64_t q, rt;\n+                                uint64_t q, rt, rt_end;\n \n                                 debug(p, \"Checking tag %\"PRIu64\"...\", le64toh(o->tag.seqnum));\n \n                                 rt = f->fss_start_usec + le64toh(o->tag.epoch) * f->fss_interval_usec;\n-                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {\n+                                rt_end = usec_add(rt, f->fss_interval_usec);\n+                                if (entry_realtime_set && entry_realtime >= rt_end) {\n                                         error(p,\n                                               \"tag/entry realtime timestamp out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n                                               entry_realtime,\n@@ -344,23 +342,23 @@\n                                         r = -EBADMSG;\n                                         goto fail;\n                                 }\n-                                if (max_entry_realtime >= rt + f->fss_interval_usec) {\n+                                if (max_entry_realtime >= rt_end) {\n                                         error(p,\n-                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",\n-                                              max_entry_realtime,\n-                                              rt + f->fss_interval_usec);\n+                                              \"Entry realtime (%\"PRIu64\", %s) is too late with respect to tag (%\"PRIu64\", %s)\",\n+                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),\n+                                              rt_end, FORMAT_TIMESTAMP(rt_end));\n                                         r = -EBADMSG;\n                                         goto fail;\n                                 }\n-                                if (min_entry_realtime_set && min_entry_realtime < rt) {\n+                                if (min_entry_realtime < rt) {\n                                         error(p,\n-                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",\n-                                              min_entry_realtime,\n-                                              rt);\n+                                              \"Entry realtime (%\"PRIu64\", %s) is too early with respect to tag (%\"PRIu64\", %s)\",\n+                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),\n+                                              rt, FORMAT_TIMESTAMP(rt));\n                                         r = -EBADMSG;\n                                         goto fail;\n                                 }\n-                                min_entry_realtime_set = false;\n+                                min_entry_realtime = USEC_INFINITY;\n \n                                 /* OK, now we know the epoch. So let's now set\n                                  * it, and calculate the HMAC for everything",
        "diff_line_info": {
            "deleted_lines": [
                "        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0, min_entry_realtime = 0, max_entry_realtime = 0;",
                "        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, min_entry_realtime_set = false, found_main_entry_array = false;",
                "                        if (max_entry_realtime < le64toh(o->entry.realtime))",
                "                                max_entry_realtime = le64toh(o->entry.realtime);",
                "                        if (!min_entry_realtime_set || min_entry_realtime > le64toh(o->entry.realtime)) {",
                "                                min_entry_realtime = le64toh(o->entry.realtime);",
                "                                min_entry_realtime_set = true;",
                "                        }",
                "                                uint64_t q, rt;",
                "                                if (entry_realtime_set && entry_realtime >= rt + f->fss_interval_usec) {",
                "                                if (max_entry_realtime >= rt + f->fss_interval_usec) {",
                "                                              \"entry realtime timestamp too late with respect to tag (%\"PRIu64\" < %\"PRIu64\")\",",
                "                                              max_entry_realtime,",
                "                                              rt + f->fss_interval_usec);",
                "                                if (min_entry_realtime_set && min_entry_realtime < rt) {",
                "                                              \"entry realtime timestamp too early with respect to tag out of synchronization (%\"PRIu64\" >= %\"PRIu64\")\",",
                "                                              min_entry_realtime,",
                "                                              rt);",
                "                                min_entry_realtime_set = false;"
            ],
            "added_lines": [
                "        uint64_t entry_seqnum = 0, entry_monotonic = 0, entry_realtime = 0;",
                "        usec_t min_entry_realtime = USEC_INFINITY, max_entry_realtime = 0;",
                "        bool entry_seqnum_set = false, entry_monotonic_set = false, entry_realtime_set = false, found_main_entry_array = false;",
                "                        max_entry_realtime = MAX(max_entry_realtime, le64toh(o->entry.realtime));",
                "                        min_entry_realtime = MIN(min_entry_realtime, le64toh(o->entry.realtime));",
                "                                uint64_t q, rt, rt_end;",
                "                                rt_end = usec_add(rt, f->fss_interval_usec);",
                "                                if (entry_realtime_set && entry_realtime >= rt_end) {",
                "                                if (max_entry_realtime >= rt_end) {",
                "                                              \"Entry realtime (%\"PRIu64\", %s) is too late with respect to tag (%\"PRIu64\", %s)\",",
                "                                              max_entry_realtime, FORMAT_TIMESTAMP(max_entry_realtime),",
                "                                              rt_end, FORMAT_TIMESTAMP(rt_end));",
                "                                if (min_entry_realtime < rt) {",
                "                                              \"Entry realtime (%\"PRIu64\", %s) is too early with respect to tag (%\"PRIu64\", %s)\",",
                "                                              min_entry_realtime, FORMAT_TIMESTAMP(min_entry_realtime),",
                "                                              rt, FORMAT_TIMESTAMP(rt));",
                "                                min_entry_realtime = USEC_INFINITY;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18672",
        "func_name": "keepkey/keepkey-firmware/recovery_cipher_finalize",
        "description": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.",
        "git_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
        "commit_title": "firmware: stronger recovery state machine checks",
        "commit_text": "",
        "func_before": "void recovery_cipher_finalize(void)\n{\n    static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";\n    static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];\n    volatile bool auto_completed = true;\n\n    /* Attempt to autocomplete each word */\n    char *tok = strtok(mnemonic, \" \");\n\n    while(tok) {\n        strlcpy(temp_word, tok, CURRENT_WORD_BUF);\n\n        auto_completed &= attempt_auto_complete(temp_word);\n\n        strlcat(new_mnemonic, temp_word, MNEMONIC_BUF);\n        strlcat(new_mnemonic, \" \", MNEMONIC_BUF);\n\n        tok = strtok(NULL, \" \");\n    }\n    memzero(temp_word, sizeof(temp_word));\n\n    if (!auto_completed && !enforce_wordlist) {\n        if (!dry_run) {\n            storage_reset();\n        }\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        awaiting_character = false;\n        layoutHome();\n        return;\n    }\n\n    /* Truncate additional space at the end */\n    new_mnemonic[strlen(new_mnemonic) - 1] = '\\0';\n\n    if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {\n        storage_setMnemonic(new_mnemonic);\n        memzero(new_mnemonic, sizeof(new_mnemonic));\n        if (!enforce_wordlist) {\n            // not enforcing => mark storage as imported\n            storage_setImported(true);\n        }\n        storage_commit();\n        fsm_sendSuccess(\"Device recovered\");\n    } else if (dry_run) {\n        bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic);\n        if (match) {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is valid and MATCHES the one in the device.\");\n            fsm_sendSuccess(\"The seed is valid and matches the one in the device.\");\n        } else if (mnemonic_check(new_mnemonic)) {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is valid, but DOES NOT MATCH the one in the device.\");\n            fsm_sendFailure(FailureType_Failure_Other,\n                            \"The seed is valid, but does not match the one in the device.\");\n        } else {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is INVALID, and DOES NOT MATCH the one in the device.\");\n            fsm_sendFailure(FailureType_Failure_Other,\n                            \"The seed is invalid, and does not match the one in the device.\");\n        }\n        memzero(new_mnemonic, sizeof(new_mnemonic));\n    } else {\n        session_clear(true);\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Invalid mnemonic, are words in correct order?\");\n        recovery_abort();\n    }\n\n    memzero(new_mnemonic, sizeof(new_mnemonic));\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n    layoutHome();\n}",
        "func": "void recovery_cipher_finalize(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";\n    static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];\n    volatile bool auto_completed = true;\n\n    /* Attempt to autocomplete each word */\n    char *tok = strtok(mnemonic, \" \");\n\n    while(tok) {\n        strlcpy(temp_word, tok, CURRENT_WORD_BUF);\n\n        auto_completed &= attempt_auto_complete(temp_word);\n\n        strlcat(new_mnemonic, temp_word, MNEMONIC_BUF);\n        strlcat(new_mnemonic, \" \", MNEMONIC_BUF);\n\n        tok = strtok(NULL, \" \");\n    }\n    memzero(temp_word, sizeof(temp_word));\n\n    if (!auto_completed && !enforce_wordlist) {\n        if (!dry_run) {\n            storage_reset();\n        }\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        awaiting_character = false;\n        layoutHome();\n        return;\n    }\n\n    /* Truncate additional space at the end */\n    new_mnemonic[MAX(0u, strnlen(new_mnemonic, sizeof(new_mnemonic)) - 1)] = '\\0';\n\n    if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {\n        storage_setMnemonic(new_mnemonic);\n        memzero(new_mnemonic, sizeof(new_mnemonic));\n        if (!enforce_wordlist) {\n            // not enforcing => mark storage as imported\n            storage_setImported(true);\n        }\n        storage_commit();\n        fsm_sendSuccess(\"Device recovered\");\n    } else if (dry_run) {\n        bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic);\n        if (match) {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is valid and MATCHES the one in the device.\");\n            fsm_sendSuccess(\"The seed is valid and matches the one in the device.\");\n        } else if (mnemonic_check(new_mnemonic)) {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is valid, but DOES NOT MATCH the one in the device.\");\n            fsm_sendFailure(FailureType_Failure_Other,\n                            \"The seed is valid, but does not match the one in the device.\");\n        } else {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is INVALID, and DOES NOT MATCH the one in the device.\");\n            fsm_sendFailure(FailureType_Failure_Other,\n                            \"The seed is invalid, and does not match the one in the device.\");\n        }\n        memzero(new_mnemonic, sizeof(new_mnemonic));\n    } else {\n        session_clear(true);\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Invalid mnemonic, are words in correct order?\");\n        recovery_abort();\n    }\n\n    memzero(new_mnemonic, sizeof(new_mnemonic));\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n    layoutHome();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,12 @@\n void recovery_cipher_finalize(void)\n {\n+    if (!recovery_started) {\n+        recovery_abort();\n+        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n+        layoutHome();\n+        return;\n+    }\n+\n     static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";\n     static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];\n     volatile bool auto_completed = true;\n@@ -31,7 +38,7 @@\n     }\n \n     /* Truncate additional space at the end */\n-    new_mnemonic[strlen(new_mnemonic) - 1] = '\\0';\n+    new_mnemonic[MAX(0u, strnlen(new_mnemonic, sizeof(new_mnemonic)) - 1)] = '\\0';\n \n     if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {\n         storage_setMnemonic(new_mnemonic);",
        "diff_line_info": {
            "deleted_lines": [
                "    new_mnemonic[strlen(new_mnemonic) - 1] = '\\0';"
            ],
            "added_lines": [
                "    if (!recovery_started) {",
                "        recovery_abort();",
                "        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
                "        layoutHome();",
                "        return;",
                "    }",
                "",
                "    new_mnemonic[MAX(0u, strnlen(new_mnemonic, sizeof(new_mnemonic)) - 1)] = '\\0';"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18672",
        "func_name": "keepkey/keepkey-firmware/recovery_cipher_init",
        "description": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.",
        "git_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
        "commit_title": "firmware: stronger recovery state machine checks",
        "commit_text": "",
        "func_before": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n\n    /* Clear mnemonic */\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n\n    /* Set to recovery cipher mode and generate and show next cipher */\n    awaiting_character = true;\n    next_character();\n}",
        "func": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n\n    /* Clear mnemonic */\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n\n    /* Set to recovery cipher mode and generate and show next cipher */\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,5 +43,6 @@\n \n     /* Set to recovery cipher mode and generate and show next cipher */\n     awaiting_character = true;\n+    recovery_started = true;\n     next_character();\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    recovery_started = true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18672",
        "func_name": "keepkey/keepkey-firmware/next_character",
        "description": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.",
        "git_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
        "commit_title": "firmware: stronger recovery state machine checks",
        "commit_text": "",
        "func_before": "void next_character(void)\n{\n    /* Scramble cipher */\n    strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n    random_permute_char(cipher, strlen(cipher));\n\n    static char CONFIDENTIAL current_word[CURRENT_WORD_BUF];\n    get_current_word(current_word);\n\n    /* Words should never be longer than 4 characters */\n    if (strlen(current_word) > 4) {\n        memzero(current_word, sizeof(current_word));\n\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        layoutHome();\n        return;\n    }\n\n    CharacterRequest resp;\n    memset(&resp, 0, sizeof(CharacterRequest));\n\n    resp.word_pos = get_current_word_pos();\n    resp.character_pos = strlen(current_word);\n\n    msg_write(MessageType_MessageType_CharacterRequest, &resp);\n\n    /* Attempt to auto complete if we have at least 3 characters */\n    bool auto_completed = false;\n    if (strlen(current_word) >= 3) {\n        auto_completed = attempt_auto_complete(current_word);\n    }\n\n#if DEBUG_LINK\n    if (auto_completed) {\n        strlcpy(auto_completed_word, current_word, CURRENT_WORD_BUF);\n    } else {\n        auto_completed_word[0] = '\\0';\n    }\n#endif\n\n    /* Format current word and display it along with cipher */\n    format_current_word(current_word, auto_completed);\n\n    /* Show cipher and partial word */\n    layout_cipher(current_word, cipher);\n    memzero(current_word, sizeof(current_word));\n}",
        "func": "void next_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    /* Scramble cipher */\n    strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n    random_permute_char(cipher, strlen(cipher));\n\n    static char CONFIDENTIAL current_word[CURRENT_WORD_BUF];\n    get_current_word(current_word);\n\n    /* Words should never be longer than 4 characters */\n    if (strlen(current_word) > 4) {\n        memzero(current_word, sizeof(current_word));\n\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        layoutHome();\n        return;\n    }\n\n    CharacterRequest resp;\n    memset(&resp, 0, sizeof(CharacterRequest));\n\n    resp.word_pos = get_current_word_pos();\n    resp.character_pos = strlen(current_word);\n\n    msg_write(MessageType_MessageType_CharacterRequest, &resp);\n\n    /* Attempt to auto complete if we have at least 3 characters */\n    bool auto_completed = false;\n    if (strlen(current_word) >= 3) {\n        auto_completed = attempt_auto_complete(current_word);\n    }\n\n#if DEBUG_LINK\n    if (auto_completed) {\n        strlcpy(auto_completed_word, current_word, CURRENT_WORD_BUF);\n    } else {\n        auto_completed_word[0] = '\\0';\n    }\n#endif\n\n    /* Format current word and display it along with cipher */\n    format_current_word(current_word, auto_completed);\n\n    /* Show cipher and partial word */\n    layout_cipher(current_word, cipher);\n    memzero(current_word, sizeof(current_word));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,12 @@\n void next_character(void)\n {\n+    if (!recovery_started) {\n+        recovery_abort();\n+        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n+        layoutHome();\n+        return;\n+    }\n+\n     /* Scramble cipher */\n     strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n     random_permute_char(cipher, strlen(cipher));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!recovery_started) {",
                "        recovery_abort();",
                "        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
                "        layoutHome();",
                "        return;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18672",
        "func_name": "keepkey/keepkey-firmware/recovery_cipher_abort",
        "description": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.",
        "git_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
        "commit_title": "firmware: stronger recovery state machine checks",
        "commit_text": "",
        "func_before": "bool recovery_cipher_abort(void)\n{\n    if (awaiting_character) {\n        awaiting_character = false;\n        return true;\n    }\n    return false;\n}",
        "func": "bool recovery_cipher_abort(void)\n{\n    recovery_started = false;\n\n    if (awaiting_character) {\n        awaiting_character = false;\n        return true;\n    }\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n bool recovery_cipher_abort(void)\n {\n+    recovery_started = false;\n+\n     if (awaiting_character) {\n         awaiting_character = false;\n         return true;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    recovery_started = false;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18672",
        "func_name": "keepkey/keepkey-firmware/recovery_character",
        "description": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.",
        "git_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
        "commit_title": "firmware: stronger recovery state machine checks",
        "commit_text": "",
        "func_before": "void recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n\n    char *pos = strchr(cipher, character[0]);\n\n    // If not a space and not a legitmate cipher character, send failure.\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n\n    // Count of words we think the user has entered without using the cipher:\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        // Decode character using cipher if not space\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            // Check & bail if the user is entering their seed without using the\n            // cipher. Note that for each word, this can give false positives about\n            // ~0.4% of the time (2048/26^4).\n\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                // Decrease the overall false positive rate by detecting that a\n                // user has entered a word which is definitely using the\n                // cipher.\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    // concat to mnemonic\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n\n    next_character();\n}",
        "func": "void recovery_character(const char *character)\n{\n    if (!awaiting_character || !recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n\n    char *pos = strchr(cipher, character[0]);\n\n    // If not a space and not a legitmate cipher character, send failure.\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n\n    // Count of words we think the user has entered without using the cipher:\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        // Decode character using cipher if not space\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            // Check & bail if the user is entering their seed without using the\n            // cipher. Note that for each word, this can give false positives about\n            // ~0.4% of the time (2048/26^4).\n\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                // Decrease the overall false positive rate by detecting that a\n                // user has entered a word which is definitely using the\n                // cipher.\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    // concat to mnemonic\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n\n    next_character();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n void recovery_character(const char *character)\n {\n-    if (!awaiting_character) {\n+    if (!awaiting_character || !recovery_started) {\n         recovery_abort();\n         fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n         layoutHome();",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!awaiting_character) {"
            ],
            "added_lines": [
                "    if (!awaiting_character || !recovery_started) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18672",
        "func_name": "keepkey/keepkey-firmware/recovery_abort",
        "description": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.",
        "git_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
        "commit_title": "firmware: stronger recovery state machine checks",
        "commit_text": "",
        "func_before": "static void recovery_abort(void) {\n    if (!dry_run) {\n        storage_reset();\n    }\n\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n}",
        "func": "static void recovery_abort(void) {\n    if (!dry_run) {\n        storage_reset();\n    }\n\n    recovery_started = false;\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n         storage_reset();\n     }\n \n+    recovery_started = false;\n     awaiting_character = false;\n     memzero(mnemonic, sizeof(mnemonic));\n     memzero(cipher, sizeof(cipher));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    recovery_started = false;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18672",
        "func_name": "keepkey/keepkey-firmware/recovery_delete_character",
        "description": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.",
        "git_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680",
        "commit_title": "firmware: stronger recovery state machine checks",
        "commit_text": "",
        "func_before": "void recovery_delete_character(void)\n{\n    if(strlen(mnemonic) > 0)\n    {\n        mnemonic[strlen(mnemonic) - 1] = '\\0';\n    }\n\n    next_character();\n}",
        "func": "void recovery_delete_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if(strlen(mnemonic) > 0)\n    {\n        mnemonic[strlen(mnemonic) - 1] = '\\0';\n    }\n\n    next_character();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,12 @@\n void recovery_delete_character(void)\n {\n+    if (!recovery_started) {\n+        recovery_abort();\n+        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n+        layoutHome();\n+        return;\n+    }\n+\n     if(strlen(mnemonic) > 0)\n     {\n         mnemonic[strlen(mnemonic) - 1] = '\\0';",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!recovery_started) {",
                "        recovery_abort();",
                "        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");",
                "        layoutHome();",
                "        return;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "TeraTermProject/teraterm/SSH2_update_kex_myproposal",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/TeraTermProject/teraterm/commit/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0",
        "commit_title": "Strict KEX  (CVE-2023-48795)",
        "commit_text": "  Strict KEX ",
        "func_before": "void SSH2_update_kex_myproposal(PTInstVar pvar)\n{\n\tstatic char buf[512]; // TODO: malloc()\n\tint index;\n\tint i;\n\n\t// \n\tif (pvar->socket != INVALID_SOCKET) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\t//  pvar->settings  myproposal \n\t\t\t//   pvar->settings   myproposal \n\t\t\t//    myproposal \n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tbuf[0] = '\\0';\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\n\t\tindex = pvar->settings.KexOrder[i] - '0';\n\t\tif (index == KEX_DH_NONE) // disabled line\n\t\t\tbreak;\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\n\t}\n\n\t// RFC 8308 Extension Negotiation\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \n}",
        "func": "void SSH2_update_kex_myproposal(PTInstVar pvar)\n{\n\tstatic char buf[512]; // TODO: malloc()\n\tint index;\n\tint i;\n\n\t// \n\tif (pvar->socket != INVALID_SOCKET) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\t//  pvar->settings  myproposal \n\t\t\t//   pvar->settings   myproposal \n\t\t\t//    myproposal \n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c,kex-strict-c-v00@openssh.com\");\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c,kex-strict-c-v00@openssh.com\") == 0) {\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tbuf[0] = '\\0';\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\n\t\tindex = pvar->settings.KexOrder[i] - '0';\n\t\tif (index == KEX_DH_NONE) // disabled line\n\t\t\tbreak;\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\n\t}\n\n\t// Enables RFC 8308 Extension Negotiation & Strict KEX mode (for CVE-2023-48795)\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c,kex-strict-c-v00@openssh.com\", _TRUNCATE);\n\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,8 @@\n \t\t\t//  pvar->settings  myproposal \n \t\t\t//   pvar->settings   myproposal \n \t\t\t//    myproposal \n-\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");\n-\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {\n+\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c,kex-strict-c-v00@openssh.com\");\n+\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c,kex-strict-c-v00@openssh.com\") == 0) {\n \t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\n \t\t\t}\n \t\t}\n@@ -27,8 +27,8 @@\n \t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\n \t}\n \n-\t// RFC 8308 Extension Negotiation\n-\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);\n+\t// Enables RFC 8308 Extension Negotiation & Strict KEX mode (for CVE-2023-48795)\n+\tstrncat_s(buf, sizeof(buf), \"ext-info-c,kex-strict-c-v00@openssh.com\", _TRUNCATE);\n \n \tmyproposal[PROPOSAL_KEX_ALGS] = buf; \n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");",
                "\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {",
                "\t// RFC 8308 Extension Negotiation",
                "\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);"
            ],
            "added_lines": [
                "\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c,kex-strict-c-v00@openssh.com\");",
                "\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c,kex-strict-c-v00@openssh.com\") == 0) {",
                "\t// Enables RFC 8308 Extension Negotiation & Strict KEX mode (for CVE-2023-48795)",
                "\tstrncat_s(buf, sizeof(buf), \"ext-info-c,kex-strict-c-v00@openssh.com\", _TRUNCATE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "TeraTermProject/teraterm/ssh2_send_newkeys",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/TeraTermProject/teraterm/commit/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0",
        "commit_title": "Strict KEX  (CVE-2023-48795)",
        "commit_text": "  Strict KEX ",
        "func_before": "static void ssh2_send_newkeys(PTInstVar pvar)\n{\n\t// send SSH2_MSG_NEWKEYS\n\tbegin_send_packet(pvar, SSH2_MSG_NEWKEYS, 0);\n\tfinish_send_packet(pvar);\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_NEWKEYS was sent.\", __FUNCTION__);\n\n\t// SSH2_MSG_NEWKEYS \n\t// \n\tssh2_set_newkeys(pvar, MODE_OUT);\n\tif (!CRYPT_start_encryption(pvar, 1, 0)) {\n\t\t// TODO: error\n\t}\n\n\n\t// MAC\n\tpvar->ssh2_keys[MODE_OUT].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_OUT].comp.enabled = 1;\n\tenable_send_compression(pvar);\n\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\n\n\t// SSH2_MSG_NEWKEYS KEX\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\n\t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t}\n\t\telse {\n\t\t\t//  SSH2_MSG_NEWKEYS \n\t\t\tssh2_finish_encryption_setup(pvar);\n\n\t\t\t// \n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\n\treturn;\n}",
        "func": "static void ssh2_send_newkeys(PTInstVar pvar)\n{\n\t// send SSH2_MSG_NEWKEYS\n\tbegin_send_packet(pvar, SSH2_MSG_NEWKEYS, 0);\n\tfinish_send_packet(pvar);\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_NEWKEYS was sent.\", __FUNCTION__);\n\n\t// SSH2_MSG_NEWKEYS \n\t// \n\tssh2_set_newkeys(pvar, MODE_OUT);\n\tif (!CRYPT_start_encryption(pvar, 1, 0)) {\n\t\t// TODO: error\n\t}\n\n\n\t// MAC\n\tpvar->ssh2_keys[MODE_OUT].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_OUT].comp.enabled = 1;\n\tenable_send_compression(pvar);\n\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\n\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.sender_sequence_number = 0;\n\t}\n\n\t// SSH2_MSG_NEWKEYS KEX\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\n\t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t}\n\t\telse {\n\t\t\t//  SSH2_MSG_NEWKEYS \n\t\t\tssh2_finish_encryption_setup(pvar);\n\n\t\t\t// \n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,10 @@\n \n \tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\n \n+\tif (pvar->server_strict_kex) {\n+\t\tpvar->ssh_state.sender_sequence_number = 0;\n+\t}\n+\n \t// SSH2_MSG_NEWKEYS KEX\n \tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\n \t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (pvar->server_strict_kex) {",
                "\t\tpvar->ssh_state.sender_sequence_number = 0;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "TeraTermProject/teraterm/handle_SSH2_kexinit",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/TeraTermProject/teraterm/commit/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0",
        "commit_title": "Strict KEX  (CVE-2023-48795)",
        "commit_text": "  Strict KEX ",
        "func_before": "static BOOL handle_SSH2_kexinit(PTInstVar pvar)\n{\n\tchar buf[1024];\n\tchar *data;\n\tint len, size;\n\tchar *msg = NULL;\n\tchar tmp[1024+512];\n\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXINIT was received.\");\n\n\t//  SSH2_MSG_KEXINIT \n\t// (2004.10.24 yutaka)\n\tif (pvar->kex_status == KEX_FLAG_KEXDONE) {\n\t\tpvar->kex_status = KEX_FLAG_REKEYING;\n\n\t\t//  myproposal  \",ext-info-c\" \n\t\t//  KEX \n\t\tSSH2_update_kex_myproposal(pvar);\n\n\t\t// SSH2_MSG_KEXINIT \n\t\tSSH2_send_kexinit(pvar);\n\t}\n\n\tdata = remained_payload(pvar);\n\tlen = remained_payloadlen(pvar);\n\n\t// KEX  exchange-hash (session-id) \n\tif (pvar->peer_kex != NULL) {\n\t\t// already allocated\n\t\tbuffer_clear(pvar->peer_kex);\n\t}\n\telse {\n\t\tpvar->peer_kex = buffer_init();\n\t\tif (pvar->peer_kex == NULL) {\n\t\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\t\"%s: Out of memory\", __FUNCTION__);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tbuffer_append(pvar->peer_kex, data, len);\n\n\tpush_memdump(\"KEXINIT\", \"exchange algorithm list: receiving\", data, len);\n\n\t// cookie\n\tif (! get_bytearray_from_payload(pvar, buf, SSH2_COOKIE_LENGTH)) {\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (cookie)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\tCRYPT_set_server_cookie(pvar, buf);\n\n\t// (,)\n\t// \n\t// \n\t// \n\n\t// \n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (kex algorithms)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed kex algorithms is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: KEX algorithm: %s\", buf);\n\n\tpvar->kex_type = choose_SSH2_kex_algorithm(buf, myproposal[PROPOSAL_KEX_ALGS]);\n\tif (pvar->kex_type == KEX_DH_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown KEX algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// \n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (hostkey algorithms)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed hostkey algorithms is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: server host key algorithm: %s\", buf);\n\n\tpvar->hostkey_type = choose_SSH2_host_key_algorithm(buf, myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]);\n\tif (pvar->hostkey_type == KEY_ALGO_UNSPEC) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown host KEY algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// ( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm client to server: %s\", buf);\n\n\tpvar->ciphers[MODE_OUT] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_CTOS]);\n\tif (pvar->ciphers[MODE_OUT] == NULL) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(client to server): \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// ( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm server to client: %s\", buf);\n\n\tpvar->ciphers[MODE_IN] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_STOC]);\n\tif (pvar->ciphers[MODE_IN] == NULL) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(server to client): \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// MAC( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm client to server: %s\", buf);\n\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_OUT]) > 0) {\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (client to server)\");\n\t\tpvar->macs[MODE_OUT] = get_ssh2_mac(HMAC_IMPLICIT);\n\t}\n\telse {\n\t\tpvar->macs[MODE_OUT] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_CTOS]);\n\t\tif (pvar->macs[MODE_OUT] == NULL) { // not match\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// MAC( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm server to client: %s\", buf);\n\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_IN]) > 0) {\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (server to client)\");\n\t\tpvar->macs[MODE_IN] = get_ssh2_mac(HMAC_IMPLICIT);\n\t}\n\telse {\n\t\tpvar->macs[MODE_IN] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_STOC]);\n\t\tif (pvar->macs[MODE_IN] == NULL) { // not match\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// ( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm client to server: %s\", buf);\n\n\tpvar->ctos_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_CTOS]);\n\tif (pvar->ctos_compression == COMP_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// ( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm server to client: %s\", buf);\n\n\tpvar->stoc_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_STOC]);\n\tif (pvar->stoc_compression == COMP_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// ( -> )\n\t// \n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t//  name-list  KEXINIT \n\t\t// \n\t\t// \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language client to server)\", __FUNCTION__);\n\t\tgoto skip;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language client to server: %s\", buf);\n\n\t// ( -> )\n\t// \n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t// ( -> ) \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language server to client)\", __FUNCTION__);\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language server to client: %s\", buf);\n\n\t// first_kex_packet_follows:\n\t// KEXINIT \n\t// SSH_MSG_KEXINIT  1 \n\tif (!get_boolean_from_payload(pvar, buf)) {\n\t\t// ( -> ) \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (first_kex_packet_follows)\", __FUNCTION__);\n\t\tgoto skip;\n\t}\n\tif (buf[0] != 0) {\n\t\t//  0 \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: first_kex_packet_follows is not 0. (%d)\", __FUNCTION__, buf[0]);\n\t}\n\n\t// reserved:  0 \n\tif (!get_uint32_from_payload(pvar, &size)) {\n\t\t// ( -> ) \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (reserved)\", __FUNCTION__ );\n\t\tgoto skip;\n\t}\n\tif (size != 0) {\n\t\tlogprintf(LOG_LEVEL_INFO, \"%s: reserved data is not 0. (%d)\", __FUNCTION__, size);\n\t}\n\nskip:\n\t// \n\tlogprintf(LOG_LEVEL_VERBOSE, \"KEX algorithm: %s\",\n\t\tget_kex_algorithm_name(pvar->kex_type));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server host key algorithm: %s\",\n\t\tget_ssh2_hostkey_algorithm_name(pvar->hostkey_type));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm client to server: %s\",\n\t\tget_cipher_string(pvar->ciphers[MODE_OUT]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm server to client: %s\",\n\t\tget_cipher_string(pvar->ciphers[MODE_IN]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm client to server: %s\",\n\t\tget_ssh2_mac_name(pvar->macs[MODE_OUT]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm server to client: %s\",\n\t\tget_ssh2_mac_name(pvar->macs[MODE_IN]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm client to server: %s\",\n\t\tget_ssh2_comp_name(pvar->ctos_compression));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm server to client: %s\",\n\t\tget_ssh2_comp_name(pvar->stoc_compression));\n\n\t// we_need (2004.11.6 yutaka)\n\t// \n\tif ((pvar->kex_status & KEX_FLAG_REKEYING) == 0) {\n\t\tchoose_SSH2_key_maxlength(pvar);\n\t}\n\n\t// send DH kex init\n\tswitch (pvar->kex_type) {\n\t\tcase KEX_DH_GRP1_SHA1:\n\t\tcase KEX_DH_GRP14_SHA1:\n\t\tcase KEX_DH_GRP14_SHA256:\n\t\tcase KEX_DH_GRP16_SHA512:\n\t\tcase KEX_DH_GRP18_SHA512:\n\t\t\tSSH2_dh_kex_init(pvar);\n\t\t\tbreak;\n\t\tcase KEX_DH_GEX_SHA1:\n\t\tcase KEX_DH_GEX_SHA256:\n\t\t\tSSH2_dh_gex_kex_init(pvar);\n\t\t\tbreak;\n\t\tcase KEX_ECDH_SHA2_256:\n\t\tcase KEX_ECDH_SHA2_384:\n\t\tcase KEX_ECDH_SHA2_521:\n\t\t\tSSH2_ecdh_kex_init(pvar);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n\nerror:;\n\tbuffer_free(pvar->peer_kex);\n\tpvar->peer_kex = NULL;\n\n\tnotify_fatal_error(pvar, msg, TRUE);\n\n\treturn FALSE;\n}",
        "func": "static BOOL handle_SSH2_kexinit(PTInstVar pvar)\n{\n\tchar buf[1024];\n\tchar *data;\n\tint len, size;\n\tchar *msg = NULL;\n\tchar tmp[1024+512];\n\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_KEXINIT was received.\");\n\n\t//  SSH2_MSG_KEXINIT \n\t// (2004.10.24 yutaka)\n\tif (pvar->kex_status == KEX_FLAG_KEXDONE) {\n\t\tpvar->kex_status = KEX_FLAG_REKEYING;\n\n\t\t//  myproposal  \",ext-info-c,kex-strict-c-v00@openssh.com\" \n\t\t//  KEX \n\t\tSSH2_update_kex_myproposal(pvar);\n\n\t\t// SSH2_MSG_KEXINIT \n\t\tSSH2_send_kexinit(pvar);\n\t}\n\n\tdata = remained_payload(pvar);\n\tlen = remained_payloadlen(pvar);\n\n\t// KEX  exchange-hash (session-id) \n\tif (pvar->peer_kex != NULL) {\n\t\t// already allocated\n\t\tbuffer_clear(pvar->peer_kex);\n\t}\n\telse {\n\t\tpvar->peer_kex = buffer_init();\n\t\tif (pvar->peer_kex == NULL) {\n\t\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\t\"%s: Out of memory\", __FUNCTION__);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tbuffer_append(pvar->peer_kex, data, len);\n\n\tpush_memdump(\"KEXINIT\", \"exchange algorithm list: receiving\", data, len);\n\n\t// cookie\n\tif (! get_bytearray_from_payload(pvar, buf, SSH2_COOKIE_LENGTH)) {\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (cookie)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\tCRYPT_set_server_cookie(pvar, buf);\n\n\t// (,)\n\t// \n\t// \n\t// \n\n\t// \n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (kex algorithms)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed kex algorithms is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: KEX algorithm: %s\", buf);\n\n\tpvar->kex_type = choose_SSH2_kex_algorithm(buf, myproposal[PROPOSAL_KEX_ALGS]);\n\tif (pvar->kex_type == KEX_DH_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown KEX algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// Strict KEX\n\tchoose_SSH2_proposal(buf, \"kex-strict-s-v00@openssh.com\", tmp, sizeof(tmp));\n\tif (tmp[0] != '\\0') {\n\t\tpvar->server_strict_kex = TRUE;\n\t\tlogprintf(LOG_LEVEL_INFO, \"Server supports strict kex. Strict kex will be enabled.\");\n\t}\n\n\t// \n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (hostkey algorithms)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed hostkey algorithms is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: server host key algorithm: %s\", buf);\n\n\tpvar->hostkey_type = choose_SSH2_host_key_algorithm(buf, myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]);\n\tif (pvar->hostkey_type == KEY_ALGO_UNSPEC) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown host KEY algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// ( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm client to server: %s\", buf);\n\n\tpvar->ciphers[MODE_OUT] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_CTOS]);\n\tif (pvar->ciphers[MODE_OUT] == NULL) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(client to server): \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// ( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (encryption algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed encryption algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: encryption algorithm server to client: %s\", buf);\n\n\tpvar->ciphers[MODE_IN] = choose_SSH2_cipher_algorithm(buf, myproposal[PROPOSAL_ENC_ALGS_STOC]);\n\tif (pvar->ciphers[MODE_IN] == NULL) {\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Encrypt algorithm(server to client): \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// MAC( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm client to server: %s\", buf);\n\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_OUT]) > 0) {\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (client to server)\");\n\t\tpvar->macs[MODE_OUT] = get_ssh2_mac(HMAC_IMPLICIT);\n\t}\n\telse {\n\t\tpvar->macs[MODE_OUT] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_CTOS]);\n\t\tif (pvar->macs[MODE_OUT] == NULL) { // not match\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// MAC( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (MAC algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed MAC algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: MAC algorithm server to client: %s\", buf);\n\n\tif (get_cipher_auth_len(pvar->ciphers[MODE_IN]) > 0) {\n\t\tlogputs(LOG_LEVEL_VERBOSE, \"AEAD cipher is selected, ignoring MAC algorithms. (server to client)\");\n\t\tpvar->macs[MODE_IN] = get_ssh2_mac(HMAC_IMPLICIT);\n\t}\n\telse {\n\t\tpvar->macs[MODE_IN] = choose_SSH2_mac_algorithm(buf, myproposal[PROPOSAL_MAC_ALGS_STOC]);\n\t\tif (pvar->macs[MODE_IN] == NULL) { // not match\n\t\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown MAC algorithm: \", _TRUNCATE);\n\t\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\t\tmsg = tmp;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// ( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms client to server)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm client to server: %s\", buf);\n\n\tpvar->ctos_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_CTOS]);\n\tif (pvar->ctos_compression == COMP_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// ( -> )\n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t_snprintf_s(tmp, sizeof(tmp), _TRUNCATE,\n\t\t\t\t\t\"%s: truncated packet (compression algorithms server to client)\", __FUNCTION__);\n\t\tmsg = tmp;\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed compression algorithms (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: compression algorithm server to client: %s\", buf);\n\n\tpvar->stoc_compression = choose_SSH2_compression_algorithm(buf, myproposal[PROPOSAL_COMP_ALGS_STOC]);\n\tif (pvar->stoc_compression == COMP_UNKNOWN) { // not match\n\t\tstrncpy_s(tmp, sizeof(tmp), \"unknown Packet Compression algorithm: \", _TRUNCATE);\n\t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n\t\tmsg = tmp;\n\t\tgoto error;\n\t}\n\n\t// ( -> )\n\t// \n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t//  name-list  KEXINIT \n\t\t// \n\t\t// \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language client to server)\", __FUNCTION__);\n\t\tgoto skip;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (client to server) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language client to server: %s\", buf);\n\n\t// ( -> )\n\t// \n\tswitch (get_namelist_from_payload(pvar, buf, sizeof(buf), &size)) {\n\tcase GetPayloadError:\n\t\t// ( -> ) \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (language server to client)\", __FUNCTION__);\n\t\tgoto error;\n\tcase GetPayloadTruncate:\n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: server proposed language (server to client) is too long.\", __FUNCTION__);\n\t\tbreak;\n\t}\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server proposal: language server to client: %s\", buf);\n\n\t// first_kex_packet_follows:\n\t// KEXINIT \n\t// SSH_MSG_KEXINIT  1 \n\tif (!get_boolean_from_payload(pvar, buf)) {\n\t\t// ( -> ) \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (first_kex_packet_follows)\", __FUNCTION__);\n\t\tgoto skip;\n\t}\n\tif (buf[0] != 0) {\n\t\t//  0 \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: first_kex_packet_follows is not 0. (%d)\", __FUNCTION__, buf[0]);\n\t}\n\n\t// reserved:  0 \n\tif (!get_uint32_from_payload(pvar, &size)) {\n\t\t// ( -> ) \n\t\tlogprintf(LOG_LEVEL_WARNING, \"%s: truncated packet (reserved)\", __FUNCTION__ );\n\t\tgoto skip;\n\t}\n\tif (size != 0) {\n\t\tlogprintf(LOG_LEVEL_INFO, \"%s: reserved data is not 0. (%d)\", __FUNCTION__, size);\n\t}\n\nskip:\n\t// \n\tlogprintf(LOG_LEVEL_VERBOSE, \"KEX algorithm: %s\",\n\t\tget_kex_algorithm_name(pvar->kex_type));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"server host key algorithm: %s\",\n\t\tget_ssh2_hostkey_algorithm_name(pvar->hostkey_type));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm client to server: %s\",\n\t\tget_cipher_string(pvar->ciphers[MODE_OUT]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"encryption algorithm server to client: %s\",\n\t\tget_cipher_string(pvar->ciphers[MODE_IN]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm client to server: %s\",\n\t\tget_ssh2_mac_name(pvar->macs[MODE_OUT]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"MAC algorithm server to client: %s\",\n\t\tget_ssh2_mac_name(pvar->macs[MODE_IN]));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm client to server: %s\",\n\t\tget_ssh2_comp_name(pvar->ctos_compression));\n\n\tlogprintf(LOG_LEVEL_VERBOSE, \"compression algorithm server to client: %s\",\n\t\tget_ssh2_comp_name(pvar->stoc_compression));\n\n\t// we_need (2004.11.6 yutaka)\n\t// \n\tif ((pvar->kex_status & KEX_FLAG_REKEYING) == 0) {\n\t\tchoose_SSH2_key_maxlength(pvar);\n\t}\n\n\t// send DH kex init\n\tswitch (pvar->kex_type) {\n\t\tcase KEX_DH_GRP1_SHA1:\n\t\tcase KEX_DH_GRP14_SHA1:\n\t\tcase KEX_DH_GRP14_SHA256:\n\t\tcase KEX_DH_GRP16_SHA512:\n\t\tcase KEX_DH_GRP18_SHA512:\n\t\t\tSSH2_dh_kex_init(pvar);\n\t\t\tbreak;\n\t\tcase KEX_DH_GEX_SHA1:\n\t\tcase KEX_DH_GEX_SHA256:\n\t\t\tSSH2_dh_gex_kex_init(pvar);\n\t\t\tbreak;\n\t\tcase KEX_ECDH_SHA2_256:\n\t\tcase KEX_ECDH_SHA2_384:\n\t\tcase KEX_ECDH_SHA2_521:\n\t\t\tSSH2_ecdh_kex_init(pvar);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n\nerror:;\n\tbuffer_free(pvar->peer_kex);\n\tpvar->peer_kex = NULL;\n\n\tnotify_fatal_error(pvar, msg, TRUE);\n\n\treturn FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \tif (pvar->kex_status == KEX_FLAG_KEXDONE) {\n \t\tpvar->kex_status = KEX_FLAG_REKEYING;\n \n-\t\t//  myproposal  \",ext-info-c\" \n+\t\t//  myproposal  \",ext-info-c,kex-strict-c-v00@openssh.com\" \n \t\t//  KEX \n \t\tSSH2_update_kex_myproposal(pvar);\n \n@@ -76,6 +76,13 @@\n \t\tstrncat_s(tmp, sizeof(tmp), buf, _TRUNCATE);\n \t\tmsg = tmp;\n \t\tgoto error;\n+\t}\n+\n+\t// Strict KEX\n+\tchoose_SSH2_proposal(buf, \"kex-strict-s-v00@openssh.com\", tmp, sizeof(tmp));\n+\tif (tmp[0] != '\\0') {\n+\t\tpvar->server_strict_kex = TRUE;\n+\t\tlogprintf(LOG_LEVEL_INFO, \"Server supports strict kex. Strict kex will be enabled.\");\n \t}\n \n \t// ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t//  myproposal  \",ext-info-c\" "
            ],
            "added_lines": [
                "\t\t//  myproposal  \",ext-info-c,kex-strict-c-v00@openssh.com\" ",
                "\t}",
                "",
                "\t// Strict KEX",
                "\tchoose_SSH2_proposal(buf, \"kex-strict-s-v00@openssh.com\", tmp, sizeof(tmp));",
                "\tif (tmp[0] != '\\0') {",
                "\t\tpvar->server_strict_kex = TRUE;",
                "\t\tlogprintf(LOG_LEVEL_INFO, \"Server supports strict kex. Strict kex will be enabled.\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "TeraTermProject/teraterm/handle_SSH2_newkeys",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/TeraTermProject/teraterm/commit/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0",
        "commit_title": "Strict KEX  (CVE-2023-48795)",
        "commit_text": "  Strict KEX ",
        "func_before": "static BOOL handle_SSH2_newkeys(PTInstVar pvar)\n{\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_NEWKEYS was received(DH key generation is completed).\");\n\n\t//  (2005.3.7 yutaka)\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\n\t\tsave_memdump(LOGDUMP);\n\t}\n\tfinish_memdump();\n\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED;\n\n\t// SSH2_MSG_NEWKEYS \n\t// ()\n\tssh2_set_newkeys(pvar, MODE_IN);\n\tif (!CRYPT_start_encryption(pvar, 0, 1)) {\n\t\t// TODO: error\n\t}\n\n\t// MAC\n\tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\n\tenable_recv_compression(pvar);\n\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\n\n\t// SSH2_MSG_NEWKEYS KEX\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint i;\n\t\t\tChannel_t *c;\n\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\n\t\t\t// \n\t\t\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\n\t\t\t\tc = &channels[i];\n\t\t\t\tif (c->used) {\n\t\t\t\t\tssh2_channel_retry_send_bufchain(pvar, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t//  SSH2_MSG_NEWKEYS \n\t\t\tssh2_finish_encryption_setup(pvar);\n\n\t\t\t// \n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\n\treturn TRUE;\n}",
        "func": "static BOOL handle_SSH2_newkeys(PTInstVar pvar)\n{\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_NEWKEYS was received(DH key generation is completed).\");\n\n\t//  (2005.3.7 yutaka)\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\n\t\tsave_memdump(LOGDUMP);\n\t}\n\tfinish_memdump();\n\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED;\n\n\t// SSH2_MSG_NEWKEYS \n\t// ()\n\tssh2_set_newkeys(pvar, MODE_IN);\n\tif (!CRYPT_start_encryption(pvar, 0, 1)) {\n\t\t// TODO: error\n\t}\n\n\t// MAC\n\tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\n\tenable_recv_compression(pvar);\n\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.receiver_sequence_number = 0;\n\t}\n\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\n\n\t// SSH2_MSG_NEWKEYS KEX\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint i;\n\t\t\tChannel_t *c;\n\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\n\t\t\t// \n\t\t\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\n\t\t\t\tc = &channels[i];\n\t\t\t\tif (c->used) {\n\t\t\t\t\tssh2_channel_retry_send_bufchain(pvar, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t//  SSH2_MSG_NEWKEYS \n\t\t\tssh2_finish_encryption_setup(pvar);\n\n\t\t\t// \n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,10 @@\n \tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\n \tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\n \tenable_recv_compression(pvar);\n+\n+\tif (pvar->server_strict_kex) {\n+\t\tpvar->ssh_state.receiver_sequence_number = 0;\n+\t}\n \n \tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (pvar->server_strict_kex) {",
                "\t\tpvar->ssh_state.receiver_sequence_number = 0;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "TeraTermProject/teraterm/SSH_init",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/TeraTermProject/teraterm/commit/7279fbd6ef4d0c8bdd6a90af4ada2899d786eec0",
        "commit_title": "Strict KEX  (CVE-2023-48795)",
        "commit_text": "  Strict KEX ",
        "func_before": "void SSH_init(PTInstVar pvar)\n{\n\tint i;\n\n\tbuf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\n\tbuf_create(&pvar->ssh_state.precompress_outbuf,\n\t           &pvar->ssh_state.precompress_outbuflen);\n\tbuf_create(&pvar->ssh_state.postdecompress_inbuf,\n\t           &pvar->ssh_state.postdecompress_inbuflen);\n\tpvar->ssh_state.payload = NULL;\n\tpvar->ssh_state.compressing = FALSE;\n\tpvar->ssh_state.decompressing = FALSE;\n\tpvar->ssh_state.status_flags =\n\t\tSTATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS;\n\tpvar->ssh_state.payload_datalen = 0;\n\tpvar->ssh_state.hostname = NULL;\n\tpvar->ssh_state.server_ID = NULL;\n\tpvar->ssh_state.receiver_sequence_number = 0;\n\tpvar->ssh_state.sender_sequence_number = 0;\n\tfor (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) {\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\n\t}\n\n\t// for SSH2(yutaka)\n\tmemset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys));\n\tpvar->userauth_success = 0;\n\tpvar->shell_id = SSH_CHANNEL_INVALID;\n\tpvar->session_nego_status = 0;\n\tpvar->settings.ssh_protocol_version = 2;  // SSH2(default)\n\tpvar->kex_status = 0;\n\tpvar->ssh2_autologin = 0;  // autologin disabled(default)\n\tpvar->ask4passwd = 0; // disabled(default) (2006.9.18 maya)\n\tpvar->userauth_retry_count = 0;\n\tpvar->decomp_buffer = NULL;\n\tpvar->authbanner_buffer = NULL;\n\tpvar->ssh2_authlist = NULL; // (2007.4.27 yutaka)\n\tpvar->tryed_ssh2_authlist = FALSE;\n\tpvar->agentfwd_enable = FALSE;\n\tpvar->use_subsystem = FALSE;\n\tpvar->nosession = FALSE;\n\tpvar->server_sig_algs = NULL;\n\n}",
        "func": "void SSH_init(PTInstVar pvar)\n{\n\tint i;\n\n\tbuf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\n\tbuf_create(&pvar->ssh_state.precompress_outbuf,\n\t           &pvar->ssh_state.precompress_outbuflen);\n\tbuf_create(&pvar->ssh_state.postdecompress_inbuf,\n\t           &pvar->ssh_state.postdecompress_inbuflen);\n\tpvar->ssh_state.payload = NULL;\n\tpvar->ssh_state.compressing = FALSE;\n\tpvar->ssh_state.decompressing = FALSE;\n\tpvar->ssh_state.status_flags =\n\t\tSTATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS;\n\tpvar->ssh_state.payload_datalen = 0;\n\tpvar->ssh_state.hostname = NULL;\n\tpvar->ssh_state.server_ID = NULL;\n\tpvar->ssh_state.receiver_sequence_number = 0;\n\tpvar->ssh_state.sender_sequence_number = 0;\n\tfor (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) {\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\n\t}\n\n\t// for SSH2(yutaka)\n\tmemset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys));\n\tpvar->userauth_success = 0;\n\tpvar->shell_id = SSH_CHANNEL_INVALID;\n\tpvar->session_nego_status = 0;\n\tpvar->settings.ssh_protocol_version = 2;  // SSH2(default)\n\tpvar->kex_status = 0;\n\tpvar->ssh2_autologin = 0;  // autologin disabled(default)\n\tpvar->ask4passwd = 0; // disabled(default) (2006.9.18 maya)\n\tpvar->userauth_retry_count = 0;\n\tpvar->decomp_buffer = NULL;\n\tpvar->authbanner_buffer = NULL;\n\tpvar->ssh2_authlist = NULL; // (2007.4.27 yutaka)\n\tpvar->tryed_ssh2_authlist = FALSE;\n\tpvar->agentfwd_enable = FALSE;\n\tpvar->use_subsystem = FALSE;\n\tpvar->nosession = FALSE;\n\tpvar->server_sig_algs = NULL;\n\tpvar->server_strict_kex = FALSE;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,5 +39,6 @@\n \tpvar->use_subsystem = FALSE;\n \tpvar->nosession = FALSE;\n \tpvar->server_sig_algs = NULL;\n+\tpvar->server_strict_kex = FALSE;\n \n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tpvar->server_strict_kex = FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "janmojzis/tinyssh/packet_kexdh",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/janmojzis/tinyssh/commit/12ec08d24e43e382cb6d9b61facd87685f99eae0",
        "commit_title": "implementation kex-strict-s-v00@openssh.com",
        "commit_text": "",
        "func_before": "int packet_kexdh(const char *keydir, struct buf *b1, struct buf *b2) {\n\n    unsigned char clientpk[sshcrypto_kem_PUBLICKEYMAX];\n    unsigned char serverpk[sshcrypto_kem_CIPHERTEXTMAX];\n    unsigned char sharedsecret[sshcrypto_kem_MAX];\n    unsigned char sm[sshcrypto_sign_MAX];\n    unsigned char key[sshcrypto_cipher_KEYMAX];\n    unsigned char hash[sshcrypto_hash_MAX];\n    long long pos = 0;\n    crypto_uint8 ch;\n    crypto_uint32 len;\n    long long i;\n\n    if (packet.kex_packet_follows && !packet.kex_guess) {\n        buf_purge(b1);\n        if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0;\n    }\n\n    buf_purge(b1);\n    if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0;\n    pos = packetparser_uint8(b1->buf, b1->len, pos, &ch);           /* byte      SSH_MSG_KEXDH_INIT */\n    if (ch != SSH_MSG_KEXDH_INIT) bug_proto();\n    pos = packetparser_uint32(b1->buf, b1->len, pos, &len);         /* string    client's public key */\n    if (len != sshcrypto_kem_publickeybytes) bug_proto();\n    pos = packetparser_copy(b1->buf, b1->len, pos, clientpk, len);\n    pos = packetparser_end(b1->buf, b1->len, pos);\n    buf_purge(b1);\n\n    /* generate key and compute shared secret */\n    do { \n        /* XXX - workaroud for bug in OpenSSH 6.5 - 6.6 */\n        if (sshcrypto_enc(serverpk, sharedsecret, clientpk) != 0) bug_proto();\n    } while(sharedsecret[0] == 0 && sshcrypto_kem_publickeybytes == 32);\n\n    /* create hash */\n    buf_purge(&packet.hashbuf);\n    buf_putstringlen(&packet.hashbuf, packet.helloreceive.buf, packet.helloreceive.len);\n    buf_putstringlen(&packet.hashbuf, packet.hellosend.buf, packet.hellosend.len);\n    buf_putstringlen(&packet.hashbuf, packet.kexrecv.buf, packet.kexrecv.len);\n    buf_putstringlen(&packet.hashbuf, packet.kexsend.buf, packet.kexsend.len);\n    sshcrypto_buf_putsignpk(&packet.hashbuf, sshcrypto_sign_publickey);\n    buf_putstringlen(&packet.hashbuf, clientpk, sshcrypto_kem_publickeybytes);\n    buf_putstringlen(&packet.hashbuf, serverpk, sshcrypto_kem_ciphertextbytes);\n    sshcrypto_buf_putkemkey(&packet.hashbuf, sharedsecret);\n    sshcrypto_hash(hash, packet.hashbuf.buf, packet.hashbuf.len);\n\n    /* session id */\n    if (!packet.flagrekeying) byte_copy(packet.sessionid, sshcrypto_hash_bytes, hash);\n    packet.flagrekeying = 1;\n\n    /* signature */\n    if (subprocess_sign(sm, sshcrypto_sign_bytes, keydir, hash, sshcrypto_hash_bytes) != 0) return 0;\n    buf_purge(b1); buf_purge(b2);\n\n    /* send server kex_ecdh_reply */\n    buf_putnum8(b2, SSH_MSG_KEXDH_REPLY);                           /* SSH_MSG_KEXDH_REPLY */\n    sshcrypto_buf_putsignpk(b2, sshcrypto_sign_publickey);          /* public key */\n    buf_putstringlen(b2, serverpk, sshcrypto_kem_ciphertextbytes);  /* servers's public key */\n    sshcrypto_buf_putsignature(b2, sm);                             /* signature */\n    packet_put(b2);\n\n    /* send server newkeys */\n    buf_purge(b2);\n    buf_putnum8(b2, SSH_MSG_NEWKEYS);\n    packet_put(b2);\n    if (!packet_sendall()) return 0;\n\n    /* receive new keys */\n    do {\n        buf_purge(b2);\n        if (!packet_getall(b2, 0)) return 0;\n    } while (b2->buf[0] != SSH_MSG_NEWKEYS);\n\n    /* key derivation */\n    for(i = 0; i < 6; ++i) {\n        buf_purge(b1);\n        sshcrypto_buf_putkemkey(b1, sharedsecret);\n        buf_put(b1, hash, sshcrypto_hash_bytes);\n        buf_putnum8(b1, 'A' + i);\n        buf_put(b1, packet.sessionid, sshcrypto_hash_bytes);\n        sshcrypto_hash(key, b1->buf, b1->len);\n\n        /* one extend */\n        buf_purge(b1);\n        sshcrypto_buf_putkemkey(b1, sharedsecret);\n        buf_put(b1, hash, sshcrypto_hash_bytes);\n        buf_put(b1, key, sshcrypto_hash_bytes);\n        sshcrypto_hash(key + sshcrypto_hash_bytes, b1->buf, b1->len);\n\n        if (i == 0) byte_copy(packet.clientnonce, sshcrypto_cipher_KEYMAX, key);\n        if (i == 1) byte_copy(packet.servernonce, sshcrypto_cipher_KEYMAX, key);\n        if (i == 2) byte_copy(packet.clientkey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 3) byte_copy(packet.serverkey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 4) byte_copy(packet.clientmackey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 5) byte_copy(packet.servermackey, sshcrypto_cipher_KEYMAX, key);\n    }\n\n    purge(clientpk, sizeof clientpk);\n    purge(serverpk, sizeof serverpk);\n    purge(sharedsecret, sizeof sharedsecret);\n    purge(sm, sizeof sm);\n    purge(key, sizeof key);\n    purge(hash, sizeof hash);\n    return 1;\n}",
        "func": "int packet_kexdh(const char *keydir, struct buf *b1, struct buf *b2) {\n\n    unsigned char clientpk[sshcrypto_kem_PUBLICKEYMAX];\n    unsigned char serverpk[sshcrypto_kem_CIPHERTEXTMAX];\n    unsigned char sharedsecret[sshcrypto_kem_MAX];\n    unsigned char sm[sshcrypto_sign_MAX];\n    unsigned char key[sshcrypto_cipher_KEYMAX];\n    unsigned char hash[sshcrypto_hash_MAX];\n    long long pos = 0;\n    crypto_uint8 ch;\n    crypto_uint32 len;\n    long long i;\n\n    if (packet.kex_packet_follows && !packet.kex_guess) {\n        buf_purge(b1);\n        if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0;\n    }\n\n    buf_purge(b1);\n    if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0;\n    pos = packetparser_uint8(b1->buf, b1->len, pos, &ch);           /* byte      SSH_MSG_KEXDH_INIT */\n    if (ch != SSH_MSG_KEXDH_INIT) bug_proto();\n    pos = packetparser_uint32(b1->buf, b1->len, pos, &len);         /* string    client's public key */\n    if (len != sshcrypto_kem_publickeybytes) bug_proto();\n    pos = packetparser_copy(b1->buf, b1->len, pos, clientpk, len);\n    pos = packetparser_end(b1->buf, b1->len, pos);\n    buf_purge(b1);\n\n    /* generate key and compute shared secret */\n    do { \n        /* XXX - workaroud for bug in OpenSSH 6.5 - 6.6 */\n        if (sshcrypto_enc(serverpk, sharedsecret, clientpk) != 0) bug_proto();\n    } while(sharedsecret[0] == 0 && sshcrypto_kem_publickeybytes == 32);\n\n    /* create hash */\n    buf_purge(&packet.hashbuf);\n    buf_putstringlen(&packet.hashbuf, packet.helloreceive.buf, packet.helloreceive.len);\n    buf_putstringlen(&packet.hashbuf, packet.hellosend.buf, packet.hellosend.len);\n    buf_putstringlen(&packet.hashbuf, packet.kexrecv.buf, packet.kexrecv.len);\n    buf_putstringlen(&packet.hashbuf, packet.kexsend.buf, packet.kexsend.len);\n    sshcrypto_buf_putsignpk(&packet.hashbuf, sshcrypto_sign_publickey);\n    buf_putstringlen(&packet.hashbuf, clientpk, sshcrypto_kem_publickeybytes);\n    buf_putstringlen(&packet.hashbuf, serverpk, sshcrypto_kem_ciphertextbytes);\n    sshcrypto_buf_putkemkey(&packet.hashbuf, sharedsecret);\n    sshcrypto_hash(hash, packet.hashbuf.buf, packet.hashbuf.len);\n\n    /* session id */\n    if (!packet.flagrekeying) byte_copy(packet.sessionid, sshcrypto_hash_bytes, hash);\n    packet.flagrekeying = 1;\n\n    /* signature */\n    if (subprocess_sign(sm, sshcrypto_sign_bytes, keydir, hash, sshcrypto_hash_bytes) != 0) return 0;\n    buf_purge(b1); buf_purge(b2);\n\n    /* send server kex_ecdh_reply */\n    buf_putnum8(b2, SSH_MSG_KEXDH_REPLY);                           /* SSH_MSG_KEXDH_REPLY */\n    sshcrypto_buf_putsignpk(b2, sshcrypto_sign_publickey);          /* public key */\n    buf_putstringlen(b2, serverpk, sshcrypto_kem_ciphertextbytes);  /* servers's public key */\n    sshcrypto_buf_putsignature(b2, sm);                             /* signature */\n    packet_put(b2);\n\n    /* send server newkeys */\n    buf_purge(b2);\n    buf_putnum8(b2, SSH_MSG_NEWKEYS);\n    packet_put(b2);\n    if (!packet_sendall()) return 0;\n\n    /* receive new keys */\n    do {\n        buf_purge(b2);\n        if (!packet_getall(b2, 0)) return 0;\n    } while (b2->buf[0] != SSH_MSG_NEWKEYS);\n\n\n    /* key derivation */\n    for(i = 0; i < 6; ++i) {\n        buf_purge(b1);\n        sshcrypto_buf_putkemkey(b1, sharedsecret);\n        buf_put(b1, hash, sshcrypto_hash_bytes);\n        buf_putnum8(b1, 'A' + i);\n        buf_put(b1, packet.sessionid, sshcrypto_hash_bytes);\n        sshcrypto_hash(key, b1->buf, b1->len);\n\n        /* one extend */\n        buf_purge(b1);\n        sshcrypto_buf_putkemkey(b1, sharedsecret);\n        buf_put(b1, hash, sshcrypto_hash_bytes);\n        buf_put(b1, key, sshcrypto_hash_bytes);\n        sshcrypto_hash(key + sshcrypto_hash_bytes, b1->buf, b1->len);\n\n        if (i == 0) byte_copy(packet.clientnonce, sshcrypto_cipher_KEYMAX, key);\n        if (i == 1) byte_copy(packet.servernonce, sshcrypto_cipher_KEYMAX, key);\n        if (i == 2) byte_copy(packet.clientkey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 3) byte_copy(packet.serverkey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 4) byte_copy(packet.clientmackey, sshcrypto_cipher_KEYMAX, key);\n        if (i == 5) byte_copy(packet.servermackey, sshcrypto_cipher_KEYMAX, key);\n    }\n\n    purge(clientpk, sizeof clientpk);\n    purge(serverpk, sizeof serverpk);\n    purge(sharedsecret, sizeof sharedsecret);\n    purge(sm, sizeof sm);\n    purge(key, sizeof key);\n    purge(hash, sizeof hash);\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,6 +71,7 @@\n         if (!packet_getall(b2, 0)) return 0;\n     } while (b2->buf[0] != SSH_MSG_NEWKEYS);\n \n+\n     /* key derivation */\n     for(i = 0; i < 6; ++i) {\n         buf_purge(b1);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "janmojzis/tinyssh/packet_put",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/janmojzis/tinyssh/commit/12ec08d24e43e382cb6d9b61facd87685f99eae0",
        "commit_title": "implementation kex-strict-s-v00@openssh.com",
        "commit_text": "",
        "func_before": "void packet_put(struct buf *b) {\n\n    if (packet.flagkeys) {\n        sshcrypto_packet_put(b);\n    }\n    else {\n        packet_put_plain_(b);\n    }\n}",
        "func": "void packet_put(struct buf *b) {\n\n    if (packet.flagkeys) {\n        sshcrypto_packet_put(b);\n    }\n    else {\n        packet_put_plain_(b);\n    }\n\n    /* strict kex - reset sendpacketid */\n    if (b->buf[0] == SSH_MSG_NEWKEYS && sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {\n        packet.sendpacketid = 0;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,4 +6,9 @@\n     else {\n         packet_put_plain_(b);\n     }\n+\n+    /* strict kex - reset sendpacketid */\n+    if (b->buf[0] == SSH_MSG_NEWKEYS && sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {\n+        packet.sendpacketid = 0;\n+    }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    /* strict kex - reset sendpacketid */",
                "    if (b->buf[0] == SSH_MSG_NEWKEYS && sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {",
                "        packet.sendpacketid = 0;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "janmojzis/tinyssh/sshcrypto_kex_put",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/janmojzis/tinyssh/commit/12ec08d24e43e382cb6d9b61facd87685f99eae0",
        "commit_title": "implementation kex-strict-s-v00@openssh.com",
        "commit_text": "",
        "func_before": "void sshcrypto_kex_put(struct buf *b) {\n\n    crypto_uint32 len = 0;\n    long long i, j, start;\n\n    j = 0;\n    for (i = 0; sshcrypto_kexs[i].name; ++i) {\n        if (!sshcrypto_kexs[i].flagenabled) continue;\n        if (j++) ++len;\n        len += str_len(sshcrypto_kexs[i].name);\n    }\n\n    buf_putnum32(b, len);\n    start = b->len;\n\n    j = 0;\n    for (i = 0; sshcrypto_kexs[i].name; ++i) {\n        if (!sshcrypto_kexs[i].flagenabled) continue;\n        if (j++) buf_puts(b, \",\");\n        buf_puts(b, sshcrypto_kexs[i].name);\n    }\n    b->buf[b->len] = 0;\n    log_d2(\"kex: server: kex algorithms: \", (char *)b->buf + start);\n}",
        "func": "void sshcrypto_kex_put(struct buf *b) {\n\n    crypto_uint32 len = 0;\n    long long i, j, start;\n\n    j = 0;\n    for (i = 0; sshcrypto_kexs[i].name; ++i) {\n        if (!sshcrypto_kexs[i].flagenabled) continue;\n        if (j++) ++len;\n        len += str_len(sshcrypto_kexs[i].name);\n    }\n    for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {\n        if (j++) ++len;\n        len += str_len(sshcrypto_pseudokexs[i].name);\n    }\n\n    buf_putnum32(b, len);\n    start = b->len;\n\n    j = 0;\n    for (i = 0; sshcrypto_kexs[i].name; ++i) {\n        if (!sshcrypto_kexs[i].flagenabled) continue;\n        if (j++) buf_puts(b, \",\");\n        buf_puts(b, sshcrypto_kexs[i].name);\n    }\n    for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {\n        if (j++) buf_puts(b, \",\");\n        buf_puts(b, sshcrypto_pseudokexs[i].name);\n    }\n    b->buf[b->len] = 0;\n    log_d2(\"kex: server: kex algorithms: \", (char *)b->buf + start);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,10 @@\n         if (j++) ++len;\n         len += str_len(sshcrypto_kexs[i].name);\n     }\n+    for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {\n+        if (j++) ++len;\n+        len += str_len(sshcrypto_pseudokexs[i].name);\n+    }\n \n     buf_putnum32(b, len);\n     start = b->len;\n@@ -19,6 +23,10 @@\n         if (j++) buf_puts(b, \",\");\n         buf_puts(b, sshcrypto_kexs[i].name);\n     }\n+    for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {\n+        if (j++) buf_puts(b, \",\");\n+        buf_puts(b, sshcrypto_pseudokexs[i].name);\n+    }\n     b->buf[b->len] = 0;\n     log_d2(\"kex: server: kex algorithms: \", (char *)b->buf + start);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {",
                "        if (j++) ++len;",
                "        len += str_len(sshcrypto_pseudokexs[i].name);",
                "    }",
                "    for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {",
                "        if (j++) buf_puts(b, \",\");",
                "        buf_puts(b, sshcrypto_pseudokexs[i].name);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "janmojzis/tinyssh/sshcrypto_kex_select",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/janmojzis/tinyssh/commit/12ec08d24e43e382cb6d9b61facd87685f99eae0",
        "commit_title": "implementation kex-strict-s-v00@openssh.com",
        "commit_text": "",
        "func_before": "int sshcrypto_kex_select(const unsigned char *buf, long long len, crypto_uint8 *kex_guess) {\n\n    long long i, pos = 0;\n    unsigned char *x;\n    long long xlen;\n\n    if (sshcrypto_kex_name) return 1;\n\n    if (buf[len] != 0) bug_proto();\n    log_d2(\"kex: client: kex algorithms: \", (char *)buf); \n\n    *kex_guess = 1;\n\n    for (;;) {\n        pos = stringparser(buf, len, pos, &x, &xlen);\n        if (!pos) break;\n\n        for (i = 0; sshcrypto_kexs[i].name; ++i) {\n            if (!sshcrypto_kexs[i].flagenabled) continue;\n            if (str_equaln((char *)x, xlen, sshcrypto_kexs[i].name)) {\n                sshcrypto_kex_name = sshcrypto_kexs[i].name;\n                sshcrypto_enc = sshcrypto_kexs[i].enc;\n                sshcrypto_kem_publickeybytes = sshcrypto_kexs[i].kem_publickeybytes;\n                sshcrypto_kem_ciphertextbytes = sshcrypto_kexs[i].kem_ciphertextbytes;\n                sshcrypto_kem_bytes = sshcrypto_kexs[i].kem_bytes;\n                sshcrypto_hash = sshcrypto_kexs[i].hash;\n                sshcrypto_hash_bytes = sshcrypto_kexs[i].hash_bytes;\n                sshcrypto_buf_putkemkey = sshcrypto_kexs[i].buf_putkemkey;\n                log_d2(\"kex: kex selected: \", sshcrypto_kexs[i].name);\n                return 1;\n            }\n        }\n        *kex_guess = 0;\n    }\n    log_d2(\"kex: kex not available \", (char *)buf);\n    errno = EPROTO;\n    return 0;\n}",
        "func": "int sshcrypto_kex_select(const unsigned char *buf, long long len, crypto_uint8 *kex_guess) {\n\n    long long i, pos;\n    unsigned char *x;\n    long long xlen;\n\n    if (sshcrypto_kex_name) return 1;\n\n    if (buf[len] != 0) bug_proto();\n    log_d2(\"kex: client: kex algorithms: \", (char *)buf); \n\n    *kex_guess = 1;\n\n    pos = 0;\n    for (;;) {\n        pos = stringparser(buf, len, pos, &x, &xlen);\n        if (!pos) break;\n        for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {\n            if (str_equaln((char *)x, xlen, sshcrypto_pseudokexs[i].cname)) {\n                log_d2(\"kex: pseudokex selected: \", sshcrypto_pseudokexs[i].name);\n                sshcrypto_kex_flags |= sshcrypto_pseudokexs[i].flag;\n            }\n        }\n    }\n\n    pos = 0;\n    for (;;) {\n        pos = stringparser(buf, len, pos, &x, &xlen);\n        if (!pos) break;\n\n        for (i = 0; sshcrypto_kexs[i].name; ++i) {\n            if (!sshcrypto_kexs[i].flagenabled) continue;\n            if (str_equaln((char *)x, xlen, sshcrypto_kexs[i].name)) {\n                sshcrypto_kex_name = sshcrypto_kexs[i].name;\n                sshcrypto_enc = sshcrypto_kexs[i].enc;\n                sshcrypto_kem_publickeybytes = sshcrypto_kexs[i].kem_publickeybytes;\n                sshcrypto_kem_ciphertextbytes = sshcrypto_kexs[i].kem_ciphertextbytes;\n                sshcrypto_kem_bytes = sshcrypto_kexs[i].kem_bytes;\n                sshcrypto_hash = sshcrypto_kexs[i].hash;\n                sshcrypto_hash_bytes = sshcrypto_kexs[i].hash_bytes;\n                sshcrypto_buf_putkemkey = sshcrypto_kexs[i].buf_putkemkey;\n                log_d2(\"kex: kex selected: \", sshcrypto_kexs[i].name);\n                return 1;\n            }\n        }\n        *kex_guess = 0;\n    }\n    log_d2(\"kex: kex not available \", (char *)buf);\n    errno = EPROTO;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n int sshcrypto_kex_select(const unsigned char *buf, long long len, crypto_uint8 *kex_guess) {\n \n-    long long i, pos = 0;\n+    long long i, pos;\n     unsigned char *x;\n     long long xlen;\n \n@@ -11,6 +11,19 @@\n \n     *kex_guess = 1;\n \n+    pos = 0;\n+    for (;;) {\n+        pos = stringparser(buf, len, pos, &x, &xlen);\n+        if (!pos) break;\n+        for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {\n+            if (str_equaln((char *)x, xlen, sshcrypto_pseudokexs[i].cname)) {\n+                log_d2(\"kex: pseudokex selected: \", sshcrypto_pseudokexs[i].name);\n+                sshcrypto_kex_flags |= sshcrypto_pseudokexs[i].flag;\n+            }\n+        }\n+    }\n+\n+    pos = 0;\n     for (;;) {\n         pos = stringparser(buf, len, pos, &x, &xlen);\n         if (!pos) break;",
        "diff_line_info": {
            "deleted_lines": [
                "    long long i, pos = 0;"
            ],
            "added_lines": [
                "    long long i, pos;",
                "    pos = 0;",
                "    for (;;) {",
                "        pos = stringparser(buf, len, pos, &x, &xlen);",
                "        if (!pos) break;",
                "        for (i = 0; sshcrypto_pseudokexs[i].name; ++i) {",
                "            if (str_equaln((char *)x, xlen, sshcrypto_pseudokexs[i].cname)) {",
                "                log_d2(\"kex: pseudokex selected: \", sshcrypto_pseudokexs[i].name);",
                "                sshcrypto_kex_flags |= sshcrypto_pseudokexs[i].flag;",
                "            }",
                "        }",
                "    }",
                "",
                "    pos = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "janmojzis/tinyssh/packet_get",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/janmojzis/tinyssh/commit/12ec08d24e43e382cb6d9b61facd87685f99eae0",
        "commit_title": "implementation kex-strict-s-v00@openssh.com",
        "commit_text": "",
        "func_before": "int packet_get(struct buf *b, crypto_uint8 x) {\n\n    buf_purge(b);\n    if (!packet_get_(b)) return 0;\n    if (b->len <= 0) return 1;\n    if (!packet.flagauthorized) if (packet.receivepacketid > PACKET_UNAUTHENTICATED_MESSAGES) {\n        errno = EPROTO;\n        log_f1(\"too many unauthenticated messages\");\n        global_die(111);\n    }\n\n    switch (b->buf[0]) {\n        case SSH_MSG_DISCONNECT:\n            errno = 0;\n            return 0;\n        case SSH_MSG_IGNORE:\n        case SSH_MSG_DEBUG:\n            buf_purge(b);\n            break;\n        default:\n            if (x && x != b->buf[0]) {\n                char buf1[NUMTOSTR_LEN];\n                char buf2[NUMTOSTR_LEN];\n                errno = EPROTO;\n                log_f4(\"expected packet type \", numtostr(buf1, x), \", got \", numtostr(buf2, b->buf[0]));\n                global_die(111);\n            }\n            break;\n    }\n    return 1;\n}",
        "func": "int packet_get(struct buf *b, crypto_uint8 x) {\n\n    buf_purge(b);\n    if (!packet_get_(b)) return 0;\n    if (b->len <= 0) return 1;\n    if (!packet.flagauthorized) if (packet.receivepacketid > PACKET_UNAUTHENTICATED_MESSAGES) {\n        errno = EPROTO;\n        log_f1(\"too many unauthenticated messages\");\n        global_die(111);\n    }\n\n    switch (b->buf[0]) {\n        case SSH_MSG_DISCONNECT:\n            errno = 0;\n            return 0;\n        case SSH_MSG_IGNORE:\n        case SSH_MSG_DEBUG:\n            if (!packet.flagkeys) {\n                log_f1(\"SSH_MSG_IGNORE/SSH_MSG_DEBUG packet rejected in plain-text mode\");\n                global_die(111);\n            }\n            buf_purge(b);\n            break;\n        case SSH_MSG_NEWKEYS:\n            /* strict kex - reset receivepacketid */\n            if (sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {\n                packet.receivepacketid = 0;\n            }\n        default:\n            if (x && x != b->buf[0]) {\n                char buf1[NUMTOSTR_LEN];\n                char buf2[NUMTOSTR_LEN];\n                errno = EPROTO;\n                log_f4(\"expected packet type \", numtostr(buf1, x), \", got \", numtostr(buf2, b->buf[0]));\n                global_die(111);\n            }\n            break;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,8 +15,17 @@\n             return 0;\n         case SSH_MSG_IGNORE:\n         case SSH_MSG_DEBUG:\n+            if (!packet.flagkeys) {\n+                log_f1(\"SSH_MSG_IGNORE/SSH_MSG_DEBUG packet rejected in plain-text mode\");\n+                global_die(111);\n+            }\n             buf_purge(b);\n             break;\n+        case SSH_MSG_NEWKEYS:\n+            /* strict kex - reset receivepacketid */\n+            if (sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {\n+                packet.receivepacketid = 0;\n+            }\n         default:\n             if (x && x != b->buf[0]) {\n                 char buf1[NUMTOSTR_LEN];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            if (!packet.flagkeys) {",
                "                log_f1(\"SSH_MSG_IGNORE/SSH_MSG_DEBUG packet rejected in plain-text mode\");",
                "                global_die(111);",
                "            }",
                "        case SSH_MSG_NEWKEYS:",
                "            /* strict kex - reset receivepacketid */",
                "            if (sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {",
                "                packet.receivepacketid = 0;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "janmojzis/tinyssh/packet_put",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/janmojzis/tinyssh/commit/ca4a78f5e716b568b5c15ec26ef2f11ecf81431b",
        "commit_title": "packet_{get,put}: add overflow checks",
        "commit_text": "",
        "func_before": "void packet_put(struct buf *b) {\n\n    if (packet.flagkeys) {\n        sshcrypto_packet_put(b);\n    }\n    else {\n        packet_put_plain_(b);\n    }\n\n    /* strict kex - reset sendpacketid */\n    if (b->buf[0] == SSH_MSG_NEWKEYS && sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {\n        packet.sendpacketid = 0;\n    }\n}",
        "func": "void packet_put(struct buf *b) {\n\n    if (packet.flagkeys) {\n        sshcrypto_packet_put(b);\n    }\n    else {\n        packet_put_plain_(b);\n    }\n\n    /* overflow check */\n    if (!packet.sendpacketid) {\n        log_f1(\"sendpacketid overflow\");\n        global_die(111);\n    }\n\n    /* strict kex - reset sendpacketid */\n    if (b->buf[0] == SSH_MSG_NEWKEYS && sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {\n        packet.sendpacketid = 0;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,12 @@\n         packet_put_plain_(b);\n     }\n \n+    /* overflow check */\n+    if (!packet.sendpacketid) {\n+        log_f1(\"sendpacketid overflow\");\n+        global_die(111);\n+    }\n+\n     /* strict kex - reset sendpacketid */\n     if (b->buf[0] == SSH_MSG_NEWKEYS && sshcrypto_kex_flags & sshcrypto_FLAGSTRICTKEX) {\n         packet.sendpacketid = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* overflow check */",
                "    if (!packet.sendpacketid) {",
                "        log_f1(\"sendpacketid overflow\");",
                "        global_die(111);",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48795",
        "func_name": "janmojzis/tinyssh/packet_get_",
        "description": "The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.",
        "git_url": "https://github.com/janmojzis/tinyssh/commit/ca4a78f5e716b568b5c15ec26ef2f11ecf81431b",
        "commit_title": "packet_{get,put}: add overflow checks",
        "commit_text": "",
        "func_before": "static int packet_get_(struct buf *b) {\n\n    if (packet.flagkeys) {\n        return sshcrypto_packet_get(b);\n    }\n    else {\n        return packet_get_plain_(b);\n    }\n}",
        "func": "static int packet_get_(struct buf *b) {\n\n    if (packet.flagkeys) {\n        return sshcrypto_packet_get(b);\n    }\n    else {\n        return packet_get_plain_(b);\n    }\n\n    /* overflow check */\n    if (!packet.receivepacketid) {\n        log_f1(\"receivepacketid overflow\");\n        global_die(111);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,4 +6,10 @@\n     else {\n         return packet_get_plain_(b);\n     }\n+\n+    /* overflow check */\n+    if (!packet.receivepacketid) {\n+        log_f1(\"receivepacketid overflow\");\n+        global_die(111);\n+    }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    /* overflow check */",
                "    if (!packet.receivepacketid) {",
                "        log_f1(\"receivepacketid overflow\");",
                "        global_die(111);",
                "    }"
            ]
        }
    }
]