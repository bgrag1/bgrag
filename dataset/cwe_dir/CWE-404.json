[
    {
        "cve_id": "CVE-2022-3299",
        "func_name": "open5gs/check_multi_info",
        "description": "A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88",
        "commit_title": "Fixed HTTP2 crashes for random JSON data (#1769)",
        "commit_text": "",
        "func_before": "static void check_multi_info(ogs_sbi_client_t *client)\n{\n    CURLM *multi = NULL;\n    CURLMsg *resource;\n    int pending;\n    CURL *easy = NULL;\n    CURLcode res;\n    connection_t *conn = NULL;\n    ogs_sbi_response_t *response = NULL;\n\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    while ((resource = curl_multi_info_read(multi, &pending))) {\n        char *url;\n        char *content_type = NULL;\n        long res_status;\n        ogs_assert(resource);\n\n        switch (resource->msg) {\n        case CURLMSG_DONE:\n            easy = resource->easy_handle;\n            ogs_assert(easy);\n\n            curl_easy_getinfo(easy, CURLINFO_PRIVATE, &conn);\n            ogs_assert(conn);\n\n            curl_easy_getinfo(easy, CURLINFO_EFFECTIVE_URL, &url);\n            curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &res_status);\n            curl_easy_getinfo(easy, CURLINFO_CONTENT_TYPE, &content_type);\n\n            res = resource->data.result;\n            if (res == CURLE_OK) {\n                response = ogs_sbi_response_new();\n                ogs_assert(response);\n\n                response->status = res_status;\n\n                ogs_assert(conn->method);\n                response->h.method = ogs_strdup(conn->method);\n                ogs_assert(response->h.method);\n\n                /* remove https://localhost:8000 */\n                response->h.uri = ogs_strdup(url);\n                ogs_assert(response->h.uri);\n\n                ogs_debug(\"[%d:%s] %s\",\n                        response->status, response->h.method, response->h.uri);\n\n                if (conn->memory) {\n                    response->http.content =\n                        ogs_memdup(conn->memory, conn->size + 1);\n                    ogs_assert(response->http.content);\n                    response->http.content_length = conn->size;\n                    ogs_assert(response->http.content_length);\n                }\n\n                ogs_debug(\"RECEIVED[%d]\", (int)response->http.content_length);\n                if (response->http.content_length && response->http.content)\n                    ogs_debug(\"%s\", response->http.content);\n\n                if (content_type)\n                    ogs_sbi_header_set(response->http.headers,\n                            OGS_SBI_CONTENT_TYPE, content_type);\n                if (conn->location)\n                    ogs_sbi_header_set(response->http.headers,\n                            OGS_SBI_LOCATION, conn->location);\n            } else\n                ogs_warn(\"[%d] %s\", res, conn->error);\n\n            ogs_assert(conn->client_cb);\n            conn->client_cb(res == CURLE_OK ? OGS_OK : OGS_ERROR,\n                            response, conn->data);\n            connection_remove(conn);\n            break;\n        default:\n            ogs_error(\"Unknown CURL resource[%d]\", resource->msg);\n            break;\n        }\n    }\n}",
        "func": "static void check_multi_info(ogs_sbi_client_t *client)\n{\n    CURLM *multi = NULL;\n    CURLMsg *resource;\n    int pending;\n    CURL *easy = NULL;\n    CURLcode res;\n    connection_t *conn = NULL;\n    ogs_sbi_response_t *response = NULL;\n\n    ogs_assert(client);\n    multi = client->multi;\n    ogs_assert(multi);\n\n    while ((resource = curl_multi_info_read(multi, &pending))) {\n        char *url;\n        char *content_type = NULL;\n        long res_status;\n        ogs_assert(resource);\n\n        switch (resource->msg) {\n        case CURLMSG_DONE:\n            easy = resource->easy_handle;\n            ogs_assert(easy);\n\n            curl_easy_getinfo(easy, CURLINFO_PRIVATE, &conn);\n            ogs_assert(conn);\n\n            curl_easy_getinfo(easy, CURLINFO_EFFECTIVE_URL, &url);\n            curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &res_status);\n            curl_easy_getinfo(easy, CURLINFO_CONTENT_TYPE, &content_type);\n\n            res = resource->data.result;\n            if (res == CURLE_OK) {\n                ogs_log_level_e level = OGS_LOG_DEBUG;\n\n                response = ogs_sbi_response_new();\n                ogs_assert(response);\n\n                response->status = res_status;\n\n                ogs_assert(conn->method);\n                response->h.method = ogs_strdup(conn->method);\n                ogs_assert(response->h.method);\n\n                /* remove https://localhost:8000 */\n                response->h.uri = ogs_strdup(url);\n                ogs_assert(response->h.uri);\n\n                if (content_type)\n                    ogs_sbi_header_set(response->http.headers,\n                            OGS_SBI_CONTENT_TYPE, content_type);\n                if (conn->location)\n                    ogs_sbi_header_set(response->http.headers,\n                            OGS_SBI_LOCATION, conn->location);\n\n                if (conn->memory_overflow == true)\n                    level = OGS_LOG_ERROR;\n\n                ogs_log_message(level, 0, \"[%d:%s] %s\",\n                        response->status, response->h.method, response->h.uri);\n\n                if (conn->memory) {\n                    response->http.content =\n                        ogs_memdup(conn->memory, conn->size + 1);\n                    ogs_assert(response->http.content);\n                    response->http.content_length = conn->size;\n                    ogs_assert(response->http.content_length);\n                }\n\n                ogs_log_message(level, 0, \"RECEIVED[%d]\",\n                        (int)response->http.content_length);\n                if (response->http.content_length && response->http.content)\n                    ogs_log_message(level, 0, \"%s\", response->http.content);\n\n                if (conn->memory_overflow == true) {\n                    ogs_sbi_response_free(response);\n                    connection_remove(conn);\n                    break;\n                }\n\n            } else\n                ogs_warn(\"[%d] %s\", res, conn->error);\n\n            ogs_assert(conn->client_cb);\n            conn->client_cb(res == CURLE_OK ? OGS_OK : OGS_ERROR,\n                            response, conn->data);\n            connection_remove(conn);\n            break;\n        default:\n            ogs_error(\"Unknown CURL resource[%d]\", resource->msg);\n            break;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,6 +32,8 @@\n \n             res = resource->data.result;\n             if (res == CURLE_OK) {\n+                ogs_log_level_e level = OGS_LOG_DEBUG;\n+\n                 response = ogs_sbi_response_new();\n                 ogs_assert(response);\n \n@@ -45,7 +47,17 @@\n                 response->h.uri = ogs_strdup(url);\n                 ogs_assert(response->h.uri);\n \n-                ogs_debug(\"[%d:%s] %s\",\n+                if (content_type)\n+                    ogs_sbi_header_set(response->http.headers,\n+                            OGS_SBI_CONTENT_TYPE, content_type);\n+                if (conn->location)\n+                    ogs_sbi_header_set(response->http.headers,\n+                            OGS_SBI_LOCATION, conn->location);\n+\n+                if (conn->memory_overflow == true)\n+                    level = OGS_LOG_ERROR;\n+\n+                ogs_log_message(level, 0, \"[%d:%s] %s\",\n                         response->status, response->h.method, response->h.uri);\n \n                 if (conn->memory) {\n@@ -56,16 +68,17 @@\n                     ogs_assert(response->http.content_length);\n                 }\n \n-                ogs_debug(\"RECEIVED[%d]\", (int)response->http.content_length);\n+                ogs_log_message(level, 0, \"RECEIVED[%d]\",\n+                        (int)response->http.content_length);\n                 if (response->http.content_length && response->http.content)\n-                    ogs_debug(\"%s\", response->http.content);\n+                    ogs_log_message(level, 0, \"%s\", response->http.content);\n \n-                if (content_type)\n-                    ogs_sbi_header_set(response->http.headers,\n-                            OGS_SBI_CONTENT_TYPE, content_type);\n-                if (conn->location)\n-                    ogs_sbi_header_set(response->http.headers,\n-                            OGS_SBI_LOCATION, conn->location);\n+                if (conn->memory_overflow == true) {\n+                    ogs_sbi_response_free(response);\n+                    connection_remove(conn);\n+                    break;\n+                }\n+\n             } else\n                 ogs_warn(\"[%d] %s\", res, conn->error);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                ogs_debug(\"[%d:%s] %s\",",
                "                ogs_debug(\"RECEIVED[%d]\", (int)response->http.content_length);",
                "                    ogs_debug(\"%s\", response->http.content);",
                "                if (content_type)",
                "                    ogs_sbi_header_set(response->http.headers,",
                "                            OGS_SBI_CONTENT_TYPE, content_type);",
                "                if (conn->location)",
                "                    ogs_sbi_header_set(response->http.headers,",
                "                            OGS_SBI_LOCATION, conn->location);"
            ],
            "added_lines": [
                "                ogs_log_level_e level = OGS_LOG_DEBUG;",
                "",
                "                if (content_type)",
                "                    ogs_sbi_header_set(response->http.headers,",
                "                            OGS_SBI_CONTENT_TYPE, content_type);",
                "                if (conn->location)",
                "                    ogs_sbi_header_set(response->http.headers,",
                "                            OGS_SBI_LOCATION, conn->location);",
                "",
                "                if (conn->memory_overflow == true)",
                "                    level = OGS_LOG_ERROR;",
                "",
                "                ogs_log_message(level, 0, \"[%d:%s] %s\",",
                "                ogs_log_message(level, 0, \"RECEIVED[%d]\",",
                "                        (int)response->http.content_length);",
                "                    ogs_log_message(level, 0, \"%s\", response->http.content);",
                "                if (conn->memory_overflow == true) {",
                "                    ogs_sbi_response_free(response);",
                "                    connection_remove(conn);",
                "                    break;",
                "                }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3299",
        "func_name": "open5gs/write_cb",
        "description": "A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88",
        "commit_title": "Fixed HTTP2 crashes for random JSON data (#1769)",
        "commit_text": "",
        "func_before": "static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n\n    conn = data;\n    ogs_assert(conn);\n\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n        ogs_assert_if_reached();\n        return 0;\n    }\n\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n\n    return realsize;\n}",
        "func": "static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n\n    conn = data;\n    ogs_assert(conn);\n\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        conn->memory_overflow = true;\n\n        ogs_error(\"Overflow : conn->size[%d], realsize[%d]\",\n                    (int)conn->size, (int)realsize);\n        ogs_log_hexdump(OGS_LOG_ERROR, contents, realsize);\n\n        return 0;\n    }\n\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n\n    return realsize;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,12 @@\n     realsize = size * nmemb;\n     ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n     if(!ptr) {\n-        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n-        ogs_assert_if_reached();\n+        conn->memory_overflow = true;\n+\n+        ogs_error(\"Overflow : conn->size[%d], realsize[%d]\",\n+                    (int)conn->size, (int)realsize);\n+        ogs_log_hexdump(OGS_LOG_ERROR, contents, realsize);\n+\n         return 0;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        ogs_fatal(\"not enough memory (realloc returned NULL)\");",
                "        ogs_assert_if_reached();"
            ],
            "added_lines": [
                "        conn->memory_overflow = true;",
                "",
                "        ogs_error(\"Overflow : conn->size[%d], realsize[%d]\",",
                "                    (int)conn->size, (int)realsize);",
                "        ogs_log_hexdump(OGS_LOG_ERROR, contents, realsize);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3299",
        "func_name": "open5gs/on_data_chunk_recv",
        "description": "A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88",
        "commit_title": "Fixed HTTP2 crashes for random JSON data (#1769)",
        "commit_text": "",
        "func_before": "static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    size_t offset = 0;\n\n    ogs_assert(session);\n\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return 0;\n    }\n\n    request = stream->request;\n    ogs_assert(request);\n\n    ogs_assert(data);\n    ogs_assert(len);\n\n    if (request->http.content == NULL) {\n        request->http.content_length = len;\n        request->http.content =\n            (char*)ogs_malloc(request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    } else {\n        offset = request->http.content_length;\n        if ((request->http.content_length + len) > OGS_HUGE_LEN) {\n            ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n                        (int)request->http.content_length, (int)len);\n            ogs_assert_if_reached();\n        }\n        request->http.content_length += len;\n        request->http.content = (char *)ogs_realloc(\n                request->http.content, request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    }\n\n    memcpy(request->http.content + offset, data, len);\n    request->http.content[request->http.content_length] = '\\0';\n\n    return 0;\n}",
        "func": "static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    size_t offset = 0;\n\n    ogs_assert(session);\n\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return 0;\n    }\n\n    request = stream->request;\n    ogs_assert(request);\n\n    ogs_assert(data);\n    ogs_assert(len);\n\n    if (request->http.content == NULL) {\n        ogs_assert(request->http.content_length == 0);\n        ogs_assert(offset == 0);\n\n        request->http.content = (char*)ogs_malloc(len + 1);\n    } else {\n        ogs_assert(request->http.content_length != 0);\n\n        request->http.content = (char*)ogs_realloc(\n                request->http.content, request->http.content_length + len + 1);\n    }\n\n    if (!request->http.content) {\n        stream->memory_overflow = true;\n\n        ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n                    (int)request->http.content_length, (int)len);\n        ogs_log_hexdump(OGS_LOG_ERROR, data, len);\n\n        return 0;\n    }\n\n    offset = request->http.content_length;\n    request->http.content_length += len;\n\n    memcpy(request->http.content + offset, data, len);\n    request->http.content[request->http.content_length] = '\\0';\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,22 +22,29 @@\n     ogs_assert(len);\n \n     if (request->http.content == NULL) {\n-        request->http.content_length = len;\n-        request->http.content =\n-            (char*)ogs_malloc(request->http.content_length + 1);\n-        ogs_assert(request->http.content);\n+        ogs_assert(request->http.content_length == 0);\n+        ogs_assert(offset == 0);\n+\n+        request->http.content = (char*)ogs_malloc(len + 1);\n     } else {\n-        offset = request->http.content_length;\n-        if ((request->http.content_length + len) > OGS_HUGE_LEN) {\n-            ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n-                        (int)request->http.content_length, (int)len);\n-            ogs_assert_if_reached();\n-        }\n-        request->http.content_length += len;\n-        request->http.content = (char *)ogs_realloc(\n-                request->http.content, request->http.content_length + 1);\n-        ogs_assert(request->http.content);\n+        ogs_assert(request->http.content_length != 0);\n+\n+        request->http.content = (char*)ogs_realloc(\n+                request->http.content, request->http.content_length + len + 1);\n     }\n+\n+    if (!request->http.content) {\n+        stream->memory_overflow = true;\n+\n+        ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n+                    (int)request->http.content_length, (int)len);\n+        ogs_log_hexdump(OGS_LOG_ERROR, data, len);\n+\n+        return 0;\n+    }\n+\n+    offset = request->http.content_length;\n+    request->http.content_length += len;\n \n     memcpy(request->http.content + offset, data, len);\n     request->http.content[request->http.content_length] = '\\0';",
        "diff_line_info": {
            "deleted_lines": [
                "        request->http.content_length = len;",
                "        request->http.content =",
                "            (char*)ogs_malloc(request->http.content_length + 1);",
                "        ogs_assert(request->http.content);",
                "        offset = request->http.content_length;",
                "        if ((request->http.content_length + len) > OGS_HUGE_LEN) {",
                "            ogs_error(\"Overflow : Content-Length[%d], len[%d]\",",
                "                        (int)request->http.content_length, (int)len);",
                "            ogs_assert_if_reached();",
                "        }",
                "        request->http.content_length += len;",
                "        request->http.content = (char *)ogs_realloc(",
                "                request->http.content, request->http.content_length + 1);",
                "        ogs_assert(request->http.content);"
            ],
            "added_lines": [
                "        ogs_assert(request->http.content_length == 0);",
                "        ogs_assert(offset == 0);",
                "",
                "        request->http.content = (char*)ogs_malloc(len + 1);",
                "        ogs_assert(request->http.content_length != 0);",
                "",
                "        request->http.content = (char*)ogs_realloc(",
                "                request->http.content, request->http.content_length + len + 1);",
                "",
                "    if (!request->http.content) {",
                "        stream->memory_overflow = true;",
                "",
                "        ogs_error(\"Overflow : Content-Length[%d], len[%d]\",",
                "                    (int)request->http.content_length, (int)len);",
                "        ogs_log_hexdump(OGS_LOG_ERROR, data, len);",
                "",
                "        return 0;",
                "    }",
                "",
                "    offset = request->http.content_length;",
                "    request->http.content_length += len;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3299",
        "func_name": "open5gs/on_frame_recv",
        "description": "A vulnerability was found in Open5GS up to 2.4.10. It has been declared as problematic. Affected by this vulnerability is an unknown functionality in the library lib/sbi/client.c of the component AMF. The manipulation leads to denial of service. The attack can be launched remotely. The name of the patch is 724fa568435dae45ef0c3a48b2aabde052afae88. It is recommended to apply a patch to fix this issue. The identifier VDB-209545 was assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/724fa568435dae45ef0c3a48b2aabde052afae88",
        "commit_title": "Fixed HTTP2 crashes for random JSON data (#1769)",
        "commit_text": "",
        "func_before": "static int on_frame_recv(nghttp2_session *session,\n                         const nghttp2_frame *frame, void *user_data)\n{\n    int rv;\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_sbi_server_t *server = NULL;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    ogs_assert(sbi_sess);\n    server = sbi_sess->server;\n    ogs_assert(server);\n    ogs_assert(server->cb);\n\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);\n    if (!stream) {\n        if (frame->hd.type == NGHTTP2_SETTINGS) {\n            sbi_sess->settings.max_concurrent_streams =\n                nghttp2_session_get_remote_settings(\n                    session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);\n            sbi_sess->settings.enable_push =\n                nghttp2_session_get_remote_settings(\n                    session, NGHTTP2_SETTINGS_ENABLE_PUSH);\n            ogs_debug(\"MAX_CONCURRENT_STREAMS = %d\",\n                sbi_sess->settings.max_concurrent_streams);\n            ogs_debug(\"ENABLE_PUSH = %s\",\n                sbi_sess->settings.enable_push ? \"TRUE\" : \"false\");\n\n        } else if (frame->hd.type == NGHTTP2_GOAWAY) {\n            rv = nghttp2_submit_goaway(\n                 session, NGHTTP2_FLAG_NONE, sbi_sess->last_stream_id,\n                 NGHTTP2_NO_ERROR, NULL, 0);\n            if (rv != 0) {\n                ogs_error(\"nghttp2_submit_goaway() failed (%d:%s)\",\n                            rv, nghttp2_strerror(rv));\n                return OGS_ERROR;\n            }\n\n            session_send(sbi_sess);\n        }\n        return 0;\n    }\n\n    request = stream->request;\n    ogs_assert(request);\n\n    switch (frame->hd.type) {\n    case NGHTTP2_HEADERS:\n        if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {\n            const char *expect100 =\n                ogs_sbi_header_get(request->http.headers, OGS_SBI_EXPECT);\n            if (expect100 && ogs_strcasecmp(expect100, \"100-continue\") == 0) {\n                nghttp2_nv nva;\n\n                add_header(&nva, \":status\", status_string[100]);\n                rv = nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE,\n                           stream->stream_id, NULL, &nva, 1, NULL);\n                if (rv != 0) {\n                    ogs_error(\"nghttp2_submit_headers() failed (%d:%s)\",\n                            rv, nghttp2_strerror(rv));\n                    nghttp2_submit_rst_stream(\n                            session, NGHTTP2_FLAG_NONE, stream->stream_id, rv);\n                    return 0;\n                }\n            }\n        }\n        /* fallthrough */\n        OGS_GNUC_FALLTHROUGH;\n\n    case NGHTTP2_DATA:\n        /* HEADERS or DATA frame with +END_STREAM flag */\n        if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n\n            ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n\n            if (request->http.content_length && request->http.content) {\n                ogs_debug(\"RECEIVED: %d\", (int)request->http.content_length);\n                ogs_debug(\"%s\", request->http.content);\n            }\n\n            if (server->cb(request, stream) != OGS_OK) {\n                ogs_warn(\"server callback error\");\n                ogs_assert(true ==\n                    ogs_sbi_server_send_error(stream,\n                        OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR, NULL,\n                        \"server callback error\", NULL));\n\n                return 0;\n            }\n            break;\n        }\n    default:\n        break;\n    }\n\n    return 0;\n}",
        "func": "static int on_frame_recv(nghttp2_session *session,\n                         const nghttp2_frame *frame, void *user_data)\n{\n    int rv;\n    ogs_sbi_session_t *sbi_sess = user_data;\n\n    ogs_sbi_server_t *server = NULL;\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n\n    ogs_assert(sbi_sess);\n    server = sbi_sess->server;\n    ogs_assert(server);\n    ogs_assert(server->cb);\n\n    ogs_assert(session);\n    ogs_assert(frame);\n\n    stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);\n    if (!stream) {\n        if (frame->hd.type == NGHTTP2_SETTINGS) {\n            sbi_sess->settings.max_concurrent_streams =\n                nghttp2_session_get_remote_settings(\n                    session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);\n            sbi_sess->settings.enable_push =\n                nghttp2_session_get_remote_settings(\n                    session, NGHTTP2_SETTINGS_ENABLE_PUSH);\n            ogs_debug(\"MAX_CONCURRENT_STREAMS = %d\",\n                sbi_sess->settings.max_concurrent_streams);\n            ogs_debug(\"ENABLE_PUSH = %s\",\n                sbi_sess->settings.enable_push ? \"TRUE\" : \"false\");\n\n        } else if (frame->hd.type == NGHTTP2_GOAWAY) {\n            rv = nghttp2_submit_goaway(\n                 session, NGHTTP2_FLAG_NONE, sbi_sess->last_stream_id,\n                 NGHTTP2_NO_ERROR, NULL, 0);\n            if (rv != 0) {\n                ogs_error(\"nghttp2_submit_goaway() failed (%d:%s)\",\n                            rv, nghttp2_strerror(rv));\n                return OGS_ERROR;\n            }\n\n            session_send(sbi_sess);\n        }\n        return 0;\n    }\n\n    request = stream->request;\n    ogs_assert(request);\n\n    switch (frame->hd.type) {\n    case NGHTTP2_HEADERS:\n        if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) {\n            const char *expect100 =\n                ogs_sbi_header_get(request->http.headers, OGS_SBI_EXPECT);\n            if (expect100 && ogs_strcasecmp(expect100, \"100-continue\") == 0) {\n                nghttp2_nv nva;\n\n                add_header(&nva, \":status\", status_string[100]);\n                rv = nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE,\n                           stream->stream_id, NULL, &nva, 1, NULL);\n                if (rv != 0) {\n                    ogs_error(\"nghttp2_submit_headers() failed (%d:%s)\",\n                            rv, nghttp2_strerror(rv));\n                    nghttp2_submit_rst_stream(\n                            session, NGHTTP2_FLAG_NONE, stream->stream_id, rv);\n                    return 0;\n                }\n            }\n        }\n        /* fallthrough */\n        OGS_GNUC_FALLTHROUGH;\n\n    case NGHTTP2_DATA:\n        /* HEADERS or DATA frame with +END_STREAM flag */\n        if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n            ogs_log_level_e level = OGS_LOG_DEBUG;\n\n            if (stream->memory_overflow == true)\n                level = OGS_LOG_ERROR;\n\n            ogs_log_message(level, 0,\n                    \"[%s] %s\", request->h.method, request->h.uri);\n\n            if (request->http.content_length && request->http.content) {\n                ogs_log_message(level, 0,\n                        \"RECEIVED: %d\", (int)request->http.content_length);\n                ogs_log_message(level, 0, \"%s\", request->http.content);\n            }\n\n            if (stream->memory_overflow == true) {\n                ogs_error(\"[DROP] Overflow\");\n                break;\n            }\n\n            if (server->cb(request, stream) != OGS_OK) {\n                ogs_warn(\"server callback error\");\n                ogs_assert(true ==\n                    ogs_sbi_server_send_error(stream,\n                        OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR, NULL,\n                        \"server callback error\", NULL));\n\n                return 0;\n            }\n            break;\n        }\n    default:\n        break;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -74,12 +74,23 @@\n     case NGHTTP2_DATA:\n         /* HEADERS or DATA frame with +END_STREAM flag */\n         if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n+            ogs_log_level_e level = OGS_LOG_DEBUG;\n \n-            ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);\n+            if (stream->memory_overflow == true)\n+                level = OGS_LOG_ERROR;\n+\n+            ogs_log_message(level, 0,\n+                    \"[%s] %s\", request->h.method, request->h.uri);\n \n             if (request->http.content_length && request->http.content) {\n-                ogs_debug(\"RECEIVED: %d\", (int)request->http.content_length);\n-                ogs_debug(\"%s\", request->http.content);\n+                ogs_log_message(level, 0,\n+                        \"RECEIVED: %d\", (int)request->http.content_length);\n+                ogs_log_message(level, 0, \"%s\", request->http.content);\n+            }\n+\n+            if (stream->memory_overflow == true) {\n+                ogs_error(\"[DROP] Overflow\");\n+                break;\n             }\n \n             if (server->cb(request, stream) != OGS_OK) {",
        "diff_line_info": {
            "deleted_lines": [
                "            ogs_debug(\"[%s] %s\", request->h.method, request->h.uri);",
                "                ogs_debug(\"RECEIVED: %d\", (int)request->http.content_length);",
                "                ogs_debug(\"%s\", request->http.content);"
            ],
            "added_lines": [
                "            ogs_log_level_e level = OGS_LOG_DEBUG;",
                "            if (stream->memory_overflow == true)",
                "                level = OGS_LOG_ERROR;",
                "",
                "            ogs_log_message(level, 0,",
                "                    \"[%s] %s\", request->h.method, request->h.uri);",
                "                ogs_log_message(level, 0,",
                "                        \"RECEIVED: %d\", (int)request->http.content_length);",
                "                ogs_log_message(level, 0, \"%s\", request->http.content);",
                "            }",
                "",
                "            if (stream->memory_overflow == true) {",
                "                ogs_error(\"[DROP] Overflow\");",
                "                break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3354",
        "func_name": "open5gs/ogs_tlv_parse_block",
        "description": "A vulnerability has been found in Open5GS up to 2.4.10 and classified as problematic. This vulnerability affects unknown code in the library lib/core/ogs-tlv-msg.c of the component UDP Packet Handler. The manipulation leads to denial of service. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-209686 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/c2f6a020a7b505e0d55748464406fb9aca062026",
        "commit_title": "[TLV] Added more debug information (#1767)",
        "commit_text": "",
        "func_before": "ogs_tlv_t *ogs_tlv_parse_block(uint32_t length, void *data, uint8_t mode)\n{\n    uint8_t *pos = data;\n    uint8_t *blk = data;\n\n    ogs_tlv_t *root = NULL;\n    ogs_tlv_t *prev = NULL;\n    ogs_tlv_t *curr = NULL;\n\n    root = curr = ogs_tlv_get();\n\n    ogs_assert(curr);\n\n    pos = tlv_get_element(curr, pos, mode);\n\n    ogs_assert(pos);\n\n    while(pos - blk < length) {\n        prev = curr;\n\n        curr = ogs_tlv_get();\n        ogs_assert(curr);\n        prev->next = curr;\n\n        pos = tlv_get_element(curr, pos, mode);\n        ogs_assert(pos);\n    }\n\n    ogs_assert(length == (pos - blk));\n\n    return root;\n}",
        "func": "ogs_tlv_t *ogs_tlv_parse_block(uint32_t length, void *data, uint8_t mode)\n{\n    uint8_t *pos = data;\n    uint8_t *blk = data;\n\n    ogs_tlv_t *root = NULL;\n    ogs_tlv_t *prev = NULL;\n    ogs_tlv_t *curr = NULL;\n\n    root = curr = ogs_tlv_get();\n\n    ogs_assert(curr);\n\n    pos = tlv_get_element(curr, pos, mode);\n\n    ogs_assert(pos);\n\n    while(pos - blk < length) {\n        prev = curr;\n\n        curr = ogs_tlv_get();\n        ogs_assert(curr);\n        prev->next = curr;\n\n        pos = tlv_get_element(curr, pos, mode);\n        ogs_assert(pos);\n    }\n\n    if (length != (pos - blk)) {\n        ogs_fatal(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);\n        ogs_log_hexdump(OGS_LOG_FATAL, data, length);\n        ogs_assert_if_reached();\n    }\n\n    return root;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,11 @@\n         ogs_assert(pos);\n     }\n \n-    ogs_assert(length == (pos - blk));\n+    if (length != (pos - blk)) {\n+        ogs_fatal(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);\n+        ogs_log_hexdump(OGS_LOG_FATAL, data, length);\n+        ogs_assert_if_reached();\n+    }\n \n     return root;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    ogs_assert(length == (pos - blk));"
            ],
            "added_lines": [
                "    if (length != (pos - blk)) {",
                "        ogs_fatal(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);",
                "        ogs_log_hexdump(OGS_LOG_FATAL, data, length);",
                "        ogs_assert_if_reached();",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3354",
        "func_name": "open5gs/pfcp_recv_cb",
        "description": "A vulnerability has been found in Open5GS up to 2.4.10 and classified as problematic. This vulnerability affects unknown code in the library lib/core/ogs-tlv-msg.c of the component UDP Packet Handler. The manipulation leads to denial of service. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-209686 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/71a1516b0376340d267caa85920cb0a4da261176",
        "commit_title": "[Security] Fixed a crash for port scanning (#1767)",
        "commit_text": "",
        "func_before": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version > OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}",
        "func": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version != OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n     ogs_pkbuf_trim(pkbuf, size);\n \n     h = (ogs_pfcp_header_t *)pkbuf->data;\n-    if (h->version > OGS_PFCP_VERSION) {\n+    if (h->version != OGS_PFCP_VERSION) {\n         ogs_pfcp_header_t rsp;\n \n         ogs_error(\"Not supported version[%d]\", h->version);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (h->version > OGS_PFCP_VERSION) {"
            ],
            "added_lines": [
                "    if (h->version != OGS_PFCP_VERSION) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3354",
        "func_name": "open5gs/ogs_tlv_parse_block",
        "description": "A vulnerability has been found in Open5GS up to 2.4.10 and classified as problematic. This vulnerability affects unknown code in the library lib/core/ogs-tlv-msg.c of the component UDP Packet Handler. The manipulation leads to denial of service. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-209686 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/71a1516b0376340d267caa85920cb0a4da261176",
        "commit_title": "[Security] Fixed a crash for port scanning (#1767)",
        "commit_text": "",
        "func_before": "ogs_tlv_t *ogs_tlv_parse_block(uint32_t length, void *data, uint8_t mode)\n{\n    uint8_t *pos = data;\n    uint8_t *blk = data;\n\n    ogs_tlv_t *root = NULL;\n    ogs_tlv_t *prev = NULL;\n    ogs_tlv_t *curr = NULL;\n\n    root = curr = ogs_tlv_get();\n\n    ogs_assert(curr);\n\n    pos = tlv_get_element(curr, pos, mode);\n\n    ogs_assert(pos);\n\n    while(pos - blk < length) {\n        prev = curr;\n\n        curr = ogs_tlv_get();\n        ogs_assert(curr);\n        prev->next = curr;\n\n        pos = tlv_get_element(curr, pos, mode);\n        ogs_assert(pos);\n    }\n\n    if (length != (pos - blk)) {\n        ogs_fatal(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);\n        ogs_log_hexdump(OGS_LOG_FATAL, data, length);\n        ogs_assert_if_reached();\n    }\n\n    return root;\n}",
        "func": "ogs_tlv_t *ogs_tlv_parse_block(uint32_t length, void *data, uint8_t mode)\n{\n    uint8_t *pos = data;\n    uint8_t *blk = data;\n\n    ogs_tlv_t *root = NULL;\n    ogs_tlv_t *prev = NULL;\n    ogs_tlv_t *curr = NULL;\n\n    root = curr = ogs_tlv_get();\n\n    ogs_assert(curr);\n\n    pos = tlv_get_element(curr, pos, mode);\n\n    ogs_assert(pos);\n\n    while(pos - blk < length) {\n        prev = curr;\n\n        curr = ogs_tlv_get();\n        ogs_assert(curr);\n        prev->next = curr;\n\n        pos = tlv_get_element(curr, pos, mode);\n        ogs_assert(pos);\n    }\n\n    if (length != (pos - blk)) {\n        ogs_error(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);\n        ogs_error(\"POS[%p] BLK[%p] POS-BLK[%d]\", pos, blk, (int)(pos - blk));\n        ogs_log_hexdump(OGS_LOG_FATAL, data, length);\n\n        ogs_tlv_free_all(root);\n        return NULL;\n    }\n\n    return root;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,9 +27,12 @@\n     }\n \n     if (length != (pos - blk)) {\n-        ogs_fatal(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);\n+        ogs_error(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);\n+        ogs_error(\"POS[%p] BLK[%p] POS-BLK[%d]\", pos, blk, (int)(pos - blk));\n         ogs_log_hexdump(OGS_LOG_FATAL, data, length);\n-        ogs_assert_if_reached();\n+\n+        ogs_tlv_free_all(root);\n+        return NULL;\n     }\n \n     return root;",
        "diff_line_info": {
            "deleted_lines": [
                "        ogs_fatal(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);",
                "        ogs_assert_if_reached();"
            ],
            "added_lines": [
                "        ogs_error(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\", length, mode);",
                "        ogs_error(\"POS[%p] BLK[%p] POS-BLK[%d]\", pos, blk, (int)(pos - blk));",
                "",
                "        ogs_tlv_free_all(root);",
                "        return NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3354",
        "func_name": "open5gs/pfcp_recv_cb",
        "description": "A vulnerability has been found in Open5GS up to 2.4.10 and classified as problematic. This vulnerability affects unknown code in the library lib/core/ogs-tlv-msg.c of the component UDP Packet Handler. The manipulation leads to denial of service. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-209686 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/71a1516b0376340d267caa85920cb0a4da261176",
        "commit_title": "[Security] Fixed a crash for port scanning (#1767)",
        "commit_text": "",
        "func_before": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version > OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}",
        "func": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version != OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n     ogs_pkbuf_trim(pkbuf, size);\n \n     h = (ogs_pfcp_header_t *)pkbuf->data;\n-    if (h->version > OGS_PFCP_VERSION) {\n+    if (h->version != OGS_PFCP_VERSION) {\n         ogs_pfcp_header_t rsp;\n \n         ogs_error(\"Not supported version[%d]\", h->version);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (h->version > OGS_PFCP_VERSION) {"
            ],
            "added_lines": [
                "    if (h->version != OGS_PFCP_VERSION) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3354",
        "func_name": "open5gs/pfcp_recv_cb",
        "description": "A vulnerability has been found in Open5GS up to 2.4.10 and classified as problematic. This vulnerability affects unknown code in the library lib/core/ogs-tlv-msg.c of the component UDP Packet Handler. The manipulation leads to denial of service. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-209686 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/71a1516b0376340d267caa85920cb0a4da261176",
        "commit_title": "[Security] Fixed a crash for port scanning (#1767)",
        "commit_text": "",
        "func_before": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version > OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}",
        "func": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version != OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n     ogs_pkbuf_trim(pkbuf, size);\n \n     h = (ogs_pfcp_header_t *)pkbuf->data;\n-    if (h->version > OGS_PFCP_VERSION) {\n+    if (h->version != OGS_PFCP_VERSION) {\n         ogs_pfcp_header_t rsp;\n \n         ogs_error(\"Not supported version[%d]\", h->version);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (h->version > OGS_PFCP_VERSION) {"
            ],
            "added_lines": [
                "    if (h->version != OGS_PFCP_VERSION) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3354",
        "func_name": "open5gs/pfcp_recv_cb",
        "description": "A vulnerability has been found in Open5GS up to 2.4.10 and classified as problematic. This vulnerability affects unknown code in the library lib/core/ogs-tlv-msg.c of the component UDP Packet Handler. The manipulation leads to denial of service. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-209686 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/71a1516b0376340d267caa85920cb0a4da261176",
        "commit_title": "[Security] Fixed a crash for port scanning (#1767)",
        "commit_text": "",
        "func_before": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version > OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}",
        "func": "static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data)\n{\n    int rv;\n\n    ssize_t size;\n    sgwc_event_t *e = NULL;\n    ogs_pkbuf_t *pkbuf = NULL;\n    ogs_sockaddr_t from;\n    ogs_pfcp_node_t *node = NULL;\n    ogs_pfcp_header_t *h = NULL;\n\n    ogs_assert(fd != INVALID_SOCKET);\n\n    pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN);\n\n    size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);\n    if (size <= 0) {\n        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                \"ogs_recvfrom() failed\");\n        ogs_pkbuf_free(pkbuf);\n        return;\n    }\n\n    ogs_pkbuf_trim(pkbuf, size);\n\n    h = (ogs_pfcp_header_t *)pkbuf->data;\n    if (h->version != OGS_PFCP_VERSION) {\n        ogs_pfcp_header_t rsp;\n\n        ogs_error(\"Not supported version[%d]\", h->version);\n\n        memset(&rsp, 0, sizeof rsp);\n        rsp.flags = (OGS_PFCP_VERSION << 5);\n        rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE;\n        rsp.length = htobe16(4);\n        rsp.sqn_only = h->sqn_only;\n        if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) {\n            ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,\n                    \"ogs_sendto() failed\");\n        }\n        ogs_pkbuf_free(pkbuf);\n\n        return;\n    }\n\n    e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE);\n    ogs_assert(e);\n\n    node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from);\n    if (!node) {\n        node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from);\n        ogs_assert(node);\n\n        node->sock = data;\n        pfcp_node_fsm_init(node, false);\n    }\n    e->pfcp_node = node;\n    e->pkbuf = pkbuf;\n\n    rv = ogs_queue_push(ogs_app()->queue, e);\n    if (rv != OGS_OK) {\n        ogs_error(\"ogs_queue_push() failed:%d\", (int)rv);\n        ogs_pkbuf_free(e->pkbuf);\n        sgwc_event_free(e);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n     ogs_pkbuf_trim(pkbuf, size);\n \n     h = (ogs_pfcp_header_t *)pkbuf->data;\n-    if (h->version > OGS_PFCP_VERSION) {\n+    if (h->version != OGS_PFCP_VERSION) {\n         ogs_pfcp_header_t rsp;\n \n         ogs_error(\"Not supported version[%d]\", h->version);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (h->version > OGS_PFCP_VERSION) {"
            ],
            "added_lines": [
                "    if (h->version != OGS_PFCP_VERSION) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3354",
        "func_name": "open5gs/ogs_tlv_parse_block_desc",
        "description": "A vulnerability has been found in Open5GS up to 2.4.10 and classified as problematic. This vulnerability affects unknown code in the library lib/core/ogs-tlv-msg.c of the component UDP Packet Handler. The manipulation leads to denial of service. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-209686 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/open5gs/open5gs/commit/71a1516b0376340d267caa85920cb0a4da261176",
        "commit_title": "[Security] Fixed a crash for port scanning (#1767)",
        "commit_text": "",
        "func_before": "static ogs_tlv_t *ogs_tlv_parse_block_desc(uint32_t length, void *data, uint8_t msg_mode, ogs_tlv_desc_t *desc)\n{\n    uint8_t *pos = data;\n    uint8_t *blk = data;\n\n    ogs_tlv_t *root = NULL;\n    ogs_tlv_t *prev = NULL;\n    ogs_tlv_t *curr = NULL;\n\n    root = curr = ogs_tlv_get();\n\n    ogs_assert(curr);\n\n    pos = tlv_get_element_desc(curr, pos, msg_mode, desc);\n\n    ogs_assert(pos);\n\n    while(pos - blk < length) {\n        prev = curr;\n\n        curr = ogs_tlv_get();\n        ogs_assert(curr);\n        prev->next = curr;\n\n        pos = tlv_get_element_desc(curr, pos, msg_mode, desc);\n        ogs_assert(pos);\n    }\n\n    ogs_assert(length == (pos - blk));\n\n    return root;\n}",
        "func": "static ogs_tlv_t *ogs_tlv_parse_block_desc(uint32_t length, void *data, uint8_t msg_mode, ogs_tlv_desc_t *desc)\n{\n    uint8_t *pos = data;\n    uint8_t *blk = data;\n\n    ogs_tlv_t *root = NULL;\n    ogs_tlv_t *prev = NULL;\n    ogs_tlv_t *curr = NULL;\n\n    root = curr = ogs_tlv_get();\n\n    ogs_assert(curr);\n\n    pos = tlv_get_element_desc(curr, pos, msg_mode, desc);\n\n    ogs_assert(pos);\n\n    while(pos - blk < length) {\n        prev = curr;\n\n        curr = ogs_tlv_get();\n        ogs_assert(curr);\n        prev->next = curr;\n\n        pos = tlv_get_element_desc(curr, pos, msg_mode, desc);\n        ogs_assert(pos);\n    }\n\n    if (length != (pos - blk)) {\n        ogs_error(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\",\n                length, msg_mode);\n        ogs_error(\"POS[%p] BLK[%p] POS-BLK[%d]\", pos, blk, (int)(pos - blk));\n        ogs_log_hexdump(OGS_LOG_FATAL, data, length);\n\n        ogs_tlv_free_all(root);\n        return NULL;\n    }\n\n    return root;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,15 @@\n         ogs_assert(pos);\n     }\n \n-    ogs_assert(length == (pos - blk));\n+    if (length != (pos - blk)) {\n+        ogs_error(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\",\n+                length, msg_mode);\n+        ogs_error(\"POS[%p] BLK[%p] POS-BLK[%d]\", pos, blk, (int)(pos - blk));\n+        ogs_log_hexdump(OGS_LOG_FATAL, data, length);\n+\n+        ogs_tlv_free_all(root);\n+        return NULL;\n+    }\n \n     return root;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    ogs_assert(length == (pos - blk));"
            ],
            "added_lines": [
                "    if (length != (pos - blk)) {",
                "        ogs_error(\"ogs_tlv_parse_block() failed[LEN:%d,MODE:%d]\",",
                "                length, msg_mode);",
                "        ogs_error(\"POS[%p] BLK[%p] POS-BLK[%d]\", pos, blk, (int)(pos - blk));",
                "        ogs_log_hexdump(OGS_LOG_FATAL, data, length);",
                "",
                "        ogs_tlv_free_all(root);",
                "        return NULL;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3524",
        "func_name": "torvalds/linux/do_ipv6_setsockopt",
        "description": "A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function ipv6_renew_options of the component IPv6 Handler. The manipulation leads to memory leak. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211021 was assigned to this vulnerability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3c52c6bb831f6335c176a0fc7214e26f43adbd11",
        "commit_title": "syzbot reported a memory leak [0] related to IPV6_ADDRFORM.",
        "commit_text": " The scenario is that while one thread is converting an IPv6 socket into IPv4 with IPV6_ADDRFORM, another thread calls do_ipv6_setsockopt() and allocates memory to inet6_sk(sk)->XXX after conversion.  Then, the converted sk with (tcp|udp)_prot never frees the IPv6 resources, which inet6_destroy_sock() should have cleaned up.  setsockopt(IPV6_ADDRFORM)                 setsockopt(IPV6_DSTOPTS) +-----------------------+                 +----------------------+ - do_ipv6_setsockopt(sk, ...)   - sockopt_lock_sock(sk)                 - do_ipv6_setsockopt(sk, ...)     - lock_sock(sk)                         ^._ called via tcpv6_prot   - WRITE_ONCE(sk->sk_prot, &tcp_prot)          before WRITE_ONCE()   - xchg(&np->opt, NULL)   - txopt_put(opt)   - sockopt_release_sock(sk)     - release_sock(sk)                      - sockopt_lock_sock(sk)                                               - lock_sock(sk)                                             - ipv6_set_opt_hdr(sk, ...)                                               - ipv6_update_options(sk, opt)                                                 - xchg(&inet6_sk(sk)->opt, opt)                                                   ^._ opt is never freed.                                              - sockopt_release_sock(sk)                                               - release_sock(sk)  Since IPV6_DSTOPTS allocates options under lock_sock(), we can avoid this memory leak by testing whether sk_family is changed by IPV6_ADDRFORM after acquiring the lock.  This issue exists from the initial commit between IPV6_ADDRFORM and IPV6_PKTOPTIONS.  [0]: BUG: memory leak unreferenced object 0xffff888009ab9f80 (size 96):   comm \"syz-executor583\", pid 328, jiffies 4294916198 (age 13.034s)   hex dump (first 32 bytes):     01 00 00 00 48 00 00 00 08 00 00 00 00 00 00 00  ....H...........     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................   backtrace:     [<000000002ee98ae1>] kmalloc include/linux/slab.h:605 [inline]     [<000000002ee98ae1>] sock_kmalloc+0xb3/0x100 net/core/sock.c:2566     [<0000000065d7b698>] ipv6_renew_options+0x21e/0x10b0 net/ipv6/exthdrs.c:1318     [<00000000a8c756d7>] ipv6_set_opt_hdr net/ipv6/ipv6_sockglue.c:354 [inline]     [<00000000a8c756d7>] do_ipv6_setsockopt.constprop.0+0x28b7/0x4350 net/ipv6/ipv6_sockglue.c:668     [<000000002854d204>] ipv6_setsockopt+0xdf/0x190 net/ipv6/ipv6_sockglue.c:1021     [<00000000e69fdcf8>] tcp_setsockopt+0x13b/0x2620 net/ipv4/tcp.c:3789     [<0000000090da4b9b>] __sys_setsockopt+0x239/0x620 net/socket.c:2252     [<00000000b10d192f>] __do_sys_setsockopt net/socket.c:2263 [inline]     [<00000000b10d192f>] __se_sys_setsockopt net/socket.c:2260 [inline]     [<00000000b10d192f>] __x64_sys_setsockopt+0xbe/0x160 net/socket.c:2260     [<000000000a80d7aa>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]     [<000000000a80d7aa>] do_syscall_64+0x38/0x90 arch/x86/entry/common.c:80     [<000000004562b5c6>] entry_SYSCALL_64_after_hwframe+0x63/0xcd  ",
        "func_before": "int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val, valbool;\n\tint retv = -ENOPROTOOPT;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tif (sockptr_is_null(optval))\n\t\tval = 0;\n\telse {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\tval = 0;\n\t}\n\n\tvalbool = (val != 0);\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_setsockopt(sk, optname, optval, optlen);\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tsockopt_lock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase IPV6_ADDRFORM:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val == PF_INET) {\n\t\t\tstruct ipv6_txoptions *opt;\n\t\t\tstruct sk_buff *pktopt;\n\n\t\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t    sk->sk_protocol == IPPROTO_UDPLITE) {\n\t\t\t\tstruct udp_sock *up = udp_sk(sk);\n\t\t\t\tif (up->pending == AF_INET6) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tif (sk->sk_prot != &tcpv6_prot) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\t\tretv = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ipv6_only_sock(sk) ||\n\t\t\t    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {\n\t\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfl6_free_socklist(sk);\n\t\t\t__ipv6_sock_mc_close(sk);\n\t\t\t__ipv6_sock_ac_close(sk);\n\n\t\t\t/*\n\t\t\t * Sock is moving from IPv6 to IPv4 (sk_prot), so\n\t\t\t * remove it from the refcnt debug socks count in the\n\t\t\t * original family...\n\t\t\t */\n\t\t\tsk_refcnt_debug_dec(sk);\n\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, &tcp_prot, 1);\n\n\t\t\t\t/* Paired with READ_ONCE(sk->sk_prot) in net/ipv6/af_inet6.c */\n\t\t\t\tWRITE_ONCE(sk->sk_prot, &tcp_prot);\n\t\t\t\ticsk->icsk_af_ops = &ipv4_specific;\n\t\t\t\tsk->sk_socket->ops = &inet_stream_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t\t} else {\n\t\t\t\tstruct proto *prot = &udp_prot;\n\n\t\t\t\tif (sk->sk_protocol == IPPROTO_UDPLITE)\n\t\t\t\t\tprot = &udplite_prot;\n\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, prot, 1);\n\n\t\t\t\t/* Paired with READ_ONCE(sk->sk_prot) in net/ipv6/af_inet6.c */\n\t\t\t\tWRITE_ONCE(sk->sk_prot, prot);\n\t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t}\n\t\t\topt = xchg((__force struct ipv6_txoptions **)&np->opt,\n\t\t\t\t   NULL);\n\t\t\tif (opt) {\n\t\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\t\t\ttxopt_put(opt);\n\t\t\t}\n\t\t\tpktopt = xchg(&np->pktoptions, NULL);\n\t\t\tkfree_skb(pktopt);\n\n\t\t\t/*\n\t\t\t * ... and add it to the refcnt debug socks count\n\t\t\t * in the new family. -acme\n\t\t\t */\n\t\t\tsk_refcnt_debug_inc(sk);\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgoto e_inval;\n\n\tcase IPV6_V6ONLY:\n\t\tif (optlen < sizeof(int) ||\n\t\t    inet_sk(sk)->inet_num)\n\t\t\tgoto e_inval;\n\t\tsk->sk_ipv6only = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxoinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxhlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxohlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.srcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.osrcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.hopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.ohopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.dstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.odstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < -1 || val > 0xff)\n\t\t\tgoto e_inval;\n\t\t/* RFC 3542, 6.5: default traffic class of 0x0 */\n\t\tif (val == -1)\n\t\t\tval = 0;\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~INET_ECN_MASK;\n\t\t\tval |= np->tclass & INET_ECN_MASK;\n\t\t}\n\t\tif (np->tclass != val) {\n\t\t\tnp->tclass = val;\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxtclass = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxpmtu = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TRANSPARENT:\n\t\tif (valbool && !sockopt_ns_capable(net->user_ns, CAP_NET_RAW) &&\n\t\t    !sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n\t\t\tretv = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t/* we don't have a separate transparent bit for IPV6 we use the one in the IPv4 socket */\n\t\tinet_sk(sk)->transparent = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FREEBIND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t/* we also don't have a separate freebind bit for IPV6 */\n\t\tinet_sk(sk)->freebind = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxorigdstaddr = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t\tretv = ipv6_set_opt_hdr(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_PKTINFO:\n\t{\n\t\tstruct in6_pktinfo pkt;\n\n\t\tif (optlen == 0)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct in6_pktinfo) ||\n\t\t\t sockptr_is_null(optval))\n\t\t\tgoto e_inval;\n\n\t\tif (copy_from_sockptr(&pkt, optval, sizeof(pkt))) {\n\t\t\tretv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!sk_dev_equal_l3scope(sk, pkt.ipi6_ifindex))\n\t\t\tgoto e_inval;\n\n\t\tnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;\n\t\tnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct ipv6_txoptions *opt = NULL;\n\t\tstruct msghdr msg;\n\t\tstruct flowi6 fl6;\n\t\tstruct ipcm6_cookie ipc6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\n\t\tif (optlen == 0)\n\t\t\tgoto update;\n\n\t\t/* 1K is probably excessive\n\t\t * 1K is surely not enough, 2K per standard header is 16K.\n\t\t */\n\t\tretv = -EINVAL;\n\t\tif (optlen > 64*1024)\n\t\t\tbreak;\n\n\t\topt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);\n\t\tretv = -ENOBUFS;\n\t\tif (!opt)\n\t\t\tbreak;\n\n\t\tmemset(opt, 0, sizeof(*opt));\n\t\trefcount_set(&opt->refcnt, 1);\n\t\topt->tot_len = sizeof(*opt) + optlen;\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(opt + 1, optval, optlen))\n\t\t\tgoto done;\n\n\t\tmsg.msg_controllen = optlen;\n\t\tmsg.msg_control = (void *)(opt+1);\n\t\tipc6.opt = opt;\n\n\t\tretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, &ipc6);\n\t\tif (retv)\n\t\t\tgoto done;\nupdate:\n\t\tretv = 0;\n\t\topt = ipv6_update_options(sk, opt);\ndone:\n\t\tif (opt) {\n\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\t\ttxopt_put(opt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase IPV6_UNICAST_HOPS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->hop_limit = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_HOPS:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val != valbool)\n\t\t\tgoto e_inval;\n\t\tnp->mc_loop = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tnp->ucast_oif = 0;\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(net, ifindex);\n\t\tretv = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\tretv = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tnp->ucast_oif = ifindex;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_IF:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tif (val) {\n\t\t\tstruct net_device *dev;\n\t\t\tint midx;\n\n\t\t\trcu_read_lock();\n\n\t\t\tdev = dev_get_by_index_rcu(net, val);\n\t\t\tif (!dev) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tretv = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmidx = l3mdev_master_ifindex_rcu(dev);\n\n\t\t\trcu_read_unlock();\n\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != val &&\n\t\t\t    (!midx || midx != sk->sk_bound_dev_if))\n\t\t\t\tgoto e_inval;\n\t\t}\n\t\tnp->mcast_oif = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_ADD_MEMBERSHIP)\n\t\t\tretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_JOIN_ANYCAST)\n\t\t\tretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_MULTICAST_ALL:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->mc_all = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t\tif (in_compat_syscall())\n\t\t\tretv = compat_ipv6_mcast_join_leave(sk, optname, optval,\n\t\t\t\t\t\t\t    optlen);\n\t\telse\n\t\t\tretv = ipv6_mcast_join_leave(sk, optname, optval,\n\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t\tretv = do_ipv6_mcast_group_source(sk, optname, optval, optlen);\n\t\tbreak;\n\tcase MCAST_MSFILTER:\n\t\tif (in_compat_syscall())\n\t\t\tretv = compat_ipv6_set_mcast_msfilter(sk, optval,\n\t\t\t\t\t\t\t      optlen);\n\t\telse\n\t\t\tretv = ipv6_set_mcast_msfilter(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_ROUTER_ALERT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = ip6_ra_control(sk, val);\n\t\tbreak;\n\tcase IPV6_ROUTER_ALERT_ISOLATE:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rtalert_isolate = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU_DISCOVER:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tnp->pmtudisc = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val && val < IPV6_MIN_MTU)\n\t\t\tgoto e_inval;\n\t\tnp->frag_size = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->recverr = valbool;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWINFO_SEND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->sndflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWLABEL_MGR:\n\t\tretv = ipv6_flowlabel_opt(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_IPSEC_POLICY:\n\tcase IPV6_XFRM_POLICY:\n\t\tretv = -EPERM;\n\t\tif (!sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tretv = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = __ip6_sock_set_addr_preferences(sk, val);\n\t\tbreak;\n\tcase IPV6_MINHOPCOUNT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\n\t\tif (val)\n\t\t\tstatic_branch_enable(&ip6_min_hopcount);\n\n\t\t/* tcp_v6_err() and tcp_v6_rcv() might read min_hopcount\n\t\t * while we are changing it.\n\t\t */\n\t\tWRITE_ONCE(np->min_hopcount, val);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_DONTFRAG:\n\t\tnp->dontfrag = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tnp->autoflowlabel = valbool;\n\t\tnp->autoflowlabel_set = 1;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVFRAGSIZE:\n\t\tnp->rxopt.bits.recvfragsize = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR_RFC4884:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 1)\n\t\t\tgoto e_inval;\n\t\tnp->recverr_rfc4884 = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tsockopt_release_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\n\treturn retv;\n\ne_inval:\n\tsockopt_release_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}",
        "func": "int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val, valbool;\n\tint retv = -ENOPROTOOPT;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tif (sockptr_is_null(optval))\n\t\tval = 0;\n\telse {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\tval = 0;\n\t}\n\n\tvalbool = (val != 0);\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_setsockopt(sk, optname, optval, optlen);\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tsockopt_lock_sock(sk);\n\n\t/* Another thread has converted the socket into IPv4 with\n\t * IPV6_ADDRFORM concurrently.\n\t */\n\tif (unlikely(sk->sk_family != AF_INET6))\n\t\tgoto unlock;\n\n\tswitch (optname) {\n\n\tcase IPV6_ADDRFORM:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val == PF_INET) {\n\t\t\tstruct ipv6_txoptions *opt;\n\t\t\tstruct sk_buff *pktopt;\n\n\t\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t    sk->sk_protocol == IPPROTO_UDPLITE) {\n\t\t\t\tstruct udp_sock *up = udp_sk(sk);\n\t\t\t\tif (up->pending == AF_INET6) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tif (sk->sk_prot != &tcpv6_prot) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\t\tretv = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ipv6_only_sock(sk) ||\n\t\t\t    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {\n\t\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfl6_free_socklist(sk);\n\t\t\t__ipv6_sock_mc_close(sk);\n\t\t\t__ipv6_sock_ac_close(sk);\n\n\t\t\t/*\n\t\t\t * Sock is moving from IPv6 to IPv4 (sk_prot), so\n\t\t\t * remove it from the refcnt debug socks count in the\n\t\t\t * original family...\n\t\t\t */\n\t\t\tsk_refcnt_debug_dec(sk);\n\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, &tcp_prot, 1);\n\n\t\t\t\t/* Paired with READ_ONCE(sk->sk_prot) in net/ipv6/af_inet6.c */\n\t\t\t\tWRITE_ONCE(sk->sk_prot, &tcp_prot);\n\t\t\t\ticsk->icsk_af_ops = &ipv4_specific;\n\t\t\t\tsk->sk_socket->ops = &inet_stream_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t\t} else {\n\t\t\t\tstruct proto *prot = &udp_prot;\n\n\t\t\t\tif (sk->sk_protocol == IPPROTO_UDPLITE)\n\t\t\t\t\tprot = &udplite_prot;\n\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, prot, 1);\n\n\t\t\t\t/* Paired with READ_ONCE(sk->sk_prot) in net/ipv6/af_inet6.c */\n\t\t\t\tWRITE_ONCE(sk->sk_prot, prot);\n\t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t}\n\t\t\topt = xchg((__force struct ipv6_txoptions **)&np->opt,\n\t\t\t\t   NULL);\n\t\t\tif (opt) {\n\t\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\t\t\ttxopt_put(opt);\n\t\t\t}\n\t\t\tpktopt = xchg(&np->pktoptions, NULL);\n\t\t\tkfree_skb(pktopt);\n\n\t\t\t/*\n\t\t\t * ... and add it to the refcnt debug socks count\n\t\t\t * in the new family. -acme\n\t\t\t */\n\t\t\tsk_refcnt_debug_inc(sk);\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgoto e_inval;\n\n\tcase IPV6_V6ONLY:\n\t\tif (optlen < sizeof(int) ||\n\t\t    inet_sk(sk)->inet_num)\n\t\t\tgoto e_inval;\n\t\tsk->sk_ipv6only = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxoinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxhlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxohlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.srcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.osrcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.hopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.ohopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.dstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.odstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < -1 || val > 0xff)\n\t\t\tgoto e_inval;\n\t\t/* RFC 3542, 6.5: default traffic class of 0x0 */\n\t\tif (val == -1)\n\t\t\tval = 0;\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~INET_ECN_MASK;\n\t\t\tval |= np->tclass & INET_ECN_MASK;\n\t\t}\n\t\tif (np->tclass != val) {\n\t\t\tnp->tclass = val;\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxtclass = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxpmtu = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TRANSPARENT:\n\t\tif (valbool && !sockopt_ns_capable(net->user_ns, CAP_NET_RAW) &&\n\t\t    !sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n\t\t\tretv = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t/* we don't have a separate transparent bit for IPV6 we use the one in the IPv4 socket */\n\t\tinet_sk(sk)->transparent = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FREEBIND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t/* we also don't have a separate freebind bit for IPV6 */\n\t\tinet_sk(sk)->freebind = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxorigdstaddr = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t\tretv = ipv6_set_opt_hdr(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_PKTINFO:\n\t{\n\t\tstruct in6_pktinfo pkt;\n\n\t\tif (optlen == 0)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct in6_pktinfo) ||\n\t\t\t sockptr_is_null(optval))\n\t\t\tgoto e_inval;\n\n\t\tif (copy_from_sockptr(&pkt, optval, sizeof(pkt))) {\n\t\t\tretv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!sk_dev_equal_l3scope(sk, pkt.ipi6_ifindex))\n\t\t\tgoto e_inval;\n\n\t\tnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;\n\t\tnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct ipv6_txoptions *opt = NULL;\n\t\tstruct msghdr msg;\n\t\tstruct flowi6 fl6;\n\t\tstruct ipcm6_cookie ipc6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\n\t\tif (optlen == 0)\n\t\t\tgoto update;\n\n\t\t/* 1K is probably excessive\n\t\t * 1K is surely not enough, 2K per standard header is 16K.\n\t\t */\n\t\tretv = -EINVAL;\n\t\tif (optlen > 64*1024)\n\t\t\tbreak;\n\n\t\topt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);\n\t\tretv = -ENOBUFS;\n\t\tif (!opt)\n\t\t\tbreak;\n\n\t\tmemset(opt, 0, sizeof(*opt));\n\t\trefcount_set(&opt->refcnt, 1);\n\t\topt->tot_len = sizeof(*opt) + optlen;\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(opt + 1, optval, optlen))\n\t\t\tgoto done;\n\n\t\tmsg.msg_controllen = optlen;\n\t\tmsg.msg_control = (void *)(opt+1);\n\t\tipc6.opt = opt;\n\n\t\tretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, &ipc6);\n\t\tif (retv)\n\t\t\tgoto done;\nupdate:\n\t\tretv = 0;\n\t\topt = ipv6_update_options(sk, opt);\ndone:\n\t\tif (opt) {\n\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\t\ttxopt_put(opt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase IPV6_UNICAST_HOPS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->hop_limit = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_HOPS:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val != valbool)\n\t\t\tgoto e_inval;\n\t\tnp->mc_loop = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tnp->ucast_oif = 0;\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(net, ifindex);\n\t\tretv = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\tretv = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tnp->ucast_oif = ifindex;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_IF:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tif (val) {\n\t\t\tstruct net_device *dev;\n\t\t\tint midx;\n\n\t\t\trcu_read_lock();\n\n\t\t\tdev = dev_get_by_index_rcu(net, val);\n\t\t\tif (!dev) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tretv = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmidx = l3mdev_master_ifindex_rcu(dev);\n\n\t\t\trcu_read_unlock();\n\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != val &&\n\t\t\t    (!midx || midx != sk->sk_bound_dev_if))\n\t\t\t\tgoto e_inval;\n\t\t}\n\t\tnp->mcast_oif = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_ADD_MEMBERSHIP)\n\t\t\tretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_JOIN_ANYCAST)\n\t\t\tretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_MULTICAST_ALL:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->mc_all = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t\tif (in_compat_syscall())\n\t\t\tretv = compat_ipv6_mcast_join_leave(sk, optname, optval,\n\t\t\t\t\t\t\t    optlen);\n\t\telse\n\t\t\tretv = ipv6_mcast_join_leave(sk, optname, optval,\n\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t\tretv = do_ipv6_mcast_group_source(sk, optname, optval, optlen);\n\t\tbreak;\n\tcase MCAST_MSFILTER:\n\t\tif (in_compat_syscall())\n\t\t\tretv = compat_ipv6_set_mcast_msfilter(sk, optval,\n\t\t\t\t\t\t\t      optlen);\n\t\telse\n\t\t\tretv = ipv6_set_mcast_msfilter(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_ROUTER_ALERT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = ip6_ra_control(sk, val);\n\t\tbreak;\n\tcase IPV6_ROUTER_ALERT_ISOLATE:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rtalert_isolate = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU_DISCOVER:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tnp->pmtudisc = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val && val < IPV6_MIN_MTU)\n\t\t\tgoto e_inval;\n\t\tnp->frag_size = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->recverr = valbool;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWINFO_SEND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->sndflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWLABEL_MGR:\n\t\tretv = ipv6_flowlabel_opt(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_IPSEC_POLICY:\n\tcase IPV6_XFRM_POLICY:\n\t\tretv = -EPERM;\n\t\tif (!sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tretv = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = __ip6_sock_set_addr_preferences(sk, val);\n\t\tbreak;\n\tcase IPV6_MINHOPCOUNT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\n\t\tif (val)\n\t\t\tstatic_branch_enable(&ip6_min_hopcount);\n\n\t\t/* tcp_v6_err() and tcp_v6_rcv() might read min_hopcount\n\t\t * while we are changing it.\n\t\t */\n\t\tWRITE_ONCE(np->min_hopcount, val);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_DONTFRAG:\n\t\tnp->dontfrag = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tnp->autoflowlabel = valbool;\n\t\tnp->autoflowlabel_set = 1;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVFRAGSIZE:\n\t\tnp->rxopt.bits.recvfragsize = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR_RFC4884:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 1)\n\t\t\tgoto e_inval;\n\t\tnp->recverr_rfc4884 = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\nunlock:\n\tsockopt_release_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\n\treturn retv;\n\ne_inval:\n\tsockopt_release_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,12 @@\n \tif (needs_rtnl)\n \t\trtnl_lock();\n \tsockopt_lock_sock(sk);\n+\n+\t/* Another thread has converted the socket into IPv4 with\n+\t * IPV6_ADDRFORM concurrently.\n+\t */\n+\tif (unlikely(sk->sk_family != AF_INET6))\n+\t\tgoto unlock;\n \n \tswitch (optname) {\n \n@@ -601,6 +607,7 @@\n \t\tbreak;\n \t}\n \n+unlock:\n \tsockopt_release_sock(sk);\n \tif (needs_rtnl)\n \t\trtnl_unlock();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t/* Another thread has converted the socket into IPv4 with",
                "\t * IPV6_ADDRFORM concurrently.",
                "\t */",
                "\tif (unlikely(sk->sk_family != AF_INET6))",
                "\t\tgoto unlock;",
                "unlock:"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3544",
        "func_name": "kernel/git/netfilter/nf-next/damon_sysfs_add_target",
        "description": "A vulnerability, which was classified as problematic, was found in Linux Kernel. Affected is the function damon_sysfs_add_target of the file mm/damon/sysfs.c of the component Netfilter. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211044.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/netfilter/nf-next.git/commit/?h=1c8e2349f2d033f634d046063b704b2ca6c46972",
        "commit_title": "When damon_sysfs_add_target couldn't find proper task, New allocated",
        "commit_text": "damon_target structure isn't registered yet, So, it's impossible to free new allocated one by damon_sysfs_destroy_targets.  By calling damon_add_target as soon as allocating new target, Fix this possible memory leak.  Link: https://lkml.kernel.org/r/20220926160611.48536-1-sj@kernel.org Cc: <stable@vger.kernel.org>\t[5.17.x] ",
        "func_before": "static int damon_sysfs_add_target(struct damon_sysfs_target *sys_target,\n\t\tstruct damon_ctx *ctx)\n{\n\tstruct damon_target *t = damon_new_target();\n\tint err = -EINVAL;\n\n\tif (!t)\n\t\treturn -ENOMEM;\n\tif (damon_target_has_pid(ctx)) {\n\t\tt->pid = find_get_pid(sys_target->pid);\n\t\tif (!t->pid)\n\t\t\tgoto destroy_targets_out;\n\t}\n\tdamon_add_target(ctx, t);\n\terr = damon_sysfs_set_regions(t, sys_target->regions);\n\tif (err)\n\t\tgoto destroy_targets_out;\n\treturn 0;\n\ndestroy_targets_out:\n\tdamon_sysfs_destroy_targets(ctx);\n\treturn err;\n}",
        "func": "static int damon_sysfs_add_target(struct damon_sysfs_target *sys_target,\n\t\tstruct damon_ctx *ctx)\n{\n\tstruct damon_target *t = damon_new_target();\n\tint err = -EINVAL;\n\n\tif (!t)\n\t\treturn -ENOMEM;\n\tdamon_add_target(ctx, t);\n\tif (damon_target_has_pid(ctx)) {\n\t\tt->pid = find_get_pid(sys_target->pid);\n\t\tif (!t->pid)\n\t\t\tgoto destroy_targets_out;\n\t}\n\terr = damon_sysfs_set_regions(t, sys_target->regions);\n\tif (err)\n\t\tgoto destroy_targets_out;\n\treturn 0;\n\ndestroy_targets_out:\n\tdamon_sysfs_destroy_targets(ctx);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,12 +6,12 @@\n \n \tif (!t)\n \t\treturn -ENOMEM;\n+\tdamon_add_target(ctx, t);\n \tif (damon_target_has_pid(ctx)) {\n \t\tt->pid = find_get_pid(sys_target->pid);\n \t\tif (!t->pid)\n \t\t\tgoto destroy_targets_out;\n \t}\n-\tdamon_add_target(ctx, t);\n \terr = damon_sysfs_set_regions(t, sys_target->regions);\n \tif (err)\n \t\tgoto destroy_targets_out;",
        "diff_line_info": {
            "deleted_lines": [
                "\tdamon_add_target(ctx, t);"
            ],
            "added_lines": [
                "\tdamon_add_target(ctx, t);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3551",
        "func_name": "xorg/xserver/ProcXkbGetKbdByName",
        "description": "A vulnerability, which was classified as problematic, has been found in X.org Server. Affected by this issue is the function ProcXkbGetKbdByName of the file xkb/xkb.c. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211052.",
        "git_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=18f91b950e22c2a342a4fbc55e9ddf7534a707d2",
        "commit_title": "GetComponentByName returns an allocated string, so let's free that if we",
        "commit_text": "fail somewhere.  ",
        "func_before": "int\nProcXkbGetKbdByName(ClientPtr client)\n{\n    DeviceIntPtr dev;\n    DeviceIntPtr tmpd;\n    DeviceIntPtr master;\n    xkbGetKbdByNameReply rep = { 0 };\n    xkbGetMapReply mrep = { 0 };\n    xkbGetCompatMapReply crep = { 0 };\n    xkbGetIndicatorMapReply irep = { 0 };\n    xkbGetNamesReply nrep = { 0 };\n    xkbGetGeometryReply grep = { 0 };\n    XkbComponentNamesRec names = { 0 };\n    XkbDescPtr xkb, new;\n    XkbEventCauseRec cause;\n    unsigned char *str;\n    char mapFile[PATH_MAX];\n    unsigned len;\n    unsigned fwant, fneed, reported;\n    int status;\n    Bool geom_changed;\n    XkbSrvLedInfoPtr old_sli;\n    XkbSrvLedInfoPtr sli;\n    Mask access_mode = DixGetAttrAccess | DixManageAccess;\n\n    REQUEST(xkbGetKbdByNameReq);\n    REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq);\n\n    if (!(client->xkbClientFlags & _XkbClientInitialized))\n        return BadAccess;\n\n    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);\n    master = GetMaster(dev, MASTER_KEYBOARD);\n\n    xkb = dev->key->xkbInfo->desc;\n    status = Success;\n    str = (unsigned char *) &stuff[1];\n    if (GetComponentSpec(&str, TRUE, &status))  /* keymap, unsupported */\n        return BadMatch;\n    names.keycodes = GetComponentSpec(&str, TRUE, &status);\n    names.types = GetComponentSpec(&str, TRUE, &status);\n    names.compat = GetComponentSpec(&str, TRUE, &status);\n    names.symbols = GetComponentSpec(&str, TRUE, &status);\n    names.geometry = GetComponentSpec(&str, TRUE, &status);\n    if (status != Success)\n        return status;\n    len = str - ((unsigned char *) stuff);\n    if ((XkbPaddedSize(len) / 4) != stuff->length)\n        return BadLength;\n\n    CHK_MASK_LEGAL(0x01, stuff->want, XkbGBN_AllComponentsMask);\n    CHK_MASK_LEGAL(0x02, stuff->need, XkbGBN_AllComponentsMask);\n\n    if (stuff->load)\n        fwant = XkbGBN_AllComponentsMask;\n    else\n        fwant = stuff->want | stuff->need;\n    if ((!names.compat) &&\n        (fwant & (XkbGBN_CompatMapMask | XkbGBN_IndicatorMapMask))) {\n        names.compat = Xstrdup(\"%\");\n    }\n    if ((!names.types) && (fwant & (XkbGBN_TypesMask))) {\n        names.types = Xstrdup(\"%\");\n    }\n    if ((!names.symbols) && (fwant & XkbGBN_SymbolsMask)) {\n        names.symbols = Xstrdup(\"%\");\n    }\n    geom_changed = ((names.geometry != NULL) &&\n                    (strcmp(names.geometry, \"%\") != 0));\n    if ((!names.geometry) && (fwant & XkbGBN_GeometryMask)) {\n        names.geometry = Xstrdup(\"%\");\n        geom_changed = FALSE;\n    }\n\n    memset(mapFile, 0, PATH_MAX);\n    rep.type = X_Reply;\n    rep.deviceID = dev->id;\n    rep.sequenceNumber = client->sequence;\n    rep.length = 0;\n    rep.minKeyCode = xkb->min_key_code;\n    rep.maxKeyCode = xkb->max_key_code;\n    rep.loaded = FALSE;\n    fwant =\n        XkbConvertGetByNameComponents(TRUE, stuff->want) | XkmVirtualModsMask;\n    fneed = XkbConvertGetByNameComponents(TRUE, stuff->need);\n    rep.reported = XkbConvertGetByNameComponents(FALSE, fwant | fneed);\n    if (stuff->load) {\n        fneed |= XkmKeymapRequired;\n        fwant |= XkmKeymapLegal;\n    }\n    if ((fwant | fneed) & XkmSymbolsMask) {\n        fneed |= XkmKeyNamesIndex | XkmTypesIndex;\n        fwant |= XkmIndicatorsIndex;\n    }\n\n    /* We pass dev in here so we can get the old names out if needed. */\n    rep.found = XkbDDXLoadKeymapByNames(dev, &names, fwant, fneed, &new,\n                                        mapFile, PATH_MAX);\n    rep.newKeyboard = FALSE;\n    rep.pad1 = rep.pad2 = rep.pad3 = rep.pad4 = 0;\n\n    stuff->want |= stuff->need;\n    if (new == NULL)\n        rep.reported = 0;\n    else {\n        if (stuff->load)\n            rep.loaded = TRUE;\n        if (stuff->load ||\n            ((rep.reported & XkbGBN_SymbolsMask) && (new->compat))) {\n            XkbChangesRec changes;\n\n            memset(&changes, 0, sizeof(changes));\n            XkbUpdateDescActions(new,\n                                 new->min_key_code, XkbNumKeys(new), &changes);\n        }\n\n        if (new->map == NULL)\n            rep.reported &= ~(XkbGBN_SymbolsMask | XkbGBN_TypesMask);\n        else if (rep.reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask)) {\n            mrep.type = X_Reply;\n            mrep.deviceID = dev->id;\n            mrep.sequenceNumber = client->sequence;\n            mrep.length =\n                ((SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2);\n            mrep.minKeyCode = new->min_key_code;\n            mrep.maxKeyCode = new->max_key_code;\n            mrep.present = 0;\n            mrep.totalSyms = mrep.totalActs =\n                mrep.totalKeyBehaviors = mrep.totalKeyExplicit =\n                mrep.totalModMapKeys = mrep.totalVModMapKeys = 0;\n            if (rep.reported & (XkbGBN_TypesMask | XkbGBN_ClientSymbolsMask)) {\n                mrep.present |= XkbKeyTypesMask;\n                mrep.firstType = 0;\n                mrep.nTypes = mrep.totalTypes = new->map->num_types;\n            }\n            else {\n                mrep.firstType = mrep.nTypes = 0;\n                mrep.totalTypes = 0;\n            }\n            if (rep.reported & XkbGBN_ClientSymbolsMask) {\n                mrep.present |= (XkbKeySymsMask | XkbModifierMapMask);\n                mrep.firstKeySym = mrep.firstModMapKey = new->min_key_code;\n                mrep.nKeySyms = mrep.nModMapKeys = XkbNumKeys(new);\n            }\n            else {\n                mrep.firstKeySym = mrep.firstModMapKey = 0;\n                mrep.nKeySyms = mrep.nModMapKeys = 0;\n            }\n            if (rep.reported & XkbGBN_ServerSymbolsMask) {\n                mrep.present |= XkbAllServerInfoMask;\n                mrep.virtualMods = ~0;\n                mrep.firstKeyAct = mrep.firstKeyBehavior =\n                    mrep.firstKeyExplicit = new->min_key_code;\n                mrep.nKeyActs = mrep.nKeyBehaviors =\n                    mrep.nKeyExplicit = XkbNumKeys(new);\n                mrep.firstVModMapKey = new->min_key_code;\n                mrep.nVModMapKeys = XkbNumKeys(new);\n            }\n            else {\n                mrep.virtualMods = 0;\n                mrep.firstKeyAct = mrep.firstKeyBehavior =\n                    mrep.firstKeyExplicit = 0;\n                mrep.nKeyActs = mrep.nKeyBehaviors = mrep.nKeyExplicit = 0;\n            }\n            XkbComputeGetMapReplySize(new, &mrep);\n            rep.length += SIZEOF(xGenericReply) / 4 + mrep.length;\n        }\n        if (new->compat == NULL)\n            rep.reported &= ~XkbGBN_CompatMapMask;\n        else if (rep.reported & XkbGBN_CompatMapMask) {\n            crep.type = X_Reply;\n            crep.deviceID = dev->id;\n            crep.sequenceNumber = client->sequence;\n            crep.length = 0;\n            crep.groups = XkbAllGroupsMask;\n            crep.firstSI = 0;\n            crep.nSI = crep.nTotalSI = new->compat->num_si;\n            XkbComputeGetCompatMapReplySize(new->compat, &crep);\n            rep.length += SIZEOF(xGenericReply) / 4 + crep.length;\n        }\n        if (new->indicators == NULL)\n            rep.reported &= ~XkbGBN_IndicatorMapMask;\n        else if (rep.reported & XkbGBN_IndicatorMapMask) {\n            irep.type = X_Reply;\n            irep.deviceID = dev->id;\n            irep.sequenceNumber = client->sequence;\n            irep.length = 0;\n            irep.which = XkbAllIndicatorsMask;\n            XkbComputeGetIndicatorMapReplySize(new->indicators, &irep);\n            rep.length += SIZEOF(xGenericReply) / 4 + irep.length;\n        }\n        if (new->names == NULL)\n            rep.reported &= ~(XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask);\n        else if (rep.reported & (XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask)) {\n            nrep.type = X_Reply;\n            nrep.deviceID = dev->id;\n            nrep.sequenceNumber = client->sequence;\n            nrep.length = 0;\n            nrep.minKeyCode = new->min_key_code;\n            nrep.maxKeyCode = new->max_key_code;\n            if (rep.reported & XkbGBN_OtherNamesMask) {\n                nrep.which = XkbAllNamesMask;\n                if (new->map != NULL)\n                    nrep.nTypes = new->map->num_types;\n                else\n                    nrep.nTypes = 0;\n                nrep.nKTLevels = 0;\n                nrep.groupNames = XkbAllGroupsMask;\n                nrep.virtualMods = XkbAllVirtualModsMask;\n                nrep.indicators = XkbAllIndicatorsMask;\n                nrep.nRadioGroups = new->names->num_rg;\n            }\n            else {\n                nrep.which = 0;\n                nrep.nTypes = 0;\n                nrep.nKTLevels = 0;\n                nrep.groupNames = 0;\n                nrep.virtualMods = 0;\n                nrep.indicators = 0;\n                nrep.nRadioGroups = 0;\n            }\n            if (rep.reported & XkbGBN_KeyNamesMask) {\n                nrep.which |= XkbKeyNamesMask;\n                nrep.firstKey = new->min_key_code;\n                nrep.nKeys = XkbNumKeys(new);\n                nrep.nKeyAliases = new->names->num_key_aliases;\n                if (nrep.nKeyAliases)\n                    nrep.which |= XkbKeyAliasesMask;\n            }\n            else {\n                nrep.which &= ~(XkbKeyNamesMask | XkbKeyAliasesMask);\n                nrep.firstKey = nrep.nKeys = 0;\n                nrep.nKeyAliases = 0;\n            }\n            XkbComputeGetNamesReplySize(new, &nrep);\n            rep.length += SIZEOF(xGenericReply) / 4 + nrep.length;\n        }\n        if (new->geom == NULL)\n            rep.reported &= ~XkbGBN_GeometryMask;\n        else if (rep.reported & XkbGBN_GeometryMask) {\n            grep.type = X_Reply;\n            grep.deviceID = dev->id;\n            grep.sequenceNumber = client->sequence;\n            grep.length = 0;\n            grep.found = TRUE;\n            grep.pad = 0;\n            grep.widthMM = grep.heightMM = 0;\n            grep.nProperties = grep.nColors = grep.nShapes = 0;\n            grep.nSections = grep.nDoodads = 0;\n            grep.baseColorNdx = grep.labelColorNdx = 0;\n            XkbComputeGetGeometryReplySize(new->geom, &grep, None);\n            rep.length += SIZEOF(xGenericReply) / 4 + grep.length;\n        }\n    }\n\n    reported = rep.reported;\n    if (client->swapped) {\n        swaps(&rep.sequenceNumber);\n        swapl(&rep.length);\n        swaps(&rep.found);\n        swaps(&rep.reported);\n    }\n    WriteToClient(client, SIZEOF(xkbGetKbdByNameReply), &rep);\n    if (reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask))\n        XkbSendMap(client, new, &mrep);\n    if (reported & XkbGBN_CompatMapMask)\n        XkbSendCompatMap(client, new->compat, &crep);\n    if (reported & XkbGBN_IndicatorMapMask)\n        XkbSendIndicatorMap(client, new->indicators, &irep);\n    if (reported & (XkbGBN_KeyNamesMask | XkbGBN_OtherNamesMask))\n        XkbSendNames(client, new, &nrep);\n    if (reported & XkbGBN_GeometryMask)\n        XkbSendGeometry(client, new->geom, &grep, FALSE);\n    if (rep.loaded) {\n        XkbDescPtr old_xkb;\n        xkbNewKeyboardNotify nkn;\n\n        old_xkb = xkb;\n        xkb = new;\n        dev->key->xkbInfo->desc = xkb;\n        new = old_xkb;          /* so it'll get freed automatically */\n\n        XkbCopyControls(xkb, old_xkb);\n\n        nkn.deviceID = nkn.oldDeviceID = dev->id;\n        nkn.minKeyCode = new->min_key_code;\n        nkn.maxKeyCode = new->max_key_code;\n        nkn.oldMinKeyCode = xkb->min_key_code;\n        nkn.oldMaxKeyCode = xkb->max_key_code;\n        nkn.requestMajor = XkbReqCode;\n        nkn.requestMinor = X_kbGetKbdByName;\n        nkn.changed = XkbNKN_KeycodesMask;\n        if (geom_changed)\n            nkn.changed |= XkbNKN_GeometryMask;\n        XkbSendNewKeyboardNotify(dev, &nkn);\n\n        /* Update the map and LED info on the device itself, as well as\n         * any slaves if it's an MD, or its MD if it's an SD and was the\n         * last device used on that MD. */\n        for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {\n            if (tmpd != dev && GetMaster(tmpd, MASTER_KEYBOARD) != dev &&\n                (tmpd != master || dev != master->lastSlave))\n                continue;\n\n            if (tmpd != dev)\n                XkbDeviceApplyKeymap(tmpd, xkb);\n\n            if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) {\n                old_sli = tmpd->kbdfeed->xkb_sli;\n                tmpd->kbdfeed->xkb_sli = NULL;\n                sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0);\n                if (sli) {\n                    sli->explicitState = old_sli->explicitState;\n                    sli->effectiveState = old_sli->effectiveState;\n                }\n                tmpd->kbdfeed->xkb_sli = sli;\n                XkbFreeSrvLedInfo(old_sli);\n            }\n        }\n    }\n    if ((new != NULL) && (new != xkb)) {\n        XkbFreeKeyboard(new, XkbAllComponentsMask, TRUE);\n        new = NULL;\n    }\n    XkbFreeComponentNames(&names, FALSE);\n    XkbSetCauseXkbReq(&cause, X_kbGetKbdByName, client);\n    XkbUpdateAllDeviceIndicators(NULL, &cause);\n\n    return Success;\n}",
        "func": "int\nProcXkbGetKbdByName(ClientPtr client)\n{\n    DeviceIntPtr dev;\n    DeviceIntPtr tmpd;\n    DeviceIntPtr master;\n    xkbGetKbdByNameReply rep = { 0 };\n    xkbGetMapReply mrep = { 0 };\n    xkbGetCompatMapReply crep = { 0 };\n    xkbGetIndicatorMapReply irep = { 0 };\n    xkbGetNamesReply nrep = { 0 };\n    xkbGetGeometryReply grep = { 0 };\n    XkbComponentNamesRec names = { 0 };\n    XkbDescPtr xkb, new;\n    XkbEventCauseRec cause;\n    unsigned char *str;\n    char mapFile[PATH_MAX];\n    unsigned len;\n    unsigned fwant, fneed, reported;\n    int status;\n    Bool geom_changed;\n    XkbSrvLedInfoPtr old_sli;\n    XkbSrvLedInfoPtr sli;\n    Mask access_mode = DixGetAttrAccess | DixManageAccess;\n\n    REQUEST(xkbGetKbdByNameReq);\n    REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq);\n\n    if (!(client->xkbClientFlags & _XkbClientInitialized))\n        return BadAccess;\n\n    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode);\n    master = GetMaster(dev, MASTER_KEYBOARD);\n\n    xkb = dev->key->xkbInfo->desc;\n    status = Success;\n    str = (unsigned char *) &stuff[1];\n    {\n        char *keymap = GetComponentSpec(&str, TRUE, &status);  /* keymap, unsupported */\n        if (keymap) {\n            free(keymap);\n            return BadMatch;\n        }\n    }\n    names.keycodes = GetComponentSpec(&str, TRUE, &status);\n    names.types = GetComponentSpec(&str, TRUE, &status);\n    names.compat = GetComponentSpec(&str, TRUE, &status);\n    names.symbols = GetComponentSpec(&str, TRUE, &status);\n    names.geometry = GetComponentSpec(&str, TRUE, &status);\n    if (status == Success) {\n        len = str - ((unsigned char *) stuff);\n        if ((XkbPaddedSize(len) / 4) != stuff->length)\n            status = BadLength;\n    }\n\n    if (status != Success) {\n        free(names.keycodes);\n        free(names.types);\n        free(names.compat);\n        free(names.symbols);\n        free(names.geometry);\n        return status;\n    }\n\n    CHK_MASK_LEGAL(0x01, stuff->want, XkbGBN_AllComponentsMask);\n    CHK_MASK_LEGAL(0x02, stuff->need, XkbGBN_AllComponentsMask);\n\n    if (stuff->load)\n        fwant = XkbGBN_AllComponentsMask;\n    else\n        fwant = stuff->want | stuff->need;\n    if ((!names.compat) &&\n        (fwant & (XkbGBN_CompatMapMask | XkbGBN_IndicatorMapMask))) {\n        names.compat = Xstrdup(\"%\");\n    }\n    if ((!names.types) && (fwant & (XkbGBN_TypesMask))) {\n        names.types = Xstrdup(\"%\");\n    }\n    if ((!names.symbols) && (fwant & XkbGBN_SymbolsMask)) {\n        names.symbols = Xstrdup(\"%\");\n    }\n    geom_changed = ((names.geometry != NULL) &&\n                    (strcmp(names.geometry, \"%\") != 0));\n    if ((!names.geometry) && (fwant & XkbGBN_GeometryMask)) {\n        names.geometry = Xstrdup(\"%\");\n        geom_changed = FALSE;\n    }\n\n    memset(mapFile, 0, PATH_MAX);\n    rep.type = X_Reply;\n    rep.deviceID = dev->id;\n    rep.sequenceNumber = client->sequence;\n    rep.length = 0;\n    rep.minKeyCode = xkb->min_key_code;\n    rep.maxKeyCode = xkb->max_key_code;\n    rep.loaded = FALSE;\n    fwant =\n        XkbConvertGetByNameComponents(TRUE, stuff->want) | XkmVirtualModsMask;\n    fneed = XkbConvertGetByNameComponents(TRUE, stuff->need);\n    rep.reported = XkbConvertGetByNameComponents(FALSE, fwant | fneed);\n    if (stuff->load) {\n        fneed |= XkmKeymapRequired;\n        fwant |= XkmKeymapLegal;\n    }\n    if ((fwant | fneed) & XkmSymbolsMask) {\n        fneed |= XkmKeyNamesIndex | XkmTypesIndex;\n        fwant |= XkmIndicatorsIndex;\n    }\n\n    /* We pass dev in here so we can get the old names out if needed. */\n    rep.found = XkbDDXLoadKeymapByNames(dev, &names, fwant, fneed, &new,\n                                        mapFile, PATH_MAX);\n    rep.newKeyboard = FALSE;\n    rep.pad1 = rep.pad2 = rep.pad3 = rep.pad4 = 0;\n\n    stuff->want |= stuff->need;\n    if (new == NULL)\n        rep.reported = 0;\n    else {\n        if (stuff->load)\n            rep.loaded = TRUE;\n        if (stuff->load ||\n            ((rep.reported & XkbGBN_SymbolsMask) && (new->compat))) {\n            XkbChangesRec changes;\n\n            memset(&changes, 0, sizeof(changes));\n            XkbUpdateDescActions(new,\n                                 new->min_key_code, XkbNumKeys(new), &changes);\n        }\n\n        if (new->map == NULL)\n            rep.reported &= ~(XkbGBN_SymbolsMask | XkbGBN_TypesMask);\n        else if (rep.reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask)) {\n            mrep.type = X_Reply;\n            mrep.deviceID = dev->id;\n            mrep.sequenceNumber = client->sequence;\n            mrep.length =\n                ((SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2);\n            mrep.minKeyCode = new->min_key_code;\n            mrep.maxKeyCode = new->max_key_code;\n            mrep.present = 0;\n            mrep.totalSyms = mrep.totalActs =\n                mrep.totalKeyBehaviors = mrep.totalKeyExplicit =\n                mrep.totalModMapKeys = mrep.totalVModMapKeys = 0;\n            if (rep.reported & (XkbGBN_TypesMask | XkbGBN_ClientSymbolsMask)) {\n                mrep.present |= XkbKeyTypesMask;\n                mrep.firstType = 0;\n                mrep.nTypes = mrep.totalTypes = new->map->num_types;\n            }\n            else {\n                mrep.firstType = mrep.nTypes = 0;\n                mrep.totalTypes = 0;\n            }\n            if (rep.reported & XkbGBN_ClientSymbolsMask) {\n                mrep.present |= (XkbKeySymsMask | XkbModifierMapMask);\n                mrep.firstKeySym = mrep.firstModMapKey = new->min_key_code;\n                mrep.nKeySyms = mrep.nModMapKeys = XkbNumKeys(new);\n            }\n            else {\n                mrep.firstKeySym = mrep.firstModMapKey = 0;\n                mrep.nKeySyms = mrep.nModMapKeys = 0;\n            }\n            if (rep.reported & XkbGBN_ServerSymbolsMask) {\n                mrep.present |= XkbAllServerInfoMask;\n                mrep.virtualMods = ~0;\n                mrep.firstKeyAct = mrep.firstKeyBehavior =\n                    mrep.firstKeyExplicit = new->min_key_code;\n                mrep.nKeyActs = mrep.nKeyBehaviors =\n                    mrep.nKeyExplicit = XkbNumKeys(new);\n                mrep.firstVModMapKey = new->min_key_code;\n                mrep.nVModMapKeys = XkbNumKeys(new);\n            }\n            else {\n                mrep.virtualMods = 0;\n                mrep.firstKeyAct = mrep.firstKeyBehavior =\n                    mrep.firstKeyExplicit = 0;\n                mrep.nKeyActs = mrep.nKeyBehaviors = mrep.nKeyExplicit = 0;\n            }\n            XkbComputeGetMapReplySize(new, &mrep);\n            rep.length += SIZEOF(xGenericReply) / 4 + mrep.length;\n        }\n        if (new->compat == NULL)\n            rep.reported &= ~XkbGBN_CompatMapMask;\n        else if (rep.reported & XkbGBN_CompatMapMask) {\n            crep.type = X_Reply;\n            crep.deviceID = dev->id;\n            crep.sequenceNumber = client->sequence;\n            crep.length = 0;\n            crep.groups = XkbAllGroupsMask;\n            crep.firstSI = 0;\n            crep.nSI = crep.nTotalSI = new->compat->num_si;\n            XkbComputeGetCompatMapReplySize(new->compat, &crep);\n            rep.length += SIZEOF(xGenericReply) / 4 + crep.length;\n        }\n        if (new->indicators == NULL)\n            rep.reported &= ~XkbGBN_IndicatorMapMask;\n        else if (rep.reported & XkbGBN_IndicatorMapMask) {\n            irep.type = X_Reply;\n            irep.deviceID = dev->id;\n            irep.sequenceNumber = client->sequence;\n            irep.length = 0;\n            irep.which = XkbAllIndicatorsMask;\n            XkbComputeGetIndicatorMapReplySize(new->indicators, &irep);\n            rep.length += SIZEOF(xGenericReply) / 4 + irep.length;\n        }\n        if (new->names == NULL)\n            rep.reported &= ~(XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask);\n        else if (rep.reported & (XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask)) {\n            nrep.type = X_Reply;\n            nrep.deviceID = dev->id;\n            nrep.sequenceNumber = client->sequence;\n            nrep.length = 0;\n            nrep.minKeyCode = new->min_key_code;\n            nrep.maxKeyCode = new->max_key_code;\n            if (rep.reported & XkbGBN_OtherNamesMask) {\n                nrep.which = XkbAllNamesMask;\n                if (new->map != NULL)\n                    nrep.nTypes = new->map->num_types;\n                else\n                    nrep.nTypes = 0;\n                nrep.nKTLevels = 0;\n                nrep.groupNames = XkbAllGroupsMask;\n                nrep.virtualMods = XkbAllVirtualModsMask;\n                nrep.indicators = XkbAllIndicatorsMask;\n                nrep.nRadioGroups = new->names->num_rg;\n            }\n            else {\n                nrep.which = 0;\n                nrep.nTypes = 0;\n                nrep.nKTLevels = 0;\n                nrep.groupNames = 0;\n                nrep.virtualMods = 0;\n                nrep.indicators = 0;\n                nrep.nRadioGroups = 0;\n            }\n            if (rep.reported & XkbGBN_KeyNamesMask) {\n                nrep.which |= XkbKeyNamesMask;\n                nrep.firstKey = new->min_key_code;\n                nrep.nKeys = XkbNumKeys(new);\n                nrep.nKeyAliases = new->names->num_key_aliases;\n                if (nrep.nKeyAliases)\n                    nrep.which |= XkbKeyAliasesMask;\n            }\n            else {\n                nrep.which &= ~(XkbKeyNamesMask | XkbKeyAliasesMask);\n                nrep.firstKey = nrep.nKeys = 0;\n                nrep.nKeyAliases = 0;\n            }\n            XkbComputeGetNamesReplySize(new, &nrep);\n            rep.length += SIZEOF(xGenericReply) / 4 + nrep.length;\n        }\n        if (new->geom == NULL)\n            rep.reported &= ~XkbGBN_GeometryMask;\n        else if (rep.reported & XkbGBN_GeometryMask) {\n            grep.type = X_Reply;\n            grep.deviceID = dev->id;\n            grep.sequenceNumber = client->sequence;\n            grep.length = 0;\n            grep.found = TRUE;\n            grep.pad = 0;\n            grep.widthMM = grep.heightMM = 0;\n            grep.nProperties = grep.nColors = grep.nShapes = 0;\n            grep.nSections = grep.nDoodads = 0;\n            grep.baseColorNdx = grep.labelColorNdx = 0;\n            XkbComputeGetGeometryReplySize(new->geom, &grep, None);\n            rep.length += SIZEOF(xGenericReply) / 4 + grep.length;\n        }\n    }\n\n    reported = rep.reported;\n    if (client->swapped) {\n        swaps(&rep.sequenceNumber);\n        swapl(&rep.length);\n        swaps(&rep.found);\n        swaps(&rep.reported);\n    }\n    WriteToClient(client, SIZEOF(xkbGetKbdByNameReply), &rep);\n    if (reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask))\n        XkbSendMap(client, new, &mrep);\n    if (reported & XkbGBN_CompatMapMask)\n        XkbSendCompatMap(client, new->compat, &crep);\n    if (reported & XkbGBN_IndicatorMapMask)\n        XkbSendIndicatorMap(client, new->indicators, &irep);\n    if (reported & (XkbGBN_KeyNamesMask | XkbGBN_OtherNamesMask))\n        XkbSendNames(client, new, &nrep);\n    if (reported & XkbGBN_GeometryMask)\n        XkbSendGeometry(client, new->geom, &grep, FALSE);\n    if (rep.loaded) {\n        XkbDescPtr old_xkb;\n        xkbNewKeyboardNotify nkn;\n\n        old_xkb = xkb;\n        xkb = new;\n        dev->key->xkbInfo->desc = xkb;\n        new = old_xkb;          /* so it'll get freed automatically */\n\n        XkbCopyControls(xkb, old_xkb);\n\n        nkn.deviceID = nkn.oldDeviceID = dev->id;\n        nkn.minKeyCode = new->min_key_code;\n        nkn.maxKeyCode = new->max_key_code;\n        nkn.oldMinKeyCode = xkb->min_key_code;\n        nkn.oldMaxKeyCode = xkb->max_key_code;\n        nkn.requestMajor = XkbReqCode;\n        nkn.requestMinor = X_kbGetKbdByName;\n        nkn.changed = XkbNKN_KeycodesMask;\n        if (geom_changed)\n            nkn.changed |= XkbNKN_GeometryMask;\n        XkbSendNewKeyboardNotify(dev, &nkn);\n\n        /* Update the map and LED info on the device itself, as well as\n         * any slaves if it's an MD, or its MD if it's an SD and was the\n         * last device used on that MD. */\n        for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) {\n            if (tmpd != dev && GetMaster(tmpd, MASTER_KEYBOARD) != dev &&\n                (tmpd != master || dev != master->lastSlave))\n                continue;\n\n            if (tmpd != dev)\n                XkbDeviceApplyKeymap(tmpd, xkb);\n\n            if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) {\n                old_sli = tmpd->kbdfeed->xkb_sli;\n                tmpd->kbdfeed->xkb_sli = NULL;\n                sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0);\n                if (sli) {\n                    sli->explicitState = old_sli->explicitState;\n                    sli->effectiveState = old_sli->effectiveState;\n                }\n                tmpd->kbdfeed->xkb_sli = sli;\n                XkbFreeSrvLedInfo(old_sli);\n            }\n        }\n    }\n    if ((new != NULL) && (new != xkb)) {\n        XkbFreeKeyboard(new, XkbAllComponentsMask, TRUE);\n        new = NULL;\n    }\n    XkbFreeComponentNames(&names, FALSE);\n    XkbSetCauseXkbReq(&cause, X_kbGetKbdByName, client);\n    XkbUpdateAllDeviceIndicators(NULL, &cause);\n\n    return Success;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,18 +35,32 @@\n     xkb = dev->key->xkbInfo->desc;\n     status = Success;\n     str = (unsigned char *) &stuff[1];\n-    if (GetComponentSpec(&str, TRUE, &status))  /* keymap, unsupported */\n-        return BadMatch;\n+    {\n+        char *keymap = GetComponentSpec(&str, TRUE, &status);  /* keymap, unsupported */\n+        if (keymap) {\n+            free(keymap);\n+            return BadMatch;\n+        }\n+    }\n     names.keycodes = GetComponentSpec(&str, TRUE, &status);\n     names.types = GetComponentSpec(&str, TRUE, &status);\n     names.compat = GetComponentSpec(&str, TRUE, &status);\n     names.symbols = GetComponentSpec(&str, TRUE, &status);\n     names.geometry = GetComponentSpec(&str, TRUE, &status);\n-    if (status != Success)\n+    if (status == Success) {\n+        len = str - ((unsigned char *) stuff);\n+        if ((XkbPaddedSize(len) / 4) != stuff->length)\n+            status = BadLength;\n+    }\n+\n+    if (status != Success) {\n+        free(names.keycodes);\n+        free(names.types);\n+        free(names.compat);\n+        free(names.symbols);\n+        free(names.geometry);\n         return status;\n-    len = str - ((unsigned char *) stuff);\n-    if ((XkbPaddedSize(len) / 4) != stuff->length)\n-        return BadLength;\n+    }\n \n     CHK_MASK_LEGAL(0x01, stuff->want, XkbGBN_AllComponentsMask);\n     CHK_MASK_LEGAL(0x02, stuff->need, XkbGBN_AllComponentsMask);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (GetComponentSpec(&str, TRUE, &status))  /* keymap, unsupported */",
                "        return BadMatch;",
                "    if (status != Success)",
                "    len = str - ((unsigned char *) stuff);",
                "    if ((XkbPaddedSize(len) / 4) != stuff->length)",
                "        return BadLength;"
            ],
            "added_lines": [
                "    {",
                "        char *keymap = GetComponentSpec(&str, TRUE, &status);  /* keymap, unsupported */",
                "        if (keymap) {",
                "            free(keymap);",
                "            return BadMatch;",
                "        }",
                "    }",
                "    if (status == Success) {",
                "        len = str - ((unsigned char *) stuff);",
                "        if ((XkbPaddedSize(len) / 4) != stuff->length)",
                "            status = BadLength;",
                "    }",
                "",
                "    if (status != Success) {",
                "        free(names.keycodes);",
                "        free(names.types);",
                "        free(names.compat);",
                "        free(names.symbols);",
                "        free(names.geometry);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3594",
        "func_name": "kernel/git/bpf/bpf-next/intr_callback",
        "description": "A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function intr_callback of the file drivers/net/usb/r8152.c of the component BPF. The manipulation leads to logging of excessive data. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211363.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=93e2be344a7db169b7119de21ac1bf253b8c6907",
        "commit_title": "My system shows almost 10 million of these messages over a 24-hour",
        "commit_text": "period which pollutes my logs.  Link: https://lore.kernel.org/r/20221002034128.2026653-1-gaul@google.com ",
        "func_before": "static void intr_callback(struct urb *urb)\n{\n\tstruct r8152 *tp;\n\t__le16 *d;\n\tint status = urb->status;\n\tint res;\n\n\ttp = urb->context;\n\tif (!tp)\n\t\treturn;\n\n\tif (!test_bit(WORK_ENABLE, &tp->flags))\n\t\treturn;\n\n\tif (test_bit(RTL8152_UNPLUG, &tp->flags))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ESHUTDOWN:\n\t\tnetif_device_detach(tp->netdev);\n\t\tfallthrough;\n\tcase -ENOENT:\n\tcase -EPROTO:\n\t\tnetif_info(tp, intr, tp->netdev,\n\t\t\t   \"Stop submitting intr, status %d\\n\", status);\n\t\treturn;\n\tcase -EOVERFLOW:\n\t\tnetif_info(tp, intr, tp->netdev, \"intr status -EOVERFLOW\\n\");\n\t\tgoto resubmit;\n\t/* -EPIPE:  should clear the halt */\n\tdefault:\n\t\tnetif_info(tp, intr, tp->netdev, \"intr status %d\\n\", status);\n\t\tgoto resubmit;\n\t}\n\n\td = urb->transfer_buffer;\n\tif (INTR_LINK & __le16_to_cpu(d[0])) {\n\t\tif (!netif_carrier_ok(tp->netdev)) {\n\t\t\tset_bit(RTL8152_LINK_CHG, &tp->flags);\n\t\t\tschedule_delayed_work(&tp->schedule, 0);\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(tp->netdev)) {\n\t\t\tnetif_stop_queue(tp->netdev);\n\t\t\tset_bit(RTL8152_LINK_CHG, &tp->flags);\n\t\t\tschedule_delayed_work(&tp->schedule, 0);\n\t\t}\n\t}\n\nresubmit:\n\tres = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (res == -ENODEV) {\n\t\trtl_set_unplug(tp);\n\t\tnetif_device_detach(tp->netdev);\n\t} else if (res) {\n\t\tnetif_err(tp, intr, tp->netdev,\n\t\t\t  \"can't resubmit intr, status %d\\n\", res);\n\t}\n}",
        "func": "static void intr_callback(struct urb *urb)\n{\n\tstruct r8152 *tp;\n\t__le16 *d;\n\tint status = urb->status;\n\tint res;\n\n\ttp = urb->context;\n\tif (!tp)\n\t\treturn;\n\n\tif (!test_bit(WORK_ENABLE, &tp->flags))\n\t\treturn;\n\n\tif (test_bit(RTL8152_UNPLUG, &tp->flags))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ESHUTDOWN:\n\t\tnetif_device_detach(tp->netdev);\n\t\tfallthrough;\n\tcase -ENOENT:\n\tcase -EPROTO:\n\t\tnetif_info(tp, intr, tp->netdev,\n\t\t\t   \"Stop submitting intr, status %d\\n\", status);\n\t\treturn;\n\tcase -EOVERFLOW:\n\t\tif (net_ratelimit())\n\t\t\tnetif_info(tp, intr, tp->netdev,\n\t\t\t\t   \"intr status -EOVERFLOW\\n\");\n\t\tgoto resubmit;\n\t/* -EPIPE:  should clear the halt */\n\tdefault:\n\t\tnetif_info(tp, intr, tp->netdev, \"intr status %d\\n\", status);\n\t\tgoto resubmit;\n\t}\n\n\td = urb->transfer_buffer;\n\tif (INTR_LINK & __le16_to_cpu(d[0])) {\n\t\tif (!netif_carrier_ok(tp->netdev)) {\n\t\t\tset_bit(RTL8152_LINK_CHG, &tp->flags);\n\t\t\tschedule_delayed_work(&tp->schedule, 0);\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(tp->netdev)) {\n\t\t\tnetif_stop_queue(tp->netdev);\n\t\t\tset_bit(RTL8152_LINK_CHG, &tp->flags);\n\t\t\tschedule_delayed_work(&tp->schedule, 0);\n\t\t}\n\t}\n\nresubmit:\n\tres = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (res == -ENODEV) {\n\t\trtl_set_unplug(tp);\n\t\tnetif_device_detach(tp->netdev);\n\t} else if (res) {\n\t\tnetif_err(tp, intr, tp->netdev,\n\t\t\t  \"can't resubmit intr, status %d\\n\", res);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,9 @@\n \t\t\t   \"Stop submitting intr, status %d\\n\", status);\n \t\treturn;\n \tcase -EOVERFLOW:\n-\t\tnetif_info(tp, intr, tp->netdev, \"intr status -EOVERFLOW\\n\");\n+\t\tif (net_ratelimit())\n+\t\t\tnetif_info(tp, intr, tp->netdev,\n+\t\t\t\t   \"intr status -EOVERFLOW\\n\");\n \t\tgoto resubmit;\n \t/* -EPIPE:  should clear the halt */\n \tdefault:",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tnetif_info(tp, intr, tp->netdev, \"intr status -EOVERFLOW\\n\");"
            ],
            "added_lines": [
                "\t\tif (net_ratelimit())",
                "\t\t\tnetif_info(tp, intr, tp->netdev,",
                "\t\t\t\t   \"intr status -EOVERFLOW\\n\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3606",
        "func_name": "kernel/git/bpf/bpf-next/find_prog_by_sec_insn",
        "description": "A vulnerability was found in Linux Kernel. It has been classified as problematic. This affects the function find_prog_by_sec_insn of the file tools/lib/bpf/libbpf.c of the component BPF. The manipulation leads to null pointer dereference. It is recommended to apply a patch to fix this issue. The identifier VDB-211749 was assigned to this vulnerability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=d0d382f95a9270dcf803539d6781d6bd67e3f5b2",
        "commit_title": "When there are no program sections, obj->programs is left unallocated,",
        "commit_text": "and find_prog_by_sec_insn()'s search lands on &obj->programs[0] == NULL, and will cause null-pointer dereference in the following access to prog->sec_idx.  Guard the search with obj->nr_programs similar to what's being done in __bpf_program__iter() to prevent null-pointer access from happening.  Link: https://lore.kernel.org/bpf/20221012022353.7350-4-shung-hsi.yu@suse.com ",
        "func_before": "static struct bpf_program *find_prog_by_sec_insn(const struct bpf_object *obj,\n\t\t\t\t\t\t size_t sec_idx, size_t insn_idx)\n{\n\tint l = 0, r = obj->nr_programs - 1, m;\n\tstruct bpf_program *prog;\n\n\twhile (l < r) {\n\t\tm = l + (r - l + 1) / 2;\n\t\tprog = &obj->programs[m];\n\n\t\tif (prog->sec_idx < sec_idx ||\n\t\t    (prog->sec_idx == sec_idx && prog->sec_insn_off <= insn_idx))\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m - 1;\n\t}\n\t/* matching program could be at index l, but it still might be the\n\t * wrong one, so we need to double check conditions for the last time\n\t */\n\tprog = &obj->programs[l];\n\tif (prog->sec_idx == sec_idx && prog_contains_insn(prog, insn_idx))\n\t\treturn prog;\n\treturn NULL;\n}",
        "func": "static struct bpf_program *find_prog_by_sec_insn(const struct bpf_object *obj,\n\t\t\t\t\t\t size_t sec_idx, size_t insn_idx)\n{\n\tint l = 0, r = obj->nr_programs - 1, m;\n\tstruct bpf_program *prog;\n\n\tif (!obj->nr_programs)\n\t\treturn NULL;\n\n\twhile (l < r) {\n\t\tm = l + (r - l + 1) / 2;\n\t\tprog = &obj->programs[m];\n\n\t\tif (prog->sec_idx < sec_idx ||\n\t\t    (prog->sec_idx == sec_idx && prog->sec_insn_off <= insn_idx))\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m - 1;\n\t}\n\t/* matching program could be at index l, but it still might be the\n\t * wrong one, so we need to double check conditions for the last time\n\t */\n\tprog = &obj->programs[l];\n\tif (prog->sec_idx == sec_idx && prog_contains_insn(prog, insn_idx))\n\t\treturn prog;\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n {\n \tint l = 0, r = obj->nr_programs - 1, m;\n \tstruct bpf_program *prog;\n+\n+\tif (!obj->nr_programs)\n+\t\treturn NULL;\n \n \twhile (l < r) {\n \t\tm = l + (r - l + 1) / 2;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (!obj->nr_programs)",
                "\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3621",
        "func_name": "kernel/git/bpf/bpf-next/nilfs_read_inode_common",
        "description": "A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is the function nilfs_bmap_lookup_at_level of the file fs/nilfs2/inode.c of the component nilfs2. The manipulation leads to null pointer dereference. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211920.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=21a87d88c2253350e115029f14fe2a10a7e6c856",
        "commit_title": "If the i_mode field in inode of metadata files is corrupted on disk, it",
        "commit_text": "can cause the initialization of bmap structure, which should have been called from nilfs_read_inode_common(), not to be called.  This causes a lockdep warning followed by a NULL pointer dereference at nilfs_bmap_lookup_at_level().  This patch fixes these issues by adding a missing sanitiy check for the i_mode field of metadata file's inode.  Link: https://lkml.kernel.org/r/20221002030804.29978-1-konishi.ryusuke@gmail.com Cc: <stable@vger.kernel.org> ",
        "func_before": "int nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}",
        "func": "int nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (nilfs_is_metadata_file_inode(inode) && !S_ISREG(inode->i_mode))\n\t\treturn -EIO; /* this inode is for metadata and corrupted */\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,8 @@\n \tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n \tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n \tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n+\tif (nilfs_is_metadata_file_inode(inode) && !S_ISREG(inode->i_mode))\n+\t\treturn -EIO; /* this inode is for metadata and corrupted */\n \tif (inode->i_nlink == 0)\n \t\treturn -ESTALE; /* this inode is deleted */\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (nilfs_is_metadata_file_inode(inode) && !S_ISREG(inode->i_mode))",
                "\t\treturn -EIO; /* this inode is for metadata and corrupted */"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3637",
        "func_name": "bluez/jlink_init",
        "description": "A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function jlink_init of the file monitor/jlink.c of the component BlueZ. The manipulation leads to denial of service. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211936.",
        "git_url": "https://git.kernel.org/pub/scm/bluetooth/bluez.git/commit/?h=1d6cfb8e625a944010956714c1802bc1e1fc6c4f",
        "commit_title": "This fix regression introduced by \"monitor: Fix memory leaks\".",
        "commit_text": "J-Link shared library is in use if jlink_init() returns 0 and thus handle shall not be closed. ",
        "func_before": "int jlink_init(void)\n{\n\tvoid *so;\n\tunsigned int i;\n\n\tfor (i = 0; i < NELEM(jlink_so_name); i++) {\n\t\tso = dlopen(jlink_so_name[i], RTLD_LAZY);\n\t\tif (so)\n\t\t\tbreak;\n\t}\n\n\tif (!so)\n\t\treturn -EIO;\n\n\tjlink.emu_selectbyusbsn = dlsym(so, \"JLINK_EMU_SelectByUSBSN\");\n\tjlink.open = dlsym(so, \"JLINK_Open\");\n\tjlink.execcommand = dlsym(so, \"JLINK_ExecCommand\");\n\tjlink.tif_select = dlsym(so, \"JLINK_TIF_Select\");\n\tjlink.setspeed = dlsym(so, \"JLINK_SetSpeed\");\n\tjlink.connect = dlsym(so, \"JLINK_Connect\");\n\tjlink.getsn = dlsym(so, \"JLINK_GetSN\");\n\tjlink.emu_getproductname = dlsym(so, \"JLINK_EMU_GetProductName\");\n\tjlink.rtterminal_control = dlsym(so, \"JLINK_RTTERMINAL_Control\");\n\tjlink.rtterminal_read = dlsym(so, \"JLINK_RTTERMINAL_Read\");\n\n\tif (!jlink.emu_selectbyusbsn || !jlink.open || !jlink.execcommand ||\n\t\t\t!jlink.tif_select || !jlink.setspeed ||\n\t\t\t!jlink.connect || !jlink.getsn ||\n\t\t\t!jlink.emu_getproductname ||\n\t\t\t!jlink.rtterminal_control || !jlink.rtterminal_read) {\n\t\tdlclose(so);\n\t\treturn -EIO;\n\t}\n\n\tdlclose(so);\n\treturn 0;\n}",
        "func": "int jlink_init(void)\n{\n\tvoid *so;\n\tunsigned int i;\n\n\tfor (i = 0; i < NELEM(jlink_so_name); i++) {\n\t\tso = dlopen(jlink_so_name[i], RTLD_LAZY);\n\t\tif (so)\n\t\t\tbreak;\n\t}\n\n\tif (!so)\n\t\treturn -EIO;\n\n\tjlink.emu_selectbyusbsn = dlsym(so, \"JLINK_EMU_SelectByUSBSN\");\n\tjlink.open = dlsym(so, \"JLINK_Open\");\n\tjlink.execcommand = dlsym(so, \"JLINK_ExecCommand\");\n\tjlink.tif_select = dlsym(so, \"JLINK_TIF_Select\");\n\tjlink.setspeed = dlsym(so, \"JLINK_SetSpeed\");\n\tjlink.connect = dlsym(so, \"JLINK_Connect\");\n\tjlink.getsn = dlsym(so, \"JLINK_GetSN\");\n\tjlink.emu_getproductname = dlsym(so, \"JLINK_EMU_GetProductName\");\n\tjlink.rtterminal_control = dlsym(so, \"JLINK_RTTERMINAL_Control\");\n\tjlink.rtterminal_read = dlsym(so, \"JLINK_RTTERMINAL_Read\");\n\n\tif (!jlink.emu_selectbyusbsn || !jlink.open || !jlink.execcommand ||\n\t\t\t!jlink.tif_select || !jlink.setspeed ||\n\t\t\t!jlink.connect || !jlink.getsn ||\n\t\t\t!jlink.emu_getproductname ||\n\t\t\t!jlink.rtterminal_control || !jlink.rtterminal_read) {\n\t\tdlclose(so);\n\t\treturn -EIO;\n\t}\n\n\t/* don't dlclose(so) here cause symbols from it are in use now */\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,6 +32,6 @@\n \t\treturn -EIO;\n \t}\n \n-\tdlclose(so);\n+\t/* don't dlclose(so) here cause symbols from it are in use now */\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tdlclose(so);"
            ],
            "added_lines": [
                "\t/* don't dlclose(so) here cause symbols from it are in use now */"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3646",
        "func_name": "kernel/git/bpf/bpf-next/nilfs_attach_log_writer",
        "description": "A vulnerability, which was classified as problematic, has been found in Linux Kernel. This issue affects the function nilfs_attach_log_writer of the file fs/nilfs2/segment.c of the component BPF. The manipulation leads to memory leak. The attack may be initiated remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211961 was assigned to this vulnerability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=d0d51a97063db4704a5ef6bc978dddab1636a306",
        "commit_title": "If nilfs_attach_log_writer() failed to create a log writer thread, it",
        "commit_text": "frees a data structure of the log writer without any cleanup.  After commit e912a5b66837 (\"nilfs2: use root object to get ifile\"), this causes a leak of struct nilfs_root, which started to leak an ifile metadata inode and a kobject on that struct.  In addition, if the kernel is booted with panic_on_warn, the above ifile metadata inode leak will cause the following panic when the nilfs2 kernel module is removed:    kmem_cache_destroy nilfs2_inode_cache: Slab cache still has objects when   called from nilfs_destroy_cachep+0x16/0x3a [nilfs2]   WARNING: CPU: 8 PID: 1464 at mm/slab_common.c:494 kmem_cache_destroy+0x138/0x140   ...   RIP: 0010:kmem_cache_destroy+0x138/0x140   Code: 00 20 00 00 e8 a9 55 d8 ff e9 76 ff ff ff 48 8b 53 60 48 c7 c6 20 70 65 86 48 c7 c7 d8 69 9c 86 48 8b 4c 24 28 e8 ef 71 c7 00 <0f> 0b e9 53 ff ff ff c3 48 81 ff ff 0f 00 00 77 03 31 c0 c3 53 48   ...   Call Trace:    <TASK>    ? nilfs_palloc_freev.cold.24+0x58/0x58 [nilfs2]    nilfs_destroy_cachep+0x16/0x3a [nilfs2]    exit_nilfs_fs+0xa/0x1b [nilfs2]     __x64_sys_delete_module+0x1d9/0x3a0    ? __sanitizer_cov_trace_pc+0x1a/0x50    ? syscall_trace_enter.isra.19+0x119/0x190    do_syscall_64+0x34/0x80    entry_SYSCALL_64_after_hwframe+0x63/0xcd    ...    </TASK>   Kernel panic - not syncing: panic_on_warn set ...  This patch fixes these issues by calling nilfs_detach_log_writer() cleanup function if spawning the log writer thread fails.  Link: https://lkml.kernel.org/r/20221007085226.57667-1-konishi.ryusuke@gmail.com Cc: <stable@vger.kernel.org> ",
        "func_before": "int nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\tinode_attach_wb(nilfs->ns_bdev->bd_inode, NULL);\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}",
        "func": "int nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\tinode_attach_wb(nilfs->ns_bdev->bd_inode, NULL);\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (unlikely(err))\n\t\tnilfs_detach_log_writer(sb);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,9 +19,8 @@\n \tinode_attach_wb(nilfs->ns_bdev->bd_inode, NULL);\n \n \terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n-\tif (err) {\n-\t\tkfree(nilfs->ns_writer);\n-\t\tnilfs->ns_writer = NULL;\n-\t}\n+\tif (unlikely(err))\n+\t\tnilfs_detach_log_writer(sb);\n+\n \treturn err;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (err) {",
                "\t\tkfree(nilfs->ns_writer);",
                "\t\tnilfs->ns_writer = NULL;",
                "\t}"
            ],
            "added_lines": [
                "\tif (unlikely(err))",
                "\t\tnilfs_detach_log_writer(sb);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3647",
        "func_name": "redis/sigsegvHandler",
        "description": "** DISPUTED ** A vulnerability, which was classified as problematic, was found in Redis up to 6.2.7/7.0.5. Affected is the function sigsegvHandler of the file debug.c of the component Crash Report. The manipulation leads to denial of service. The complexity of an attack is rather high. The exploitability is told to be difficult. The real existence of this vulnerability is still doubted at the moment. Upgrading to version 6.2.8 and 7.0.6 is able to address this issue. The patch is identified as 0bf90d944313919eb8e63d3588bf63a367f020a3. It is recommended to apply a patch to fix this issue. VDB-211962 is the identifier assigned to this vulnerability. NOTE: The vendor claims that this is not a DoS because it applies to the crash logging mechanism which is triggered after a crash has occurred.",
        "git_url": "https://github.com/redis/redis/commit/0bf90d944313919eb8e63d3588bf63a367f020a3",
        "commit_title": "Avoid crash on crash report when a bad function pointer was called (#11298)",
        "commit_text": " If Redis crashes due to calling an invalid function pointer,\r the `backtrace` function will try to dereference this invalid pointer\r which will cause a crash inside the crash report and will kill\r the processes without having all the crash report information.\r \r Example:\r \r ```\r === REDIS BUG REPORT START: Cut & paste starting from here ===\r 198672:M 19 Sep 2022 18:06:12.936 # Redis 255.255.255 crashed by signal: 11, si_code: 1\r 198672:M 19 Sep 2022 18:06:12.936 # Accessing address: 0x1\r 198672:M 19 Sep 2022 18:06:12.936 # Crashed running the instruction at: 0x1\r // here the processes is crashing\r ```\r \r This PR tries to fix this crash be:\r 1. Identify the issue when it happened.\r 2. Replace the invalid pointer with a pointer to some dummy function\r    so that `backtrace` will not crash.\r \r I identification is done by comparing `eip` to `info->si_addr`, if they\r are the same we know that the crash happened on the same address it tries to\r accesses and we can conclude that it tries to call and invalid function pointer.\r \r To replace the invalid pointer we introduce a new function, `setMcontextEip`,\r which is very similar to `getMcontextEip` and it knows to set the Eip for the\r different supported OS's. After printing the trace we retrieve the old `Eip` value.",
        "func_before": "void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    logStackTrace(getMcontextEip(uc), 1);\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();\n\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n\n    bugReportEnd(1, sig);\n}",
        "func": "void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getAndSetMcontextEip(uc, NULL);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    if (eip == info->si_addr) {\n        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped\n         * function pointer. In that case the call to backtrace will crash trying to access that address and we\n         * won't get a crash report logged. Set it to a valid point to avoid that crash. */\n\n        /* This trick allow to avoid compiler warning */\n        void *ptr;\n        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;\n        *ptr_ptr = invalidFunctionWasCalled;\n        getAndSetMcontextEip(uc, ptr);\n    }\n\n    logStackTrace(eip, 1);\n\n    if (eip == info->si_addr) {\n        /* Restore old eip */\n        getAndSetMcontextEip(uc, eip);\n    }\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();\n\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n\n    bugReportEnd(1, sig);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,13 +15,30 @@\n \n #ifdef HAVE_BACKTRACE\n     ucontext_t *uc = (ucontext_t*) secret;\n-    void *eip = getMcontextEip(uc);\n+    void *eip = getAndSetMcontextEip(uc, NULL);\n     if (eip != NULL) {\n         serverLog(LL_WARNING,\n         \"Crashed running the instruction at: %p\", eip);\n     }\n \n-    logStackTrace(getMcontextEip(uc), 1);\n+    if (eip == info->si_addr) {\n+        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped\n+         * function pointer. In that case the call to backtrace will crash trying to access that address and we\n+         * won't get a crash report logged. Set it to a valid point to avoid that crash. */\n+\n+        /* This trick allow to avoid compiler warning */\n+        void *ptr;\n+        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;\n+        *ptr_ptr = invalidFunctionWasCalled;\n+        getAndSetMcontextEip(uc, ptr);\n+    }\n+\n+    logStackTrace(eip, 1);\n+\n+    if (eip == info->si_addr) {\n+        /* Restore old eip */\n+        getAndSetMcontextEip(uc, eip);\n+    }\n \n     logRegisters(uc);\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "    void *eip = getMcontextEip(uc);",
                "    logStackTrace(getMcontextEip(uc), 1);"
            ],
            "added_lines": [
                "    void *eip = getAndSetMcontextEip(uc, NULL);",
                "    if (eip == info->si_addr) {",
                "        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped",
                "         * function pointer. In that case the call to backtrace will crash trying to access that address and we",
                "         * won't get a crash report logged. Set it to a valid point to avoid that crash. */",
                "",
                "        /* This trick allow to avoid compiler warning */",
                "        void *ptr;",
                "        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;",
                "        *ptr_ptr = invalidFunctionWasCalled;",
                "        getAndSetMcontextEip(uc, ptr);",
                "    }",
                "",
                "    logStackTrace(eip, 1);",
                "",
                "    if (eip == info->si_addr) {",
                "        /* Restore old eip */",
                "        getAndSetMcontextEip(uc, eip);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3647",
        "func_name": "redis/watchdogSignalHandler",
        "description": "** DISPUTED ** A vulnerability, which was classified as problematic, was found in Redis up to 6.2.7/7.0.5. Affected is the function sigsegvHandler of the file debug.c of the component Crash Report. The manipulation leads to denial of service. The complexity of an attack is rather high. The exploitability is told to be difficult. The real existence of this vulnerability is still doubted at the moment. Upgrading to version 6.2.8 and 7.0.6 is able to address this issue. The patch is identified as 0bf90d944313919eb8e63d3588bf63a367f020a3. It is recommended to apply a patch to fix this issue. VDB-211962 is the identifier assigned to this vulnerability. NOTE: The vendor claims that this is not a DoS because it applies to the crash logging mechanism which is triggered after a crash has occurred.",
        "git_url": "https://github.com/redis/redis/commit/0bf90d944313919eb8e63d3588bf63a367f020a3",
        "commit_title": "Avoid crash on crash report when a bad function pointer was called (#11298)",
        "commit_text": " If Redis crashes due to calling an invalid function pointer,\r the `backtrace` function will try to dereference this invalid pointer\r which will cause a crash inside the crash report and will kill\r the processes without having all the crash report information.\r \r Example:\r \r ```\r === REDIS BUG REPORT START: Cut & paste starting from here ===\r 198672:M 19 Sep 2022 18:06:12.936 # Redis 255.255.255 crashed by signal: 11, si_code: 1\r 198672:M 19 Sep 2022 18:06:12.936 # Accessing address: 0x1\r 198672:M 19 Sep 2022 18:06:12.936 # Crashed running the instruction at: 0x1\r // here the processes is crashing\r ```\r \r This PR tries to fix this crash be:\r 1. Identify the issue when it happened.\r 2. Replace the invalid pointer with a pointer to some dummy function\r    so that `backtrace` will not crash.\r \r I identification is done by comparing `eip` to `info->si_addr`, if they\r are the same we know that the crash happened on the same address it tries to\r accesses and we can conclude that it tries to call and invalid function pointer.\r \r To replace the invalid pointer we introduce a new function, `setMcontextEip`,\r which is very similar to `getMcontextEip` and it knows to set the Eip for the\r different supported OS's. After printing the trace we retrieve the old `Eip` value.",
        "func_before": "void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n#else\n    (void)secret;\n#endif\n    UNUSED(info);\n    UNUSED(sig);\n\n    serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n#ifdef HAVE_BACKTRACE\n    logStackTrace(getMcontextEip(uc), 1);\n#else\n    serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n#endif\n    serverLogFromHandler(LL_WARNING,\"--------\\n\");\n}",
        "func": "void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n#else\n    (void)secret;\n#endif\n    UNUSED(info);\n    UNUSED(sig);\n\n    serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n#ifdef HAVE_BACKTRACE\n    logStackTrace(getAndSetMcontextEip(uc, NULL), 1);\n#else\n    serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n#endif\n    serverLogFromHandler(LL_WARNING,\"--------\\n\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \n     serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n #ifdef HAVE_BACKTRACE\n-    logStackTrace(getMcontextEip(uc), 1);\n+    logStackTrace(getAndSetMcontextEip(uc, NULL), 1);\n #else\n     serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "    logStackTrace(getMcontextEip(uc), 1);"
            ],
            "added_lines": [
                "    logStackTrace(getAndSetMcontextEip(uc, NULL), 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-20154",
        "func_name": "ghostlander/Phoenixcoin/ProcessMessage",
        "description": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068.",
        "git_url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699",
        "commit_title": "Implement fLimitFree to CTxMemPool::accept()",
        "commit_text": " Works around a potential DoS vulnerability (see Bitcoin commit ce99358f4aa4182d6983fde3e33a8fdbe1dfe4c3).",
        "func_before": "bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n\n\n\n\n    if (strCommand == \"version\")\n    {\n        /* Process the 1st version message received per connection\n         * and ignore the others if any */\n        if(pfrom->nVersion)\n          return(true);\n\n        int64 nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64 nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n\n        // Do not connect to these clients as they're not Phoenixcoin ones or too old\n        if((pfrom->nVersion > MAX_PROTOCOL_VERSION) || (pfrom->nVersion < MIN_PROTOCOL_VERSION)) {\n            printf(\"peer %s reports incompatible version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s; disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        // Our external IP for getinfo\n        if(addrFrom.IsRoutable() && addrMe.IsRoutable()) addrExternal = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            int nAddrSize;\n            if(fBerkeleyAddrDB)\n              nAddrSize = mapAddresses.size();\n            else\n              nAddrSize = addrman.size();\n            if(pfrom->fOneShot || (nAddrSize < 1000)) {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            if(!fBerkeleyAddrDB)\n              addrman.Good(pfrom->addr);\n        } else {\n            if(!fBerkeleyAddrDB && ((CNetAddr)pfrom->addr == (CNetAddr)addrFrom)) {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Another Ghostlander's quick hack to deal with nodes advertising\n        // compatible version numbers while confusing our Qt client;\n        // if their nStartingHeight is much higher of what we estimate it\n        // to be, disconnect them.\n        // nRefHeight and nRefTime should be updated periodically\n        long nRefHeight = 745000, nRefTime = 1438677830; // block #745000\n        long nOurTime = GetAdjustedTime();\n        long nHeightOffset = (nOurTime - nRefTime) / nTargetSpacingFour;\n        // Add 10000 blocks to be safe\n        if(pfrom->nStartingHeight > (nRefHeight + nHeightOffset + 10000)) {\n            printf(\"peer %s reports height %i, estimated height is %i; disconnecting\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nStartingHeight, nRefHeight + nHeightOffset);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay advanced checkpoints\n        {\n            LOCK(cs_hashSyncCheckpoint);\n            if (!checkpointMessage.IsNull())\n                checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"received version message from %s, version %d, blocks=%d, us=%s, them=%s\\n\",\n          pfrom->addr.ToString().c_str(), pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // Check for any advanced checkpoint pending\n        if (!IsInitialBlockDownload())\n            AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        if(vAddr.size() > 1000) {\n            pfrom->Misbehaving(20);\n            return(error(\"Address message size = %d\", vAddr.size()));\n        }\n\n        int64 nNow = GetAdjustedTime();\n        int64 nSince = nNow - 10 * 60;\n        bool fReachable;\n\n        if(fBerkeleyAddrDB) {\n\n            CBerkeleyAddrDB adb;\n            adb.TxnBegin();\n\n            BOOST_FOREACH(CAddress& addr, vAddr) {\n\n                if(fShutdown)\n                  return(true);\n\n                /* Simple port filter */\n                ushort nPort = addr.GetPort();\n                if(nPort != GetDefaultPort())\n                  continue;\n\n                if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))\n                  addr.nTime = nNow - 5 * 24 * 60 * 60;\n\n                fReachable = IsReachable(addr);\n\n                if(fReachable)\n                  AddAddress(addr, 2 * 60 * 60, &adb);\n\n                pfrom->AddAddressKnown(addr);\n\n                if((addr.nTime > nSince) && !pfrom->fGetAddr &&\n                  (vAddr.size() <= 10) && addr.IsRoutable())\n                  RelayAddress(addr, fReachable);\n\n            }\n\n            adb.TxnCommit();\n\n        } else {\n\n            vector<CAddress> vAddrOk;\n\n            BOOST_FOREACH(CAddress& addr, vAddr) {\n\n                if(fShutdown)\n                  return(true);\n\n                /* Simple port filter */\n                ushort nPort = addr.GetPort();\n                if(nPort != GetDefaultPort())\n                  continue;\n\n                if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))\n                  addr.nTime = nNow - 5 * 24 * 60 * 60;\n\n                fReachable = IsReachable(addr);\n\n                if(fReachable)\n                  vAddrOk.push_back(addr);\n\n                pfrom->AddAddressKnown(addr);\n\n                if((addr.nTime > nSince) && !pfrom->fGetAddr &&\n                  (vAddr.size() <= 10) && addr.IsRoutable())\n                  RelayAddress(addr, fReachable);\n\n            }\n\n            addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n\n        }\n\n        if(vAddr.size() < 1000)\n          pfrom->fGetAddr = false;\n\n        if(pfrom->fOneShot)\n          pfrom->fDisconnect = true;\n\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %d\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                std::vector<CInv> vGetData(1,inv);\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %d\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%d invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // Bypass PushInventory, this must send even if redundant,\n                        // and we want it right after the last block so they don't\n                        // wait for other stuff first.\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end())\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 1000;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        // Truncate a message to the actual transaction size\n        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n        unsigned int oldSize = vMsg.size();\n        if(nSize < oldSize) {\n            printf(\"truncating oversized transaction message %s (%u -> %u)\\n\",\n              tx.GetHash().ToString().c_str(), oldSize, nSize);\n            vMsg.resize(nSize);\n        }\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayMessage(inv, vMsg);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (map<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const CDataStream& vMsg = *((*mi).second);\n                    CTransaction tx;\n                    CDataStream(vMsg) >> tx;\n                    CInv inv(MSG_TX, tx.GetHash());\n                    bool fMissingInputs2 = false;\n\n                    if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayMessage(inv, vMsg);\n                        mapAlreadyAskedFor.erase(inv);\n                        vWorkQueue.push_back(inv.hash);\n                        vEraseQueue.push_back(inv.hash);\n                    }\n                    else if (!fMissingInputs2)\n                    {\n                        // invalid orphan\n                        vEraseQueue.push_back(inv.hash);\n                        printf(\"   removed invalid orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(vMsg);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n        int nBlockHeight = block.GetBlockHeight();\n\n        printf(\"received block %s height %d\\n\",\n          hashBlock.ToString().substr(0,20).c_str(), nBlockHeight);\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if(ProcessBlock(pfrom, &block))\n          mapAlreadyAskedFor.erase(inv);\n\n        if(block.nDoS)\n          pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64 nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        if(pfrom->fDisconnect) {\n            printf(\"alert received from a disconnected peer %s of version %i; ignoring\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            return false;\n        }\n\n        CAlert alert;\n        vRecv >> alert;\n\n        if (alert.ProcessAlert())\n        {\n            // Relay\n            pfrom->setKnown.insert(alert.GetHash());\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    alert.RelayTo(pnode);\n            }\n        } else {\n             // DDoS protection\n             pfrom->Misbehaving(20);\n        }\n    }\n\n\n    // Advanced checkpoint\n    else if (strCommand == \"checkpoint\")\n    {\n        if(pfrom->fDisconnect) {\n            printf(\"sync-checkpoint received from a disconnected peer %s of version %i; ignoring\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            return false;\n        }\n\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}",
        "func": "bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n\n\n\n\n    if (strCommand == \"version\")\n    {\n        /* Process the 1st version message received per connection\n         * and ignore the others if any */\n        if(pfrom->nVersion)\n          return(true);\n\n        int64 nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64 nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n\n        // Do not connect to these clients as they're not Phoenixcoin ones or too old\n        if((pfrom->nVersion > MAX_PROTOCOL_VERSION) || (pfrom->nVersion < MIN_PROTOCOL_VERSION)) {\n            printf(\"peer %s reports incompatible version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s; disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        // Our external IP for getinfo\n        if(addrFrom.IsRoutable() && addrMe.IsRoutable()) addrExternal = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            int nAddrSize;\n            if(fBerkeleyAddrDB)\n              nAddrSize = mapAddresses.size();\n            else\n              nAddrSize = addrman.size();\n            if(pfrom->fOneShot || (nAddrSize < 1000)) {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            if(!fBerkeleyAddrDB)\n              addrman.Good(pfrom->addr);\n        } else {\n            if(!fBerkeleyAddrDB && ((CNetAddr)pfrom->addr == (CNetAddr)addrFrom)) {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Another Ghostlander's quick hack to deal with nodes advertising\n        // compatible version numbers while confusing our Qt client;\n        // if their nStartingHeight is much higher of what we estimate it\n        // to be, disconnect them.\n        // nRefHeight and nRefTime should be updated periodically\n        long nRefHeight = 745000, nRefTime = 1438677830; // block #745000\n        long nOurTime = GetAdjustedTime();\n        long nHeightOffset = (nOurTime - nRefTime) / nTargetSpacingFour;\n        // Add 10000 blocks to be safe\n        if(pfrom->nStartingHeight > (nRefHeight + nHeightOffset + 10000)) {\n            printf(\"peer %s reports height %i, estimated height is %i; disconnecting\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nStartingHeight, nRefHeight + nHeightOffset);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay advanced checkpoints\n        {\n            LOCK(cs_hashSyncCheckpoint);\n            if (!checkpointMessage.IsNull())\n                checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"received version message from %s, version %d, blocks=%d, us=%s, them=%s\\n\",\n          pfrom->addr.ToString().c_str(), pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // Check for any advanced checkpoint pending\n        if (!IsInitialBlockDownload())\n            AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        if(vAddr.size() > 1000) {\n            pfrom->Misbehaving(20);\n            return(error(\"Address message size = %d\", vAddr.size()));\n        }\n\n        int64 nNow = GetAdjustedTime();\n        int64 nSince = nNow - 10 * 60;\n        bool fReachable;\n\n        if(fBerkeleyAddrDB) {\n\n            CBerkeleyAddrDB adb;\n            adb.TxnBegin();\n\n            BOOST_FOREACH(CAddress& addr, vAddr) {\n\n                if(fShutdown)\n                  return(true);\n\n                /* Simple port filter */\n                ushort nPort = addr.GetPort();\n                if(nPort != GetDefaultPort())\n                  continue;\n\n                if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))\n                  addr.nTime = nNow - 5 * 24 * 60 * 60;\n\n                fReachable = IsReachable(addr);\n\n                if(fReachable)\n                  AddAddress(addr, 2 * 60 * 60, &adb);\n\n                pfrom->AddAddressKnown(addr);\n\n                if((addr.nTime > nSince) && !pfrom->fGetAddr &&\n                  (vAddr.size() <= 10) && addr.IsRoutable())\n                  RelayAddress(addr, fReachable);\n\n            }\n\n            adb.TxnCommit();\n\n        } else {\n\n            vector<CAddress> vAddrOk;\n\n            BOOST_FOREACH(CAddress& addr, vAddr) {\n\n                if(fShutdown)\n                  return(true);\n\n                /* Simple port filter */\n                ushort nPort = addr.GetPort();\n                if(nPort != GetDefaultPort())\n                  continue;\n\n                if((addr.nTime <= 100000000) || (addr.nTime > nNow + 10 * 60))\n                  addr.nTime = nNow - 5 * 24 * 60 * 60;\n\n                fReachable = IsReachable(addr);\n\n                if(fReachable)\n                  vAddrOk.push_back(addr);\n\n                pfrom->AddAddressKnown(addr);\n\n                if((addr.nTime > nSince) && !pfrom->fGetAddr &&\n                  (vAddr.size() <= 10) && addr.IsRoutable())\n                  RelayAddress(addr, fReachable);\n\n            }\n\n            addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n\n        }\n\n        if(vAddr.size() < 1000)\n          pfrom->fGetAddr = false;\n\n        if(pfrom->fOneShot)\n          pfrom->fDisconnect = true;\n\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %d\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                std::vector<CInv> vGetData(1,inv);\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %d\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%d invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // Bypass PushInventory, this must send even if redundant,\n                        // and we want it right after the last block so they don't\n                        // wait for other stuff first.\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end())\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 1000;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        // Truncate a message to the actual transaction size\n        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n        unsigned int oldSize = vMsg.size();\n        if(nSize < oldSize) {\n            printf(\"truncating oversized transaction message %s (%u -> %u)\\n\",\n              tx.GetHash().ToString().c_str(), oldSize, nSize);\n            vMsg.resize(nSize);\n        }\n\n        bool fMissingInputs = false;\n        if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs)) {\n            SyncWithWallets(tx, NULL, true);\n            RelayMessage(inv, vMsg);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (map<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const CDataStream& vMsg = *((*mi).second);\n                    CTransaction tx;\n                    CDataStream(vMsg) >> tx;\n                    CInv inv(MSG_TX, tx.GetHash());\n                    bool fMissingInputs2 = false;\n\n                    if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs2)) {\n                        printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayMessage(inv, vMsg);\n                        mapAlreadyAskedFor.erase(inv);\n                        vWorkQueue.push_back(inv.hash);\n                        vEraseQueue.push_back(inv.hash);\n                    }\n                    else if(!fMissingInputs2) {\n                        /* Invalid or insufficient fee orphan */\n                        vEraseQueue.push_back(inv.hash);\n                        printf(\"   removed orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(vMsg);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n        int nBlockHeight = block.GetBlockHeight();\n\n        printf(\"received block %s height %d\\n\",\n          hashBlock.ToString().substr(0,20).c_str(), nBlockHeight);\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if(ProcessBlock(pfrom, &block))\n          mapAlreadyAskedFor.erase(inv);\n\n        if(block.nDoS)\n          pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64 nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        if(pfrom->fDisconnect) {\n            printf(\"alert received from a disconnected peer %s of version %i; ignoring\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            return false;\n        }\n\n        CAlert alert;\n        vRecv >> alert;\n\n        if (alert.ProcessAlert())\n        {\n            // Relay\n            pfrom->setKnown.insert(alert.GetHash());\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    alert.RelayTo(pnode);\n            }\n        } else {\n             // DDoS protection\n             pfrom->Misbehaving(20);\n        }\n    }\n\n\n    // Advanced checkpoint\n    else if (strCommand == \"checkpoint\")\n    {\n        if(pfrom->fDisconnect) {\n            printf(\"sync-checkpoint received from a disconnected peer %s of version %i; ignoring\\n\",\n              pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            return false;\n        }\n\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -459,8 +459,7 @@\n         }\n \n         bool fMissingInputs = false;\n-        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n-        {\n+        if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs)) {\n             SyncWithWallets(tx, NULL, true);\n             RelayMessage(inv, vMsg);\n             mapAlreadyAskedFor.erase(inv);\n@@ -481,8 +480,7 @@\n                     CInv inv(MSG_TX, tx.GetHash());\n                     bool fMissingInputs2 = false;\n \n-                    if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n-                    {\n+                    if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs2)) {\n                         printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                         SyncWithWallets(tx, NULL, true);\n                         RelayMessage(inv, vMsg);\n@@ -490,11 +488,10 @@\n                         vWorkQueue.push_back(inv.hash);\n                         vEraseQueue.push_back(inv.hash);\n                     }\n-                    else if (!fMissingInputs2)\n-                    {\n-                        // invalid orphan\n+                    else if(!fMissingInputs2) {\n+                        /* Invalid or insufficient fee orphan */\n                         vEraseQueue.push_back(inv.hash);\n-                        printf(\"   removed invalid orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n+                        printf(\"   removed orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                     }\n                 }\n             }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))",
                "        {",
                "                    if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))",
                "                    {",
                "                    else if (!fMissingInputs2)",
                "                    {",
                "                        // invalid orphan",
                "                        printf(\"   removed invalid orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());"
            ],
            "added_lines": [
                "        if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs)) {",
                "                    if(tx.AcceptToMemoryPool(txdb, true, true, &fMissingInputs2)) {",
                "                    else if(!fMissingInputs2) {",
                "                        /* Invalid or insufficient fee orphan */",
                "                        printf(\"   removed orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-20154",
        "func_name": "ghostlander/Phoenixcoin/CTransaction::AcceptToMemoryPool",
        "description": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068.",
        "git_url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699",
        "commit_title": "Implement fLimitFree to CTxMemPool::accept()",
        "commit_text": " Works around a potential DoS vulnerability (see Bitcoin commit ce99358f4aa4182d6983fde3e33a8fdbe1dfe4c3).",
        "func_before": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}",
        "func": "bool CTransaction::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs, bool fLimitFree,\n  bool *pfMissingInputs) {\n\n    return mempool.accept(txdb, *this, fCheckInputs, fLimitFree, pfMissingInputs);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n-bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n-{\n-    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n+bool CTransaction::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs, bool fLimitFree,\n+  bool *pfMissingInputs) {\n+\n+    return mempool.accept(txdb, *this, fCheckInputs, fLimitFree, pfMissingInputs);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)",
                "{",
                "    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);"
            ],
            "added_lines": [
                "bool CTransaction::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs, bool fLimitFree,",
                "  bool *pfMissingInputs) {",
                "",
                "    return mempool.accept(txdb, *this, fCheckInputs, fLimitFree, pfMissingInputs);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-20154",
        "func_name": "ghostlander/Phoenixcoin/CWalletTx::AcceptWalletTransaction",
        "description": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068.",
        "git_url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699",
        "commit_title": "Implement fLimitFree to CTxMemPool::accept()",
        "commit_text": " Works around a potential DoS vulnerability (see Bitcoin commit ce99358f4aa4182d6983fde3e33a8fdbe1dfe4c3).",
        "func_before": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n\n    {\n        LOCK(mempool.cs);\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}",
        "func": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n\n    {\n        LOCK(mempool.cs);\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs, false);\n            }\n        }\n        return(AcceptToMemoryPool(txdb, fCheckInputs, false));\n    }\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,10 +10,10 @@\n             {\n                 uint256 hash = tx.GetHash();\n                 if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n-                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n+                    tx.AcceptToMemoryPool(txdb, fCheckInputs, false);\n             }\n         }\n-        return AcceptToMemoryPool(txdb, fCheckInputs);\n+        return(AcceptToMemoryPool(txdb, fCheckInputs, false));\n     }\n     return false;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                    tx.AcceptToMemoryPool(txdb, fCheckInputs);",
                "        return AcceptToMemoryPool(txdb, fCheckInputs);"
            ],
            "added_lines": [
                "                    tx.AcceptToMemoryPool(txdb, fCheckInputs, false);",
                "        return(AcceptToMemoryPool(txdb, fCheckInputs, false));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-20154",
        "func_name": "ghostlander/Phoenixcoin/Reorganize",
        "description": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068.",
        "git_url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699",
        "commit_title": "Implement fLimitFree to CTxMemPool::accept()",
        "commit_text": " Works around a potential DoS vulnerability (see Bitcoin commit ce99358f4aa4182d6983fde3e33a8fdbe1dfe4c3).",
        "func_before": "bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %i blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %i blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!tx.IsCoinBase())\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}",
        "func": "bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %i blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %i blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!tx.IsCoinBase())\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n      tx.AcceptToMemoryPool(txdb, true, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -83,7 +83,7 @@\n \n     // Resurrect memory transactions that were in the disconnected branch\n     BOOST_FOREACH(CTransaction& tx, vResurrect)\n-        tx.AcceptToMemoryPool(txdb, false);\n+      tx.AcceptToMemoryPool(txdb, true, false);\n \n     // Delete redundant memory transactions that are in the connected branch\n     BOOST_FOREACH(CTransaction &tx, vDelete) {",
        "diff_line_info": {
            "deleted_lines": [
                "        tx.AcceptToMemoryPool(txdb, false);"
            ],
            "added_lines": [
                "      tx.AcceptToMemoryPool(txdb, true, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-20154",
        "func_name": "ghostlander/Phoenixcoin/CTxMemPool::accept",
        "description": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068.",
        "git_url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699",
        "commit_title": "Implement fLimitFree to CTxMemPool::accept()",
        "commit_text": " Works around a potential DoS vulnerability (see Bitcoin commit ce99358f4aa4182d6983fde3e33a8fdbe1dfe4c3).",
        "func_before": "bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                        bool* pfMissingInputs)\n{\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!tx.CheckTransaction())\n        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (tx.IsCoinBase())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !tx.IsStandard())\n        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs);\n        if (mapTx.count(hash))\n            return false;\n    }\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (unsigned int i = 0; i < tx.vin.size(); i++)\n    {\n        COutPoint outpoint = tx.vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!tx.IsNewerThan(*ptxOld))\n                return false;\n            for (unsigned int i = 0; i < tx.vin.size(); i++)\n            {\n                COutPoint outpoint = tx.vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return false;\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64 nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n        unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n        // Don't accept it if it can't get into a block\n        if(nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY))\n            return error(\"CTxMemPool::accept() : not enough fees\");\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make other's transactions take longer to confirm.\n        if (nFees < MIN_RELAY_TX_FEE)\n        {\n            static CCriticalSection cs;\n            static double dFreeCount;\n            static int64 nLastTime;\n            int64 nNow = GetTime();\n\n            {\n                LOCK(cs);\n                // Use an exponentially decaying ~10-minute window:\n                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                nLastTime = nNow;\n                // -limitfreerelay unit is thousand-bytes-per-minute\n                // At default rate it would take over a month to fill 1GB\n                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                if (fDebug)\n                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nTxSize);\n                dFreeCount += nTxSize;\n            }\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    {\n        LOCK(cs);\n        if (ptxOld)\n        {\n            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            remove(*ptxOld);\n        }\n        addUnchecked(hash, tx);\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"CTxMemPool::accept() : accepted %s (poolsz %u)\\n\",\n           hash.ToString().substr(0,10).c_str(),\n           mapTx.size());\n    return true;\n}",
        "func": "bool CTxMemPool::accept(CTxDB &txdb, CTransaction &tx, bool fCheckInputs,\n  bool fLimitFree, bool *pfMissingInputs) {\n\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!tx.CheckTransaction())\n        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (tx.IsCoinBase())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !tx.IsStandard())\n        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs);\n        if (mapTx.count(hash))\n            return false;\n    }\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (unsigned int i = 0; i < tx.vin.size(); i++)\n    {\n        COutPoint outpoint = tx.vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!tx.IsNewerThan(*ptxOld))\n                return false;\n            for (unsigned int i = 0; i < tx.vin.size(); i++)\n            {\n                COutPoint outpoint = tx.vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return false;\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64 nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n        unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n        // Don't accept it if it can't get into a block\n        if(fLimitFree && (nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY)))\n          return(error(\"CTxMemPool::accept() : not enough fees\"));\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make other's transactions take longer to confirm.\n        if(fLimitFree && (nFees < MIN_RELAY_TX_FEE)) {\n            static double dFreeCount;\n            static int64 nLastTime;\n            int64 nNow = GetTime();\n\n            LOCK(cs);\n\n            // Use an exponentially decaying ~10-minute window:\n            dFreeCount *= pow(1.0 - 1.0 / 600.0, (double)(nNow - nLastTime));\n            nLastTime = nNow;\n            // -limitfreerelay unit is thousand-bytes-per-minute\n            // At default rate it would take over a month to fill 1GB\n            if(dFreeCount > GetArg(\"-limitfreerelay\", 15) * 10 * 1000)\n              return(error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\"));\n            if(fDebug)\n              printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount + nTxSize);\n            dFreeCount += nTxSize;\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    {\n        LOCK(cs);\n        if (ptxOld)\n        {\n            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            remove(*ptxOld);\n        }\n        addUnchecked(hash, tx);\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"CTxMemPool::accept() : accepted %s (poolsz %u)\\n\",\n           hash.ToString().substr(0,10).c_str(),\n           mapTx.size());\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n-bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n-                        bool* pfMissingInputs)\n-{\n+bool CTxMemPool::accept(CTxDB &txdb, CTransaction &tx, bool fCheckInputs,\n+  bool fLimitFree, bool *pfMissingInputs) {\n+\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n@@ -84,32 +84,29 @@\n         unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n \n         // Don't accept it if it can't get into a block\n-        if(nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY))\n-            return error(\"CTxMemPool::accept() : not enough fees\");\n+        if(fLimitFree && (nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY)))\n+          return(error(\"CTxMemPool::accept() : not enough fees\"));\n \n         // Continuously rate-limit free transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n         // be annoying or make other's transactions take longer to confirm.\n-        if (nFees < MIN_RELAY_TX_FEE)\n-        {\n-            static CCriticalSection cs;\n+        if(fLimitFree && (nFees < MIN_RELAY_TX_FEE)) {\n             static double dFreeCount;\n             static int64 nLastTime;\n             int64 nNow = GetTime();\n \n-            {\n-                LOCK(cs);\n-                // Use an exponentially decaying ~10-minute window:\n-                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n-                nLastTime = nNow;\n-                // -limitfreerelay unit is thousand-bytes-per-minute\n-                // At default rate it would take over a month to fill 1GB\n-                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n-                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n-                if (fDebug)\n-                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nTxSize);\n-                dFreeCount += nTxSize;\n-            }\n+            LOCK(cs);\n+\n+            // Use an exponentially decaying ~10-minute window:\n+            dFreeCount *= pow(1.0 - 1.0 / 600.0, (double)(nNow - nLastTime));\n+            nLastTime = nNow;\n+            // -limitfreerelay unit is thousand-bytes-per-minute\n+            // At default rate it would take over a month to fill 1GB\n+            if(dFreeCount > GetArg(\"-limitfreerelay\", 15) * 10 * 1000)\n+              return(error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\"));\n+            if(fDebug)\n+              printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount + nTxSize);\n+            dFreeCount += nTxSize;\n         }\n \n         // Check against previous transactions",
        "diff_line_info": {
            "deleted_lines": [
                "bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,",
                "                        bool* pfMissingInputs)",
                "{",
                "        if(nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY))",
                "            return error(\"CTxMemPool::accept() : not enough fees\");",
                "        if (nFees < MIN_RELAY_TX_FEE)",
                "        {",
                "            static CCriticalSection cs;",
                "            {",
                "                LOCK(cs);",
                "                // Use an exponentially decaying ~10-minute window:",
                "                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));",
                "                nLastTime = nNow;",
                "                // -limitfreerelay unit is thousand-bytes-per-minute",
                "                // At default rate it would take over a month to fill 1GB",
                "                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))",
                "                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");",
                "                if (fDebug)",
                "                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nTxSize);",
                "                dFreeCount += nTxSize;",
                "            }"
            ],
            "added_lines": [
                "bool CTxMemPool::accept(CTxDB &txdb, CTransaction &tx, bool fCheckInputs,",
                "  bool fLimitFree, bool *pfMissingInputs) {",
                "",
                "        if(fLimitFree && (nFees < tx.GetMinFee(nTxSize, true, GMF_RELAY)))",
                "          return(error(\"CTxMemPool::accept() : not enough fees\"));",
                "        if(fLimitFree && (nFees < MIN_RELAY_TX_FEE)) {",
                "            LOCK(cs);",
                "",
                "            // Use an exponentially decaying ~10-minute window:",
                "            dFreeCount *= pow(1.0 - 1.0 / 600.0, (double)(nNow - nLastTime));",
                "            nLastTime = nNow;",
                "            // -limitfreerelay unit is thousand-bytes-per-minute",
                "            // At default rate it would take over a month to fill 1GB",
                "            if(dFreeCount > GetArg(\"-limitfreerelay\", 15) * 10 * 1000)",
                "              return(error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\"));",
                "            if(fDebug)",
                "              printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount + nTxSize);",
                "            dFreeCount += nTxSize;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-20154",
        "func_name": "ghostlander/Phoenixcoin/sendrawtransaction",
        "description": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068.",
        "git_url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699",
        "commit_title": "Implement fLimitFree to CTxMemPool::accept()",
        "commit_text": " Works around a potential DoS vulnerability (see Bitcoin commit ce99358f4aa4182d6983fde3e33a8fdbe1dfe4c3).",
        "func_before": "Value sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    // parse hex string from parameter\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n\n    // deserialize binary data stream\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n\n    // See if the transaction is already in a block\n    // or in the memory pool:\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(-5, string(\"transaction already in block \")+hashBlock.GetHex());\n        // Not in block, but already in the memory pool; will drop\n        // through to re-relay it.\n    }\n    else\n    {\n        // push to local node\n        CTxDB txdb(\"r\");\n        if (!tx.AcceptToMemoryPool(txdb))\n            throw JSONRPCError(-22, \"TX rejected\");\n\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayMessage(CInv(MSG_TX, hashTx), tx);\n\n    return hashTx.GetHex();\n}",
        "func": "Value sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    // parse hex string from parameter\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n\n    // deserialize binary data stream\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n\n    // See if the transaction is already in a block\n    // or in the memory pool:\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(-5, string(\"transaction already in block \")+hashBlock.GetHex());\n        // Not in block, but already in the memory pool; will drop\n        // through to re-relay it.\n    }\n    else\n    {\n        // push to local node\n        CTxDB txdb(\"r\");\n        if(!tx.AcceptToMemoryPool(txdb, true, false))\n          throw(JSONRPCError(-22, \"TX rejected\"));\n\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayMessage(CInv(MSG_TX, hashTx), tx);\n\n    return hashTx.GetHex();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,8 +36,8 @@\n     {\n         // push to local node\n         CTxDB txdb(\"r\");\n-        if (!tx.AcceptToMemoryPool(txdb))\n-            throw JSONRPCError(-22, \"TX rejected\");\n+        if(!tx.AcceptToMemoryPool(txdb, true, false))\n+          throw(JSONRPCError(-22, \"TX rejected\"));\n \n         SyncWithWallets(tx, NULL, true);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!tx.AcceptToMemoryPool(txdb))",
                "            throw JSONRPCError(-22, \"TX rejected\");"
            ],
            "added_lines": [
                "        if(!tx.AcceptToMemoryPool(txdb, true, false))",
                "          throw(JSONRPCError(-22, \"TX rejected\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-20154",
        "func_name": "ghostlander/Phoenixcoin/CWallet::CommitTransaction",
        "description": "A vulnerability was found in ghostlander Phoenixcoin. It has been classified as problematic. Affected is the function CTxMemPool::accept of the file src/main.cpp. The manipulation leads to denial of service. Upgrading to version 0.6.6.1-pxc is able to address this issue. The name of the patch is 987dd68f71a7d8276cef3b6c3d578fd4845b5699. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217068.",
        "git_url": "https://github.com/ghostlander/Phoenixcoin/commit/987dd68f71a7d8276cef3b6c3d578fd4845b5699",
        "commit_title": "Implement fLimitFree to CTxMemPool::accept()",
        "commit_text": " Works around a potential DoS vulnerability (see Bitcoin commit ce99358f4aa4182d6983fde3e33a8fdbe1dfe4c3).",
        "func_before": "bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}",
        "func": "bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        CTxDB txdb(\"r\");\n        if(!wtxNew.AcceptToMemoryPool(txdb, true, false)) {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,8 +35,8 @@\n         mapRequestCount[wtxNew.GetHash()] = 0;\n \n         // Broadcast\n-        if (!wtxNew.AcceptToMemoryPool())\n-        {\n+        CTxDB txdb(\"r\");\n+        if(!wtxNew.AcceptToMemoryPool(txdb, true, false)) {\n             // This must not fail. The transaction has already been signed and recorded.\n             printf(\"CommitTransaction() : Error: Transaction not valid\");\n             return false;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!wtxNew.AcceptToMemoryPool())",
                "        {"
            ],
            "added_lines": [
                "        CTxDB txdb(\"r\");",
                "        if(!wtxNew.AcceptToMemoryPool(txdb, true, false)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25062",
        "func_name": "flar2/ElementalX-N9/xfrm_dump_policy",
        "description": "A vulnerability classified as problematic has been found in flar2 ElementalX up to 6.x on Nexus 9. Affected is the function xfrm_dump_policy_done of the file net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial of service. Upgrading to version 7.00 is able to address this issue. The name of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217152.",
        "git_url": "https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79",
        "commit_title": "ipsec: Fix aborted xfrm policy dump crash",
        "commit_text": " An independent security researcher, Mohamed Ghannam, has reported this vulnerability to Beyond Security's SecuriTeam Secure Disclosure program.  The xfrm_dump_policy_done function expects xfrm_dump_policy to have been called at least once or it will crash.  This can be triggered if a dump fails because the target socket's receive buffer is full.  This patch fixes it by using the cb->start mechanism to ensure that the initialisation is always done regardless of the buffer situation. ",
        "func_before": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}",
        "func": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct xfrm_dump_info info;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,22 +1,14 @@\n static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n {\n \tstruct net *net = sock_net(skb->sk);\n-\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n+\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n \tstruct xfrm_dump_info info;\n-\n-\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n-\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n \n \tinfo.in_skb = cb->skb;\n \tinfo.out_skb = skb;\n \tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n \tinfo.nlmsg_flags = NLM_F_MULTI;\n \n-\tif (!cb->args[0]) {\n-\t\tcb->args[0] = 1;\n-\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n-\t}\n-\n \t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n \n \treturn skb->len;",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];",
                "",
                "\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >",
                "\t\t     sizeof(cb->args) - sizeof(cb->args[0]));",
                "\tif (!cb->args[0]) {",
                "\t\tcb->args[0] = 1;",
                "\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);",
                "\t}",
                ""
            ],
            "added_lines": [
                "\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25062",
        "func_name": "flar2/ElementalX-N9/xfrm_dump_policy_done",
        "description": "A vulnerability classified as problematic has been found in flar2 ElementalX up to 6.x on Nexus 9. Affected is the function xfrm_dump_policy_done of the file net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial of service. Upgrading to version 7.00 is able to address this issue. The name of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217152.",
        "git_url": "https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79",
        "commit_title": "ipsec: Fix aborted xfrm policy dump crash",
        "commit_text": " An independent security researcher, Mohamed Ghannam, has reported this vulnerability to Beyond Security's SecuriTeam Secure Disclosure program.  The xfrm_dump_policy_done function expects xfrm_dump_policy to have been called at least once or it will crash.  This can be triggered if a dump fails because the target socket's receive buffer is full.  This patch fixes it by using the cb->start mechanism to ensure that the initialisation is always done regardless of the buffer situation. ",
        "func_before": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\n\txfrm_policy_walk_done(walk);\n\treturn 0;\n}",
        "func": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\n\txfrm_policy_walk_done(walk);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int xfrm_dump_policy_done(struct netlink_callback *cb)\n {\n-\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n+\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n \n \txfrm_policy_walk_done(walk);\n \treturn 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];"
            ],
            "added_lines": [
                "\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25062",
        "func_name": "flar2/ElementalX-N9/xfrm_user_rcv_msg",
        "description": "A vulnerability classified as problematic has been found in flar2 ElementalX up to 6.x on Nexus 9. Affected is the function xfrm_dump_policy_done of the file net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial of service. Upgrading to version 7.00 is able to address this issue. The name of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217152.",
        "git_url": "https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79",
        "commit_title": "ipsec: Fix aborted xfrm policy dump crash",
        "commit_text": " An independent security researcher, Mohamed Ghannam, has reported this vulnerability to Beyond Security's SecuriTeam Secure Disclosure program.  The xfrm_dump_policy_done function expects xfrm_dump_policy to have been called at least once or it will crash.  This can be triggered if a dump fails because the target socket's receive buffer is full.  This patch fixes it by using the cb->start mechanism to ensure that the initialisation is always done regardless of the buffer situation. ",
        "func_before": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}",
        "func": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,7 @@\n \n \t\t{\n \t\t\tstruct netlink_dump_control c = {\n+\t\t\t\t.start = link->start,\n \t\t\t\t.dump = link->dump,\n \t\t\t\t.done = link->done,\n \t\t\t};",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\t.start = link->start,"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0412",
        "func_name": "wireshark/proto_register_tipc",
        "description": "TIPC dissector crash in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/659b830aef88753d7b1ba67230d30add31f7d24e",
        "commit_title": "TIPC: Add a recursion check",
        "commit_text": " Add a recursion check. Fixes #18770. ",
        "func_before": "void\nproto_register_tipc(void)\n{\n\tstatic hf_register_info hf[] = {\n\t\t{ &hf_tipc_msg_fragments,\n\t\t\t{ \"Message fragments\", \"tipc.msg.fragments\",\n\t\t\t\tFT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment,\n\t\t\t{ \"Message fragment\", \"tipc.msg.fragment\",\n\t\t\t\tFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_overlap,\n\t\t\t{ \"Message fragment overlap\", \"tipc.msg.fragment.overlap\",\n\t\t\t\tFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_overlap_conflicts,\n\t\t\t{ \"Message fragment overlapping with conflicting data\", \"tipc.msg.fragment.overlap.conflicts\",\n\t\t\t\tFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_multiple_tails,\n\t\t\t{ \"Message has multiple tail fragments\", \"tipc.msg.fragment.multiple_tails\",\n\t\t\t\tFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_too_long_fragment,\n\t\t\t{ \"Message fragment too long\", \"tipc.msg.fragment.too_long_fragment\",\n\t\t\t\tFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_error,\n\t\t\t{ \"Message defragmentation error\", \"tipc.msg.fragment.error\",\n\t\t\t\tFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_count,\n\t\t\t{ \"Message fragment count\", \"tipc.msg.fragment.count\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_reassembled_in,\n\t\t\t{ \"Reassembled in\", \"tipc.msg.reassembled.in\",\n\t\t\t\tFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_reassembled_length,\n\t\t\t{ \"Reassembled TIPC length\", \"tipc.msg.reassembled.length\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_ver,\n\t\t\t{ \"Version\", \"tipc.ver\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xe0000000,\n\t\t\t\t\"TIPC protocol version\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_usr,\n\t\t\t{ \"User\", \"tipc.usr\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_user_values), 0x1e000000,\n\t\t\t\t\"TIPC User\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_usr,\n\t\t\t{ \"User\", \"tipc.usr\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_user_values), 0x1e000000,\n\t\t\t\t\"TIPC User\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_hdr_size,\n\t\t\t{ \"Header size\", \"tipc.hdr_size\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x01e00000,\n\t\t\t\t\"TIPC Header size\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_nonsequenced,\n\t\t\t{ \"Non-sequenced\", \"tipc.non_sequenced\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00100000,\n\t\t\t\t\"Non-sequenced Bit\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_destdrop,\n\t\t\t{ \"Destination Droppable\", \"tipc.destdrop\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00080000,\n\t\t\t\t\"Destination Droppable Bit\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_unused,\n\t\t\t{ \"Unused\", \"tipc.hdr_unused\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x000e0000,\n\t\t\t\t\"TIPC Unused\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_size,\n\t\t\t{ \"Message size\", \"tipc.msg_size\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0001ffff,\n\t\t\t\t\"TIPC Message size\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_ack_link_lev_seq,\n\t\t\t{ \"Acknowledged link level sequence number\", \"tipc.ack_link_lev_seq\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffff0000,\n\t\t\t\t\"TIPC Acknowledged link level sequence number\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_link_lev_seq,\n\t\t\t{ \"Link level sequence number\", \"tipc.link_lev_seq\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000ffff,\n\t\t\t\t\"TIPC Link level sequence number\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_prev_proc,\n\t\t\t{ \"Previous processor\", \"tipc.prev_proc\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Previous processor\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_org_port,\n\t\t\t{ \"Originating port\", \"tipc.org_port\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Originating port\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_dst_port,\n\t\t\t{ \"Destination port\", \"tipc.dst_port\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Destination port\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_data_msg_type,\n\t\t\t{ \"Message type\", \"tipc.msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_data_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_err_code,\n\t\t\t{ \"Error code\", \"tipc.err_code\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_error_code_values), 0x0f000000,\n\t\t\t\t\"TIPC Error code\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_reroute_cnt,\n\t\t\t{ \"Reroute counter\", \"tipc.route_cnt\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00f00000,\n\t\t\t\t\"TIPC Reroute counter\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_act_id,\n\t\t\t{ \"Activity identity\", \"tipc.act_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x000fffff,\n\t\t\t\t\"TIPC Activity identity\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_org_proc,\n\t\t\t{ \"Originating processor\", \"tipc.org_proc\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Originating processor\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_dst_proc,\n\t\t\t{ \"Destination processor\", \"tipc.dst_proc\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Destination processor\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_unused2,\n\t\t\t{ \"Unused\", \"tipc.unused2\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xe0000000,\n\t\t\t\t\"TIPC Unused\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_importance,\n\t\t\t{ \"Importance\", \"tipc.importance\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x18000000,\n\t\t\t\t\"TIPC Importance\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_link_selector,\n\t\t\t{ \"Link selector\", \"tipc.link_selector\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x07000000,\n\t\t\t\t\"TIPC Link selector\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_cnt,\n\t\t\t{ \"Message count\", \"tipc.imsg_cnt\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00ffff00,\n\t\t\t\t\"TIPC Message count\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_probe,\n\t\t\t{ \"Probe\", \"tipc.probe\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000040,\n\t\t\t\t\"TIPC Probe\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_bearer_id,\n\t\t\t{ \"Bearer identity\", \"tipc.bearer_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000038,\n\t\t\t\t\"TIPC Bearer identity\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_link_selector2,\n\t\t\t{ \"Link selector\", \"tipc.link_selector\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000007,\n\t\t\t\t\"TIPC Link selector\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_remote_addr,\n\t\t\t{ \"Remote address\", \"tipc.remote_addr\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Remote address\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_rm_msg_type,\n\t\t\t{ \"Message type\", \"tipc.rm_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_routing_mgr_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_nd_msg_type,\n\t\t\t{ \"Message type\", \"tipc.nd_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_name_dist_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_cm_msg_type,\n\t\t\t{ \"Message type\", \"tipc.nd_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_cm_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_lp_msg_type,\n\t\t\t{ \"Message type\", \"tipc.lp_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_link_prot_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_cng_prot_msg_type,\n\t\t\t{ \"Message type\", \"tipc.cng_prot_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_cng_prot_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_sm_msg_type,\n\t\t\t{ \"Message type\", \"tipc.sm_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_sm_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_unknown_msg_type,\n\t\t\t{ \"Message type\", \"tipc.unknown_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_seq_gap,\n\t\t\t{ \"Sequence gap\", \"tipc.seq_gap\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x1fff0000,\n\t\t\t\t\"TIPC Sequence gap\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_nxt_snt_pkg,\n\t\t\t{ \"Next sent packet\", \"tipc.nxt_snt_pkg\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000ffff,\n\t\t\t\t\"TIPC Next sent packet\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_unused_word,\n\t\t\t{ \"Word Unused\", \"tipc.unused_word\",\n\t\t\t\tFT_NONE, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_bearer_name,\n\t\t\t{ \"Bearer name\", \"tipc.bearer_name\",\n\t\t\t\tFT_STRINGZ, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Bearer name\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_data,\n\t\t\t{ \"Data\", \"tipc.data\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_no_bundle,\n\t\t\t{ \"Message no. in bundle\", \"tipc.msg_no_bundle\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_changeover_protocol,\n\t\t\t{ \"TIPC_CHANGEOVER_PROTOCOL\", \"tipc.changeover_protocol\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_type,\n\t\t\t{ \"Published port name type\", \"tipc.name_dist_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Published port name type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_lower,\n\t\t\t{ \"Lower bound of published sequence\", \"tipc.name_dist_lower\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Lower bound of published sequence\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_upper,\n\t\t\t{ \"Upper bound of published sequence\", \"tipc.name_dist_upper\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Upper bound of published sequence\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_port,\n\t\t\t{ \"Random number part of port identity\", \"tipc.dist_port\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Random number part of port identity\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_key,\n\t\t\t{ \"Key (Use for verification at withdrawal)\", \"tipc.dist_key\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC key\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_srcdrop,\n\t\t\t{ \"Source Droppable\", \"tipc.srcdrop\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00040000,\n\t\t\t\t\"Destination Droppable Bit\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_syn,\n\t\t\t{ \"Connection request (SYN)\", \"tipc.syn\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00020000,\n\t\t\t\t\"Destination Droppable Bit\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_data_msg_type,\n\t\t\t{ \"Message type\", \"tipc.data_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_data_msg_type_values), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bcast_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.bcast_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_bcast_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bundler_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.bundler_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_bundler_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.link_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_link_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_connmgr_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.connmgr_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_connmgr_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_route_mtype_1_6,\n\t\t\t{ \"Message type\", \"tipcv2.route_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_route_mtype_strings_1_6), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_route_mtype_1_7,\n\t\t\t{ \"Message type\", \"tipcv2.route_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_route_mtype_strings_1_7), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_changeover_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.changeover_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_changeover_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_naming_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.naming_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_naming_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_fragmenter_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.fragmenter_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_fragmenter_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_neighbour_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.data_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_neighbour_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_errorcode,\n\t\t\t{ \"Error code\", \"tipcv2.errorcode\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_error_code_strings), 0x1e000000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_rer_cnt,\n\t\t\t{ \"Reroute Counter\", \"tipcv2.rer_cnt\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x01e00000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_lookup_scope,\n\t\t\t{ \"Lookup Scope\", \"tipcv2.lookup_scope\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_lookup_scope_strings), 0x00180000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_opt_p,\n\t\t\t{ \"Options Position\", \"tipcv2.opt_p\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00070000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_broadcast_ack_no,\n\t\t\t{ \"Broadcast Acknowledge Number\", \"tipcv2.broadcast_ack_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_level_ack_no,\n\t\t\t{ \"Link Level Acknowledge Number\", \"tipcv2.link_level_ack_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_level_seq_no,\n\t\t\t{ \"Link Level Sequence Number\", \"tipcv2.link_level_seq_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n#if 0\n\t\t{ &hf_tipcv2_bcast_seq_no,\n\t\t\t{ \"Broadcast Sequence Number\", \"tipcv2.bcast_seq_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n#endif\n\t\t{ &hf_tipcv2_prev_node,\n\t\t\t{ \"Previous Node\", \"tipcv2.prev_node\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Previous Node\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_orig_node,\n\t\t\t{ \"Originating Node\", \"tipcv2.orig_node\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Originating Node\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_dest_node,\n\t\t\t{ \"Destination Node\", \"tipcv2.dest_node\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Destination Node\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_port_name_type,\n\t\t\t{ \"Port name type\", \"tipcv2.port_name_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_port_name_instance,\n\t\t\t{ \"Port name instance\", \"tipcv2.port_name_instance\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_multicast_lower,\n\t\t\t{ \"Multicast lower bound\", \"tipcv2.multicast_lower\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"Multicast port name instance lower bound\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_multicast_upper,\n\t\t\t{ \"Multicast upper bound\", \"tipcv2.multicast_upper\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"Multicast port name instance upper bound\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_sequence_gap,\n\t\t\t{ \"Sequence Gap\", \"tipcv2.seq_gap\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x1FFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_next_sent_broadcast,\n\t\t\t{ \"Next Sent Broadcast\", \"tipcv2.next_sent_broadcast\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_fragment_number,\n\t\t\t{ \"Fragment Number\", \"tipcv2.fragment_number\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_fragment_msg_number,\n\t\t\t{ \"Fragment Message Number\", \"tipcv2.fragment_msg_number\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_next_sent_packet,\n\t\t\t{ \"Next Sent Packet\", \"tipcv2.next_sent_packet\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_session_no,\n\t\t\t{ \"Session Number\", \"tipcv2.session_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_prio,\n\t\t\t{ \"Link Priority\", \"tipcv2.link_prio\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x000001F0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_network_plane,\n\t\t\t{ \"Network Plane\", \"tipcv2.network_plane\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_networkplane_strings), 0x0000000E,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_probe,\n\t\t\t{ \"Probe\", \"tipcv2.probe\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000001,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_tolerance,\n\t\t\t{ \"Link Tolerance (ms)\", \"tipcv2.link_tolerance\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\t\"Link Tolerance in ms\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bearer_instance,\n\t\t\t{ \"Bearer Instance\", \"tipcv2.bearer_instance\",\n\t\t\t\tFT_STRINGZ, BASE_NONE, NULL, 0,\n\t\t\t\t\"Bearer instance used by the sender node for this link\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_padding,\n\t\t\t{ \"Padding\", \"tipcv2.padding\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bearer_level_orig_addr,\n\t\t\t{ \"Bearer Level Originating Address\", \"tipcv2.bearer_level_orig_addr\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_cluster_address,\n\t\t\t{ \"Cluster Address\", \"tipcv2.cluster_address\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"The remote cluster concerned by the table\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bitmap,\n\t\t\t{ \"Bitmap\", \"tipcv2.bitmap\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\t\"Bitmap, indicating to which nodes within that cluster the sending node has direct links\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_node_address,\n\t\t\t{ \"Node Address\", \"tipcv2.node_address\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"Which node the route addition/loss concern\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_destination_domain,\n\t\t\t{ \"Destination Domain\", \"tipcv2.destination_domain\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"The domain to which the link request is directed\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_network_id,\n\t\t\t{ \"Network Identity\", \"tipcv2.network_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF,\n\t\t\t\t\"The sender node's network identity\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bcast_tag,\n\t\t\t{ \"Broadcast Tag\", \"tipcv2.bcast_tag\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_msg_count,\n\t\t\t{ \"Message Count\", \"tipcv2.msg_count\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_max_packet,\n\t\t\t{ \"Max Packet\", \"tipcv2.max_packet\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_transport_seq_no,\n\t\t\t{ \"Transport Sequence No\", \"tipcv2.tseq_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF,\n\t\t\t\t\"Transport Level Sequence Number\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_redundant_link,\n\t\t\t{ \"Redundant Link\", \"tipcv2.redundant_link\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00001000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bearer_id,\n\t\t\t{ \"Bearer identity\", \"tipcv2.bearer_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000e00,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_conn_mgr_msg_ack, /* special CONN_MANAGER payload */\n\t\t\t{ \"Number of Messages Acknowledged\", \"tipcv2.conn_mgr_msg_ack\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffff0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_minor_pv,\n\t\t\t{ \"Minor protocol version\", \"tipcv2.minor_pv\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00ff0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_node_sig,\n\t\t\t{ \"Node signature\", \"tipcv2.node_sig\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_filler_mtu_discovery,\n\t\t\t{ \"Filler for MTU discovery\", \"tipcv2.filler_mtu_discovery\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_vendor_specific_data,\n\t\t\t{ \"Vendor specific data\", \"tipcv2.vendor_specific_data\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_options,\n\t\t\t{ \"Options\", \"tipcv2.options\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_named_msg_hdr,\n\t\t\t{ \"TIPC_NAMED_MSG Hdr\", \"tipc.named_msg_hdr\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_port_name_type,\n\t\t\t{ \"Port name type / Connection level sequence number\", \"tipc.port_name_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_port_name_instance,\n\t\t\t{ \"Port name instance\", \"tipc.port_name_instance\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_data_fragment,\n\t\t\t{ \"Data fragment\", \"tipc.data_fragment\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_message_bundle,\n\t\t\t{ \"Message Bundle\", \"tipc.message_bundle\",\n\t\t\t\tFT_NONE, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_timestamp,\n\t\t\t{ \"Timestamp\", \"tipcv2.timestamp\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF,\n\t\t\t\t\"OS-dependent Timestamp\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_item_size,\n\t\t\t{ \"Item Size\", \"tipcv2.item_size\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFF000000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_network_region,\n\t\t\t{ \"Network Region\", \"tipcv2.network_region\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_local_router,\n\t\t\t{ \"Local Router\", \"tipcv2.local_router\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_remote_router,\n\t\t\t{ \"Remote Router\", \"tipcv2.remote_router\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_dist_dist,\n\t\t\t{ \"Route Distributor Dist\", \"tipcv2.dist_dist\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_dist_dist_strings), 0x000000f0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_dist_scope,\n\t\t\t{ \"Route Distributor Scope\", \"tipcv2.dist_scope\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_dist_scope_strings), 0x0000000f,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_name_dist_port_id_node,\n\t\t\t{ \"Port Id Node\", \"tipcv2.port_id_node\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_media_id,\n\t\t\t{ \"Media Id\", \"tipcv2.media_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x000000ff,\n\t\t\t\tNULL, HFILL }\n\t\t}\n\t};\n\n\t/* Setup protocol subtree array */\n\tstatic gint *ett[] = {\n\t\t&ett_tipc,\n\t\t&ett_tipc_data,\n\t\t&ett_tipc_msg_fragment,\n\t\t&ett_tipc_msg_fragments\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_tipc_field_not_specified, { \"tipc.field_not_specified\", PI_PROTOCOL, PI_WARN, \"This field is not specified in TIPC v7\", EXPFILL }},\n\t\t{ &ei_tipc_invalid_bundle_size, { \"tipc.invalid_bundle_size\", PI_PROTOCOL, PI_WARN, \"Invalid message bundle size\", EXPFILL }},\n\t};\n\n\tmodule_t *tipc_module;\n\texpert_module_t* expert_tipc;\n\n\t/* options for the enum in the protocol preferences */\n\tstatic const enum_val_t handle_v2_as_options[] = {\n\t\t{ \"all\",          \"ALL\",          V2_AS_ALL },\n\t\t{ \"tipc l.5/1.6\", \"TIPC 1.5/1.6\", V2_AS_1_6 },\n\t\t{ \"tipc 1.7\",     \"TIPC 1.7\",     V2_AS_1_7 },\n\t\t{ NULL,           NULL,           0 }\n\t};\n\n\t/* Register the protocol name and description */\n\tproto_tipc = proto_register_protocol(\"Transparent Inter Process Communication(TIPC)\", \"TIPC\", \"tipc\");\n\n\t/* Required function calls to register the header fields and subtrees used */\n\tproto_register_field_array(proto_tipc, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_tipc = expert_register_protocol(proto_tipc);\n\texpert_register_field_array(expert_tipc, ei, array_length(ei));\n\n\t/* allow other protocols to be called according to specific values in order to\n\t * dissect the protocols sent by TIPC */\n\n\t/* this allows e.g. to dissect everything which is TIPC Data */\n\ttipc_user_dissector = register_dissector_table(\"tipc.usr\",\n\t\t\t\"TIPC user\", proto_tipc, FT_UINT8, BASE_DEC);\n\t/* this allows to dissect everything which is TIPC Data and uses a specific\n\t * port name type it actually does not really work because the type is not\n\t * necessarily set in every data message */\n\ttipc_type_dissector = register_dissector_table(\"tipcv2.port_name_type\",\n\t\t\t\"TIPC port name type\", proto_tipc, FT_UINT32, BASE_DEC);\n\n\t/* make heuristic dissectors possible */\n\ttipc_heur_subdissector_list = register_heur_dissector_list(\"tipc\", proto_tipc);\n\n\t/* Register by name */\n\ttipc_handle = register_dissector(\"tipc\", dissect_tipc, proto_tipc);\n\n\treassembly_table_register(&tipc_msg_reassembly_table,\n\t    &addresses_reassembly_table_functions);\n\n\t/* Register configuration options */\n\ttipc_module = prefs_register_protocol(proto_tipc, NULL);\n\n\ttipc_address_type = address_type_dissector_register(\"AT_TIPC\", \"TIPC Address Zone,Subnetwork,Processor\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttipc_addr_to_str_buf, tipc_addr_str_len, NULL, NULL, NULL, NULL, NULL);\n\n\tprefs_register_bool_preference(tipc_module, \"defragment\",\n\t\t\t\"Reassemble TIPCv1 SEGMENTATION_MANAGER datagrams\",\n\t\t\t\"Whether TIPCv1 SEGMENTATION_MANAGER datagrams should be reassembled\",\n\t\t\t&tipc_defragment);\n\n\tprefs_register_bool_preference(tipc_module, \"dissect_tipc_data\",\n\t\t\t\"Dissect TIPC data\",\n\t\t\t\"Whether to try to dissect TIPC data or not\",\n\t\t\t&dissect_tipc_data);\n\n\tprefs_register_bool_preference(tipc_module, \"try_heuristic_first\",\n\t\t\t\"Try heuristic sub-dissectors first\",\n\t\t\t\"Try to decode a TIPCv2 packet using an heuristic sub-dissector before using a registered sub-dissector\",\n\t\t\t&try_heuristic_first);\n\n\tprefs_register_enum_preference(tipc_module, \"handle_v2_as\",\n\t\t\t\"Handle version 2 as\",\n\t\t\t\"TIPC 1.7 removes/adds fields (not) available in TIPC 1.5/1.6 while keeping the version number 2 in the packages. \\\"ALL\\\" shows all fields that were ever used in both versions.\",\n\t\t\t&handle_v2_as,\n\t\t\thandle_v2_as_options,\n\t\t\tTRUE);\n\n\tprefs_register_bool_preference(tipc_module, \"desegment\",\n\t\t\t\"Reassemble TIPC-over-TCP messages spanning multiple TCP segments\",\n\t\t\t\"Whether the TIPC-over-TCP dissector should reassemble messages spanning multiple TCP segments. \"\n\t\t\t\"To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\",\n\t\t\t&tipc_tcp_desegment);\n}",
        "func": "void\nproto_register_tipc(void)\n{\n\tstatic hf_register_info hf[] = {\n\t\t{ &hf_tipc_msg_fragments,\n\t\t\t{ \"Message fragments\", \"tipc.msg.fragments\",\n\t\t\t\tFT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment,\n\t\t\t{ \"Message fragment\", \"tipc.msg.fragment\",\n\t\t\t\tFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_overlap,\n\t\t\t{ \"Message fragment overlap\", \"tipc.msg.fragment.overlap\",\n\t\t\t\tFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_overlap_conflicts,\n\t\t\t{ \"Message fragment overlapping with conflicting data\", \"tipc.msg.fragment.overlap.conflicts\",\n\t\t\t\tFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_multiple_tails,\n\t\t\t{ \"Message has multiple tail fragments\", \"tipc.msg.fragment.multiple_tails\",\n\t\t\t\tFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_too_long_fragment,\n\t\t\t{ \"Message fragment too long\", \"tipc.msg.fragment.too_long_fragment\",\n\t\t\t\tFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_error,\n\t\t\t{ \"Message defragmentation error\", \"tipc.msg.fragment.error\",\n\t\t\t\tFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_fragment_count,\n\t\t\t{ \"Message fragment count\", \"tipc.msg.fragment.count\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_reassembled_in,\n\t\t\t{ \"Reassembled in\", \"tipc.msg.reassembled.in\",\n\t\t\t\tFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_reassembled_length,\n\t\t\t{ \"Reassembled TIPC length\", \"tipc.msg.reassembled.length\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_ver,\n\t\t\t{ \"Version\", \"tipc.ver\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xe0000000,\n\t\t\t\t\"TIPC protocol version\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_usr,\n\t\t\t{ \"User\", \"tipc.usr\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_user_values), 0x1e000000,\n\t\t\t\t\"TIPC User\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_usr,\n\t\t\t{ \"User\", \"tipc.usr\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_user_values), 0x1e000000,\n\t\t\t\t\"TIPC User\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_hdr_size,\n\t\t\t{ \"Header size\", \"tipc.hdr_size\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x01e00000,\n\t\t\t\t\"TIPC Header size\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_nonsequenced,\n\t\t\t{ \"Non-sequenced\", \"tipc.non_sequenced\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00100000,\n\t\t\t\t\"Non-sequenced Bit\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_destdrop,\n\t\t\t{ \"Destination Droppable\", \"tipc.destdrop\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00080000,\n\t\t\t\t\"Destination Droppable Bit\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_unused,\n\t\t\t{ \"Unused\", \"tipc.hdr_unused\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x000e0000,\n\t\t\t\t\"TIPC Unused\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_size,\n\t\t\t{ \"Message size\", \"tipc.msg_size\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0001ffff,\n\t\t\t\t\"TIPC Message size\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_ack_link_lev_seq,\n\t\t\t{ \"Acknowledged link level sequence number\", \"tipc.ack_link_lev_seq\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffff0000,\n\t\t\t\t\"TIPC Acknowledged link level sequence number\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_link_lev_seq,\n\t\t\t{ \"Link level sequence number\", \"tipc.link_lev_seq\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000ffff,\n\t\t\t\t\"TIPC Link level sequence number\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_prev_proc,\n\t\t\t{ \"Previous processor\", \"tipc.prev_proc\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Previous processor\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_org_port,\n\t\t\t{ \"Originating port\", \"tipc.org_port\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Originating port\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_dst_port,\n\t\t\t{ \"Destination port\", \"tipc.dst_port\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Destination port\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_data_msg_type,\n\t\t\t{ \"Message type\", \"tipc.msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_data_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_err_code,\n\t\t\t{ \"Error code\", \"tipc.err_code\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_error_code_values), 0x0f000000,\n\t\t\t\t\"TIPC Error code\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_reroute_cnt,\n\t\t\t{ \"Reroute counter\", \"tipc.route_cnt\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00f00000,\n\t\t\t\t\"TIPC Reroute counter\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_act_id,\n\t\t\t{ \"Activity identity\", \"tipc.act_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x000fffff,\n\t\t\t\t\"TIPC Activity identity\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_org_proc,\n\t\t\t{ \"Originating processor\", \"tipc.org_proc\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Originating processor\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_dst_proc,\n\t\t\t{ \"Destination processor\", \"tipc.dst_proc\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Destination processor\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_unused2,\n\t\t\t{ \"Unused\", \"tipc.unused2\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xe0000000,\n\t\t\t\t\"TIPC Unused\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_importance,\n\t\t\t{ \"Importance\", \"tipc.importance\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x18000000,\n\t\t\t\t\"TIPC Importance\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_link_selector,\n\t\t\t{ \"Link selector\", \"tipc.link_selector\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x07000000,\n\t\t\t\t\"TIPC Link selector\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_cnt,\n\t\t\t{ \"Message count\", \"tipc.imsg_cnt\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00ffff00,\n\t\t\t\t\"TIPC Message count\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_probe,\n\t\t\t{ \"Probe\", \"tipc.probe\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000040,\n\t\t\t\t\"TIPC Probe\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_bearer_id,\n\t\t\t{ \"Bearer identity\", \"tipc.bearer_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000038,\n\t\t\t\t\"TIPC Bearer identity\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_link_selector2,\n\t\t\t{ \"Link selector\", \"tipc.link_selector\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000007,\n\t\t\t\t\"TIPC Link selector\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_remote_addr,\n\t\t\t{ \"Remote address\", \"tipc.remote_addr\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Remote address\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_rm_msg_type,\n\t\t\t{ \"Message type\", \"tipc.rm_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_routing_mgr_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_nd_msg_type,\n\t\t\t{ \"Message type\", \"tipc.nd_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_name_dist_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_cm_msg_type,\n\t\t\t{ \"Message type\", \"tipc.nd_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_cm_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_lp_msg_type,\n\t\t\t{ \"Message type\", \"tipc.lp_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_link_prot_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_cng_prot_msg_type,\n\t\t\t{ \"Message type\", \"tipc.cng_prot_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_cng_prot_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_sm_msg_type,\n\t\t\t{ \"Message type\", \"tipc.sm_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_sm_msg_type_values), 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_unknown_msg_type,\n\t\t\t{ \"Message type\", \"tipc.unknown_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xf0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_seq_gap,\n\t\t\t{ \"Sequence gap\", \"tipc.seq_gap\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x1fff0000,\n\t\t\t\t\"TIPC Sequence gap\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_nxt_snt_pkg,\n\t\t\t{ \"Next sent packet\", \"tipc.nxt_snt_pkg\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000ffff,\n\t\t\t\t\"TIPC Next sent packet\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_unused_word,\n\t\t\t{ \"Word Unused\", \"tipc.unused_word\",\n\t\t\t\tFT_NONE, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_bearer_name,\n\t\t\t{ \"Bearer name\", \"tipc.bearer_name\",\n\t\t\t\tFT_STRINGZ, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Bearer name\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_data,\n\t\t\t{ \"Data\", \"tipc.data\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_msg_no_bundle,\n\t\t\t{ \"Message no. in bundle\", \"tipc.msg_no_bundle\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_changeover_protocol,\n\t\t\t{ \"TIPC_CHANGEOVER_PROTOCOL\", \"tipc.changeover_protocol\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_type,\n\t\t\t{ \"Published port name type\", \"tipc.name_dist_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Published port name type\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_lower,\n\t\t\t{ \"Lower bound of published sequence\", \"tipc.name_dist_lower\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Lower bound of published sequence\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_upper,\n\t\t\t{ \"Upper bound of published sequence\", \"tipc.name_dist_upper\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Upper bound of published sequence\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_port,\n\t\t\t{ \"Random number part of port identity\", \"tipc.dist_port\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC Random number part of port identity\", HFILL }\n\t\t},\n\t\t{ &hf_tipc_name_dist_key,\n\t\t\t{ \"Key (Use for verification at withdrawal)\", \"tipc.dist_key\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"TIPC key\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_srcdrop,\n\t\t\t{ \"Source Droppable\", \"tipc.srcdrop\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00040000,\n\t\t\t\t\"Destination Droppable Bit\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_syn,\n\t\t\t{ \"Connection request (SYN)\", \"tipc.syn\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00020000,\n\t\t\t\t\"Destination Droppable Bit\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_data_msg_type,\n\t\t\t{ \"Message type\", \"tipc.data_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipc_data_msg_type_values), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bcast_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.bcast_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_bcast_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bundler_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.bundler_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_bundler_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.link_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_link_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_connmgr_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.connmgr_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_connmgr_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_route_mtype_1_6,\n\t\t\t{ \"Message type\", \"tipcv2.route_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_route_mtype_strings_1_6), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_route_mtype_1_7,\n\t\t\t{ \"Message type\", \"tipcv2.route_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_route_mtype_strings_1_7), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_changeover_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.changeover_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_changeover_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_naming_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.naming_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_naming_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_fragmenter_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.fragmenter_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_fragmenter_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_neighbour_mtype,\n\t\t\t{ \"Message type\", \"tipcv2.data_msg_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_neighbour_mtype_strings), 0xe0000000,\n\t\t\t\t\"TIPC Message type\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_errorcode,\n\t\t\t{ \"Error code\", \"tipcv2.errorcode\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_error_code_strings), 0x1e000000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_rer_cnt,\n\t\t\t{ \"Reroute Counter\", \"tipcv2.rer_cnt\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x01e00000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_lookup_scope,\n\t\t\t{ \"Lookup Scope\", \"tipcv2.lookup_scope\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_lookup_scope_strings), 0x00180000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_opt_p,\n\t\t\t{ \"Options Position\", \"tipcv2.opt_p\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00070000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_broadcast_ack_no,\n\t\t\t{ \"Broadcast Acknowledge Number\", \"tipcv2.broadcast_ack_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_level_ack_no,\n\t\t\t{ \"Link Level Acknowledge Number\", \"tipcv2.link_level_ack_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_level_seq_no,\n\t\t\t{ \"Link Level Sequence Number\", \"tipcv2.link_level_seq_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n#if 0\n\t\t{ &hf_tipcv2_bcast_seq_no,\n\t\t\t{ \"Broadcast Sequence Number\", \"tipcv2.bcast_seq_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n#endif\n\t\t{ &hf_tipcv2_prev_node,\n\t\t\t{ \"Previous Node\", \"tipcv2.prev_node\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Previous Node\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_orig_node,\n\t\t\t{ \"Originating Node\", \"tipcv2.orig_node\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Originating Node\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_dest_node,\n\t\t\t{ \"Destination Node\", \"tipcv2.dest_node\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"TIPC Destination Node\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_port_name_type,\n\t\t\t{ \"Port name type\", \"tipcv2.port_name_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_port_name_instance,\n\t\t\t{ \"Port name instance\", \"tipcv2.port_name_instance\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_multicast_lower,\n\t\t\t{ \"Multicast lower bound\", \"tipcv2.multicast_lower\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"Multicast port name instance lower bound\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_multicast_upper,\n\t\t\t{ \"Multicast upper bound\", \"tipcv2.multicast_upper\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffffffff,\n\t\t\t\t\"Multicast port name instance upper bound\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_sequence_gap,\n\t\t\t{ \"Sequence Gap\", \"tipcv2.seq_gap\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x1FFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_next_sent_broadcast,\n\t\t\t{ \"Next Sent Broadcast\", \"tipcv2.next_sent_broadcast\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_fragment_number,\n\t\t\t{ \"Fragment Number\", \"tipcv2.fragment_number\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_fragment_msg_number,\n\t\t\t{ \"Fragment Message Number\", \"tipcv2.fragment_msg_number\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_next_sent_packet,\n\t\t\t{ \"Next Sent Packet\", \"tipcv2.next_sent_packet\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_session_no,\n\t\t\t{ \"Session Number\", \"tipcv2.session_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_prio,\n\t\t\t{ \"Link Priority\", \"tipcv2.link_prio\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x000001F0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_network_plane,\n\t\t\t{ \"Network Plane\", \"tipcv2.network_plane\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_networkplane_strings), 0x0000000E,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_probe,\n\t\t\t{ \"Probe\", \"tipcv2.probe\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000001,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_link_tolerance,\n\t\t\t{ \"Link Tolerance (ms)\", \"tipcv2.link_tolerance\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\t\"Link Tolerance in ms\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bearer_instance,\n\t\t\t{ \"Bearer Instance\", \"tipcv2.bearer_instance\",\n\t\t\t\tFT_STRINGZ, BASE_NONE, NULL, 0,\n\t\t\t\t\"Bearer instance used by the sender node for this link\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_padding,\n\t\t\t{ \"Padding\", \"tipcv2.padding\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bearer_level_orig_addr,\n\t\t\t{ \"Bearer Level Originating Address\", \"tipcv2.bearer_level_orig_addr\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_cluster_address,\n\t\t\t{ \"Cluster Address\", \"tipcv2.cluster_address\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"The remote cluster concerned by the table\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bitmap,\n\t\t\t{ \"Bitmap\", \"tipcv2.bitmap\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\t\"Bitmap, indicating to which nodes within that cluster the sending node has direct links\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_node_address,\n\t\t\t{ \"Node Address\", \"tipcv2.node_address\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"Which node the route addition/loss concern\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_destination_domain,\n\t\t\t{ \"Destination Domain\", \"tipcv2.destination_domain\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\t\"The domain to which the link request is directed\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_network_id,\n\t\t\t{ \"Network Identity\", \"tipcv2.network_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF,\n\t\t\t\t\"The sender node's network identity\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bcast_tag,\n\t\t\t{ \"Broadcast Tag\", \"tipcv2.bcast_tag\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_msg_count,\n\t\t\t{ \"Message Count\", \"tipcv2.msg_count\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_max_packet,\n\t\t\t{ \"Max Packet\", \"tipcv2.max_packet\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFF0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_transport_seq_no,\n\t\t\t{ \"Transport Sequence No\", \"tipcv2.tseq_no\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF,\n\t\t\t\t\"Transport Level Sequence Number\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_redundant_link,\n\t\t\t{ \"Redundant Link\", \"tipcv2.redundant_link\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00001000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_bearer_id,\n\t\t\t{ \"Bearer identity\", \"tipcv2.bearer_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00000e00,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_conn_mgr_msg_ack, /* special CONN_MANAGER payload */\n\t\t\t{ \"Number of Messages Acknowledged\", \"tipcv2.conn_mgr_msg_ack\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xffff0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_minor_pv,\n\t\t\t{ \"Minor protocol version\", \"tipcv2.minor_pv\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x00ff0000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_node_sig,\n\t\t\t{ \"Node signature\", \"tipcv2.node_sig\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0000FFFF,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_filler_mtu_discovery,\n\t\t\t{ \"Filler for MTU discovery\", \"tipcv2.filler_mtu_discovery\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_vendor_specific_data,\n\t\t\t{ \"Vendor specific data\", \"tipcv2.vendor_specific_data\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_options,\n\t\t\t{ \"Options\", \"tipcv2.options\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_named_msg_hdr,\n\t\t\t{ \"TIPC_NAMED_MSG Hdr\", \"tipc.named_msg_hdr\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_port_name_type,\n\t\t\t{ \"Port name type / Connection level sequence number\", \"tipc.port_name_type\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_port_name_instance,\n\t\t\t{ \"Port name instance\", \"tipc.port_name_instance\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_data_fragment,\n\t\t\t{ \"Data fragment\", \"tipc.data_fragment\",\n\t\t\t\tFT_BYTES, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipc_message_bundle,\n\t\t\t{ \"Message Bundle\", \"tipc.message_bundle\",\n\t\t\t\tFT_NONE, BASE_NONE, NULL, 0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_timestamp,\n\t\t\t{ \"Timestamp\", \"tipcv2.timestamp\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF,\n\t\t\t\t\"OS-dependent Timestamp\", HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_item_size,\n\t\t\t{ \"Item Size\", \"tipcv2.item_size\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0xFF000000,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_network_region,\n\t\t\t{ \"Network Region\", \"tipcv2.network_region\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_local_router,\n\t\t\t{ \"Local Router\", \"tipcv2.local_router\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_remote_router,\n\t\t\t{ \"Remote Router\", \"tipcv2.remote_router\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_dist_dist,\n\t\t\t{ \"Route Distributor Dist\", \"tipcv2.dist_dist\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_dist_dist_strings), 0x000000f0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_dist_scope,\n\t\t\t{ \"Route Distributor Scope\", \"tipcv2.dist_scope\",\n\t\t\t\tFT_UINT32, BASE_DEC, VALS(tipcv2_dist_scope_strings), 0x0000000f,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_name_dist_port_id_node,\n\t\t\t{ \"Port Id Node\", \"tipcv2.port_id_node\",\n\t\t\t\tFT_STRING, BASE_NONE, NULL, 0x0,\n\t\t\t\tNULL, HFILL }\n\t\t},\n\t\t{ &hf_tipcv2_media_id,\n\t\t\t{ \"Media Id\", \"tipcv2.media_id\",\n\t\t\t\tFT_UINT32, BASE_DEC, NULL, 0x000000ff,\n\t\t\t\tNULL, HFILL }\n\t\t}\n\t};\n\n\t/* Setup protocol subtree array */\n\tstatic gint *ett[] = {\n\t\t&ett_tipc,\n\t\t&ett_tipc_data,\n\t\t&ett_tipc_msg_fragment,\n\t\t&ett_tipc_msg_fragments\n\t};\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_tipc_field_not_specified, { \"tipc.field_not_specified\", PI_PROTOCOL, PI_WARN, \"This field is not specified in TIPC v7\", EXPFILL }},\n\t\t{ &ei_tipc_invalid_bundle_size, { \"tipc.invalid_bundle_size\", PI_PROTOCOL, PI_WARN, \"Invalid message bundle size\", EXPFILL }},\n\t\t{ &ei_tipc_max_recursion_depth_reached, { \"tipc.max_recursion_depth_reached\", PI_PROTOCOL, PI_WARN, \"Maximum allowed recursion depth reached. Dissection stopped.\", EXPFILL }},\n\t};\n\n\tmodule_t *tipc_module;\n\texpert_module_t* expert_tipc;\n\n\t/* options for the enum in the protocol preferences */\n\tstatic const enum_val_t handle_v2_as_options[] = {\n\t\t{ \"all\",          \"ALL\",          V2_AS_ALL },\n\t\t{ \"tipc l.5/1.6\", \"TIPC 1.5/1.6\", V2_AS_1_6 },\n\t\t{ \"tipc 1.7\",     \"TIPC 1.7\",     V2_AS_1_7 },\n\t\t{ NULL,           NULL,           0 }\n\t};\n\n\t/* Register the protocol name and description */\n\tproto_tipc = proto_register_protocol(\"Transparent Inter Process Communication(TIPC)\", \"TIPC\", \"tipc\");\n\n\t/* Required function calls to register the header fields and subtrees used */\n\tproto_register_field_array(proto_tipc, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\texpert_tipc = expert_register_protocol(proto_tipc);\n\texpert_register_field_array(expert_tipc, ei, array_length(ei));\n\n\t/* allow other protocols to be called according to specific values in order to\n\t * dissect the protocols sent by TIPC */\n\n\t/* this allows e.g. to dissect everything which is TIPC Data */\n\ttipc_user_dissector = register_dissector_table(\"tipc.usr\",\n\t\t\t\"TIPC user\", proto_tipc, FT_UINT8, BASE_DEC);\n\t/* this allows to dissect everything which is TIPC Data and uses a specific\n\t * port name type it actually does not really work because the type is not\n\t * necessarily set in every data message */\n\ttipc_type_dissector = register_dissector_table(\"tipcv2.port_name_type\",\n\t\t\t\"TIPC port name type\", proto_tipc, FT_UINT32, BASE_DEC);\n\n\t/* make heuristic dissectors possible */\n\ttipc_heur_subdissector_list = register_heur_dissector_list(\"tipc\", proto_tipc);\n\n\t/* Register by name */\n\ttipc_handle = register_dissector(\"tipc\", dissect_tipc, proto_tipc);\n\n\treassembly_table_register(&tipc_msg_reassembly_table,\n\t    &addresses_reassembly_table_functions);\n\n\t/* Register configuration options */\n\ttipc_module = prefs_register_protocol(proto_tipc, NULL);\n\n\ttipc_address_type = address_type_dissector_register(\"AT_TIPC\", \"TIPC Address Zone,Subnetwork,Processor\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttipc_addr_to_str_buf, tipc_addr_str_len, NULL, NULL, NULL, NULL, NULL);\n\n\tprefs_register_bool_preference(tipc_module, \"defragment\",\n\t\t\t\"Reassemble TIPCv1 SEGMENTATION_MANAGER datagrams\",\n\t\t\t\"Whether TIPCv1 SEGMENTATION_MANAGER datagrams should be reassembled\",\n\t\t\t&tipc_defragment);\n\n\tprefs_register_bool_preference(tipc_module, \"dissect_tipc_data\",\n\t\t\t\"Dissect TIPC data\",\n\t\t\t\"Whether to try to dissect TIPC data or not\",\n\t\t\t&dissect_tipc_data);\n\n\tprefs_register_bool_preference(tipc_module, \"try_heuristic_first\",\n\t\t\t\"Try heuristic sub-dissectors first\",\n\t\t\t\"Try to decode a TIPCv2 packet using an heuristic sub-dissector before using a registered sub-dissector\",\n\t\t\t&try_heuristic_first);\n\n\tprefs_register_enum_preference(tipc_module, \"handle_v2_as\",\n\t\t\t\"Handle version 2 as\",\n\t\t\t\"TIPC 1.7 removes/adds fields (not) available in TIPC 1.5/1.6 while keeping the version number 2 in the packages. \\\"ALL\\\" shows all fields that were ever used in both versions.\",\n\t\t\t&handle_v2_as,\n\t\t\thandle_v2_as_options,\n\t\t\tTRUE);\n\n\tprefs_register_bool_preference(tipc_module, \"desegment\",\n\t\t\t\"Reassemble TIPC-over-TCP messages spanning multiple TCP segments\",\n\t\t\t\"Whether the TIPC-over-TCP dissector should reassemble messages spanning multiple TCP segments. \"\n\t\t\t\"To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\",\n\t\t\t&tipc_tcp_desegment);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -647,6 +647,7 @@\n \tstatic ei_register_info ei[] = {\n \t\t{ &ei_tipc_field_not_specified, { \"tipc.field_not_specified\", PI_PROTOCOL, PI_WARN, \"This field is not specified in TIPC v7\", EXPFILL }},\n \t\t{ &ei_tipc_invalid_bundle_size, { \"tipc.invalid_bundle_size\", PI_PROTOCOL, PI_WARN, \"Invalid message bundle size\", EXPFILL }},\n+\t\t{ &ei_tipc_max_recursion_depth_reached, { \"tipc.max_recursion_depth_reached\", PI_PROTOCOL, PI_WARN, \"Maximum allowed recursion depth reached. Dissection stopped.\", EXPFILL }},\n \t};\n \n \tmodule_t *tipc_module;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t{ &ei_tipc_max_recursion_depth_reached, { \"tipc.max_recursion_depth_reached\", PI_PROTOCOL, PI_WARN, \"Maximum allowed recursion depth reached. Dissection stopped.\", EXPFILL }},"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0412",
        "func_name": "wireshark/dissect_tipc",
        "description": "TIPC dissector crash in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/659b830aef88753d7b1ba67230d30add31f7d24e",
        "commit_title": "TIPC: Add a recursion check",
        "commit_text": " Add a recursion check. Fixes #18770. ",
        "func_before": "static int\ndissect_tipc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tproto_item *ti, *item;\n\tproto_tree *tipc_tree, *tipc_data_tree;\n\tint offset = 0;\n\tguint32 srcport, destport = 0, dword;\n\tguint8  version;\n\tguint32 msg_size;\n\tguint8  hdr_size;\n\tguint8  user;\n\tgchar  *addr_str_ptr;\n\ttvbuff_t *data_tvb, *tipc_tvb;\n\tgboolean datatype_hdr = FALSE;\n\tguint8   msg_type = 0;\n\n\t/* Make entry in Protocol column on summary display */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"TIPC\");\n\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\ttop_tree = tree;\n\tdword = tvb_get_ntohl(tvb, offset);\n\tversion = (dword >>29) & 0xf;\n\thdr_size = (dword >>21) & 0xf;\n\tuser = (dword>>25) & 0xf;\n\tmsg_size = dword & 0x1ffff;\n\n\tif ((guint32)tvb_reported_length_remaining(tvb, offset) < msg_size) {\n\t\ttipc_tvb = tvb;\n\t} else {\n\t\ttipc_tvb = tvb_new_subset_length(tvb, offset, msg_size);\n\t}\n\t/* user == 7 only works for v2, this will decode the legacy TIPC configuration protocol */\n\tif (user == TIPCv2_LINK_PROTOCOL) version = TIPCv2;\n\t/* Set User values in COL INFO different in V1 and V2 */\n\tswitch (version) {\n\t\tcase 0:\n\t\tcase TIPCv1:\n\t\t\tmsg_type = tvb_get_guint8(tipc_tvb, offset + 20)>>4;\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" %s(%u) \", val_to_str_const(user, tipc_user_values, \"unknown\"), user);\n\t\t\t/* Set msg type in info col and find out if it's a data hdr or not */\n\t\t\tdatatype_hdr = tipc_v1_set_col_msgtype(pinfo, user, msg_type);\n\t\t\tif (datatype_hdr) {\n\t\t\t\t/* Data type header */\n\t\t\t\tif (hdr_size > 5 && user <4) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* Short data hdr */\n\t\t\t\t\t/* W2 Previous Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 8);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* W2 Previous Processor */\n\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 8);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIPCv2:\n\t\t\tmsg_type = tvb_get_guint8(tipc_tvb, offset + 4)>>5;\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \"%-12s\", val_to_str_const(user, tipcv2_user_short_str_vals, \"unknown\"));\n\t\t\t/* Set msg type in info col */\n\t\t\ttipc_v2_set_info_col(tvb, pinfo, user, msg_type, hdr_size);\n\n\t\t\t/* find out if it's a data hdr or not */\n\t\t\tswitch (user) {\n\t\t\t\tcase TIPCv2_DATA_LOW:\n\t\t\t\tcase TIPCv2_DATA_NORMAL:\n\t\t\t\tcase TIPCv2_DATA_HIGH:\n\t\t\t\tcase TIPCv2_DATA_NON_REJECTABLE:\n\t\t\t\t\tdatatype_hdr = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdatatype_hdr = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (datatype_hdr) {\n\t\t\t\tif (hdr_size > 6) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* W3 Previous Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 12);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (user != TIPCv2_NEIGHBOUR_DISCOVERY) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* W2 Destination Domain */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 8);\n\n\t\t\t\t\t/* W3 Previous Node */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 12);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tti = proto_tree_add_item(tree, proto_tipc, tipc_tvb, offset, -1, ENC_NA);\n\ttipc_tree = proto_item_add_subtree(ti, ett_tipc);\n\tif (version == TIPCv2) {\n\t\tdissect_tipc_v2(tipc_tvb, tipc_tree, pinfo, offset, user, msg_size, hdr_size, datatype_hdr);\n\t\treturn tvb_captured_length(tvb);\n\t}\n\n\t/* Word 0-2 common for all messages */\n\t/* Word 0 */\n\tproto_tree_add_item(tipc_tree, hf_tipc_ver, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_usr, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\titem = proto_tree_add_item(tipc_tree, hf_tipc_hdr_size, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_item_append_text(item, \" = %u bytes\", (hdr_size * 4));\n\tproto_tree_add_item(tipc_tree, hf_tipc_nonsequenced, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_unused, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tif (datatype_hdr) {\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_destdrop, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipcv2_srcdrop, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t}\n\n\tproto_tree_add_item(tipc_tree, hf_tipc_msg_size, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\toffset = offset + 4;\n\n\t/* Word 1 */\n\tproto_tree_add_item(tipc_tree, hf_tipc_ack_link_lev_seq, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_link_lev_seq, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\toffset = offset + 4;\n\n\t/* Word 2 */\n\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\taddr_str_ptr = tipc_addr_to_str(dword);\n\tproto_tree_add_string(tipc_tree, hf_tipc_prev_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\n\toffset = offset + 4;\n\tswitch (user) {\n\t\tcase TIPC_ROUTING_MANAGER:\n\t\tcase TIPC_LINK_PROTOCOL:\n\t\tcase TIPC_CHANGEOVER_PROTOCOL:\n\t\tcase TIPC_SEGMENTATION_MANAGER:\n\t\tcase TIPC_MSG_BUNDLER:\n\t\t\tdissect_tipc_int_prot_msg(tipc_tvb, pinfo, tipc_tree, offset, user, msg_size);\n\t\t\treturn tvb_captured_length(tvb);\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tproto_tree_add_item_ret_uint(tipc_tree, hf_tipc_org_port, tipc_tvb, offset, 4, ENC_BIG_ENDIAN, &srcport);\n\toffset = offset + 4;\n\tif (user != TIPC_NAME_DISTRIBUTOR) {\n\t\tproto_tree_add_item_ret_uint(tipc_tree, hf_tipc_dst_port, tipc_tvb, offset, 4, ENC_BIG_ENDIAN, &destport);\n\t}\n\n\tconversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, CONVERSATION_TIPC, srcport, destport);\n\n\toffset = offset + 4;\n\t/* 20 - 24 Bytes\n\t   20 bytes: Used in subnetwork local, connection oriented messages, where error code, reroute\n\t   counter and activity identity are zero. A recipient finding that the header size field is 20 does\n\t   by default know both user (DATA), message type (CONNECTED_MSG), error code\n\t   (MSG_OK), reroute counter (0), and activity identity (undefined). Since no more testing for\n\t   this is needed these fields can be left out in the header. Furthermore, since such messages\n\t   only will do zero or one inter-processor hop, we know that previous processor is the real\n\t   origin of the message. Hence the field originating processor can be omitted. For the same\n\t   reason, the recipient processor will know that it is identical to destination processor, so even\n\t   this field can be skipped. Finally, because the link layer guarantees delivery and sequence\n\t   order for this single hop, even the connection sequence number is redundant. So the message\n\t   can just be passed directly on to the destination port. Since this type of message statistically\n\t   should be by far the most frequent one this small optimization pays off.\n\t   */\n\tif (hdr_size <= 6) {\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t} else {\n\t\tswitch (user) {\n\t\t\tcase TIPC_NAME_DISTRIBUTOR:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_nd_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t\tcase TIPC_CONNECTION_MANAGER:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_cm_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t}\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_err_code, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_reroute_cnt, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_act_id, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\toffset = offset + 4;\n\n\t\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\t\taddr_str_ptr = tipc_addr_to_str(dword);\n\n\t\tproto_tree_add_string(tipc_tree, hf_tipc_org_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\t\toffset = offset + 4;\n\n\t\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\t\taddr_str_ptr = tipc_addr_to_str(dword);\n\n\t\tproto_tree_add_string(tipc_tree, hf_tipc_dst_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\t\toffset = offset + 4;\n\t\t/* 32 bytes\n\t\t   32 bytes: The size of all data messages containing an explicit port identity as destination\n\t\t   address.\n\t\t   */\n\t\tif (hdr_size > 8) {\n\t\t\tif (user == TIPC_NAME_DISTRIBUTOR) {\n\t\t\t\t/*\n\t\t\t\t   Although an internal service, the name distributor uses the full 40-byte \"external\" data header\n\t\t\t\t   format when updating the naming table instances. This is because its messages may need\n\t\t\t\t   routing, - all system processor must contain the publications from all device processors and\n\t\t\t\t   vice versa, whether they are directly linked or not. The fields name type, name instance, and\n\t\t\t\t   destination port of that header have no meaning for such messages\n\t\t\t\t   */\n\t\t\t\toffset = offset + 8;\n\t\t\t\ttipc_data_tree = proto_tree_add_subtree_format(tipc_tree, tvb, offset, -1, ett_tipc_data, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"TIPC_NAME_DISTRIBUTOR %u bytes User Data\", (msg_size - hdr_size*4));\n\t\t\t\tdata_tvb = tvb_new_subset_remaining(tipc_tvb, offset);\n\t\t\t\tdissect_tipc_name_dist_data(data_tvb, pinfo, tipc_data_tree, 0);\n\t\t\t\treturn tvb_captured_length(tvb);\n\t\t\t} else {\n\t\t\t\t/* Port name type / Connection level sequence number */\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_port_name_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\toffset = offset + 4;\n\t\t\t\t/* Port name instance */\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_port_name_instance, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\toffset = offset + 4;\n\t\t\t}\n\t\t}\n\n\t\tif (user < 4 && dissect_tipc_data) { /* DATA type user */\n\t\t\ttvbuff_t *next_tvb;\n\t\t\tguint32 msg_type32 = msg_type;\n\t\t\tguint32 *name_type_p = &msg_type32;\n\t\t\tswitch (msg_type) {\n\t\t\t\tcase TIPC_CONNECTED_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIPC_NAMED_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_named_msg_hdr, tipc_tvb, offset, 14, ENC_NA);\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset+14, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIPC_DIRECT_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* tipc data type user doesn't change format, reuse v2 function */\n\t\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\t\t\tcall_tipc_v2_data_subdissectors(next_tvb, pinfo, name_type_p, user);\n\t\t}\n\t} /*if (hdr_size <= 5) */\n\n\treturn tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_tipc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\tproto_item *ti, *item;\n\tproto_tree *tipc_tree, *tipc_data_tree;\n\tint offset = 0;\n\tguint32 srcport, destport = 0, dword;\n\tguint8  version;\n\tguint32 msg_size;\n\tguint8  hdr_size;\n\tguint8  user;\n\tgchar  *addr_str_ptr;\n\ttvbuff_t *data_tvb, *tipc_tvb;\n\tgboolean datatype_hdr = FALSE;\n\tguint8   msg_type = 0;\n\n\t/* Make entry in Protocol column on summary display */\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"TIPC\");\n\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\ttop_tree = tree;\n\tdword = tvb_get_ntohl(tvb, offset);\n\tversion = (dword >>29) & 0xf;\n\thdr_size = (dword >>21) & 0xf;\n\tuser = (dword>>25) & 0xf;\n\tmsg_size = dword & 0x1ffff;\n\n\tunsigned recursion_depth = p_get_proto_depth(pinfo, proto_tipc);\n\tif (++recursion_depth >= TIPC_MAX_RECURSION_DEPTH) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_tipc_max_recursion_depth_reached, tvb, 0, 0);\n\t\treturn tvb_captured_length(tvb);\n\t}\n\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth);\n\n\tif ((guint32)tvb_reported_length_remaining(tvb, offset) < msg_size) {\n\t\ttipc_tvb = tvb;\n\t} else {\n\t\ttipc_tvb = tvb_new_subset_length(tvb, offset, msg_size);\n\t}\n\t/* user == 7 only works for v2, this will decode the legacy TIPC configuration protocol */\n\tif (user == TIPCv2_LINK_PROTOCOL) version = TIPCv2;\n\t/* Set User values in COL INFO different in V1 and V2 */\n\tswitch (version) {\n\t\tcase 0:\n\t\tcase TIPCv1:\n\t\t\tmsg_type = tvb_get_guint8(tipc_tvb, offset + 20)>>4;\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" %s(%u) \", val_to_str_const(user, tipc_user_values, \"unknown\"), user);\n\t\t\t/* Set msg type in info col and find out if it's a data hdr or not */\n\t\t\tdatatype_hdr = tipc_v1_set_col_msgtype(pinfo, user, msg_type);\n\t\t\tif (datatype_hdr) {\n\t\t\t\t/* Data type header */\n\t\t\t\tif (hdr_size > 5 && user <4) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* Short data hdr */\n\t\t\t\t\t/* W2 Previous Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 8);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* W2 Previous Processor */\n\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 8);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIPCv2:\n\t\t\tmsg_type = tvb_get_guint8(tipc_tvb, offset + 4)>>5;\n\t\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \"%-12s\", val_to_str_const(user, tipcv2_user_short_str_vals, \"unknown\"));\n\t\t\t/* Set msg type in info col */\n\t\t\ttipc_v2_set_info_col(tvb, pinfo, user, msg_type, hdr_size);\n\n\t\t\t/* find out if it's a data hdr or not */\n\t\t\tswitch (user) {\n\t\t\t\tcase TIPCv2_DATA_LOW:\n\t\t\t\tcase TIPCv2_DATA_NORMAL:\n\t\t\t\tcase TIPCv2_DATA_HIGH:\n\t\t\t\tcase TIPCv2_DATA_NON_REJECTABLE:\n\t\t\t\t\tdatatype_hdr = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdatatype_hdr = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (datatype_hdr) {\n\t\t\t\tif (hdr_size > 6) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* W3 Previous Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 12);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (user != TIPCv2_NEIGHBOUR_DISCOVERY) {\n\t\t\t\t\t/* W6 Originating Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 24);\n\n\t\t\t\t\t/* W7 Destination Processor */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 28);\n\t\t\t\t} else {\n\t\t\t\t\t/* W2 Destination Domain */\n\t\t\t\t\tset_address_tvb(&pinfo->dst, tipc_address_type, 4, tipc_tvb, offset + 8);\n\n\t\t\t\t\t/* W3 Previous Node */\n\t\t\t\t\tset_address_tvb(&pinfo->src, tipc_address_type, 4, tipc_tvb, offset + 12);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tti = proto_tree_add_item(tree, proto_tipc, tipc_tvb, offset, -1, ENC_NA);\n\ttipc_tree = proto_item_add_subtree(ti, ett_tipc);\n\tif (version == TIPCv2) {\n\t\tdissect_tipc_v2(tipc_tvb, tipc_tree, pinfo, offset, user, msg_size, hdr_size, datatype_hdr);\n\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n\t\treturn tvb_captured_length(tvb);\n\t}\n\n\t/* Word 0-2 common for all messages */\n\t/* Word 0 */\n\tproto_tree_add_item(tipc_tree, hf_tipc_ver, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_usr, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\titem = proto_tree_add_item(tipc_tree, hf_tipc_hdr_size, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_item_append_text(item, \" = %u bytes\", (hdr_size * 4));\n\tproto_tree_add_item(tipc_tree, hf_tipc_nonsequenced, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_unused, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tif (datatype_hdr) {\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_destdrop, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipcv2_srcdrop, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t}\n\n\tproto_tree_add_item(tipc_tree, hf_tipc_msg_size, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\toffset = offset + 4;\n\n\t/* Word 1 */\n\tproto_tree_add_item(tipc_tree, hf_tipc_ack_link_lev_seq, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(tipc_tree, hf_tipc_link_lev_seq, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\toffset = offset + 4;\n\n\t/* Word 2 */\n\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\taddr_str_ptr = tipc_addr_to_str(dword);\n\tproto_tree_add_string(tipc_tree, hf_tipc_prev_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\n\toffset = offset + 4;\n\tswitch (user) {\n\t\tcase TIPC_ROUTING_MANAGER:\n\t\tcase TIPC_LINK_PROTOCOL:\n\t\tcase TIPC_CHANGEOVER_PROTOCOL:\n\t\tcase TIPC_SEGMENTATION_MANAGER:\n\t\tcase TIPC_MSG_BUNDLER:\n\t\t\tdissect_tipc_int_prot_msg(tipc_tvb, pinfo, tipc_tree, offset, user, msg_size);\n\t\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n\t\t\treturn tvb_captured_length(tvb);\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tproto_tree_add_item_ret_uint(tipc_tree, hf_tipc_org_port, tipc_tvb, offset, 4, ENC_BIG_ENDIAN, &srcport);\n\toffset = offset + 4;\n\tif (user != TIPC_NAME_DISTRIBUTOR) {\n\t\tproto_tree_add_item_ret_uint(tipc_tree, hf_tipc_dst_port, tipc_tvb, offset, 4, ENC_BIG_ENDIAN, &destport);\n\t}\n\n\tconversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, CONVERSATION_TIPC, srcport, destport);\n\n\toffset = offset + 4;\n\t/* 20 - 24 Bytes\n\t   20 bytes: Used in subnetwork local, connection oriented messages, where error code, reroute\n\t   counter and activity identity are zero. A recipient finding that the header size field is 20 does\n\t   by default know both user (DATA), message type (CONNECTED_MSG), error code\n\t   (MSG_OK), reroute counter (0), and activity identity (undefined). Since no more testing for\n\t   this is needed these fields can be left out in the header. Furthermore, since such messages\n\t   only will do zero or one inter-processor hop, we know that previous processor is the real\n\t   origin of the message. Hence the field originating processor can be omitted. For the same\n\t   reason, the recipient processor will know that it is identical to destination processor, so even\n\t   this field can be skipped. Finally, because the link layer guarantees delivery and sequence\n\t   order for this single hop, even the connection sequence number is redundant. So the message\n\t   can just be passed directly on to the destination port. Since this type of message statistically\n\t   should be by far the most frequent one this small optimization pays off.\n\t   */\n\tif (hdr_size <= 6) {\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t} else {\n\t\tswitch (user) {\n\t\t\tcase TIPC_NAME_DISTRIBUTOR:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_nd_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t\tcase TIPC_CONNECTION_MANAGER:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_cm_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data_msg_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\t\t}\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_err_code, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_reroute_cnt, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tipc_tree, hf_tipc_act_id, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\toffset = offset + 4;\n\n\t\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\t\taddr_str_ptr = tipc_addr_to_str(dword);\n\n\t\tproto_tree_add_string(tipc_tree, hf_tipc_org_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\t\toffset = offset + 4;\n\n\t\tdword = tvb_get_ntohl(tipc_tvb, offset);\n\t\taddr_str_ptr = tipc_addr_to_str(dword);\n\n\t\tproto_tree_add_string(tipc_tree, hf_tipc_dst_proc, tipc_tvb, offset, 4, addr_str_ptr);\n\t\toffset = offset + 4;\n\t\t/* 32 bytes\n\t\t   32 bytes: The size of all data messages containing an explicit port identity as destination\n\t\t   address.\n\t\t   */\n\t\tif (hdr_size > 8) {\n\t\t\tif (user == TIPC_NAME_DISTRIBUTOR) {\n\t\t\t\t/*\n\t\t\t\t   Although an internal service, the name distributor uses the full 40-byte \"external\" data header\n\t\t\t\t   format when updating the naming table instances. This is because its messages may need\n\t\t\t\t   routing, - all system processor must contain the publications from all device processors and\n\t\t\t\t   vice versa, whether they are directly linked or not. The fields name type, name instance, and\n\t\t\t\t   destination port of that header have no meaning for such messages\n\t\t\t\t   */\n\t\t\t\toffset = offset + 8;\n\t\t\t\ttipc_data_tree = proto_tree_add_subtree_format(tipc_tree, tvb, offset, -1, ett_tipc_data, NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"TIPC_NAME_DISTRIBUTOR %u bytes User Data\", (msg_size - hdr_size*4));\n\t\t\t\tdata_tvb = tvb_new_subset_remaining(tipc_tvb, offset);\n\t\t\t\tdissect_tipc_name_dist_data(data_tvb, pinfo, tipc_data_tree, 0);\n\t\t\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n\t\t\t\treturn tvb_captured_length(tvb);\n\t\t\t} else {\n\t\t\t\t/* Port name type / Connection level sequence number */\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_port_name_type, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\toffset = offset + 4;\n\t\t\t\t/* Port name instance */\n\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_port_name_instance, tipc_tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\toffset = offset + 4;\n\t\t\t}\n\t\t}\n\n\t\tif (user < 4 && dissect_tipc_data) { /* DATA type user */\n\t\t\ttvbuff_t *next_tvb;\n\t\t\tguint32 msg_type32 = msg_type;\n\t\t\tguint32 *name_type_p = &msg_type32;\n\t\t\tswitch (msg_type) {\n\t\t\t\tcase TIPC_CONNECTED_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIPC_NAMED_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_named_msg_hdr, tipc_tvb, offset, 14, ENC_NA);\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset+14, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIPC_DIRECT_MSG:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tproto_tree_add_item(tipc_tree, hf_tipc_data, tipc_tvb, offset, -1, ENC_NA);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* tipc data type user doesn't change format, reuse v2 function */\n\t\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\t\t\tcall_tipc_v2_data_subdissectors(next_tvb, pinfo, name_type_p, user);\n\t\t}\n\t} /*if (hdr_size <= 5) */\n\n\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n\treturn tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,13 @@\n \tuser = (dword>>25) & 0xf;\n \tmsg_size = dword & 0x1ffff;\n \n+\tunsigned recursion_depth = p_get_proto_depth(pinfo, proto_tipc);\n+\tif (++recursion_depth >= TIPC_MAX_RECURSION_DEPTH) {\n+\t\tproto_tree_add_expert(tree, pinfo, &ei_tipc_max_recursion_depth_reached, tvb, 0, 0);\n+\t\treturn tvb_captured_length(tvb);\n+\t}\n+\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth);\n+\n \tif ((guint32)tvb_reported_length_remaining(tvb, offset) < msg_size) {\n \t\ttipc_tvb = tvb;\n \t} else {\n@@ -114,6 +121,7 @@\n \ttipc_tree = proto_item_add_subtree(ti, ett_tipc);\n \tif (version == TIPCv2) {\n \t\tdissect_tipc_v2(tipc_tvb, tipc_tree, pinfo, offset, user, msg_size, hdr_size, datatype_hdr);\n+\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n \t\treturn tvb_captured_length(tvb);\n \t}\n \n@@ -151,6 +159,7 @@\n \t\tcase TIPC_SEGMENTATION_MANAGER:\n \t\tcase TIPC_MSG_BUNDLER:\n \t\t\tdissect_tipc_int_prot_msg(tipc_tvb, pinfo, tipc_tree, offset, user, msg_size);\n+\t\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n \t\t\treturn tvb_captured_length(tvb);\n \t\tdefault:\n \t\t\tbreak;\n@@ -227,6 +236,7 @@\n \t\t\t\t\t\t\t\t\t\t\t\t\t\"TIPC_NAME_DISTRIBUTOR %u bytes User Data\", (msg_size - hdr_size*4));\n \t\t\t\tdata_tvb = tvb_new_subset_remaining(tipc_tvb, offset);\n \t\t\t\tdissect_tipc_name_dist_data(data_tvb, pinfo, tipc_data_tree, 0);\n+\t\t\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n \t\t\t\treturn tvb_captured_length(tvb);\n \t\t\t} else {\n \t\t\t\t/* Port name type / Connection level sequence number */\n@@ -263,5 +273,6 @@\n \t\t}\n \t} /*if (hdr_size <= 5) */\n \n+\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);\n \treturn tvb_captured_length(tvb);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tunsigned recursion_depth = p_get_proto_depth(pinfo, proto_tipc);",
                "\tif (++recursion_depth >= TIPC_MAX_RECURSION_DEPTH) {",
                "\t\tproto_tree_add_expert(tree, pinfo, &ei_tipc_max_recursion_depth_reached, tvb, 0, 0);",
                "\t\treturn tvb_captured_length(tvb);",
                "\t}",
                "\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth);",
                "",
                "\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);",
                "\t\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);",
                "\t\t\t\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);",
                "\tp_set_proto_depth(pinfo, proto_tipc, recursion_depth - 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0413",
        "func_name": "wireshark/conversation_set_addr2",
        "description": "Dissection engine bug in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/55ffdb08bb5c12cfd5e2fee05f8c01d23ceaf9a3",
        "commit_title": "conversation: Remove conversation from the correct table",
        "commit_text": " In conversation_set_addr2, if the existing conversation has a port2, remove it from the _no_addr2 hashtable, not the _no_port2 hashtable.  Fix #18766 ",
        "func_before": "void\nconversation_set_addr2(conversation_t *conv, const address *addr)\n{\n    char* addr_str;\n    DISSECTOR_ASSERT_HINT(!(conv->options & CONVERSATION_TEMPLATE),\n            \"Use the conversation_create_from_template function when the CONVERSATION_TEMPLATE bit is set in the options mask\");\n\n    addr_str = address_to_str(NULL, addr);\n    DPRINT((\"called for addr=%s\", addr_str));\n    wmem_free(NULL, addr_str);\n\n    /*\n     * If the address 2 value is not wildcarded, don't set it.\n     */\n    if (!(conv->options & NO_ADDR2))\n        return;\n\n    DINDENT();\n    if (conv->options & NO_PORT2) {\n        conversation_remove_from_hashtable(conversation_hashtable_no_addr2_or_port2, conv);\n    } else {\n        conversation_remove_from_hashtable(conversation_hashtable_no_port2, conv);\n    }\n\n    // Shift our endpoint and, if needed, our port element over and set our address.\n    // We assume that conv->key_ptr was created with conversation_new and that we have\n    // enough element slots.\n    conv->options &= ~NO_ADDR2;\n    wmem_map_t *hashtable;\n    if (conv->options & NO_PORT2) {\n        // addr1,port1,endp -> addr1,port1,addr2,endp\n        conv->key_ptr[ENDP_NO_PORT2_IDX] = conv->key_ptr[ENDP_NO_ADDR2_PORT2_IDX];\n        hashtable = conversation_hashtable_no_port2;\n    } else {\n        // addr1,port1,port2,endp -> addr1,port1,addr2,port2,endp\n        conv->key_ptr[ENDP_EXACT_IDX] = conv->key_ptr[ENDP_NO_ADDR2_IDX];\n        conv->key_ptr[PORT2_IDX] = conv->key_ptr[PORT2_NO_ADDR2_IDX];\n        hashtable = conversation_hashtable_exact_addr_port;\n    }\n    conv->key_ptr[ADDR2_IDX].type = CE_ADDRESS;\n    copy_address_wmem(wmem_file_scope(), &conv->key_ptr[ADDR2_IDX].addr_val, addr);\n    conversation_insert_into_hashtable(hashtable, conv);\n    DENDENT();\n}",
        "func": "void\nconversation_set_addr2(conversation_t *conv, const address *addr)\n{\n    char* addr_str;\n    DISSECTOR_ASSERT_HINT(!(conv->options & CONVERSATION_TEMPLATE),\n            \"Use the conversation_create_from_template function when the CONVERSATION_TEMPLATE bit is set in the options mask\");\n\n    addr_str = address_to_str(NULL, addr);\n    DPRINT((\"called for addr=%s\", addr_str));\n    wmem_free(NULL, addr_str);\n\n    /*\n     * If the address 2 value is not wildcarded, don't set it.\n     */\n    if (!(conv->options & NO_ADDR2))\n        return;\n\n    DINDENT();\n    if (conv->options & NO_PORT2) {\n        conversation_remove_from_hashtable(conversation_hashtable_no_addr2_or_port2, conv);\n    } else {\n        conversation_remove_from_hashtable(conversation_hashtable_no_addr2, conv);\n    }\n\n    // Shift our endpoint and, if needed, our port element over and set our address.\n    // We assume that conv->key_ptr was created with conversation_new and that we have\n    // enough element slots.\n    conv->options &= ~NO_ADDR2;\n    wmem_map_t *hashtable;\n    if (conv->options & NO_PORT2) {\n        // addr1,port1,endp -> addr1,port1,addr2,endp\n        conv->key_ptr[ENDP_NO_PORT2_IDX] = conv->key_ptr[ENDP_NO_ADDR2_PORT2_IDX];\n        hashtable = conversation_hashtable_no_port2;\n    } else {\n        // addr1,port1,port2,endp -> addr1,port1,addr2,port2,endp\n        conv->key_ptr[ENDP_EXACT_IDX] = conv->key_ptr[ENDP_NO_ADDR2_IDX];\n        conv->key_ptr[PORT2_IDX] = conv->key_ptr[PORT2_NO_ADDR2_IDX];\n        hashtable = conversation_hashtable_exact_addr_port;\n    }\n    conv->key_ptr[ADDR2_IDX].type = CE_ADDRESS;\n    copy_address_wmem(wmem_file_scope(), &conv->key_ptr[ADDR2_IDX].addr_val, addr);\n    conversation_insert_into_hashtable(hashtable, conv);\n    DENDENT();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n     if (conv->options & NO_PORT2) {\n         conversation_remove_from_hashtable(conversation_hashtable_no_addr2_or_port2, conv);\n     } else {\n-        conversation_remove_from_hashtable(conversation_hashtable_no_port2, conv);\n+        conversation_remove_from_hashtable(conversation_hashtable_no_addr2, conv);\n     }\n \n     // Shift our endpoint and, if needed, our port element over and set our address.",
        "diff_line_info": {
            "deleted_lines": [
                "        conversation_remove_from_hashtable(conversation_hashtable_no_port2, conv);"
            ],
            "added_lines": [
                "        conversation_remove_from_hashtable(conversation_hashtable_no_addr2, conv);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0414",
        "func_name": "wireshark/dissect_eap",
        "description": "Crash in the EAP dissector in Wireshark 4.0.0 to 4.0.2 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a8b16d74e1946c4d32bd6b880ab13b7850cc70be",
        "commit_title": "eap: tweak conversation tracking to avoid breaking pinfo horribly",
        "commit_text": " Looks like conversation_set_conv_addr_port_endpoints() from 66b441f3d is designed with this use case in mind.  This should resolve issue #18622 ",
        "func_before": "static int\ndissect_eap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n  guint8          eap_code;\n  guint8          eap_identifier;\n  guint16         eap_len;\n  guint8          eap_type;\n  gint            len;\n  conversation_t *conversation       = NULL;\n  conv_state_t   *conversation_state = NULL;\n  frame_state_t  *packet_state;\n  int             leap_state;\n  proto_tree     *ti, *ti_id, *ti_len;\n  proto_tree     *eap_tree;\n  proto_tree     *eap_tls_flags_tree;\n  proto_item     *eap_type_item;\n  static address null_address = ADDRESS_INIT_NONE;\n  static guint8 pae_group_address_mac_addr[6] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x03 };\n  static address pae_group_address = ADDRESS_INIT(AT_ETHER, sizeof(pae_group_address_mac_addr), pae_group_address_mac_addr);\n  packet_info    pinfo_eapol;\n  packet_info    *pinfo_conv;\n\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"EAP\");\n  col_clear(pinfo->cinfo, COL_INFO);\n\n  eap_code = tvb_get_guint8(tvb, 0);\n  eap_identifier = tvb_get_guint8(tvb, 1);\n\n  col_add_str(pinfo->cinfo, COL_INFO,\n                val_to_str(eap_code, eap_code_vals, \"Unknown code (0x%02X)\"));\n\n  /*\n   * Find a conversation to which we belong; create one if we don't find it.\n   *\n   * EAP runs over RADIUS (which runs over UDP), EAPOL (802.1X Authentication)\n   * or other transports. In case of RADIUS, a single \"session\" may consist\n   * of two UDP associations (one for authorization, one for accounting) which\n   * results in two separate conversations. This wastes memory, but won't affect\n   * the use cases below. In case of EAPOL, there are no ports. In any case,\n   * force a new conversation when the EAP-Request/Identity message is found.\n   *\n   * Conversation tracking is required for 1) EAP-TLS reassembly and 2) tracking\n   * the stage in the LEAP protocol. In both cases, the protocol starts with an\n   * EAP-Request/Identity message which cannot be found in the middle of the\n   * session. Use it as a signal to start a new conversation. This ensures that\n   * the TLS dissector associates new TLS messages with a unique TLS session.\n   *\n   * For EAPOL frames we need to massage the source/destination addresses into\n   * something stable for the TLS decoder as wireshark typically thinks there\n   * are three conversations occurring when there is only one:\n   *  * src ether = server mac -> dst ether = PAE multicast group address\n   *  * src ether = server mac -> dst ether = client mac\n   *  * src ether = client mac -> dst ether = PAE multicast group address\n   * We set the port so the TLS decoder can figure out which side is the server\n   */\n  if (pinfo->src.type == AT_ETHER) {\n    memcpy(&pinfo_eapol, pinfo, sizeof(packet_info));\n    pinfo_conv = &pinfo_eapol;\n    if (eap_code == EAP_REQUEST) {\t/* server -> client */\n      copy_address_shallow(&pinfo_conv->src, &null_address);\n      copy_address_shallow(&pinfo_conv->dst, &pae_group_address);\n      pinfo_conv->srcport = 443;\n    } else {\t\t\t\t/* client -> server */\n      copy_address_shallow(&pinfo_conv->src, &pae_group_address);\n      copy_address_shallow(&pinfo_conv->dst, &null_address);\n      pinfo_conv->destport = 443;\n    }\n  } else {\n    pinfo_conv = pinfo;\n  }\n\n  /*\n   * To support tunneled EAP-TLS (e.g. {TTLS,PEAP,TEAP,...}/EAP-TLS) we\n   * group our TLS frames by the depth they are found at and use this\n   * as offsets for p_get_proto_data/p_add_proto_data and as done for\n   * EAPOL above we massage the client port using this too\n   */\n  guint32 tls_group = pinfo_conv->curr_proto_layer_num << 16;\n  if (eap_code == EAP_REQUEST) {\t/* server -> client */\n    pinfo_conv->destport |= tls_group;\n  } else {\t\t\t\t/* client -> server */\n    pinfo_conv->srcport |= tls_group;\n  }\n\n  if (PINFO_FD_VISITED(pinfo_conv) || !(eap_code == EAP_REQUEST && tvb_get_guint8(tvb, 4) == EAP_TYPE_ID)) {\n    conversation = find_conversation_pinfo(pinfo_conv, 0);\n  }\n  if (conversation == NULL) {\n    conversation = conversation_new(pinfo_conv->num, &pinfo_conv->src,\n\t\t      &pinfo_conv->dst, conversation_pt_to_conversation_type(pinfo_conv->ptype),\n\t\t      pinfo_conv->srcport, pinfo_conv->destport, 0);\n  }\n\n  /*\n   * Get the state information for the conversation; attach some if\n   * we don't find it.\n   */\n  conversation_state = (conv_state_t *)conversation_get_proto_data(conversation, proto_eap);\n  if (conversation_state == NULL) {\n    /*\n     * Attach state information to the conversation.\n     */\n    conversation_state = wmem_new(wmem_file_scope(), conv_state_t);\n    conversation_state->eap_tls_seq      = -1;\n    conversation_state->eap_reass_cookie =  0;\n    conversation_state->leap_state       = -1;\n    conversation_state->last_eap_id_req  = -1;\n    conversation_state->last_eap_id_resp = -1;\n    conversation_add_proto_data(conversation, proto_eap, conversation_state);\n  }\n\n  /*\n   * Set this now, so that it gets remembered even if we throw an exception\n   * later.\n   */\n  if (eap_code == EAP_FAILURE)\n    conversation_state->leap_state = -1;\n\n  eap_len = tvb_get_ntohs(tvb, 2);\n  len     = eap_len;\n\n  ti = proto_tree_add_item(tree, proto_eap, tvb, 0, len, ENC_NA);\n  eap_tree = proto_item_add_subtree(ti, ett_eap);\n\n  proto_tree_add_item(eap_tree, hf_eap_code, tvb, 0, 1, ENC_BIG_ENDIAN);\n  ti_id = proto_tree_add_item(eap_tree, hf_eap_identifier, tvb, 1, 1, ENC_BIG_ENDIAN);\n  ti_len = proto_tree_add_item(eap_tree, hf_eap_len, tvb, 2, 2, ENC_BIG_ENDIAN);\n  if (len < 4 || (guint)len > tvb_reported_length(tvb)) {\n    expert_add_info(pinfo, ti_len, &ei_eap_bad_length);\n  }\n\n  /* Detect message retransmissions. Since the protocol proceeds in lock-step,\n   * reordering is not expected. If retransmissions somehow occur, we would have\n   * to detect retransmissions via a bitmap. */\n  gboolean is_duplicate_id = FALSE;\n  if (conversation_state) {\n    if (eap_code == EAP_REQUEST || eap_code == EAP_RESPONSE ||\n        eap_code == EAP_INITIATE || eap_code == EAP_FINISH) {\n      if (!PINFO_FD_VISITED(pinfo)) {\n        gint16 *last_eap_id = eap_code == EAP_REQUEST || eap_code == EAP_INITIATE ?\n          &conversation_state->last_eap_id_req :\n          &conversation_state->last_eap_id_resp;\n        is_duplicate_id = *last_eap_id == eap_identifier;\n        *last_eap_id = eap_identifier;\n        if (is_duplicate_id) {\n          // Use a dummy value to remember that this packet is a duplicate.\n          p_add_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_DUPLICATE_ID | tls_group, GINT_TO_POINTER(1));\n        }\n      } else {\n        is_duplicate_id = !!p_get_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_DUPLICATE_ID | tls_group);\n      }\n      if (is_duplicate_id) {\n        expert_add_info(pinfo, ti_id, &ei_eap_retransmission);\n      }\n    }\n  }\n\n  switch (eap_code) {\n\n  case EAP_SUCCESS:\n  case EAP_FAILURE:\n    break;\n\n  case EAP_REQUEST:\n  case EAP_RESPONSE:\n    eap_type = tvb_get_guint8(tvb, 4);\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n                      val_to_str_ext(eap_type, &eap_type_vals_ext,\n                                     \"Unknown type (0x%02x)\"));\n    eap_type_item = proto_tree_add_item(eap_tree, hf_eap_type, tvb, 4, 1, ENC_BIG_ENDIAN);\n\n    if ((len > 5) || ((len == 5) && (eap_type == EAP_TYPE_ID))) {\n      int     offset = 5;\n      gint    size   = len - offset;\n\n      switch (eap_type) {\n        /*********************************************************************\n        **********************************************************************/\n      case EAP_TYPE_ID:\n        if (size > 0) {\n          dissect_eap_identity(tvb, pinfo, eap_tree, offset, size);\n        }\n        if (conversation_state && !PINFO_FD_VISITED(pinfo)) {\n          conversation_state->leap_state  =  0;\n          conversation_state->eap_tls_seq = -1;\n        }\n        break;\n\n        /*********************************************************************\n        **********************************************************************/\n      case EAP_TYPE_NOTIFY:\n        proto_tree_add_item(eap_tree, hf_eap_notification, tvb,\n            offset, size, ENC_ASCII);\n        break;\n\n        /*********************************************************************\n        **********************************************************************/\n      case EAP_TYPE_NAK:\n        proto_tree_add_item(eap_tree, hf_eap_type_nak, tvb,\n            offset, 1, ENC_BIG_ENDIAN);\n        break;\n        /*********************************************************************\n        **********************************************************************/\n      case EAP_TYPE_MD5:\n      {\n        guint8      value_size = tvb_get_guint8(tvb, offset);\n        gint        extra_len  = size - 1 - value_size;\n        proto_item *item;\n\n        /* Warn that this is an insecure EAP type. */\n        expert_add_info(pinfo, eap_type_item, &ei_eap_mitm_attacks);\n\n        item = proto_tree_add_item(eap_tree, hf_eap_md5_value_size, tvb, offset, 1, ENC_BIG_ENDIAN);\n        if (value_size > (size - 1))\n        {\n          expert_add_info(pinfo, item, &ei_eap_md5_value_size_overflow);\n          value_size = size - 1;\n        }\n\n        offset += 1;\n        proto_tree_add_item(eap_tree, hf_eap_md5_value, tvb, offset, value_size, ENC_NA);\n        offset += value_size;\n        if (extra_len > 0) {\n          proto_tree_add_item(eap_tree, hf_eap_md5_extra_data, tvb, offset, extra_len, ENC_NA);\n        }\n      }\n      break;\n\n      /*********************************************************************\n                                EAP-TLS\n      **********************************************************************/\n      case EAP_TYPE_FAST:\n      case EAP_TYPE_PEAP:\n      case EAP_TYPE_TTLS:\n      case EAP_TYPE_TLS:\n      case EAP_TYPE_TEAP:\n      {\n        gboolean more_fragments;\n        gboolean has_length;\n        gboolean is_start;\n        gboolean outer_tlvs = false;\n        gint outer_tlvs_length = 0;\n        int      eap_tls_seq      = -1;\n        guint32  eap_reass_cookie =  0;\n        gboolean needs_reassembly =  FALSE;\n\n        if (!conversation_state) {\n          // XXX expert info? There cannot be another EAP-TTLS message within\n          // the EAP-Message inside EAP-TTLS.\n          break;\n        }\n\n        /* Flags field, 1 byte */\n        ti = proto_tree_add_item(eap_tree, hf_eap_tls_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n        eap_tls_flags_tree = proto_item_add_subtree(ti, ett_eap_tls_flags);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_tls_flag_l, tvb, offset, 1, ENC_BIG_ENDIAN, &has_length);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_tls_flag_m, tvb, offset, 1, ENC_BIG_ENDIAN, &more_fragments);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_tls_flag_s, tvb, offset, 1, ENC_BIG_ENDIAN, &is_start);\n\n        switch (eap_type) {\n        case EAP_TYPE_TEAP:\n          proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_tls_flag_o, tvb, offset, 1, ENC_BIG_ENDIAN, &outer_tlvs);\n          /* FALLTHROUGH */\n        case EAP_TYPE_TTLS:\n        case EAP_TYPE_FAST:\n        case EAP_TYPE_PEAP:\n          proto_tree_add_item(eap_tls_flags_tree, hf_eap_tls_flags_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n          break;\n        }\n        size   -= 1;\n        offset += 1;\n\n        /* Length field, 4 bytes, OPTIONAL. */\n        if (has_length) {\n          proto_tree_add_item(eap_tree, hf_eap_tls_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n          size   -= 4;\n          offset += 4;\n        }\n\n        /* Outer TLV Length field, 4 bytes, OPTIONAL. */\n        if (outer_tlvs) {\n          proto_tree_add_item_ret_uint(eap_tree, hf_eap_tls_outer_tlvs_len, tvb, offset, 4, ENC_BIG_ENDIAN, &outer_tlvs_length);\n          size   -= 4;\n          offset += 4;\n        }\n\n        if (is_start)\n          conversation_state->eap_tls_seq = -1;\n\n        /* 4.1.1 Authority ID Data https://datatracker.ietf.org/doc/html/rfc4851#section-4.1.1 */\n        if (eap_type == EAP_TYPE_FAST && is_start) {\n          guint32 length, type;\n\n          proto_tree_add_item_ret_uint(eap_tree, hf_eap_fast_type, tvb, offset, 2, ENC_BIG_ENDIAN, &type);\n          size   -= 2;\n          offset += 2;\n\n          proto_tree_add_item_ret_uint(eap_tree, hf_eap_fast_length, tvb, offset, 2, ENC_BIG_ENDIAN, &length);\n          size   -= 2;\n          offset += 2;\n\n          proto_tree_add_item(eap_tree, hf_eap_data, tvb, offset, length, ENC_NA);\n\n          switch (type) {\n            case 4:\n              proto_tree_add_item(eap_tree, hf_eap_fast_aidd, tvb, offset, length, ENC_NA);\n            break;\n          }\n          size   -= length;\n          offset += length;\n\n        }\n\n        if (size > 0) {\n\n          tvbuff_t *next_tvb = NULL;\n          gint      tvb_len;\n          gboolean  save_fragmented;\n\n          tvb_len = tvb_captured_length_remaining(tvb, offset);\n          if (size < tvb_len)\n            tvb_len = size;\n\n          /* If this is a retransmission, do not save the fragment. */\n          if (is_duplicate_id) {\n            next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_len, size);\n            call_data_dissector(next_tvb, pinfo, eap_tree);\n            break;\n          }\n\n          /*\n            EAP/TLS is weird protocol (it comes from\n            Microsoft after all).\n\n            If we have series of fragmented packets,\n            then there's no way of knowing that from\n            the packet itself, if it is the last packet\n            in series, that is that the packet part of\n            bigger fragmented set of data.\n\n            The only way to know is, by knowing\n            that we are already in defragmentation\n            \"mode\" and we are expecing packet\n            carrying fragment of data. (either\n            because we have not received expected\n            amount of data, or because the packet before\n            had \"F\"ragment flag set.)\n\n            The situation is alleviated by fact that it\n            is simple ack/nack protcol so there's no\n            place for out-of-order packets like it is\n            possible with IP.\n\n            Anyway, point of this lengthy essay is that\n            we have to keep state information in the\n            conversation, so that we can put ourselves in\n            defragmenting mode and wait for the last packet,\n            and have to attach state to frames as well, so\n            that we can handle defragmentation after the\n            first pass through the capture.\n          */\n          /* See if we have a remembered defragmentation EAP ID. */\n          packet_state = (frame_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_FRAME_STATE | tls_group);\n          if (packet_state == NULL) {\n            /*\n             * We haven't - does this message require reassembly?\n             */\n            if (!pinfo->fd->visited) {\n              /*\n               * This is the first time we've looked at this frame,\n               * so it wouldn't have any remembered information.\n               *\n               * Therefore, we check whether this conversation has\n               * a reassembly operation in progress, or whether\n               * this frame has the Fragment flag set.\n               */\n              if (conversation_state->eap_tls_seq != -1) {\n                /*\n                 * There's a reassembly in progress; the sequence number\n                 * of the previous fragment is\n                 * \"conversation_state->eap_tls_seq\", and the reassembly\n                 * ID is \"conversation_state->eap_reass_cookie\".\n                 *\n                 * We must include this frame in the reassembly.\n                 * We advance the sequence number, giving us the\n                 * sequence number for this fragment.\n                 */\n                needs_reassembly = TRUE;\n                conversation_state->eap_tls_seq++;\n\n                eap_reass_cookie = conversation_state->eap_reass_cookie;\n                eap_tls_seq = conversation_state->eap_tls_seq;\n              } else if (more_fragments && has_length) {\n                /*\n                 * This message has the Fragment flag set, so it requires\n                 * reassembly.  It's the message containing the first\n                 * fragment (if it's a later fragment, the sequence\n                 * number in the conversation state would not be -1).\n                 *\n                 * If it doesn't include a length, however, we can't\n                 * do reassembly (either the message is in error, as\n                 * the first fragment *must* contain a length, or we\n                 * didn't capture the first fragment, and this just\n                 * happens to be the first fragment we saw), so we\n                 * also check that we have a length;\n                 */\n                needs_reassembly = TRUE;\n                conversation_state->eap_reass_cookie = pinfo->num;\n\n                /*\n                 * Start the reassembly sequence number at 0.\n                 */\n                conversation_state->eap_tls_seq = 0;\n\n                eap_tls_seq = conversation_state->eap_tls_seq;\n                eap_reass_cookie = conversation_state->eap_reass_cookie;\n              }\n\n              if (needs_reassembly) {\n                /*\n                 * This frame requires reassembly; remember the reassembly\n                 * ID for subsequent accesses to it.\n                 */\n                packet_state = wmem_new(wmem_file_scope(), frame_state_t);\n                packet_state->info = eap_reass_cookie;\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_FRAME_STATE | tls_group, packet_state);\n              }\n            }\n          } else {\n            /*\n             * This frame has a reassembly cookie associated with it, so\n             * it requires reassembly.  We've already done the\n             * reassembly in the first pass, so \"fragment_add_seq()\"\n             * won't look at the sequence number; set it to 0.\n             *\n             * XXX - a frame isn't supposed to have more than one\n             * EAP message in it, but if it includes both an EAP-TLS\n             * message and a LEAP message, we might be mistakenly\n             * concluding it requires reassembly because the \"info\"\n             * field isn't -1.  We could, I guess, pack both EAP-TLS\n             * ID and LEAP state into the structure, but that doesn't\n             * work if you have multiple EAP-TLS or LEAP messages in\n             * the frame.\n             *\n             * But it's not clear how much work we should do to handle\n             * a bogus message such as that; as long as we don't crash\n             * or do something else equally horrible, we may not\n             * have to worry about this at all.\n             */\n            needs_reassembly = TRUE;\n            eap_reass_cookie = packet_state->info;\n            eap_tls_seq = 0;\n          }\n\n          /*\n            We test here to see whether EAP-TLS packet\n            carry fragmented of TLS data.\n\n            If this is the case, we do reasembly below,\n            otherwise we just call dissector.\n          */\n          if (needs_reassembly) {\n            fragment_head   *fd_head;\n\n            /*\n             * Yes, this frame contains a fragment that requires\n             * reassembly.\n             */\n            save_fragmented   = pinfo->fragmented;\n            pinfo->fragmented = TRUE;\n            fd_head = fragment_add_seq(&eap_tls_reassembly_table,\n                                       tvb, offset,\n                                       pinfo, eap_reass_cookie, NULL,\n                                       eap_tls_seq,\n                                       size,\n                                       more_fragments, 0);\n\n            if (fd_head != NULL && fd_head->reassembled_in == pinfo->num) {\n              /* Reassembled  */\n              proto_item *frag_tree_item;\n\n              next_tvb = tvb_new_chain(tvb, fd_head->tvb_data);\n              add_new_data_source(pinfo, next_tvb, \"Reassembled EAP-TLS\");\n\n              show_fragment_seq_tree(fd_head, &eap_tls_frag_items,\n                                     eap_tree, pinfo, next_tvb, &frag_tree_item);\n\n              /*\n               * We're finished reassembing this frame.\n               * Reinitialize the reassembly state.\n               */\n              if (!pinfo->fd->visited)\n                conversation_state->eap_tls_seq = -1;\n            }\n\n            pinfo->fragmented = save_fragmented;\n\n          } else { /* this data is NOT fragmented */\n            next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_len, size);\n          }\n\n          if (next_tvb) {\n            switch (eap_type) {\n              case EAP_TYPE_TTLS:\n                tls_set_appdata_dissector(tls_handle, pinfo_conv, diameter_avps_handle);\n                break;\n              case EAP_TYPE_PEAP:\n                p_add_proto_data(pinfo->pool, pinfo, proto_eap, PROTO_DATA_EAP_TVB | tls_group, tvb);\n                tls_set_appdata_dissector(tls_handle, pinfo_conv, peap_handle);\n                break;\n              case EAP_TYPE_TEAP:\n                if (outer_tlvs) {\t/* https://www.rfc-editor.org/rfc/rfc7170.html#section-4.1 */\n                  tvbuff_t *teap_tvb = tvb_new_subset_length(tvb, offset + size - outer_tlvs_length, outer_tlvs_length);\n                  call_dissector(teap_handle, teap_tvb, pinfo_conv, eap_tree);\n                  if (size == outer_tlvs_length) goto skip_tls_dissector;\n                  next_tvb = tvb_new_subset_length(next_tvb, 0, size - outer_tlvs_length);\n                }\n                tls_set_appdata_dissector(tls_handle, pinfo_conv, teap_handle);\n                break;\n            }\n            call_dissector(tls_handle, next_tvb, pinfo_conv, eap_tree);\n          }\n        }\n      }\nskip_tls_dissector:\n      break; /*  EAP_TYPE_TLS */\n\n      /*********************************************************************\n        Cisco's Lightweight EAP (LEAP)\n        https://web.archive.org/web/20070623090417if_/http://www.missl.cs.umd.edu/wireless/ethereal/leap.txt\n      **********************************************************************/\n      case EAP_TYPE_LEAP:\n      {\n        guint8 count, namesize;\n\n        /* Warn that this is an insecure EAP type. */\n        expert_add_info(pinfo, eap_type_item, &ei_eap_dictionary_attacks);\n\n        /* Version (byte) */\n        proto_tree_add_item(eap_tree, hf_eap_leap_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* Unused  (byte) */\n        proto_tree_add_item(eap_tree, hf_eap_leap_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* Count   (byte) */\n        count = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(eap_tree, hf_eap_leap_count, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* Data    (byte*Count) */\n        /* This part is state-dependent. */\n\n        if (!conversation_state) {\n          // XXX expert info? LEAP is not expected within the EAP-Message within EAP-TTLS.\n          break;\n        }\n        /* XXX - are duplicates possible (is_duplicate_id)?\n         * If so, should we stop here to avoid modifying conversation_state? */\n\n        /* See if we've already remembered the state. */\n        packet_state = (frame_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_FRAME_STATE | tls_group);\n        if (packet_state == NULL) {\n          /*\n           * We haven't - compute the state based on the current\n           * state in the conversation.\n           */\n          leap_state = conversation_state->leap_state;\n\n          /* Advance the state machine. */\n          if (leap_state==0) leap_state =  1; else\n            if (leap_state==1) leap_state =  2; else\n              if (leap_state==2) leap_state =  3; else\n                if (leap_state==3) leap_state =  4; else\n                  if (leap_state==4) leap_state = -1;\n\n          /*\n           * Remember the state for subsequent accesses to this\n           * frame.\n           */\n          packet_state = wmem_new(wmem_file_scope(), frame_state_t);\n          packet_state->info = leap_state;\n          p_add_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_FRAME_STATE | tls_group, packet_state);\n\n          /*\n           * Update the conversation's state.\n           */\n          conversation_state->leap_state = leap_state;\n        }\n\n        /* Get the remembered state. */\n        leap_state = packet_state->info;\n\n        switch (leap_state) {\n          case 1:\n            proto_tree_add_item(eap_tree, hf_eap_leap_peer_challenge, tvb, offset, count, ENC_NA);\n            break;\n\n          case 2:\n            proto_tree_add_item(eap_tree, hf_eap_leap_peer_response, tvb, offset, count, ENC_NA);\n            break;\n\n          case 3:\n            proto_tree_add_item(eap_tree, hf_eap_leap_ap_challenge, tvb, offset, count, ENC_NA);\n            break;\n\n          case 4:\n            proto_tree_add_item(eap_tree, hf_eap_leap_ap_response, tvb, offset, count, ENC_NA);\n            break;\n\n          default:\n            proto_tree_add_item(eap_tree, hf_eap_leap_data, tvb, offset, count, ENC_NA);\n            break;\n        }\n\n        offset += count;\n\n        /* Name    (Length-(8+Count)) */\n        namesize = eap_len - (8+count);\n        proto_tree_add_item(eap_tree, hf_eap_leap_name, tvb, offset, namesize, ENC_ASCII);\n      }\n\n      break; /* EAP_TYPE_LEAP */\n\n      /*********************************************************************\n            EAP-MSCHAPv2 - draft-kamath-pppext-eap-mschapv2-00.txt\n      **********************************************************************/\n      case EAP_TYPE_MSCHAPV2:\n        dissect_eap_mschapv2(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_MSCHAPV2 */\n\n        /*********************************************************************\n           EAP-SIM - draft-haverinen-pppext-eap-sim-13.txt\n        **********************************************************************/\n      case EAP_TYPE_SIM:\n        dissect_eap_sim(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_SIM */\n\n        /*********************************************************************\n            EAP-AKA - draft-arkko-pppext-eap-aka-12.txt\n        **********************************************************************/\n      case EAP_TYPE_AKA:\n      case EAP_TYPE_AKA_PRIME:\n        dissect_eap_aka(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_AKA */\n\n        /*********************************************************************\n            EAP Expanded Type\n        **********************************************************************/\n      case EAP_TYPE_EXT:\n      {\n        proto_tree *exptree;\n\n        exptree   = proto_tree_add_subtree(eap_tree, tvb, offset, size, ett_eap_exp_attr, NULL, \"Expanded Type\");\n        dissect_exteap(exptree, tvb, offset, size, pinfo, eap_code, eap_identifier);\n      }\n      break;\n\n      /*********************************************************************\n            EAP-PAX - RFC 4746\n      **********************************************************************/\n      case EAP_TYPE_PAX:\n        dissect_eap_pax(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_PAX */\n\n      /*********************************************************************\n            EAP-PSK - RFC 4764\n      **********************************************************************/\n      case EAP_TYPE_PSK:\n        dissect_eap_psk(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_PSK */\n\n      /*********************************************************************\n            EAP-SAKE - RFC 4763\n      **********************************************************************/\n      case EAP_TYPE_SAKE:\n        dissect_eap_sake(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_SAKE */\n\n      /*********************************************************************\n            EAP-GPSK - RFC 5433\n      **********************************************************************/\n      case EAP_TYPE_GPSK:\n        dissect_eap_gpsk(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_GPSK */\n\n      /*********************************************************************\n            EAP-IKEv2 - RFC 5106\n      **********************************************************************/\n      case EAP_TYPE_IKEV2:\n      {\n        gboolean more_fragments;\n        gboolean has_length;\n        gboolean icv_present;\n\n        /* Flags field, 1 byte */\n        ti = proto_tree_add_item(eap_tree, hf_eap_ikev2_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n        eap_tls_flags_tree = proto_item_add_subtree(ti, hf_eap_ikev2_flags);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_ikev2_flag_l, tvb, offset, 1, ENC_BIG_ENDIAN, &has_length);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_ikev2_flag_m, tvb, offset, 1, ENC_BIG_ENDIAN, &more_fragments);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_ikev2_flag_i, tvb, offset, 1, ENC_BIG_ENDIAN, &icv_present);\n\n        size -= 1;\n        offset += 1;\n\n        /* Length field, 4 bytes, OPTIONAL. */\n        if (has_length) {\n          proto_tree_add_item(eap_tree, hf_eap_ikev2_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n          size -= 4;\n          offset += 4;\n        }\n\n        if (size > 0) {\n          tvbuff_t* next_tvb = NULL;\n          gint      tvb_len;\n\n          tvb_len = tvb_captured_length_remaining(tvb, offset);\n          if (size < tvb_len) {\n            tvb_len = size;\n          }\n\n          if (has_length || more_fragments) {\n            /* TODO: Add fragmentation support\n             * Length of integrity check data needs to be determined in case of fragmentation. Chosen INTEG transform?\n             */\n          } else {\n            next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_len, size);\n            guint tmp = call_dissector(isakmp_handle, next_tvb, pinfo, eap_tree);\n            size -= tmp;\n            offset += tmp;\n\n            if (icv_present && size > 0) {\n              /* We assume that all data present is integrity check data. We cannot detect too short/long right now. */\n              proto_tree_add_item(eap_tree, hf_eap_ikev2_int_chk_data, tvb, offset, size, ENC_NA);\n            }\n          }\n        }\n\n        break;\n      } /* EAP_TYPE_IKEV2 */\n\n      /*********************************************************************\n            MS-Authentication-TLV - MS-PEAP section 2.2.8.1\n      **********************************************************************/\n      case EAP_TYPE_MSAUTH_TLV:\n        dissect_eap_msauth_tlv(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_MSAUTH_TLV */\n\n      /*********************************************************************\n      **********************************************************************/\n      default:\n        proto_tree_add_item(eap_tree, hf_eap_data, tvb, offset, size, ENC_NA);\n        break;\n        /*********************************************************************\n        **********************************************************************/\n      } /* switch (eap_type) */\n\n    }\n\n  } /* switch (eap_code) */\n\n  return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_eap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n  guint8          eap_code;\n  guint8          eap_identifier;\n  guint16         eap_len;\n  guint8          eap_type;\n  gint            len;\n  conversation_t *conversation       = NULL;\n  conv_state_t   *conversation_state = NULL;\n  frame_state_t  *packet_state;\n  int             leap_state;\n  proto_tree     *ti, *ti_id, *ti_len;\n  proto_tree     *eap_tree;\n  proto_tree     *eap_tls_flags_tree;\n  proto_item     *eap_type_item;\n  static address null_address = ADDRESS_INIT_NONE;\n  static guint8 pae_group_address_mac_addr[6] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x03 };\n  static address pae_group_address = ADDRESS_INIT(AT_ETHER, sizeof(pae_group_address_mac_addr), pae_group_address_mac_addr);\n\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"EAP\");\n  col_clear(pinfo->cinfo, COL_INFO);\n\n  eap_code = tvb_get_guint8(tvb, 0);\n  eap_identifier = tvb_get_guint8(tvb, 1);\n\n  col_add_str(pinfo->cinfo, COL_INFO,\n                val_to_str(eap_code, eap_code_vals, \"Unknown code (0x%02X)\"));\n\n  /*\n   * Find a conversation to which we belong; create one if we don't find it.\n   *\n   * EAP runs over RADIUS (which runs over UDP), EAPOL (802.1X Authentication)\n   * or other transports. In case of RADIUS, a single \"session\" may consist\n   * of two UDP associations (one for authorization, one for accounting) which\n   * results in two separate conversations. This wastes memory, but won't affect\n   * the use cases below. In case of EAPOL, there are no ports. In any case,\n   * force a new conversation when the EAP-Request/Identity message is found.\n   *\n   * Conversation tracking is required for 1) EAP-TLS reassembly and 2) tracking\n   * the stage in the LEAP protocol. In both cases, the protocol starts with an\n   * EAP-Request/Identity message which cannot be found in the middle of the\n   * session. Use it as a signal to start a new conversation. This ensures that\n   * the TLS dissector associates new TLS messages with a unique TLS session.\n   *\n   * For EAPOL frames we need to massage the source/destination addresses into\n   * something stable for the TLS decoder as wireshark typically thinks there\n   * are three conversations occurring when there is only one:\n   *  * src ether = server mac -> dst ether = PAE multicast group address\n   *  * src ether = server mac -> dst ether = client mac\n   *  * src ether = client mac -> dst ether = PAE multicast group address\n   * We set the port so the TLS decoder can figure out which side is the server\n   */\n  if (pinfo->src.type == AT_ETHER) {\n    if (eap_code == EAP_REQUEST) {\t/* server -> client */\n      conversation_set_conv_addr_port_endpoints(pinfo, &null_address, &pae_group_address, conversation_pt_to_conversation_type(pinfo->ptype), 443, pinfo->destport);\n    } else {\t\t\t\t/* client -> server */\n      conversation_set_conv_addr_port_endpoints(pinfo, &pae_group_address, &null_address, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport, 443);\n    }\n  }\n\n  /*\n   * To support tunneled EAP-TLS (e.g. {TTLS,PEAP,TEAP,...}/EAP-TLS) we\n   * group our TLS frames by the depth they are found at and use this\n   * as offsets for p_get_proto_data/p_add_proto_data and as done for\n   * EAPOL above we massage the client port using this too\n   */\n  guint32 tls_group = pinfo->curr_proto_layer_num << 16;\n  if (eap_code == EAP_REQUEST) {\t/* server -> client */\n    conversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport, pinfo->destport | tls_group);\n  } else {\t\t\t\t/* client -> server */\n    conversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport | tls_group, pinfo->destport);\n  }\n\n  if (PINFO_FD_VISITED(pinfo) || !(eap_code == EAP_REQUEST && tvb_get_guint8(tvb, 4) == EAP_TYPE_ID)) {\n    conversation = find_conversation_pinfo(pinfo, 0);\n  }\n  if (conversation == NULL) {\n    conversation = conversation_new(pinfo->num, &pinfo->src,\n\t\t      &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype),\n\t\t      pinfo->srcport, pinfo->destport, 0);\n  }\n\n  /*\n   * Get the state information for the conversation; attach some if\n   * we don't find it.\n   */\n  conversation_state = (conv_state_t *)conversation_get_proto_data(conversation, proto_eap);\n  if (conversation_state == NULL) {\n    /*\n     * Attach state information to the conversation.\n     */\n    conversation_state = wmem_new(wmem_file_scope(), conv_state_t);\n    conversation_state->eap_tls_seq      = -1;\n    conversation_state->eap_reass_cookie =  0;\n    conversation_state->leap_state       = -1;\n    conversation_state->last_eap_id_req  = -1;\n    conversation_state->last_eap_id_resp = -1;\n    conversation_add_proto_data(conversation, proto_eap, conversation_state);\n  }\n\n  /*\n   * Set this now, so that it gets remembered even if we throw an exception\n   * later.\n   */\n  if (eap_code == EAP_FAILURE)\n    conversation_state->leap_state = -1;\n\n  eap_len = tvb_get_ntohs(tvb, 2);\n  len     = eap_len;\n\n  ti = proto_tree_add_item(tree, proto_eap, tvb, 0, len, ENC_NA);\n  eap_tree = proto_item_add_subtree(ti, ett_eap);\n\n  proto_tree_add_item(eap_tree, hf_eap_code, tvb, 0, 1, ENC_BIG_ENDIAN);\n  ti_id = proto_tree_add_item(eap_tree, hf_eap_identifier, tvb, 1, 1, ENC_BIG_ENDIAN);\n  ti_len = proto_tree_add_item(eap_tree, hf_eap_len, tvb, 2, 2, ENC_BIG_ENDIAN);\n  if (len < 4 || (guint)len > tvb_reported_length(tvb)) {\n    expert_add_info(pinfo, ti_len, &ei_eap_bad_length);\n  }\n\n  /* Detect message retransmissions. Since the protocol proceeds in lock-step,\n   * reordering is not expected. If retransmissions somehow occur, we would have\n   * to detect retransmissions via a bitmap. */\n  gboolean is_duplicate_id = FALSE;\n  if (conversation_state) {\n    if (eap_code == EAP_REQUEST || eap_code == EAP_RESPONSE ||\n        eap_code == EAP_INITIATE || eap_code == EAP_FINISH) {\n      if (!PINFO_FD_VISITED(pinfo)) {\n        gint16 *last_eap_id = eap_code == EAP_REQUEST || eap_code == EAP_INITIATE ?\n          &conversation_state->last_eap_id_req :\n          &conversation_state->last_eap_id_resp;\n        is_duplicate_id = *last_eap_id == eap_identifier;\n        *last_eap_id = eap_identifier;\n        if (is_duplicate_id) {\n          // Use a dummy value to remember that this packet is a duplicate.\n          p_add_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_DUPLICATE_ID | tls_group, GINT_TO_POINTER(1));\n        }\n      } else {\n        is_duplicate_id = !!p_get_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_DUPLICATE_ID | tls_group);\n      }\n      if (is_duplicate_id) {\n        expert_add_info(pinfo, ti_id, &ei_eap_retransmission);\n      }\n    }\n  }\n\n  switch (eap_code) {\n\n  case EAP_SUCCESS:\n  case EAP_FAILURE:\n    break;\n\n  case EAP_REQUEST:\n  case EAP_RESPONSE:\n    eap_type = tvb_get_guint8(tvb, 4);\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \", %s\",\n                      val_to_str_ext(eap_type, &eap_type_vals_ext,\n                                     \"Unknown type (0x%02x)\"));\n    eap_type_item = proto_tree_add_item(eap_tree, hf_eap_type, tvb, 4, 1, ENC_BIG_ENDIAN);\n\n    if ((len > 5) || ((len == 5) && (eap_type == EAP_TYPE_ID))) {\n      int     offset = 5;\n      gint    size   = len - offset;\n\n      switch (eap_type) {\n        /*********************************************************************\n        **********************************************************************/\n      case EAP_TYPE_ID:\n        if (size > 0) {\n          dissect_eap_identity(tvb, pinfo, eap_tree, offset, size);\n        }\n        if (conversation_state && !PINFO_FD_VISITED(pinfo)) {\n          conversation_state->leap_state  =  0;\n          conversation_state->eap_tls_seq = -1;\n        }\n        break;\n\n        /*********************************************************************\n        **********************************************************************/\n      case EAP_TYPE_NOTIFY:\n        proto_tree_add_item(eap_tree, hf_eap_notification, tvb,\n            offset, size, ENC_ASCII);\n        break;\n\n        /*********************************************************************\n        **********************************************************************/\n      case EAP_TYPE_NAK:\n        proto_tree_add_item(eap_tree, hf_eap_type_nak, tvb,\n            offset, 1, ENC_BIG_ENDIAN);\n        break;\n        /*********************************************************************\n        **********************************************************************/\n      case EAP_TYPE_MD5:\n      {\n        guint8      value_size = tvb_get_guint8(tvb, offset);\n        gint        extra_len  = size - 1 - value_size;\n        proto_item *item;\n\n        /* Warn that this is an insecure EAP type. */\n        expert_add_info(pinfo, eap_type_item, &ei_eap_mitm_attacks);\n\n        item = proto_tree_add_item(eap_tree, hf_eap_md5_value_size, tvb, offset, 1, ENC_BIG_ENDIAN);\n        if (value_size > (size - 1))\n        {\n          expert_add_info(pinfo, item, &ei_eap_md5_value_size_overflow);\n          value_size = size - 1;\n        }\n\n        offset += 1;\n        proto_tree_add_item(eap_tree, hf_eap_md5_value, tvb, offset, value_size, ENC_NA);\n        offset += value_size;\n        if (extra_len > 0) {\n          proto_tree_add_item(eap_tree, hf_eap_md5_extra_data, tvb, offset, extra_len, ENC_NA);\n        }\n      }\n      break;\n\n      /*********************************************************************\n                                EAP-TLS\n      **********************************************************************/\n      case EAP_TYPE_FAST:\n      case EAP_TYPE_PEAP:\n      case EAP_TYPE_TTLS:\n      case EAP_TYPE_TLS:\n      case EAP_TYPE_TEAP:\n      {\n        gboolean more_fragments;\n        gboolean has_length;\n        gboolean is_start;\n        gboolean outer_tlvs = false;\n        gint outer_tlvs_length = 0;\n        int      eap_tls_seq      = -1;\n        guint32  eap_reass_cookie =  0;\n        gboolean needs_reassembly =  FALSE;\n\n        if (!conversation_state) {\n          // XXX expert info? There cannot be another EAP-TTLS message within\n          // the EAP-Message inside EAP-TTLS.\n          break;\n        }\n\n        /* Flags field, 1 byte */\n        ti = proto_tree_add_item(eap_tree, hf_eap_tls_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n        eap_tls_flags_tree = proto_item_add_subtree(ti, ett_eap_tls_flags);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_tls_flag_l, tvb, offset, 1, ENC_BIG_ENDIAN, &has_length);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_tls_flag_m, tvb, offset, 1, ENC_BIG_ENDIAN, &more_fragments);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_tls_flag_s, tvb, offset, 1, ENC_BIG_ENDIAN, &is_start);\n\n        switch (eap_type) {\n        case EAP_TYPE_TEAP:\n          proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_tls_flag_o, tvb, offset, 1, ENC_BIG_ENDIAN, &outer_tlvs);\n          /* FALLTHROUGH */\n        case EAP_TYPE_TTLS:\n        case EAP_TYPE_FAST:\n        case EAP_TYPE_PEAP:\n          proto_tree_add_item(eap_tls_flags_tree, hf_eap_tls_flags_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n          break;\n        }\n        size   -= 1;\n        offset += 1;\n\n        /* Length field, 4 bytes, OPTIONAL. */\n        if (has_length) {\n          proto_tree_add_item(eap_tree, hf_eap_tls_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n          size   -= 4;\n          offset += 4;\n        }\n\n        /* Outer TLV Length field, 4 bytes, OPTIONAL. */\n        if (outer_tlvs) {\n          proto_tree_add_item_ret_uint(eap_tree, hf_eap_tls_outer_tlvs_len, tvb, offset, 4, ENC_BIG_ENDIAN, &outer_tlvs_length);\n          size   -= 4;\n          offset += 4;\n        }\n\n        if (is_start)\n          conversation_state->eap_tls_seq = -1;\n\n        /* 4.1.1 Authority ID Data https://datatracker.ietf.org/doc/html/rfc4851#section-4.1.1 */\n        if (eap_type == EAP_TYPE_FAST && is_start) {\n          guint32 length, type;\n\n          proto_tree_add_item_ret_uint(eap_tree, hf_eap_fast_type, tvb, offset, 2, ENC_BIG_ENDIAN, &type);\n          size   -= 2;\n          offset += 2;\n\n          proto_tree_add_item_ret_uint(eap_tree, hf_eap_fast_length, tvb, offset, 2, ENC_BIG_ENDIAN, &length);\n          size   -= 2;\n          offset += 2;\n\n          proto_tree_add_item(eap_tree, hf_eap_data, tvb, offset, length, ENC_NA);\n\n          switch (type) {\n            case 4:\n              proto_tree_add_item(eap_tree, hf_eap_fast_aidd, tvb, offset, length, ENC_NA);\n            break;\n          }\n          size   -= length;\n          offset += length;\n\n        }\n\n        if (size > 0) {\n\n          tvbuff_t *next_tvb = NULL;\n          gint      tvb_len;\n          gboolean  save_fragmented;\n\n          tvb_len = tvb_captured_length_remaining(tvb, offset);\n          if (size < tvb_len)\n            tvb_len = size;\n\n          /* If this is a retransmission, do not save the fragment. */\n          if (is_duplicate_id) {\n            next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_len, size);\n            call_data_dissector(next_tvb, pinfo, eap_tree);\n            break;\n          }\n\n          /*\n            EAP/TLS is weird protocol (it comes from\n            Microsoft after all).\n\n            If we have series of fragmented packets,\n            then there's no way of knowing that from\n            the packet itself, if it is the last packet\n            in series, that is that the packet part of\n            bigger fragmented set of data.\n\n            The only way to know is, by knowing\n            that we are already in defragmentation\n            \"mode\" and we are expecing packet\n            carrying fragment of data. (either\n            because we have not received expected\n            amount of data, or because the packet before\n            had \"F\"ragment flag set.)\n\n            The situation is alleviated by fact that it\n            is simple ack/nack protcol so there's no\n            place for out-of-order packets like it is\n            possible with IP.\n\n            Anyway, point of this lengthy essay is that\n            we have to keep state information in the\n            conversation, so that we can put ourselves in\n            defragmenting mode and wait for the last packet,\n            and have to attach state to frames as well, so\n            that we can handle defragmentation after the\n            first pass through the capture.\n          */\n          /* See if we have a remembered defragmentation EAP ID. */\n          packet_state = (frame_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_FRAME_STATE | tls_group);\n          if (packet_state == NULL) {\n            /*\n             * We haven't - does this message require reassembly?\n             */\n            if (!pinfo->fd->visited) {\n              /*\n               * This is the first time we've looked at this frame,\n               * so it wouldn't have any remembered information.\n               *\n               * Therefore, we check whether this conversation has\n               * a reassembly operation in progress, or whether\n               * this frame has the Fragment flag set.\n               */\n              if (conversation_state->eap_tls_seq != -1) {\n                /*\n                 * There's a reassembly in progress; the sequence number\n                 * of the previous fragment is\n                 * \"conversation_state->eap_tls_seq\", and the reassembly\n                 * ID is \"conversation_state->eap_reass_cookie\".\n                 *\n                 * We must include this frame in the reassembly.\n                 * We advance the sequence number, giving us the\n                 * sequence number for this fragment.\n                 */\n                needs_reassembly = TRUE;\n                conversation_state->eap_tls_seq++;\n\n                eap_reass_cookie = conversation_state->eap_reass_cookie;\n                eap_tls_seq = conversation_state->eap_tls_seq;\n              } else if (more_fragments && has_length) {\n                /*\n                 * This message has the Fragment flag set, so it requires\n                 * reassembly.  It's the message containing the first\n                 * fragment (if it's a later fragment, the sequence\n                 * number in the conversation state would not be -1).\n                 *\n                 * If it doesn't include a length, however, we can't\n                 * do reassembly (either the message is in error, as\n                 * the first fragment *must* contain a length, or we\n                 * didn't capture the first fragment, and this just\n                 * happens to be the first fragment we saw), so we\n                 * also check that we have a length;\n                 */\n                needs_reassembly = TRUE;\n                conversation_state->eap_reass_cookie = pinfo->num;\n\n                /*\n                 * Start the reassembly sequence number at 0.\n                 */\n                conversation_state->eap_tls_seq = 0;\n\n                eap_tls_seq = conversation_state->eap_tls_seq;\n                eap_reass_cookie = conversation_state->eap_reass_cookie;\n              }\n\n              if (needs_reassembly) {\n                /*\n                 * This frame requires reassembly; remember the reassembly\n                 * ID for subsequent accesses to it.\n                 */\n                packet_state = wmem_new(wmem_file_scope(), frame_state_t);\n                packet_state->info = eap_reass_cookie;\n                p_add_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_FRAME_STATE | tls_group, packet_state);\n              }\n            }\n          } else {\n            /*\n             * This frame has a reassembly cookie associated with it, so\n             * it requires reassembly.  We've already done the\n             * reassembly in the first pass, so \"fragment_add_seq()\"\n             * won't look at the sequence number; set it to 0.\n             *\n             * XXX - a frame isn't supposed to have more than one\n             * EAP message in it, but if it includes both an EAP-TLS\n             * message and a LEAP message, we might be mistakenly\n             * concluding it requires reassembly because the \"info\"\n             * field isn't -1.  We could, I guess, pack both EAP-TLS\n             * ID and LEAP state into the structure, but that doesn't\n             * work if you have multiple EAP-TLS or LEAP messages in\n             * the frame.\n             *\n             * But it's not clear how much work we should do to handle\n             * a bogus message such as that; as long as we don't crash\n             * or do something else equally horrible, we may not\n             * have to worry about this at all.\n             */\n            needs_reassembly = TRUE;\n            eap_reass_cookie = packet_state->info;\n            eap_tls_seq = 0;\n          }\n\n          /*\n            We test here to see whether EAP-TLS packet\n            carry fragmented of TLS data.\n\n            If this is the case, we do reasembly below,\n            otherwise we just call dissector.\n          */\n          if (needs_reassembly) {\n            fragment_head   *fd_head;\n\n            /*\n             * Yes, this frame contains a fragment that requires\n             * reassembly.\n             */\n            save_fragmented   = pinfo->fragmented;\n            pinfo->fragmented = TRUE;\n            fd_head = fragment_add_seq(&eap_tls_reassembly_table,\n                                       tvb, offset,\n                                       pinfo, eap_reass_cookie, NULL,\n                                       eap_tls_seq,\n                                       size,\n                                       more_fragments, 0);\n\n            if (fd_head != NULL && fd_head->reassembled_in == pinfo->num) {\n              /* Reassembled  */\n              proto_item *frag_tree_item;\n\n              next_tvb = tvb_new_chain(tvb, fd_head->tvb_data);\n              add_new_data_source(pinfo, next_tvb, \"Reassembled EAP-TLS\");\n\n              show_fragment_seq_tree(fd_head, &eap_tls_frag_items,\n                                     eap_tree, pinfo, next_tvb, &frag_tree_item);\n\n              /*\n               * We're finished reassembing this frame.\n               * Reinitialize the reassembly state.\n               */\n              if (!pinfo->fd->visited)\n                conversation_state->eap_tls_seq = -1;\n            }\n\n            pinfo->fragmented = save_fragmented;\n\n          } else { /* this data is NOT fragmented */\n            next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_len, size);\n          }\n\n          if (next_tvb) {\n            switch (eap_type) {\n              case EAP_TYPE_TTLS:\n                tls_set_appdata_dissector(tls_handle, pinfo, diameter_avps_handle);\n                break;\n              case EAP_TYPE_PEAP:\n                p_add_proto_data(pinfo->pool, pinfo, proto_eap, PROTO_DATA_EAP_TVB | tls_group, tvb);\n                tls_set_appdata_dissector(tls_handle, pinfo, peap_handle);\n                break;\n              case EAP_TYPE_TEAP:\n                if (outer_tlvs) {\t/* https://www.rfc-editor.org/rfc/rfc7170.html#section-4.1 */\n                  tvbuff_t *teap_tvb = tvb_new_subset_length(tvb, offset + size - outer_tlvs_length, outer_tlvs_length);\n                  call_dissector(teap_handle, teap_tvb, pinfo, eap_tree);\n                  if (size == outer_tlvs_length) goto skip_tls_dissector;\n                  next_tvb = tvb_new_subset_length(next_tvb, 0, size - outer_tlvs_length);\n                }\n                tls_set_appdata_dissector(tls_handle, pinfo, teap_handle);\n                break;\n            }\n            call_dissector(tls_handle, next_tvb, pinfo, eap_tree);\n          }\n        }\n      }\nskip_tls_dissector:\n      break; /*  EAP_TYPE_TLS */\n\n      /*********************************************************************\n        Cisco's Lightweight EAP (LEAP)\n        https://web.archive.org/web/20070623090417if_/http://www.missl.cs.umd.edu/wireless/ethereal/leap.txt\n      **********************************************************************/\n      case EAP_TYPE_LEAP:\n      {\n        guint8 count, namesize;\n\n        /* Warn that this is an insecure EAP type. */\n        expert_add_info(pinfo, eap_type_item, &ei_eap_dictionary_attacks);\n\n        /* Version (byte) */\n        proto_tree_add_item(eap_tree, hf_eap_leap_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* Unused  (byte) */\n        proto_tree_add_item(eap_tree, hf_eap_leap_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* Count   (byte) */\n        count = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(eap_tree, hf_eap_leap_count, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* Data    (byte*Count) */\n        /* This part is state-dependent. */\n\n        if (!conversation_state) {\n          // XXX expert info? LEAP is not expected within the EAP-Message within EAP-TTLS.\n          break;\n        }\n        /* XXX - are duplicates possible (is_duplicate_id)?\n         * If so, should we stop here to avoid modifying conversation_state? */\n\n        /* See if we've already remembered the state. */\n        packet_state = (frame_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_FRAME_STATE | tls_group);\n        if (packet_state == NULL) {\n          /*\n           * We haven't - compute the state based on the current\n           * state in the conversation.\n           */\n          leap_state = conversation_state->leap_state;\n\n          /* Advance the state machine. */\n          if (leap_state==0) leap_state =  1; else\n            if (leap_state==1) leap_state =  2; else\n              if (leap_state==2) leap_state =  3; else\n                if (leap_state==3) leap_state =  4; else\n                  if (leap_state==4) leap_state = -1;\n\n          /*\n           * Remember the state for subsequent accesses to this\n           * frame.\n           */\n          packet_state = wmem_new(wmem_file_scope(), frame_state_t);\n          packet_state->info = leap_state;\n          p_add_proto_data(wmem_file_scope(), pinfo, proto_eap, PROTO_DATA_EAP_FRAME_STATE | tls_group, packet_state);\n\n          /*\n           * Update the conversation's state.\n           */\n          conversation_state->leap_state = leap_state;\n        }\n\n        /* Get the remembered state. */\n        leap_state = packet_state->info;\n\n        switch (leap_state) {\n          case 1:\n            proto_tree_add_item(eap_tree, hf_eap_leap_peer_challenge, tvb, offset, count, ENC_NA);\n            break;\n\n          case 2:\n            proto_tree_add_item(eap_tree, hf_eap_leap_peer_response, tvb, offset, count, ENC_NA);\n            break;\n\n          case 3:\n            proto_tree_add_item(eap_tree, hf_eap_leap_ap_challenge, tvb, offset, count, ENC_NA);\n            break;\n\n          case 4:\n            proto_tree_add_item(eap_tree, hf_eap_leap_ap_response, tvb, offset, count, ENC_NA);\n            break;\n\n          default:\n            proto_tree_add_item(eap_tree, hf_eap_leap_data, tvb, offset, count, ENC_NA);\n            break;\n        }\n\n        offset += count;\n\n        /* Name    (Length-(8+Count)) */\n        namesize = eap_len - (8+count);\n        proto_tree_add_item(eap_tree, hf_eap_leap_name, tvb, offset, namesize, ENC_ASCII);\n      }\n\n      break; /* EAP_TYPE_LEAP */\n\n      /*********************************************************************\n            EAP-MSCHAPv2 - draft-kamath-pppext-eap-mschapv2-00.txt\n      **********************************************************************/\n      case EAP_TYPE_MSCHAPV2:\n        dissect_eap_mschapv2(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_MSCHAPV2 */\n\n        /*********************************************************************\n           EAP-SIM - draft-haverinen-pppext-eap-sim-13.txt\n        **********************************************************************/\n      case EAP_TYPE_SIM:\n        dissect_eap_sim(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_SIM */\n\n        /*********************************************************************\n            EAP-AKA - draft-arkko-pppext-eap-aka-12.txt\n        **********************************************************************/\n      case EAP_TYPE_AKA:\n      case EAP_TYPE_AKA_PRIME:\n        dissect_eap_aka(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_AKA */\n\n        /*********************************************************************\n            EAP Expanded Type\n        **********************************************************************/\n      case EAP_TYPE_EXT:\n      {\n        proto_tree *exptree;\n\n        exptree   = proto_tree_add_subtree(eap_tree, tvb, offset, size, ett_eap_exp_attr, NULL, \"Expanded Type\");\n        dissect_exteap(exptree, tvb, offset, size, pinfo, eap_code, eap_identifier);\n      }\n      break;\n\n      /*********************************************************************\n            EAP-PAX - RFC 4746\n      **********************************************************************/\n      case EAP_TYPE_PAX:\n        dissect_eap_pax(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_PAX */\n\n      /*********************************************************************\n            EAP-PSK - RFC 4764\n      **********************************************************************/\n      case EAP_TYPE_PSK:\n        dissect_eap_psk(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_PSK */\n\n      /*********************************************************************\n            EAP-SAKE - RFC 4763\n      **********************************************************************/\n      case EAP_TYPE_SAKE:\n        dissect_eap_sake(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_SAKE */\n\n      /*********************************************************************\n            EAP-GPSK - RFC 5433\n      **********************************************************************/\n      case EAP_TYPE_GPSK:\n        dissect_eap_gpsk(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_GPSK */\n\n      /*********************************************************************\n            EAP-IKEv2 - RFC 5106\n      **********************************************************************/\n      case EAP_TYPE_IKEV2:\n      {\n        gboolean more_fragments;\n        gboolean has_length;\n        gboolean icv_present;\n\n        /* Flags field, 1 byte */\n        ti = proto_tree_add_item(eap_tree, hf_eap_ikev2_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n        eap_tls_flags_tree = proto_item_add_subtree(ti, hf_eap_ikev2_flags);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_ikev2_flag_l, tvb, offset, 1, ENC_BIG_ENDIAN, &has_length);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_ikev2_flag_m, tvb, offset, 1, ENC_BIG_ENDIAN, &more_fragments);\n        proto_tree_add_item_ret_boolean(eap_tls_flags_tree, hf_eap_ikev2_flag_i, tvb, offset, 1, ENC_BIG_ENDIAN, &icv_present);\n\n        size -= 1;\n        offset += 1;\n\n        /* Length field, 4 bytes, OPTIONAL. */\n        if (has_length) {\n          proto_tree_add_item(eap_tree, hf_eap_ikev2_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n          size -= 4;\n          offset += 4;\n        }\n\n        if (size > 0) {\n          tvbuff_t* next_tvb = NULL;\n          gint      tvb_len;\n\n          tvb_len = tvb_captured_length_remaining(tvb, offset);\n          if (size < tvb_len) {\n            tvb_len = size;\n          }\n\n          if (has_length || more_fragments) {\n            /* TODO: Add fragmentation support\n             * Length of integrity check data needs to be determined in case of fragmentation. Chosen INTEG transform?\n             */\n          } else {\n            next_tvb = tvb_new_subset_length_caplen(tvb, offset, tvb_len, size);\n            guint tmp = call_dissector(isakmp_handle, next_tvb, pinfo, eap_tree);\n            size -= tmp;\n            offset += tmp;\n\n            if (icv_present && size > 0) {\n              /* We assume that all data present is integrity check data. We cannot detect too short/long right now. */\n              proto_tree_add_item(eap_tree, hf_eap_ikev2_int_chk_data, tvb, offset, size, ENC_NA);\n            }\n          }\n        }\n\n        break;\n      } /* EAP_TYPE_IKEV2 */\n\n      /*********************************************************************\n            MS-Authentication-TLV - MS-PEAP section 2.2.8.1\n      **********************************************************************/\n      case EAP_TYPE_MSAUTH_TLV:\n        dissect_eap_msauth_tlv(eap_tree, tvb, pinfo, offset, size);\n        break; /* EAP_TYPE_MSAUTH_TLV */\n\n      /*********************************************************************\n      **********************************************************************/\n      default:\n        proto_tree_add_item(eap_tree, hf_eap_data, tvb, offset, size, ENC_NA);\n        break;\n        /*********************************************************************\n        **********************************************************************/\n      } /* switch (eap_type) */\n\n    }\n\n  } /* switch (eap_code) */\n\n  return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,6 @@\n   static address null_address = ADDRESS_INIT_NONE;\n   static guint8 pae_group_address_mac_addr[6] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x03 };\n   static address pae_group_address = ADDRESS_INIT(AT_ETHER, sizeof(pae_group_address_mac_addr), pae_group_address_mac_addr);\n-  packet_info    pinfo_eapol;\n-  packet_info    *pinfo_conv;\n \n   col_set_str(pinfo->cinfo, COL_PROTOCOL, \"EAP\");\n   col_clear(pinfo->cinfo, COL_INFO);\n@@ -54,19 +52,11 @@\n    * We set the port so the TLS decoder can figure out which side is the server\n    */\n   if (pinfo->src.type == AT_ETHER) {\n-    memcpy(&pinfo_eapol, pinfo, sizeof(packet_info));\n-    pinfo_conv = &pinfo_eapol;\n     if (eap_code == EAP_REQUEST) {\t/* server -> client */\n-      copy_address_shallow(&pinfo_conv->src, &null_address);\n-      copy_address_shallow(&pinfo_conv->dst, &pae_group_address);\n-      pinfo_conv->srcport = 443;\n+      conversation_set_conv_addr_port_endpoints(pinfo, &null_address, &pae_group_address, conversation_pt_to_conversation_type(pinfo->ptype), 443, pinfo->destport);\n     } else {\t\t\t\t/* client -> server */\n-      copy_address_shallow(&pinfo_conv->src, &pae_group_address);\n-      copy_address_shallow(&pinfo_conv->dst, &null_address);\n-      pinfo_conv->destport = 443;\n+      conversation_set_conv_addr_port_endpoints(pinfo, &pae_group_address, &null_address, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport, 443);\n     }\n-  } else {\n-    pinfo_conv = pinfo;\n   }\n \n   /*\n@@ -75,20 +65,20 @@\n    * as offsets for p_get_proto_data/p_add_proto_data and as done for\n    * EAPOL above we massage the client port using this too\n    */\n-  guint32 tls_group = pinfo_conv->curr_proto_layer_num << 16;\n+  guint32 tls_group = pinfo->curr_proto_layer_num << 16;\n   if (eap_code == EAP_REQUEST) {\t/* server -> client */\n-    pinfo_conv->destport |= tls_group;\n+    conversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport, pinfo->destport | tls_group);\n   } else {\t\t\t\t/* client -> server */\n-    pinfo_conv->srcport |= tls_group;\n+    conversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport | tls_group, pinfo->destport);\n   }\n \n-  if (PINFO_FD_VISITED(pinfo_conv) || !(eap_code == EAP_REQUEST && tvb_get_guint8(tvb, 4) == EAP_TYPE_ID)) {\n-    conversation = find_conversation_pinfo(pinfo_conv, 0);\n+  if (PINFO_FD_VISITED(pinfo) || !(eap_code == EAP_REQUEST && tvb_get_guint8(tvb, 4) == EAP_TYPE_ID)) {\n+    conversation = find_conversation_pinfo(pinfo, 0);\n   }\n   if (conversation == NULL) {\n-    conversation = conversation_new(pinfo_conv->num, &pinfo_conv->src,\n-\t\t      &pinfo_conv->dst, conversation_pt_to_conversation_type(pinfo_conv->ptype),\n-\t\t      pinfo_conv->srcport, pinfo_conv->destport, 0);\n+    conversation = conversation_new(pinfo->num, &pinfo->src,\n+\t\t      &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype),\n+\t\t      pinfo->srcport, pinfo->destport, 0);\n   }\n \n   /*\n@@ -503,23 +493,23 @@\n           if (next_tvb) {\n             switch (eap_type) {\n               case EAP_TYPE_TTLS:\n-                tls_set_appdata_dissector(tls_handle, pinfo_conv, diameter_avps_handle);\n+                tls_set_appdata_dissector(tls_handle, pinfo, diameter_avps_handle);\n                 break;\n               case EAP_TYPE_PEAP:\n                 p_add_proto_data(pinfo->pool, pinfo, proto_eap, PROTO_DATA_EAP_TVB | tls_group, tvb);\n-                tls_set_appdata_dissector(tls_handle, pinfo_conv, peap_handle);\n+                tls_set_appdata_dissector(tls_handle, pinfo, peap_handle);\n                 break;\n               case EAP_TYPE_TEAP:\n                 if (outer_tlvs) {\t/* https://www.rfc-editor.org/rfc/rfc7170.html#section-4.1 */\n                   tvbuff_t *teap_tvb = tvb_new_subset_length(tvb, offset + size - outer_tlvs_length, outer_tlvs_length);\n-                  call_dissector(teap_handle, teap_tvb, pinfo_conv, eap_tree);\n+                  call_dissector(teap_handle, teap_tvb, pinfo, eap_tree);\n                   if (size == outer_tlvs_length) goto skip_tls_dissector;\n                   next_tvb = tvb_new_subset_length(next_tvb, 0, size - outer_tlvs_length);\n                 }\n-                tls_set_appdata_dissector(tls_handle, pinfo_conv, teap_handle);\n+                tls_set_appdata_dissector(tls_handle, pinfo, teap_handle);\n                 break;\n             }\n-            call_dissector(tls_handle, next_tvb, pinfo_conv, eap_tree);\n+            call_dissector(tls_handle, next_tvb, pinfo, eap_tree);\n           }\n         }\n       }",
        "diff_line_info": {
            "deleted_lines": [
                "  packet_info    pinfo_eapol;",
                "  packet_info    *pinfo_conv;",
                "    memcpy(&pinfo_eapol, pinfo, sizeof(packet_info));",
                "    pinfo_conv = &pinfo_eapol;",
                "      copy_address_shallow(&pinfo_conv->src, &null_address);",
                "      copy_address_shallow(&pinfo_conv->dst, &pae_group_address);",
                "      pinfo_conv->srcport = 443;",
                "      copy_address_shallow(&pinfo_conv->src, &pae_group_address);",
                "      copy_address_shallow(&pinfo_conv->dst, &null_address);",
                "      pinfo_conv->destport = 443;",
                "  } else {",
                "    pinfo_conv = pinfo;",
                "  guint32 tls_group = pinfo_conv->curr_proto_layer_num << 16;",
                "    pinfo_conv->destport |= tls_group;",
                "    pinfo_conv->srcport |= tls_group;",
                "  if (PINFO_FD_VISITED(pinfo_conv) || !(eap_code == EAP_REQUEST && tvb_get_guint8(tvb, 4) == EAP_TYPE_ID)) {",
                "    conversation = find_conversation_pinfo(pinfo_conv, 0);",
                "    conversation = conversation_new(pinfo_conv->num, &pinfo_conv->src,",
                "\t\t      &pinfo_conv->dst, conversation_pt_to_conversation_type(pinfo_conv->ptype),",
                "\t\t      pinfo_conv->srcport, pinfo_conv->destport, 0);",
                "                tls_set_appdata_dissector(tls_handle, pinfo_conv, diameter_avps_handle);",
                "                tls_set_appdata_dissector(tls_handle, pinfo_conv, peap_handle);",
                "                  call_dissector(teap_handle, teap_tvb, pinfo_conv, eap_tree);",
                "                tls_set_appdata_dissector(tls_handle, pinfo_conv, teap_handle);",
                "            call_dissector(tls_handle, next_tvb, pinfo_conv, eap_tree);"
            ],
            "added_lines": [
                "      conversation_set_conv_addr_port_endpoints(pinfo, &null_address, &pae_group_address, conversation_pt_to_conversation_type(pinfo->ptype), 443, pinfo->destport);",
                "      conversation_set_conv_addr_port_endpoints(pinfo, &pae_group_address, &null_address, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport, 443);",
                "  guint32 tls_group = pinfo->curr_proto_layer_num << 16;",
                "    conversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport, pinfo->destport | tls_group);",
                "    conversation_set_conv_addr_port_endpoints(pinfo, &pinfo->src, &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype), pinfo->srcport | tls_group, pinfo->destport);",
                "  if (PINFO_FD_VISITED(pinfo) || !(eap_code == EAP_REQUEST && tvb_get_guint8(tvb, 4) == EAP_TYPE_ID)) {",
                "    conversation = find_conversation_pinfo(pinfo, 0);",
                "    conversation = conversation_new(pinfo->num, &pinfo->src,",
                "\t\t      &pinfo->dst, conversation_pt_to_conversation_type(pinfo->ptype),",
                "\t\t      pinfo->srcport, pinfo->destport, 0);",
                "                tls_set_appdata_dissector(tls_handle, pinfo, diameter_avps_handle);",
                "                tls_set_appdata_dissector(tls_handle, pinfo, peap_handle);",
                "                  call_dissector(teap_handle, teap_tvb, pinfo, eap_tree);",
                "                tls_set_appdata_dissector(tls_handle, pinfo, teap_handle);",
                "            call_dissector(tls_handle, next_tvb, pinfo, eap_tree);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0415",
        "func_name": "wireshark/proto_register_iscsi",
        "description": "iSCSI dissector crash in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/1e1e733d8cae8e6f6b6f463160061896cb1daed2",
        "commit_title": "iSCSI: Handle invalid opcodes inside Reject message",
        "commit_text": " Allow dissect_iscsi_pdu to handle iSCSI messages with invalid opcodes, so that it does not crash when receiving them in Reject messages.  Fix #18796 ",
        "func_before": "void\nproto_register_iscsi(void)\n{\n    module_t *iscsi_module;\n    expert_module_t* expert_iscsi;\n\n    /* Setup list of header fields  See Section 1.6.1 for details*/\n    static hf_register_info hf[] = {\n        { &hf_iscsi_request_frame,\n          { \"Request in\", \"iscsi.request_frame\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0,\n            \"The request to this transaction is in this frame\", HFILL }},\n\n        { &hf_iscsi_time,\n          { \"Time from request\", \"iscsi.time\",\n            FT_RELATIVE_TIME, BASE_NONE, NULL, 0,\n            \"Time between the Command and the Response\", HFILL }},\n\n        { &hf_iscsi_data_in_frame,\n          { \"Data In in\", \"iscsi.data_in_frame\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0,\n            \"The Data In for this transaction is in this frame\", HFILL }},\n\n        { &hf_iscsi_data_out_frame,\n          { \"Data Out in\", \"iscsi.data_out_frame\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0,\n            \"The Data Out for this transaction is in this frame\", HFILL }},\n\n        { &hf_iscsi_response_frame,\n          { \"Response in\", \"iscsi.response_frame\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0,\n            \"The response to this transaction is in this frame\", HFILL }},\n        { &hf_iscsi_AHS_length,\n          { \"AHS Length\", \"iscsi.ahs.length\",\n            FT_UINT16, BASE_DEC, NULL, 0,\n            \"Length of Additional header segment\", HFILL }\n        },\n        { &hf_iscsi_AHS_read_data_length,\n          { \"Bidirectional Read Data Length\", \"iscsi.ahs.bidir.length\",\n            FT_UINT32, BASE_DEC, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_AHS_type,\n          { \"AHS Type\", \"iscsi.ahs.type\",\n            FT_UINT8, BASE_DEC, VALS(ahs_type_vals), 0,\n            \"Type of Additional header segment\", HFILL }\n        },\n        { &hf_iscsi_AHS_extended_cdb,\n          { \"AHS Extended CDB\", \"iscsi.ahs.extended_cdb\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_AHS_blob,\n          { \"Unknown AHS blob\", \"iscsi.ahs.unknown_blob\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_Padding,\n          { \"Padding\", \"iscsi.padding\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Padding to 4 byte boundary\", HFILL }\n        },\n        { &hf_iscsi_ping_data,\n          { \"PingData\", \"iscsi.pingdata\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Ping Data\", HFILL }\n        },\n        { &hf_iscsi_immediate_data,\n          { \"ImmediateData\", \"iscsi.immediatedata\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Immediate Data\", HFILL }\n        },\n        { &hf_iscsi_async_event_data,\n          { \"AsyncEventData\", \"iscsi.asynceventdata\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Async Event Data\", HFILL }\n        },\n        { &hf_iscsi_vendor_specific_data,\n          { \"VendorSpecificData\", \"iscsi.vendorspecificdata\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Vendor Specific Data\", HFILL }\n        },\n        { &hf_iscsi_HeaderDigest32,\n          { \"HeaderDigest\", \"iscsi.headerdigest32\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Header Digest\", HFILL }\n        },\n        { &hf_iscsi_DataDigest32,\n          { \"DataDigest\", \"iscsi.datadigest32\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Data Digest\", HFILL }\n        },\n        { &hf_iscsi_Opcode,\n          { \"Opcode\", \"iscsi.opcode\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_opcodes), 0,\n            NULL, HFILL }\n        },\n/* #ifdef DRAFT08 */\n        { &hf_iscsi_X,\n          { \"X\", \"iscsi.X\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_X), 0x80,\n            \"Command Retry\", HFILL }\n        },\n/* #endif */\n        { &hf_iscsi_I,\n          { \"I\", \"iscsi.I\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_I), 0x40,\n            \"Immediate delivery\", HFILL }\n        },\n        { &hf_iscsi_Flags,\n          { \"Flags\", \"iscsi.flags\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Opcode specific flags\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_F,\n          { \"F\", \"iscsi.scsicommand.F\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80,\n            \"PDU completes command\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_R,\n          { \"R\", \"iscsi.scsicommand.R\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_R), 0x40,\n            \"Command reads from SCSI target\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_W,\n          { \"W\", \"iscsi.scsicommand.W\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_W), 0x20,\n            \"Command writes to SCSI target\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_Attr,\n          { \"Attr\", \"iscsi.scsicommand.attr\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_scsicommand_taskattrs), 0x07,\n            \"SCSI task attributes\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_CRN,\n          { \"CRN\", \"iscsi.scsicommand.crn\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"SCSI command reference number\", HFILL }\n        },\n        { &hf_iscsi_DataSegmentLength,\n          { \"DataSegmentLength\", \"iscsi.datasegmentlength\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Data segment length (bytes)\", HFILL }\n        },\n        { &hf_iscsi_TotalAHSLength,\n          { \"TotalAHSLength\", \"iscsi.totalahslength\",\n            FT_UINT8, BASE_DEC_HEX, NULL, 0,\n            \"Total additional header segment length (4 byte words)\", HFILL }\n        },\n        { &hf_iscsi_InitiatorTaskTag,\n          { \"InitiatorTaskTag\", \"iscsi.initiatortasktag\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Initiator's task tag\", HFILL }\n        },\n        { &hf_iscsi_ExpectedDataTransferLength,\n          { \"ExpectedDataTransferLength\", \"iscsi.scsicommand.expecteddatatransferlength\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Expected length of data transfer\", HFILL }\n        },\n        { &hf_iscsi_CmdSN,\n          { \"CmdSN\", \"iscsi.cmdsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Sequence number for this command\", HFILL }\n        },\n        { &hf_iscsi_ExpStatSN,\n          { \"ExpStatSN\", \"iscsi.expstatsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Next expected status sequence number\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_ResidualCount,\n          { \"ResidualCount\", \"iscsi.scsiresponse.residualcount\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Residual count\", HFILL }\n        },\n        { &hf_iscsi_StatSN,\n          { \"StatSN\", \"iscsi.statsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Status sequence number\", HFILL }\n        },\n        { &hf_iscsi_ExpCmdSN,\n          { \"ExpCmdSN\", \"iscsi.expcmdsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Next expected command sequence number\", HFILL }\n        },\n        { &hf_iscsi_MaxCmdSN,\n          { \"MaxCmdSN\", \"iscsi.maxcmdsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Maximum acceptable command sequence number\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_o,\n          { \"o\", \"iscsi.scsiresponse.o\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_o), 0x10,\n            \"Bi-directional read residual overflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_u,\n          { \"u\", \"iscsi.scsiresponse.u\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_u), 0x08,\n            \"Bi-directional read residual underflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_O,\n          { \"O\", \"iscsi.scsiresponse.O\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_O), 0x04,\n            \"Residual overflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_U,\n          { \"U\", \"iscsi.scsiresponse.U\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_U), 0x02,\n            \"Residual underflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_Status,\n          { \"Status\", \"iscsi.scsiresponse.status\",\n            FT_UINT8, BASE_HEX, VALS(scsi_status_val), 0,\n            \"SCSI command status value\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_Response,\n          { \"Response\", \"iscsi.scsiresponse.response\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_scsi_responses), 0,\n            \"SCSI command response value\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_BidiReadResidualCount,\n          { \"BidiReadResidualCount\", \"iscsi.scsiresponse.bidireadresidualcount\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Bi-directional read residual count\", HFILL }\n        },\n        { &hf_iscsi_SenseLength,\n          { \"SenseLength\", \"iscsi.scsiresponse.senselength\",\n            FT_UINT16, BASE_DEC_HEX, NULL, 0,\n            \"Sense data length\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_F,\n          { \"F\", \"iscsi.scsidata.F\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), ISCSI_SCSI_DATA_FLAG_F,\n            \"Final PDU\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_A,\n          { \"A\", \"iscsi.scsidata.A\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_A), ISCSI_SCSI_DATA_FLAG_A,\n            \"Acknowledge Requested\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_S,\n          { \"S\", \"iscsi.scsidata.S\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_S), ISCSI_SCSI_DATA_FLAG_S,\n            \"PDU Contains SCSI command status\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_U,\n          { \"U\", \"iscsi.scsidata.U\",\n            FT_BOOLEAN, 8,  TFS(&iscsi_meaning_U), ISCSI_SCSI_DATA_FLAG_U,\n            \"Residual underflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_O,\n          { \"O\", \"iscsi.scsidata.O\",\n            FT_BOOLEAN, 8,  TFS(&iscsi_meaning_O), ISCSI_SCSI_DATA_FLAG_O,\n            \"Residual overflow\", HFILL }\n        },\n        { &hf_iscsi_TargetTransferTag,\n          { \"TargetTransferTag\", \"iscsi.targettransfertag\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Target transfer tag\", HFILL }\n        },\n        { &hf_iscsi_BufferOffset,\n          { \"BufferOffset\", \"iscsi.bufferOffset\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Buffer offset\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_ResidualCount,\n          { \"ResidualCount\", \"iscsi.scsidata.readresidualcount\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Residual count\", HFILL }\n        },\n        { &hf_iscsi_DataSN,\n          { \"DataSN\", \"iscsi.datasn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Data sequence number\", HFILL }\n        },\n        { &hf_iscsi_VersionMax,\n          { \"VersionMax\", \"iscsi.versionmax\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Maximum supported protocol version\", HFILL }\n        },\n        { &hf_iscsi_VersionMin,\n          { \"VersionMin\", \"iscsi.versionmin\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Minimum supported protocol version\", HFILL }\n        },\n        { &hf_iscsi_VersionActive,\n          { \"VersionActive\", \"iscsi.versionactive\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Negotiated protocol version\", HFILL }\n        },\n        { &hf_iscsi_CID,\n          { \"CID\", \"iscsi.cid\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Connection identifier\", HFILL }\n        },\n/* #ifdef DRAFT08 */\n        { &hf_iscsi_ISID8,\n          { \"ISID\", \"iscsi.isid8\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier\", HFILL }\n        },\n/* #else */\n        { &hf_iscsi_ISID,\n          { \"ISID\", \"iscsi.isid\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Initiator part of session identifier\", HFILL }\n        },\n/* #ifdef DRAFT09 */\n        { &hf_iscsi_ISID_Type,\n          { \"ISID_Type\", \"iscsi.isid.type\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0,\n            \"Initiator part of session identifier - type\", HFILL }\n        },\n        { &hf_iscsi_ISID_NamingAuthority,\n          { \"ISID_NamingAuthority\", \"iscsi.isid.namingauthority\",\n            FT_UINT24, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - naming authority\", HFILL }\n        },\n        { &hf_iscsi_ISID_Qualifier,\n          { \"ISID_Qualifier\", \"iscsi.isid.qualifier\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - qualifier\", HFILL }\n        },\n/* #else */\n        { &hf_iscsi_ISID_t,\n          { \"ISID_t\", \"iscsi.isid.t\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0xc0,\n            \"Initiator part of session identifier - t\", HFILL }\n        },\n        { &hf_iscsi_ISID_a,\n          { \"ISID_a\", \"iscsi.isid.a\",\n            FT_UINT8, BASE_HEX, NULL, 0x3f,\n            \"Initiator part of session identifier - a\", HFILL }\n        },\n        { &hf_iscsi_ISID_b,\n          { \"ISID_b\", \"iscsi.isid.b\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - b\", HFILL }\n        },\n        { &hf_iscsi_ISID_c,\n          { \"ISID_c\", \"iscsi.isid.c\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - c\", HFILL }\n        },\n        { &hf_iscsi_ISID_d,\n          { \"ISID_d\", \"iscsi.isid.d\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - d\", HFILL }\n        },\n/* #endif */\n/* #endif */\n        { &hf_iscsi_TSID,\n          { \"TSID\", \"iscsi.tsid\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Target part of session identifier\", HFILL }\n        },\n        { &hf_iscsi_TSIH,\n          { \"TSIH\", \"iscsi.tsih\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Target session identifying handle\", HFILL }\n        },\n        { &hf_iscsi_Login_T,\n          { \"T\", \"iscsi.login.T\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_T), 0x80,\n            \"Transit to next login stage\",  HFILL }\n        },\n        { &hf_iscsi_Login_C,\n          { \"C\", \"iscsi.login.C\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40,\n            \"Text incomplete\",  HFILL }\n        },\n/* #ifdef DRAFT09 */\n        { &hf_iscsi_Login_X,\n          { \"X\", \"iscsi.login.X\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_login_X), 0x40,\n            \"Restart Connection\",  HFILL }\n        },\n/* #endif */\n        { &hf_iscsi_Login_CSG,\n          { \"CSG\", \"iscsi.login.csg\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_login_stage), CSG_MASK,\n            \"Current stage\",  HFILL }\n        },\n        { &hf_iscsi_Login_NSG,\n          { \"NSG\", \"iscsi.login.nsg\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_login_stage), NSG_MASK,\n            \"Next stage\",  HFILL }\n        },\n        { &hf_iscsi_Login_Status,\n          { \"Status\", \"iscsi.login.status\",\n            FT_UINT16, BASE_HEX, VALS(iscsi_login_status), 0,\n            \"Status class and detail\", HFILL }\n        },\n        { &hf_iscsi_KeyValue,\n          { \"KeyValue\", \"iscsi.keyvalue\",\n            FT_STRING, BASE_NONE, NULL, 0,\n            \"Key/value pair\", HFILL }\n        },\n        { &hf_iscsi_Text_F,\n          { \"F\", \"iscsi.text.F\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80,\n            \"Final PDU in text sequence\", HFILL }\n        },\n        { &hf_iscsi_Text_C,\n          { \"C\", \"iscsi.text.C\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40,\n            \"Text incomplete\", HFILL }\n        },\n        { &hf_iscsi_ExpDataSN,\n          { \"ExpDataSN\", \"iscsi.expdatasn\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Next expected data sequence number\", HFILL }\n        },\n        { &hf_iscsi_R2TSN,\n          { \"R2TSN\", \"iscsi.r2tsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"R2T PDU Number\", HFILL }\n        },\n        { &hf_iscsi_TaskManagementFunction_Response,\n          { \"Response\", \"iscsi.taskmanfun.response\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_task_management_responses), 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_TaskManagementFunction_ReferencedTaskTag,\n          { \"ReferencedTaskTag\", \"iscsi.taskmanfun.referencedtasktag\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Referenced task tag\", HFILL }\n        },\n        { &hf_iscsi_RefCmdSN,\n          { \"RefCmdSN\", \"iscsi.refcmdsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Command sequence number for command to be aborted\", HFILL }\n        },\n        { &hf_iscsi_TaskManagementFunction_Function,\n          { \"Function\", \"iscsi.taskmanfun.function\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_task_management_functions), 0x7F,\n            \"Requested task function\", HFILL }\n        },\n        { &hf_iscsi_Logout_Reason,\n          { \"Reason\", \"iscsi.logout.reason\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_logout_reasons), 0x7F,\n            \"Reason for logout\", HFILL }\n        },\n        { &hf_iscsi_Logout_Response,\n          { \"Response\", \"iscsi.logout.response\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_logout_response), 0,\n            \"Logout response\", HFILL }\n        },\n        { &hf_iscsi_Time2Wait,\n          { \"Time2Wait\", \"iscsi.time2wait\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_Time2Retain,\n          { \"Time2Retain\", \"iscsi.time2retain\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_DesiredDataLength,\n          { \"DesiredDataLength\", \"iscsi.desireddatalength\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Desired data length (bytes)\", HFILL }\n        },\n        { &hf_iscsi_AsyncEvent,\n          { \"AsyncEvent\", \"iscsi.asyncevent\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_asyncevents), 0,\n            \"Async event type\", HFILL }\n        },\n        { &hf_iscsi_EventVendorCode,\n          { \"EventVendorCode\", \"iscsi.eventvendorcode\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Event vendor code\", HFILL }\n        },\n        { &hf_iscsi_Parameter1,\n          { \"Parameter1\", \"iscsi.parameter1\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Parameter 1\", HFILL }\n        },\n        { &hf_iscsi_Parameter2,\n          { \"Parameter2\", \"iscsi.parameter2\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Parameter 2\", HFILL }\n        },\n        { &hf_iscsi_Parameter3,\n          { \"Parameter3\", \"iscsi.parameter3\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Parameter 3\", HFILL }\n        },\n        { &hf_iscsi_Reject_Reason,\n          { \"Reason\", \"iscsi.reject.reason\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_reject_reasons), 0,\n            \"Reason for command rejection\", HFILL }\n        },\n        { &hf_iscsi_snack_type,\n          { \"S\", \"iscsi.snack.type\",\n            FT_UINT8, BASE_DEC, VALS(iscsi_snack_types), 0x0f,\n            \"Type of SNACK requested\", HFILL }\n        },\n        { &hf_iscsi_BegRun,\n          { \"BegRun\", \"iscsi.snack.begrun\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"First missed DataSN or StatSN\", HFILL }\n        },\n        { &hf_iscsi_RunLength,\n          { \"RunLength\", \"iscsi.snack.runlength\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Number of additional missing status PDUs in this run\", HFILL }\n        },\n    };\n\n    /* Setup protocol subtree array */\n    static gint *ett[] = {\n        &ett_iscsi,\n        &ett_iscsi_KeyValues,\n        &ett_iscsi_CDB,\n        &ett_iscsi_Flags,\n        &ett_iscsi_RejectHeader,\n        &ett_iscsi_lun,\n/* #ifndef DRAFT08 */\n        &ett_iscsi_ISID,\n/* #endif */\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_iscsi_keyvalue_invalid, { \"iscsi.keyvalue.invalid\", PI_MALFORMED, PI_ERROR,\n            \"Invalid key/value pair\", EXPFILL }}\n    };\n\n    /* Register the protocol name and description */\n    proto_iscsi = proto_register_protocol(\"iSCSI\", \"iSCSI\", \"iscsi\");\n    iscsi_handle = register_dissector(\"iscsi\", dissect_iscsi_handle, proto_iscsi);\n\n    /* Required function calls to register the header fields and\n     * subtrees used */\n    proto_register_field_array(proto_iscsi, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    iscsi_module = prefs_register_protocol(proto_iscsi, NULL);\n\n    prefs_register_enum_preference(iscsi_module,\n                                   \"protocol_version\",\n                                   \"Protocol version\",\n                                   \"The iSCSI protocol version\",\n                                   &iscsi_protocol_version,\n                                   iscsi_protocol_versions,\n                                   FALSE);\n\n    prefs_register_bool_preference(iscsi_module,\n                                   \"desegment_iscsi_messages\",\n                                   \"Reassemble iSCSI messages spanning multiple TCP segments\",\n                                   \"Whether the iSCSI dissector should reassemble messages spanning multiple TCP segments.\"\n                                   \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\",\n                                   &iscsi_desegment);\n\n    prefs_register_bool_preference(iscsi_module,\n                                   \"bogus_pdu_filter\",\n                                   \"Enable bogus pdu filter\",\n                                   \"When enabled, packets that appear bogus are ignored\",\n                                   &enable_bogosity_filter);\n\n    prefs_register_bool_preference(iscsi_module,\n                                   \"demand_good_f_bit\",\n                                   \"Ignore packets with bad F bit\",\n                                   \"Ignore packets that haven't set the F bit when they should have\",\n                                   &demand_good_f_bit);\n\n    prefs_register_uint_preference(iscsi_module,\n                                   \"bogus_pdu_max_data_len\",\n                                   \"Bogus pdu max data length threshold\",\n                                   \"Treat packets whose data segment length is greater than this value as bogus\",\n                                   10,\n                                   &bogus_pdu_data_length_threshold);\n\n    range_convert_str(wmem_epan_scope(), &global_iscsi_port_range, TCP_PORT_ISCSI_RANGE, MAX_TCP_PORT);\n    prefs_register_range_preference(iscsi_module,\n                                    \"target_ports\",\n                                    \"Target Ports Range\",\n                                    \"Range of iSCSI target ports\"\n                                    \"(default \" TCP_PORT_ISCSI_RANGE \")\",\n                                    &global_iscsi_port_range, MAX_TCP_PORT);\n\n    prefs_register_uint_preference(iscsi_module,\n                                   \"target_system_port\",\n                                   \"Target system port\",\n                                   \"System port number of iSCSI target\",\n                                   10,\n                                   &iscsi_system_port);\n\n    /* Preference supported in older versions.\n       Register them as obsolete. */\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"version_03_compatible\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"bogus_pdu_max_digest_padding\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"header_digest_is_crc32c\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"header_digest_size\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"enable_header_digests\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"data_digest_is_crc32c\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"data_digest_size\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"enable_data_digests\");\n\n    expert_iscsi = expert_register_protocol(proto_iscsi);\n    expert_register_field_array(expert_iscsi, ei, array_length(ei));\n}",
        "func": "void\nproto_register_iscsi(void)\n{\n    module_t *iscsi_module;\n    expert_module_t* expert_iscsi;\n\n    /* Setup list of header fields  See Section 1.6.1 for details*/\n    static hf_register_info hf[] = {\n        { &hf_iscsi_request_frame,\n          { \"Request in\", \"iscsi.request_frame\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0,\n            \"The request to this transaction is in this frame\", HFILL }},\n\n        { &hf_iscsi_time,\n          { \"Time from request\", \"iscsi.time\",\n            FT_RELATIVE_TIME, BASE_NONE, NULL, 0,\n            \"Time between the Command and the Response\", HFILL }},\n\n        { &hf_iscsi_data_in_frame,\n          { \"Data In in\", \"iscsi.data_in_frame\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0,\n            \"The Data In for this transaction is in this frame\", HFILL }},\n\n        { &hf_iscsi_data_out_frame,\n          { \"Data Out in\", \"iscsi.data_out_frame\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0,\n            \"The Data Out for this transaction is in this frame\", HFILL }},\n\n        { &hf_iscsi_response_frame,\n          { \"Response in\", \"iscsi.response_frame\",\n            FT_FRAMENUM, BASE_NONE, NULL, 0,\n            \"The response to this transaction is in this frame\", HFILL }},\n        { &hf_iscsi_AHS_length,\n          { \"AHS Length\", \"iscsi.ahs.length\",\n            FT_UINT16, BASE_DEC, NULL, 0,\n            \"Length of Additional header segment\", HFILL }\n        },\n        { &hf_iscsi_AHS_read_data_length,\n          { \"Bidirectional Read Data Length\", \"iscsi.ahs.bidir.length\",\n            FT_UINT32, BASE_DEC, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_AHS_type,\n          { \"AHS Type\", \"iscsi.ahs.type\",\n            FT_UINT8, BASE_DEC, VALS(ahs_type_vals), 0,\n            \"Type of Additional header segment\", HFILL }\n        },\n        { &hf_iscsi_AHS_extended_cdb,\n          { \"AHS Extended CDB\", \"iscsi.ahs.extended_cdb\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_AHS_blob,\n          { \"Unknown AHS blob\", \"iscsi.ahs.unknown_blob\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_Padding,\n          { \"Padding\", \"iscsi.padding\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Padding to 4 byte boundary\", HFILL }\n        },\n        { &hf_iscsi_ping_data,\n          { \"PingData\", \"iscsi.pingdata\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Ping Data\", HFILL }\n        },\n        { &hf_iscsi_immediate_data,\n          { \"ImmediateData\", \"iscsi.immediatedata\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Immediate Data\", HFILL }\n        },\n        { &hf_iscsi_async_event_data,\n          { \"AsyncEventData\", \"iscsi.asynceventdata\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Async Event Data\", HFILL }\n        },\n        { &hf_iscsi_vendor_specific_data,\n          { \"VendorSpecificData\", \"iscsi.vendorspecificdata\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Vendor Specific Data\", HFILL }\n        },\n        { &hf_iscsi_HeaderDigest32,\n          { \"HeaderDigest\", \"iscsi.headerdigest32\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Header Digest\", HFILL }\n        },\n        { &hf_iscsi_DataDigest32,\n          { \"DataDigest\", \"iscsi.datadigest32\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Data Digest\", HFILL }\n        },\n        { &hf_iscsi_Opcode,\n          { \"Opcode\", \"iscsi.opcode\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_opcodes), OPCODE_MASK,\n            NULL, HFILL }\n        },\n/* #ifdef DRAFT08 */\n        { &hf_iscsi_X,\n          { \"X\", \"iscsi.X\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_X), 0x80,\n            \"Command Retry\", HFILL }\n        },\n/* #endif */\n        { &hf_iscsi_I,\n          { \"I\", \"iscsi.I\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_I), 0x40,\n            \"Immediate delivery\", HFILL }\n        },\n        { &hf_iscsi_Flags,\n          { \"Flags\", \"iscsi.flags\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Opcode specific flags\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_F,\n          { \"F\", \"iscsi.scsicommand.F\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80,\n            \"PDU completes command\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_R,\n          { \"R\", \"iscsi.scsicommand.R\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_R), 0x40,\n            \"Command reads from SCSI target\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_W,\n          { \"W\", \"iscsi.scsicommand.W\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_W), 0x20,\n            \"Command writes to SCSI target\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_Attr,\n          { \"Attr\", \"iscsi.scsicommand.attr\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_scsicommand_taskattrs), 0x07,\n            \"SCSI task attributes\", HFILL }\n        },\n        { &hf_iscsi_SCSICommand_CRN,\n          { \"CRN\", \"iscsi.scsicommand.crn\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"SCSI command reference number\", HFILL }\n        },\n        { &hf_iscsi_DataSegmentLength,\n          { \"DataSegmentLength\", \"iscsi.datasegmentlength\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Data segment length (bytes)\", HFILL }\n        },\n        { &hf_iscsi_TotalAHSLength,\n          { \"TotalAHSLength\", \"iscsi.totalahslength\",\n            FT_UINT8, BASE_DEC_HEX, NULL, 0,\n            \"Total additional header segment length (4 byte words)\", HFILL }\n        },\n        { &hf_iscsi_InitiatorTaskTag,\n          { \"InitiatorTaskTag\", \"iscsi.initiatortasktag\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Initiator's task tag\", HFILL }\n        },\n        { &hf_iscsi_ExpectedDataTransferLength,\n          { \"ExpectedDataTransferLength\", \"iscsi.scsicommand.expecteddatatransferlength\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Expected length of data transfer\", HFILL }\n        },\n        { &hf_iscsi_CmdSN,\n          { \"CmdSN\", \"iscsi.cmdsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Sequence number for this command\", HFILL }\n        },\n        { &hf_iscsi_ExpStatSN,\n          { \"ExpStatSN\", \"iscsi.expstatsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Next expected status sequence number\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_ResidualCount,\n          { \"ResidualCount\", \"iscsi.scsiresponse.residualcount\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Residual count\", HFILL }\n        },\n        { &hf_iscsi_StatSN,\n          { \"StatSN\", \"iscsi.statsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Status sequence number\", HFILL }\n        },\n        { &hf_iscsi_ExpCmdSN,\n          { \"ExpCmdSN\", \"iscsi.expcmdsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Next expected command sequence number\", HFILL }\n        },\n        { &hf_iscsi_MaxCmdSN,\n          { \"MaxCmdSN\", \"iscsi.maxcmdsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Maximum acceptable command sequence number\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_o,\n          { \"o\", \"iscsi.scsiresponse.o\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_o), 0x10,\n            \"Bi-directional read residual overflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_u,\n          { \"u\", \"iscsi.scsiresponse.u\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_u), 0x08,\n            \"Bi-directional read residual underflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_O,\n          { \"O\", \"iscsi.scsiresponse.O\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_O), 0x04,\n            \"Residual overflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_U,\n          { \"U\", \"iscsi.scsiresponse.U\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_U), 0x02,\n            \"Residual underflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_Status,\n          { \"Status\", \"iscsi.scsiresponse.status\",\n            FT_UINT8, BASE_HEX, VALS(scsi_status_val), 0,\n            \"SCSI command status value\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_Response,\n          { \"Response\", \"iscsi.scsiresponse.response\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_scsi_responses), 0,\n            \"SCSI command response value\", HFILL }\n        },\n        { &hf_iscsi_SCSIResponse_BidiReadResidualCount,\n          { \"BidiReadResidualCount\", \"iscsi.scsiresponse.bidireadresidualcount\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Bi-directional read residual count\", HFILL }\n        },\n        { &hf_iscsi_SenseLength,\n          { \"SenseLength\", \"iscsi.scsiresponse.senselength\",\n            FT_UINT16, BASE_DEC_HEX, NULL, 0,\n            \"Sense data length\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_F,\n          { \"F\", \"iscsi.scsidata.F\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), ISCSI_SCSI_DATA_FLAG_F,\n            \"Final PDU\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_A,\n          { \"A\", \"iscsi.scsidata.A\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_A), ISCSI_SCSI_DATA_FLAG_A,\n            \"Acknowledge Requested\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_S,\n          { \"S\", \"iscsi.scsidata.S\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_S), ISCSI_SCSI_DATA_FLAG_S,\n            \"PDU Contains SCSI command status\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_U,\n          { \"U\", \"iscsi.scsidata.U\",\n            FT_BOOLEAN, 8,  TFS(&iscsi_meaning_U), ISCSI_SCSI_DATA_FLAG_U,\n            \"Residual underflow\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_O,\n          { \"O\", \"iscsi.scsidata.O\",\n            FT_BOOLEAN, 8,  TFS(&iscsi_meaning_O), ISCSI_SCSI_DATA_FLAG_O,\n            \"Residual overflow\", HFILL }\n        },\n        { &hf_iscsi_TargetTransferTag,\n          { \"TargetTransferTag\", \"iscsi.targettransfertag\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Target transfer tag\", HFILL }\n        },\n        { &hf_iscsi_BufferOffset,\n          { \"BufferOffset\", \"iscsi.bufferOffset\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Buffer offset\", HFILL }\n        },\n        { &hf_iscsi_SCSIData_ResidualCount,\n          { \"ResidualCount\", \"iscsi.scsidata.readresidualcount\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Residual count\", HFILL }\n        },\n        { &hf_iscsi_DataSN,\n          { \"DataSN\", \"iscsi.datasn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Data sequence number\", HFILL }\n        },\n        { &hf_iscsi_VersionMax,\n          { \"VersionMax\", \"iscsi.versionmax\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Maximum supported protocol version\", HFILL }\n        },\n        { &hf_iscsi_VersionMin,\n          { \"VersionMin\", \"iscsi.versionmin\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Minimum supported protocol version\", HFILL }\n        },\n        { &hf_iscsi_VersionActive,\n          { \"VersionActive\", \"iscsi.versionactive\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Negotiated protocol version\", HFILL }\n        },\n        { &hf_iscsi_CID,\n          { \"CID\", \"iscsi.cid\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Connection identifier\", HFILL }\n        },\n/* #ifdef DRAFT08 */\n        { &hf_iscsi_ISID8,\n          { \"ISID\", \"iscsi.isid8\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier\", HFILL }\n        },\n/* #else */\n        { &hf_iscsi_ISID,\n          { \"ISID\", \"iscsi.isid\",\n            FT_BYTES, BASE_NONE, NULL, 0,\n            \"Initiator part of session identifier\", HFILL }\n        },\n/* #ifdef DRAFT09 */\n        { &hf_iscsi_ISID_Type,\n          { \"ISID_Type\", \"iscsi.isid.type\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0,\n            \"Initiator part of session identifier - type\", HFILL }\n        },\n        { &hf_iscsi_ISID_NamingAuthority,\n          { \"ISID_NamingAuthority\", \"iscsi.isid.namingauthority\",\n            FT_UINT24, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - naming authority\", HFILL }\n        },\n        { &hf_iscsi_ISID_Qualifier,\n          { \"ISID_Qualifier\", \"iscsi.isid.qualifier\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - qualifier\", HFILL }\n        },\n/* #else */\n        { &hf_iscsi_ISID_t,\n          { \"ISID_t\", \"iscsi.isid.t\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0xc0,\n            \"Initiator part of session identifier - t\", HFILL }\n        },\n        { &hf_iscsi_ISID_a,\n          { \"ISID_a\", \"iscsi.isid.a\",\n            FT_UINT8, BASE_HEX, NULL, 0x3f,\n            \"Initiator part of session identifier - a\", HFILL }\n        },\n        { &hf_iscsi_ISID_b,\n          { \"ISID_b\", \"iscsi.isid.b\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - b\", HFILL }\n        },\n        { &hf_iscsi_ISID_c,\n          { \"ISID_c\", \"iscsi.isid.c\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - c\", HFILL }\n        },\n        { &hf_iscsi_ISID_d,\n          { \"ISID_d\", \"iscsi.isid.d\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Initiator part of session identifier - d\", HFILL }\n        },\n/* #endif */\n/* #endif */\n        { &hf_iscsi_TSID,\n          { \"TSID\", \"iscsi.tsid\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Target part of session identifier\", HFILL }\n        },\n        { &hf_iscsi_TSIH,\n          { \"TSIH\", \"iscsi.tsih\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Target session identifying handle\", HFILL }\n        },\n        { &hf_iscsi_Login_T,\n          { \"T\", \"iscsi.login.T\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_T), 0x80,\n            \"Transit to next login stage\",  HFILL }\n        },\n        { &hf_iscsi_Login_C,\n          { \"C\", \"iscsi.login.C\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40,\n            \"Text incomplete\",  HFILL }\n        },\n/* #ifdef DRAFT09 */\n        { &hf_iscsi_Login_X,\n          { \"X\", \"iscsi.login.X\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_login_X), 0x40,\n            \"Restart Connection\",  HFILL }\n        },\n/* #endif */\n        { &hf_iscsi_Login_CSG,\n          { \"CSG\", \"iscsi.login.csg\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_login_stage), CSG_MASK,\n            \"Current stage\",  HFILL }\n        },\n        { &hf_iscsi_Login_NSG,\n          { \"NSG\", \"iscsi.login.nsg\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_login_stage), NSG_MASK,\n            \"Next stage\",  HFILL }\n        },\n        { &hf_iscsi_Login_Status,\n          { \"Status\", \"iscsi.login.status\",\n            FT_UINT16, BASE_HEX, VALS(iscsi_login_status), 0,\n            \"Status class and detail\", HFILL }\n        },\n        { &hf_iscsi_KeyValue,\n          { \"KeyValue\", \"iscsi.keyvalue\",\n            FT_STRING, BASE_NONE, NULL, 0,\n            \"Key/value pair\", HFILL }\n        },\n        { &hf_iscsi_Text_F,\n          { \"F\", \"iscsi.text.F\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80,\n            \"Final PDU in text sequence\", HFILL }\n        },\n        { &hf_iscsi_Text_C,\n          { \"C\", \"iscsi.text.C\",\n            FT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40,\n            \"Text incomplete\", HFILL }\n        },\n        { &hf_iscsi_ExpDataSN,\n          { \"ExpDataSN\", \"iscsi.expdatasn\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Next expected data sequence number\", HFILL }\n        },\n        { &hf_iscsi_R2TSN,\n          { \"R2TSN\", \"iscsi.r2tsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"R2T PDU Number\", HFILL }\n        },\n        { &hf_iscsi_TaskManagementFunction_Response,\n          { \"Response\", \"iscsi.taskmanfun.response\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_task_management_responses), 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_TaskManagementFunction_ReferencedTaskTag,\n          { \"ReferencedTaskTag\", \"iscsi.taskmanfun.referencedtasktag\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"Referenced task tag\", HFILL }\n        },\n        { &hf_iscsi_RefCmdSN,\n          { \"RefCmdSN\", \"iscsi.refcmdsn\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Command sequence number for command to be aborted\", HFILL }\n        },\n        { &hf_iscsi_TaskManagementFunction_Function,\n          { \"Function\", \"iscsi.taskmanfun.function\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_task_management_functions), 0x7F,\n            \"Requested task function\", HFILL }\n        },\n        { &hf_iscsi_Logout_Reason,\n          { \"Reason\", \"iscsi.logout.reason\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_logout_reasons), 0x7F,\n            \"Reason for logout\", HFILL }\n        },\n        { &hf_iscsi_Logout_Response,\n          { \"Response\", \"iscsi.logout.response\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_logout_response), 0,\n            \"Logout response\", HFILL }\n        },\n        { &hf_iscsi_Time2Wait,\n          { \"Time2Wait\", \"iscsi.time2wait\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_Time2Retain,\n          { \"Time2Retain\", \"iscsi.time2retain\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            NULL, HFILL }\n        },\n        { &hf_iscsi_DesiredDataLength,\n          { \"DesiredDataLength\", \"iscsi.desireddatalength\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Desired data length (bytes)\", HFILL }\n        },\n        { &hf_iscsi_AsyncEvent,\n          { \"AsyncEvent\", \"iscsi.asyncevent\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_asyncevents), 0,\n            \"Async event type\", HFILL }\n        },\n        { &hf_iscsi_EventVendorCode,\n          { \"EventVendorCode\", \"iscsi.eventvendorcode\",\n            FT_UINT8, BASE_HEX, NULL, 0,\n            \"Event vendor code\", HFILL }\n        },\n        { &hf_iscsi_Parameter1,\n          { \"Parameter1\", \"iscsi.parameter1\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Parameter 1\", HFILL }\n        },\n        { &hf_iscsi_Parameter2,\n          { \"Parameter2\", \"iscsi.parameter2\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Parameter 2\", HFILL }\n        },\n        { &hf_iscsi_Parameter3,\n          { \"Parameter3\", \"iscsi.parameter3\",\n            FT_UINT16, BASE_HEX, NULL, 0,\n            \"Parameter 3\", HFILL }\n        },\n        { &hf_iscsi_Reject_Reason,\n          { \"Reason\", \"iscsi.reject.reason\",\n            FT_UINT8, BASE_HEX, VALS(iscsi_reject_reasons), 0,\n            \"Reason for command rejection\", HFILL }\n        },\n        { &hf_iscsi_snack_type,\n          { \"S\", \"iscsi.snack.type\",\n            FT_UINT8, BASE_DEC, VALS(iscsi_snack_types), 0x0f,\n            \"Type of SNACK requested\", HFILL }\n        },\n        { &hf_iscsi_BegRun,\n          { \"BegRun\", \"iscsi.snack.begrun\",\n            FT_UINT32, BASE_HEX, NULL, 0,\n            \"First missed DataSN or StatSN\", HFILL }\n        },\n        { &hf_iscsi_RunLength,\n          { \"RunLength\", \"iscsi.snack.runlength\",\n            FT_UINT32, BASE_DEC_HEX, NULL, 0,\n            \"Number of additional missing status PDUs in this run\", HFILL }\n        },\n    };\n\n    /* Setup protocol subtree array */\n    static gint *ett[] = {\n        &ett_iscsi,\n        &ett_iscsi_KeyValues,\n        &ett_iscsi_CDB,\n        &ett_iscsi_Flags,\n        &ett_iscsi_RejectHeader,\n        &ett_iscsi_lun,\n/* #ifndef DRAFT08 */\n        &ett_iscsi_ISID,\n/* #endif */\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_iscsi_keyvalue_invalid, { \"iscsi.keyvalue.invalid\", PI_MALFORMED, PI_ERROR,\n            \"Invalid key/value pair\", EXPFILL }},\n        { &ei_iscsi_opcode_invalid, { \"iscsi.opcode.invalid\", PI_MALFORMED, PI_ERROR,\n            \"Invalid opcode\", EXPFILL }},\n    };\n\n    /* Register the protocol name and description */\n    proto_iscsi = proto_register_protocol(\"iSCSI\", \"iSCSI\", \"iscsi\");\n    iscsi_handle = register_dissector(\"iscsi\", dissect_iscsi_handle, proto_iscsi);\n\n    /* Required function calls to register the header fields and\n     * subtrees used */\n    proto_register_field_array(proto_iscsi, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    iscsi_module = prefs_register_protocol(proto_iscsi, NULL);\n\n    prefs_register_enum_preference(iscsi_module,\n                                   \"protocol_version\",\n                                   \"Protocol version\",\n                                   \"The iSCSI protocol version\",\n                                   &iscsi_protocol_version,\n                                   iscsi_protocol_versions,\n                                   FALSE);\n\n    prefs_register_bool_preference(iscsi_module,\n                                   \"desegment_iscsi_messages\",\n                                   \"Reassemble iSCSI messages spanning multiple TCP segments\",\n                                   \"Whether the iSCSI dissector should reassemble messages spanning multiple TCP segments.\"\n                                   \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\",\n                                   &iscsi_desegment);\n\n    prefs_register_bool_preference(iscsi_module,\n                                   \"bogus_pdu_filter\",\n                                   \"Enable bogus pdu filter\",\n                                   \"When enabled, packets that appear bogus are ignored\",\n                                   &enable_bogosity_filter);\n\n    prefs_register_bool_preference(iscsi_module,\n                                   \"demand_good_f_bit\",\n                                   \"Ignore packets with bad F bit\",\n                                   \"Ignore packets that haven't set the F bit when they should have\",\n                                   &demand_good_f_bit);\n\n    prefs_register_uint_preference(iscsi_module,\n                                   \"bogus_pdu_max_data_len\",\n                                   \"Bogus pdu max data length threshold\",\n                                   \"Treat packets whose data segment length is greater than this value as bogus\",\n                                   10,\n                                   &bogus_pdu_data_length_threshold);\n\n    range_convert_str(wmem_epan_scope(), &global_iscsi_port_range, TCP_PORT_ISCSI_RANGE, MAX_TCP_PORT);\n    prefs_register_range_preference(iscsi_module,\n                                    \"target_ports\",\n                                    \"Target Ports Range\",\n                                    \"Range of iSCSI target ports\"\n                                    \"(default \" TCP_PORT_ISCSI_RANGE \")\",\n                                    &global_iscsi_port_range, MAX_TCP_PORT);\n\n    prefs_register_uint_preference(iscsi_module,\n                                   \"target_system_port\",\n                                   \"Target system port\",\n                                   \"System port number of iSCSI target\",\n                                   10,\n                                   &iscsi_system_port);\n\n    /* Preference supported in older versions.\n       Register them as obsolete. */\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"version_03_compatible\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"bogus_pdu_max_digest_padding\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"header_digest_is_crc32c\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"header_digest_size\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"enable_header_digests\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"data_digest_is_crc32c\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"data_digest_size\");\n    prefs_register_obsolete_preference(iscsi_module,\n                                       \"enable_data_digests\");\n\n    expert_iscsi = expert_register_protocol(proto_iscsi);\n    expert_register_field_array(expert_iscsi, ei, array_length(ei));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -92,7 +92,7 @@\n         },\n         { &hf_iscsi_Opcode,\n           { \"Opcode\", \"iscsi.opcode\",\n-            FT_UINT8, BASE_HEX, VALS(iscsi_opcodes), 0,\n+            FT_UINT8, BASE_HEX, VALS(iscsi_opcodes), OPCODE_MASK,\n             NULL, HFILL }\n         },\n /* #ifdef DRAFT08 */\n@@ -522,7 +522,9 @@\n \n     static ei_register_info ei[] = {\n         { &ei_iscsi_keyvalue_invalid, { \"iscsi.keyvalue.invalid\", PI_MALFORMED, PI_ERROR,\n-            \"Invalid key/value pair\", EXPFILL }}\n+            \"Invalid key/value pair\", EXPFILL }},\n+        { &ei_iscsi_opcode_invalid, { \"iscsi.opcode.invalid\", PI_MALFORMED, PI_ERROR,\n+            \"Invalid opcode\", EXPFILL }},\n     };\n \n     /* Register the protocol name and description */",
        "diff_line_info": {
            "deleted_lines": [
                "            FT_UINT8, BASE_HEX, VALS(iscsi_opcodes), 0,",
                "            \"Invalid key/value pair\", EXPFILL }}"
            ],
            "added_lines": [
                "            FT_UINT8, BASE_HEX, VALS(iscsi_opcodes), OPCODE_MASK,",
                "            \"Invalid key/value pair\", EXPFILL }},",
                "        { &ei_iscsi_opcode_invalid, { \"iscsi.opcode.invalid\", PI_MALFORMED, PI_ERROR,",
                "            \"Invalid opcode\", EXPFILL }},"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0415",
        "func_name": "wireshark/dissect_iscsi",
        "description": "iSCSI dissector crash in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/1e1e733d8cae8e6f6b6f463160061896cb1daed2",
        "commit_title": "iSCSI: Handle invalid opcodes inside Reject message",
        "commit_text": " Allow dissect_iscsi_pdu to handle iSCSI messages with invalid opcodes, so that it does not crash when receiving them in Reject messages.  Fix #18796 ",
        "func_before": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        const char *opcode_str = NULL;\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        opcode_str = try_val_to_str(opcode, iscsi_opcodes);\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if(opcode_str == NULL) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, opcode_str, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if (!try_val_to_str(opcode, iscsi_opcodes)) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -538,7 +538,6 @@\n \n     /* process multiple iSCSI PDUs per packet */\n     while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n-        const char *opcode_str = NULL;\n         guint32 data_segment_len;\n         guint32 pduLen = 48;\n         guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n@@ -550,7 +549,6 @@\n         opcode = tvb_get_guint8(tvb, offset + 0);\n         opcode &= OPCODE_MASK;\n \n-        opcode_str = try_val_to_str(opcode, iscsi_opcodes);\n         if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n            opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n            opcode == ISCSI_OPCODE_R2T ||\n@@ -561,7 +559,7 @@\n         else\n             data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n \n-        if(opcode_str == NULL) {\n+        if (!try_val_to_str(opcode, iscsi_opcodes)) {\n             badPdu = TRUE;\n         }\n \n@@ -761,7 +759,7 @@\n         else\n             col_append_str(pinfo->cinfo, COL_INFO, \", \");\n \n-        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, opcode_str, data_segment_len, iscsi_session, conversation);\n+        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, data_segment_len, iscsi_session, conversation);\n         if(pduLen > available_bytes)\n             pduLen = available_bytes;\n         offset += pduLen;",
        "diff_line_info": {
            "deleted_lines": [
                "        const char *opcode_str = NULL;",
                "        opcode_str = try_val_to_str(opcode, iscsi_opcodes);",
                "        if(opcode_str == NULL) {",
                "        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, opcode_str, data_segment_len, iscsi_session, conversation);"
            ],
            "added_lines": [
                "        if (!try_val_to_str(opcode, iscsi_opcodes)) {",
                "        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, data_segment_len, iscsi_session, conversation);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0416",
        "func_name": "wireshark/dissect_geonw",
        "description": "GNW dissector crash in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/693dc40936a9eeac0e1c10ff496b3d327e25642b",
        "commit_title": "GNW: Ensure that tvbuff proto data has the proper scope.",
        "commit_text": " Add security tvbuffs to our proto data using pinfo->pool. Fixes #18779. ",
        "func_before": "static int\ndissect_geonw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    guint8 bh_next_header;\n    guint32 ch_next_header;\n    guint32 header_type;\n    guint32 rhl;\n    guint32 tmp_val;\n    gint offset = 0;\n    proto_item *ti;\n    proto_item *top_item;\n    gint hdr_len = 0;\n    guint32 payload_len = 0;\n    guint32 reserved;\n    guint32 timestamp;\n    guint32 sequence_number = SN_MAX + 1;\n    struct geonwheader *geonwh;\n    gint32 latlon;\n\n    geonwh = wmem_new0(pinfo->pool, struct geonwheader);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"GEONW\");\n    /* Clear out stuff in the info column */\n    col_clear(pinfo->cinfo,COL_INFO);\n\n    bh_next_header = tvb_get_guint8(tvb, 0) & 0x0f;\n    header_type = tvb_get_guint8(tvb, 5);\n\n    if (bh_next_header == BH_NH_SECURED_PKT) {\n        hdr_len = BH_LEN;\n    }\n    else {\n        hdr_len = BH_LEN + CH_LEN;\n        switch(header_type & HT_MASK) {\n            case HT_BEACON:\n                hdr_len += BEACON_LEN;\n                break;\n            case HT_GEOUNICAST:\n                hdr_len += GUC_LEN;\n                break;\n            case HT_GEOANYCAST:\n                hdr_len += GAC_LEN;\n                break;\n            case HT_GEOBROADCAST:\n                hdr_len += GBC_LEN;\n                break;\n            case HT_TSB:\n                hdr_len += TSB_LEN;\n                break;\n            case HT_LS:\n                hdr_len += LS_REQUEST_LEN;\n                if (header_type == HTST_LS_REPLY) {\n                    hdr_len += (LS_REPLY_LEN - LS_REQUEST_LEN);\n                }\n                break;\n            default:\n                hdr_len = -1;\n        }\n    }\n    top_item = proto_tree_add_item(tree, proto_geonw, tvb, 0, hdr_len, ENC_NA);\n    proto_tree *geonw_tree = proto_item_add_subtree(top_item, ett_geonw);\n\n    // Basic Header subtree\n    ti = proto_tree_add_item(geonw_tree, hf_geonw_bh, tvb, 0, 4, ENC_NA);\n    proto_tree *geonw_bh_tree = proto_item_add_subtree(ti, ett_geonw_bh);\n\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_version, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n    geonwh->gnw_ver = tmp_val;\n    // Shall be 0 or 1\n    if (tmp_val > 1) {\n        col_add_fstr(pinfo->cinfo, COL_INFO,\n                     \"Bogus GeoNetworking version (%u, must be less than 2)\", tmp_val);\n        expert_add_info_format(pinfo, ti, &ei_geonw_version_err, \"Bogus GeoNetworking version\");\n        return tvb_captured_length(tvb);\n    }\n    proto_tree_add_item(geonw_bh_tree, hf_geonw_bh_next_header, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    // Reserved byte\n    // Expert info if not zero?\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_reserved, tvb, offset, 1, ENC_NA, &reserved);\n    if (reserved) {\n        expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n    }\n    offset += 1;\n\n    // Subtree and lt_mult and lt_base\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_life_time, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n    geonwh->gnw_lt = tmp_val;\n    proto_tree *geonw_bh_lt_tree = proto_item_add_subtree(ti, ett_geonw_bh_lt);\n\n    proto_tree_add_item(geonw_bh_lt_tree, hf_geonw_bh_lt_mult, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(geonw_bh_lt_tree, hf_geonw_bh_lt_base, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    proto_item *rhl_ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_remain_hop_limit, tvb, offset, 1, ENC_BIG_ENDIAN, &rhl);\n    geonwh->gnw_rhl = rhl;\n    /*\n     * Flag a low RHL if the next header is not a common header\n     */\n    if (rhl < 5 && bh_next_header != BH_NH_COMMON_HDR) {\n        expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_too_low, \"\\\"Remain Hop Limit\\\" only %u\", rhl);\n    }\n    offset += 1;\n\n    if (bh_next_header == BH_NH_SECURED_PKT) {\n        dissect_secured_message(tvb, offset, pinfo, geonw_tree, NULL);\n        tvbuff_t *next_tvb = (tvbuff_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0);\n        if (next_tvb) {\n            tvb = next_tvb;\n            bh_next_header = BH_NH_COMMON_HDR;\n            offset = 0;\n            header_type = tvb_get_guint8(tvb, 1);\n\n            hdr_len = CH_LEN;\n            switch(header_type & HT_MASK) {\n                case HT_BEACON:\n                    hdr_len += BEACON_LEN;\n                    break;\n                case HT_GEOUNICAST:\n                    hdr_len += GUC_LEN;\n                    break;\n                case HT_GEOANYCAST:\n                    hdr_len += GAC_LEN;\n                    break;\n                case HT_GEOBROADCAST:\n                    hdr_len += GBC_LEN;\n                    break;\n                case HT_TSB:\n                    hdr_len += TSB_LEN;\n                    break;\n                case HT_LS:\n                    hdr_len += LS_REQUEST_LEN;\n                    if (header_type == HTST_LS_REPLY) {\n                        hdr_len += (LS_REPLY_LEN - LS_REQUEST_LEN);\n                    }\n                    break;\n                default:\n                    hdr_len = -1;\n            }\n            p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, NULL);\n        }\n    }\n\n    if (bh_next_header == BH_NH_COMMON_HDR) {\n        // Common Header subtree\n        ti = proto_tree_add_item(geonw_tree, hf_geonw_ch, tvb, offset, 8, ENC_NA);\n        proto_tree *geonw_ch_tree = proto_item_add_subtree(ti, ett_geonw_ch);\n\n        // Next Header\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_next_header, tvb, offset, 1, ENC_BIG_ENDIAN, &ch_next_header);\n        geonwh->gnw_proto = ch_next_header;\n        // Reserved\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_reserved1, tvb, offset, 1, ENC_NA, &reserved);\n        if (reserved) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // HT\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_header_type, tvb, offset, 1, ENC_BIG_ENDIAN, &header_type);\n        geonwh->gnw_htype = header_type;\n        col_add_str(pinfo->cinfo, COL_INFO, val_to_str(header_type, ch_header_type_names, \"Unknown (%u)\"));\n        offset += 1;\n\n        /* Now that we know the header type, lets add expert info on RHL\n         * RHL shall be\n         *  = 1 if parameter Packet transport type in the service primitive\n         *    GN-DATA.request is SHB, or if Header type HT = 1 (BEACON)\n         *  = Value of optional Maximum hop limit parameter from service\n         *    primitive GN-DATA.request\n         *  = Otherwise GN protocol constant itsGnDefaultHopLimit if\n         *    GN-DATA.request parameter Packet transport type is GUC, GBC, GBC\n         *    or TSB\n         * Flag a low RHL if the packet is not BEACON or SHB.\n         */\n        if (header_type == HTST_BEACON || header_type == HTST_TSB_SINGLE) {\n            if (rhl > 1) {\n                expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_lncb, \"\\\"Remain Hop Limit\\\" != 1 for BEACON or SHB (%u)\", rhl);\n            }\n        } else if (rhl < 5) {\n            expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_too_low, \"\\\"Remain Hop Limit\\\" only %u\", rhl);\n        }\n\n        // TC\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_traffic_class, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_tc = tmp_val;\n        proto_tree *geonw_ch_tc_tree = proto_item_add_subtree(ti, ett_geonw_ch_tc);\n\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_scf, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_offload, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        ti = proto_tree_add_item(geonw_ch_tree, hf_geonw_ch_flags, tvb, offset, 1, ENC_NA);\n        proto_tree *geonw_ch_flag_tree = proto_item_add_subtree(ti, ett_geonw_ch_tc);\n        // Flag (itsGnIsMobile)\n        proto_tree_add_item_ret_uint(geonw_ch_flag_tree, hf_geonw_ch_flags_mob, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_flags = tmp_val;\n        ti = proto_tree_add_item_ret_uint(geonw_ch_flag_tree, hf_geonw_ch_flags_reserved, tvb, offset, 1, ENC_BIG_ENDIAN, &reserved);\n        if (reserved & 0x7f) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // PL (16 bits)\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_payload_length, tvb, offset, 2, ENC_BIG_ENDIAN, &payload_len);\n        geonwh->gnw_len = payload_len;\n        if (hdr_len > 0) { // We know the length of the header\n            if (payload_len) {\n                if (((header_type & HT_MASK) == HT_LS) || (header_type == HT_BEACON)) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                else if ((payload_len + (unsigned) hdr_len) > tvb_reported_length(tvb)) {\n                    expert_add_info(pinfo, ti, &ei_geonw_payload_len);\n                }\n                else {\n                    /*\n                     * Now that we know that the total length of this GNW datagram isn't\n                     * obviously bogus, adjust the length of this tvbuff to include only\n                     * the GNW datagram.\n                     */\n                    set_actual_length(tvb, hdr_len + payload_len);\n                }\n            }\n            else {\n                set_actual_length(tvb, hdr_len);\n            }\n        }\n        offset += 2;\n\n        // MHL\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_max_hop_limit, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_mhl = tmp_val;\n        // Expert mhl < rhl: packet will be ignored\n        if (tmp_val < rhl) {\n            expert_add_info_format(pinfo, rhl_ti, &ei_geonw_mhl_lt_rhl, \"Ignored: \\\"Remain Hop Limit\\\" > %u (mhl)\", tmp_val);\n        }\n        offset += 1;\n\n        // Reserved...\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_reserved2, tvb, offset, 1, ENC_NA, &reserved);\n        // Expert info if not zero\n        if (reserved) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // Stop here if header_type unknown\n        if (!IS_HT_KNOWN(header_type)) {\n            // Update top level tree item\n            proto_item_set_end(top_item, tvb, offset);\n            return tvb_reported_length(tvb);\n        }\n\n        geonwh->gnw_sn = SN_MAX+1;\n\n        proto_tree *geonw_sh_tree;\n        switch(header_type & HT_MASK) {\n            case HT_BEACON:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_beacon, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOUNICAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_guc, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOANYCAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_gac, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOBROADCAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_gbc, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_TSB:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_tsb, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_LS:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_ls, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            default:\n                // Exit if header_type unknown?\n                return tvb_captured_length(tvb);\n        }\n        geonw_sh_tree = proto_item_add_subtree(ti, ett_geonw_sh);\n\n        switch(header_type) {\n            case HTST_GEOUNICAST:\n            case HTST_GAC_CIRCLE:\n            case HTST_GAC_RECT:\n            case HTST_GAC_ELLIPSE:\n            case HTST_GBC_CIRCLE:\n            case HTST_GBC_RECT:\n            case HTST_GBC_ELLIPSE:\n            case HTST_TSB_MULT:\n            case HTST_LS_REQUEST:\n            case HTST_LS_REPLY:\n                // Seq num\n                proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_seq_num, tvb, offset, 2, ENC_BIG_ENDIAN, &sequence_number);\n                geonwh->gnw_sn = sequence_number;\n                offset += 2;\n                // 16 bits reserved\n                ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_reserved, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                // Expert info if not zero?\n                if (reserved) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                offset += 2;\n            case HTST_TSB_SINGLE:\n            case HTST_BEACON:\n                break;\n        }\n\n        // Every packet has source address\n        ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_so_pv, tvb, offset, 24, ENC_NA);\n        proto_tree *geonw_so_tree = proto_item_add_subtree(ti, ett_geonw_so);\n\n        ti = proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_addr, tvb, offset, 8, ENC_NA);\n        proto_tree *geonw_so_add_tree = proto_item_add_subtree(ti, ett_geonw_so);\n        set_address_tvb(&pinfo->net_src, geonw_address_type, 8, tvb, offset);\n        copy_address_shallow(&pinfo->src, &pinfo->net_src);\n        copy_address_shallow(&geonwh->gnw_src, &pinfo->src);\n\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        ti = proto_tree_add_item_ret_uint(geonw_so_add_tree, hf_geonw_so_pv_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n        if (reserved > 999) {\n            expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n        }\n        offset += 2;\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_mid, tvb, offset, 6, ENC_NA);\n        offset += 6;\n\n        proto_tree_add_item_ret_uint(geonw_so_tree, hf_geonw_so_pv_time, tvb, offset, 4, ENC_BIG_ENDIAN, &timestamp);\n        geonwh->gnw_tst = timestamp;\n\n        // XXX Is it possible to \"follow\" a station when updating its GN_ADDR?\n\n        if(geonw_analyze_seq && (geonwh->gnw_ver==0) && !(pinfo->fd->visited)) {\n            // Duplication detection uses SN and TST or only TST (see Annex A of ETSI EN 302 636-4-1)\n            // We rely on address type and hashtable as this shall be done on a per station basis (i.e. not over a conversation)\n            // We do not try to consider GN_ADDR updates (due to duplicate address detection or anonymous setting)\n            hashgeonw_t *tp = (hashgeonw_t *)wmem_map_lookup(geonw_hashtable, pinfo->net_src.data);\n            if (tp == NULL) {\n                tp = geonw_hash_new_entry((const guint8 *)pinfo->net_src.data, FALSE);\n                tp->sequence_number = sequence_number;\n                tp->timestamp = timestamp;\n            } else {\n                if ((sequence_number <= SN_MAX) && (tp->sequence_number > SN_MAX)) {\n                    tp->sequence_number = sequence_number;\n                    tp->timestamp = timestamp;\n                }\n                else if (sequence_number <= SN_MAX) {\n                    /*\n                     * 1   P is the received GeoNetworking packet\n                     * 2   SN(P) is the sequence number in the received GeoNetworking packet\n                     * 3   SN(SO) is the last received sequence number from source SO\n                     * 4   SN_MAX is the maximum sequence number = 2^16 - 1\n                     * 5   TST(P) is the timestamp in the received GeoNetworking packet\n                     * 6   TST(SO) is the last received timestamp from source SO\n                     * 7   TST_MAX is the maximum value of the timestamp = 2^32 - 1\n                     * 8\n                     * 9   IF (((TST(P) > TST(SO) AND ((TST(P) - TST(SO)) <= TST_MAX/2)) OR\n                     *             ((TST(SO) > TST(P)) AND ((TST(SO) - TST(P)) > TST_MAX/2))) THEN\n                     * 10                                                  # TST(P) is greater than TST(SO)\n                     * 11      TST(SO) = TST(P)\n                     * 12      SN(SO) = SN(P)                              # P is not a duplicate packet\n                     * 13  ELSEIF TST(P) = TST(SO) THEN\n                     * 14      IF (((SN(P) > SN(SO) AND ((SN(P) - SN(SO)) <= SN_MAX/2)) OR\n                     *              ((SN(SO) > SN(P)) AND ((SN(SO) - SN(P)) > SN_MAX/2))) THEN\n                     * 15                                                  # SN(P) is greater than SN(SO)\n                     * 16          TST(SO) = TST(P)\n                     * 17          SN(SO) = SN(P)                          # P is not a duplicate packet\n                     * 18      ELSE\n                     * 19                                                  # SN(P) is not greater than SN(SO)\n                     * 20                                                  # P is a duplicate\n                     * 21      ENDIF\n                     * 22  ELSE\n                     * 23                                                  # TST(P) not greater than TST(SO)\n                     * 24  ENDIF\n                     */\n                    if (((timestamp > tp->timestamp) && (((guint64)timestamp - (guint64)tp->timestamp) <= (guint64)TST_MAX/2)) ||\n                            ((tp->timestamp > timestamp) && (((guint64)tp->timestamp - (guint64)timestamp) > (guint64)TST_MAX/2))) {\n                                                                    // TST(P) is greater than TST(SO)\n                        tp->sequence_number = sequence_number;\n                        tp->timestamp = timestamp;                  // P is not a duplicate packet\n                    } else if (timestamp == tp->timestamp) {\n                        if (((sequence_number > tp->sequence_number) && ((sequence_number - tp->sequence_number) <= SN_MAX/2)) ||\n                             ((tp->sequence_number > sequence_number) && ((tp->sequence_number - sequence_number) > SN_MAX/2))) {\n                                                                    // SN(P) is greater than SN(SO)\n                            tp->timestamp = timestamp;\n                            tp->sequence_number = sequence_number;  // P is not a duplicate packet\n                        } else {\n                                                                    // SN(P) is not greater than SN(SO)\n                                                                    // P is a duplicate\n                            ti = proto_tree_add_item(geonw_tree, hf_geonw_analysis_flags, tvb, 0, 0, ENC_NA);\n                            proto_item_set_generated(ti);\n                            expert_add_info(pinfo, ti, &ei_geonw_analysis_duplicate);\n                            col_prepend_fence_fstr(pinfo->cinfo, COL_INFO, \"[Duplicate packet] \");\n                        }\n                    } // else { # TST(P) not greater than TST(SO) }\n                }\n                else {\n                    /*\n                     * 1   P is the received GeoNetworking packet\n                     * 2   TST(P) is the timestamp in the received GeoNetworking packet\n                     * 3   TST(SO) is the last received timestamp from source SO\n                     * 4   TS_MAX is the maximum value of the timestamp = 2^32 - 1\n                     * 5\n                     * 6   IF (((TST(P) > TST(SO) AND ((TST(P) - TST(SO)) <= TST_MAX/2)) OR\n                     *             ((TST(SO) > TST(P)) AND ((TST(SO) - TST(P)) > TST_MAX/2))) THEN\n                     * 7                                       # TST(P) is greater than TST(SO)\n                     * 8       TST(SO) = TST(P)                # P is not a duplicate packet\n                     * 9   ELSE\n                     * 10                                      # P is a duplicate\n                     * 11  ENDIF\n                     */\n                    if (((timestamp > tp->timestamp) && (((guint64)timestamp - (guint64)tp->timestamp) <= (guint64)TST_MAX/2)) ||\n                            ((tp->timestamp > timestamp) && (((guint64)tp->timestamp - (guint64)timestamp) > (guint64)TST_MAX/2))) {\n                                                        // TST(P) is greater than TST(SO)\n                        tp->timestamp = timestamp;      // P is not a duplicate packet\n                    } else {\n                                                        // P is a duplicate\n                        ti = proto_tree_add_item(geonw_tree, hf_geonw_analysis_flags, tvb, 0, 0, ENC_NA);\n                        proto_item_set_generated(ti);\n                        expert_add_info(pinfo, ti, &ei_geonw_analysis_duplicate);\n                        col_prepend_fence_fstr(pinfo->cinfo, COL_INFO, \"[Duplicate packet] \");\n                    }\n                }\n            }\n        }\n        // XXX Implement DPD if version == 1\n\n        offset += 4;\n        ti = proto_tree_add_item_ret_int(geonw_so_tree, hf_geonw_so_pv_lat, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n        if (latlon < -900000000 || latlon > 900000000) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n        }\n        geonwh->gnw_lat = latlon;\n        offset += 4;\n        ti = proto_tree_add_item_ret_int(geonw_so_tree, hf_geonw_so_pv_lon, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n        if (latlon < -1800000000 || latlon > 1800000000) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n        }\n        geonwh->gnw_lon = latlon;\n        offset += 4;\n        proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_pai, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_speed, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        ti = proto_tree_add_item_ret_uint(geonw_so_tree, hf_geonw_so_pv_heading, tvb, offset, 2, ENC_BIG_ENDIAN, &tmp_val);\n        if (tmp_val > 3600) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Out of range [0..360] (%f)\", (float)tmp_val/10);\n        }\n        offset += 2;\n\n        proto_tree *geonw_de_tree = NULL;\n        proto_tree *geonw_de_add_tree = NULL;\n        switch(header_type) {\n            case HTST_GEOUNICAST:\n            case HTST_LS_REPLY:\n                // Destination address\n                ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_de_pv, tvb, offset, 20, ENC_NA);\n                geonw_de_tree = proto_item_add_subtree(ti, ett_geonw_de);\n\n                ti = proto_tree_add_item(geonw_de_tree, hf_geonw_de_pv_addr, tvb, offset, 8, ENC_NA);\n                geonw_de_add_tree = proto_item_add_subtree(ti, ett_geonw_de);\n                set_address_tvb(&pinfo->net_dst, geonw_address_type, 8, tvb, offset);\n                copy_address_shallow(&pinfo->dst, &pinfo->net_dst);\n                copy_address_shallow(&geonwh->gnw_dst, &pinfo->dst);\n\n                if (header_type == HTST_LS_REPLY) {\n                    transaction_end(pinfo, geonw_tree);\n                }\n\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                ti = proto_tree_add_item_ret_uint(geonw_de_add_tree, hf_geonw_de_pv_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved > 999) {\n                    expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n                }\n                offset += 2;\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_mid, tvb, offset, 6, ENC_NA);\n                offset += 6;\n\n                proto_tree_add_item(geonw_de_tree, hf_geonw_de_pv_time, tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_de_tree, hf_geonw_de_pv_lat, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -900000000 || latlon > 900000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_de_tree, hf_geonw_de_pv_lon, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -1800000000 || latlon > 1800000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                break;\n            case HTST_TSB_SINGLE:\n                // Reserved 32 bits\n                // See usage in 636-4 subpart 2 for ITS-5G\n                reserved = tvb_get_guint32(tvb, offset, ENC_BIG_ENDIAN);\n                if (reserved) {\n                    ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_dccmco, tvb, offset, 4, ENC_NA);\n                    proto_tree *dccmco = proto_item_add_subtree(ti, ett_geonw_dccmco);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_cbr_l_0_hop, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_cbr_l_1_hop, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_output_power, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_reserved, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_shb_reserved, tvb, offset+3, 1, ENC_BIG_ENDIAN);\n                }\n                else {\n                    proto_tree_add_item(geonw_sh_tree, hf_geonw_shb_reserved, tvb, offset, 4, ENC_BIG_ENDIAN);\n                }\n                offset += 4;\n                break;\n            case HTST_GAC_CIRCLE:\n            case HTST_GAC_RECT:\n            case HTST_GAC_ELLIPSE:\n            case HTST_GBC_CIRCLE:\n            case HTST_GBC_RECT:\n            case HTST_GBC_ELLIPSE:\n                ti = proto_tree_add_item_ret_int(geonw_sh_tree, hf_geonw_gxc_latitude, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -900000000 || latlon > 900000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_sh_tree, hf_geonw_gxc_longitude, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -1800000000 || latlon > 1800000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                switch(header_type&0x0f) {\n                    case HST_CIRCULAR:\n                        /*\n                         * According to EN 302 363-4-1:\n                         * In case of a circular area (GeoNetworking packet\n                         * sub-type HST = 0), the fields shall be set to the\n                         * following values:\n                         *  1) Distance a is set to the radius r.\n                         *  2) Distance b is set to 0.\n                         *  3) Angle is set to 0.\n                         */\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_radius, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_distanceb, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                        if (reserved) {\n                            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                        }\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_angle, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                        if (reserved) {\n                            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                        }\n                        offset += 2;\n                        break;\n                    case HST_RECTANGULAR:\n                    case HST_ELLIPSOIDAL:\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_distancea, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_distanceb, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_angle, tvb, offset, 2, ENC_BIG_ENDIAN, &tmp_val);\n                        if (tmp_val > 360) {\n                            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Out of range [0..360] (%f)\", (float)tmp_val);\n                        }\n                        offset += 2;\n                }\n                ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_reserved, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                offset += 2;\n                break;\n            case HTST_LS_REQUEST:\n                // GN_ADDR\n                ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_lsrq_addr, tvb, offset, 8, ENC_NA);\n                geonw_de_add_tree = proto_item_add_subtree(ti, ett_geonw_lsrq_add);\n                set_address_tvb(&pinfo->net_dst, geonw_address_type, 8, tvb, offset);\n                copy_address_shallow(&pinfo->dst, &pinfo->net_dst);\n\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                ti = proto_tree_add_item_ret_uint(geonw_de_add_tree, hf_geonw_lsrq_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved > 999) {\n                    expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n                }\n                offset += 2;\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_mid, tvb, offset, 6, ENC_NA);\n                offset += 6;\n                transaction_start(pinfo, geonw_tree);\n                break;\n            //case HTST_BEACON:\n            //case HTST_TSB_MULT:\n        }\n        proto_item_set_end(top_item, tvb, offset);\n\n        tap_queue_packet(geonw_tap, pinfo, geonwh);\n\n        if (payload_len) {\n            // TODO expert info if payload_len different from remaining\n            tvbuff_t *next_tvb = tvb_new_subset_length(tvb, offset, payload_len);\n            switch(ch_next_header) {\n                case CH_NH_BTP_A:\n                    call_dissector(btpa_handle, next_tvb, pinfo, tree);\n                    break;\n                case CH_NH_BTP_B:\n                    call_dissector(btpb_handle, next_tvb, pinfo, tree);\n                    break;\n                case CH_NH_IPV6:\n                    call_dissector(ipv6_handle, next_tvb, pinfo, tree);\n                    break;\n                default:\n                    if (!dissector_try_uint(geonw_subdissector_table, ch_next_header, next_tvb, pinfo, tree)) {\n                        call_data_dissector(next_tvb, pinfo, tree);\n                    }\n            }\n        }\n\n    }\n\n    return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_geonw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    guint8 bh_next_header;\n    guint32 ch_next_header;\n    guint32 header_type;\n    guint32 rhl;\n    guint32 tmp_val;\n    gint offset = 0;\n    proto_item *ti;\n    proto_item *top_item;\n    gint hdr_len = 0;\n    guint32 payload_len = 0;\n    guint32 reserved;\n    guint32 timestamp;\n    guint32 sequence_number = SN_MAX + 1;\n    struct geonwheader *geonwh;\n    gint32 latlon;\n\n    geonwh = wmem_new0(pinfo->pool, struct geonwheader);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"GEONW\");\n    /* Clear out stuff in the info column */\n    col_clear(pinfo->cinfo,COL_INFO);\n\n    bh_next_header = tvb_get_guint8(tvb, 0) & 0x0f;\n    header_type = tvb_get_guint8(tvb, 5);\n\n    if (bh_next_header == BH_NH_SECURED_PKT) {\n        hdr_len = BH_LEN;\n    }\n    else {\n        hdr_len = BH_LEN + CH_LEN;\n        switch(header_type & HT_MASK) {\n            case HT_BEACON:\n                hdr_len += BEACON_LEN;\n                break;\n            case HT_GEOUNICAST:\n                hdr_len += GUC_LEN;\n                break;\n            case HT_GEOANYCAST:\n                hdr_len += GAC_LEN;\n                break;\n            case HT_GEOBROADCAST:\n                hdr_len += GBC_LEN;\n                break;\n            case HT_TSB:\n                hdr_len += TSB_LEN;\n                break;\n            case HT_LS:\n                hdr_len += LS_REQUEST_LEN;\n                if (header_type == HTST_LS_REPLY) {\n                    hdr_len += (LS_REPLY_LEN - LS_REQUEST_LEN);\n                }\n                break;\n            default:\n                hdr_len = -1;\n        }\n    }\n    top_item = proto_tree_add_item(tree, proto_geonw, tvb, 0, hdr_len, ENC_NA);\n    proto_tree *geonw_tree = proto_item_add_subtree(top_item, ett_geonw);\n\n    // Basic Header subtree\n    ti = proto_tree_add_item(geonw_tree, hf_geonw_bh, tvb, 0, 4, ENC_NA);\n    proto_tree *geonw_bh_tree = proto_item_add_subtree(ti, ett_geonw_bh);\n\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_version, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n    geonwh->gnw_ver = tmp_val;\n    // Shall be 0 or 1\n    if (tmp_val > 1) {\n        col_add_fstr(pinfo->cinfo, COL_INFO,\n                     \"Bogus GeoNetworking version (%u, must be less than 2)\", tmp_val);\n        expert_add_info_format(pinfo, ti, &ei_geonw_version_err, \"Bogus GeoNetworking version\");\n        return tvb_captured_length(tvb);\n    }\n    proto_tree_add_item(geonw_bh_tree, hf_geonw_bh_next_header, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    // Reserved byte\n    // Expert info if not zero?\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_reserved, tvb, offset, 1, ENC_NA, &reserved);\n    if (reserved) {\n        expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n    }\n    offset += 1;\n\n    // Subtree and lt_mult and lt_base\n    ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_life_time, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n    geonwh->gnw_lt = tmp_val;\n    proto_tree *geonw_bh_lt_tree = proto_item_add_subtree(ti, ett_geonw_bh_lt);\n\n    proto_tree_add_item(geonw_bh_lt_tree, hf_geonw_bh_lt_mult, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(geonw_bh_lt_tree, hf_geonw_bh_lt_base, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    proto_item *rhl_ti = proto_tree_add_item_ret_uint(geonw_bh_tree, hf_geonw_bh_remain_hop_limit, tvb, offset, 1, ENC_BIG_ENDIAN, &rhl);\n    geonwh->gnw_rhl = rhl;\n    /*\n     * Flag a low RHL if the next header is not a common header\n     */\n    if (rhl < 5 && bh_next_header != BH_NH_COMMON_HDR) {\n        expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_too_low, \"\\\"Remain Hop Limit\\\" only %u\", rhl);\n    }\n    offset += 1;\n\n    if (bh_next_header == BH_NH_SECURED_PKT) {\n        dissect_secured_message(tvb, offset, pinfo, geonw_tree, NULL);\n        tvbuff_t *next_tvb = (tvbuff_t*)p_get_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY);\n        if (next_tvb) {\n            tvb = next_tvb;\n            bh_next_header = BH_NH_COMMON_HDR;\n            offset = 0;\n            header_type = tvb_get_guint8(tvb, 1);\n\n            hdr_len = CH_LEN;\n            switch(header_type & HT_MASK) {\n                case HT_BEACON:\n                    hdr_len += BEACON_LEN;\n                    break;\n                case HT_GEOUNICAST:\n                    hdr_len += GUC_LEN;\n                    break;\n                case HT_GEOANYCAST:\n                    hdr_len += GAC_LEN;\n                    break;\n                case HT_GEOBROADCAST:\n                    hdr_len += GBC_LEN;\n                    break;\n                case HT_TSB:\n                    hdr_len += TSB_LEN;\n                    break;\n                case HT_LS:\n                    hdr_len += LS_REQUEST_LEN;\n                    if (header_type == HTST_LS_REPLY) {\n                        hdr_len += (LS_REPLY_LEN - LS_REQUEST_LEN);\n                    }\n                    break;\n                default:\n                    hdr_len = -1;\n            }\n        }\n    }\n\n    if (bh_next_header == BH_NH_COMMON_HDR) {\n        // Common Header subtree\n        ti = proto_tree_add_item(geonw_tree, hf_geonw_ch, tvb, offset, 8, ENC_NA);\n        proto_tree *geonw_ch_tree = proto_item_add_subtree(ti, ett_geonw_ch);\n\n        // Next Header\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_next_header, tvb, offset, 1, ENC_BIG_ENDIAN, &ch_next_header);\n        geonwh->gnw_proto = ch_next_header;\n        // Reserved\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_reserved1, tvb, offset, 1, ENC_NA, &reserved);\n        if (reserved) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // HT\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_header_type, tvb, offset, 1, ENC_BIG_ENDIAN, &header_type);\n        geonwh->gnw_htype = header_type;\n        col_add_str(pinfo->cinfo, COL_INFO, val_to_str(header_type, ch_header_type_names, \"Unknown (%u)\"));\n        offset += 1;\n\n        /* Now that we know the header type, lets add expert info on RHL\n         * RHL shall be\n         *  = 1 if parameter Packet transport type in the service primitive\n         *    GN-DATA.request is SHB, or if Header type HT = 1 (BEACON)\n         *  = Value of optional Maximum hop limit parameter from service\n         *    primitive GN-DATA.request\n         *  = Otherwise GN protocol constant itsGnDefaultHopLimit if\n         *    GN-DATA.request parameter Packet transport type is GUC, GBC, GBC\n         *    or TSB\n         * Flag a low RHL if the packet is not BEACON or SHB.\n         */\n        if (header_type == HTST_BEACON || header_type == HTST_TSB_SINGLE) {\n            if (rhl > 1) {\n                expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_lncb, \"\\\"Remain Hop Limit\\\" != 1 for BEACON or SHB (%u)\", rhl);\n            }\n        } else if (rhl < 5) {\n            expert_add_info_format(pinfo, rhl_ti, &ei_geonw_rhl_too_low, \"\\\"Remain Hop Limit\\\" only %u\", rhl);\n        }\n\n        // TC\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_traffic_class, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_tc = tmp_val;\n        proto_tree *geonw_ch_tc_tree = proto_item_add_subtree(ti, ett_geonw_ch_tc);\n\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_scf, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_offload, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_ch_tc_tree, hf_geonw_ch_tc_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        ti = proto_tree_add_item(geonw_ch_tree, hf_geonw_ch_flags, tvb, offset, 1, ENC_NA);\n        proto_tree *geonw_ch_flag_tree = proto_item_add_subtree(ti, ett_geonw_ch_tc);\n        // Flag (itsGnIsMobile)\n        proto_tree_add_item_ret_uint(geonw_ch_flag_tree, hf_geonw_ch_flags_mob, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_flags = tmp_val;\n        ti = proto_tree_add_item_ret_uint(geonw_ch_flag_tree, hf_geonw_ch_flags_reserved, tvb, offset, 1, ENC_BIG_ENDIAN, &reserved);\n        if (reserved & 0x7f) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // PL (16 bits)\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_payload_length, tvb, offset, 2, ENC_BIG_ENDIAN, &payload_len);\n        geonwh->gnw_len = payload_len;\n        if (hdr_len > 0) { // We know the length of the header\n            if (payload_len) {\n                if (((header_type & HT_MASK) == HT_LS) || (header_type == HT_BEACON)) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                else if ((payload_len + (unsigned) hdr_len) > tvb_reported_length(tvb)) {\n                    expert_add_info(pinfo, ti, &ei_geonw_payload_len);\n                }\n                else {\n                    /*\n                     * Now that we know that the total length of this GNW datagram isn't\n                     * obviously bogus, adjust the length of this tvbuff to include only\n                     * the GNW datagram.\n                     */\n                    set_actual_length(tvb, hdr_len + payload_len);\n                }\n            }\n            else {\n                set_actual_length(tvb, hdr_len);\n            }\n        }\n        offset += 2;\n\n        // MHL\n        proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_max_hop_limit, tvb, offset, 1, ENC_BIG_ENDIAN, &tmp_val);\n        geonwh->gnw_mhl = tmp_val;\n        // Expert mhl < rhl: packet will be ignored\n        if (tmp_val < rhl) {\n            expert_add_info_format(pinfo, rhl_ti, &ei_geonw_mhl_lt_rhl, \"Ignored: \\\"Remain Hop Limit\\\" > %u (mhl)\", tmp_val);\n        }\n        offset += 1;\n\n        // Reserved...\n        ti = proto_tree_add_item_ret_uint(geonw_ch_tree, hf_geonw_ch_reserved2, tvb, offset, 1, ENC_NA, &reserved);\n        // Expert info if not zero\n        if (reserved) {\n            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n        }\n        offset += 1;\n\n        // Stop here if header_type unknown\n        if (!IS_HT_KNOWN(header_type)) {\n            // Update top level tree item\n            proto_item_set_end(top_item, tvb, offset);\n            return tvb_reported_length(tvb);\n        }\n\n        geonwh->gnw_sn = SN_MAX+1;\n\n        proto_tree *geonw_sh_tree;\n        switch(header_type & HT_MASK) {\n            case HT_BEACON:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_beacon, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOUNICAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_guc, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOANYCAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_gac, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_GEOBROADCAST:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_gbc, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_TSB:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_tsb, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            case HT_LS:\n                ti = proto_tree_add_item(geonw_tree, hf_geonw_ls, tvb, offset, hdr_len-offset, ENC_NA);\n                break;\n            default:\n                // Exit if header_type unknown?\n                return tvb_captured_length(tvb);\n        }\n        geonw_sh_tree = proto_item_add_subtree(ti, ett_geonw_sh);\n\n        switch(header_type) {\n            case HTST_GEOUNICAST:\n            case HTST_GAC_CIRCLE:\n            case HTST_GAC_RECT:\n            case HTST_GAC_ELLIPSE:\n            case HTST_GBC_CIRCLE:\n            case HTST_GBC_RECT:\n            case HTST_GBC_ELLIPSE:\n            case HTST_TSB_MULT:\n            case HTST_LS_REQUEST:\n            case HTST_LS_REPLY:\n                // Seq num\n                proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_seq_num, tvb, offset, 2, ENC_BIG_ENDIAN, &sequence_number);\n                geonwh->gnw_sn = sequence_number;\n                offset += 2;\n                // 16 bits reserved\n                ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_reserved, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                // Expert info if not zero?\n                if (reserved) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                offset += 2;\n            case HTST_TSB_SINGLE:\n            case HTST_BEACON:\n                break;\n        }\n\n        // Every packet has source address\n        ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_so_pv, tvb, offset, 24, ENC_NA);\n        proto_tree *geonw_so_tree = proto_item_add_subtree(ti, ett_geonw_so);\n\n        ti = proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_addr, tvb, offset, 8, ENC_NA);\n        proto_tree *geonw_so_add_tree = proto_item_add_subtree(ti, ett_geonw_so);\n        set_address_tvb(&pinfo->net_src, geonw_address_type, 8, tvb, offset);\n        copy_address_shallow(&pinfo->src, &pinfo->net_src);\n        copy_address_shallow(&geonwh->gnw_src, &pinfo->src);\n\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        ti = proto_tree_add_item_ret_uint(geonw_so_add_tree, hf_geonw_so_pv_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n        if (reserved > 999) {\n            expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n        }\n        offset += 2;\n        proto_tree_add_item(geonw_so_add_tree, hf_geonw_so_pv_addr_mid, tvb, offset, 6, ENC_NA);\n        offset += 6;\n\n        proto_tree_add_item_ret_uint(geonw_so_tree, hf_geonw_so_pv_time, tvb, offset, 4, ENC_BIG_ENDIAN, &timestamp);\n        geonwh->gnw_tst = timestamp;\n\n        // XXX Is it possible to \"follow\" a station when updating its GN_ADDR?\n\n        if(geonw_analyze_seq && (geonwh->gnw_ver==0) && !(pinfo->fd->visited)) {\n            // Duplication detection uses SN and TST or only TST (see Annex A of ETSI EN 302 636-4-1)\n            // We rely on address type and hashtable as this shall be done on a per station basis (i.e. not over a conversation)\n            // We do not try to consider GN_ADDR updates (due to duplicate address detection or anonymous setting)\n            hashgeonw_t *tp = (hashgeonw_t *)wmem_map_lookup(geonw_hashtable, pinfo->net_src.data);\n            if (tp == NULL) {\n                tp = geonw_hash_new_entry((const guint8 *)pinfo->net_src.data, FALSE);\n                tp->sequence_number = sequence_number;\n                tp->timestamp = timestamp;\n            } else {\n                if ((sequence_number <= SN_MAX) && (tp->sequence_number > SN_MAX)) {\n                    tp->sequence_number = sequence_number;\n                    tp->timestamp = timestamp;\n                }\n                else if (sequence_number <= SN_MAX) {\n                    /*\n                     * 1   P is the received GeoNetworking packet\n                     * 2   SN(P) is the sequence number in the received GeoNetworking packet\n                     * 3   SN(SO) is the last received sequence number from source SO\n                     * 4   SN_MAX is the maximum sequence number = 2^16 - 1\n                     * 5   TST(P) is the timestamp in the received GeoNetworking packet\n                     * 6   TST(SO) is the last received timestamp from source SO\n                     * 7   TST_MAX is the maximum value of the timestamp = 2^32 - 1\n                     * 8\n                     * 9   IF (((TST(P) > TST(SO) AND ((TST(P) - TST(SO)) <= TST_MAX/2)) OR\n                     *             ((TST(SO) > TST(P)) AND ((TST(SO) - TST(P)) > TST_MAX/2))) THEN\n                     * 10                                                  # TST(P) is greater than TST(SO)\n                     * 11      TST(SO) = TST(P)\n                     * 12      SN(SO) = SN(P)                              # P is not a duplicate packet\n                     * 13  ELSEIF TST(P) = TST(SO) THEN\n                     * 14      IF (((SN(P) > SN(SO) AND ((SN(P) - SN(SO)) <= SN_MAX/2)) OR\n                     *              ((SN(SO) > SN(P)) AND ((SN(SO) - SN(P)) > SN_MAX/2))) THEN\n                     * 15                                                  # SN(P) is greater than SN(SO)\n                     * 16          TST(SO) = TST(P)\n                     * 17          SN(SO) = SN(P)                          # P is not a duplicate packet\n                     * 18      ELSE\n                     * 19                                                  # SN(P) is not greater than SN(SO)\n                     * 20                                                  # P is a duplicate\n                     * 21      ENDIF\n                     * 22  ELSE\n                     * 23                                                  # TST(P) not greater than TST(SO)\n                     * 24  ENDIF\n                     */\n                    if (((timestamp > tp->timestamp) && (((guint64)timestamp - (guint64)tp->timestamp) <= (guint64)TST_MAX/2)) ||\n                            ((tp->timestamp > timestamp) && (((guint64)tp->timestamp - (guint64)timestamp) > (guint64)TST_MAX/2))) {\n                                                                    // TST(P) is greater than TST(SO)\n                        tp->sequence_number = sequence_number;\n                        tp->timestamp = timestamp;                  // P is not a duplicate packet\n                    } else if (timestamp == tp->timestamp) {\n                        if (((sequence_number > tp->sequence_number) && ((sequence_number - tp->sequence_number) <= SN_MAX/2)) ||\n                             ((tp->sequence_number > sequence_number) && ((tp->sequence_number - sequence_number) > SN_MAX/2))) {\n                                                                    // SN(P) is greater than SN(SO)\n                            tp->timestamp = timestamp;\n                            tp->sequence_number = sequence_number;  // P is not a duplicate packet\n                        } else {\n                                                                    // SN(P) is not greater than SN(SO)\n                                                                    // P is a duplicate\n                            ti = proto_tree_add_item(geonw_tree, hf_geonw_analysis_flags, tvb, 0, 0, ENC_NA);\n                            proto_item_set_generated(ti);\n                            expert_add_info(pinfo, ti, &ei_geonw_analysis_duplicate);\n                            col_prepend_fence_fstr(pinfo->cinfo, COL_INFO, \"[Duplicate packet] \");\n                        }\n                    } // else { # TST(P) not greater than TST(SO) }\n                }\n                else {\n                    /*\n                     * 1   P is the received GeoNetworking packet\n                     * 2   TST(P) is the timestamp in the received GeoNetworking packet\n                     * 3   TST(SO) is the last received timestamp from source SO\n                     * 4   TS_MAX is the maximum value of the timestamp = 2^32 - 1\n                     * 5\n                     * 6   IF (((TST(P) > TST(SO) AND ((TST(P) - TST(SO)) <= TST_MAX/2)) OR\n                     *             ((TST(SO) > TST(P)) AND ((TST(SO) - TST(P)) > TST_MAX/2))) THEN\n                     * 7                                       # TST(P) is greater than TST(SO)\n                     * 8       TST(SO) = TST(P)                # P is not a duplicate packet\n                     * 9   ELSE\n                     * 10                                      # P is a duplicate\n                     * 11  ENDIF\n                     */\n                    if (((timestamp > tp->timestamp) && (((guint64)timestamp - (guint64)tp->timestamp) <= (guint64)TST_MAX/2)) ||\n                            ((tp->timestamp > timestamp) && (((guint64)tp->timestamp - (guint64)timestamp) > (guint64)TST_MAX/2))) {\n                                                        // TST(P) is greater than TST(SO)\n                        tp->timestamp = timestamp;      // P is not a duplicate packet\n                    } else {\n                                                        // P is a duplicate\n                        ti = proto_tree_add_item(geonw_tree, hf_geonw_analysis_flags, tvb, 0, 0, ENC_NA);\n                        proto_item_set_generated(ti);\n                        expert_add_info(pinfo, ti, &ei_geonw_analysis_duplicate);\n                        col_prepend_fence_fstr(pinfo->cinfo, COL_INFO, \"[Duplicate packet] \");\n                    }\n                }\n            }\n        }\n        // XXX Implement DPD if version == 1\n\n        offset += 4;\n        ti = proto_tree_add_item_ret_int(geonw_so_tree, hf_geonw_so_pv_lat, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n        if (latlon < -900000000 || latlon > 900000000) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n        }\n        geonwh->gnw_lat = latlon;\n        offset += 4;\n        ti = proto_tree_add_item_ret_int(geonw_so_tree, hf_geonw_so_pv_lon, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n        if (latlon < -1800000000 || latlon > 1800000000) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n        }\n        geonwh->gnw_lon = latlon;\n        offset += 4;\n        proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_pai, tvb, offset, 1, ENC_BIG_ENDIAN);\n        proto_tree_add_item(geonw_so_tree, hf_geonw_so_pv_speed, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        ti = proto_tree_add_item_ret_uint(geonw_so_tree, hf_geonw_so_pv_heading, tvb, offset, 2, ENC_BIG_ENDIAN, &tmp_val);\n        if (tmp_val > 3600) {\n            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Out of range [0..360] (%f)\", (float)tmp_val/10);\n        }\n        offset += 2;\n\n        proto_tree *geonw_de_tree = NULL;\n        proto_tree *geonw_de_add_tree = NULL;\n        switch(header_type) {\n            case HTST_GEOUNICAST:\n            case HTST_LS_REPLY:\n                // Destination address\n                ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_de_pv, tvb, offset, 20, ENC_NA);\n                geonw_de_tree = proto_item_add_subtree(ti, ett_geonw_de);\n\n                ti = proto_tree_add_item(geonw_de_tree, hf_geonw_de_pv_addr, tvb, offset, 8, ENC_NA);\n                geonw_de_add_tree = proto_item_add_subtree(ti, ett_geonw_de);\n                set_address_tvb(&pinfo->net_dst, geonw_address_type, 8, tvb, offset);\n                copy_address_shallow(&pinfo->dst, &pinfo->net_dst);\n                copy_address_shallow(&geonwh->gnw_dst, &pinfo->dst);\n\n                if (header_type == HTST_LS_REPLY) {\n                    transaction_end(pinfo, geonw_tree);\n                }\n\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                ti = proto_tree_add_item_ret_uint(geonw_de_add_tree, hf_geonw_de_pv_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved > 999) {\n                    expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n                }\n                offset += 2;\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_de_pv_addr_mid, tvb, offset, 6, ENC_NA);\n                offset += 6;\n\n                proto_tree_add_item(geonw_de_tree, hf_geonw_de_pv_time, tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_de_tree, hf_geonw_de_pv_lat, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -900000000 || latlon > 900000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_de_tree, hf_geonw_de_pv_lon, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -1800000000 || latlon > 1800000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                break;\n            case HTST_TSB_SINGLE:\n                // Reserved 32 bits\n                // See usage in 636-4 subpart 2 for ITS-5G\n                reserved = tvb_get_guint32(tvb, offset, ENC_BIG_ENDIAN);\n                if (reserved) {\n                    ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_dccmco, tvb, offset, 4, ENC_NA);\n                    proto_tree *dccmco = proto_item_add_subtree(ti, ett_geonw_dccmco);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_cbr_l_0_hop, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_cbr_l_1_hop, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_output_power, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_dccmco_reserved, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(dccmco, hf_geonw_shb_reserved, tvb, offset+3, 1, ENC_BIG_ENDIAN);\n                }\n                else {\n                    proto_tree_add_item(geonw_sh_tree, hf_geonw_shb_reserved, tvb, offset, 4, ENC_BIG_ENDIAN);\n                }\n                offset += 4;\n                break;\n            case HTST_GAC_CIRCLE:\n            case HTST_GAC_RECT:\n            case HTST_GAC_ELLIPSE:\n            case HTST_GBC_CIRCLE:\n            case HTST_GBC_RECT:\n            case HTST_GBC_ELLIPSE:\n                ti = proto_tree_add_item_ret_int(geonw_sh_tree, hf_geonw_gxc_latitude, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -900000000 || latlon > 900000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Latitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                ti = proto_tree_add_item_ret_int(geonw_sh_tree, hf_geonw_gxc_longitude, tvb, offset, 4, ENC_BIG_ENDIAN, &latlon);\n                if (latlon < -1800000000 || latlon > 1800000000) {\n                    expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Longitude out of range (%f)\", (float)latlon/10000000);\n                }\n                offset += 4;\n                switch(header_type&0x0f) {\n                    case HST_CIRCULAR:\n                        /*\n                         * According to EN 302 363-4-1:\n                         * In case of a circular area (GeoNetworking packet\n                         * sub-type HST = 0), the fields shall be set to the\n                         * following values:\n                         *  1) Distance a is set to the radius r.\n                         *  2) Distance b is set to 0.\n                         *  3) Angle is set to 0.\n                         */\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_radius, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_distanceb, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                        if (reserved) {\n                            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                        }\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_angle, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                        if (reserved) {\n                            expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                        }\n                        offset += 2;\n                        break;\n                    case HST_RECTANGULAR:\n                    case HST_ELLIPSOIDAL:\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_distancea, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        proto_tree_add_item(geonw_sh_tree, hf_geonw_gxc_distanceb, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_angle, tvb, offset, 2, ENC_BIG_ENDIAN, &tmp_val);\n                        if (tmp_val > 360) {\n                            expert_add_info_format(pinfo, ti, &ei_geonw_out_of_range, \"Out of range [0..360] (%f)\", (float)tmp_val);\n                        }\n                        offset += 2;\n                }\n                ti = proto_tree_add_item_ret_uint(geonw_sh_tree, hf_geonw_gxc_reserved, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved) {\n                    expert_add_info(pinfo, ti, &ei_geonw_nz_reserved);\n                }\n                offset += 2;\n                break;\n            case HTST_LS_REQUEST:\n                // GN_ADDR\n                ti = proto_tree_add_item(geonw_sh_tree, hf_geonw_lsrq_addr, tvb, offset, 8, ENC_NA);\n                geonw_de_add_tree = proto_item_add_subtree(ti, ett_geonw_lsrq_add);\n                set_address_tvb(&pinfo->net_dst, geonw_address_type, 8, tvb, offset);\n                copy_address_shallow(&pinfo->dst, &pinfo->net_dst);\n\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_manual, tvb, offset, 1, ENC_BIG_ENDIAN);\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                ti = proto_tree_add_item_ret_uint(geonw_de_add_tree, hf_geonw_lsrq_addr_country, tvb, offset, 2, ENC_BIG_ENDIAN, &reserved);\n                if (reserved > 999) {\n                    expert_add_info(pinfo, ti, &ei_geonw_scc_too_big);\n                }\n                offset += 2;\n                proto_tree_add_item(geonw_de_add_tree, hf_geonw_lsrq_addr_mid, tvb, offset, 6, ENC_NA);\n                offset += 6;\n                transaction_start(pinfo, geonw_tree);\n                break;\n            //case HTST_BEACON:\n            //case HTST_TSB_MULT:\n        }\n        proto_item_set_end(top_item, tvb, offset);\n\n        tap_queue_packet(geonw_tap, pinfo, geonwh);\n\n        if (payload_len) {\n            // TODO expert info if payload_len different from remaining\n            tvbuff_t *next_tvb = tvb_new_subset_length(tvb, offset, payload_len);\n            switch(ch_next_header) {\n                case CH_NH_BTP_A:\n                    call_dissector(btpa_handle, next_tvb, pinfo, tree);\n                    break;\n                case CH_NH_BTP_B:\n                    call_dissector(btpb_handle, next_tvb, pinfo, tree);\n                    break;\n                case CH_NH_IPV6:\n                    call_dissector(ipv6_handle, next_tvb, pinfo, tree);\n                    break;\n                default:\n                    if (!dissector_try_uint(geonw_subdissector_table, ch_next_header, next_tvb, pinfo, tree)) {\n                        call_data_dissector(next_tvb, pinfo, tree);\n                    }\n            }\n        }\n\n    }\n\n    return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -104,7 +104,7 @@\n \n     if (bh_next_header == BH_NH_SECURED_PKT) {\n         dissect_secured_message(tvb, offset, pinfo, geonw_tree, NULL);\n-        tvbuff_t *next_tvb = (tvbuff_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0);\n+        tvbuff_t *next_tvb = (tvbuff_t*)p_get_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY);\n         if (next_tvb) {\n             tvb = next_tvb;\n             bh_next_header = BH_NH_COMMON_HDR;\n@@ -137,7 +137,6 @@\n                 default:\n                     hdr_len = -1;\n             }\n-            p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, NULL);\n         }\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        tvbuff_t *next_tvb = (tvbuff_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0);",
                "            p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, NULL);"
            ],
            "added_lines": [
                "        tvbuff_t *next_tvb = (tvbuff_t*)p_get_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0416",
        "func_name": "wireshark/dissect_sec_payload",
        "description": "GNW dissector crash in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/693dc40936a9eeac0e1c10ff496b3d327e25642b",
        "commit_title": "GNW: Ensure that tvbuff proto data has the proper scope.",
        "commit_text": " Add security tvbuffs to our proto data using pinfo->pool. Fixes #18779. ",
        "func_before": "static int\ndissect_sec_payload(tvbuff_t *tvb, gint *offset, packet_info *pinfo, proto_tree *part_tree)\n{\n    gint start = *offset;\n    guint32 tmp_val;\n    guint32 param_len;\n    proto_tree *field_tree;\n    proto_item *ti;\n\n    tmp_val = tvb_get_guint8(tvb, *offset);\n    if (tmp_val == signed_external) {\n        proto_tree_add_item(part_tree, hf_sgeonw_payload_field_type, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n    }\n    else {\n        ti = proto_tree_add_item(part_tree, hf_sgeonw_payload_field, tvb, *offset, 0, ENC_NA);\n        field_tree = proto_item_add_subtree(ti, ett_sgeonw_field);\n        proto_tree_add_item(field_tree, hf_sgeonw_payload_field_type, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n        switch(tmp_val) {\n            case unsecured:\n            case signed_pl:\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                if (param_len) {\n                    tvbuff_t *next_tvb = tvb_new_subset_length(tvb, *offset, param_len);\n                    p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, next_tvb);\n                }\n                *offset += param_len;\n                break;\n            case encrypted:\n            case signed_and_encrypted:\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                proto_tree_add_item(field_tree, hf_sgeonw_opaque, tvb, *offset, param_len, ENC_NA);\n                *offset += param_len;\n                break;\n            default:\n                // Opaque\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                proto_tree_add_item(field_tree, hf_sgeonw_opaque, tvb, *offset, param_len, ENC_NA);\n                *offset += param_len;\n        }\n        proto_item_set_end(ti, tvb, *offset);\n    }\n\n    return (*offset) - start;\n}",
        "func": "static int\ndissect_sec_payload(tvbuff_t *tvb, gint *offset, packet_info *pinfo, proto_tree *part_tree)\n{\n    gint start = *offset;\n    guint32 tmp_val;\n    guint32 param_len;\n    proto_tree *field_tree;\n    proto_item *ti;\n\n    tmp_val = tvb_get_guint8(tvb, *offset);\n    if (tmp_val == signed_external) {\n        proto_tree_add_item(part_tree, hf_sgeonw_payload_field_type, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n    }\n    else {\n        ti = proto_tree_add_item(part_tree, hf_sgeonw_payload_field, tvb, *offset, 0, ENC_NA);\n        field_tree = proto_item_add_subtree(ti, ett_sgeonw_field);\n        proto_tree_add_item(field_tree, hf_sgeonw_payload_field_type, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n        switch(tmp_val) {\n            case unsecured:\n            case signed_pl:\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                if (param_len) {\n                    tvbuff_t *next_tvb = tvb_new_subset_length(tvb, *offset, param_len);\n                    p_add_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY, next_tvb);\n                }\n                *offset += param_len;\n                break;\n            case encrypted:\n            case signed_and_encrypted:\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                proto_tree_add_item(field_tree, hf_sgeonw_opaque, tvb, *offset, param_len, ENC_NA);\n                *offset += param_len;\n                break;\n            default:\n                // Opaque\n                param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                proto_tree_add_item(field_tree, hf_sgeonw_opaque, tvb, *offset, param_len, ENC_NA);\n                *offset += param_len;\n        }\n        proto_item_set_end(ti, tvb, *offset);\n    }\n\n    return (*offset) - start;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n                 param_len = dissect_sec_var_len(tvb, offset, pinfo, field_tree);\n                 if (param_len) {\n                     tvbuff_t *next_tvb = tvb_new_subset_length(tvb, *offset, param_len);\n-                    p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, next_tvb);\n+                    p_add_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY, next_tvb);\n                 }\n                 *offset += param_len;\n                 break;",
        "diff_line_info": {
            "deleted_lines": [
                "                    p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, next_tvb);"
            ],
            "added_lines": [
                "                    p_add_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY, next_tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0416",
        "func_name": "wireshark/dissect_sgeonw",
        "description": "GNW dissector crash in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/693dc40936a9eeac0e1c10ff496b3d327e25642b",
        "commit_title": "GNW: Ensure that tvbuff proto data has the proper scope.",
        "commit_text": " Add security tvbuffs to our proto data using pinfo->pool. Fixes #18779. ",
        "func_before": "static int\ndissect_sgeonw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree _U_, void *data _U_)\n{\n    // Just store the tvbuff for later, as it is embedded inside a secured geonetworking packet\n    p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, tvb);\n\n    return tvb_reported_length(tvb);\n}",
        "func": "static int\ndissect_sgeonw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree _U_, void *data _U_)\n{\n    // Just store the tvbuff for later, as it is embedded inside a secured geonetworking packet\n    p_add_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY, tvb);\n\n    return tvb_reported_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n dissect_sgeonw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree _U_, void *data _U_)\n {\n     // Just store the tvbuff for later, as it is embedded inside a secured geonetworking packet\n-    p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, tvb);\n+    p_add_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY, tvb);\n \n     return tvb_reported_length(tvb);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    p_add_proto_data(wmem_file_scope(), pinfo, proto_geonw, 0, tvb);"
            ],
            "added_lines": [
                "    p_add_proto_data(pinfo->pool, pinfo, proto_geonw, SEC_TVB_KEY, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0417",
        "func_name": "wireshark/dissect_nfs4_dirlist",
        "description": "Memory leak in the NFS dissector in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ae0c38a07a64a7c002d64b31e13c349ee4919791",
        "commit_title": "NFS: Fix string decoding to use UTF-8",
        "commit_text": " Use tvb_get_string_enc() to read a string.  I think NFSv3 doesn't specify an encoding so interoperabilty is dicey. I believe NFSv4 specifies UTF-8.  Fixes #18628. ",
        "func_before": "static int\ndissect_nfs4_dirlist(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t     proto_tree *tree, rpc_call_info_value *civ)\n{\n\tguint32\t    val_follows;\n\tguint32\t    name_len;\n\tchar\t   *name;\n\tproto_tree *dirlist_tree;\n\tproto_item *eitem;\n\tproto_tree *entry_tree;\n\n\tdirlist_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nfs4_dirlist, NULL, \"Directory Listing\");\n\n\twhile (1)\n\t{\n\t\tval_follows = tvb_get_ntohl(tvb, offset);\n\t\tif (val_follows) {\n\t\t\tint start_off = offset;\n\n\t\t\t/* Make sure we have 16 bytes (value follows + cookie + name length) */\n\t\t\tname_len = tvb_get_ntohl(tvb, offset + 12);\n\t\t\ttvb_ensure_bytes_exist(tvb, offset, 16 + name_len);\n\t\t\t/*\n\t\t\t* Get the entry name and create subtree of field nfs.name\n\t\t\t*/\n\t\t\tname = (char *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), name_len+1), offset + 16, name_len);\n\t\t\tname[name_len] = '\\0';\n\n\t\t\teitem = proto_tree_add_string_format(\n\t\t\t\tdirlist_tree, hf_nfs_name, tvb, offset, -1, name, \"Entry: %s\", name);\n\t\t\tentry_tree = proto_item_add_subtree(eitem, ett_nfs4_dir_entry);\n\n\t\t\t/* Value Follows: <Yes|No> */\n\t\t\tproto_tree_add_boolean(entry_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows);\n\t\t\toffset += 4;\n\n\t\t\t/* Directory entry cookie */\n\t\t\tif (entry_tree)\n\t\t\t\tdissect_rpc_uint64(tvb, entry_tree, hf_nfs4_cookie, offset);\n\t\t\toffset += 8;\n\n\t\t\t/* Directory entry name (nfs.entry_name) */\n\t\t\toffset = dissect_nfs_utf8string(tvb, offset, entry_tree, hf_nfs4_dir_entry_name, NULL);\n\n\t\t\t/* Attrmask(s) */\n\t\t\toffset = dissect_nfs4_fattrs(tvb, offset, pinfo, entry_tree, FATTR4_DISSECT_VALUES, civ);\n\t\t\tproto_item_set_len(eitem, offset - start_off);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dirlist_tree) {\n\t\tproto_tree_add_boolean(dirlist_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows);\n\t\toffset += 4;\n\t\t/* The last entry in this packet has been reached but do more follow? */\n\t\toffset = dissect_rpc_bool(tvb, dirlist_tree, hf_nfs4_dirlist_eof, offset);\n\t} else {\n\t\toffset += 8;\n\t}\n\treturn offset;\n}",
        "func": "static int\ndissect_nfs4_dirlist(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t     proto_tree *tree, rpc_call_info_value *civ)\n{\n\tguint32\t    val_follows;\n\tguint32\t    name_len;\n\tchar\t   *name;\n\tproto_tree *dirlist_tree;\n\tproto_item *eitem;\n\tproto_tree *entry_tree;\n\n\tdirlist_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nfs4_dirlist, NULL, \"Directory Listing\");\n\n\twhile (1)\n\t{\n\t\tval_follows = tvb_get_ntohl(tvb, offset);\n\t\tif (val_follows) {\n\t\t\tint start_off = offset;\n\n\t\t\t/* Make sure we have 16 bytes (value follows + cookie + name length) */\n\t\t\tname_len = tvb_get_ntohl(tvb, offset + 12);\n\t\t\ttvb_ensure_bytes_exist(tvb, offset, 16 + name_len);\n\t\t\t/*\n\t\t\t* Get the entry name and create subtree of field nfs.name\n\t\t\t*/\n\t\t\tname = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 16, name_len, ENC_UTF_8);\n\n\t\t\teitem = proto_tree_add_string_format(\n\t\t\t\tdirlist_tree, hf_nfs_name, tvb, offset, -1, name, \"Entry: %s\", name);\n\t\t\tentry_tree = proto_item_add_subtree(eitem, ett_nfs4_dir_entry);\n\n\t\t\t/* Value Follows: <Yes|No> */\n\t\t\tproto_tree_add_boolean(entry_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows);\n\t\t\toffset += 4;\n\n\t\t\t/* Directory entry cookie */\n\t\t\tif (entry_tree)\n\t\t\t\tdissect_rpc_uint64(tvb, entry_tree, hf_nfs4_cookie, offset);\n\t\t\toffset += 8;\n\n\t\t\t/* Directory entry name (nfs.entry_name) */\n\t\t\toffset = dissect_nfs_utf8string(tvb, offset, entry_tree, hf_nfs4_dir_entry_name, NULL);\n\n\t\t\t/* Attrmask(s) */\n\t\t\toffset = dissect_nfs4_fattrs(tvb, offset, pinfo, entry_tree, FATTR4_DISSECT_VALUES, civ);\n\t\t\tproto_item_set_len(eitem, offset - start_off);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dirlist_tree) {\n\t\tproto_tree_add_boolean(dirlist_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows);\n\t\toffset += 4;\n\t\t/* The last entry in this packet has been reached but do more follow? */\n\t\toffset = dissect_rpc_bool(tvb, dirlist_tree, hf_nfs4_dirlist_eof, offset);\n\t} else {\n\t\toffset += 8;\n\t}\n\treturn offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,8 +23,7 @@\n \t\t\t/*\n \t\t\t* Get the entry name and create subtree of field nfs.name\n \t\t\t*/\n-\t\t\tname = (char *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), name_len+1), offset + 16, name_len);\n-\t\t\tname[name_len] = '\\0';\n+\t\t\tname = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 16, name_len, ENC_UTF_8);\n \n \t\t\teitem = proto_tree_add_string_format(\n \t\t\t\tdirlist_tree, hf_nfs_name, tvb, offset, -1, name, \"Entry: %s\", name);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tname = (char *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), name_len+1), offset + 16, name_len);",
                "\t\t\tname[name_len] = '\\0';"
            ],
            "added_lines": [
                "\t\t\tname = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 16, name_len, ENC_UTF_8);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25104",
        "func_name": "rtcwcoop/AICast_ScriptParse",
        "description": "A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic. Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c of the component Team Command Handler. The manipulation leads to denial of service. The identifier of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is recommended to apply a patch to fix this issue. The identifier VDB-221485 was assigned to this vulnerability.",
        "git_url": "https://github.com/rtcwcoop/rtcwcoop/commit/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac",
        "commit_title": "fixed exploit where server crash by spamming team command",
        "commit_text": " ******************** ERROR: G_Alloc: failed on allocation of 27248 bytes ******************** ----- Server Shutdown (Server crashed: G_Alloc: failed on allocation of 27248 bytes) -----  replaced G_Alloc -> trap_Alloc  anyway POOLSIZE for G_Alloc will fill up quickly just changing team in game menu",
        "func_before": "void AICast_ScriptParse( cast_state_t *cs ) {\n\tgentity_t   *ent;\n\tchar        *pScript;\n\tchar        *token;\n\tqboolean wantName;\n\tqboolean inScript;\n\tint eventNum;\n\tint numEventItems;\n\tcast_script_event_t *curEvent;\n\tchar params[MAX_QPATH];\n\tcast_script_stack_action_t  *action;\n\tint i;\n\tint bracketLevel;\n\tqboolean buildScript;       //----(SA)\tadded\n\n\tif ( !level.scriptAI ) {\n\t\treturn;\n\t}\n\n\tent = &g_entities[cs->entityNum];\n\tif ( !ent->aiName ) {\n\t\treturn;\n\t}\n\n\tbuildScript = qtrue;\n\n\tpScript = level.scriptAI;\n\twantName = qtrue;\n\tinScript = qfalse;\n\tCOM_BeginParseSession( \"AICast_ScriptParse\" );\n\tbracketLevel = 0;\n\tnumEventItems = 0;\n\n\tmemset( cast_temp_events, 0, sizeof( cast_temp_events ) );\n\n\twhile ( 1 )\n\t{\n\t\ttoken = COM_Parse( &pScript );\n\n\t\tif ( !token[0] ) {\n\t\t\tif ( !wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// end of script\n\t\tif ( token[0] == '}' ) {\n\t\t\tif ( inScript ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\twantName = qtrue;\n\t\t} else if ( token[0] == '{' )    {\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t} else if ( wantName )   {\n\t\t\tif ( !Q_strcasecmp( ent->aiName, token ) ) {\n\t\t\t\tinScript = qtrue;\n\t\t\t\tnumEventItems = 0;\n\t\t\t}\n\t\t\twantName = qfalse;\n\t\t} else if ( inScript )   {\n\t\t\tif ( !Q_strcasecmp( token, \"attributes\" ) ) {\n\t\t\t\t// read in all the attributes\n\t\t\t\tAICast_CheckLevelAttributes( cs, ent, &pScript );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\teventNum = AICast_EventForString( token );\n\t\t\tif ( eventNum < 0 ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown event: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t}\n\t\t\tif ( numEventItems >= MAX_SCRIPT_EVENTS ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\\n\", COM_GetCurrentParseLine(), MAX_SCRIPT_EVENTS );\n\t\t\t}\n\n\t\t\t// if this is a \"friendlysightcorpse\" event, then disable corpse vis sharing\n\t\t\tif ( !Q_stricmp( token, \"friendlysightcorpse\" ) ) {\n\t\t\t\tcs->aiFlags &= ~AIFL_CORPSESIGHTING;\n\t\t\t}\n\n\t\t\tcurEvent = &cast_temp_events[numEventItems];\n\t\t\tcurEvent->eventNum = eventNum;\n\t\t\tmemset( params, 0, sizeof( params ) );\n\n\t\t\t// parse any event params before the start of this event's actions\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '{' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\tif ( eventNum == 13 ) {   // statechange event, check params\n\t\t\t\t\tif ( strlen( token ) > 1 ) {\n\t\t\t\t\t\tif ( BG_IndexForString( token, animStateStr, qtrue ) < 0 ) {\n\t\t\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\tcurEvent->params = G_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t// parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\taction = AICast_ActionForString( cs, token );\n\t\t\t\tif ( !action ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown action: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].action = action;\n\n\t\t\t\tmemset( params, 0, sizeof( params ) );\n\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\tfor ( i = 0; token[0]; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( i == 0 ) {\n\t\t\t\t\t\t// Special case: playsound's need to be cached on startup to prevent in-game pauses\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"playsound\" ) ) {\n\t\t\t\t\t\t\tG_SoundIndex( token );\n\t\t\t\t\t\t}\n\n//----(SA)\tadded a bit more\n\t\t\t\t\t\tif (    buildScript && (\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_start\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_play\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_queue\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcam\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcamblack\" ) )\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif ( strlen( token ) ) { // we know there's a [0], but don't know if it's '0'\n\t\t\t\t\t\t\t\ttrap_SendServerCommand( cs->entityNum, va( \"addToBuild %s\\n\", token ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"giveweapon\" ) ) { // register weapon for client pre-loading\n\t\t\t\t\t\t\tgitem_t *weap = BG_FindItem2( token );    // (SA) FIXME: rats, need to fix this for weapon names with spaces: 'mauser rifle'\n//\t\t\t\t\t\t\tif(weap)\n\t\t\t\t\t\t\tRegisterItem( weap );   // don't be nice, just do it.  if it can't find it, you'll bomb out to the error menu\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to get this for callvote nextmap\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"changelevel\" ) ) {\n\t\t\t\t\t\t\tQ_strncpyz( level.nextMap, token, sizeof( level.nextMap ) );\n\t\t\t\t\t\t\ttrap_Cvar_Set( \"nextmap\", level.nextMap );\n\t\t\t\t\t\t}\n//----(SA)\tend\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t\t\tif ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\\n\", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnumEventItems++;\n\t\t} else    // skip this character completely\n\t\t{\n\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t} else if ( token[0] == '{' ) {\n\t\t\t\t\tbracketLevel++;\n\t\t\t\t} else if ( token[0] == '}' ) {\n\t\t\t\t\tif ( !--bracketLevel ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}\n}",
        "func": "void AICast_ScriptParse( cast_state_t *cs ) {\n\tgentity_t   *ent;\n\tchar        *pScript;\n\tchar        *token;\n\tqboolean wantName;\n\tqboolean inScript;\n\tint eventNum;\n\tint numEventItems;\n\tcast_script_event_t *curEvent;\n\tchar params[MAX_QPATH];\n\tcast_script_stack_action_t  *action;\n\tint i;\n\tint bracketLevel;\n\tqboolean buildScript;       //----(SA)\tadded\n\n\tif ( !level.scriptAI ) {\n\t\treturn;\n\t}\n\n\tent = &g_entities[cs->entityNum];\n\tif ( !ent->aiName ) {\n\t\treturn;\n\t}\n\n\tbuildScript = qtrue;\n\n\tpScript = level.scriptAI;\n\twantName = qtrue;\n\tinScript = qfalse;\n\tCOM_BeginParseSession( \"AICast_ScriptParse\" );\n\tbracketLevel = 0;\n\tnumEventItems = 0;\n\n\tmemset( cast_temp_events, 0, sizeof( cast_temp_events ) );\n\n\twhile ( 1 )\n\t{\n\t\ttoken = COM_Parse( &pScript );\n\n\t\tif ( !token[0] ) {\n\t\t\tif ( !wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// end of script\n\t\tif ( token[0] == '}' ) {\n\t\t\tif ( inScript ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t\twantName = qtrue;\n\t\t} else if ( token[0] == '{' )    {\n\t\t\tif ( wantName ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\\n\", COM_GetCurrentParseLine() );\n\t\t\t}\n\t\t} else if ( wantName )   {\n\t\t\tif ( !Q_strcasecmp( ent->aiName, token ) ) {\n\t\t\t\tinScript = qtrue;\n\t\t\t\tnumEventItems = 0;\n\t\t\t}\n\t\t\twantName = qfalse;\n\t\t} else if ( inScript )   {\n\t\t\tif ( !Q_strcasecmp( token, \"attributes\" ) ) {\n\t\t\t\t// read in all the attributes\n\t\t\t\tAICast_CheckLevelAttributes( cs, ent, &pScript );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\teventNum = AICast_EventForString( token );\n\t\t\tif ( eventNum < 0 ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown event: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t}\n\t\t\tif ( numEventItems >= MAX_SCRIPT_EVENTS ) {\n\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\\n\", COM_GetCurrentParseLine(), MAX_SCRIPT_EVENTS );\n\t\t\t}\n\n\t\t\t// if this is a \"friendlysightcorpse\" event, then disable corpse vis sharing\n\t\t\tif ( !Q_stricmp( token, \"friendlysightcorpse\" ) ) {\n\t\t\t\tcs->aiFlags &= ~AIFL_CORPSESIGHTING;\n\t\t\t}\n\n\t\t\tcurEvent = &cast_temp_events[numEventItems];\n\t\t\tcurEvent->eventNum = eventNum;\n\t\t\tmemset( params, 0, sizeof( params ) );\n\n\t\t\t// parse any event params before the start of this event's actions\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '{' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\tif ( eventNum == 13 ) {   // statechange event, check params\n\t\t\t\t\tif ( strlen( token ) > 1 ) {\n\t\t\t\t\t\tif ( BG_IndexForString( token, animStateStr, qtrue ) < 0 ) {\n\t\t\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\tcurEvent->params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t// parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\taction = AICast_ActionForString( cs, token );\n\t\t\t\tif ( !action ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): unknown action: %s.\\n\", COM_GetCurrentParseLine(), token );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].action = action;\n\n\t\t\t\tmemset( params, 0, sizeof( params ) );\n\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\tfor ( i = 0; token[0]; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( i == 0 ) {\n\t\t\t\t\t\t// Special case: playsound's need to be cached on startup to prevent in-game pauses\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"playsound\" ) ) {\n\t\t\t\t\t\t\tG_SoundIndex( token );\n\t\t\t\t\t\t}\n\n//----(SA)\tadded a bit more\n\t\t\t\t\t\tif (    buildScript && (\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_start\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_play\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"mu_queue\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcam\" ) ||\n\t\t\t\t\t\t\t\t\t!Q_stricmp( action->actionString, \"startcamblack\" ) )\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif ( strlen( token ) ) { // we know there's a [0], but don't know if it's '0'\n\t\t\t\t\t\t\t\ttrap_SendServerCommand( cs->entityNum, va( \"addToBuild %s\\n\", token ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"giveweapon\" ) ) { // register weapon for client pre-loading\n\t\t\t\t\t\t\tgitem_t *weap = BG_FindItem2( token );    // (SA) FIXME: rats, need to fix this for weapon names with spaces: 'mauser rifle'\n//\t\t\t\t\t\t\tif(weap)\n\t\t\t\t\t\t\tRegisterItem( weap );   // don't be nice, just do it.  if it can't find it, you'll bomb out to the error menu\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to get this for callvote nextmap\n\t\t\t\t\t\tif ( !Q_stricmp( action->actionString, \"changelevel\" ) ) {\n\t\t\t\t\t\t\tQ_strncpyz( level.nextMap, token, sizeof( level.nextMap ) );\n\t\t\t\t\t\t\ttrap_Cvar_Set( \"nextmap\", level.nextMap );\n\t\t\t\t\t\t}\n//----(SA)\tend\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t\t\tif ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\\n\", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnumEventItems++;\n\t\t} else    // skip this character completely\n\t\t{\n\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t} else if ( token[0] == '{' ) {\n\t\t\t\t\tbracketLevel++;\n\t\t\t\t} else if ( token[0] == '}' ) {\n\t\t\t\t\tif ( !--bracketLevel ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -108,7 +108,7 @@\n \t\t\t}\n \n \t\t\tif ( strlen( params ) ) { // copy the params into the event\n-\t\t\t\tcurEvent->params = G_Alloc( strlen( params ) + 1 );\n+\t\t\t\tcurEvent->params = trap_Alloc( strlen( params ) + 1 );\n \t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n \t\t\t}\n \n@@ -181,7 +181,7 @@\n \t\t\t\t}\n \n \t\t\t\tif ( strlen( params ) ) { // copy the params into the event\n-\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );\n+\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );\n \t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n \t\t\t\t}\n \n@@ -213,7 +213,7 @@\n \n \t// alloc and copy the events into the cast_state_t for this cast\n \tif ( numEventItems > 0 ) {\n-\t\tcs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n+\t\tcs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n \t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n \t\tcs->numCastScriptEvents = numEventItems;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tcurEvent->params = G_Alloc( strlen( params ) + 1 );",
                "\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );",
                "\t\tcs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );"
            ],
            "added_lines": [
                "\t\t\t\tcurEvent->params = trap_Alloc( strlen( params ) + 1 );",
                "\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );",
                "\t\tcs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25104",
        "func_name": "rtcwcoop/AICast_ScriptLoad",
        "description": "A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic. Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c of the component Team Command Handler. The manipulation leads to denial of service. The identifier of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is recommended to apply a patch to fix this issue. The identifier VDB-221485 was assigned to this vulnerability.",
        "git_url": "https://github.com/rtcwcoop/rtcwcoop/commit/f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac",
        "commit_title": "fixed exploit where server crash by spamming team command",
        "commit_text": " ******************** ERROR: G_Alloc: failed on allocation of 27248 bytes ******************** ----- Server Shutdown (Server crashed: G_Alloc: failed on allocation of 27248 bytes) -----  replaced G_Alloc -> trap_Alloc  anyway POOLSIZE for G_Alloc will fill up quickly just changing team in game menu",
        "func_before": "void AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\n\tlevel.scriptAI = NULL;\n\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\n\tG_Printf( \"Loading: %s\\n\", filename );\n\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\n\tlevel.scriptAI = G_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\n\ttrap_FS_FCloseFile( f );\n\n\treturn;\n}",
        "func": "void AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\n\tlevel.scriptAI = NULL;\n\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\n\tG_Printf( \"Loading: %s\\n\", filename );\n\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\n\tlevel.scriptAI = trap_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\n\ttrap_FS_FCloseFile( f );\n\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \t\treturn;\n \t}\n \n-\tlevel.scriptAI = G_Alloc( len );\n+\tlevel.scriptAI = trap_Alloc( len );\n \ttrap_FS_Read( level.scriptAI, len, f );\n \n \ttrap_FS_FCloseFile( f );",
        "diff_line_info": {
            "deleted_lines": [
                "\tlevel.scriptAI = G_Alloc( len );"
            ],
            "added_lines": [
                "\tlevel.scriptAI = trap_Alloc( len );"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1289",
        "func_name": "tildearrow/furnace/FurnaceGUI::patternRow",
        "description": "A denial of service vulnerability was found in tildearrow Furnace. It has been classified as problematic. This is due to an incomplete fix of CVE-2022-1211. It is possible to initiate the attack remotely but it requires user interaction. The issue got fixed with the patch 0eb02422d5161767e9983bdaa5c429762d3477ce.",
        "git_url": "https://github.com/tildearrow/furnace/commit/0eb02422d5161767e9983bdaa5c429762d3477ce",
        "commit_title": "fix possible pattern crash",
        "commit_text": " issue #325",
        "func_before": "inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i>=sel1.y && i<=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord<0 || ord>=e->song.ordersLen) {\n    return;\n  }\n  if (i<0 || i>=e->song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit && cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit && cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,\"%3d \",i);\n  }\n  // for each column\n  for (int j=0; j<chans; j++) {\n    // check if channel is not hidden\n    if (!e->song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e->getMaxVolumeChan(j);\n    if (chanVolMax<1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n    bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n    bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n    bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n    bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n    bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n\n    // note\n    sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n    if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e->song.chanCollapse[j]) {\n      // instrument\n      if (pat->data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,\"..##PI_%d_%d\",i,j);\n      } else {\n        if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n          if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat->data[i][3]==-1) {\n        sprintf(id,\"..##PV_%d_%d\",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat->data[i][3]*127)/chanVolMax;\n        if (volColor>127) volColor=127;\n        if (volColor<0) volColor=0;\n        sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k<e->song.pat[j].effectRows; k++) {\n        int index=4+(k<<1);\n        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n          if (pat->data[i][index]<0x10) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n          } else if (pat->data[i][index]<0x20) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x30) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n          } else if (pat->data[i][index]<0x48) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x90) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xa0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n          } else if (pat->data[i][index]<0xc0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xd0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n          } else if (pat->data[i][index]<0xe0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat->data[i][index+1]==-1) {\n          sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n        } else {\n          sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}",
        "func": "inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i>=sel1.y && i<=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord<0 || ord>=e->song.ordersLen) {\n    return;\n  }\n  if (i<0 || i>=e->song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit && cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit && cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,\"%3d \",i);\n  }\n  // for each column\n  for (int j=0; j<chans; j++) {\n    // check if channel is not hidden\n    if (!e->song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e->getMaxVolumeChan(j);\n    if (chanVolMax<1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n    bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n    bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n    bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n    bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n    bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n\n    // note\n    sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n    if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e->song.chanCollapse[j]) {\n      // instrument\n      if (pat->data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,\"..##PI_%d_%d\",i,j);\n      } else {\n        if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n          if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat->data[i][3]==-1) {\n        sprintf(id,\"..##PV_%d_%d\",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat->data[i][3]*127)/chanVolMax;\n        if (volColor>127) volColor=127;\n        if (volColor<0) volColor=0;\n        sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k<e->song.pat[j].effectRows; k++) {\n        int index=4+(k<<1);\n        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          if (pat->data[i][index]>0xff) {\n            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            const unsigned char data=pat->data[i][index];\n            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);\n            if (data<0x10) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n            } else if (data<0x20) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x30) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n            } else if (data<0x48) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x90) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xa0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n            } else if (data<0xc0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xd0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n            } else if (data<0xe0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n            }\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat->data[i][index+1]==-1) {\n          sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n        } else {\n          sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -195,27 +195,33 @@\n           sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n           ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n         } else {\n-          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n-          if (pat->data[i][index]<0x10) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n-          } else if (pat->data[i][index]<0x20) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n-          } else if (pat->data[i][index]<0x30) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n-          } else if (pat->data[i][index]<0x48) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n-          } else if (pat->data[i][index]<0x90) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n-          } else if (pat->data[i][index]<0xa0) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n-          } else if (pat->data[i][index]<0xc0) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n-          } else if (pat->data[i][index]<0xd0) {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n-          } else if (pat->data[i][index]<0xe0) {\n+          if (pat->data[i][index]>0xff) {\n+            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n             ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n           } else {\n-            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n+            const unsigned char data=pat->data[i][index];\n+            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);\n+            if (data<0x10) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n+            } else if (data<0x20) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n+            } else if (data<0x30) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n+            } else if (data<0x48) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n+            } else if (data<0x90) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n+            } else if (data<0xa0) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n+            } else if (data<0xc0) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n+            } else if (data<0xd0) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n+            } else if (data<0xe0) {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n+            } else {\n+              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n+            }\n           }\n         }\n         ImGui::SameLine(0.0f,0.0f);",
        "diff_line_info": {
            "deleted_lines": [
                "          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);",
                "          if (pat->data[i][index]<0x10) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);",
                "          } else if (pat->data[i][index]<0x20) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);",
                "          } else if (pat->data[i][index]<0x30) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);",
                "          } else if (pat->data[i][index]<0x48) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);",
                "          } else if (pat->data[i][index]<0x90) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);",
                "          } else if (pat->data[i][index]<0xa0) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);",
                "          } else if (pat->data[i][index]<0xc0) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);",
                "          } else if (pat->data[i][index]<0xd0) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);",
                "          } else if (pat->data[i][index]<0xe0) {",
                "            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);"
            ],
            "added_lines": [
                "          if (pat->data[i][index]>0xff) {",
                "            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);",
                "            const unsigned char data=pat->data[i][index];",
                "            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);",
                "            if (data<0x10) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);",
                "            } else if (data<0x20) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);",
                "            } else if (data<0x30) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);",
                "            } else if (data<0x48) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);",
                "            } else if (data<0x90) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);",
                "            } else if (data<0xa0) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);",
                "            } else if (data<0xc0) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);",
                "            } else if (data<0xd0) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);",
                "            } else if (data<0xe0) {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);",
                "            } else {",
                "              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8071",
        "func_name": "torvalds/linux/cp2112_gpio_direction_output",
        "description": "drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors.",
        "git_url": "https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654",
        "commit_title": "HID: cp2112: fix sleep-while-atomic",
        "commit_text": " A recent commit fixing DMA-buffers on stack added a shared transfer buffer protected by a spinlock. This is broken as the USB HID request callbacks can sleep. Fix this up by replacing the spinlock with a mutex.  Cc: stable <stable@vger.kernel.org>\t# 4.9",
        "func_before": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t/*\n\t * Set gpio value when output direction is already set,\n\t * as specified in AN495, Rev. 0.2, cpt. 4.4\n\t */\n\tcp2112_gpio_set(chip, offset, value);\n\n\treturn 0;\n\nfail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret < 0 ? ret : -EIO;\n}",
        "func": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tmutex_unlock(&dev->lock);\n\n\t/*\n\t * Set gpio value when output direction is already set,\n\t * as specified in AN495, Rev. 0.2, cpt. 4.4\n\t */\n\tcp2112_gpio_set(chip, offset, value);\n\n\treturn 0;\n\nfail:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,10 +4,9 @@\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n-\tunsigned long flags;\n \tint ret;\n \n-\tspin_lock_irqsave(&dev->lock, flags);\n+\tmutex_lock(&dev->lock);\n \n \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n@@ -28,7 +27,7 @@\n \t\tgoto fail;\n \t}\n \n-\tspin_unlock_irqrestore(&dev->lock, flags);\n+\tmutex_unlock(&dev->lock);\n \n \t/*\n \t * Set gpio value when output direction is already set,\n@@ -39,6 +38,6 @@\n \treturn 0;\n \n fail:\n-\tspin_unlock_irqrestore(&dev->lock, flags);\n+\tmutex_unlock(&dev->lock);\n \treturn ret < 0 ? ret : -EIO;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned long flags;",
                "\tspin_lock_irqsave(&dev->lock, flags);",
                "\tspin_unlock_irqrestore(&dev->lock, flags);",
                "\tspin_unlock_irqrestore(&dev->lock, flags);"
            ],
            "added_lines": [
                "\tmutex_lock(&dev->lock);",
                "\tmutex_unlock(&dev->lock);",
                "\tmutex_unlock(&dev->lock);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8071",
        "func_name": "torvalds/linux/cp2112_gpio_set",
        "description": "drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors.",
        "git_url": "https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654",
        "commit_title": "HID: cp2112: fix sleep-while-atomic",
        "commit_text": " A recent commit fixing DMA-buffers on stack added a shared transfer buffer protected by a spinlock. This is broken as the USB HID request callbacks can sleep. Fix this up by replacing the spinlock with a mutex.  Cc: stable <stable@vger.kernel.org>\t# 4.9",
        "func_before": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}",
        "func": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tmutex_unlock(&dev->lock);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,9 @@\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n-\tunsigned long flags;\n \tint ret;\n \n-\tspin_lock_irqsave(&dev->lock, flags);\n+\tmutex_lock(&dev->lock);\n \n \tbuf[0] = CP2112_GPIO_SET;\n \tbuf[1] = value ? 0xff : 0;\n@@ -18,5 +17,5 @@\n \tif (ret < 0)\n \t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n \n-\tspin_unlock_irqrestore(&dev->lock, flags);\n+\tmutex_unlock(&dev->lock);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned long flags;",
                "\tspin_lock_irqsave(&dev->lock, flags);",
                "\tspin_unlock_irqrestore(&dev->lock, flags);"
            ],
            "added_lines": [
                "\tmutex_lock(&dev->lock);",
                "\tmutex_unlock(&dev->lock);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8071",
        "func_name": "torvalds/linux/cp2112_probe",
        "description": "drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors.",
        "git_url": "https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654",
        "commit_title": "HID: cp2112: fix sleep-while-atomic",
        "commit_text": " A recent commit fixing DMA-buffers on stack added a shared transfer buffer protected by a spinlock. This is broken as the USB HID request callbacks can sleep. Fix this up by replacing the spinlock with a mutex.  Cc: stable <stable@vger.kernel.org>\t# 4.9",
        "func_before": "static int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct cp2112_device *dev;\n\tu8 buf[3];\n\tstruct cp2112_smbus_config_report config;\n\tint ret;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->in_out_buffer)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dev->lock);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hw open failed\\n\");\n\t\tgoto err_hid_stop;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\tgoto err_hid_close;\n\t}\n\n\tret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error requesting version\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_info(hdev, \"Part Number: 0x%02X Device Version: 0x%02X\\n\",\n\t\t buf[1], buf[2]);\n\n\tret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\n\t\t\t     sizeof(config), HID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error requesting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\tconfig.retry_time = cpu_to_be16(1);\n\n\tret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error setting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_set_drvdata(hdev, (void *)dev);\n\tdev->hdev\t\t= hdev;\n\tdev->adap.owner\t\t= THIS_MODULE;\n\tdev->adap.class\t\t= I2C_CLASS_HWMON;\n\tdev->adap.algo\t\t= &smbus_algorithm;\n\tdev->adap.algo_data\t= dev;\n\tdev->adap.dev.parent\t= &hdev->dev;\n\tsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\t\t \"CP2112 SMBus Bridge on hiddev%d\", hdev->minor);\n\tdev->hwversion = buf[2];\n\tinit_waitqueue_head(&dev->wait);\n\n\thid_device_io_start(hdev);\n\tret = i2c_add_adapter(&dev->adap);\n\thid_device_io_stop(hdev);\n\n\tif (ret) {\n\t\thid_err(hdev, \"error registering i2c adapter\\n\");\n\t\tgoto err_power_normal;\n\t}\n\n\thid_dbg(hdev, \"adapter registered\\n\");\n\n\tdev->gc.label\t\t\t= \"cp2112_gpio\";\n\tdev->gc.direction_input\t\t= cp2112_gpio_direction_input;\n\tdev->gc.direction_output\t= cp2112_gpio_direction_output;\n\tdev->gc.set\t\t\t= cp2112_gpio_set;\n\tdev->gc.get\t\t\t= cp2112_gpio_get;\n\tdev->gc.base\t\t\t= -1;\n\tdev->gc.ngpio\t\t\t= 8;\n\tdev->gc.can_sleep\t\t= 1;\n\tdev->gc.parent\t\t\t= &hdev->dev;\n\n\tret = gpiochip_add_data(&dev->gc, dev);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error registering gpio chip\\n\");\n\t\tgoto err_free_i2c;\n\t}\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error creating sysfs attrs\\n\");\n\t\tgoto err_gpiochip_remove;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\n\tret = gpiochip_irqchip_add(&dev->gc, &cp2112_gpio_irqchip, 0,\n\t\t\t\t   handle_simple_irq, IRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(dev->gc.parent, \"failed to add IRQ chip\\n\");\n\t\tgoto err_sysfs_remove;\n\t}\n\n\treturn ret;\n\nerr_sysfs_remove:\n\tsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\nerr_gpiochip_remove:\n\tgpiochip_remove(&dev->gc);\nerr_free_i2c:\n\ti2c_del_adapter(&dev->adap);\nerr_power_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\nerr_hid_close:\n\thid_hw_close(hdev);\nerr_hid_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}",
        "func": "static int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct cp2112_device *dev;\n\tu8 buf[3];\n\tstruct cp2112_smbus_config_report config;\n\tint ret;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->in_out_buffer)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->lock);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hw open failed\\n\");\n\t\tgoto err_hid_stop;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\tgoto err_hid_close;\n\t}\n\n\tret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error requesting version\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_info(hdev, \"Part Number: 0x%02X Device Version: 0x%02X\\n\",\n\t\t buf[1], buf[2]);\n\n\tret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\n\t\t\t     sizeof(config), HID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error requesting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\tconfig.retry_time = cpu_to_be16(1);\n\n\tret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error setting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_set_drvdata(hdev, (void *)dev);\n\tdev->hdev\t\t= hdev;\n\tdev->adap.owner\t\t= THIS_MODULE;\n\tdev->adap.class\t\t= I2C_CLASS_HWMON;\n\tdev->adap.algo\t\t= &smbus_algorithm;\n\tdev->adap.algo_data\t= dev;\n\tdev->adap.dev.parent\t= &hdev->dev;\n\tsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\t\t \"CP2112 SMBus Bridge on hiddev%d\", hdev->minor);\n\tdev->hwversion = buf[2];\n\tinit_waitqueue_head(&dev->wait);\n\n\thid_device_io_start(hdev);\n\tret = i2c_add_adapter(&dev->adap);\n\thid_device_io_stop(hdev);\n\n\tif (ret) {\n\t\thid_err(hdev, \"error registering i2c adapter\\n\");\n\t\tgoto err_power_normal;\n\t}\n\n\thid_dbg(hdev, \"adapter registered\\n\");\n\n\tdev->gc.label\t\t\t= \"cp2112_gpio\";\n\tdev->gc.direction_input\t\t= cp2112_gpio_direction_input;\n\tdev->gc.direction_output\t= cp2112_gpio_direction_output;\n\tdev->gc.set\t\t\t= cp2112_gpio_set;\n\tdev->gc.get\t\t\t= cp2112_gpio_get;\n\tdev->gc.base\t\t\t= -1;\n\tdev->gc.ngpio\t\t\t= 8;\n\tdev->gc.can_sleep\t\t= 1;\n\tdev->gc.parent\t\t\t= &hdev->dev;\n\n\tret = gpiochip_add_data(&dev->gc, dev);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error registering gpio chip\\n\");\n\t\tgoto err_free_i2c;\n\t}\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error creating sysfs attrs\\n\");\n\t\tgoto err_gpiochip_remove;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\n\tret = gpiochip_irqchip_add(&dev->gc, &cp2112_gpio_irqchip, 0,\n\t\t\t\t   handle_simple_irq, IRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(dev->gc.parent, \"failed to add IRQ chip\\n\");\n\t\tgoto err_sysfs_remove;\n\t}\n\n\treturn ret;\n\nerr_sysfs_remove:\n\tsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\nerr_gpiochip_remove:\n\tgpiochip_remove(&dev->gc);\nerr_free_i2c:\n\ti2c_del_adapter(&dev->adap);\nerr_power_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\nerr_hid_close:\n\thid_hw_close(hdev);\nerr_hid_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \tif (!dev->in_out_buffer)\n \t\treturn -ENOMEM;\n \n-\tspin_lock_init(&dev->lock);\n+\tmutex_init(&dev->lock);\n \n \tret = hid_parse(hdev);\n \tif (ret) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tspin_lock_init(&dev->lock);"
            ],
            "added_lines": [
                "\tmutex_init(&dev->lock);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8071",
        "func_name": "torvalds/linux/cp2112_gpio_direction_input",
        "description": "drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors.",
        "git_url": "https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654",
        "commit_title": "HID: cp2112: fix sleep-while-atomic",
        "commit_text": " A recent commit fixing DMA-buffers on stack added a shared transfer buffer protected by a spinlock. This is broken as the USB HID request callbacks can sleep. Fix this up by replacing the spinlock with a mutex.  Cc: stable <stable@vger.kernel.org>\t# 4.9",
        "func_before": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret <= 0 ? ret : -EIO;\n}",
        "func": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret <= 0 ? ret : -EIO;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,9 @@\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n-\tunsigned long flags;\n \tint ret;\n \n-\tspin_lock_irqsave(&dev->lock, flags);\n+\tmutex_lock(&dev->lock);\n \n \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n@@ -30,6 +29,6 @@\n \tret = 0;\n \n exit:\n-\tspin_unlock_irqrestore(&dev->lock, flags);\n+\tmutex_unlock(&dev->lock);\n \treturn ret <= 0 ? ret : -EIO;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned long flags;",
                "\tspin_lock_irqsave(&dev->lock, flags);",
                "\tspin_unlock_irqrestore(&dev->lock, flags);"
            ],
            "added_lines": [
                "\tmutex_lock(&dev->lock);",
                "\tmutex_unlock(&dev->lock);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8071",
        "func_name": "torvalds/linux/cp2112_gpio_get_all",
        "description": "drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors.",
        "git_url": "https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654",
        "commit_title": "HID: cp2112: fix sleep-while-atomic",
        "commit_text": " A recent commit fixing DMA-buffers on stack added a shared transfer buffer protected by a spinlock. This is broken as the USB HID request callbacks can sleep. Fix this up by replacing the spinlock with a mutex.  Cc: stable <stable@vger.kernel.org>\t# 4.9",
        "func_before": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn ret;\n}",
        "func": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,9 @@\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n-\tunsigned long flags;\n \tint ret;\n \n-\tspin_lock_irqsave(&dev->lock, flags);\n+\tmutex_lock(&dev->lock);\n \n \tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n \t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n@@ -20,7 +19,7 @@\n \tret = buf[1];\n \n exit:\n-\tspin_unlock_irqrestore(&dev->lock, flags);\n+\tmutex_unlock(&dev->lock);\n \n \treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned long flags;",
                "\tspin_lock_irqsave(&dev->lock, flags);",
                "\tspin_unlock_irqrestore(&dev->lock, flags);"
            ],
            "added_lines": [
                "\tmutex_lock(&dev->lock);",
                "\tmutex_unlock(&dev->lock);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7472",
        "func_name": "torvalds/linux/keyctl_set_reqkey_keyring",
        "description": "The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.",
        "git_url": "https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b",
        "commit_title": "KEYS: fix keyctl_set_reqkey_keyring() to not leak thread keyrings",
        "commit_text": " This fixes CVE-2017-7472.  Running the following program as an unprivileged user exhausts kernel memory by leaking thread keyrings:  \t#include <keyutils.h>  \tint main() \t{ \t\tfor (;;) \t\t\tkeyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_THREAD_KEYRING); \t}  Fix it by only creating a new thread keyring if there wasn't one before. To make things more consistent, make install_thread_keyring_to_cred() and install_process_keyring_to_cred() both return 0 if the corresponding keyring is already present.  Cc: stable@vger.kernel.org # 2.6.29+",
        "func_before": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}",
        "func": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,11 +21,8 @@\n \n \tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n \t\tret = install_process_keyring_to_cred(new);\n-\t\tif (ret < 0) {\n-\t\t\tif (ret != -EEXIST)\n-\t\t\t\tgoto error;\n-\t\t\tret = 0;\n-\t\t}\n+\t\tif (ret < 0)\n+\t\t\tgoto error;\n \t\tgoto set;\n \n \tcase KEY_REQKEY_DEFL_DEFAULT:",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (ret < 0) {",
                "\t\t\tif (ret != -EEXIST)",
                "\t\t\t\tgoto error;",
                "\t\t\tret = 0;",
                "\t\t}"
            ],
            "added_lines": [
                "\t\tif (ret < 0)",
                "\t\t\tgoto error;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7472",
        "func_name": "torvalds/linux/install_process_keyring",
        "description": "The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.",
        "git_url": "https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b",
        "commit_title": "KEYS: fix keyctl_set_reqkey_keyring() to not leak thread keyrings",
        "commit_text": " This fixes CVE-2017-7472.  Running the following program as an unprivileged user exhausts kernel memory by leaking thread keyrings:  \t#include <keyutils.h>  \tint main() \t{ \t\tfor (;;) \t\t\tkeyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_THREAD_KEYRING); \t}  Fix it by only creating a new thread keyring if there wasn't one before. To make things more consistent, make install_thread_keyring_to_cred() and install_process_keyring_to_cred() both return 0 if the corresponding keyring is already present.  Cc: stable@vger.kernel.org # 2.6.29+",
        "func_before": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\n\treturn commit_creds(new);\n}",
        "func": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \tret = install_process_keyring_to_cred(new);\n \tif (ret < 0) {\n \t\tabort_creds(new);\n-\t\treturn ret != -EEXIST ? ret : 0;\n+\t\treturn ret;\n \t}\n \n \treturn commit_creds(new);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn ret != -EEXIST ? ret : 0;"
            ],
            "added_lines": [
                "\t\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7472",
        "func_name": "torvalds/linux/install_process_keyring_to_cred",
        "description": "The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.",
        "git_url": "https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b",
        "commit_title": "KEYS: fix keyctl_set_reqkey_keyring() to not leak thread keyrings",
        "commit_text": " This fixes CVE-2017-7472.  Running the following program as an unprivileged user exhausts kernel memory by leaking thread keyrings:  \t#include <keyutils.h>  \tint main() \t{ \t\tfor (;;) \t\t\tkeyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_THREAD_KEYRING); \t}  Fix it by only creating a new thread keyring if there wasn't one before. To make things more consistent, make install_thread_keyring_to_cred() and install_process_keyring_to_cred() both return 0 if the corresponding keyring is already present.  Cc: stable@vger.kernel.org # 2.6.29+",
        "func_before": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}",
        "func": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tstruct key *keyring;\n \n \tif (new->process_keyring)\n-\t\treturn -EEXIST;\n+\t\treturn 0;\n \n \tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n \t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn -EEXIST;"
            ],
            "added_lines": [
                "\t\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7472",
        "func_name": "torvalds/linux/install_thread_keyring_to_cred",
        "description": "The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.",
        "git_url": "https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b",
        "commit_title": "KEYS: fix keyctl_set_reqkey_keyring() to not leak thread keyrings",
        "commit_text": " This fixes CVE-2017-7472.  Running the following program as an unprivileged user exhausts kernel memory by leaking thread keyrings:  \t#include <keyutils.h>  \tint main() \t{ \t\tfor (;;) \t\t\tkeyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_THREAD_KEYRING); \t}  Fix it by only creating a new thread keyring if there wasn't one before. To make things more consistent, make install_thread_keyring_to_cred() and install_process_keyring_to_cred() both return 0 if the corresponding keyring is already present.  Cc: stable@vger.kernel.org # 2.6.29+",
        "func_before": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}",
        "func": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n int install_thread_keyring_to_cred(struct cred *new)\n {\n \tstruct key *keyring;\n+\n+\tif (new->thread_keyring)\n+\t\treturn 0;\n \n \tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n \t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (new->thread_keyring)",
                "\t\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7472",
        "func_name": "torvalds/linux/install_thread_keyring",
        "description": "The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.",
        "git_url": "https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b",
        "commit_title": "KEYS: fix keyctl_set_reqkey_keyring() to not leak thread keyrings",
        "commit_text": " This fixes CVE-2017-7472.  Running the following program as an unprivileged user exhausts kernel memory by leaking thread keyrings:  \t#include <keyutils.h>  \tint main() \t{ \t\tfor (;;) \t\t\tkeyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_THREAD_KEYRING); \t}  Fix it by only creating a new thread keyring if there wasn't one before. To make things more consistent, make install_thread_keyring_to_cred() and install_process_keyring_to_cred() both return 0 if the corresponding keyring is already present.  Cc: stable@vger.kernel.org # 2.6.29+",
        "func_before": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(new->thread_keyring);\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}",
        "func": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,6 @@\n \tif (!new)\n \t\treturn -ENOMEM;\n \n-\tBUG_ON(new->thread_keyring);\n-\n \tret = install_thread_keyring_to_cred(new);\n \tif (ret < 0) {\n \t\tabort_creds(new);",
        "diff_line_info": {
            "deleted_lines": [
                "\tBUG_ON(new->thread_keyring);",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-8925",
        "func_name": "torvalds/linux/omninet_open",
        "description": "The omninet_open function in drivers/usb/serial/omninet.c in the Linux kernel before 4.10.4 allows local users to cause a denial of service (tty exhaustion) by leveraging reference count mishandling.",
        "git_url": "https://github.com/torvalds/linux/commit/30572418b445d85fcfe6c8fe84c947d2606767d8",
        "commit_title": "USB: serial: omninet: fix reference leaks at open",
        "commit_text": " This driver needlessly took another reference to the tty on open, a reference which was then never released on close. This lead to not just a leak of the tty, but also a driver reference leak that prevented the driver from being unloaded after a port had once been opened.  Cc: stable <stable@vger.kernel.org>\t# 2.6.28",
        "func_before": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\n\treturn usb_serial_generic_open(tty, port);\n}",
        "func": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\treturn usb_serial_generic_open(tty, port);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,4 @@\n static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n {\n-\tstruct usb_serial\t*serial = port->serial;\n-\tstruct usb_serial_port\t*wport;\n-\n-\twport = serial->port[1];\n-\ttty_port_tty_set(&wport->port, tty);\n-\n \treturn usb_serial_generic_open(tty, port);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct usb_serial\t*serial = port->serial;",
                "\tstruct usb_serial_port\t*wport;",
                "",
                "\twport = serial->port[1];",
                "\ttty_port_tty_set(&wport->port, tty);",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-3957",
        "func_name": "gpac/load_svg_run",
        "description": "A vulnerability classified as problematic was found in GPAC. Affected by this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads to memory leak. The attack can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-213463.",
        "git_url": "https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb",
        "commit_title": "fixed mem leak in sgv parse error",
        "commit_text": "",
        "func_before": "GF_Err load_svg_run(GF_SceneLoader *load)\n{\n\tu32 in_time;\n\tGF_Err e;\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)load->loader_priv;\n\n\tif (!parser) {\n\t\te = gf_sm_load_initialize_svg(load, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t\tparser = (GF_SVG_Parser *)load->loader_priv;\n\t}\n\n\tin_time = gf_sys_clock();\n\te = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);\n\tif (parser->last_error<0) e = parser->last_error;\n\t\n\tif (e<0) return svg_report(parser, e, \"Unable to parse file %s: %s\", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[Parser] Scene parsed and Scene Graph built in %d ms\\n\", gf_sys_clock() - in_time));\n\n\tsvg_flush_animations(parser);\n\tgf_sm_svg_flush_state(parser);\n\treturn e;\n\n}",
        "func": "GF_Err load_svg_run(GF_SceneLoader *load)\n{\n\tu32 in_time;\n\tGF_Err e;\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)load->loader_priv;\n\n\tif (!parser) {\n\t\te = gf_sm_load_initialize_svg(load, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t\tparser = (GF_SVG_Parser *)load->loader_priv;\n\t}\n\n\tin_time = gf_sys_clock();\n\te = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);\n\tsvg_flush_animations(parser);\n\tgf_sm_svg_flush_state(parser);\n\tif (parser->last_error<0) e = parser->last_error;\n\n\tif (e<0) return svg_report(parser, e, \"Unable to parse file %s: %s\", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[Parser] Scene parsed and Scene Graph built in %d ms\\n\", gf_sys_clock() - in_time));\n\n\treturn e;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,13 +12,13 @@\n \n \tin_time = gf_sys_clock();\n \te = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);\n+\tsvg_flush_animations(parser);\n+\tgf_sm_svg_flush_state(parser);\n \tif (parser->last_error<0) e = parser->last_error;\n-\t\n+\n \tif (e<0) return svg_report(parser, e, \"Unable to parse file %s: %s\", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );\n \tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[Parser] Scene parsed and Scene Graph built in %d ms\\n\", gf_sys_clock() - in_time));\n \n-\tsvg_flush_animations(parser);\n-\tgf_sm_svg_flush_state(parser);\n \treturn e;\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t",
                "\tsvg_flush_animations(parser);",
                "\tgf_sm_svg_flush_state(parser);"
            ],
            "added_lines": [
                "\tsvg_flush_animations(parser);",
                "\tgf_sm_svg_flush_state(parser);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3957",
        "func_name": "gpac/svg_parse_animation",
        "description": "A vulnerability classified as problematic was found in GPAC. Affected by this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads to memory leak. The attack can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-213463.",
        "git_url": "https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb",
        "commit_title": "fixed mem leak in sgv parse error",
        "commit_text": "",
        "func_before": "static Bool svg_parse_animation(GF_SVG_Parser *parser, GF_SceneGraph *sg, SVG_DeferredAnimation *anim, const char *nodeID, u32 force_type)\n{\n\tGF_FieldInfo info;\n\tu32 tag;\n\tu8 anim_value_type = 0;\n\n\tif (!anim->animation_elt)\n\t\treturn GF_FALSE;\n\tif (anim->resolve_stage==0) {\n\t\t/* Stage 0: parsing the animation attribute values\n\t\t\t\t\tfor that we need to resolve the target first */\n\n\t\t/* if we don't have a target, try to get it */\n\t\tif (!anim->target && anim->target_id)\n\t\t\tanim->target = (SVG_Element *) gf_sg_find_node_by_name(sg, anim->target_id + 1);\n\n\t\t/* if now we have a target, create the xlink:href attribute on the animation element and set it to the found target */\n\t\tif (anim->target) {\n\t\t\tXMLRI *iri;\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_XLINK_ATT_href, GF_TRUE, GF_FALSE, &info);\n\t\t\tiri = (XMLRI *)info.far_ptr;\n\t\t\tiri->type = XMLRI_ELEMENTID;\n\t\t\tiri->target = anim->target;\n\t\t\tgf_node_register_iri(sg, iri);\n\t\t}\n\n\t\ttag = gf_node_get_tag((GF_Node *)anim->animation_elt);\n\t\t/* get the attribute name attribute if specified */\n\t\tif (anim->type && (tag== TAG_SVG_animateTransform) ) {\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_transform_type, GF_TRUE, GF_FALSE, &info);\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->type, 0);\n\t\t\tswitch(*(SVG_TransformType *) info.far_ptr) {\n\t\t\tcase SVG_TRANSFORM_TRANSLATE:\n\t\t\t\tanim_value_type = SVG_Transform_Translate_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_SCALE:\n\t\t\t\tanim_value_type = SVG_Transform_Scale_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_ROTATE:\n\t\t\t\tanim_value_type = SVG_Transform_Rotate_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_SKEWX:\n\t\t\t\tanim_value_type = SVG_Transform_SkewX_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_SKEWY:\n\t\t\t\tanim_value_type = SVG_Transform_SkewY_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_MATRIX:\n\t\t\t\tanim_value_type = SVG_Transform_datatype;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsvg_report(parser, GF_OK, \"unknown datatype for animate transform\");\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\telse if (gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_attributeName, GF_FALSE, GF_FALSE, &info) == GF_OK) {\n\t\t\tSMIL_AttributeName *attname = (SMIL_AttributeName *)info.far_ptr;\n\n\t\t\t/*parse the attribute name even if the target is not found, because a namespace could be specified and\n\t\t\tonly valid for the current node*/\n\t\t\tif (!attname->type) {\n\t\t\t\tchar *sep;\n\t\t\t\tchar *name = attname->name;\n\t\t\t\tsep = strchr(name, ':');\n\t\t\t\tif (sep) {\n\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\tattname->type = gf_sg_get_namespace_code(anim->animation_elt->sgprivate->scenegraph, name);\n\t\t\t\t\tsep[0] = ':';\n\t\t\t\t\tname = gf_strdup(sep+1);\n\t\t\t\t\tgf_free(attname->name);\n\t\t\t\t\tattname->name = name;\n\t\t\t\t} else {\n\t\t\t\t\tattname->type = parser->current_ns;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* the target is still not known stay in stage 0 */\n\t\t\tif (!anim->target) return GF_FALSE;\n\n\t\t\tgf_node_get_attribute_by_name((GF_Node *)anim->target, attname->name, attname->type, GF_TRUE, GF_TRUE, &info);\n\t\t\t/*set the tag value to avoid parsing the name in the anim node_init phase*/\n\t\t\tattname->tag = info.fieldIndex;\n\t\t\tattname->type = 0;\n\t\t\tanim_value_type = info.fieldType;\n\t\t} else {\n\t\t\tif (tag == TAG_SVG_animateMotion) {\n\t\t\t\tanim_value_type = SVG_Motion_datatype;\n\t\t\t} else if (tag == TAG_SVG_discard) {\n\t\t\t\t/* there is no value to parse in discard, we can jump to the next stage */\n\t\t\t\tanim->resolve_stage = 1;\n\t\t\t\treturn svg_parse_animation(parser, sg, anim, nodeID, 0);\n\t\t\t} else {\n\t\t\t\tsvg_report(parser, GF_OK, \"Missing attributeName attribute on %s\", gf_node_get_name((GF_Node *)anim->animation_elt));\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/* the target is still not known stay in stage 0 */\n\t\tif (!anim->target) return GF_FALSE;\n\n\t\tif (anim->to) {\n\t\t\t/* now that we have a target, if there is a to value to parse, create the attribute and parse it */\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_to, GF_TRUE, GF_FALSE, &info);\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->to, anim_value_type);\n\t\t\tif (anim_value_type==XMLRI_datatype) {\n\t\t\t\tsvg_post_process_href(parser, (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n\t\t\t}\n\t\t}\n\t\tif (anim->from) {\n\t\t\t/* now that we have a target, if there is a from value to parse, create the attribute and parse it */\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_from, GF_TRUE, GF_FALSE, &info);\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->from, anim_value_type);\n\t\t\tif (anim_value_type==XMLRI_datatype)\n\t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n\t\t}\n\t\tif (anim->by) {\n\t\t\t/* now that we have a target, if there is a by value to parse, create the attribute and parse it */\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_by, GF_TRUE, GF_FALSE, &info);\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->by, anim_value_type);\n\t\t\tif (anim_value_type==XMLRI_datatype)\n\t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n\t\t}\n\t\tif (anim->values) {\n\t\t\t/* now that we have a target, if there is a 'values' value to parse, create the attribute and parse it */\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_values, GF_TRUE, GF_FALSE, &info);\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->values, anim_value_type);\n\t\t\tif (anim_value_type==XMLRI_datatype) {\n\t\t\t\tu32 i, count;\n\t\t\t\tSMIL_AnimateValues *anim_values;\n\t\t\t\tanim_values = (SMIL_AnimateValues *)info.far_ptr;\n\t\t\t\tcount = gf_list_count(anim_values->values);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tXMLRI *iri = (XMLRI *)gf_list_get(anim_values->values, i);\n\t\t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, iri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tanim->resolve_stage = 1;\n\t}\n\n\tif (anim->resolve_stage == 1) {\n\t\t/* Stage 1: parsing the begin values\n\t\t\t\t\twe go into the next stage only if at least one begin value is resolved */\n\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_begin, GF_TRUE, GF_FALSE, &info);\n\t\tif (gf_svg_resolve_smil_times((GF_Node *)anim->animation_elt, anim->target, *(GF_List **)info.far_ptr, GF_FALSE, nodeID)) {\n\t\t\tanim->resolve_stage = 2;\n\t\t} else if (force_type!=2) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_end, GF_TRUE, GF_FALSE, &info);\n\tif (!gf_svg_resolve_smil_times((GF_Node *)anim->animation_elt, anim->target, *(GF_List **)info.far_ptr, GF_TRUE, nodeID)) {\n\t\tif (force_type!=2) return GF_FALSE;\n\t}\n\n\t/*animateMotion needs its children to be parsed before it can be initialized !! */\n\tif (force_type || gf_node_get_tag((GF_Node *)anim->animation_elt) != TAG_SVG_animateMotion) {\n\t\tgf_node_init((GF_Node *)anim->animation_elt);\n\t\treturn GF_TRUE;\n\t} else {\n\t\treturn GF_FALSE;\n\t}\n\n}",
        "func": "static Bool svg_parse_animation(GF_SVG_Parser *parser, GF_SceneGraph *sg, SVG_DeferredAnimation *anim, const char *nodeID, u32 force_type)\n{\n\tGF_FieldInfo info;\n\tu32 tag;\n\tu8 anim_value_type = 0;\n\n\tif (!anim->animation_elt)\n\t\treturn GF_FALSE;\n\tif (anim->resolve_stage==0) {\n\t\t/* Stage 0: parsing the animation attribute values\n\t\t\t\t\tfor that we need to resolve the target first */\n\n\t\t/* if we don't have a target, try to get it */\n\t\tif (!anim->target && anim->target_id)\n\t\t\tanim->target = (SVG_Element *) gf_sg_find_node_by_name(sg, anim->target_id + 1);\n\n\t\t/* if now we have a target, create the xlink:href attribute on the animation element and set it to the found target */\n\t\tif (anim->target) {\n\t\t\tXMLRI *iri;\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_XLINK_ATT_href, GF_TRUE, GF_FALSE, &info);\n\t\t\tiri = (XMLRI *)info.far_ptr;\n\t\t\tiri->type = XMLRI_ELEMENTID;\n\t\t\tiri->target = anim->target;\n\t\t\tgf_node_register_iri(sg, iri);\n\t\t}\n\n\t\ttag = gf_node_get_tag((GF_Node *)anim->animation_elt);\n\t\t/* get the attribute name attribute if specified */\n\t\tif (anim->type && (tag== TAG_SVG_animateTransform) ) {\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_transform_type, GF_TRUE, GF_FALSE, &info);\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->type, 0);\n\t\t\tswitch(*(SVG_TransformType *) info.far_ptr) {\n\t\t\tcase SVG_TRANSFORM_TRANSLATE:\n\t\t\t\tanim_value_type = SVG_Transform_Translate_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_SCALE:\n\t\t\t\tanim_value_type = SVG_Transform_Scale_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_ROTATE:\n\t\t\t\tanim_value_type = SVG_Transform_Rotate_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_SKEWX:\n\t\t\t\tanim_value_type = SVG_Transform_SkewX_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_SKEWY:\n\t\t\t\tanim_value_type = SVG_Transform_SkewY_datatype;\n\t\t\t\tbreak;\n\t\t\tcase SVG_TRANSFORM_MATRIX:\n\t\t\t\tanim_value_type = SVG_Transform_datatype;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsvg_report(parser, GF_OK, \"unknown datatype for animate transform\");\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\telse if (gf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_attributeName, GF_FALSE, GF_FALSE, &info) == GF_OK) {\n\t\t\tSMIL_AttributeName *attname = (SMIL_AttributeName *)info.far_ptr;\n\n\t\t\t/*parse the attribute name even if the target is not found, because a namespace could be specified and\n\t\t\tonly valid for the current node*/\n\t\t\tif (!attname->type) {\n\t\t\t\tchar *sep;\n\t\t\t\tchar *name = attname->name;\n\t\t\t\tsep = strchr(name, ':');\n\t\t\t\tif (sep) {\n\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\tattname->type = gf_sg_get_namespace_code(anim->animation_elt->sgprivate->scenegraph, name);\n\t\t\t\t\tsep[0] = ':';\n\t\t\t\t\tname = gf_strdup(sep+1);\n\t\t\t\t\tgf_free(attname->name);\n\t\t\t\t\tattname->name = name;\n\t\t\t\t} else {\n\t\t\t\t\tattname->type = parser->current_ns;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* the target is still not known stay in stage 0 */\n\t\t\tif (!anim->target) return GF_FALSE;\n\n\t\t\tgf_node_get_attribute_by_name((GF_Node *)anim->target, attname->name, attname->type, GF_TRUE, GF_TRUE, &info);\n\t\t\t/*set the tag value to avoid parsing the name in the anim node_init phase*/\n\t\t\tattname->tag = info.fieldIndex;\n\t\t\tattname->type = 0;\n\t\t\tanim_value_type = info.fieldType;\n\t\t} else {\n\t\t\tif (tag == TAG_SVG_animateMotion) {\n\t\t\t\tanim_value_type = SVG_Motion_datatype;\n\t\t\t} else if (tag == TAG_SVG_discard) {\n\t\t\t\t/* there is no value to parse in discard, we can jump to the next stage */\n\t\t\t\tanim->resolve_stage = 1;\n\t\t\t\treturn svg_parse_animation(parser, sg, anim, nodeID, 0);\n\t\t\t} else {\n\t\t\t\tsvg_report(parser, GF_OK, \"Missing attributeName attribute on %s\", gf_node_get_name((GF_Node *)anim->animation_elt));\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\t/* the target is still not known stay in stage 0 */\n\t\tif (!anim->target) return GF_FALSE;\n\n\t\tif (anim->to) {\n\t\t\t/* now that we have a target, if there is a to value to parse, create the attribute and parse it */\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_to, GF_TRUE, GF_FALSE, &info);\n\t\t\tif (!info.name) info.name = \"to\";\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->to, anim_value_type);\n\t\t\tif (anim_value_type==XMLRI_datatype) {\n\t\t\t\tsvg_post_process_href(parser, (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n\t\t\t}\n\t\t}\n\t\tif (anim->from) {\n\t\t\t/* now that we have a target, if there is a from value to parse, create the attribute and parse it */\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_from, GF_TRUE, GF_FALSE, &info);\n\t\t\tif (!info.name) info.name = \"from\";\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->from, anim_value_type);\n\t\t\tif (anim_value_type==XMLRI_datatype)\n\t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n\t\t}\n\t\tif (anim->by) {\n\t\t\t/* now that we have a target, if there is a by value to parse, create the attribute and parse it */\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_by, GF_TRUE, GF_FALSE, &info);\n\t\t\tif (!info.name) info.name = \"by\";\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->by, anim_value_type);\n\t\t\tif (anim_value_type==XMLRI_datatype)\n\t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n\t\t}\n\t\tif (anim->values) {\n\t\t\t/* now that we have a target, if there is a 'values' value to parse, create the attribute and parse it */\n\t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_values, GF_TRUE, GF_FALSE, &info);\n\t\t\tif (!info.name) info.name = \"values\";\n\t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->values, anim_value_type);\n\t\t\tif (anim_value_type==XMLRI_datatype) {\n\t\t\t\tu32 i, count;\n\t\t\t\tSMIL_AnimateValues *anim_values;\n\t\t\t\tanim_values = (SMIL_AnimateValues *)info.far_ptr;\n\t\t\t\tcount = gf_list_count(anim_values->values);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tXMLRI *iri = (XMLRI *)gf_list_get(anim_values->values, i);\n\t\t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, iri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tanim->resolve_stage = 1;\n\t}\n\n\tif (anim->resolve_stage == 1) {\n\t\t/* Stage 1: parsing the begin values\n\t\t\t\t\twe go into the next stage only if at least one begin value is resolved */\n\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_begin, GF_TRUE, GF_FALSE, &info);\n\t\tif (gf_svg_resolve_smil_times((GF_Node *)anim->animation_elt, anim->target, *(GF_List **)info.far_ptr, GF_FALSE, nodeID)) {\n\t\t\tanim->resolve_stage = 2;\n\t\t} else if (force_type!=2) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\n\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_end, GF_TRUE, GF_FALSE, &info);\n\tif (!gf_svg_resolve_smil_times((GF_Node *)anim->animation_elt, anim->target, *(GF_List **)info.far_ptr, GF_TRUE, nodeID)) {\n\t\tif (force_type!=2) return GF_FALSE;\n\t}\n\n\t/*animateMotion needs its children to be parsed before it can be initialized !! */\n\tif (force_type || gf_node_get_tag((GF_Node *)anim->animation_elt) != TAG_SVG_animateMotion) {\n\t\tgf_node_init((GF_Node *)anim->animation_elt);\n\t\treturn GF_TRUE;\n\t} else {\n\t\treturn GF_FALSE;\n\t}\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -101,6 +101,7 @@\n \t\tif (anim->to) {\n \t\t\t/* now that we have a target, if there is a to value to parse, create the attribute and parse it */\n \t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_to, GF_TRUE, GF_FALSE, &info);\n+\t\t\tif (!info.name) info.name = \"to\";\n \t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->to, anim_value_type);\n \t\t\tif (anim_value_type==XMLRI_datatype) {\n \t\t\t\tsvg_post_process_href(parser, (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n@@ -109,6 +110,7 @@\n \t\tif (anim->from) {\n \t\t\t/* now that we have a target, if there is a from value to parse, create the attribute and parse it */\n \t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_from, GF_TRUE, GF_FALSE, &info);\n+\t\t\tif (!info.name) info.name = \"from\";\n \t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->from, anim_value_type);\n \t\t\tif (anim_value_type==XMLRI_datatype)\n \t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n@@ -116,6 +118,7 @@\n \t\tif (anim->by) {\n \t\t\t/* now that we have a target, if there is a by value to parse, create the attribute and parse it */\n \t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_by, GF_TRUE, GF_FALSE, &info);\n+\t\t\tif (!info.name) info.name = \"by\";\n \t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->by, anim_value_type);\n \t\t\tif (anim_value_type==XMLRI_datatype)\n \t\t\t\tsvg_post_process_href(parser,  (GF_Node *) anim->target, (XMLRI*)((SMIL_AnimateValue *)info.far_ptr)->value);\n@@ -123,6 +126,7 @@\n \t\tif (anim->values) {\n \t\t\t/* now that we have a target, if there is a 'values' value to parse, create the attribute and parse it */\n \t\t\tgf_node_get_attribute_by_tag((GF_Node *)anim->animation_elt, TAG_SVG_ATT_values, GF_TRUE, GF_FALSE, &info);\n+\t\t\tif (!info.name) info.name = \"values\";\n \t\t\tgf_svg_parse_attribute((GF_Node *)anim->animation_elt, &info, anim->values, anim_value_type);\n \t\t\tif (anim_value_type==XMLRI_datatype) {\n \t\t\t\tu32 i, count;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif (!info.name) info.name = \"to\";",
                "\t\t\tif (!info.name) info.name = \"from\";",
                "\t\t\tif (!info.name) info.name = \"by\";",
                "\t\t\tif (!info.name) info.name = \"values\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3957",
        "func_name": "gpac/gf_svg_parse_attribute",
        "description": "A vulnerability classified as problematic was found in GPAC. Affected by this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads to memory leak. The attack can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-213463.",
        "git_url": "https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb",
        "commit_title": "fixed mem leak in sgv parse error",
        "commit_text": "",
        "func_before": "GF_EXPORT\nGF_Err gf_svg_parse_attribute(GF_Node *n, GF_FieldInfo *info, char *attribute_content, u8 anim_value_type)\n{\n\tGF_Err e = GF_OK;\n\t/* for all attributes, except strings, apply some sort of white space normalization*/\n\tif (info->fieldType != DOM_String_datatype && strlen(attribute_content)) {\n\t\tu32 i, len;\n\t\t/*remove spaces at the beginning*/\n\t\twhile (attribute_content[0] && (strchr(\"\\r\\n\\t \", attribute_content[0])))\n\t\t\tattribute_content++;\n\n\t\t/*change all special chars in spaces*/\n\t\ti=0;\n\t\tlen = (u32) strlen(attribute_content);\n\t\twhile (i<len) {\n\t\t\tif (strchr(\"\\r\\n\\t\", attribute_content[i]))\n\t\t\t\tattribute_content[i] = ' ';\n\t\t\ti++;\n\t\t}\n\t\t/*remove spaces in the end*/\n\t\twhile (len && attribute_content[len-1]==' ') {\n\t\t\tattribute_content[len-1] = 0;\n\t\t\tlen--;\n\t\t}\n\t}\n\n\tswitch (info->fieldType) {\n\tcase SVG_Boolean_datatype:\n\t\tsvg_parse_boolean((SVG_Boolean *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Color_datatype:\n\t\tsvg_parse_color((SVG_Color *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Paint_datatype:\n\t\tsvg_parse_paint(n, (SVG_Paint *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\n\t/* beginning of keyword type parsing */\n\tcase SVG_FillRule_datatype:\n\t\tsvg_parse_clipfillrule((SVG_FillRule *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_StrokeLineJoin_datatype:\n\t\tsvg_parse_strokelinejoin((SVG_StrokeLineJoin *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_StrokeLineCap_datatype:\n\t\tsvg_parse_strokelinecap((SVG_StrokeLineCap *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_FontStyle_datatype:\n\t\tsvg_parse_fontstyle((SVG_FontStyle *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_FontWeight_datatype:\n\t\tsvg_parse_fontweight((SVG_FontWeight *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_FontVariant_datatype:\n\t\tsvg_parse_fontvariant((SVG_FontVariant *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TextAnchor_datatype:\n\t\tsvg_parse_textanchor((SVG_TextAnchor *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Display_datatype:\n\t\tsvg_parse_display((SVG_Display *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Visibility_datatype:\n\t\tsvg_parse_visibility((SVG_Visibility *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Overflow_datatype:\n\t\tsvg_parse_overflow((SVG_Overflow *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_ZoomAndPan_datatype:\n\t\tsvg_parse_zoomandpan((SVG_ZoomAndPan *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_DisplayAlign_datatype:\n\t\tsvg_parse_displayalign((SVG_DisplayAlign *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TextAlign_datatype:\n\t\tsvg_parse_textalign((SVG_TextAlign *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_PointerEvents_datatype:\n\t\tsvg_parse_pointerevents((SVG_PointerEvents *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_RenderingHint_datatype:\n\t\tsvg_parse_renderinghint((SVG_RenderingHint *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_VectorEffect_datatype:\n\t\tsvg_parse_vectoreffect((SVG_VectorEffect *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_PlaybackOrder_datatype:\n\t\tsvg_parse_playbackorder((SVG_PlaybackOrder *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TimelineBegin_datatype:\n\t\tsvg_parse_timelinebegin((SVG_TimelineBegin *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase XML_Space_datatype:\n\t\tsvg_parse_xmlspace((XML_Space *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase XMLEV_Propagate_datatype:\n\t\tsvg_parse_xmlev_propagate((XMLEV_Propagate *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase XMLEV_DefaultAction_datatype:\n\t\tsvg_parse_xmlev_defaultAction((XMLEV_DefaultAction *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase XMLEV_Phase_datatype:\n\t\tsvg_parse_xmlev_phase((XMLEV_Phase *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_SyncBehavior_datatype:\n\t\tsmil_parse_syncBehaviorOrDefault((SMIL_SyncBehavior *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_SyncTolerance_datatype:\n\t\tsmil_parse_syncToleranceOrDefault((SMIL_SyncTolerance *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_AttributeType_datatype:\n\t\tsmil_parse_attributeType((SMIL_AttributeType *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_CalcMode_datatype:\n\t\tsmil_parse_calcmode((SMIL_CalcMode *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_Additive_datatype:\n\t\tsmil_parse_additive((SMIL_CalcMode *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_Accumulate_datatype:\n\t\tsmil_parse_accumulate((SMIL_Accumulate *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_Restart_datatype:\n\t\tsmil_parse_restart((SMIL_Restart *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_Fill_datatype:\n\t\tsmil_parse_fill((SMIL_Fill *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_GradientUnit_datatype:\n\t\tif (!strcmp(attribute_content, \"userSpaceOnUse\"))\n\t\t\t*((SVG_GradientUnit *)info->far_ptr) = SVG_GRADIENTUNITS_USER;\n\t\telse if (!strcmp(attribute_content, \"objectBoundingBox\"))\n\t\t\t*((SVG_GradientUnit *)info->far_ptr) = SVG_GRADIENTUNITS_OBJECT;\n\t\telse\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\tcase SVG_FocusHighlight_datatype:\n\t\tsvg_parse_focushighlight((SVG_FocusHighlight*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Focusable_datatype:\n\t\tsvg_parse_focusable((SVG_Focusable*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_InitialVisibility_datatype:\n\t\tsvg_parse_initialvisibility((SVG_InitialVisibility*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Overlay_datatype:\n\t\tsvg_parse_overlay((SVG_Overlay*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TransformBehavior_datatype:\n\t\tsvg_parse_transformbehavior((SVG_TransformBehavior*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_SpreadMethod_datatype:\n\t\tif (!strcmp(attribute_content, \"reflect\")) *(u8*)info->far_ptr = SVG_SPREAD_REFLECT;\n\t\telse if (!strcmp(attribute_content, \"repeat\")) *(u8*)info->far_ptr = SVG_SPREAD_REPEAT;\n\t\telse if (!strcmp(attribute_content, \"pad\")) *(u8*)info->far_ptr = SVG_SPREAD_PAD;\n\t\telse e = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\tcase SVG_Filter_TransferType_datatype:\n\t\tif (!strcmp(attribute_content, \"table\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_TABLE;\n\t\telse if (!strcmp(attribute_content, \"discrete\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_DISCRETE;\n\t\telse if (!strcmp(attribute_content, \"linear\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_LINEAR;\n\t\telse if (!strcmp(attribute_content, \"gamma\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_GAMMA;\n\t\telse if (!strcmp(attribute_content, \"identity\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_IDENTITY;\n\t\telse if (!strcmp(attribute_content, \"fractalNoise\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_FRACTAL_NOISE;\n\t\telse if (!strcmp(attribute_content, \"turbulence\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_TURBULENCE;\n\t\telse if (!strcmp(attribute_content, \"matrix\")) *(u8*)info->far_ptr = SVG_FILTER_MX_MATRIX;\n\t\telse if (!strcmp(attribute_content, \"saturate\")) *(u8*)info->far_ptr = SVG_FILTER_MX_SATURATE;\n\t\telse if (!strcmp(attribute_content, \"hueRotate\")) *(u8*)info->far_ptr = SVG_FILTER_HUE_ROTATE;\n\t\telse if (!strcmp(attribute_content, \"luminanceToAlpha\")) *(u8*)info->far_ptr = SVG_FILTER_LUM_TO_ALPHA;\n\t\telse e = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\n\t/* end of keyword type parsing */\n\n\t/* keyword | numbers (with possibly units) */\n\tcase SVG_Length_datatype:\n\tcase SVG_Coordinate_datatype:\n\tcase SVG_FontSize_datatype:\n\tcase SVG_Rotate_datatype:\n\tcase SVG_Number_datatype:\n\t\tsvg_parse_length((SVG_Number*)info->far_ptr, attribute_content, 0, &e);\n\t\tbreak;\n\n\tcase SMIL_AnimateValue_datatype:\n\t\tsvg_parse_one_anim_value(n, (SMIL_AnimateValue*)info->far_ptr, attribute_content, anim_value_type, &e);\n\t\tbreak;\n\tcase SMIL_AnimateValues_datatype:\n\t\tsvg_parse_anim_values(n, (SMIL_AnimateValues*)info->far_ptr, attribute_content, anim_value_type, &e);\n\t\tbreak;\n\n\tcase XMLRI_datatype:\n\t\tsvg_parse_iri(n, (XMLRI*)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase XML_IDREF_datatype:\n\t\tsvg_parse_idref(n, (XMLRI*)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase SMIL_AttributeName_datatype:\n\t\t((SMIL_AttributeName *)info->far_ptr)->name = gf_strdup(attribute_content);\n\t\tbreak;\n\tcase SMIL_Times_datatype:\n\t\tsmil_parse_time_list(n, *(GF_List **)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase SMIL_Duration_datatype:\n\t\tsmil_parse_min_max_dur_repeatdur((SMIL_Duration*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_RepeatCount_datatype:\n\t\tsmil_parse_repeatcount((SMIL_RepeatCount*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_PathData_datatype:\n\t\tsvg_parse_path((SVG_PathData*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Points_datatype:\n\t\tsvg_parse_points(*(GF_List **)(info->far_ptr), attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_KeyTimes_datatype:\n\tcase SMIL_KeyPoints_datatype:\n\tcase SMIL_KeySplines_datatype:\n\tcase SVG_Numbers_datatype:\n\t\tsvg_parse_numbers(*(GF_List **)(info->far_ptr), attribute_content, 0, &e);\n\t\tbreak;\n\tcase SVG_Coordinates_datatype:\n\t\tsvg_parse_coordinates(*(GF_List **)(info->far_ptr), attribute_content, &e);\n\t\tbreak;\n\tcase SVG_ViewBox_datatype:\n\t\tsvg_parse_viewbox((SVG_ViewBox*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_StrokeDashArray_datatype:\n\t\tsvg_parse_strokedasharray((SVG_StrokeDashArray*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_FontFamily_datatype:\n\t\tsvg_parse_fontfamily((SVG_FontFamily*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Motion_datatype:\n\t\tsvg_parse_point_into_matrix((GF_Matrix2D*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Transform_datatype:\n\t\te = svg_parse_transform((SVG_Transform*)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase SVG_Transform_Translate_datatype:\n\t{\n\t\tu32 i = 0;\n\t\tSVG_Point *p = (SVG_Point *)info->far_ptr;\n\t\ti+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);\n\t\tif (attribute_content[i] == 0) {\n\t\t\tp->y = 0;\n\t\t} else {\n\t\t\t/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);\n\t\t}\n\t}\n\tbreak;\n\tcase SVG_Transform_Scale_datatype:\n\t{\n\t\tu32 i = 0;\n\t\tSVG_Point *p = (SVG_Point *)info->far_ptr;\n\t\ti+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);\n\t\tif (attribute_content[i] == 0) {\n\t\t\tp->y = p->x;\n\t\t} else {\n\t\t\t/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);\n\t\t}\n\t}\n\tbreak;\n\tcase SVG_Transform_SkewX_datatype:\n\tcase SVG_Transform_SkewY_datatype:\n\t{\n\t\tFixed *p = (Fixed *)info->far_ptr;\n\t\tsvg_parse_number(attribute_content, p, 1, &e);\n\t}\n\tbreak;\n\tcase SVG_Transform_Rotate_datatype:\n\t{\n\t\tu32 i = 0;\n\t\tSVG_Point_Angle *p = (SVG_Point_Angle *)info->far_ptr;\n\t\ti+=svg_parse_number(&(attribute_content[i]), &(p->angle), 1, &e);\n\t\tif (attribute_content[i] == 0) {\n\t\t\tp->y = p->x = 0;\n\t\t} else {\n\t\t\ti+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);\n\t\t\t/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);\n\t\t}\n\t}\n\tbreak;\n\tcase SVG_PreserveAspectRatio_datatype:\n\t\tsvg_parse_preserveaspectratio((SVG_PreserveAspectRatio*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TransformType_datatype:\n\t\tsvg_parse_animatetransform_type((SVG_TransformType*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\n\tcase SVG_ID_datatype:\n\tcase DOM_String_datatype:\n\tcase SVG_ContentType_datatype:\n\tcase SVG_LanguageID_datatype:\n\t\tif (*(SVG_String *)info->far_ptr) gf_free(*(SVG_String *)info->far_ptr);\n\n\t\t*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);\n\t\tbreak;\n\n\tcase DOM_StringList_datatype:\n\t\tsvg_parse_strings(*(GF_List **)info->far_ptr, attribute_content, 0);\n\t\tbreak;\n\tcase XMLRI_List_datatype:\n\t\tsvg_parse_strings(*(GF_List **)info->far_ptr, attribute_content, 1);\n\t\tbreak;\n\n\tcase XMLEV_Event_datatype:\n\t{\n\t\tXMLEV_Event *xml_ev = (XMLEV_Event *)info->far_ptr;\n\t\tchar *sep = strchr(attribute_content, '(');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\txml_ev->type = gf_dom_event_type_by_name(attribute_content);\n\t\t\tsep[0] = '(';\n\t\t\tif ((xml_ev->type == GF_EVENT_REPEAT) || (xml_ev->type == GF_EVENT_REPEAT_EVENT)) {\n\t\t\t\tchar _v;\n\t\t\t\tsscanf(sep, \"(%c)\", &_v);\n\t\t\t\txml_ev->parameter = _v;\n\t\t\t} else { /* key events ... */\n\t\t\t\tchar *sep2 = strchr(attribute_content, ')');\n\t\t\t\tsep2[0] = 0;\n\t\t\t\txml_ev->parameter = gf_dom_get_key_type(sep+1);\n\t\t\t\tsep2[0] = ')';\n\t\t\t}\n\t\t} else {\n\t\t\txml_ev->parameter = 0;\n\t\t\txml_ev->type = gf_dom_event_type_by_name(attribute_content);\n\t\t}\n\t}\n\tbreak;\n\n\tcase SVG_Focus_datatype:\n\t\tsvg_parse_focus(n, (SVG_Focus*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_ClipPath_datatype:\n\t\tsvg_parse_clippath(n, (SVG_ClipPath*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\n\tcase LASeR_Choice_datatype:\n\t\te = laser_parse_choice((LASeR_Choice*)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase LASeR_Size_datatype:\n\t\te = laser_parse_size((LASeR_Size*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Clock_datatype:\n\t\tsvg_parse_clock_value(attribute_content, (SVG_Clock*)info->far_ptr);\n\t\tbreak;\n\tcase SVG_Unknown_datatype:\n\t\tif (*(SVG_String *)info->far_ptr) gf_free(*(SVG_String *)info->far_ptr);\n\t\t*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute %s\\n\", info->name ? info->name : \"\"));\n\t\tbreak;\n\t}\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute %s value %s: %s\\n\", info->name ? info->name : \"\", attribute_content, gf_error_to_string(e)));\n\t}\n\treturn e;\n}",
        "func": "GF_EXPORT\nGF_Err gf_svg_parse_attribute(GF_Node *n, GF_FieldInfo *info, char *attribute_content, u8 anim_value_type)\n{\n\tGF_Err e = GF_OK;\n\t/* for all attributes, except strings, apply some sort of white space normalization*/\n\tif (info->fieldType != DOM_String_datatype && strlen(attribute_content)) {\n\t\tu32 i, len;\n\t\t/*remove spaces at the beginning*/\n\t\twhile (attribute_content[0] && (strchr(\"\\r\\n\\t \", attribute_content[0])))\n\t\t\tattribute_content++;\n\n\t\t/*change all special chars in spaces*/\n\t\ti=0;\n\t\tlen = (u32) strlen(attribute_content);\n\t\twhile (i<len) {\n\t\t\tif (strchr(\"\\r\\n\\t\", attribute_content[i]))\n\t\t\t\tattribute_content[i] = ' ';\n\t\t\ti++;\n\t\t}\n\t\t/*remove spaces in the end*/\n\t\twhile (len && attribute_content[len-1]==' ') {\n\t\t\tattribute_content[len-1] = 0;\n\t\t\tlen--;\n\t\t}\n\t}\n\n\tswitch (info->fieldType) {\n\tcase SVG_Boolean_datatype:\n\t\tsvg_parse_boolean((SVG_Boolean *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Color_datatype:\n\t\tsvg_parse_color((SVG_Color *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Paint_datatype:\n\t\tsvg_parse_paint(n, (SVG_Paint *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\n\t/* beginning of keyword type parsing */\n\tcase SVG_FillRule_datatype:\n\t\tsvg_parse_clipfillrule((SVG_FillRule *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_StrokeLineJoin_datatype:\n\t\tsvg_parse_strokelinejoin((SVG_StrokeLineJoin *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_StrokeLineCap_datatype:\n\t\tsvg_parse_strokelinecap((SVG_StrokeLineCap *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_FontStyle_datatype:\n\t\tsvg_parse_fontstyle((SVG_FontStyle *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_FontWeight_datatype:\n\t\tsvg_parse_fontweight((SVG_FontWeight *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_FontVariant_datatype:\n\t\tsvg_parse_fontvariant((SVG_FontVariant *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TextAnchor_datatype:\n\t\tsvg_parse_textanchor((SVG_TextAnchor *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Display_datatype:\n\t\tsvg_parse_display((SVG_Display *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Visibility_datatype:\n\t\tsvg_parse_visibility((SVG_Visibility *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Overflow_datatype:\n\t\tsvg_parse_overflow((SVG_Overflow *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_ZoomAndPan_datatype:\n\t\tsvg_parse_zoomandpan((SVG_ZoomAndPan *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_DisplayAlign_datatype:\n\t\tsvg_parse_displayalign((SVG_DisplayAlign *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TextAlign_datatype:\n\t\tsvg_parse_textalign((SVG_TextAlign *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_PointerEvents_datatype:\n\t\tsvg_parse_pointerevents((SVG_PointerEvents *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_RenderingHint_datatype:\n\t\tsvg_parse_renderinghint((SVG_RenderingHint *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_VectorEffect_datatype:\n\t\tsvg_parse_vectoreffect((SVG_VectorEffect *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_PlaybackOrder_datatype:\n\t\tsvg_parse_playbackorder((SVG_PlaybackOrder *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TimelineBegin_datatype:\n\t\tsvg_parse_timelinebegin((SVG_TimelineBegin *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase XML_Space_datatype:\n\t\tsvg_parse_xmlspace((XML_Space *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase XMLEV_Propagate_datatype:\n\t\tsvg_parse_xmlev_propagate((XMLEV_Propagate *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase XMLEV_DefaultAction_datatype:\n\t\tsvg_parse_xmlev_defaultAction((XMLEV_DefaultAction *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase XMLEV_Phase_datatype:\n\t\tsvg_parse_xmlev_phase((XMLEV_Phase *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_SyncBehavior_datatype:\n\t\tsmil_parse_syncBehaviorOrDefault((SMIL_SyncBehavior *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_SyncTolerance_datatype:\n\t\tsmil_parse_syncToleranceOrDefault((SMIL_SyncTolerance *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_AttributeType_datatype:\n\t\tsmil_parse_attributeType((SMIL_AttributeType *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_CalcMode_datatype:\n\t\tsmil_parse_calcmode((SMIL_CalcMode *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_Additive_datatype:\n\t\tsmil_parse_additive((SMIL_CalcMode *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_Accumulate_datatype:\n\t\tsmil_parse_accumulate((SMIL_Accumulate *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_Restart_datatype:\n\t\tsmil_parse_restart((SMIL_Restart *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_Fill_datatype:\n\t\tsmil_parse_fill((SMIL_Fill *)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_GradientUnit_datatype:\n\t\tif (!strcmp(attribute_content, \"userSpaceOnUse\"))\n\t\t\t*((SVG_GradientUnit *)info->far_ptr) = SVG_GRADIENTUNITS_USER;\n\t\telse if (!strcmp(attribute_content, \"objectBoundingBox\"))\n\t\t\t*((SVG_GradientUnit *)info->far_ptr) = SVG_GRADIENTUNITS_OBJECT;\n\t\telse\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\tcase SVG_FocusHighlight_datatype:\n\t\tsvg_parse_focushighlight((SVG_FocusHighlight*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Focusable_datatype:\n\t\tsvg_parse_focusable((SVG_Focusable*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_InitialVisibility_datatype:\n\t\tsvg_parse_initialvisibility((SVG_InitialVisibility*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Overlay_datatype:\n\t\tsvg_parse_overlay((SVG_Overlay*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TransformBehavior_datatype:\n\t\tsvg_parse_transformbehavior((SVG_TransformBehavior*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_SpreadMethod_datatype:\n\t\tif (!strcmp(attribute_content, \"reflect\")) *(u8*)info->far_ptr = SVG_SPREAD_REFLECT;\n\t\telse if (!strcmp(attribute_content, \"repeat\")) *(u8*)info->far_ptr = SVG_SPREAD_REPEAT;\n\t\telse if (!strcmp(attribute_content, \"pad\")) *(u8*)info->far_ptr = SVG_SPREAD_PAD;\n\t\telse e = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\tcase SVG_Filter_TransferType_datatype:\n\t\tif (!strcmp(attribute_content, \"table\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_TABLE;\n\t\telse if (!strcmp(attribute_content, \"discrete\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_DISCRETE;\n\t\telse if (!strcmp(attribute_content, \"linear\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_LINEAR;\n\t\telse if (!strcmp(attribute_content, \"gamma\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_GAMMA;\n\t\telse if (!strcmp(attribute_content, \"identity\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_IDENTITY;\n\t\telse if (!strcmp(attribute_content, \"fractalNoise\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_FRACTAL_NOISE;\n\t\telse if (!strcmp(attribute_content, \"turbulence\")) *(u8*)info->far_ptr = SVG_FILTER_TRANSFER_TURBULENCE;\n\t\telse if (!strcmp(attribute_content, \"matrix\")) *(u8*)info->far_ptr = SVG_FILTER_MX_MATRIX;\n\t\telse if (!strcmp(attribute_content, \"saturate\")) *(u8*)info->far_ptr = SVG_FILTER_MX_SATURATE;\n\t\telse if (!strcmp(attribute_content, \"hueRotate\")) *(u8*)info->far_ptr = SVG_FILTER_HUE_ROTATE;\n\t\telse if (!strcmp(attribute_content, \"luminanceToAlpha\")) *(u8*)info->far_ptr = SVG_FILTER_LUM_TO_ALPHA;\n\t\telse e = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\n\t/* end of keyword type parsing */\n\n\t/* keyword | numbers (with possibly units) */\n\tcase SVG_Length_datatype:\n\tcase SVG_Coordinate_datatype:\n\tcase SVG_FontSize_datatype:\n\tcase SVG_Rotate_datatype:\n\tcase SVG_Number_datatype:\n\t\tsvg_parse_length((SVG_Number*)info->far_ptr, attribute_content, 0, &e);\n\t\tbreak;\n\n\tcase SMIL_AnimateValue_datatype:\n\t\tsvg_parse_one_anim_value(n, (SMIL_AnimateValue*)info->far_ptr, attribute_content, anim_value_type, &e);\n\t\tbreak;\n\tcase SMIL_AnimateValues_datatype:\n\t\tsvg_parse_anim_values(n, (SMIL_AnimateValues*)info->far_ptr, attribute_content, anim_value_type, &e);\n\t\tbreak;\n\n\tcase XMLRI_datatype:\n\t\tsvg_parse_iri(n, (XMLRI*)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase XML_IDREF_datatype:\n\t\tsvg_parse_idref(n, (XMLRI*)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase SMIL_AttributeName_datatype:\n\t\t((SMIL_AttributeName *)info->far_ptr)->name = gf_strdup(attribute_content);\n\t\tbreak;\n\tcase SMIL_Times_datatype:\n\t\tsmil_parse_time_list(n, *(GF_List **)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase SMIL_Duration_datatype:\n\t\tsmil_parse_min_max_dur_repeatdur((SMIL_Duration*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_RepeatCount_datatype:\n\t\tsmil_parse_repeatcount((SMIL_RepeatCount*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_PathData_datatype:\n\t\tsvg_parse_path((SVG_PathData*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Points_datatype:\n\t\tsvg_parse_points(*(GF_List **)(info->far_ptr), attribute_content, &e);\n\t\tbreak;\n\tcase SMIL_KeyTimes_datatype:\n\tcase SMIL_KeyPoints_datatype:\n\tcase SMIL_KeySplines_datatype:\n\tcase SVG_Numbers_datatype:\n\t\tsvg_parse_numbers(*(GF_List **)(info->far_ptr), attribute_content, 0, &e);\n\t\tbreak;\n\tcase SVG_Coordinates_datatype:\n\t\tsvg_parse_coordinates(*(GF_List **)(info->far_ptr), attribute_content, &e);\n\t\tbreak;\n\tcase SVG_ViewBox_datatype:\n\t\tsvg_parse_viewbox((SVG_ViewBox*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_StrokeDashArray_datatype:\n\t\tsvg_parse_strokedasharray((SVG_StrokeDashArray*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_FontFamily_datatype:\n\t\tsvg_parse_fontfamily((SVG_FontFamily*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Motion_datatype:\n\t\tsvg_parse_point_into_matrix((GF_Matrix2D*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Transform_datatype:\n\t\te = svg_parse_transform((SVG_Transform*)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase SVG_Transform_Translate_datatype:\n\t{\n\t\tu32 i = 0;\n\t\tSVG_Point *p = (SVG_Point *)info->far_ptr;\n\t\ti+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);\n\t\tif (attribute_content[i] == 0) {\n\t\t\tp->y = 0;\n\t\t} else {\n\t\t\t/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);\n\t\t}\n\t}\n\tbreak;\n\tcase SVG_Transform_Scale_datatype:\n\t{\n\t\tu32 i = 0;\n\t\tSVG_Point *p = (SVG_Point *)info->far_ptr;\n\t\ti+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);\n\t\tif (attribute_content[i] == 0) {\n\t\t\tp->y = p->x;\n\t\t} else {\n\t\t\t/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);\n\t\t}\n\t}\n\tbreak;\n\tcase SVG_Transform_SkewX_datatype:\n\tcase SVG_Transform_SkewY_datatype:\n\t{\n\t\tFixed *p = (Fixed *)info->far_ptr;\n\t\tsvg_parse_number(attribute_content, p, 1, &e);\n\t}\n\tbreak;\n\tcase SVG_Transform_Rotate_datatype:\n\t{\n\t\tu32 i = 0;\n\t\tSVG_Point_Angle *p = (SVG_Point_Angle *)info->far_ptr;\n\t\ti+=svg_parse_number(&(attribute_content[i]), &(p->angle), 1, &e);\n\t\tif (attribute_content[i] == 0) {\n\t\t\tp->y = p->x = 0;\n\t\t} else {\n\t\t\ti+=svg_parse_number(&(attribute_content[i]), &(p->x), 0, &e);\n\t\t\t/*i+=*/svg_parse_number(&(attribute_content[i]), &(p->y), 0, &e);\n\t\t}\n\t}\n\tbreak;\n\tcase SVG_PreserveAspectRatio_datatype:\n\t\tsvg_parse_preserveaspectratio((SVG_PreserveAspectRatio*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_TransformType_datatype:\n\t\tsvg_parse_animatetransform_type((SVG_TransformType*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\n\tcase SVG_ID_datatype:\n\tcase DOM_String_datatype:\n\tcase SVG_ContentType_datatype:\n\tcase SVG_LanguageID_datatype:\n\t\tif (*(SVG_String *)info->far_ptr) gf_free(*(SVG_String *)info->far_ptr);\n\n\t\t*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);\n\t\tbreak;\n\n\tcase DOM_StringList_datatype:\n\t\tsvg_parse_strings(*(GF_List **)info->far_ptr, attribute_content, 0);\n\t\tbreak;\n\tcase XMLRI_List_datatype:\n\t\tsvg_parse_strings(*(GF_List **)info->far_ptr, attribute_content, 1);\n\t\tbreak;\n\n\tcase XMLEV_Event_datatype:\n\t{\n\t\tXMLEV_Event *xml_ev = (XMLEV_Event *)info->far_ptr;\n\t\tchar *sep = strchr(attribute_content, '(');\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\txml_ev->type = gf_dom_event_type_by_name(attribute_content);\n\t\t\tsep[0] = '(';\n\t\t\tif ((xml_ev->type == GF_EVENT_REPEAT) || (xml_ev->type == GF_EVENT_REPEAT_EVENT)) {\n\t\t\t\tchar _v;\n\t\t\t\tsscanf(sep, \"(%c)\", &_v);\n\t\t\t\txml_ev->parameter = _v;\n\t\t\t} else { /* key events ... */\n\t\t\t\tchar *sep2 = strchr(attribute_content, ')');\n\t\t\t\tsep2[0] = 0;\n\t\t\t\txml_ev->parameter = gf_dom_get_key_type(sep+1);\n\t\t\t\tsep2[0] = ')';\n\t\t\t}\n\t\t} else {\n\t\t\txml_ev->parameter = 0;\n\t\t\txml_ev->type = gf_dom_event_type_by_name(attribute_content);\n\t\t}\n\t}\n\tbreak;\n\n\tcase SVG_Focus_datatype:\n\t\tsvg_parse_focus(n, (SVG_Focus*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_ClipPath_datatype:\n\t\tsvg_parse_clippath(n, (SVG_ClipPath*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\n\tcase LASeR_Choice_datatype:\n\t\te = laser_parse_choice((LASeR_Choice*)info->far_ptr, attribute_content);\n\t\tbreak;\n\tcase LASeR_Size_datatype:\n\t\te = laser_parse_size((LASeR_Size*)info->far_ptr, attribute_content, &e);\n\t\tbreak;\n\tcase SVG_Clock_datatype:\n\t\tsvg_parse_clock_value(attribute_content, (SVG_Clock*)info->far_ptr);\n\t\tbreak;\n\tcase SVG_Unknown_datatype:\n\t\tif (*(SVG_String *)info->far_ptr) gf_free(*(SVG_String *)info->far_ptr);\n\t\t*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute \\\"%s\\\"\\n\", info->name ? info->name : \"\"));\n\t\treturn GF_OK;\n\t}\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute \\\"%s\\\" value %s: %s\\n\", info->name ? info->name : \"\", attribute_content, gf_error_to_string(e)));\n\t\t//continue parsing if not test mode\n\t\tif (!gf_sys_is_test_mode())\n\t\t\te = GF_OK;\n\t}\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -349,11 +349,14 @@\n \t\t*(SVG_String *)info->far_ptr = gf_strdup(attribute_content);\n \t\tbreak;\n \tdefault:\n-\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute %s\\n\", info->name ? info->name : \"\"));\n-\t\tbreak;\n+\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute \\\"%s\\\"\\n\", info->name ? info->name : \"\"));\n+\t\treturn GF_OK;\n \t}\n \tif (e) {\n-\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute %s value %s: %s\\n\", info->name ? info->name : \"\", attribute_content, gf_error_to_string(e)));\n+\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute \\\"%s\\\" value %s: %s\\n\", info->name ? info->name : \"\", attribute_content, gf_error_to_string(e)));\n+\t\t//continue parsing if not test mode\n+\t\tif (!gf_sys_is_test_mode())\n+\t\t\te = GF_OK;\n \t}\n \treturn e;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute %s\\n\", info->name ? info->name : \"\"));",
                "\t\tbreak;",
                "\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute %s value %s: %s\\n\", info->name ? info->name : \"\", attribute_content, gf_error_to_string(e)));"
            ],
            "added_lines": [
                "\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute \\\"%s\\\"\\n\", info->name ? info->name : \"\"));",
                "\t\treturn GF_OK;",
                "\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[SVG Parsing] Cannot parse attribute \\\"%s\\\" value %s: %s\\n\", info->name ? info->name : \"\", attribute_content, gf_error_to_string(e)));",
                "\t\t//continue parsing if not test mode",
                "\t\tif (!gf_sys_is_test_mode())",
                "\t\t\te = GF_OK;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3957",
        "func_name": "gpac/svg_parse_preserveaspectratio",
        "description": "A vulnerability classified as problematic was found in GPAC. Affected by this vulnerability is the function svg_parse_preserveaspectratio of the file scenegraph/svg_attributes.c of the component SVG Parser. The manipulation leads to memory leak. The attack can be launched remotely. The name of the patch is 2191e66aa7df750e8ef01781b1930bea87b713bb. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-213463.",
        "git_url": "https://github.com/gpac/gpac/commit/2191e66aa7df750e8ef01781b1930bea87b713bb",
        "commit_title": "fixed mem leak in sgv parse error",
        "commit_text": "",
        "func_before": "static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e)\n{\n\tchar *content = attribute_content;\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"defer\")) {\n\t\tpar->defer = 1;\n\t\tcontent += 4;\n\t} else {\n\t\tcontent = attribute_content;\n\t}\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"none\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_NONE;\n\t\tcontent+=4;\n\t} else if (strstr(content, \"xMinYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;\n\t\tcontent+=8;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\twhile (*content == ' ') content++;\n\tif (*content == 0) return;\n\n\tif (strstr(content, \"meet\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_MEET;\n\t} else if (strstr(content, \"slice\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_SLICE;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}",
        "func": "static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e)\n{\n\tchar *content = attribute_content;\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"defer\")) {\n\t\tpar->defer = 1;\n\t\tcontent += 5;\n\t} else {\n\t\tcontent = attribute_content;\n\t}\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"none\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_NONE;\n\t\tcontent+=4;\n\t} else if (strstr(content, \"xMinYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;\n\t\tcontent+=8;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\twhile (*content == ' ') content++;\n\tif (*content == 0) return;\n\n\tif (strstr(content, \"meet\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_MEET;\n\t} else if (strstr(content, \"slice\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_SLICE;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \twhile (*content == ' ') content++;\n \tif (strstr(content, \"defer\")) {\n \t\tpar->defer = 1;\n-\t\tcontent += 4;\n+\t\tcontent += 5;\n \t} else {\n \t\tcontent = attribute_content;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tcontent += 4;"
            ],
            "added_lines": [
                "\t\tcontent += 5;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25021",
        "func_name": "TokTok/c-toxcore/kill_TCP_connection",
        "description": "The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).",
        "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
        "commit_title": "Fix memleak in tcp server by wiping priority queues on deletion",
        "commit_text": "",
        "func_before": "void kill_TCP_connection(TCP_Client_Connection *tcp_connection)\n{\n    if (tcp_connection == nullptr) {\n        return;\n    }\n\n    wipe_priority_list(tcp_connection);\n    kill_sock(tcp_connection->sock);\n    crypto_memzero(tcp_connection, sizeof(TCP_Client_Connection));\n    free(tcp_connection);\n}",
        "func": "void kill_TCP_connection(TCP_Client_Connection *tcp_connection)\n{\n    if (tcp_connection == nullptr) {\n        return;\n    }\n\n    wipe_priority_list(tcp_connection->priority_queue_start);\n    kill_sock(tcp_connection->sock);\n    crypto_memzero(tcp_connection, sizeof(TCP_Client_Connection));\n    free(tcp_connection);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n         return;\n     }\n \n-    wipe_priority_list(tcp_connection);\n+    wipe_priority_list(tcp_connection->priority_queue_start);\n     kill_sock(tcp_connection->sock);\n     crypto_memzero(tcp_connection, sizeof(TCP_Client_Connection));\n     free(tcp_connection);",
        "diff_line_info": {
            "deleted_lines": [
                "    wipe_priority_list(tcp_connection);"
            ],
            "added_lines": [
                "    wipe_priority_list(tcp_connection->priority_queue_start);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25021",
        "func_name": "TokTok/c-toxcore/kill_TCP_secure_connection",
        "description": "The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).",
        "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
        "commit_title": "Fix memleak in tcp server by wiping priority queues on deletion",
        "commit_text": "",
        "func_before": "static void kill_TCP_secure_connection(TCP_Secure_Connection *con)\n{\n    kill_sock(con->sock);\n    crypto_memzero(con, sizeof(TCP_Secure_Connection));\n}",
        "func": "static void kill_TCP_secure_connection(TCP_Secure_Connection *con)\n{\n    kill_sock(con->sock);\n    wipe_secure_connection(con);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static void kill_TCP_secure_connection(TCP_Secure_Connection *con)\n {\n     kill_sock(con->sock);\n-    crypto_memzero(con, sizeof(TCP_Secure_Connection));\n+    wipe_secure_connection(con);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    crypto_memzero(con, sizeof(TCP_Secure_Connection));"
            ],
            "added_lines": [
                "    wipe_secure_connection(con);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25021",
        "func_name": "TokTok/c-toxcore/add_accepted",
        "description": "The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).",
        "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
        "commit_title": "Fix memleak in tcp server by wiping priority queues on deletion",
        "commit_text": "",
        "func_before": "static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, const TCP_Secure_Connection *con)\n{\n    int index = get_TCP_connection_index(tcp_server, con->public_key);\n\n    if (index != -1) { /* If an old connection to the same public key exists, kill it. */\n        kill_accepted(tcp_server, index);\n        index = -1;\n    }\n\n    if (tcp_server->size_accepted_connections == tcp_server->num_accepted_connections) {\n        if (realloc_connection(tcp_server, tcp_server->size_accepted_connections + 4) == -1) {\n            return -1;\n        }\n\n        index = tcp_server->num_accepted_connections;\n    } else {\n        uint32_t i;\n\n        for (i = tcp_server->size_accepted_connections; i != 0; --i) {\n            if (tcp_server->accepted_connection_array[i - 1].status == TCP_STATUS_NO_STATUS) {\n                index = i - 1;\n                break;\n            }\n        }\n    }\n\n    if (index == -1) {\n        fprintf(stderr, \"FAIL index is -1\\n\");\n        return -1;\n    }\n\n    if (!bs_list_add(&tcp_server->accepted_key_list, con->public_key, index)) {\n        return -1;\n    }\n\n    memcpy(&tcp_server->accepted_connection_array[index], con, sizeof(TCP_Secure_Connection));\n    tcp_server->accepted_connection_array[index].status = TCP_STATUS_CONFIRMED;\n    ++tcp_server->num_accepted_connections;\n    tcp_server->accepted_connection_array[index].identifier = ++tcp_server->counter;\n    tcp_server->accepted_connection_array[index].last_pinged = mono_time_get(mono_time);\n    tcp_server->accepted_connection_array[index].ping_id = 0;\n\n    return index;\n}",
        "func": "static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con)\n{\n    int index = get_TCP_connection_index(tcp_server, con->public_key);\n\n    if (index != -1) { /* If an old connection to the same public key exists, kill it. */\n        kill_accepted(tcp_server, index);\n        index = -1;\n    }\n\n    if (tcp_server->size_accepted_connections == tcp_server->num_accepted_connections) {\n        if (alloc_new_connections(tcp_server, 4) == -1) {\n            return -1;\n        }\n\n        index = tcp_server->num_accepted_connections;\n    } else {\n        uint32_t i;\n\n        for (i = tcp_server->size_accepted_connections; i != 0; --i) {\n            if (tcp_server->accepted_connection_array[i - 1].status == TCP_STATUS_NO_STATUS) {\n                index = i - 1;\n                break;\n            }\n        }\n    }\n\n    if (index == -1) {\n        fprintf(stderr, \"FAIL index is -1\\n\");\n        return -1;\n    }\n\n    if (!bs_list_add(&tcp_server->accepted_key_list, con->public_key, index)) {\n        return -1;\n    }\n\n    move_secure_connection(&tcp_server->accepted_connection_array[index], con);\n\n    tcp_server->accepted_connection_array[index].status = TCP_STATUS_CONFIRMED;\n    ++tcp_server->num_accepted_connections;\n    tcp_server->accepted_connection_array[index].identifier = ++tcp_server->counter;\n    tcp_server->accepted_connection_array[index].last_pinged = mono_time_get(mono_time);\n    tcp_server->accepted_connection_array[index].ping_id = 0;\n\n    return index;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, const TCP_Secure_Connection *con)\n+static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con)\n {\n     int index = get_TCP_connection_index(tcp_server, con->public_key);\n \n@@ -8,7 +8,7 @@\n     }\n \n     if (tcp_server->size_accepted_connections == tcp_server->num_accepted_connections) {\n-        if (realloc_connection(tcp_server, tcp_server->size_accepted_connections + 4) == -1) {\n+        if (alloc_new_connections(tcp_server, 4) == -1) {\n             return -1;\n         }\n \n@@ -33,7 +33,8 @@\n         return -1;\n     }\n \n-    memcpy(&tcp_server->accepted_connection_array[index], con, sizeof(TCP_Secure_Connection));\n+    move_secure_connection(&tcp_server->accepted_connection_array[index], con);\n+\n     tcp_server->accepted_connection_array[index].status = TCP_STATUS_CONFIRMED;\n     ++tcp_server->num_accepted_connections;\n     tcp_server->accepted_connection_array[index].identifier = ++tcp_server->counter;",
        "diff_line_info": {
            "deleted_lines": [
                "static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, const TCP_Secure_Connection *con)",
                "        if (realloc_connection(tcp_server, tcp_server->size_accepted_connections + 4) == -1) {",
                "    memcpy(&tcp_server->accepted_connection_array[index], con, sizeof(TCP_Secure_Connection));"
            ],
            "added_lines": [
                "static int add_accepted(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con)",
                "        if (alloc_new_connections(tcp_server, 4) == -1) {",
                "    move_secure_connection(&tcp_server->accepted_connection_array[index], con);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25021",
        "func_name": "TokTok/c-toxcore/kill_TCP_server",
        "description": "The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).",
        "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
        "commit_title": "Fix memleak in tcp server by wiping priority queues on deletion",
        "commit_text": "",
        "func_before": "void kill_TCP_server(TCP_Server *tcp_server)\n{\n    uint32_t i;\n\n    for (i = 0; i < tcp_server->num_listening_socks; ++i) {\n        kill_sock(tcp_server->socks_listening[i]);\n    }\n\n    if (tcp_server->onion) {\n        set_callback_handle_recv_1(tcp_server->onion, nullptr, nullptr);\n    }\n\n    bs_list_free(&tcp_server->accepted_key_list);\n\n#ifdef TCP_SERVER_USE_EPOLL\n    close(tcp_server->efd);\n#endif\n\n    free(tcp_server->socks_listening);\n    free(tcp_server->accepted_connection_array);\n    free(tcp_server);\n}",
        "func": "void kill_TCP_server(TCP_Server *tcp_server)\n{\n    for (uint32_t i = 0; i < tcp_server->num_listening_socks; ++i) {\n        kill_sock(tcp_server->socks_listening[i]);\n    }\n\n    if (tcp_server->onion) {\n        set_callback_handle_recv_1(tcp_server->onion, nullptr, nullptr);\n    }\n\n    bs_list_free(&tcp_server->accepted_key_list);\n\n#ifdef TCP_SERVER_USE_EPOLL\n    close(tcp_server->efd);\n#endif\n\n    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {\n        wipe_secure_connection(&tcp_server->incoming_connection_queue[i]);\n        wipe_secure_connection(&tcp_server->unconfirmed_connection_queue[i]);\n    }\n\n    free_accepted_connection_array(tcp_server);\n\n    free(tcp_server->socks_listening);\n    free(tcp_server);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,6 @@\n void kill_TCP_server(TCP_Server *tcp_server)\n {\n-    uint32_t i;\n-\n-    for (i = 0; i < tcp_server->num_listening_socks; ++i) {\n+    for (uint32_t i = 0; i < tcp_server->num_listening_socks; ++i) {\n         kill_sock(tcp_server->socks_listening[i]);\n     }\n \n@@ -16,7 +14,13 @@\n     close(tcp_server->efd);\n #endif\n \n+    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {\n+        wipe_secure_connection(&tcp_server->incoming_connection_queue[i]);\n+        wipe_secure_connection(&tcp_server->unconfirmed_connection_queue[i]);\n+    }\n+\n+    free_accepted_connection_array(tcp_server);\n+\n     free(tcp_server->socks_listening);\n-    free(tcp_server->accepted_connection_array);\n     free(tcp_server);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    uint32_t i;",
                "",
                "    for (i = 0; i < tcp_server->num_listening_socks; ++i) {",
                "    free(tcp_server->accepted_connection_array);"
            ],
            "added_lines": [
                "    for (uint32_t i = 0; i < tcp_server->num_listening_socks; ++i) {",
                "    for (uint32_t i = 0; i < MAX_INCOMING_CONNECTIONS; ++i) {",
                "        wipe_secure_connection(&tcp_server->incoming_connection_queue[i]);",
                "        wipe_secure_connection(&tcp_server->unconfirmed_connection_queue[i]);",
                "    }",
                "",
                "    free_accepted_connection_array(tcp_server);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25021",
        "func_name": "TokTok/c-toxcore/del_accepted",
        "description": "The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).",
        "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
        "commit_title": "Fix memleak in tcp server by wiping priority queues on deletion",
        "commit_text": "",
        "func_before": "static int del_accepted(TCP_Server *tcp_server, int index)\n{\n    if ((uint32_t)index >= tcp_server->size_accepted_connections) {\n        return -1;\n    }\n\n    if (tcp_server->accepted_connection_array[index].status == TCP_STATUS_NO_STATUS) {\n        return -1;\n    }\n\n    if (!bs_list_remove(&tcp_server->accepted_key_list, tcp_server->accepted_connection_array[index].public_key, index)) {\n        return -1;\n    }\n\n    crypto_memzero(&tcp_server->accepted_connection_array[index], sizeof(TCP_Secure_Connection));\n    --tcp_server->num_accepted_connections;\n\n    if (tcp_server->num_accepted_connections == 0) {\n        realloc_connection(tcp_server, 0);\n    }\n\n    return 0;\n}",
        "func": "static int del_accepted(TCP_Server *tcp_server, int index)\n{\n    if ((uint32_t)index >= tcp_server->size_accepted_connections) {\n        return -1;\n    }\n\n    if (tcp_server->accepted_connection_array[index].status == TCP_STATUS_NO_STATUS) {\n        return -1;\n    }\n\n    if (!bs_list_remove(&tcp_server->accepted_key_list, tcp_server->accepted_connection_array[index].public_key, index)) {\n        return -1;\n    }\n\n    wipe_secure_connection(&tcp_server->accepted_connection_array[index]);\n    --tcp_server->num_accepted_connections;\n\n    if (tcp_server->num_accepted_connections == 0) {\n        free_accepted_connection_array(tcp_server);\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,11 +12,11 @@\n         return -1;\n     }\n \n-    crypto_memzero(&tcp_server->accepted_connection_array[index], sizeof(TCP_Secure_Connection));\n+    wipe_secure_connection(&tcp_server->accepted_connection_array[index]);\n     --tcp_server->num_accepted_connections;\n \n     if (tcp_server->num_accepted_connections == 0) {\n-        realloc_connection(tcp_server, 0);\n+        free_accepted_connection_array(tcp_server);\n     }\n \n     return 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    crypto_memzero(&tcp_server->accepted_connection_array[index], sizeof(TCP_Secure_Connection));",
                "        realloc_connection(tcp_server, 0);"
            ],
            "added_lines": [
                "    wipe_secure_connection(&tcp_server->accepted_connection_array[index]);",
                "        free_accepted_connection_array(tcp_server);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25021",
        "func_name": "TokTok/c-toxcore/do_incoming",
        "description": "The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).",
        "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
        "commit_title": "Fix memleak in tcp server by wiping priority queues on deletion",
        "commit_text": "",
        "func_before": "static int do_incoming(TCP_Server *tcp_server, uint32_t i)\n{\n    if (tcp_server->incoming_connection_queue[i].status != TCP_STATUS_CONNECTED) {\n        return -1;\n    }\n\n    int ret = read_connection_handshake(&tcp_server->incoming_connection_queue[i], tcp_server->secret_key);\n\n    if (ret == -1) {\n        kill_TCP_secure_connection(&tcp_server->incoming_connection_queue[i]);\n    } else if (ret == 1) {\n        int index_new = tcp_server->unconfirmed_connection_queue_index % MAX_INCOMING_CONNECTIONS;\n        TCP_Secure_Connection *conn_old = &tcp_server->incoming_connection_queue[i];\n        TCP_Secure_Connection *conn_new = &tcp_server->unconfirmed_connection_queue[index_new];\n\n        if (conn_new->status != TCP_STATUS_NO_STATUS) {\n            kill_TCP_secure_connection(conn_new);\n        }\n\n        memcpy(conn_new, conn_old, sizeof(TCP_Secure_Connection));\n        crypto_memzero(conn_old, sizeof(TCP_Secure_Connection));\n        ++tcp_server->unconfirmed_connection_queue_index;\n\n        return index_new;\n    }\n\n    return -1;\n}",
        "func": "static int do_incoming(TCP_Server *tcp_server, uint32_t i)\n{\n    if (tcp_server->incoming_connection_queue[i].status != TCP_STATUS_CONNECTED) {\n        return -1;\n    }\n\n    int ret = read_connection_handshake(&tcp_server->incoming_connection_queue[i], tcp_server->secret_key);\n\n    if (ret == -1) {\n        kill_TCP_secure_connection(&tcp_server->incoming_connection_queue[i]);\n    } else if (ret == 1) {\n        int index_new = tcp_server->unconfirmed_connection_queue_index % MAX_INCOMING_CONNECTIONS;\n        TCP_Secure_Connection *conn_old = &tcp_server->incoming_connection_queue[i];\n        TCP_Secure_Connection *conn_new = &tcp_server->unconfirmed_connection_queue[index_new];\n\n        if (conn_new->status != TCP_STATUS_NO_STATUS) {\n            kill_TCP_secure_connection(conn_new);\n        }\n\n        move_secure_connection(conn_new, conn_old);\n        ++tcp_server->unconfirmed_connection_queue_index;\n\n        return index_new;\n    }\n\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,7 @@\n             kill_TCP_secure_connection(conn_new);\n         }\n \n-        memcpy(conn_new, conn_old, sizeof(TCP_Secure_Connection));\n-        crypto_memzero(conn_old, sizeof(TCP_Secure_Connection));\n+        move_secure_connection(conn_new, conn_old);\n         ++tcp_server->unconfirmed_connection_queue_index;\n \n         return index_new;",
        "diff_line_info": {
            "deleted_lines": [
                "        memcpy(conn_new, conn_old, sizeof(TCP_Secure_Connection));",
                "        crypto_memzero(conn_old, sizeof(TCP_Secure_Connection));"
            ],
            "added_lines": [
                "        move_secure_connection(conn_new, conn_old);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-25021",
        "func_name": "TokTok/c-toxcore/confirm_TCP_connection",
        "description": "The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).",
        "git_url": "https://github.com/TokTok/c-toxcore/commit/5beb00c93d3adb5c23149535624d27c67bc146ea",
        "commit_title": "Fix memleak in tcp server by wiping priority queues on deletion",
        "commit_text": "",
        "func_before": "static int confirm_TCP_connection(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con,\n                                  const uint8_t *data,\n                                  uint16_t length)\n{\n    int index = add_accepted(tcp_server, mono_time, con);\n\n    if (index == -1) {\n        kill_TCP_secure_connection(con);\n        return -1;\n    }\n\n    crypto_memzero(con, sizeof(TCP_Secure_Connection));\n\n    if (handle_TCP_packet(tcp_server, index, data, length) == -1) {\n        kill_accepted(tcp_server, index);\n        return -1;\n    }\n\n    return index;\n}",
        "func": "static int confirm_TCP_connection(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con,\n                                  const uint8_t *data,\n                                  uint16_t length)\n{\n    int index = add_accepted(tcp_server, mono_time, con);\n\n    if (index == -1) {\n        kill_TCP_secure_connection(con);\n        return -1;\n    }\n\n    wipe_secure_connection(con);\n\n    if (handle_TCP_packet(tcp_server, index, data, length) == -1) {\n        kill_accepted(tcp_server, index);\n        return -1;\n    }\n\n    return index;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n         return -1;\n     }\n \n-    crypto_memzero(con, sizeof(TCP_Secure_Connection));\n+    wipe_secure_connection(con);\n \n     if (handle_TCP_packet(tcp_server, index, data, length) == -1) {\n         kill_accepted(tcp_server, index);",
        "diff_line_info": {
            "deleted_lines": [
                "    crypto_memzero(con, sizeof(TCP_Secure_Connection));"
            ],
            "added_lines": [
                "    wipe_secure_connection(con);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46322",
        "func_name": "svaarala/duktape/duk__handle_call_raw",
        "description": "Duktape v2.99.99 was discovered to contain a SEGV vulnerability via the component duk_push_tval in duktape/duk_api_stack.c.",
        "git_url": "https://github.com/svaarala/duktape/commit/fc75060165a011ff5ec43bfebea0c37a3d1baca1",
        "commit_title": "Fix segfault in call setup when valstack limit hit",
        "commit_text": "",
        "func_before": "DUK_LOCAL duk_int_t duk__handle_call_raw(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags) {\n#if defined(DUK_USE_ASSERTIONS)\n\tduk_activation *entry_act;\n\tduk_size_t entry_callstack_top;\n#endif\n\tduk_size_t entry_valstack_bottom_byteoff;\n\tduk_size_t entry_valstack_end_byteoff;\n\tduk_int_t entry_call_recursion_depth;\n\tduk_hthread *entry_curr_thread;\n\tduk_uint_fast8_t entry_thread_state;\n\tduk_instr_t **entry_ptr_curr_pc;\n\tduk_idx_t idx_args;\n\tduk_idx_t nargs; /* # argument registers target function wants (< 0 => \"as is\") */\n\tduk_idx_t nregs; /* # total registers target function wants on entry (< 0 => \"as is\") */\n\tduk_size_t vs_min_bytes; /* minimum value stack size (bytes) for handling call */\n\tduk_hobject *func = NULL; /* 'func' on stack (borrowed reference) */\n\tduk_activation *act;\n\tduk_ret_t rc;\n\tduk_small_uint_t use_tailcall;\n\n\tDUK_ASSERT(thr != NULL);\n\tDUK_ASSERT(thr->heap != NULL);\n\t/* Asserts for heap->curr_thread omitted: it may be NULL, 'thr', or\n\t * any other thread (e.g. when heap thread is used to run finalizers).\n\t */\n\tDUK_CTX_ASSERT_VALID(thr);\n\tDUK_ASSERT(duk_is_valid_index(thr, idx_func));\n\tDUK_ASSERT(idx_func >= 0);\n\n\tDUK_STATS_INC(thr->heap, stats_call_all);\n\n\t/* If a tail call:\n\t *   - an ECMAScript activation must be on top of the callstack\n\t *   - there cannot be any catch stack entries that would catch\n\t *     a return\n\t */\n#if defined(DUK_USE_ASSERTIONS)\n\tif (call_flags & DUK_CALL_FLAG_TAILCALL) {\n\t\tduk_activation *tmp_act;\n\t\tduk_catcher *tmp_cat;\n\n\t\tDUK_ASSERT(thr->callstack_top >= 1);\n\t\tDUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr) != NULL);\n\t\tDUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr)));\n\n\t\t/* No entry in the catch stack which would actually catch a\n\t\t * throw can refer to the callstack entry being reused.\n\t\t * There *can* be catch stack entries referring to the current\n\t\t * callstack entry as long as they don't catch (e.g. label sites).\n\t\t */\n\n\t\ttmp_act = thr->callstack_curr;\n\t\tfor (tmp_cat = tmp_act->cat; tmp_cat != NULL; tmp_cat = tmp_cat->parent) {\n\t\t\tDUK_ASSERT(DUK_CAT_GET_TYPE(tmp_cat) == DUK_CAT_TYPE_LABEL); /* a non-catching entry */\n\t\t}\n\t}\n#endif /* DUK_USE_ASSERTIONS */\n\n\t/*\n\t *  Store entry state.\n\t */\n\n#if defined(DUK_USE_ASSERTIONS)\n\tentry_act = thr->callstack_curr;\n\tentry_callstack_top = thr->callstack_top;\n#endif\n\tentry_valstack_bottom_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack);\n\tentry_valstack_end_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);\n\tentry_call_recursion_depth = thr->heap->call_recursion_depth;\n\tentry_curr_thread = thr->heap->curr_thread; /* may be NULL if first call */\n\tentry_thread_state = thr->state;\n\tentry_ptr_curr_pc = thr->ptr_curr_pc; /* may be NULL */\n\n\t/* If thr->ptr_curr_pc is set, sync curr_pc to act->pc.  Then NULL\n\t * thr->ptr_curr_pc so that it's not accidentally used with an incorrect\n\t * activation when side effects occur.\n\t */\n\tduk_hthread_sync_and_null_currpc(thr);\n\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\n\tDUK_DD(DUK_DDPRINT(\"duk__handle_call_raw: thr=%p, idx_func=%ld, \"\n\t                   \"call_flags=0x%08lx (constructor=%ld), \"\n\t                   \"valstack_top=%ld, idx_func=%ld, idx_args=%ld, rec_depth=%ld/%ld, \"\n\t                   \"entry_valstack_bottom_byteoff=%ld, entry_valstack_end_byteoff=%ld, \"\n\t                   \"entry_call_recursion_depth=%ld, \"\n\t                   \"entry_curr_thread=%p, entry_thread_state=%ld\",\n\t                   (void *) thr,\n\t                   (long) idx_func,\n\t                   (unsigned long) call_flags,\n\t                   (long) ((call_flags & DUK_CALL_FLAG_CONSTRUCT) != 0 ? 1 : 0),\n\t                   (long) duk_get_top(thr),\n\t                   (long) idx_func,\n\t                   (long) (idx_func + 2),\n\t                   (long) thr->heap->call_recursion_depth,\n\t                   (long) thr->heap->call_recursion_limit,\n\t                   (long) entry_valstack_bottom_byteoff,\n\t                   (long) entry_valstack_end_byteoff,\n\t                   (long) entry_call_recursion_depth,\n\t                   (void *) entry_curr_thread,\n\t                   (long) entry_thread_state));\n\n\t/*\n\t *  Thread state check and book-keeping.\n\t */\n\n\tduk__call_thread_state_update(thr);\n\n\t/*\n\t *  Increase call recursion depth as early as possible so that if we\n\t *  enter a recursive call for any reason there's a backstop to native\n\t *  recursion.  This can happen e.g. for almost any property read\n\t *  because it may cause a getter call or a Proxy trap (GC and finalizers\n\t *  are not an issue because they are not recursive).  If we end up\n\t *  doing an Ecma-to-Ecma call, revert the increase.  (See GH-2032.)\n\t *\n\t *  For similar reasons, ensure there is a known value stack spare\n\t *  even before we actually prepare the value stack for the target\n\t *  function.  If this isn't done, early recursion may consume the\n\t *  value stack space.\n\t *\n\t *  XXX: Should bump yield preventcount early, for the same reason.\n\t */\n\n\tduk__call_c_recursion_limit_check(thr);\n\tthr->heap->call_recursion_depth++;\n\tduk_require_stack(thr, DUK__CALL_HANDLING_REQUIRE_STACK);\n\n\t/*\n\t *  Resolve final target function; handle bound functions and special\n\t *  functions like .call() and .apply().  Also figure out the effective\n\t *  'this' binding, which replaces the current value at idx_func + 1.\n\t */\n\n\tif (DUK_LIKELY(duk__resolve_target_fastpath_check(thr, idx_func, &func, call_flags) != 0U)) {\n\t\tDUK_DDD(DUK_DDDPRINT(\"fast path target resolve\"));\n\t} else {\n\t\tDUK_DDD(DUK_DDDPRINT(\"slow path target resolve\"));\n\t\tfunc = duk__resolve_target_func_and_this_binding(thr, idx_func, &call_flags);\n\t}\n\tDUK_ASSERT(duk_get_top(thr) - idx_func >= 2); /* at least func and this present */\n\n\tDUK_ASSERT(func == NULL || !DUK_HOBJECT_HAS_BOUNDFUNC(func));\n\tDUK_ASSERT(func == NULL || (DUK_HOBJECT_IS_COMPFUNC(func) || DUK_HOBJECT_IS_NATFUNC(func)));\n\n\t/* [ ... func this arg1 ... argN ] */\n\n\t/*\n\t *  Setup a preliminary activation and figure out nargs/nregs and\n\t *  value stack minimum size.\n\t *\n\t *  Don't touch valstack_bottom or valstack_top yet so that Duktape API\n\t *  calls work normally.\n\t *\n\t *  Because 'act' is not zeroed, all fields must be filled in.\n\t */\n\n\t/* Should not be necessary, but initialize to silence warnings. */\n\tact = NULL;\n\tnargs = 0;\n\tnregs = 0;\n\tvs_min_bytes = 0;\n\n#if defined(DUK_USE_TAILCALL)\n\tuse_tailcall = (call_flags & DUK_CALL_FLAG_TAILCALL);\n\tif (use_tailcall) {\n\t\tuse_tailcall = duk__call_setup_act_attempt_tailcall(thr,\n\t\t                                                    call_flags,\n\t\t                                                    idx_func,\n\t\t                                                    func,\n\t\t                                                    entry_valstack_bottom_byteoff,\n\t\t                                                    entry_valstack_end_byteoff,\n\t\t                                                    &nargs,\n\t\t                                                    &nregs,\n\t\t                                                    &vs_min_bytes,\n\t\t                                                    &act);\n\t}\n#else\n\tDUK_ASSERT((call_flags & DUK_CALL_FLAG_TAILCALL) == 0); /* compiler ensures this */\n\tuse_tailcall = 0;\n#endif\n\n\tif (use_tailcall) {\n\t\tidx_args = 0;\n\t\tDUK_STATS_INC(thr->heap, stats_call_tailcall);\n\t} else {\n\t\tduk__call_setup_act_not_tailcall(thr,\n\t\t                                 call_flags,\n\t\t                                 idx_func,\n\t\t                                 func,\n\t\t                                 entry_valstack_bottom_byteoff,\n\t\t                                 entry_valstack_end_byteoff,\n\t\t                                 &nargs,\n\t\t                                 &nregs,\n\t\t                                 &vs_min_bytes,\n\t\t                                 &act);\n\t\tidx_args = idx_func + 2;\n\t}\n\t/* After this point idx_func is no longer valid for tailcalls. */\n\n\tDUK_ASSERT(act != NULL);\n\n\t/* [ ... func this arg1 ... argN ] */\n\n\t/*\n\t *  Environment record creation and 'arguments' object creation.\n\t *  Named function expression name binding is handled by the\n\t *  compiler; the compiled function's parent env will contain\n\t *  the (immutable) binding already.\n\t *\n\t *  This handling is now identical for C and ECMAScript functions.\n\t *  C functions always have the 'NEWENV' flag set, so their\n\t *  environment record initialization is delayed (which is good).\n\t *\n\t *  Delayed creation (on demand) is handled in duk_js_var.c.\n\t */\n\n\tduk__call_env_setup(thr, func, act, idx_args);\n\n\t/* [ ... func this arg1 ... argN ] */\n\n\t/*\n\t *  Setup value stack: clamp to 'nargs', fill up to 'nregs',\n\t *  ensure value stack size matches target requirements, and\n\t *  switch value stack bottom.  Valstack top is kept.\n\t *\n\t *  Value stack can only grow here.\n\t */\n\n\tduk_valstack_grow_check_throw(thr, vs_min_bytes);\n\tact->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);\n\n\tif (use_tailcall) {\n\t\tDUK_ASSERT(nregs >= 0);\n\t\tDUK_ASSERT(nregs >= nargs);\n\t\tduk_set_top_and_wipe(thr, nregs, nargs);\n\t} else {\n\t\tif (nregs >= 0) {\n\t\t\tDUK_ASSERT(nregs >= nargs);\n\t\t\tduk_set_top_and_wipe(thr, idx_func + 2 + nregs, idx_func + 2 + nargs);\n\t\t} else {\n\t\t\t;\n\t\t}\n\t\tthr->valstack_bottom = thr->valstack_bottom + idx_func + 2;\n\t}\n\tDUK_ASSERT(thr->valstack_bottom >= thr->valstack);\n\tDUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);\n\tDUK_ASSERT(thr->valstack_end >= thr->valstack_top);\n\n\t/*\n\t *  Make the actual call.  For Ecma-to-Ecma calls detect that\n\t *  setup is complete, then return with a status code that allows\n\t *  the caller to reuse the running executor.\n\t */\n\n\tif (func != NULL && DUK_HOBJECT_IS_COMPFUNC(func)) {\n\t\t/*\n\t\t *  ECMAScript call.\n\t\t */\n\n\t\tDUK_ASSERT(func != NULL);\n\t\tDUK_ASSERT(DUK_HOBJECT_HAS_COMPFUNC(func));\n\t\tact->curr_pc = DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, (duk_hcompfunc *) func);\n\n\t\tif (call_flags & DUK_CALL_FLAG_ALLOW_ECMATOECMA) {\n\t\t\tDUK_DD(DUK_DDPRINT(\"avoid native call, use existing executor\"));\n\t\t\tDUK_STATS_INC(thr->heap, stats_call_ecmatoecma);\n\t\t\tDUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);\n\t\t\tDUK_REFZERO_CHECK_FAST(thr);\n\t\t\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\t\t\tthr->heap->call_recursion_depth--; /* No recursion increase for this case. */\n\t\t\treturn 1; /* 1=reuse executor */\n\t\t}\n\t\tDUK_ASSERT(use_tailcall == 0);\n\n\t\t/* duk_hthread_activation_unwind_norz() will decrease this on unwind */\n\t\tDUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);\n\t\tact->flags |= DUK_ACT_FLAG_PREVENT_YIELD;\n\t\tthr->callstack_preventcount++;\n\n\t\t/* [ ... func this | arg1 ... argN ] ('this' must precede new bottom) */\n\n\t\t/*\n\t\t *  Bytecode executor call.\n\t\t *\n\t\t *  Execute bytecode, handling any recursive function calls and\n\t\t *  thread resumptions.  Returns when execution would return from\n\t\t *  the entry level activation.  When the executor returns, a\n\t\t *  single return value is left on the stack top.\n\t\t *\n\t\t *  The only possible longjmp() is an error (DUK_LJ_TYPE_THROW),\n\t\t *  other types are handled internally by the executor.\n\t\t */\n\n\t\t/* thr->ptr_curr_pc is set by bytecode executor early on entry */\n\t\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\t\tDUK_DDD(DUK_DDDPRINT(\"entering bytecode execution\"));\n\t\tduk_js_execute_bytecode(thr);\n\t\tDUK_DDD(DUK_DDDPRINT(\"returned from bytecode execution\"));\n\t} else {\n\t\t/*\n\t\t *  Native call.\n\t\t */\n\n\t\tDUK_ASSERT(func == NULL || ((duk_hnatfunc *) func)->func != NULL);\n\t\tDUK_ASSERT(use_tailcall == 0);\n\n\t\t/* [ ... func this | arg1 ... argN ] ('this' must precede new bottom) */\n\n\t\t/* duk_hthread_activation_unwind_norz() will decrease this on unwind */\n\t\tDUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);\n\t\tact->flags |= DUK_ACT_FLAG_PREVENT_YIELD;\n\t\tthr->callstack_preventcount++;\n\n\t\t/* For native calls must be NULL so we don't sync back */\n\t\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\n\t\t/* XXX: native funcptr could come out of call setup. */\n\t\tif (func != NULL) {\n\t\t\trc = ((duk_hnatfunc *) func)->func(thr);\n\t\t} else {\n\t\t\tduk_tval *tv_func;\n\t\t\tduk_c_function funcptr;\n\n\t\t\ttv_func = &act->tv_func;\n\t\t\tDUK_ASSERT(DUK_TVAL_IS_LIGHTFUNC(tv_func));\n\t\t\tfuncptr = DUK_TVAL_GET_LIGHTFUNC_FUNCPTR(tv_func);\n\t\t\trc = funcptr(thr);\n\t\t}\n\n\t\t/* Automatic error throwing, retval check. */\n\n\t\tif (rc == 0) {\n\t\t\tDUK_ASSERT(thr->valstack < thr->valstack_end);\n\t\t\tDUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top));\n\t\t\tthr->valstack_top++;\n\t\t} else if (rc == 1) {\n\t\t\t;\n\t\t} else if (rc < 0) {\n\t\t\tduk_error_throw_from_negative_rc(thr, rc);\n\t\t\tDUK_WO_NORETURN(return 0;);\n\t\t} else {\n\t\t\tDUK_ERROR_TYPE(thr, DUK_STR_INVALID_CFUNC_RC);\n\t\t\tDUK_WO_NORETURN(return 0;);\n\t\t}\n\t}\n\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\tDUK_ASSERT(use_tailcall == 0);\n\n\t/*\n\t *  Constructor call post processing.\n\t */\n\n#if defined(DUK_USE_ES6_PROXY)\n\tif (call_flags & (DUK_CALL_FLAG_CONSTRUCT | DUK_CALL_FLAG_CONSTRUCT_PROXY)) {\n\t\tduk_call_construct_postprocess(thr, call_flags & DUK_CALL_FLAG_CONSTRUCT_PROXY);\n\t}\n#else\n\tif (call_flags & DUK_CALL_FLAG_CONSTRUCT) {\n\t\tduk_call_construct_postprocess(thr, 0);\n\t}\n#endif\n\n\t/*\n\t *  Unwind, restore valstack bottom and other book-keeping.\n\t */\n\n\tDUK_ASSERT(thr->callstack_curr != NULL);\n\tDUK_ASSERT(thr->callstack_curr->parent == entry_act);\n\tDUK_ASSERT(thr->callstack_top == entry_callstack_top + 1);\n\tduk_hthread_activation_unwind_norz(thr);\n\tDUK_ASSERT(thr->callstack_curr == entry_act);\n\tDUK_ASSERT(thr->callstack_top == entry_callstack_top);\n\n\tthr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_bottom_byteoff);\n\t/* keep current valstack_top */\n\tDUK_ASSERT(thr->valstack_bottom >= thr->valstack);\n\tDUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);\n\tDUK_ASSERT(thr->valstack_end >= thr->valstack_top);\n\tDUK_ASSERT(thr->valstack_top - thr->valstack_bottom >= idx_func + 1);\n\n\t/* Return value handling. */\n\n\t/* [ ... func this (crud) retval ] */\n\n\t{\n\t\tduk_tval *tv_ret;\n\t\tduk_tval *tv_funret;\n\n\t\ttv_ret = thr->valstack_bottom + idx_func;\n\t\ttv_funret = thr->valstack_top - 1;\n#if defined(DUK_USE_FASTINT)\n\t\t/* Explicit check for fastint downgrade. */\n\t\tDUK_TVAL_CHKFAST_INPLACE_FAST(tv_funret);\n#endif\n\t\tDUK_TVAL_SET_TVAL_UPDREF(thr, tv_ret, tv_funret); /* side effects */\n\t}\n\n\tduk_set_top_unsafe(thr, idx_func + 1);\n\n\t/* [ ... retval ] */\n\n\t/* Restore caller's value stack reserve (cannot fail). */\n\tDUK_ASSERT((duk_uint8_t *) thr->valstack + entry_valstack_end_byteoff >= (duk_uint8_t *) thr->valstack_top);\n\tDUK_ASSERT((duk_uint8_t *) thr->valstack + entry_valstack_end_byteoff <= (duk_uint8_t *) thr->valstack_alloc_end);\n\tthr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_end_byteoff);\n\n\t/* XXX: Trial value stack shrink would be OK here, but we'd need\n\t * to prevent side effects of the potential realloc.\n\t */\n\n\t/* Restore entry thread executor curr_pc stack frame pointer. */\n\tthr->ptr_curr_pc = entry_ptr_curr_pc;\n\n\tDUK_HEAP_SWITCH_THREAD(thr->heap, entry_curr_thread); /* may be NULL */\n\tthr->state = (duk_uint8_t) entry_thread_state;\n\n\t/* Disabled assert: triggered with some torture tests. */\n#if 0\n\tDUK_ASSERT((thr->state == DUK_HTHREAD_STATE_INACTIVE && thr->heap->curr_thread == NULL) ||  /* first call */\n\t           (thr->state == DUK_HTHREAD_STATE_INACTIVE && thr->heap->curr_thread != NULL) ||  /* other call */\n\t           (thr->state == DUK_HTHREAD_STATE_RUNNING && thr->heap->curr_thread == thr));     /* current thread */\n#endif\n\n\tthr->heap->call_recursion_depth = entry_call_recursion_depth;\n\n\t/* If the debugger is active we need to force an interrupt so that\n\t * debugger breakpoints are rechecked.  This is important for function\n\t * calls caused by side effects (e.g. when doing a DUK_OP_GETPROP), see\n\t * GH-303.  Only needed for success path, error path always causes a\n\t * breakpoint recheck in the executor.  It would be enough to set this\n\t * only when returning to an ECMAScript activation, but setting the flag\n\t * on every return should have no ill effect.\n\t */\n#if defined(DUK_USE_DEBUGGER_SUPPORT)\n\tif (duk_debug_is_attached(thr->heap)) {\n\t\tDUK_DD(DUK_DDPRINT(\"returning with debugger enabled, force interrupt\"));\n\t\tDUK_ASSERT(thr->interrupt_counter <= thr->interrupt_init);\n\t\tthr->interrupt_init -= thr->interrupt_counter;\n\t\tthr->interrupt_counter = 0;\n\t\tthr->heap->dbg_force_restart = 1;\n\t}\n#endif\n\n#if defined(DUK_USE_INTERRUPT_COUNTER) && defined(DUK_USE_DEBUG)\n\tduk__interrupt_fixup(thr, entry_curr_thread);\n#endif\n\n\t/* Restored by success path. */\n\tDUK_ASSERT(thr->heap->call_recursion_depth == entry_call_recursion_depth);\n\tDUK_ASSERT(thr->ptr_curr_pc == entry_ptr_curr_pc);\n\tDUK_ASSERT_LJSTATE_UNSET(thr->heap);\n\n\tDUK_REFZERO_CHECK_FAST(thr);\n\n\treturn 0; /* 0=call handled inline */\n}",
        "func": "DUK_LOCAL duk_int_t duk__handle_call_raw(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags) {\n#if defined(DUK_USE_ASSERTIONS)\n\tduk_activation *entry_act;\n\tduk_size_t entry_callstack_top;\n#endif\n\tduk_size_t entry_valstack_bottom_byteoff;\n\tduk_size_t entry_valstack_end_byteoff;\n\tduk_int_t entry_call_recursion_depth;\n\tduk_hthread *entry_curr_thread;\n\tduk_uint_fast8_t entry_thread_state;\n\tduk_instr_t **entry_ptr_curr_pc;\n\tduk_idx_t idx_args;\n\tduk_idx_t nargs; /* # argument registers target function wants (< 0 => \"as is\") */\n\tduk_idx_t nregs; /* # total registers target function wants on entry (< 0 => \"as is\") */\n\tduk_size_t vs_min_bytes; /* minimum value stack size (bytes) for handling call */\n\tduk_hobject *func = NULL; /* 'func' on stack (borrowed reference) */\n\tduk_activation *act;\n\tduk_ret_t rc;\n\tduk_small_uint_t use_tailcall;\n\n\tDUK_ASSERT(thr != NULL);\n\tDUK_ASSERT(thr->heap != NULL);\n\t/* Asserts for heap->curr_thread omitted: it may be NULL, 'thr', or\n\t * any other thread (e.g. when heap thread is used to run finalizers).\n\t */\n\tDUK_CTX_ASSERT_VALID(thr);\n\tDUK_ASSERT(duk_is_valid_index(thr, idx_func));\n\tDUK_ASSERT(idx_func >= 0);\n\n\tDUK_STATS_INC(thr->heap, stats_call_all);\n\n\t/* If a tail call:\n\t *   - an ECMAScript activation must be on top of the callstack\n\t *   - there cannot be any catch stack entries that would catch\n\t *     a return\n\t */\n#if defined(DUK_USE_ASSERTIONS)\n\tif (call_flags & DUK_CALL_FLAG_TAILCALL) {\n\t\tduk_activation *tmp_act;\n\t\tduk_catcher *tmp_cat;\n\n\t\tDUK_ASSERT(thr->callstack_top >= 1);\n\t\tDUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr) != NULL);\n\t\tDUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr)));\n\n\t\t/* No entry in the catch stack which would actually catch a\n\t\t * throw can refer to the callstack entry being reused.\n\t\t * There *can* be catch stack entries referring to the current\n\t\t * callstack entry as long as they don't catch (e.g. label sites).\n\t\t */\n\n\t\ttmp_act = thr->callstack_curr;\n\t\tfor (tmp_cat = tmp_act->cat; tmp_cat != NULL; tmp_cat = tmp_cat->parent) {\n\t\t\tDUK_ASSERT(DUK_CAT_GET_TYPE(tmp_cat) == DUK_CAT_TYPE_LABEL); /* a non-catching entry */\n\t\t}\n\t}\n#endif /* DUK_USE_ASSERTIONS */\n\n\t/*\n\t *  Store entry state.\n\t */\n\n#if defined(DUK_USE_ASSERTIONS)\n\tentry_act = thr->callstack_curr;\n\tentry_callstack_top = thr->callstack_top;\n#endif\n\tentry_valstack_bottom_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack);\n\tentry_valstack_end_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);\n\tentry_call_recursion_depth = thr->heap->call_recursion_depth;\n\tentry_curr_thread = thr->heap->curr_thread; /* may be NULL if first call */\n\tentry_thread_state = thr->state;\n\tentry_ptr_curr_pc = thr->ptr_curr_pc; /* may be NULL */\n\n\t/* If thr->ptr_curr_pc is set, sync curr_pc to act->pc.  Then NULL\n\t * thr->ptr_curr_pc so that it's not accidentally used with an incorrect\n\t * activation when side effects occur.\n\t */\n\tduk_hthread_sync_and_null_currpc(thr);\n\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\n\tDUK_DD(DUK_DDPRINT(\"duk__handle_call_raw: thr=%p, idx_func=%ld, \"\n\t                   \"call_flags=0x%08lx (constructor=%ld), \"\n\t                   \"valstack_top=%ld, idx_func=%ld, idx_args=%ld, rec_depth=%ld/%ld, \"\n\t                   \"entry_valstack_bottom_byteoff=%ld, entry_valstack_end_byteoff=%ld, \"\n\t                   \"entry_call_recursion_depth=%ld, \"\n\t                   \"entry_curr_thread=%p, entry_thread_state=%ld\",\n\t                   (void *) thr,\n\t                   (long) idx_func,\n\t                   (unsigned long) call_flags,\n\t                   (long) ((call_flags & DUK_CALL_FLAG_CONSTRUCT) != 0 ? 1 : 0),\n\t                   (long) duk_get_top(thr),\n\t                   (long) idx_func,\n\t                   (long) (idx_func + 2),\n\t                   (long) thr->heap->call_recursion_depth,\n\t                   (long) thr->heap->call_recursion_limit,\n\t                   (long) entry_valstack_bottom_byteoff,\n\t                   (long) entry_valstack_end_byteoff,\n\t                   (long) entry_call_recursion_depth,\n\t                   (void *) entry_curr_thread,\n\t                   (long) entry_thread_state));\n\n\t/*\n\t *  Thread state check and book-keeping.\n\t */\n\n\tduk__call_thread_state_update(thr);\n\n\t/*\n\t *  Increase call recursion depth as early as possible so that if we\n\t *  enter a recursive call for any reason there's a backstop to native\n\t *  recursion.  This can happen e.g. for almost any property read\n\t *  because it may cause a getter call or a Proxy trap (GC and finalizers\n\t *  are not an issue because they are not recursive).  If we end up\n\t *  doing an Ecma-to-Ecma call, revert the increase.  (See GH-2032.)\n\t *\n\t *  For similar reasons, ensure there is a known value stack spare\n\t *  even before we actually prepare the value stack for the target\n\t *  function.  If this isn't done, early recursion may consume the\n\t *  value stack space.\n\t *\n\t *  XXX: Should bump yield preventcount early, for the same reason.\n\t */\n\n\tduk__call_c_recursion_limit_check(thr);\n\tthr->heap->call_recursion_depth++;\n\tduk_require_stack(thr, DUK__CALL_HANDLING_REQUIRE_STACK);\n\n\t/*\n\t *  Resolve final target function; handle bound functions and special\n\t *  functions like .call() and .apply().  Also figure out the effective\n\t *  'this' binding, which replaces the current value at idx_func + 1.\n\t */\n\n\tif (DUK_LIKELY(duk__resolve_target_fastpath_check(thr, idx_func, &func, call_flags) != 0U)) {\n\t\tDUK_DDD(DUK_DDDPRINT(\"fast path target resolve\"));\n\t} else {\n\t\tDUK_DDD(DUK_DDDPRINT(\"slow path target resolve\"));\n\t\tfunc = duk__resolve_target_func_and_this_binding(thr, idx_func, &call_flags);\n\t}\n\tDUK_ASSERT(duk_get_top(thr) - idx_func >= 2); /* at least func and this present */\n\n\tDUK_ASSERT(func == NULL || !DUK_HOBJECT_HAS_BOUNDFUNC(func));\n\tDUK_ASSERT(func == NULL || (DUK_HOBJECT_IS_COMPFUNC(func) || DUK_HOBJECT_IS_NATFUNC(func)));\n\n\t/* [ ... func this arg1 ... argN ] */\n\n\t/*\n\t *  Setup a preliminary activation and figure out nargs/nregs and\n\t *  value stack minimum size.\n\t *\n\t *  Don't touch valstack_bottom or valstack_top yet so that Duktape API\n\t *  calls work normally.\n\t *\n\t *  Because 'act' is not zeroed, all fields must be filled in.\n\t */\n\n\t/* Should not be necessary, but initialize to silence warnings. */\n\tact = NULL;\n\tnargs = 0;\n\tnregs = 0;\n\tvs_min_bytes = 0;\n\n#if defined(DUK_USE_TAILCALL)\n\tuse_tailcall = (call_flags & DUK_CALL_FLAG_TAILCALL);\n\tif (use_tailcall) {\n\t\tuse_tailcall = duk__call_setup_act_attempt_tailcall(thr,\n\t\t                                                    call_flags,\n\t\t                                                    idx_func,\n\t\t                                                    func,\n\t\t                                                    entry_valstack_bottom_byteoff,\n\t\t                                                    entry_valstack_end_byteoff,\n\t\t                                                    &nargs,\n\t\t                                                    &nregs,\n\t\t                                                    &vs_min_bytes,\n\t\t                                                    &act);\n\t}\n#else\n\tDUK_ASSERT((call_flags & DUK_CALL_FLAG_TAILCALL) == 0); /* compiler ensures this */\n\tuse_tailcall = 0;\n#endif\n\n\tif (use_tailcall) {\n\t\tidx_args = 0;\n\t\tDUK_STATS_INC(thr->heap, stats_call_tailcall);\n\t} else {\n\t\tduk__call_setup_act_not_tailcall(thr,\n\t\t                                 call_flags,\n\t\t                                 idx_func,\n\t\t                                 func,\n\t\t                                 entry_valstack_bottom_byteoff,\n\t\t                                 entry_valstack_end_byteoff,\n\t\t                                 &nargs,\n\t\t                                 &nregs,\n\t\t                                 &vs_min_bytes,\n\t\t                                 &act);\n\t\tidx_args = idx_func + 2;\n\t}\n\t/* After this point idx_func is no longer valid for tailcalls. */\n\n\tDUK_ASSERT(act != NULL);\n\n\t/* [ ... func this arg1 ... argN ] */\n\n\t/*\n\t *  Grow value stack to required size before env setup.  This\n\t *  must happen before env setup to handle some corner cases\n\t *  correctly, e.g. test-bug-scope-segv-gh2448.js.\n\t */\n\n\tduk_valstack_grow_check_throw(thr, vs_min_bytes);\n\tact->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);\n\n\t/*\n\t *  Environment record creation and 'arguments' object creation.\n\t *  Named function expression name binding is handled by the\n\t *  compiler; the compiled function's parent env will contain\n\t *  the (immutable) binding already.\n\t *\n\t *  This handling is now identical for C and ECMAScript functions.\n\t *  C functions always have the 'NEWENV' flag set, so their\n\t *  environment record initialization is delayed (which is good).\n\t *\n\t *  Delayed creation (on demand) is handled in duk_js_var.c.\n\t */\n\n\tduk__call_env_setup(thr, func, act, idx_args);\n\n\t/* [ ... func this arg1 ... argN ] */\n\n\t/*\n\t *  Setup value stack: clamp to 'nargs', fill up to 'nregs',\n\t *  ensure value stack size matches target requirements, and\n\t *  switch value stack bottom.  Valstack top is kept.\n\t */\n\n\tif (use_tailcall) {\n\t\tDUK_ASSERT(nregs >= 0);\n\t\tDUK_ASSERT(nregs >= nargs);\n\t\tduk_set_top_and_wipe(thr, nregs, nargs);\n\t} else {\n\t\tif (nregs >= 0) {\n\t\t\tDUK_ASSERT(nregs >= nargs);\n\t\t\tduk_set_top_and_wipe(thr, idx_func + 2 + nregs, idx_func + 2 + nargs);\n\t\t} else {\n\t\t\t;\n\t\t}\n\t\tthr->valstack_bottom = thr->valstack_bottom + idx_func + 2;\n\t}\n\tDUK_ASSERT(thr->valstack_bottom >= thr->valstack);\n\tDUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);\n\tDUK_ASSERT(thr->valstack_end >= thr->valstack_top);\n\n\t/*\n\t *  Make the actual call.  For Ecma-to-Ecma calls detect that\n\t *  setup is complete, then return with a status code that allows\n\t *  the caller to reuse the running executor.\n\t */\n\n\tif (func != NULL && DUK_HOBJECT_IS_COMPFUNC(func)) {\n\t\t/*\n\t\t *  ECMAScript call.\n\t\t */\n\n\t\tDUK_ASSERT(func != NULL);\n\t\tDUK_ASSERT(DUK_HOBJECT_HAS_COMPFUNC(func));\n\t\tact->curr_pc = DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, (duk_hcompfunc *) func);\n\n\t\tif (call_flags & DUK_CALL_FLAG_ALLOW_ECMATOECMA) {\n\t\t\tDUK_DD(DUK_DDPRINT(\"avoid native call, use existing executor\"));\n\t\t\tDUK_STATS_INC(thr->heap, stats_call_ecmatoecma);\n\t\t\tDUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);\n\t\t\tDUK_REFZERO_CHECK_FAST(thr);\n\t\t\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\t\t\tthr->heap->call_recursion_depth--; /* No recursion increase for this case. */\n\t\t\treturn 1; /* 1=reuse executor */\n\t\t}\n\t\tDUK_ASSERT(use_tailcall == 0);\n\n\t\t/* duk_hthread_activation_unwind_norz() will decrease this on unwind */\n\t\tDUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);\n\t\tact->flags |= DUK_ACT_FLAG_PREVENT_YIELD;\n\t\tthr->callstack_preventcount++;\n\n\t\t/* [ ... func this | arg1 ... argN ] ('this' must precede new bottom) */\n\n\t\t/*\n\t\t *  Bytecode executor call.\n\t\t *\n\t\t *  Execute bytecode, handling any recursive function calls and\n\t\t *  thread resumptions.  Returns when execution would return from\n\t\t *  the entry level activation.  When the executor returns, a\n\t\t *  single return value is left on the stack top.\n\t\t *\n\t\t *  The only possible longjmp() is an error (DUK_LJ_TYPE_THROW),\n\t\t *  other types are handled internally by the executor.\n\t\t */\n\n\t\t/* thr->ptr_curr_pc is set by bytecode executor early on entry */\n\t\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\t\tDUK_DDD(DUK_DDDPRINT(\"entering bytecode execution\"));\n\t\tduk_js_execute_bytecode(thr);\n\t\tDUK_DDD(DUK_DDDPRINT(\"returned from bytecode execution\"));\n\t} else {\n\t\t/*\n\t\t *  Native call.\n\t\t */\n\n\t\tDUK_ASSERT(func == NULL || ((duk_hnatfunc *) func)->func != NULL);\n\t\tDUK_ASSERT(use_tailcall == 0);\n\n\t\t/* [ ... func this | arg1 ... argN ] ('this' must precede new bottom) */\n\n\t\t/* duk_hthread_activation_unwind_norz() will decrease this on unwind */\n\t\tDUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);\n\t\tact->flags |= DUK_ACT_FLAG_PREVENT_YIELD;\n\t\tthr->callstack_preventcount++;\n\n\t\t/* For native calls must be NULL so we don't sync back */\n\t\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\n\t\t/* XXX: native funcptr could come out of call setup. */\n\t\tif (func != NULL) {\n\t\t\trc = ((duk_hnatfunc *) func)->func(thr);\n\t\t} else {\n\t\t\tduk_tval *tv_func;\n\t\t\tduk_c_function funcptr;\n\n\t\t\ttv_func = &act->tv_func;\n\t\t\tDUK_ASSERT(DUK_TVAL_IS_LIGHTFUNC(tv_func));\n\t\t\tfuncptr = DUK_TVAL_GET_LIGHTFUNC_FUNCPTR(tv_func);\n\t\t\trc = funcptr(thr);\n\t\t}\n\n\t\t/* Automatic error throwing, retval check. */\n\n\t\tif (rc == 0) {\n\t\t\tDUK_ASSERT(thr->valstack < thr->valstack_end);\n\t\t\tDUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top));\n\t\t\tthr->valstack_top++;\n\t\t} else if (rc == 1) {\n\t\t\t;\n\t\t} else if (rc < 0) {\n\t\t\tduk_error_throw_from_negative_rc(thr, rc);\n\t\t\tDUK_WO_NORETURN(return 0;);\n\t\t} else {\n\t\t\tDUK_ERROR_TYPE(thr, DUK_STR_INVALID_CFUNC_RC);\n\t\t\tDUK_WO_NORETURN(return 0;);\n\t\t}\n\t}\n\tDUK_ASSERT(thr->ptr_curr_pc == NULL);\n\tDUK_ASSERT(use_tailcall == 0);\n\n\t/*\n\t *  Constructor call post processing.\n\t */\n\n#if defined(DUK_USE_ES6_PROXY)\n\tif (call_flags & (DUK_CALL_FLAG_CONSTRUCT | DUK_CALL_FLAG_CONSTRUCT_PROXY)) {\n\t\tduk_call_construct_postprocess(thr, call_flags & DUK_CALL_FLAG_CONSTRUCT_PROXY);\n\t}\n#else\n\tif (call_flags & DUK_CALL_FLAG_CONSTRUCT) {\n\t\tduk_call_construct_postprocess(thr, 0);\n\t}\n#endif\n\n\t/*\n\t *  Unwind, restore valstack bottom and other book-keeping.\n\t */\n\n\tDUK_ASSERT(thr->callstack_curr != NULL);\n\tDUK_ASSERT(thr->callstack_curr->parent == entry_act);\n\tDUK_ASSERT(thr->callstack_top == entry_callstack_top + 1);\n\tduk_hthread_activation_unwind_norz(thr);\n\tDUK_ASSERT(thr->callstack_curr == entry_act);\n\tDUK_ASSERT(thr->callstack_top == entry_callstack_top);\n\n\tthr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_bottom_byteoff);\n\t/* keep current valstack_top */\n\tDUK_ASSERT(thr->valstack_bottom >= thr->valstack);\n\tDUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);\n\tDUK_ASSERT(thr->valstack_end >= thr->valstack_top);\n\tDUK_ASSERT(thr->valstack_top - thr->valstack_bottom >= idx_func + 1);\n\n\t/* Return value handling. */\n\n\t/* [ ... func this (crud) retval ] */\n\n\t{\n\t\tduk_tval *tv_ret;\n\t\tduk_tval *tv_funret;\n\n\t\ttv_ret = thr->valstack_bottom + idx_func;\n\t\ttv_funret = thr->valstack_top - 1;\n#if defined(DUK_USE_FASTINT)\n\t\t/* Explicit check for fastint downgrade. */\n\t\tDUK_TVAL_CHKFAST_INPLACE_FAST(tv_funret);\n#endif\n\t\tDUK_TVAL_SET_TVAL_UPDREF(thr, tv_ret, tv_funret); /* side effects */\n\t}\n\n\tduk_set_top_unsafe(thr, idx_func + 1);\n\n\t/* [ ... retval ] */\n\n\t/* Restore caller's value stack reserve (cannot fail). */\n\tDUK_ASSERT((duk_uint8_t *) thr->valstack + entry_valstack_end_byteoff >= (duk_uint8_t *) thr->valstack_top);\n\tDUK_ASSERT((duk_uint8_t *) thr->valstack + entry_valstack_end_byteoff <= (duk_uint8_t *) thr->valstack_alloc_end);\n\tthr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_end_byteoff);\n\n\t/* XXX: Trial value stack shrink would be OK here, but we'd need\n\t * to prevent side effects of the potential realloc.\n\t */\n\n\t/* Restore entry thread executor curr_pc stack frame pointer. */\n\tthr->ptr_curr_pc = entry_ptr_curr_pc;\n\n\tDUK_HEAP_SWITCH_THREAD(thr->heap, entry_curr_thread); /* may be NULL */\n\tthr->state = (duk_uint8_t) entry_thread_state;\n\n\t/* Disabled assert: triggered with some torture tests. */\n#if 0\n\tDUK_ASSERT((thr->state == DUK_HTHREAD_STATE_INACTIVE && thr->heap->curr_thread == NULL) ||  /* first call */\n\t           (thr->state == DUK_HTHREAD_STATE_INACTIVE && thr->heap->curr_thread != NULL) ||  /* other call */\n\t           (thr->state == DUK_HTHREAD_STATE_RUNNING && thr->heap->curr_thread == thr));     /* current thread */\n#endif\n\n\tthr->heap->call_recursion_depth = entry_call_recursion_depth;\n\n\t/* If the debugger is active we need to force an interrupt so that\n\t * debugger breakpoints are rechecked.  This is important for function\n\t * calls caused by side effects (e.g. when doing a DUK_OP_GETPROP), see\n\t * GH-303.  Only needed for success path, error path always causes a\n\t * breakpoint recheck in the executor.  It would be enough to set this\n\t * only when returning to an ECMAScript activation, but setting the flag\n\t * on every return should have no ill effect.\n\t */\n#if defined(DUK_USE_DEBUGGER_SUPPORT)\n\tif (duk_debug_is_attached(thr->heap)) {\n\t\tDUK_DD(DUK_DDPRINT(\"returning with debugger enabled, force interrupt\"));\n\t\tDUK_ASSERT(thr->interrupt_counter <= thr->interrupt_init);\n\t\tthr->interrupt_init -= thr->interrupt_counter;\n\t\tthr->interrupt_counter = 0;\n\t\tthr->heap->dbg_force_restart = 1;\n\t}\n#endif\n\n#if defined(DUK_USE_INTERRUPT_COUNTER) && defined(DUK_USE_DEBUG)\n\tduk__interrupt_fixup(thr, entry_curr_thread);\n#endif\n\n\t/* Restored by success path. */\n\tDUK_ASSERT(thr->heap->call_recursion_depth == entry_call_recursion_depth);\n\tDUK_ASSERT(thr->ptr_curr_pc == entry_ptr_curr_pc);\n\tDUK_ASSERT_LJSTATE_UNSET(thr->heap);\n\n\tDUK_REFZERO_CHECK_FAST(thr);\n\n\treturn 0; /* 0=call handled inline */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -202,6 +202,15 @@\n \t/* [ ... func this arg1 ... argN ] */\n \n \t/*\n+\t *  Grow value stack to required size before env setup.  This\n+\t *  must happen before env setup to handle some corner cases\n+\t *  correctly, e.g. test-bug-scope-segv-gh2448.js.\n+\t */\n+\n+\tduk_valstack_grow_check_throw(thr, vs_min_bytes);\n+\tact->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);\n+\n+\t/*\n \t *  Environment record creation and 'arguments' object creation.\n \t *  Named function expression name binding is handled by the\n \t *  compiler; the compiled function's parent env will contain\n@@ -222,12 +231,7 @@\n \t *  Setup value stack: clamp to 'nargs', fill up to 'nregs',\n \t *  ensure value stack size matches target requirements, and\n \t *  switch value stack bottom.  Valstack top is kept.\n-\t *\n-\t *  Value stack can only grow here.\n-\t */\n-\n-\tduk_valstack_grow_check_throw(thr, vs_min_bytes);\n-\tact->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);\n+\t */\n \n \tif (use_tailcall) {\n \t\tDUK_ASSERT(nregs >= 0);",
        "diff_line_info": {
            "deleted_lines": [
                "\t *",
                "\t *  Value stack can only grow here.",
                "\t */",
                "",
                "\tduk_valstack_grow_check_throw(thr, vs_min_bytes);",
                "\tact->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);"
            ],
            "added_lines": [
                "\t *  Grow value stack to required size before env setup.  This",
                "\t *  must happen before env setup to handle some corner cases",
                "\t *  correctly, e.g. test-bug-scope-segv-gh2448.js.",
                "\t */",
                "",
                "\tduk_valstack_grow_check_throw(thr, vs_min_bytes);",
                "\tact->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);",
                "",
                "\t/*",
                "\t */"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12049",
        "func_name": "dbus/_dbus_read_socket_with_unix_fds",
        "description": "An issue was discovered in dbus >= 1.3.0 before 1.12.18. The DBusServer in libdbus, as used in dbus-daemon, leaks file descriptors when a message exceeds the per-message file descriptor limit. A local attacker with access to the D-Bus system bus or another system service's private AF_UNIX socket could use this to make the system service reach its file descriptor limit, denying service to subsequent D-Bus clients.",
        "git_url": "https://cgit.freedesktop.org/dbus/dbus/commit/?id=872b085f12f56da25a2dbd9bd0b2dff31d5aea63",
        "commit_title": "MSG_CTRUNC indicates that we have received fewer fds that we should",
        "commit_text": "have done because the buffer was too small, but we were treating it as though it indicated that we received *no* fds. If we received any, we still have to make sure we close them, otherwise they will be leaked.  On the system bus, if an attacker can induce us to leak fds in this way, that's a local denial of service via resource exhaustion.  ",
        "func_before": "int\n_dbus_read_socket_with_unix_fds (DBusSocket        fd,\n                                 DBusString       *buffer,\n                                 int               count,\n                                 int              *fds,\n                                 unsigned int     *n_fds) {\n#ifndef HAVE_UNIX_FD_PASSING\n  int r;\n\n  if ((r = _dbus_read_socket(fd, buffer, count)) < 0)\n    return r;\n\n  *n_fds = 0;\n  return r;\n\n#else\n  int bytes_read;\n  int start;\n  struct msghdr m;\n  struct iovec iov;\n\n  _dbus_assert (count >= 0);\n  _dbus_assert (*n_fds <= DBUS_MAXIMUM_MESSAGE_UNIX_FDS);\n\n  start = _dbus_string_get_length (buffer);\n\n  if (!_dbus_string_lengthen (buffer, count))\n    {\n      errno = ENOMEM;\n      return -1;\n    }\n\n  _DBUS_ZERO(iov);\n  iov.iov_base = _dbus_string_get_data_len (buffer, start, count);\n  iov.iov_len = count;\n\n  _DBUS_ZERO(m);\n  m.msg_iov = &iov;\n  m.msg_iovlen = 1;\n\n  /* Hmm, we have no clue how long the control data will actually be\n     that is queued for us. The least we can do is assume that the\n     caller knows. Hence let's make space for the number of fds that\n     we shall read at max plus the cmsg header. */\n  m.msg_controllen = CMSG_SPACE(*n_fds * sizeof(int));\n\n  /* It's probably safe to assume that systems with SCM_RIGHTS also\n     know alloca() */\n  m.msg_control = alloca(m.msg_controllen);\n  memset(m.msg_control, 0, m.msg_controllen);\n\n  /* Do not include the padding at the end when we tell the kernel\n   * how much we're willing to receive. This avoids getting\n   * the padding filled with additional fds that we weren't expecting,\n   * if a (potentially malicious) sender included them. (fd.o #83622) */\n  m.msg_controllen = CMSG_LEN (*n_fds * sizeof(int));\n\n again:\n\n  bytes_read = recvmsg (fd.fd, &m, 0\n#ifdef MSG_CMSG_CLOEXEC\n                       |MSG_CMSG_CLOEXEC\n#endif\n                       );\n\n  if (bytes_read < 0)\n    {\n      if (errno == EINTR)\n        goto again;\n      else\n        {\n          /* put length back (note that this doesn't actually realloc anything) */\n          _dbus_string_set_length (buffer, start);\n          return -1;\n        }\n    }\n  else\n    {\n      struct cmsghdr *cm;\n      dbus_bool_t found = FALSE;\n\n      if (m.msg_flags & MSG_CTRUNC)\n        {\n          /* Hmm, apparently the control data was truncated. The bad\n             thing is that we might have completely lost a couple of fds\n             without chance to recover them. Hence let's treat this as a\n             serious error. */\n\n          errno = ENOSPC;\n          _dbus_string_set_length (buffer, start);\n          return -1;\n        }\n\n      for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))\n        if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_RIGHTS)\n          {\n            size_t i;\n            int *payload = (int *) CMSG_DATA (cm);\n            size_t payload_len_bytes = (cm->cmsg_len - CMSG_LEN (0));\n            size_t payload_len_fds = payload_len_bytes / sizeof (int);\n            size_t fds_to_use;\n\n            /* Every unsigned int fits in a size_t without truncation, so\n             * casting (size_t) *n_fds is OK */\n            _DBUS_STATIC_ASSERT (sizeof (size_t) >= sizeof (unsigned int));\n\n            if (_DBUS_LIKELY (payload_len_fds <= (size_t) *n_fds))\n              {\n                /* The fds in the payload will fit in our buffer */\n                fds_to_use = payload_len_fds;\n              }\n            else\n              {\n                /* Too many fds in the payload. This shouldn't happen\n                 * any more because we're setting m.msg_controllen to\n                 * the exact number we can accept, but be safe and\n                 * truncate. */\n                fds_to_use = (size_t) *n_fds;\n\n                /* Close the excess fds to avoid DoS: if they stayed open,\n                 * someone could send us an extra fd per message\n                 * and we'd eventually run out. */\n                for (i = fds_to_use; i < payload_len_fds; i++)\n                  {\n                    close (payload[i]);\n                  }\n              }\n\n            memcpy (fds, payload, fds_to_use * sizeof (int));\n            found = TRUE;\n            /* This narrowing cast from size_t to unsigned int cannot\n             * overflow because we have chosen fds_to_use\n             * to be <= *n_fds */\n            *n_fds = (unsigned int) fds_to_use;\n\n            /* Linux doesn't tell us whether MSG_CMSG_CLOEXEC actually\n               worked, hence we need to go through this list and set\n               CLOEXEC everywhere in any case */\n            for (i = 0; i < fds_to_use; i++)\n              _dbus_fd_set_close_on_exec(fds[i]);\n\n            break;\n          }\n\n      if (!found)\n        *n_fds = 0;\n\n      /* put length back (doesn't actually realloc) */\n      _dbus_string_set_length (buffer, start + bytes_read);\n\n#if 0\n      if (bytes_read > 0)\n        _dbus_verbose_bytes_of_string (buffer, start, bytes_read);\n#endif\n\n      return bytes_read;\n    }\n#endif\n}",
        "func": "int\n_dbus_read_socket_with_unix_fds (DBusSocket        fd,\n                                 DBusString       *buffer,\n                                 int               count,\n                                 int              *fds,\n                                 unsigned int     *n_fds) {\n#ifndef HAVE_UNIX_FD_PASSING\n  int r;\n\n  if ((r = _dbus_read_socket(fd, buffer, count)) < 0)\n    return r;\n\n  *n_fds = 0;\n  return r;\n\n#else\n  int bytes_read;\n  int start;\n  struct msghdr m;\n  struct iovec iov;\n\n  _dbus_assert (count >= 0);\n  _dbus_assert (*n_fds <= DBUS_MAXIMUM_MESSAGE_UNIX_FDS);\n\n  start = _dbus_string_get_length (buffer);\n\n  if (!_dbus_string_lengthen (buffer, count))\n    {\n      errno = ENOMEM;\n      return -1;\n    }\n\n  _DBUS_ZERO(iov);\n  iov.iov_base = _dbus_string_get_data_len (buffer, start, count);\n  iov.iov_len = count;\n\n  _DBUS_ZERO(m);\n  m.msg_iov = &iov;\n  m.msg_iovlen = 1;\n\n  /* Hmm, we have no clue how long the control data will actually be\n     that is queued for us. The least we can do is assume that the\n     caller knows. Hence let's make space for the number of fds that\n     we shall read at max plus the cmsg header. */\n  m.msg_controllen = CMSG_SPACE(*n_fds * sizeof(int));\n\n  /* It's probably safe to assume that systems with SCM_RIGHTS also\n     know alloca() */\n  m.msg_control = alloca(m.msg_controllen);\n  memset(m.msg_control, 0, m.msg_controllen);\n\n  /* Do not include the padding at the end when we tell the kernel\n   * how much we're willing to receive. This avoids getting\n   * the padding filled with additional fds that we weren't expecting,\n   * if a (potentially malicious) sender included them. (fd.o #83622) */\n  m.msg_controllen = CMSG_LEN (*n_fds * sizeof(int));\n\n again:\n\n  bytes_read = recvmsg (fd.fd, &m, 0\n#ifdef MSG_CMSG_CLOEXEC\n                       |MSG_CMSG_CLOEXEC\n#endif\n                       );\n\n  if (bytes_read < 0)\n    {\n      if (errno == EINTR)\n        goto again;\n      else\n        {\n          /* put length back (note that this doesn't actually realloc anything) */\n          _dbus_string_set_length (buffer, start);\n          return -1;\n        }\n    }\n  else\n    {\n      struct cmsghdr *cm;\n      dbus_bool_t found = FALSE;\n\n      for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))\n        if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_RIGHTS)\n          {\n            size_t i;\n            int *payload = (int *) CMSG_DATA (cm);\n            size_t payload_len_bytes = (cm->cmsg_len - CMSG_LEN (0));\n            size_t payload_len_fds = payload_len_bytes / sizeof (int);\n            size_t fds_to_use;\n\n            /* Every unsigned int fits in a size_t without truncation, so\n             * casting (size_t) *n_fds is OK */\n            _DBUS_STATIC_ASSERT (sizeof (size_t) >= sizeof (unsigned int));\n\n            if (_DBUS_LIKELY (payload_len_fds <= (size_t) *n_fds))\n              {\n                /* The fds in the payload will fit in our buffer */\n                fds_to_use = payload_len_fds;\n              }\n            else\n              {\n                /* Too many fds in the payload. This shouldn't happen\n                 * any more because we're setting m.msg_controllen to\n                 * the exact number we can accept, but be safe and\n                 * truncate. */\n                fds_to_use = (size_t) *n_fds;\n\n                /* Close the excess fds to avoid DoS: if they stayed open,\n                 * someone could send us an extra fd per message\n                 * and we'd eventually run out. */\n                for (i = fds_to_use; i < payload_len_fds; i++)\n                  {\n                    close (payload[i]);\n                  }\n              }\n\n            memcpy (fds, payload, fds_to_use * sizeof (int));\n            found = TRUE;\n            /* This narrowing cast from size_t to unsigned int cannot\n             * overflow because we have chosen fds_to_use\n             * to be <= *n_fds */\n            *n_fds = (unsigned int) fds_to_use;\n\n            /* Linux doesn't tell us whether MSG_CMSG_CLOEXEC actually\n               worked, hence we need to go through this list and set\n               CLOEXEC everywhere in any case */\n            for (i = 0; i < fds_to_use; i++)\n              _dbus_fd_set_close_on_exec(fds[i]);\n\n            break;\n          }\n\n      if (!found)\n        *n_fds = 0;\n\n      if (m.msg_flags & MSG_CTRUNC)\n        {\n          unsigned int i;\n\n          /* Hmm, apparently the control data was truncated. The bad\n             thing is that we might have completely lost a couple of fds\n             without chance to recover them. Hence let's treat this as a\n             serious error. */\n\n          /* We still need to close whatever fds we *did* receive,\n           * otherwise they'll never get closed. (CVE-2020-12049) */\n          for (i = 0; i < *n_fds; i++)\n            close (fds[i]);\n\n          *n_fds = 0;\n          errno = ENOSPC;\n          _dbus_string_set_length (buffer, start);\n          return -1;\n        }\n\n      /* put length back (doesn't actually realloc) */\n      _dbus_string_set_length (buffer, start + bytes_read);\n\n#if 0\n      if (bytes_read > 0)\n        _dbus_verbose_bytes_of_string (buffer, start, bytes_read);\n#endif\n\n      return bytes_read;\n    }\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -79,18 +79,6 @@\n       struct cmsghdr *cm;\n       dbus_bool_t found = FALSE;\n \n-      if (m.msg_flags & MSG_CTRUNC)\n-        {\n-          /* Hmm, apparently the control data was truncated. The bad\n-             thing is that we might have completely lost a couple of fds\n-             without chance to recover them. Hence let's treat this as a\n-             serious error. */\n-\n-          errno = ENOSPC;\n-          _dbus_string_set_length (buffer, start);\n-          return -1;\n-        }\n-\n       for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))\n         if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_RIGHTS)\n           {\n@@ -145,6 +133,26 @@\n       if (!found)\n         *n_fds = 0;\n \n+      if (m.msg_flags & MSG_CTRUNC)\n+        {\n+          unsigned int i;\n+\n+          /* Hmm, apparently the control data was truncated. The bad\n+             thing is that we might have completely lost a couple of fds\n+             without chance to recover them. Hence let's treat this as a\n+             serious error. */\n+\n+          /* We still need to close whatever fds we *did* receive,\n+           * otherwise they'll never get closed. (CVE-2020-12049) */\n+          for (i = 0; i < *n_fds; i++)\n+            close (fds[i]);\n+\n+          *n_fds = 0;\n+          errno = ENOSPC;\n+          _dbus_string_set_length (buffer, start);\n+          return -1;\n+        }\n+\n       /* put length back (doesn't actually realloc) */\n       _dbus_string_set_length (buffer, start + bytes_read);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      if (m.msg_flags & MSG_CTRUNC)",
                "        {",
                "          /* Hmm, apparently the control data was truncated. The bad",
                "             thing is that we might have completely lost a couple of fds",
                "             without chance to recover them. Hence let's treat this as a",
                "             serious error. */",
                "",
                "          errno = ENOSPC;",
                "          _dbus_string_set_length (buffer, start);",
                "          return -1;",
                "        }",
                ""
            ],
            "added_lines": [
                "      if (m.msg_flags & MSG_CTRUNC)",
                "        {",
                "          unsigned int i;",
                "",
                "          /* Hmm, apparently the control data was truncated. The bad",
                "             thing is that we might have completely lost a couple of fds",
                "             without chance to recover them. Hence let's treat this as a",
                "             serious error. */",
                "",
                "          /* We still need to close whatever fds we *did* receive,",
                "           * otherwise they'll never get closed. (CVE-2020-12049) */",
                "          for (i = 0; i < *n_fds; i++)",
                "            close (fds[i]);",
                "",
                "          *n_fds = 0;",
                "          errno = ENOSPC;",
                "          _dbus_string_set_length (buffer, start);",
                "          return -1;",
                "        }",
                ""
            ]
        }
    }
]