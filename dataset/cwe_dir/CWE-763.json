[
    {
        "cve_id": "CVE-2022-24958",
        "func_name": "torvalds/linux/dev_config",
        "description": "drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.",
        "git_url": "https://github.com/torvalds/linux/commit/89f3594d0de58e8a57d92d497dea9fee3d4b9cda",
        "commit_title": "usb: gadget: don't release an existing dev->buf",
        "commit_text": " dev->buf does not need to be released if it already exists before executing dev_config.  Link: https://lore.kernel.org/r/20211231172138.7993-2-hbh25y@gmail.com",
        "func_before": "static ssize_t\ndev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tvalue, length = len;\n\tunsigned\t\ttotal;\n\tu32\t\t\ttag;\n\tchar\t\t\t*kbuf;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state > STATE_DEV_OPENED) {\n\t\tvalue = ep0_write(fd, buf, len, ptr);\n\t\tspin_unlock_irq(&dev->lock);\n\t\treturn value;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\tif ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||\n\t    (len > PAGE_SIZE * 4))\n\t\treturn -EINVAL;\n\n\t/* we might need to change message format someday */\n\tif (copy_from_user (&tag, buf, 4))\n\t\treturn -EFAULT;\n\tif (tag != 0)\n\t\treturn -EINVAL;\n\tbuf += 4;\n\tlength -= 4;\n\n\tkbuf = memdup_user(buf, length);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tspin_lock_irq (&dev->lock);\n\tvalue = -EINVAL;\n\tif (dev->buf) {\n\t\tkfree(kbuf);\n\t\tgoto fail;\n\t}\n\tdev->buf = kbuf;\n\n\t/* full or low speed config */\n\tdev->config = (void *) kbuf;\n\ttotal = le16_to_cpu(dev->config->wTotalLength);\n\tif (!is_valid_config(dev->config, total) ||\n\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tkbuf += total;\n\tlength -= total;\n\n\t/* optional high speed config */\n\tif (kbuf [1] == USB_DT_CONFIG) {\n\t\tdev->hs_config = (void *) kbuf;\n\t\ttotal = le16_to_cpu(dev->hs_config->wTotalLength);\n\t\tif (!is_valid_config(dev->hs_config, total) ||\n\t\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\t\tgoto fail;\n\t\tkbuf += total;\n\t\tlength -= total;\n\t} else {\n\t\tdev->hs_config = NULL;\n\t}\n\n\t/* could support multiple configs, using another encoding! */\n\n\t/* device descriptor (tweaked for paranoia) */\n\tif (length != USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tdev->dev = (void *)kbuf;\n\tif (dev->dev->bLength != USB_DT_DEVICE_SIZE\n\t\t\t|| dev->dev->bDescriptorType != USB_DT_DEVICE\n\t\t\t|| dev->dev->bNumConfigurations != 1)\n\t\tgoto fail;\n\tdev->dev->bcdUSB = cpu_to_le16 (0x0200);\n\n\t/* triggers gadgetfs_bind(); then we can enumerate. */\n\tspin_unlock_irq (&dev->lock);\n\tif (dev->hs_config)\n\t\tgadgetfs_driver.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tgadgetfs_driver.max_speed = USB_SPEED_FULL;\n\n\tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n\tif (value != 0) {\n\t\tkfree (dev->buf);\n\t\tdev->buf = NULL;\n\t} else {\n\t\t/* at this point \"good\" hardware has for the first time\n\t\t * let the USB the host see us.  alternatively, if users\n\t\t * unplug/replug that will clear all the error state.\n\t\t *\n\t\t * note:  everything running before here was guaranteed\n\t\t * to choke driver model style diagnostics.  from here\n\t\t * on, they can work ... except in cleanup paths that\n\t\t * kick in after the ep0 descriptor is closed.\n\t\t */\n\t\tvalue = len;\n\t\tdev->gadget_registered = true;\n\t}\n\treturn value;\n\nfail:\n\tspin_unlock_irq (&dev->lock);\n\tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\treturn value;\n}",
        "func": "static ssize_t\ndev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tvalue, length = len;\n\tunsigned\t\ttotal;\n\tu32\t\t\ttag;\n\tchar\t\t\t*kbuf;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state > STATE_DEV_OPENED) {\n\t\tvalue = ep0_write(fd, buf, len, ptr);\n\t\tspin_unlock_irq(&dev->lock);\n\t\treturn value;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\tif ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||\n\t    (len > PAGE_SIZE * 4))\n\t\treturn -EINVAL;\n\n\t/* we might need to change message format someday */\n\tif (copy_from_user (&tag, buf, 4))\n\t\treturn -EFAULT;\n\tif (tag != 0)\n\t\treturn -EINVAL;\n\tbuf += 4;\n\tlength -= 4;\n\n\tkbuf = memdup_user(buf, length);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tspin_lock_irq (&dev->lock);\n\tvalue = -EINVAL;\n\tif (dev->buf) {\n\t\tspin_unlock_irq(&dev->lock);\n\t\tkfree(kbuf);\n\t\treturn value;\n\t}\n\tdev->buf = kbuf;\n\n\t/* full or low speed config */\n\tdev->config = (void *) kbuf;\n\ttotal = le16_to_cpu(dev->config->wTotalLength);\n\tif (!is_valid_config(dev->config, total) ||\n\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tkbuf += total;\n\tlength -= total;\n\n\t/* optional high speed config */\n\tif (kbuf [1] == USB_DT_CONFIG) {\n\t\tdev->hs_config = (void *) kbuf;\n\t\ttotal = le16_to_cpu(dev->hs_config->wTotalLength);\n\t\tif (!is_valid_config(dev->hs_config, total) ||\n\t\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\t\tgoto fail;\n\t\tkbuf += total;\n\t\tlength -= total;\n\t} else {\n\t\tdev->hs_config = NULL;\n\t}\n\n\t/* could support multiple configs, using another encoding! */\n\n\t/* device descriptor (tweaked for paranoia) */\n\tif (length != USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tdev->dev = (void *)kbuf;\n\tif (dev->dev->bLength != USB_DT_DEVICE_SIZE\n\t\t\t|| dev->dev->bDescriptorType != USB_DT_DEVICE\n\t\t\t|| dev->dev->bNumConfigurations != 1)\n\t\tgoto fail;\n\tdev->dev->bcdUSB = cpu_to_le16 (0x0200);\n\n\t/* triggers gadgetfs_bind(); then we can enumerate. */\n\tspin_unlock_irq (&dev->lock);\n\tif (dev->hs_config)\n\t\tgadgetfs_driver.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tgadgetfs_driver.max_speed = USB_SPEED_FULL;\n\n\tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n\tif (value != 0) {\n\t\tkfree (dev->buf);\n\t\tdev->buf = NULL;\n\t} else {\n\t\t/* at this point \"good\" hardware has for the first time\n\t\t * let the USB the host see us.  alternatively, if users\n\t\t * unplug/replug that will clear all the error state.\n\t\t *\n\t\t * note:  everything running before here was guaranteed\n\t\t * to choke driver model style diagnostics.  from here\n\t\t * on, they can work ... except in cleanup paths that\n\t\t * kick in after the ep0 descriptor is closed.\n\t\t */\n\t\tvalue = len;\n\t\tdev->gadget_registered = true;\n\t}\n\treturn value;\n\nfail:\n\tspin_unlock_irq (&dev->lock);\n\tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\treturn value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,8 +34,9 @@\n \tspin_lock_irq (&dev->lock);\n \tvalue = -EINVAL;\n \tif (dev->buf) {\n+\t\tspin_unlock_irq(&dev->lock);\n \t\tkfree(kbuf);\n-\t\tgoto fail;\n+\t\treturn value;\n \t}\n \tdev->buf = kbuf;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgoto fail;"
            ],
            "added_lines": [
                "\t\tspin_unlock_irq(&dev->lock);",
                "\t\treturn value;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24958",
        "func_name": "torvalds/linux/dev_config",
        "description": "drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.",
        "git_url": "https://github.com/torvalds/linux/commit/501e38a5531efbd77d5c73c0ba838a889bfc1d74",
        "commit_title": "usb: gadget: clear related members when goto fail",
        "commit_text": " dev->config and dev->hs_config and dev->dev need to be cleaned if dev_config fails to avoid UAF.  Link: https://lore.kernel.org/r/20211231172138.7993-3-hbh25y@gmail.com",
        "func_before": "static ssize_t\ndev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tvalue, length = len;\n\tunsigned\t\ttotal;\n\tu32\t\t\ttag;\n\tchar\t\t\t*kbuf;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state > STATE_DEV_OPENED) {\n\t\tvalue = ep0_write(fd, buf, len, ptr);\n\t\tspin_unlock_irq(&dev->lock);\n\t\treturn value;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\tif ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||\n\t    (len > PAGE_SIZE * 4))\n\t\treturn -EINVAL;\n\n\t/* we might need to change message format someday */\n\tif (copy_from_user (&tag, buf, 4))\n\t\treturn -EFAULT;\n\tif (tag != 0)\n\t\treturn -EINVAL;\n\tbuf += 4;\n\tlength -= 4;\n\n\tkbuf = memdup_user(buf, length);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tspin_lock_irq (&dev->lock);\n\tvalue = -EINVAL;\n\tif (dev->buf) {\n\t\tspin_unlock_irq(&dev->lock);\n\t\tkfree(kbuf);\n\t\treturn value;\n\t}\n\tdev->buf = kbuf;\n\n\t/* full or low speed config */\n\tdev->config = (void *) kbuf;\n\ttotal = le16_to_cpu(dev->config->wTotalLength);\n\tif (!is_valid_config(dev->config, total) ||\n\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tkbuf += total;\n\tlength -= total;\n\n\t/* optional high speed config */\n\tif (kbuf [1] == USB_DT_CONFIG) {\n\t\tdev->hs_config = (void *) kbuf;\n\t\ttotal = le16_to_cpu(dev->hs_config->wTotalLength);\n\t\tif (!is_valid_config(dev->hs_config, total) ||\n\t\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\t\tgoto fail;\n\t\tkbuf += total;\n\t\tlength -= total;\n\t} else {\n\t\tdev->hs_config = NULL;\n\t}\n\n\t/* could support multiple configs, using another encoding! */\n\n\t/* device descriptor (tweaked for paranoia) */\n\tif (length != USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tdev->dev = (void *)kbuf;\n\tif (dev->dev->bLength != USB_DT_DEVICE_SIZE\n\t\t\t|| dev->dev->bDescriptorType != USB_DT_DEVICE\n\t\t\t|| dev->dev->bNumConfigurations != 1)\n\t\tgoto fail;\n\tdev->dev->bcdUSB = cpu_to_le16 (0x0200);\n\n\t/* triggers gadgetfs_bind(); then we can enumerate. */\n\tspin_unlock_irq (&dev->lock);\n\tif (dev->hs_config)\n\t\tgadgetfs_driver.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tgadgetfs_driver.max_speed = USB_SPEED_FULL;\n\n\tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n\tif (value != 0) {\n\t\tkfree (dev->buf);\n\t\tdev->buf = NULL;\n\t} else {\n\t\t/* at this point \"good\" hardware has for the first time\n\t\t * let the USB the host see us.  alternatively, if users\n\t\t * unplug/replug that will clear all the error state.\n\t\t *\n\t\t * note:  everything running before here was guaranteed\n\t\t * to choke driver model style diagnostics.  from here\n\t\t * on, they can work ... except in cleanup paths that\n\t\t * kick in after the ep0 descriptor is closed.\n\t\t */\n\t\tvalue = len;\n\t\tdev->gadget_registered = true;\n\t}\n\treturn value;\n\nfail:\n\tspin_unlock_irq (&dev->lock);\n\tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\treturn value;\n}",
        "func": "static ssize_t\ndev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tvalue, length = len;\n\tunsigned\t\ttotal;\n\tu32\t\t\ttag;\n\tchar\t\t\t*kbuf;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state > STATE_DEV_OPENED) {\n\t\tvalue = ep0_write(fd, buf, len, ptr);\n\t\tspin_unlock_irq(&dev->lock);\n\t\treturn value;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\tif ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||\n\t    (len > PAGE_SIZE * 4))\n\t\treturn -EINVAL;\n\n\t/* we might need to change message format someday */\n\tif (copy_from_user (&tag, buf, 4))\n\t\treturn -EFAULT;\n\tif (tag != 0)\n\t\treturn -EINVAL;\n\tbuf += 4;\n\tlength -= 4;\n\n\tkbuf = memdup_user(buf, length);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tspin_lock_irq (&dev->lock);\n\tvalue = -EINVAL;\n\tif (dev->buf) {\n\t\tspin_unlock_irq(&dev->lock);\n\t\tkfree(kbuf);\n\t\treturn value;\n\t}\n\tdev->buf = kbuf;\n\n\t/* full or low speed config */\n\tdev->config = (void *) kbuf;\n\ttotal = le16_to_cpu(dev->config->wTotalLength);\n\tif (!is_valid_config(dev->config, total) ||\n\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tkbuf += total;\n\tlength -= total;\n\n\t/* optional high speed config */\n\tif (kbuf [1] == USB_DT_CONFIG) {\n\t\tdev->hs_config = (void *) kbuf;\n\t\ttotal = le16_to_cpu(dev->hs_config->wTotalLength);\n\t\tif (!is_valid_config(dev->hs_config, total) ||\n\t\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\t\tgoto fail;\n\t\tkbuf += total;\n\t\tlength -= total;\n\t} else {\n\t\tdev->hs_config = NULL;\n\t}\n\n\t/* could support multiple configs, using another encoding! */\n\n\t/* device descriptor (tweaked for paranoia) */\n\tif (length != USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tdev->dev = (void *)kbuf;\n\tif (dev->dev->bLength != USB_DT_DEVICE_SIZE\n\t\t\t|| dev->dev->bDescriptorType != USB_DT_DEVICE\n\t\t\t|| dev->dev->bNumConfigurations != 1)\n\t\tgoto fail;\n\tdev->dev->bcdUSB = cpu_to_le16 (0x0200);\n\n\t/* triggers gadgetfs_bind(); then we can enumerate. */\n\tspin_unlock_irq (&dev->lock);\n\tif (dev->hs_config)\n\t\tgadgetfs_driver.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tgadgetfs_driver.max_speed = USB_SPEED_FULL;\n\n\tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n\tif (value != 0) {\n\t\tspin_lock_irq(&dev->lock);\n\t\tgoto fail;\n\t} else {\n\t\t/* at this point \"good\" hardware has for the first time\n\t\t * let the USB the host see us.  alternatively, if users\n\t\t * unplug/replug that will clear all the error state.\n\t\t *\n\t\t * note:  everything running before here was guaranteed\n\t\t * to choke driver model style diagnostics.  from here\n\t\t * on, they can work ... except in cleanup paths that\n\t\t * kick in after the ep0 descriptor is closed.\n\t\t */\n\t\tvalue = len;\n\t\tdev->gadget_registered = true;\n\t}\n\treturn value;\n\nfail:\n\tdev->config = NULL;\n\tdev->hs_config = NULL;\n\tdev->dev = NULL;\n\tspin_unlock_irq (&dev->lock);\n\tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\treturn value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -83,8 +83,8 @@\n \n \tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n \tif (value != 0) {\n-\t\tkfree (dev->buf);\n-\t\tdev->buf = NULL;\n+\t\tspin_lock_irq(&dev->lock);\n+\t\tgoto fail;\n \t} else {\n \t\t/* at this point \"good\" hardware has for the first time\n \t\t * let the USB the host see us.  alternatively, if users\n@@ -101,6 +101,9 @@\n \treturn value;\n \n fail:\n+\tdev->config = NULL;\n+\tdev->hs_config = NULL;\n+\tdev->dev = NULL;\n \tspin_unlock_irq (&dev->lock);\n \tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n \tkfree (dev->buf);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tkfree (dev->buf);",
                "\t\tdev->buf = NULL;"
            ],
            "added_lines": [
                "\t\tspin_lock_irq(&dev->lock);",
                "\t\tgoto fail;",
                "\tdev->config = NULL;",
                "\tdev->hs_config = NULL;",
                "\tdev->dev = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27797",
        "func_name": "upx/PackLinuxElf32::check_pt_dynamic",
        "description": "An invalid memory address reference was discovered in the elf_lookup function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.",
        "git_url": "https://github.com/upx/upx/commit/73b854874e723f38e84e5ff57a9eeb99653ca74c",
        "commit_title": "Defend against junk PT_DYNAMIC",
        "commit_text": " https://github.com/upx/upx/issues/390 \tmodified:   p_lx_elf.cpp",
        "func_before": "unsigned  // checked .p_offset; sz_dynseg set\nPackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    unsigned align = get_te32(&phdr->p_align);\n    if (s < t || (u32_t)file_size < s\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  (-1+ align) & (t ^ vaddr)\n    ||  (unsigned long)file_size <= memsz\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
        "func": "unsigned  // checked .p_offset; sz_dynseg set\nPackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    unsigned align = get_te32(&phdr->p_align);\n    if (s < t || (u32_t)file_size < s || t < sizeof(Elf32_Ehdr)\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  (-1+ align) & (t ^ vaddr)\n    ||  (unsigned long)file_size <= memsz\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     unsigned vaddr = get_te32(&phdr->p_vaddr);\n     unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n     unsigned align = get_te32(&phdr->p_align);\n-    if (s < t || (u32_t)file_size < s\n+    if (s < t || (u32_t)file_size < s || t < sizeof(Elf32_Ehdr)\n     ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n     ||  (-1+ align) & (t ^ vaddr)\n     ||  (unsigned long)file_size <= memsz",
        "diff_line_info": {
            "deleted_lines": [
                "    if (s < t || (u32_t)file_size < s"
            ],
            "added_lines": [
                "    if (s < t || (u32_t)file_size < s || t < sizeof(Elf32_Ehdr)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27797",
        "func_name": "upx/PackLinuxElf64::check_pt_dynamic",
        "description": "An invalid memory address reference was discovered in the elf_lookup function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.",
        "git_url": "https://github.com/upx/upx/commit/73b854874e723f38e84e5ff57a9eeb99653ca74c",
        "commit_title": "Defend against junk PT_DYNAMIC",
        "commit_text": " https://github.com/upx/upx/issues/390 \tmodified:   p_lx_elf.cpp",
        "func_before": "upx_uint64_t  // checked .p_offset; sz_dynseg set\nPackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n{\n    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n    upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n    upx_uint64_t align = get_te64(&phdr->p_align);\n    if (s < t || (upx_uint64_t)file_size < s\n    ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n    ||  (-1+ align) & (t ^ vaddr)\n    ||  (unsigned long)file_size <= memsz\n    ||  filesz < sizeof(Elf64_Dyn)\n    ||  memsz  < sizeof(Elf64_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
        "func": "upx_uint64_t  // checked .p_offset; sz_dynseg set\nPackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n{\n    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n    upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n    upx_uint64_t align = get_te64(&phdr->p_align);\n    if (s < t || (upx_uint64_t)file_size < s || t < sizeof(Elf64_Ehdr)\n    ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n    ||  (-1+ align) & (t ^ vaddr)\n    ||  (unsigned long)file_size <= memsz\n    ||  filesz < sizeof(Elf64_Dyn)\n    ||  memsz  < sizeof(Elf64_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n     upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n     upx_uint64_t align = get_te64(&phdr->p_align);\n-    if (s < t || (upx_uint64_t)file_size < s\n+    if (s < t || (upx_uint64_t)file_size < s || t < sizeof(Elf64_Ehdr)\n     ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n     ||  (-1+ align) & (t ^ vaddr)\n     ||  (unsigned long)file_size <= memsz",
        "diff_line_info": {
            "deleted_lines": [
                "    if (s < t || (upx_uint64_t)file_size < s"
            ],
            "added_lines": [
                "    if (s < t || (upx_uint64_t)file_size < s || t < sizeof(Elf64_Ehdr)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27798",
        "func_name": "upx/PackLinuxElf64::adjABS",
        "description": "An invalid memory address reference was discovered in the adjABS function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.",
        "git_url": "https://github.com/upx/upx/commit/77c914bce58aab9459029bed699f2bfb7ff2f90f",
        "commit_title": "Check de-compressed SHT_SYMTAB",
        "commit_text": " https://github.com/upx/upx/issues/396 \tmodified:   p_lx_elf.cpp",
        "func_before": "int\nPackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta)\n{\n    for (int j = 0; abs_symbol_names[j][0]; ++j) {\n        unsigned st_name = get_te32(&sym->st_name);\n        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n            sym->st_value += delta;\n            return 1;\n        }\n    }\n    return 0;\n}",
        "func": "int\nPackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta)\n{\n    unsigned st_name = get_te32(&sym->st_name);\n    for (int j = 0; abs_symbol_names[j][0]; ++j) {\n        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n            sym->st_value += delta;\n            return 1;\n        }\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n int\n PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta)\n {\n+    unsigned st_name = get_te32(&sym->st_name);\n     for (int j = 0; abs_symbol_names[j][0]; ++j) {\n-        unsigned st_name = get_te32(&sym->st_name);\n         if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n             sym->st_value += delta;\n             return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "        unsigned st_name = get_te32(&sym->st_name);"
            ],
            "added_lines": [
                "    unsigned st_name = get_te32(&sym->st_name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27798",
        "func_name": "upx/PackLinuxElf64::unpack",
        "description": "An invalid memory address reference was discovered in the adjABS function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.",
        "git_url": "https://github.com/upx/upx/commit/77c914bce58aab9459029bed699f2bfb7ff2f90f",
        "commit_title": "Check de-compressed SHT_SYMTAB",
        "commit_text": " https://github.com/upx/upx/issues/396 \tmodified:   p_lx_elf.cpp",
        "func_before": "void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\"l_info corrupted\");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((umin64(MAX_ELF_HDR, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack(\"bad compressed e_phnum\");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    Elf64_Phdr const *const dynhdr = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    bool const is_shlib = !!dynhdr;\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz));\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        ibuf.subref(\"bad .e_shoff %#lx for %#lx\", e_shoff, sizeof(Elf64_Shdr) * e_shnum);\n        if (e_shoff && e_shnum) { // --android-shlib\n            shdri = (Elf64_Shdr /*const*/ *)ibuf.subref(\n                \"bad Shdr table\", e_shoff, sizeof(Elf64_Shdr)*e_shnum);\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            dynseg = (Elf64_Dyn const *)ibuf.subref(\n                \"bad DYNAMIC\", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));\n            dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n            sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n                upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n                if ((upx_uint64_t)file_size < sz_dynsym\n                ||  (upx_uint64_t)file_size < off_dynsym\n                || ((upx_uint64_t)file_size - off_dynsym) < sz_dynsym) {\n                    throwCantUnpack(\"bad SHT_DYNSYM\");\n                }\n                Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                    \"bad dynsym\", off_dynsym, sz_dynsym);\n                Elf64_Sym *sym = sym0;\n                for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                    upx_uint64_t symval = get_te64(&sym->st_value);\n                    unsigned symsec = get_te16(&sym->st_shndx);\n                    if (Elf64_Sym::SHN_UNDEF != symsec\n                    &&  Elf64_Sym::SHN_ABS   != symsec\n                    &&  xct_off <= symval) {\n                        set_te64(&sym->st_value, symval - asl_delta);\n                    }\n                    if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {\n                        adjABS(sym, 0u - asl_delta);\n                    }\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n        // Position the input for next unpackExtent.\n        fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (0x1000==get_te64(&phdri[0].p_filesz)  // detect C_BASE style\n    &&  0==get_te64(&phdri[1].p_offset)\n    &&  0==get_te64(&phdri[0].p_offset)\n    &&     get_te64(&phdri[1].p_filesz) == get_te64(&phdri[1].p_memsz)) {\n        fi->seek(up4(get_te64(&phdr[1].p_memsz)), SEEK_SET);  // past the loader\n    }\n    else if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);\n            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr const *udynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&udynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&udynhdr->p_offset);\n                    if ((unsigned long)file_size < (dyn_len + dyn_off)) {\n                        char msg[50]; snprintf(msg, sizeof(msg),\n                                \"bad PT_DYNAMIC .p_filesz %#lx\", (long unsigned)dyn_len);\n                        throwCantUnpack(msg);\n                    }\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg, get_te64(&udynhdr->p_filesz));\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else if (Elf64_Dyn::DT_INIT_ARRAY    == tag\n                            ||       Elf64_Dyn::DT_PREINIT_ARRAY == tag) {\n                                if (val < load_va || (long unsigned)file_size < (long unsigned)val) {\n                                    char msg[50]; snprintf(msg, sizeof(msg),\n                                            \"Bad Dynamic tag %#lx %#lx\",\n                                            (long unsigned)tag, (long unsigned)val);\n                                    throwCantUnpack(msg);\n                                }\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                \"bad Rela offset\", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, old_dtinit, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                \"bad Jmprel offset\", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, old_dtinit, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}",
        "func": "void PackLinuxElf64::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    upx_uint64_t old_data_off = 0;\n    upx_uint64_t old_data_len = 0;\n    upx_uint64_t old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);\n        if (e_entry < 0x401180\n        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\"l_info corrupted\");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];\n    Elf64_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len)\n        throwCompressedDataViolation();\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n        // less strict for EM_PPC64 to workaround earlier bug\n    ||  !( ehdr->e_flags==ehdri.e_flags\n        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 1024\n    if ((umin64(MAX_ELF_HDR, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {\n        throwCantUnpack(\"bad compressed e_phnum\");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    Elf64_Phdr const *const dynhdr = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    bool const is_shlib = !!dynhdr;\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz));\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te64(&ehdri.e_shoff);\n        ibuf.subref(\"bad .e_shoff %#lx for %#lx\", e_shoff, sizeof(Elf64_Shdr) * e_shnum);\n        if (e_shoff && e_shnum) { // --android-shlib\n            shdri = (Elf64_Shdr /*const*/ *)ibuf.subref(\n                \"bad Shdr table\", e_shoff, sizeof(Elf64_Shdr)*e_shnum);\n            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            upx_uint64_t dyn_offset = get_te64(&dynhdr->p_offset);\n            upx_uint64_t dyn_filesz = get_te64(&dynhdr->p_filesz);\n            if (orig_file_size < dyn_offset\n            || (orig_file_size - dyn_offset) < dyn_filesz) {\n                throwCantUnpack(\"bad PT_DYNAMIC\");\n            }\n            dynseg = (Elf64_Dyn const *)ibuf.subref(\"bad DYNAMIC\", dyn_offset, dyn_filesz);\n            dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n            sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n                upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n                if (orig_file_size < sz_dynsym\n                ||  orig_file_size < off_dynsym\n                || (orig_file_size - off_dynsym) < sz_dynsym) {\n                    throwCantUnpack(\"bad SHT_DYNSYM\");\n                }\n                Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(\n                    \"bad dynsym\", off_dynsym, sz_dynsym);\n                Elf64_Sym *sym = sym0;\n                for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {\n                    upx_uint64_t symval = get_te64(&sym->st_value);\n                    unsigned symsec = get_te16(&sym->st_shndx);\n                    if (Elf64_Sym::SHN_UNDEF != symsec\n                    &&  Elf64_Sym::SHN_ABS   != symsec\n                    &&  xct_off <= symval) {\n                        set_te64(&sym->st_value, symval - asl_delta);\n                    }\n                    if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {\n                        adjABS(sym, 0u - asl_delta);\n                    }\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te64(&phdr->p_offset);\n                old_data_len = get_te64(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n        // Position the input for next unpackExtent.\n        fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD64==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te64(&phdr->p_filesz);\n                unsigned const offset = get_te64(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD64==get_te32(&phdr->p_type)) {\n            load_va = get_te64(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (0x1000==get_te64(&phdri[0].p_filesz)  // detect C_BASE style\n    &&  0==get_te64(&phdri[1].p_offset)\n    &&  0==get_te64(&phdri[0].p_offset)\n    &&     get_te64(&phdri[1].p_filesz) == get_te64(&phdri[1].p_memsz)) {\n        fi->seek(up4(get_te64(&phdr[1].p_memsz)), SEEK_SET);  // past the loader\n    }\n    else if (is_shlib\n    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);\n            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n    upx_uint64_t hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD64==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te64(&phdr[j].p_offset) +\n                                   get_te64(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        upx_uint64_t load_off = 0;\n        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te64(&phdr->p_offset);\n                load_va = get_te64(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf64_Phdr const *udynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)\n                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {\n                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);\n                    upx_uint64_t dt_relasz(0), dt_rela(0);\n                    upx_uint64_t const dyn_len = get_te64(&udynhdr->p_filesz);\n                    upx_uint64_t const dyn_off = get_te64(&udynhdr->p_offset);\n                    if ((unsigned long)file_size < (dyn_len + dyn_off)) {\n                        char msg[50]; snprintf(msg, sizeof(msg),\n                                \"bad PT_DYNAMIC .p_filesz %#lx\", (long unsigned)dyn_len);\n                        throwCantUnpack(msg);\n                    }\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]\n                    }\n                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg, get_te64(&udynhdr->p_filesz));\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        upx_uint64_t const tag = get_te64(&dyn->d_tag);\n                        upx_uint64_t       val = get_te64(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;\n                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;\n                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf64_Dyn::DT_PLTGOT:\n                        case Elf64_Dyn::DT_PREINIT_ARRAY:\n                        case Elf64_Dyn::DT_INIT_ARRAY:\n                        case Elf64_Dyn::DT_FINI_ARRAY:\n                        case Elf64_Dyn::DT_FINI: {\n                            set_te64(&dyn->d_val, val - asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf64_Dyn::DT_INIT == tag) {\n                                set_te64(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf64_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else if (Elf64_Dyn::DT_INIT_ARRAY    == tag\n                            ||       Elf64_Dyn::DT_PREINIT_ARRAY == tag) {\n                                if (val < load_va || (long unsigned)file_size < (long unsigned)val) {\n                                    char msg[50]; snprintf(msg, sizeof(msg),\n                                            \"Bad Dynamic tag %#lx %#lx\",\n                                            (long unsigned)tag, (long unsigned)val);\n                                    throwCantUnpack(msg);\n                                }\n                                set_te64(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relasz && dt_rela) {\n                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(\n                                \"bad Rela offset\", dt_rela, dt_relasz);\n                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, old_dtinit, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(\n                                \"bad Jmprel offset\", dt_jmprel, dt_pltrelsz);\n                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, old_dtinit, fo);\n                        }\n                        // Modified relocation tables are re-written by unRela64\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -99,16 +99,21 @@\n                 xct_off = e_shoff;\n             }\n             // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n-            dynseg = (Elf64_Dyn const *)ibuf.subref(\n-                \"bad DYNAMIC\", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));\n+            upx_uint64_t dyn_offset = get_te64(&dynhdr->p_offset);\n+            upx_uint64_t dyn_filesz = get_te64(&dynhdr->p_filesz);\n+            if (orig_file_size < dyn_offset\n+            || (orig_file_size - dyn_offset) < dyn_filesz) {\n+                throwCantUnpack(\"bad PT_DYNAMIC\");\n+            }\n+            dynseg = (Elf64_Dyn const *)ibuf.subref(\"bad DYNAMIC\", dyn_offset, dyn_filesz);\n             dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n             sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n             if (sec_dynsym) {\n                 upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);\n                 upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);\n-                if ((upx_uint64_t)file_size < sz_dynsym\n-                ||  (upx_uint64_t)file_size < off_dynsym\n-                || ((upx_uint64_t)file_size - off_dynsym) < sz_dynsym) {\n+                if (orig_file_size < sz_dynsym\n+                ||  orig_file_size < off_dynsym\n+                || (orig_file_size - off_dynsym) < sz_dynsym) {\n                     throwCantUnpack(\"bad SHT_DYNSYM\");\n                 }\n                 Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(",
        "diff_line_info": {
            "deleted_lines": [
                "            dynseg = (Elf64_Dyn const *)ibuf.subref(",
                "                \"bad DYNAMIC\", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));",
                "                if ((upx_uint64_t)file_size < sz_dynsym",
                "                ||  (upx_uint64_t)file_size < off_dynsym",
                "                || ((upx_uint64_t)file_size - off_dynsym) < sz_dynsym) {"
            ],
            "added_lines": [
                "            upx_uint64_t dyn_offset = get_te64(&dynhdr->p_offset);",
                "            upx_uint64_t dyn_filesz = get_te64(&dynhdr->p_filesz);",
                "            if (orig_file_size < dyn_offset",
                "            || (orig_file_size - dyn_offset) < dyn_filesz) {",
                "                throwCantUnpack(\"bad PT_DYNAMIC\");",
                "            }",
                "            dynseg = (Elf64_Dyn const *)ibuf.subref(\"bad DYNAMIC\", dyn_offset, dyn_filesz);",
                "                if (orig_file_size < sz_dynsym",
                "                ||  orig_file_size < off_dynsym",
                "                || (orig_file_size - off_dynsym) < sz_dynsym) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27798",
        "func_name": "upx/PackLinuxElf32::adjABS",
        "description": "An invalid memory address reference was discovered in the adjABS function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.",
        "git_url": "https://github.com/upx/upx/commit/77c914bce58aab9459029bed699f2bfb7ff2f90f",
        "commit_title": "Check de-compressed SHT_SYMTAB",
        "commit_text": " https://github.com/upx/upx/issues/396 \tmodified:   p_lx_elf.cpp",
        "func_before": "int\nPackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)\n{\n    for (int j = 0; abs_symbol_names[j][0]; ++j) {\n        unsigned st_name = get_te32(&sym->st_name);\n        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n            sym->st_value += delta;\n            return 1;\n        }\n    }\n    return 0;\n}",
        "func": "int\nPackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)\n{\n    unsigned st_name = get_te32(&sym->st_name);\n    for (int j = 0; abs_symbol_names[j][0]; ++j) {\n        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n            sym->st_value += delta;\n            return 1;\n        }\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n int\n PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)\n {\n+    unsigned st_name = get_te32(&sym->st_name);\n     for (int j = 0; abs_symbol_names[j][0]; ++j) {\n-        unsigned st_name = get_te32(&sym->st_name);\n         if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n             sym->st_value += delta;\n             return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "        unsigned st_name = get_te32(&sym->st_name);"
            ],
            "added_lines": [
                "    unsigned st_name = get_te32(&sym->st_name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27798",
        "func_name": "upx/PackLinuxElf32::unpack",
        "description": "An invalid memory address reference was discovered in the adjABS function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.",
        "git_url": "https://github.com/upx/upx/commit/77c914bce58aab9459029bed699f2bfb7ff2f90f",
        "commit_title": "Check de-compressed SHT_SYMTAB",
        "commit_text": " https://github.com/upx/upx/issues/396 \tmodified:   p_lx_elf.cpp",
        "func_before": "void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\"l_info corrupted\");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len) {\n        throwCompressedDataViolation();\n    }\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 512\n    if ((umin(MAX_ELF_HDR, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n        throwCantUnpack(\"bad compressed e_phnum\");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    Elf32_Phdr const *const dynhdr = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    bool const is_shlib = !!dynhdr;\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz));\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te32(&ehdri.e_shoff);\n        ibuf.subref(\"bad .e_shoff %#x for %#x\", e_shoff, sizeof(Elf32_Shdr) * e_shnum);\n        if (e_shoff && e_shnum) { // --android-shlib\n            shdri = (Elf32_Shdr /*const*/ *)ibuf.subref(\n                \"bad Shdr table\", e_shoff, sizeof(Elf32_Shdr)*e_shnum);\n            unsigned xct_off2 = get_te32(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            dynseg = (Elf32_Dyn const *)ibuf.subref(\n                \"bad DYNAMIC\", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));\n            dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n            sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n                unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n                Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                    \"bad dynsym\", off_dynsym, sz_dynsym);\n                Elf32_Sym *sym = sym0;\n                for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n                    unsigned symval = get_te32(&sym->st_value);\n                    unsigned symsec = get_te16(&sym->st_shndx);\n                    if (Elf32_Sym::SHN_UNDEF != symsec\n                    &&  Elf32_Sym::SHN_ABS   != symsec\n                    &&  xct_off <= symval) {\n                        set_te32(&sym->st_value, symval - asl_delta);\n                    }\n                    if (Elf32_Sym::SHN_ABS == symsec && xct_off <= symval) {\n                        adjABS(sym, 0u - asl_delta);\n                    }\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n        // Position the input for next unpackExtent.\n        fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (0x1000==get_te32(&phdri[0].p_filesz)  // detect C_BASE style\n    &&  0==get_te32(&phdri[1].p_offset)\n    &&  0==get_te32(&phdri[0].p_offset)\n    &&     get_te32(&phdri[1].p_filesz) == get_te32(&phdri[1].p_memsz)) {\n        fi->seek(up4(get_te32(&phdr[1].p_memsz)), SEEK_SET);  // past the loader\n    }\n    else if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);\n            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                load_va  = get_te32(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf32_Phdr const *udynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)\n                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {\n                    unsigned dt_pltrelsz(0), dt_jmprel(0);\n                    unsigned dt_relsz(0), dt_rel(0);\n                    unsigned const dyn_len = get_te32(&udynhdr->p_filesz);\n                    unsigned const dyn_off = get_te32(&udynhdr->p_offset);\n                    if ((unsigned long)file_size < (dyn_len + dyn_off)) {\n                        char msg[50]; snprintf(msg, sizeof(msg),\n                                \"bad PT_DYNAMIC .p_filesz %#x\", dyn_len);\n                        throwCantUnpack(msg);\n                    }\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]\n                    }\n                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg, get_te32(&udynhdr->p_filesz));\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        unsigned const tag = get_te32(&dyn->d_tag);\n                        unsigned       val = get_te32(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;\n                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;\n                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf32_Dyn::DT_PLTGOT:\n                        case Elf32_Dyn::DT_PREINIT_ARRAY:\n                        case Elf32_Dyn::DT_INIT_ARRAY:\n                        case Elf32_Dyn::DT_FINI_ARRAY:\n                        case Elf32_Dyn::DT_FINI: {\n                            set_te32(&dyn->d_val, val -= asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf32_Dyn::DT_INIT == tag) {\n                                set_te32(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else if (Elf32_Dyn::DT_INIT_ARRAY    == tag\n                            ||       Elf32_Dyn::DT_PREINIT_ARRAY == tag) {\n                                if (val < load_va || (unsigned)file_size < (unsigned)val) {\n                                    char msg[50]; snprintf(msg, sizeof(msg),\n                                            \"Bad Dynamic tag %#x %#x\",\n                                            (unsigned)tag, (unsigned)val);\n                                    throwCantUnpack(msg);\n                                }\n                                set_te32(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relsz && dt_rel) {\n                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                                \"bad Rel offset\", dt_rel, dt_relsz);\n                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                                \"bad Jmprel offset\", dt_jmprel, dt_pltrelsz);\n                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRel32\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}",
        "func": "void PackLinuxElf32::unpack(OutputFile *fo)\n{\n    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantUnpack(\"bad e_phoff\");\n    }\n    unsigned const c_phnum = get_te16(&ehdri.e_phnum);\n    unsigned old_data_off = 0;\n    unsigned old_data_len = 0;\n    unsigned old_dtinit = 0;\n    unsigned is_asl = 0;  // is Android Shared Library\n\n    unsigned szb_info = sizeof(b_info);\n    {\n        if (get_te32(&ehdri.e_entry) < 0x401180\n        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)\n        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {\n            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.\n            /* old style, 8-byte b_info */\n            szb_info = 2*sizeof(unsigned);\n        }\n    }\n\n    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);\n    fi->readx(&linfo, sizeof(linfo));\n    lsize = get_te16(&linfo.l_lsize);\n    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {\n        throwCantUnpack(\"l_info corrupted\");\n    }\n    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));\n    unsigned orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);\n    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size\n        || !mem_size_valid(1, blocksize, OVERHEAD))\n        throwCantUnpack(\"p_info corrupted\");\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, szb_info);\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0\n    ||  ph.u_len > orig_file_size)\n        throwCantUnpack(\"b_info corrupted\");\n    ph.filter_cto = bhdr.b_cto8;\n\n    MemBuffer u(ph.u_len);\n    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];\n    Elf32_Phdr const *phdr = 0;\n\n    // Uncompress Ehdr and Phdrs.\n    if (ibuf.getSize() < ph.c_len) {\n        throwCompressedDataViolation();\n    }\n    fi->readx(ibuf, ph.c_len);\n    decompress(ibuf, (upx_byte *)ehdr, false);\n    if (ehdr->e_type   !=ehdri.e_type\n    ||  ehdr->e_machine!=ehdri.e_machine\n    ||  ehdr->e_version!=ehdri.e_version\n    ||  ehdr->e_flags  !=ehdri.e_flags\n    ||  ehdr->e_ehsize !=ehdri.e_ehsize\n        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION\n    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {\n        throwCantUnpack(\"ElfXX_Ehdr corrupted\");\n    }\n    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);\n\n    unsigned const u_phnum = get_te16(&ehdr->e_phnum);\n    unsigned total_in = 0;\n    unsigned total_out = 0;\n    unsigned c_adler = upx_adler32(NULL, 0);\n    unsigned u_adler = upx_adler32(NULL, 0);\n#define MAX_ELF_HDR 512\n    if ((umin(MAX_ELF_HDR, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {\n        throwCantUnpack(\"bad compressed e_phnum\");\n    }\n#undef MAX_ELF_HDR\n\n    // Packed ET_EXE has no PT_DYNAMIC.\n    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.\n    Elf32_Phdr const *const dynhdr = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);\n    bool const is_shlib = !!dynhdr;\n    if (is_shlib) {\n        // Unpack and output the Ehdr and Phdrs for real.\n        // This depends on position within input file fi.\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n\n        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)\n        fi->seek(0, SEEK_SET);\n        fi->readx(ibuf, get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz));\n        overlay_offset -= sizeof(linfo);\n        xct_off = overlay_offset;\n        e_shoff = get_te32(&ehdri.e_shoff);\n        ibuf.subref(\"bad .e_shoff %#x for %#x\", e_shoff, sizeof(Elf32_Shdr) * e_shnum);\n        if (e_shoff && e_shnum) { // --android-shlib\n            shdri = (Elf32_Shdr /*const*/ *)ibuf.subref(\n                \"bad Shdr table\", e_shoff, sizeof(Elf32_Shdr)*e_shnum);\n            unsigned xct_off2 = get_te32(&shdri->sh_offset);\n            if (e_shoff == xct_off2) {\n                xct_off = e_shoff;\n            }\n            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n            unsigned dyn_offset = get_te32(&dynhdr->p_offset);\n            unsigned dyn_filesz = get_te32(&dynhdr->p_filesz);\n            if (orig_file_size < dyn_offset\n            || (orig_file_size - dyn_offset) < dyn_filesz) {\n                throwCantUnpack(\"bad PT_DYNAMIC\");\n            }\n            dynseg = (Elf32_Dyn const *)ibuf.subref(\"bad DYNAMIC\", dyn_offset, dyn_filesz);\n            dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n            sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n            if (sec_dynsym) {\n                unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n                unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n                if (orig_file_size < sz_dynsym\n                ||  orig_file_size < off_dynsym\n                || (orig_file_size - off_dynsym) < sz_dynsym) {\n                    throwCantUnpack(\"bad SHT_DYNSYM\");\n                }\n                Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                    \"bad dynsym\", off_dynsym, sz_dynsym);\n                Elf32_Sym *sym = sym0;\n                for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {\n                    unsigned symval = get_te32(&sym->st_value);\n                    unsigned symsec = get_te16(&sym->st_shndx);\n                    if (Elf32_Sym::SHN_UNDEF != symsec\n                    &&  Elf32_Sym::SHN_ABS   != symsec\n                    &&  xct_off <= symval) {\n                        set_te32(&sym->st_value, symval - asl_delta);\n                    }\n                    if (Elf32_Sym::SHN_ABS == symsec && xct_off <= symval) {\n                        adjABS(sym, 0u - asl_delta);\n                    }\n                }\n            }\n        }\n        if (fo) {\n            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);\n        }\n        // Search the Phdrs of compressed\n        int n_ptload = 0;\n        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                old_data_off = get_te32(&phdr->p_offset);\n                old_data_len = get_te32(&phdr->p_filesz);\n                break;\n            }\n        }\n\n        total_in  = xct_off;\n        total_out = xct_off;\n        ph.u_len = 0;\n        // Position the input for next unpackExtent.\n        fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);\n\n        // Decompress and unfilter the tail of first PT_LOAD.\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;\n                break;\n            }\n        }\n        unpackExtent(ph.u_len, fo, total_in, total_out,\n            c_adler, u_adler, false, szb_info);\n    }\n    else {  // main executable\n        // Decompress each PT_LOAD.\n        bool first_PF_X = true;\n        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed\n        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {\n            if (PT_LOAD32==get_te32(&phdr->p_type)) {\n                unsigned const filesz = get_te32(&phdr->p_filesz);\n                unsigned const offset = get_te32(&phdr->p_offset);\n                if (fo)\n                    fo->seek(offset, SEEK_SET);\n                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, first_PF_X, szb_info);\n                    first_PF_X = false;\n                }\n                else {\n                    unpackExtent(filesz, fo, total_in, total_out,\n                        c_adler, u_adler, false, szb_info);\n                }\n            }\n        }\n    }\n    phdr = phdri;\n    load_va = 0;\n    for (unsigned j=0; j < c_phnum; ++j) {\n        if (PT_LOAD32==get_te32(&phdr->p_type)) {\n            load_va = get_te32(&phdr->p_vaddr);\n            break;\n        }\n    }\n    if (0x1000==get_te32(&phdri[0].p_filesz)  // detect C_BASE style\n    &&  0==get_te32(&phdri[1].p_offset)\n    &&  0==get_te32(&phdri[0].p_offset)\n    &&     get_te32(&phdri[1].p_filesz) == get_te32(&phdri[1].p_memsz)) {\n        fi->seek(up4(get_te32(&phdr[1].p_memsz)), SEEK_SET);  // past the loader\n    }\n    else if (is_shlib\n    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +\n                ph.getPackHeaderSize() + sizeof(overlay_offset))\n            < up4(file_size)) {\n        // Loader is not at end; skip past it.\n        funpad4(fi);  // MATCH01\n        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));\n        if (0==old_dtinit) {\n            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);\n            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);\n        }\n        fi->seek(lsize - sizeof(d_info), SEEK_CUR);\n    }\n\n    // The gaps between PT_LOAD and after last PT_LOAD\n    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n    unsigned hi_offset(0);\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        if (PT_LOAD32==phdr[j].p_type\n        &&  hi_offset < phdr[j].p_offset)\n            hi_offset = phdr[j].p_offset;\n    }\n    for (unsigned j = 0; j < u_phnum; ++j) {\n        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);\n        if (size) {\n            unsigned const where = get_te32(&phdr[j].p_offset) +\n                                   get_te32(&phdr[j].p_filesz);\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo, total_in, total_out,\n                c_adler, u_adler, false, szb_info,\n                (phdr[j].p_offset != hi_offset));\n        }\n    }\n\n    // check for end-of-file\n    fi->readx(&bhdr, szb_info);\n    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);\n\n    if (sz_unc == 0) { // uncompressed size 0 -> EOF\n        // note: magic is always stored le32\n        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);\n        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic\n            throwCompressedDataViolation();\n    }\n    else { // extra bytes after end?\n        throwCompressedDataViolation();\n    }\n\n    if (is_shlib) {\n        // DT_INIT must be restored.\n        // If android_shlib, then the asl_delta relocations must be un-done.\n        int n_ptload = 0;\n        unsigned load_off = 0;\n        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {\n            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {\n                load_off = get_te32(&phdr->p_offset);\n                load_va  = get_te32(&phdr->p_vaddr);\n                fi->seek(old_data_off, SEEK_SET);\n                fi->readx(ibuf, old_data_len);\n                total_in  += old_data_len;\n                total_out += old_data_len;\n\n                Elf32_Phdr const *udynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];\n                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)\n                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {\n                    unsigned dt_pltrelsz(0), dt_jmprel(0);\n                    unsigned dt_relsz(0), dt_rel(0);\n                    unsigned const dyn_len = get_te32(&udynhdr->p_filesz);\n                    unsigned const dyn_off = get_te32(&udynhdr->p_offset);\n                    if ((unsigned long)file_size < (dyn_len + dyn_off)) {\n                        char msg[50]; snprintf(msg, sizeof(msg),\n                                \"bad PT_DYNAMIC .p_filesz %#x\", dyn_len);\n                        throwCantUnpack(msg);\n                    }\n                    if (dyn_off < load_off) {\n                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]\n                    }\n                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +\n                        (dyn_off - load_off));\n                    dynseg = dyn; invert_pt_dynamic(dynseg, get_te32(&udynhdr->p_filesz));\n                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {\n                        unsigned const tag = get_te32(&dyn->d_tag);\n                        unsigned       val = get_te32(&dyn->d_val);\n                        if (is_asl) switch (tag) {\n                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;\n                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;\n                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;\n                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;\n\n                        case Elf32_Dyn::DT_PLTGOT:\n                        case Elf32_Dyn::DT_PREINIT_ARRAY:\n                        case Elf32_Dyn::DT_INIT_ARRAY:\n                        case Elf32_Dyn::DT_FINI_ARRAY:\n                        case Elf32_Dyn::DT_FINI: {\n                            set_te32(&dyn->d_val, val -= asl_delta);\n                        }; break;\n                        } // end switch()\n                        if (upx_dt_init == tag) {\n                            if (Elf32_Dyn::DT_INIT == tag) {\n                                set_te32(&dyn->d_val, old_dtinit);\n                                if (!old_dtinit) { // compressor took the slot\n                                    dyn->d_tag = Elf32_Dyn::DT_NULL;\n                                    dyn->d_val = 0;\n                                }\n                            }\n                            else if (Elf32_Dyn::DT_INIT_ARRAY    == tag\n                            ||       Elf32_Dyn::DT_PREINIT_ARRAY == tag) {\n                                if (val < load_va || (unsigned)file_size < (unsigned)val) {\n                                    char msg[50]; snprintf(msg, sizeof(msg),\n                                            \"Bad Dynamic tag %#x %#x\",\n                                            (unsigned)tag, (unsigned)val);\n                                    throwCantUnpack(msg);\n                                }\n                                set_te32(&ibuf[val - load_va], old_dtinit\n                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32\n                            }\n                        }\n                        // Modified DT_*.d_val are re-written later from ibuf[]\n                    }\n                    if (is_asl) {\n                        lowmem.alloc(xct_off);\n                        fi->seek(0, SEEK_SET);\n                        fi->read(lowmem, xct_off);  // contains relocation tables\n                        if (dt_relsz && dt_rel) {\n                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(\n                                \"bad Rel offset\", dt_rel, dt_relsz);\n                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);\n                        }\n                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?\n                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(\n                                \"bad Jmprel offset\", dt_jmprel, dt_pltrelsz);\n                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);\n                        }\n                        // Modified relocation tables are re-written by unRel32\n                    }\n                }\n                if (fo) {\n                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);\n                    fo->rewrite(ibuf, old_data_len);\n                }\n            }\n        }\n    }\n\n    // update header with totals\n    ph.c_len = total_in;\n    ph.u_len = total_out;\n\n    // all bytes must be written\n    if (total_out != orig_file_size)\n        throwEOFException();\n\n    // finally test the checksums\n    if (ph.c_adler != c_adler || ph.u_adler != u_adler)\n        throwChecksumError();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -100,13 +100,23 @@\n                 xct_off = e_shoff;\n             }\n             // un-Relocate dynsym (DT_SYMTAB) which is below xct_off\n-            dynseg = (Elf32_Dyn const *)ibuf.subref(\n-                \"bad DYNAMIC\", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));\n+            unsigned dyn_offset = get_te32(&dynhdr->p_offset);\n+            unsigned dyn_filesz = get_te32(&dynhdr->p_filesz);\n+            if (orig_file_size < dyn_offset\n+            || (orig_file_size - dyn_offset) < dyn_filesz) {\n+                throwCantUnpack(\"bad PT_DYNAMIC\");\n+            }\n+            dynseg = (Elf32_Dyn const *)ibuf.subref(\"bad DYNAMIC\", dyn_offset, dyn_filesz);\n             dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n             sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n             if (sec_dynsym) {\n                 unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);\n                 unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);\n+                if (orig_file_size < sz_dynsym\n+                ||  orig_file_size < off_dynsym\n+                || (orig_file_size - off_dynsym) < sz_dynsym) {\n+                    throwCantUnpack(\"bad SHT_DYNSYM\");\n+                }\n                 Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(\n                     \"bad dynsym\", off_dynsym, sz_dynsym);\n                 Elf32_Sym *sym = sym0;",
        "diff_line_info": {
            "deleted_lines": [
                "            dynseg = (Elf32_Dyn const *)ibuf.subref(",
                "                \"bad DYNAMIC\", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));"
            ],
            "added_lines": [
                "            unsigned dyn_offset = get_te32(&dynhdr->p_offset);",
                "            unsigned dyn_filesz = get_te32(&dynhdr->p_filesz);",
                "            if (orig_file_size < dyn_offset",
                "            || (orig_file_size - dyn_offset) < dyn_filesz) {",
                "                throwCantUnpack(\"bad PT_DYNAMIC\");",
                "            }",
                "            dynseg = (Elf32_Dyn const *)ibuf.subref(\"bad DYNAMIC\", dyn_offset, dyn_filesz);",
                "                if (orig_file_size < sz_dynsym",
                "                ||  orig_file_size < off_dynsym",
                "                || (orig_file_size - off_dynsym) < sz_dynsym) {",
                "                    throwCantUnpack(\"bad SHT_DYNSYM\");",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2953",
        "func_name": "libtiff/process_command_opts",
        "description": "LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 48d6ece8.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/8fe3735942ea1d90d8cef843b55b3efe8ab6feaf",
        "commit_title": "According to Richard Nolde https://gitlab.com/libtiff/libtiff/-/issues/401#note_877637400 the tiffcrop option -S is also mutually exclusive to the other crop options (-X|-Y), -Z and -z.",
        "commit_text": " This is now checked and ends tiffcrop if those arguments are not mutually exclusive.  This MR will fix the following tiffcrop issues: #349, #414, #422, #423, #424 ",
        "func_before": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,\n                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,\n                            uint32_t *deftilelength, uint32_t *defrowsperstrip,\n                            struct crop_mask *crop_data, struct pagedef *page,\n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'h':\tusage(EXIT_SUCCESS);\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'k':\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': printf(\"Library Release: %s\\n\", TIFFGetVersion());\n                printf(\"Tiffcrop version: %s, last updated: %s\\n\",\n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n\t        printf(\"Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\\n\");\n\t\tprintf(\"           : Copyright (c) 1991-1997 Silicon Graphics, Inc\\n\");\n                printf(\"Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\\n\");\n\t        exit (EXIT_SUCCESS);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%u %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (EXIT_FAILURE);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (EXIT_FAILURE);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned output pages */\n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned output pages*/\n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (EXIT_FAILURE);\n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (EXIT_FAILURE);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16_t)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16_t)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16_t)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(EXIT_FAILURE);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\t/*NOTREACHED*/\n      }\n    }\n    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z and -z are mutually exclusive) --*/\n    char XY, Z, R;\n    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n    Z = (crop_data->crop_mode & CROP_ZONES);\n    R = (crop_data->crop_mode & CROP_REGIONS);\n    if ((XY && Z) || (XY && R) || (Z && R)) {\n        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit\");\n        exit(EXIT_FAILURE);\n    }\n  }",
        "func": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,\n                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,\n                            uint32_t *deftilelength, uint32_t *defrowsperstrip,\n                            struct crop_mask *crop_data, struct pagedef *page,\n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'h':\tusage(EXIT_SUCCESS);\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'k':\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': printf(\"Library Release: %s\\n\", TIFFGetVersion());\n                printf(\"Tiffcrop version: %s, last updated: %s\\n\",\n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n\t        printf(\"Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\\n\");\n\t\tprintf(\"           : Copyright (c) 1991-1997 Silicon Graphics, Inc\\n\");\n                printf(\"Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\\n\");\n\t        exit (EXIT_SUCCESS);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%u %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (EXIT_FAILURE);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (EXIT_FAILURE);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned output pages */\n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned output pages*/\n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (EXIT_FAILURE);\n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (EXIT_FAILURE);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16_t)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16_t)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16_t)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(EXIT_FAILURE);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\t/*NOTREACHED*/\n      }\n    }\n    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n    char XY, Z, R, S;\n    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n    Z = (crop_data->crop_mode & CROP_ZONES);\n    R = (crop_data->crop_mode & CROP_REGIONS);\n    S = (page->mode & PAGE_MODE_ROWSCOLS);\n    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {\n        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n        exit(EXIT_FAILURE);\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -506,13 +506,14 @@\n \t\t/*NOTREACHED*/\n       }\n     }\n-    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z and -z are mutually exclusive) --*/\n-    char XY, Z, R;\n+    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n+    char XY, Z, R, S;\n     XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n     Z = (crop_data->crop_mode & CROP_ZONES);\n     R = (crop_data->crop_mode & CROP_REGIONS);\n-    if ((XY && Z) || (XY && R) || (Z && R)) {\n-        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit\");\n+    S = (page->mode & PAGE_MODE_ROWSCOLS);\n+    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {\n+        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n         exit(EXIT_FAILURE);\n     }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z and -z are mutually exclusive) --*/",
                "    char XY, Z, R;",
                "    if ((XY && Z) || (XY && R) || (Z && R)) {",
                "        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit\");"
            ],
            "added_lines": [
                "    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/",
                "    char XY, Z, R, S;",
                "    S = (page->mode & PAGE_MODE_ROWSCOLS);",
                "    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {",
                "        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2953",
        "func_name": "libtiff/process_command_opts",
        "description": "LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 48d6ece8.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/bad48e90b410df32172006c7876da449ba62cdba",
        "commit_title": "tiffcrop -S option: Make decision simpler.",
        "commit_text": "",
        "func_before": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,\n                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,\n                            uint32_t *deftilelength, uint32_t *defrowsperstrip,\n                            struct crop_mask *crop_data, struct pagedef *page,\n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'h':\tusage(EXIT_SUCCESS);\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'k':\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': printf(\"Library Release: %s\\n\", TIFFGetVersion());\n                printf(\"Tiffcrop version: %s, last updated: %s\\n\",\n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n\t        printf(\"Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\\n\");\n\t\tprintf(\"           : Copyright (c) 1991-1997 Silicon Graphics, Inc\\n\");\n                printf(\"Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\\n\");\n\t        exit (EXIT_SUCCESS);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%u %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (EXIT_FAILURE);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (EXIT_FAILURE);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned output pages */\n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned output pages*/\n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (EXIT_FAILURE);\n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (EXIT_FAILURE);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16_t)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16_t)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16_t)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(EXIT_FAILURE);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\t/*NOTREACHED*/\n      }\n    }\n    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n    char XY, Z, R, S;\n    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n    Z = (crop_data->crop_mode & CROP_ZONES);\n    R = (crop_data->crop_mode & CROP_REGIONS);\n    S = (page->mode & PAGE_MODE_ROWSCOLS);\n    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {\n        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n        exit(EXIT_FAILURE);\n    }\n  }",
        "func": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,\n                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,\n                            uint32_t *deftilelength, uint32_t *defrowsperstrip,\n                            struct crop_mask *crop_data, struct pagedef *page,\n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'h':\tusage(EXIT_SUCCESS);\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'k':\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': printf(\"Library Release: %s\\n\", TIFFGetVersion());\n                printf(\"Tiffcrop version: %s, last updated: %s\\n\",\n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n\t        printf(\"Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\\n\");\n\t\tprintf(\"           : Copyright (c) 1991-1997 Silicon Graphics, Inc\\n\");\n                printf(\"Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\\n\");\n\t        exit (EXIT_SUCCESS);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%u %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (EXIT_FAILURE);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (EXIT_FAILURE);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned output pages */\n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned output pages*/\n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (EXIT_FAILURE);\n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (EXIT_FAILURE);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16_t)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16_t)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16_t)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(EXIT_FAILURE);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\t/*NOTREACHED*/\n      }\n    }\n    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n    char XY, Z, R, S;\n    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;\n    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;\n    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;\n    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n    if (XY + Z + R + S > 1) {\n        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n        exit(EXIT_FAILURE);\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -508,11 +508,11 @@\n     }\n     /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n     char XY, Z, R, S;\n-    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n-    Z = (crop_data->crop_mode & CROP_ZONES);\n-    R = (crop_data->crop_mode & CROP_REGIONS);\n-    S = (page->mode & PAGE_MODE_ROWSCOLS);\n-    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {\n+    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;\n+    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;\n+    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;\n+    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n+    if (XY + Z + R + S > 1) {\n         TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n         exit(EXIT_FAILURE);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));",
                "    Z = (crop_data->crop_mode & CROP_ZONES);",
                "    R = (crop_data->crop_mode & CROP_REGIONS);",
                "    S = (page->mode & PAGE_MODE_ROWSCOLS);",
                "    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {"
            ],
            "added_lines": [
                "    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;",
                "    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;",
                "    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;",
                "    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;",
                "    if (XY + Z + R + S > 1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42309",
        "func_name": "xen-project/xen/create_node",
        "description": "Xenstore: Guests can crash xenstored Due to a bug in the fix of XSA-115 a malicious guest can cause xenstored to use a wrong pointer during node creation in an error path, resulting in a crash of xenstored or a memory corruption in xenstored causing further damage. Entering the error path can be controlled by the guest e.g. by exceeding the quota value of maximum nodes per domain.",
        "git_url": "https://github.com/xen-project/xen/commit/1cd3cc7ea27cda7640a8d895e09617b61c265697",
        "commit_title": "tools/xenstore: create_node: Don't defer work to undo any changes on failure",
        "commit_text": " XSA-115 extended destroy_node() to update the node accounting for the connection. The implementation is assuming the connection is the parent of the node, however all the nodes are allocated using a separate context (see process_message()). This will result to crash (or corrupt) xenstored as the pointer is wrongly used.  In case of an error, any changes to the database or update to the accounting will now be reverted in create_node() by calling directly destroy_node(). This has the nice advantage to remove the loop to unset the destructors in case of success.  Take the opportunity to free the nodes right now as they are not going to be reachable (the function returns NULL) and are just wasting resources.  This is XSA-414 / CVE-2022-42309. ",
        "func_before": "static struct node *create_node(struct connection *conn, const void *ctx,\n\t\t\t\tconst char *name,\n\t\t\t\tvoid *data, unsigned int datalen)\n{\n\tstruct node *node, *i;\n\n\tnode = construct_node(conn, ctx, name);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->data = data;\n\tnode->datalen = datalen;\n\n\t/*\n\t * We write out the nodes bottom up.\n\t * All new created nodes will have i->parent set, while the final\n\t * node will be already existing and won't have i->parent set.\n\t * New nodes are subject to quota handling.\n\t * Initially set a destructor for all new nodes removing them from\n\t * TDB again and undoing quota accounting for the case of an error\n\t * during the write loop.\n\t */\n\tfor (i = node; i; i = i->parent) {\n\t\t/* i->parent is set for each new node, so check quota. */\n\t\tif (i->parent &&\n\t\t    domain_entry(conn) >= quota_nb_entry_per_domain) {\n\t\t\terrno = ENOSPC;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (write_node(conn, i, false))\n\t\t\treturn NULL;\n\n\t\t/* Account for new node, set destructor for error case. */\n\t\tif (i->parent) {\n\t\t\tdomain_entry_inc(conn, i);\n\t\t\ttalloc_set_destructor(i, destroy_node);\n\t\t}\n\t}\n\n\t/* OK, now remove destructors so they stay around */\n\tfor (i = node; i->parent; i = i->parent)\n\t\ttalloc_set_destructor(i, NULL);\n\treturn node;\n}",
        "func": "static struct node *create_node(struct connection *conn, const void *ctx,\n\t\t\t\tconst char *name,\n\t\t\t\tvoid *data, unsigned int datalen)\n{\n\tstruct node *node, *i, *j;\n\tint ret;\n\n\tnode = construct_node(conn, ctx, name);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->data = data;\n\tnode->datalen = datalen;\n\n\t/*\n\t * We write out the nodes bottom up.\n\t * All new created nodes will have i->parent set, while the final\n\t * node will be already existing and won't have i->parent set.\n\t * New nodes are subject to quota handling.\n\t * Initially set a destructor for all new nodes removing them from\n\t * TDB again and undoing quota accounting for the case of an error\n\t * during the write loop.\n\t */\n\tfor (i = node; i; i = i->parent) {\n\t\t/* i->parent is set for each new node, so check quota. */\n\t\tif (i->parent &&\n\t\t    domain_entry(conn) >= quota_nb_entry_per_domain) {\n\t\t\tret = ENOSPC;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = write_node(conn, i, false);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* Account for new node */\n\t\tif (i->parent)\n\t\t\tdomain_entry_inc(conn, i);\n\t}\n\n\treturn node;\n\nerr:\n\t/*\n\t * We failed to update TDB for some of the nodes. Undo any work that\n\t * have already been done.\n\t */\n\tfor (j = node; j != i; j = j->parent)\n\t\tdestroy_node(conn, j);\n\n\t/* We don't need to keep the nodes around, so free them. */\n\ti = node;\n\twhile (i) {\n\t\tj = i;\n\t\ti = i->parent;\n\t\ttalloc_free(j);\n\t}\n\n\terrno = ret;\n\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,8 @@\n \t\t\t\tconst char *name,\n \t\t\t\tvoid *data, unsigned int datalen)\n {\n-\tstruct node *node, *i;\n+\tstruct node *node, *i, *j;\n+\tint ret;\n \n \tnode = construct_node(conn, ctx, name);\n \tif (!node)\n@@ -24,21 +25,38 @@\n \t\t/* i->parent is set for each new node, so check quota. */\n \t\tif (i->parent &&\n \t\t    domain_entry(conn) >= quota_nb_entry_per_domain) {\n-\t\t\terrno = ENOSPC;\n-\t\t\treturn NULL;\n+\t\t\tret = ENOSPC;\n+\t\t\tgoto err;\n \t\t}\n-\t\tif (write_node(conn, i, false))\n-\t\t\treturn NULL;\n \n-\t\t/* Account for new node, set destructor for error case. */\n-\t\tif (i->parent) {\n+\t\tret = write_node(conn, i, false);\n+\t\tif (ret)\n+\t\t\tgoto err;\n+\n+\t\t/* Account for new node */\n+\t\tif (i->parent)\n \t\t\tdomain_entry_inc(conn, i);\n-\t\t\ttalloc_set_destructor(i, destroy_node);\n-\t\t}\n \t}\n \n-\t/* OK, now remove destructors so they stay around */\n-\tfor (i = node; i->parent; i = i->parent)\n-\t\ttalloc_set_destructor(i, NULL);\n \treturn node;\n+\n+err:\n+\t/*\n+\t * We failed to update TDB for some of the nodes. Undo any work that\n+\t * have already been done.\n+\t */\n+\tfor (j = node; j != i; j = j->parent)\n+\t\tdestroy_node(conn, j);\n+\n+\t/* We don't need to keep the nodes around, so free them. */\n+\ti = node;\n+\twhile (i) {\n+\t\tj = i;\n+\t\ti = i->parent;\n+\t\ttalloc_free(j);\n+\t}\n+\n+\terrno = ret;\n+\n+\treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct node *node, *i;",
                "\t\t\terrno = ENOSPC;",
                "\t\t\treturn NULL;",
                "\t\tif (write_node(conn, i, false))",
                "\t\t\treturn NULL;",
                "\t\t/* Account for new node, set destructor for error case. */",
                "\t\tif (i->parent) {",
                "\t\t\ttalloc_set_destructor(i, destroy_node);",
                "\t\t}",
                "\t/* OK, now remove destructors so they stay around */",
                "\tfor (i = node; i->parent; i = i->parent)",
                "\t\ttalloc_set_destructor(i, NULL);"
            ],
            "added_lines": [
                "\tstruct node *node, *i, *j;",
                "\tint ret;",
                "\t\t\tret = ENOSPC;",
                "\t\t\tgoto err;",
                "\t\tret = write_node(conn, i, false);",
                "\t\tif (ret)",
                "\t\t\tgoto err;",
                "",
                "\t\t/* Account for new node */",
                "\t\tif (i->parent)",
                "",
                "err:",
                "\t/*",
                "\t * We failed to update TDB for some of the nodes. Undo any work that",
                "\t * have already been done.",
                "\t */",
                "\tfor (j = node; j != i; j = j->parent)",
                "\t\tdestroy_node(conn, j);",
                "",
                "\t/* We don't need to keep the nodes around, so free them. */",
                "\ti = node;",
                "\twhile (i) {",
                "\t\tj = i;",
                "\t\ti = i->parent;",
                "\t\ttalloc_free(j);",
                "\t}",
                "",
                "\terrno = ret;",
                "",
                "\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42309",
        "func_name": "xen-project/xen/destroy_node",
        "description": "Xenstore: Guests can crash xenstored Due to a bug in the fix of XSA-115 a malicious guest can cause xenstored to use a wrong pointer during node creation in an error path, resulting in a crash of xenstored or a memory corruption in xenstored causing further damage. Entering the error path can be controlled by the guest e.g. by exceeding the quota value of maximum nodes per domain.",
        "git_url": "https://github.com/xen-project/xen/commit/1cd3cc7ea27cda7640a8d895e09617b61c265697",
        "commit_title": "tools/xenstore: create_node: Don't defer work to undo any changes on failure",
        "commit_text": " XSA-115 extended destroy_node() to update the node accounting for the connection. The implementation is assuming the connection is the parent of the node, however all the nodes are allocated using a separate context (see process_message()). This will result to crash (or corrupt) xenstored as the pointer is wrongly used.  In case of an error, any changes to the database or update to the accounting will now be reverted in create_node() by calling directly destroy_node(). This has the nice advantage to remove the loop to unset the destructors in case of success.  Take the opportunity to free the nodes right now as they are not going to be reachable (the function returns NULL) and are just wasting resources.  This is XSA-414 / CVE-2022-42309. ",
        "func_before": "static int destroy_node(void *_node)\n{\n\tstruct node *node = _node;\n\tTDB_DATA key;\n\n\tif (streq(node->name, \"/\"))\n\t\tcorrupt(NULL, \"Destroying root node!\");\n\n\tset_tdb_key(node->name, &key);\n\ttdb_delete(tdb_ctx, key);\n\n\tdomain_entry_dec(talloc_parent(node), node);\n\n\treturn 0;\n}",
        "func": "static int destroy_node(struct connection *conn, struct node *node)\n{\n\tTDB_DATA key;\n\n\tif (streq(node->name, \"/\"))\n\t\tcorrupt(NULL, \"Destroying root node!\");\n\n\tset_tdb_key(node->name, &key);\n\ttdb_delete(tdb_ctx, key);\n\n\tdomain_entry_dec(conn, node);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n-static int destroy_node(void *_node)\n+static int destroy_node(struct connection *conn, struct node *node)\n {\n-\tstruct node *node = _node;\n \tTDB_DATA key;\n \n \tif (streq(node->name, \"/\"))\n@@ -9,7 +8,7 @@\n \tset_tdb_key(node->name, &key);\n \ttdb_delete(tdb_ctx, key);\n \n-\tdomain_entry_dec(talloc_parent(node), node);\n+\tdomain_entry_dec(conn, node);\n \n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int destroy_node(void *_node)",
                "\tstruct node *node = _node;",
                "\tdomain_entry_dec(talloc_parent(node), node);"
            ],
            "added_lines": [
                "static int destroy_node(struct connection *conn, struct node *node)",
                "\tdomain_entry_dec(conn, node);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24371",
        "func_name": "lua/youngcollection",
        "description": "lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage.",
        "git_url": "https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110",
        "commit_title": "Fixed bug: barriers cannot be active during sweep",
        "commit_text": " Barriers cannot be active during sweep, even in generational mode. (Although gen. mode is not incremental, it can hit a barrier when deleting a thread and closing its upvalues.)  The colors of objects are being changed during sweep and, therefore, cannot be trusted.",
        "func_before": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  /* to point to first non-dead survival object */\n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n\n  /* sweep nursery and get a pointer to its last live element */\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  /* 'survival' survivals are old now */\n  g->survival = g->allgc;  /* all news are survivals */\n\n  /* repeat for 'finobj' lists */\n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  /* 'survival' survivals are old now */\n  g->finobjsur = g->finobj;  /* all news are survivals */\n\n  sweepgen(L, g, &g->tobefnz, NULL);\n\n  finishgencycle(L, g);\n}",
        "func": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  /* to point to first non-dead survival object */\n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n\n  /* sweep nursery and get a pointer to its last live element */\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  /* 'survival' survivals are old now */\n  g->survival = g->allgc;  /* all news are survivals */\n\n  /* repeat for 'finobj' lists */\n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  /* sweep 'survival' and 'old' */\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  /* 'survival' survivals are old now */\n  g->finobjsur = g->finobj;  /* all news are survivals */\n\n  sweepgen(L, g, &g->tobefnz, NULL);\n\n  finishgencycle(L, g);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n   atomic(L);\n \n   /* sweep nursery and get a pointer to its last live element */\n+  g->gcstate = GCSswpallgc;\n   psurvival = sweepgen(L, g, &g->allgc, g->survival);\n   /* sweep 'survival' and 'old' */\n   sweepgen(L, g, psurvival, g->reallyold);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  g->gcstate = GCSswpallgc;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24371",
        "func_name": "lua/atomic2gen",
        "description": "lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage.",
        "git_url": "https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110",
        "commit_title": "Fixed bug: barriers cannot be active during sweep",
        "commit_text": " Barriers cannot be active during sweep, even in generational mode. (Although gen. mode is not incremental, it can hit a barrier when deleting a thread and closing its upvalues.)  The colors of objects are being changed during sweep and, therefore, cannot be trusted.",
        "func_before": "static void atomic2gen (lua_State *L, global_State *g) {\n  /* sweep all elements making them old */\n  sweep2old(L, &g->allgc);\n  /* everything alive now is old */\n  g->reallyold = g->old = g->survival = g->allgc;\n\n  /* repeat for 'finobj' lists */\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n\n  sweep2old(L, &g->tobefnz);\n\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  /* base for memory control */\n  finishgencycle(L, g);\n}",
        "func": "static void atomic2gen (lua_State *L, global_State *g) {\n  /* sweep all elements making them old */\n  g->gcstate = GCSswpallgc;\n  sweep2old(L, &g->allgc);\n  /* everything alive now is old */\n  g->reallyold = g->old = g->survival = g->allgc;\n\n  /* repeat for 'finobj' lists */\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n\n  sweep2old(L, &g->tobefnz);\n\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  /* base for memory control */\n  finishgencycle(L, g);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static void atomic2gen (lua_State *L, global_State *g) {\n   /* sweep all elements making them old */\n+  g->gcstate = GCSswpallgc;\n   sweep2old(L, &g->allgc);\n   /* everything alive now is old */\n   g->reallyold = g->old = g->survival = g->allgc;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  g->gcstate = GCSswpallgc;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24371",
        "func_name": "lua/remarkupvals",
        "description": "lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage.",
        "git_url": "https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110",
        "commit_title": "Fixed bug: barriers cannot be active during sweep",
        "commit_text": " Barriers cannot be active during sweep, even in generational mode. (Although gen. mode is not incremental, it can hit a barrier when deleting a thread and closing its upvalues.)  The colors of objects are being changed during sweep and, therefore, cannot be trusted.",
        "func_before": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  /* threads are never black */\n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        work++;\n        if (!iswhite(uv))  /* upvalue already visited? */\n          markvalue(g, uv->v);  /* mark its value */\n      }\n    }\n  }\n  return work;\n}",
        "func": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  /* threads are never black */\n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      lua_assert(!isold(thread) || thread->openupval == NULL);\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        lua_assert(getage(uv) <= getage(thread));\n        work++;\n        if (!iswhite(uv))  /* upvalue already visited? */\n          markvalue(g, uv->v);  /* mark its value */\n      }\n    }\n  }\n  return work;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,9 +9,11 @@\n       p = &thread->twups;  /* keep marked thread with upvalues in the list */\n     else {  /* thread is not marked or without upvalues */\n       UpVal *uv;\n+      lua_assert(!isold(thread) || thread->openupval == NULL);\n       *p = thread->twups;  /* remove thread from the list */\n       thread->twups = thread;  /* mark that it is out of list */\n       for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n+        lua_assert(getage(uv) <= getage(thread));\n         work++;\n         if (!iswhite(uv))  /* upvalue already visited? */\n           markvalue(g, uv->v);  /* mark its value */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      lua_assert(!isold(thread) || thread->openupval == NULL);",
                "        lua_assert(getage(uv) <= getage(thread));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24371",
        "func_name": "lua/correctgraylist",
        "description": "lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage.",
        "git_url": "https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110",
        "commit_title": "Fixed bug: barriers cannot be active during sweep",
        "commit_text": " Barriers cannot be active during sweep, even in generational mode. (Although gen. mode is not incremental, it can hit a barrier when deleting a thread and closing its upvalues.)  The colors of objects are being changed during sweep and, therefore, cannot be trusted.",
        "func_before": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  /* touched in this cycle? */\n          lua_assert(isgray(curr));\n          gray2black(curr);  /* make it black, for next barrier */\n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  /* go to next element */\n        }\n        else {  /* not touched in this cycle */\n          if (!iswhite(curr)) {  /* not white? */\n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  /* advance from G_TOUCHED2... */\n              changeage(curr, G_TOUCHED2, G_OLD);  /* ... to G_OLD */\n            gray2black(curr);  /* make it black */\n          }\n          /* else, object is white: just remove it from this list */\n          *p = *next;  /* remove 'curr' from gray list */\n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  /* new object? */\n          *p = th->gclist;  /* remove from gray list */\n        else  /* old threads remain gray */\n          p = &th->gclist;  /* go to next element */\n        break;\n      }\n      default: lua_assert(0);  /* nothing more could be gray here */\n    }\n  }\n  return p;\n}",
        "func": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  /* touched in this cycle? */\n          lua_assert(isgray(curr));\n          gray2black(curr);  /* make it black, for next barrier */\n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  /* keep it in the list and go to next element */\n        }\n        else {  /* everything else is removed */\n          /* white objects are simply removed */\n          if (!iswhite(curr)) {  /* not white? */\n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  /* advance from G_TOUCHED2... */\n              changeage(curr, G_TOUCHED2, G_OLD);  /* ... to G_OLD */\n            gray2black(curr);  /* make it black */\n          }\n          *p = *next;  /* remove 'curr' from gray list */\n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  /* new object? */\n          *p = th->gclist;  /* remove from gray list */\n        else  /* old threads remain gray */\n          p = &th->gclist;  /* go to next element */\n        break;\n      }\n      default: lua_assert(0);  /* nothing more could be gray here */\n    }\n  }\n  return p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,16 +8,16 @@\n           lua_assert(isgray(curr));\n           gray2black(curr);  /* make it black, for next barrier */\n           changeage(curr, G_TOUCHED1, G_TOUCHED2);\n-          p = next;  /* go to next element */\n+          p = next;  /* keep it in the list and go to next element */\n         }\n-        else {  /* not touched in this cycle */\n+        else {  /* everything else is removed */\n+          /* white objects are simply removed */\n           if (!iswhite(curr)) {  /* not white? */\n             lua_assert(isold(curr));\n             if (getage(curr) == G_TOUCHED2)  /* advance from G_TOUCHED2... */\n               changeage(curr, G_TOUCHED2, G_OLD);  /* ... to G_OLD */\n             gray2black(curr);  /* make it black */\n           }\n-          /* else, object is white: just remove it from this list */\n           *p = *next;  /* remove 'curr' from gray list */\n         }\n         break;",
        "diff_line_info": {
            "deleted_lines": [
                "          p = next;  /* go to next element */",
                "        else {  /* not touched in this cycle */",
                "          /* else, object is white: just remove it from this list */"
            ],
            "added_lines": [
                "          p = next;  /* keep it in the list and go to next element */",
                "        else {  /* everything else is removed */",
                "          /* white objects are simply removed */"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24371",
        "func_name": "lua/luaC_barrier_",
        "description": "lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage.",
        "git_url": "https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110",
        "commit_title": "Fixed bug: barriers cannot be active during sweep",
        "commit_text": " Barriers cannot be active during sweep, even in generational mode. (Although gen. mode is not incremental, it can hit a barrier when deleting a thread and closing its upvalues.)  The colors of objects are being changed during sweep and, therefore, cannot be trusted.",
        "func_before": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n  }\n}",
        "func": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    if (g->gckind == KGC_INC)  /* incremental mode? */\n      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n   }\n   else {  /* sweep phase */\n     lua_assert(issweepphase(g));\n-    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n+    if (g->gckind == KGC_INC)  /* incremental mode? */\n+      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */"
            ],
            "added_lines": [
                "    if (g->gckind == KGC_INC)  /* incremental mode? */",
                "      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41073",
        "func_name": "torvalds/linux/loop_rw_iter",
        "description": "loop_rw_iter in fs/io_uring.c in the Linux kernel 5.10 through 5.14.6 allows local users to gain privileges by using IORING_OP_PROVIDE_BUFFERS to trigger a free of a kernel buffer, as demonstrated by using /proc/<pid>/maps for exploitation.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=16c8d2df7ec0eed31b7d3b61cb13206a7fb930cc",
        "commit_title": "When setting up the next segment, we check what type the iter is and",
        "commit_text": "handle it accordingly. However, when incrementing and processed amount we do not, and both iter advance and addr/len are adjusted, regardless of type. Split the increment side just like we do on the setup side.  Cc: stable@vger.kernel.org ",
        "func_before": "static ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct file *file = req->file;\n\tssize_t ret = 0;\n\n\t/*\n\t * Don't support polled IO through this interface, and we can't\n\t * support non-blocking either. For the latter, this just causes\n\t * the kiocb to be handled from an async context.\n\t */\n\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\tif (kiocb->ki_flags & IOCB_NOWAIT)\n\t\treturn -EAGAIN;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec;\n\t\tssize_t nr;\n\n\t\tif (!iov_iter_is_bvec(iter)) {\n\t\t\tiovec = iov_iter_iovec(iter);\n\t\t} else {\n\t\t\tiovec.iov_base = u64_to_user_ptr(req->rw.addr);\n\t\t\tiovec.iov_len = req->rw.len;\n\t\t}\n\n\t\tif (rw == READ) {\n\t\t\tnr = file->f_op->read(file, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, io_kiocb_ppos(kiocb));\n\t\t} else {\n\t\t\tnr = file->f_op->write(file, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, io_kiocb_ppos(kiocb));\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t\treq->rw.len -= nr;\n\t\treq->rw.addr += nr;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}",
        "func": "static ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct file *file = req->file;\n\tssize_t ret = 0;\n\n\t/*\n\t * Don't support polled IO through this interface, and we can't\n\t * support non-blocking either. For the latter, this just causes\n\t * the kiocb to be handled from an async context.\n\t */\n\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\tif (kiocb->ki_flags & IOCB_NOWAIT)\n\t\treturn -EAGAIN;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec;\n\t\tssize_t nr;\n\n\t\tif (!iov_iter_is_bvec(iter)) {\n\t\t\tiovec = iov_iter_iovec(iter);\n\t\t} else {\n\t\t\tiovec.iov_base = u64_to_user_ptr(req->rw.addr);\n\t\t\tiovec.iov_len = req->rw.len;\n\t\t}\n\n\t\tif (rw == READ) {\n\t\t\tnr = file->f_op->read(file, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, io_kiocb_ppos(kiocb));\n\t\t} else {\n\t\t\tnr = file->f_op->write(file, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, io_kiocb_ppos(kiocb));\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tif (!iov_iter_is_bvec(iter)) {\n\t\t\tiov_iter_advance(iter, nr);\n\t\t} else {\n\t\t\treq->rw.len -= nr;\n\t\t\treq->rw.addr += nr;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,12 +38,15 @@\n \t\t\t\tret = nr;\n \t\t\tbreak;\n \t\t}\n+\t\tif (!iov_iter_is_bvec(iter)) {\n+\t\t\tiov_iter_advance(iter, nr);\n+\t\t} else {\n+\t\t\treq->rw.len -= nr;\n+\t\t\treq->rw.addr += nr;\n+\t\t}\n \t\tret += nr;\n \t\tif (nr != iovec.iov_len)\n \t\t\tbreak;\n-\t\treq->rw.len -= nr;\n-\t\treq->rw.addr += nr;\n-\t\tiov_iter_advance(iter, nr);\n \t}\n \n \treturn ret;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treq->rw.len -= nr;",
                "\t\treq->rw.addr += nr;",
                "\t\tiov_iter_advance(iter, nr);"
            ],
            "added_lines": [
                "\t\tif (!iov_iter_is_bvec(iter)) {",
                "\t\t\tiov_iter_advance(iter, nr);",
                "\t\t} else {",
                "\t\t\treq->rw.len -= nr;",
                "\t\t\treq->rw.addr += nr;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18075",
        "func_name": "torvalds/linux/pcrypt_create_aead",
        "description": "crypto/pcrypt.c in the Linux kernel before 4.14.13 mishandles freeing instances, allowing a local user able to access the AF_ALG-based AEAD interface (CONFIG_CRYPTO_USER_API_AEAD) and pcrypt (CONFIG_CRYPTO_PCRYPT) to cause a denial of service (kfree of an incorrect pointer) or possibly have unspecified other impact by executing a crafted sequence of system calls.",
        "git_url": "https://github.com/torvalds/linux/commit/d76c68109f37cb85b243a1cf0f40313afd2bae68",
        "commit_title": "crypto: pcrypt - fix freeing pcrypt instances",
        "commit_text": " pcrypt is using the old way of freeing instances, where the ->free() method specified in the 'struct crypto_template' is passed a pointer to the 'struct crypto_instance'.  But the crypto_instance is being kfree()'d directly, which is incorrect because the memory was actually allocated as an aead_instance, which contains the crypto_instance at a nonzero offset.  Thus, the wrong pointer was being kfree()'d.  Fix it by switching to the new way to free aead_instance's where the ->free() method is specified in the aead_instance itself.  Cc: <stable@vger.kernel.org> # v4.2+",
        "func_before": "static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      u32 type, u32 mask)\n{\n\tstruct pcrypt_instance_ctx *ctx;\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct aead_alg *alg;\n\tconst char *name;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tname = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tctx = aead_instance_ctx(inst);\n\tcrypto_set_aead_spawn(&ctx->spawn, aead_crypto_instance(inst));\n\n\terr = crypto_grab_aead(&ctx->spawn, name, 0, 0);\n\tif (err)\n\t\tgoto out_free_inst;\n\n\talg = crypto_spawn_aead_alg(&ctx->spawn);\n\terr = pcrypt_init_instance(aead_crypto_instance(inst), &alg->base);\n\tif (err)\n\t\tgoto out_drop_aead;\n\n\tinst->alg.base.cra_flags = CRYPTO_ALG_ASYNC;\n\n\tinst->alg.ivsize = crypto_aead_alg_ivsize(alg);\n\tinst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\n\n\tinst->alg.init = pcrypt_aead_init_tfm;\n\tinst->alg.exit = pcrypt_aead_exit_tfm;\n\n\tinst->alg.setkey = pcrypt_aead_setkey;\n\tinst->alg.setauthsize = pcrypt_aead_setauthsize;\n\tinst->alg.encrypt = pcrypt_aead_encrypt;\n\tinst->alg.decrypt = pcrypt_aead_decrypt;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto out_drop_aead;\n\nout:\n\treturn err;\n\nout_drop_aead:\n\tcrypto_drop_aead(&ctx->spawn);\nout_free_inst:\n\tkfree(inst);\n\tgoto out;\n}",
        "func": "static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      u32 type, u32 mask)\n{\n\tstruct pcrypt_instance_ctx *ctx;\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct aead_alg *alg;\n\tconst char *name;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tname = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tctx = aead_instance_ctx(inst);\n\tcrypto_set_aead_spawn(&ctx->spawn, aead_crypto_instance(inst));\n\n\terr = crypto_grab_aead(&ctx->spawn, name, 0, 0);\n\tif (err)\n\t\tgoto out_free_inst;\n\n\talg = crypto_spawn_aead_alg(&ctx->spawn);\n\terr = pcrypt_init_instance(aead_crypto_instance(inst), &alg->base);\n\tif (err)\n\t\tgoto out_drop_aead;\n\n\tinst->alg.base.cra_flags = CRYPTO_ALG_ASYNC;\n\n\tinst->alg.ivsize = crypto_aead_alg_ivsize(alg);\n\tinst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\n\n\tinst->alg.init = pcrypt_aead_init_tfm;\n\tinst->alg.exit = pcrypt_aead_exit_tfm;\n\n\tinst->alg.setkey = pcrypt_aead_setkey;\n\tinst->alg.setauthsize = pcrypt_aead_setauthsize;\n\tinst->alg.encrypt = pcrypt_aead_encrypt;\n\tinst->alg.decrypt = pcrypt_aead_decrypt;\n\n\tinst->free = pcrypt_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto out_drop_aead;\n\nout:\n\treturn err;\n\nout_drop_aead:\n\tcrypto_drop_aead(&ctx->spawn);\nout_free_inst:\n\tkfree(inst);\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,6 +47,8 @@\n \tinst->alg.encrypt = pcrypt_aead_encrypt;\n \tinst->alg.decrypt = pcrypt_aead_decrypt;\n \n+\tinst->free = pcrypt_free;\n+\n \terr = aead_register_instance(tmpl, inst);\n \tif (err)\n \t\tgoto out_drop_aead;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tinst->free = pcrypt_free;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18075",
        "func_name": "torvalds/linux/pcrypt_free",
        "description": "crypto/pcrypt.c in the Linux kernel before 4.14.13 mishandles freeing instances, allowing a local user able to access the AF_ALG-based AEAD interface (CONFIG_CRYPTO_USER_API_AEAD) and pcrypt (CONFIG_CRYPTO_PCRYPT) to cause a denial of service (kfree of an incorrect pointer) or possibly have unspecified other impact by executing a crafted sequence of system calls.",
        "git_url": "https://github.com/torvalds/linux/commit/d76c68109f37cb85b243a1cf0f40313afd2bae68",
        "commit_title": "crypto: pcrypt - fix freeing pcrypt instances",
        "commit_text": " pcrypt is using the old way of freeing instances, where the ->free() method specified in the 'struct crypto_template' is passed a pointer to the 'struct crypto_instance'.  But the crypto_instance is being kfree()'d directly, which is incorrect because the memory was actually allocated as an aead_instance, which contains the crypto_instance at a nonzero offset.  Thus, the wrong pointer was being kfree()'d.  Fix it by switching to the new way to free aead_instance's where the ->free() method is specified in the aead_instance itself.  Cc: <stable@vger.kernel.org> # v4.2+",
        "func_before": "static void pcrypt_free(struct crypto_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\n\n\tcrypto_drop_aead(&ctx->spawn);\n\tkfree(inst);\n}",
        "func": "static void pcrypt_free(struct aead_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_aead(&ctx->spawn);\n\tkfree(inst);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n-static void pcrypt_free(struct crypto_instance *inst)\n+static void pcrypt_free(struct aead_instance *inst)\n {\n-\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\n+\tstruct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);\n \n \tcrypto_drop_aead(&ctx->spawn);\n \tkfree(inst);",
        "diff_line_info": {
            "deleted_lines": [
                "static void pcrypt_free(struct crypto_instance *inst)",
                "\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);"
            ],
            "added_lines": [
                "static void pcrypt_free(struct aead_instance *inst)",
                "\tstruct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-6836",
        "func_name": "wireshark/netmon_open",
        "description": "The netmonrec_comment_destroy function in wiretap/netmon.c in Wireshark through 2.4.4 performs a free operation on an uninitialized memory address, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/wireshark/wireshark/commit/28960d79cca262ac6b974f339697b299a1e28fef",
        "commit_title": "netmon: Initialize struct netmonrec_comment on alloc",
        "commit_text": " This avoids an illegal pointer to free() on error.  Bug: 14397",
        "func_before": "wtap_open_return_val netmon_open(wtap *wth, int *err, gchar **err_info)\n{\n\tchar magic[MAGIC_SIZE];\n\tstruct netmon_hdr hdr;\n\tint file_type;\n\tstruct tm tm;\n\tguint32 frame_table_offset;\n\tguint32 frame_table_length;\n\tguint32 frame_table_size;\n\tguint32 *frame_table;\n\tguint32 comment_table_offset, process_info_table_offset;\n\tguint32 comment_table_size, process_info_table_count;\n\tGHashTable *comment_table, *process_info_table;\n\tstruct netmonrec_comment* comment_rec;\n\tgint64 file_size = wtap_file_size(wth, err);\n#ifdef WORDS_BIGENDIAN\n\tunsigned int i;\n#endif\n\tnetmon_t *netmon;\n\n\t/* Read in the string that should be at the start of a Network\n\t * Monitor file */\n\tif (!wtap_read_bytes(wth->fh, magic, MAGIC_SIZE, err, err_info)) {\n\t\tif (*err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (memcmp(magic, netmon_1_x_magic, MAGIC_SIZE) != 0 &&\n\t    memcmp(magic, netmon_2_x_magic, MAGIC_SIZE) != 0) {\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\t/* Read the rest of the header. */\n\tif (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))\n\t\treturn WTAP_OPEN_ERROR;\n\n\tswitch (hdr.ver_major) {\n\n\tcase 1:\n\t\tfile_type = WTAP_FILE_TYPE_SUBTYPE_NETMON_1_x;\n\t\tbreak;\n\n\tcase 2:\n\t\tfile_type = WTAP_FILE_TYPE_SUBTYPE_NETMON_2_x;\n\t\tbreak;\n\n\tdefault:\n\t\t*err = WTAP_ERR_UNSUPPORTED;\n\t\t*err_info = g_strdup_printf(\"netmon: major version %u unsupported\", hdr.ver_major);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\n\thdr.network = pletoh16(&hdr.network);\n\tif (hdr.network >= NUM_NETMON_ENCAPS\n\t    || netmon_encap[hdr.network] == WTAP_ENCAP_UNKNOWN) {\n\t\t*err = WTAP_ERR_UNSUPPORTED;\n\t\t*err_info = g_strdup_printf(\"netmon: network type %u unknown or unsupported\",\n\t\t    hdr.network);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\n\t/* This is a netmon file */\n\twth->file_type_subtype = file_type;\n\tnetmon = (netmon_t *)g_malloc0(sizeof(netmon_t));\n\twth->priv = (void *)netmon;\n\twth->subtype_read = netmon_read;\n\twth->subtype_seek_read = netmon_seek_read;\n\twth->subtype_close = netmon_close;\n\n\t/* NetMon capture file formats v2.1+ use per-packet encapsulation types.  NetMon 3 sets the value in\n\t * the header to 1 (Ethernet) for backwards compability. */\n\tif((hdr.ver_major == 2 && hdr.ver_minor >= 1) || hdr.ver_major > 2)\n\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\telse\n\t\twth->file_encap = netmon_encap[hdr.network];\n\n\twth->snapshot_length = 0;\t/* not available in header */\n\t/*\n\t * Convert the time stamp to a \"time_t\" and a number of\n\t * milliseconds.\n\t */\n\ttm.tm_year = pletoh16(&hdr.ts_year) - 1900;\n\ttm.tm_mon = pletoh16(&hdr.ts_month) - 1;\n\ttm.tm_mday = pletoh16(&hdr.ts_day);\n\ttm.tm_hour = pletoh16(&hdr.ts_hour);\n\ttm.tm_min = pletoh16(&hdr.ts_min);\n\ttm.tm_sec = pletoh16(&hdr.ts_sec);\n\ttm.tm_isdst = -1;\n\tnetmon->start_secs = mktime(&tm);\n\t/*\n\t * XXX - what if \"secs\" is -1?  Unlikely, but if the capture was\n\t * done in a time zone that switches between standard and summer\n\t * time sometime other than when we do, and thus the time was one\n\t * that doesn't exist here because a switch from standard to summer\n\t * time zips over it, it could happen.\n\t *\n\t * On the other hand, if the capture was done in a different time\n\t * zone, this won't work right anyway; unfortunately, the time\n\t * zone isn't stored in the capture file (why the hell didn't\n\t * they stuff a FILETIME, which is the number of 100-nanosecond\n\t * intervals since 1601-01-01 00:00:00 \"UTC\", there, instead\n\t * of stuffing a SYSTEMTIME, which is time-zone-dependent, there?).\n\t */\n\tnetmon->start_nsecs = pletoh16(&hdr.ts_msec)*1000000;\n\n\tnetmon->version_major = hdr.ver_major;\n\tnetmon->version_minor = hdr.ver_minor;\n\n\t/*\n\t * Get the offset of the frame index table.\n\t */\n\tframe_table_offset = pletoh32(&hdr.frametableoffset);\n\n\t/*\n\t * For NetMon 2.2 format and later, get the offset and length of\n\t * the comment index table and process info table.\n\t *\n\t * For earlier versions, set them to zero; they appear to be\n\t * uninitialized, so they're not necessarily zero.\n\t */\n\tif ((netmon->version_major == 2 && netmon->version_minor >= 2) ||\n\t    netmon->version_major > 2) {\n\t\tcomment_table_offset = pletoh32(&hdr.commentdataoffset);\n\t\tcomment_table_size = pletoh32(&hdr.commentdatalength);\n\t\tprocess_info_table_offset = pletoh32(&hdr.processinfooffset);\n\t\tprocess_info_table_count = pletoh32(&hdr.processinfocount);\n\t} else {\n\t\tcomment_table_offset = 0;\n\t\tcomment_table_size = 0;\n\t\tprocess_info_table_offset = 0;\n\t\tprocess_info_table_count = 0;\n\t}\n\n\t/*\n\t * It appears that some NetMon 2.x files don't have the\n\t * first packet starting exactly 128 bytes into the file.\n\t *\n\t * Furthermore, it also appears that there are \"holes\" in\n\t * the file, i.e. frame N+1 doesn't always follow immediately\n\t * after frame N.\n\t *\n\t * Therefore, we must read the frame table, and use the offsets\n\t * in it as the offsets of the frames.\n\t */\n\tframe_table_length = pletoh32(&hdr.frametablelength);\n\tframe_table_size = frame_table_length / (guint32)sizeof (guint32);\n\tif ((frame_table_size * sizeof (guint32)) != frame_table_length) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netmon: frame table length is %u, which is not a multiple of the size of an entry\",\n\t\t    frame_table_length);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\tif (frame_table_size == 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netmon: frame table length is %u, which means it's less than one entry in size\",\n\t\t    frame_table_length);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\t/*\n\t * XXX - clamp the size of the frame table, so that we don't\n\t * attempt to allocate a huge frame table and fail.\n\t *\n\t * Given that file offsets in the frame table are 32-bit,\n\t * a NetMon file cannot be bigger than 2^32 bytes.\n\t * Given that a NetMon 1.x-format packet header is 8 bytes,\n\t * that means a NetMon file cannot have more than\n\t * 512*2^20 packets.  We'll pick that as the limit for\n\t * now; it's 1/8th of a 32-bit address space, which is\n\t * probably not going to exhaust the address space all by\n\t * itself, and probably won't exhaust the backing store.\n\t */\n\tif (frame_table_size > 512*1024*1024) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netmon: frame table length is %u, which is larger than we support\",\n\t\t    frame_table_length);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\tif (file_seek(wth->fh, frame_table_offset, SEEK_SET, err) == -1) {\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\n\t/*\n\t * Sanity check the comment table information before we bother to allocate\n\t * large chunks of memory for the frame table\n\t */\n\tif (comment_table_size > 0) {\n\t\t/*\n\t\t * XXX - clamp the size of the comment table, so that we don't\n\t\t * attempt to allocate a huge comment table and fail.\n\t\t *\n\t\t * Just use same size requires as frame table\n\t\t */\n\t\tif (comment_table_size > 512*1024*1024) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: comment table size is %u, which is larger than we support\",\n\t\t\t\tcomment_table_size);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tif (comment_table_size < 17) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: comment table size is %u, which is too small to use\",\n\t\t\t\tcomment_table_size);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tif (comment_table_offset > file_size) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: comment table offset (%u) is larger than file\",\n\t\t\t\tcomment_table_offset);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * Sanity check the process info table information before we bother to allocate\n\t * large chunks of memory for the frame table\n\t */\n\tif ((process_info_table_offset > 0) && (process_info_table_count > 0)) {\n\t\t/*\n\t\t * XXX - clamp the size of the process info table, so that we don't\n\t\t * attempt to allocate a huge process info table and fail.\n\t\t */\n\t\tif (process_info_table_count > 512*1024) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: process info table size is %u, which is larger than we support\",\n\t\t\t\tprocess_info_table_count);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tif (process_info_table_offset > file_size) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: process info table offset (%u) is larger than file\",\n\t\t\t\tprocess_info_table_offset);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * Return back to the frame table offset\n\t */\n\tif (file_seek(wth->fh, frame_table_offset, SEEK_SET, err) == -1) {\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\n\t/*\n\t * Sanity check the process info table information before we bother to allocate\n\t * large chunks of memory for the frame table\n\t */\n\n\tframe_table = (guint32 *)g_try_malloc(frame_table_length);\n\tif (frame_table_length != 0 && frame_table == NULL) {\n\t\t*err = ENOMEM;\t/* we assume we're out of memory */\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\tif (!wtap_read_bytes(wth->fh, frame_table, frame_table_length,\n\t    err, err_info)) {\n\t\tg_free(frame_table);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\tnetmon->frame_table_size = frame_table_size;\n\tnetmon->frame_table = frame_table;\n\n\tif (comment_table_size > 0) {\n\t\tcomment_table = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, netmonrec_comment_destroy);\n\t\tif (comment_table == NULL) {\n\t\t\t\t*err = ENOMEM;\t/* we assume we're out of memory */\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\t/* Make sure the file contains the full comment section */\n\t\tif (file_seek(wth->fh, comment_table_offset+comment_table_size, SEEK_SET, err) == -1) {\n\t\t\tg_hash_table_destroy(comment_table);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tif (file_seek(wth->fh, comment_table_offset, SEEK_SET, err) == -1) {\n\t\t\t/* Shouldn't fail... */\n\t\t\tg_hash_table_destroy(comment_table);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\twhile (comment_table_size > 16) {\n\t\t\tstruct netmonrec_comment_header comment_header;\n\t\t\tguint32 desc_length;\n\n\t\t\t/* Read the first 12 bytes of the structure */\n\t\t\tif (!wtap_read_bytes(wth->fh, &comment_header, 12, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tcomment_table_size -= 12;\n\n\t\t\t/* Make sure comment size is sane */\n\t\t\tif (pletoh32(&comment_header.titleLength) == 0) {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netmon: comment title size can't be 0\");\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tif (pletoh32(&comment_header.titleLength) > comment_table_size) {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup_printf(\"netmon: comment title size is %u, which is larger than the entire comment section (%d)\",\n\t\t\t\t\t\tpletoh32(&comment_header.titleLength), comment_table_size);\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tcomment_rec = g_new(struct netmonrec_comment, 1);\n\t\t\tcomment_rec->numFramePerComment = pletoh32(&comment_header.numFramePerComment);\n\t\t\tcomment_rec->frameOffset = pletoh32(&comment_header.frameOffset);\n\t\t\tcomment_rec->titleLength = pletoh32(&comment_header.titleLength);\n\t\t\tcomment_rec->title = (guint8*)g_malloc(comment_rec->titleLength);\n\n\t\t\tg_hash_table_insert(comment_table, GUINT_TO_POINTER(comment_rec->frameOffset), comment_rec);\n\n\t\t\t/* Read the comment title */\n\t\t\tif (!wtap_read_bytes(wth->fh, comment_rec->title, comment_rec->titleLength, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tcomment_table_size -= comment_rec->titleLength;\n\n\t\t\tif (comment_table_size < 4) {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netmon: corrupt comment section\");\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tif (!wtap_read_bytes(wth->fh, &desc_length, 4, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tcomment_table_size -= 4;\n\n\t\t\tcomment_rec->descLength = pletoh32(&desc_length);\n\t\t\tif (comment_rec->descLength > 0) {\n\t\t\t\t/* Make sure comment size is sane */\n\t\t\t\tif (comment_rec->descLength > comment_table_size) {\n\t\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t\t*err_info = g_strdup_printf(\"netmon: comment description size is %u, which is larger than the entire comment section (%d)\",\n\t\t\t\t\t\t\t\tcomment_rec->descLength, comment_table_size);\n\t\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\n\t\t\t\tcomment_rec->description = (guint8*)g_malloc(comment_rec->descLength);\n\n\t\t\t\t/* Read the comment description */\n\t\t\t\tif (!wtap_read_bytes(wth->fh, comment_rec->description, comment_rec->descLength, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\n\t\t\t\tcomment_table_size -= comment_rec->descLength;\n\t\t\t}\n\t\t}\n\t\tnetmon->comment_table = comment_table;\n\t}\n\n\tif ((process_info_table_offset > 0) && (process_info_table_count > 0)) {\n\t\tguint16 version;\n\n\t\t/* Go to the process table offset */\n\t\tif (file_seek(wth->fh, process_info_table_offset, SEEK_SET, err) == -1) {\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tprocess_info_table = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, netmonrec_process_info_destroy);\n\t\tif (process_info_table == NULL) {\n\t\t\t*err = ENOMEM;\t/* we assume we're out of memory */\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\t/* Read the version (ignored for now) */\n\t\tif (!wtap_read_bytes(wth->fh, &version, 2, err, err_info)) {\n\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\twhile (process_info_table_count > 0)\n\t\t{\n\t\t\tstruct netmonrec_process_info* process_info;\n\t\t\tguint32 tmp32;\n\t\t\tguint16 tmp16;\n\n\t\t\tprocess_info = g_new0(struct netmonrec_process_info, 1);\n\n\t\t\t/* Read path */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tprocess_info->pathSize = pletoh32(&tmp32);\n\t\t\tif (process_info->pathSize > 260) {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup_printf(\"netmon: Path size for process info record is %u, which is larger than allowed max value (260)\",\n\t\t\t\t\t\t\tprocess_info->pathSize);\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tprocess_info->path = (guint8*)g_malloc(process_info->pathSize);\n\t\t\tif (!wtap_read_bytes(wth->fh, process_info->path, process_info->pathSize, err, err_info)) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\t/* Read icon (currently not saved) */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tprocess_info->iconSize = pletoh32(&tmp32);\n\n\t\t\t/* XXX - skip the icon for now */\n\t\t\tif (file_seek(wth->fh, process_info->iconSize, SEEK_CUR, err) == -1) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->iconSize = 0;\n\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->pid = pletoh32(&tmp32);\n\n\t\t\t/* XXX - Currently index process information by PID */\n\t\t\tg_hash_table_insert(process_info_table, GUINT_TO_POINTER(process_info->pid), process_info);\n\n\t\t\t/* Read local port */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->localPort = pletoh16(&tmp16);\n\n\t\t\t/* Skip padding */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\t/* Read remote port */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->remotePort = pletoh16(&tmp16);\n\n\t\t\t/* Skip padding */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\t/* Determine IP version */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->isIPv6 = ((pletoh32(&tmp32) == 0) ? FALSE : TRUE);\n\n\t\t\tif (process_info->isIPv6) {\n\t\t\t\tif (!wtap_read_bytes(wth->fh, &process_info->localAddr.ipv6, 16, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\t\t\t\tif (!wtap_read_bytes(wth->fh, &process_info->remoteAddr.ipv6, 16, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tguint8 ipbuffer[16];\n\t\t\t\tif (!wtap_read_bytes(wth->fh, ipbuffer, 16, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\t\t\t\tprocess_info->localAddr.ipv4 = pletoh32(ipbuffer);\n\n\t\t\t\tif (!wtap_read_bytes(wth->fh, ipbuffer, 16, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\t\t\t\tprocess_info->remoteAddr.ipv4 = pletoh32(ipbuffer);\n\t\t\t}\n\n\t\t\tprocess_info_table_count--;\n\t\t}\n\n\t\tnetmon->process_info_table = process_info_table;\n\t}\n\n#ifdef WORDS_BIGENDIAN\n\t/*\n\t * OK, now byte-swap the frame table.\n\t */\n\tfor (i = 0; i < frame_table_size; i++)\n\t\tframe_table[i] = pletoh32(&frame_table[i]);\n#endif\n\n\t/* Set up to start reading at the first frame. */\n\tnetmon->current_frame = 0;\n\tswitch (netmon->version_major) {\n\n\tcase 1:\n\t\t/*\n\t\t * Version 1.x of the file format supports\n\t\t * millisecond precision.\n\t\t */\n\t\twth->file_tsprec = WTAP_TSPREC_MSEC;\n\t\tbreak;\n\n\tcase 2:\n\t\t/*\n\t\t * Version 1.x of the file format supports\n\t\t * 100-nanosecond precision; we don't\n\t\t * currently support that, so say\n\t\t * \"nanosecond precision\" for now.\n\t\t */\n\t\twth->file_tsprec = WTAP_TSPREC_NSEC;\n\t\tbreak;\n\t}\n\treturn WTAP_OPEN_MINE;\n}",
        "func": "wtap_open_return_val netmon_open(wtap *wth, int *err, gchar **err_info)\n{\n\tchar magic[MAGIC_SIZE];\n\tstruct netmon_hdr hdr;\n\tint file_type;\n\tstruct tm tm;\n\tguint32 frame_table_offset;\n\tguint32 frame_table_length;\n\tguint32 frame_table_size;\n\tguint32 *frame_table;\n\tguint32 comment_table_offset, process_info_table_offset;\n\tguint32 comment_table_size, process_info_table_count;\n\tGHashTable *comment_table, *process_info_table;\n\tstruct netmonrec_comment* comment_rec;\n\tgint64 file_size = wtap_file_size(wth, err);\n#ifdef WORDS_BIGENDIAN\n\tunsigned int i;\n#endif\n\tnetmon_t *netmon;\n\n\t/* Read in the string that should be at the start of a Network\n\t * Monitor file */\n\tif (!wtap_read_bytes(wth->fh, magic, MAGIC_SIZE, err, err_info)) {\n\t\tif (*err != WTAP_ERR_SHORT_READ)\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\tif (memcmp(magic, netmon_1_x_magic, MAGIC_SIZE) != 0 &&\n\t    memcmp(magic, netmon_2_x_magic, MAGIC_SIZE) != 0) {\n\t\treturn WTAP_OPEN_NOT_MINE;\n\t}\n\n\t/* Read the rest of the header. */\n\tif (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))\n\t\treturn WTAP_OPEN_ERROR;\n\n\tswitch (hdr.ver_major) {\n\n\tcase 1:\n\t\tfile_type = WTAP_FILE_TYPE_SUBTYPE_NETMON_1_x;\n\t\tbreak;\n\n\tcase 2:\n\t\tfile_type = WTAP_FILE_TYPE_SUBTYPE_NETMON_2_x;\n\t\tbreak;\n\n\tdefault:\n\t\t*err = WTAP_ERR_UNSUPPORTED;\n\t\t*err_info = g_strdup_printf(\"netmon: major version %u unsupported\", hdr.ver_major);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\n\thdr.network = pletoh16(&hdr.network);\n\tif (hdr.network >= NUM_NETMON_ENCAPS\n\t    || netmon_encap[hdr.network] == WTAP_ENCAP_UNKNOWN) {\n\t\t*err = WTAP_ERR_UNSUPPORTED;\n\t\t*err_info = g_strdup_printf(\"netmon: network type %u unknown or unsupported\",\n\t\t    hdr.network);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\n\t/* This is a netmon file */\n\twth->file_type_subtype = file_type;\n\tnetmon = (netmon_t *)g_malloc0(sizeof(netmon_t));\n\twth->priv = (void *)netmon;\n\twth->subtype_read = netmon_read;\n\twth->subtype_seek_read = netmon_seek_read;\n\twth->subtype_close = netmon_close;\n\n\t/* NetMon capture file formats v2.1+ use per-packet encapsulation types.  NetMon 3 sets the value in\n\t * the header to 1 (Ethernet) for backwards compability. */\n\tif((hdr.ver_major == 2 && hdr.ver_minor >= 1) || hdr.ver_major > 2)\n\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\telse\n\t\twth->file_encap = netmon_encap[hdr.network];\n\n\twth->snapshot_length = 0;\t/* not available in header */\n\t/*\n\t * Convert the time stamp to a \"time_t\" and a number of\n\t * milliseconds.\n\t */\n\ttm.tm_year = pletoh16(&hdr.ts_year) - 1900;\n\ttm.tm_mon = pletoh16(&hdr.ts_month) - 1;\n\ttm.tm_mday = pletoh16(&hdr.ts_day);\n\ttm.tm_hour = pletoh16(&hdr.ts_hour);\n\ttm.tm_min = pletoh16(&hdr.ts_min);\n\ttm.tm_sec = pletoh16(&hdr.ts_sec);\n\ttm.tm_isdst = -1;\n\tnetmon->start_secs = mktime(&tm);\n\t/*\n\t * XXX - what if \"secs\" is -1?  Unlikely, but if the capture was\n\t * done in a time zone that switches between standard and summer\n\t * time sometime other than when we do, and thus the time was one\n\t * that doesn't exist here because a switch from standard to summer\n\t * time zips over it, it could happen.\n\t *\n\t * On the other hand, if the capture was done in a different time\n\t * zone, this won't work right anyway; unfortunately, the time\n\t * zone isn't stored in the capture file (why the hell didn't\n\t * they stuff a FILETIME, which is the number of 100-nanosecond\n\t * intervals since 1601-01-01 00:00:00 \"UTC\", there, instead\n\t * of stuffing a SYSTEMTIME, which is time-zone-dependent, there?).\n\t */\n\tnetmon->start_nsecs = pletoh16(&hdr.ts_msec)*1000000;\n\n\tnetmon->version_major = hdr.ver_major;\n\tnetmon->version_minor = hdr.ver_minor;\n\n\t/*\n\t * Get the offset of the frame index table.\n\t */\n\tframe_table_offset = pletoh32(&hdr.frametableoffset);\n\n\t/*\n\t * For NetMon 2.2 format and later, get the offset and length of\n\t * the comment index table and process info table.\n\t *\n\t * For earlier versions, set them to zero; they appear to be\n\t * uninitialized, so they're not necessarily zero.\n\t */\n\tif ((netmon->version_major == 2 && netmon->version_minor >= 2) ||\n\t    netmon->version_major > 2) {\n\t\tcomment_table_offset = pletoh32(&hdr.commentdataoffset);\n\t\tcomment_table_size = pletoh32(&hdr.commentdatalength);\n\t\tprocess_info_table_offset = pletoh32(&hdr.processinfooffset);\n\t\tprocess_info_table_count = pletoh32(&hdr.processinfocount);\n\t} else {\n\t\tcomment_table_offset = 0;\n\t\tcomment_table_size = 0;\n\t\tprocess_info_table_offset = 0;\n\t\tprocess_info_table_count = 0;\n\t}\n\n\t/*\n\t * It appears that some NetMon 2.x files don't have the\n\t * first packet starting exactly 128 bytes into the file.\n\t *\n\t * Furthermore, it also appears that there are \"holes\" in\n\t * the file, i.e. frame N+1 doesn't always follow immediately\n\t * after frame N.\n\t *\n\t * Therefore, we must read the frame table, and use the offsets\n\t * in it as the offsets of the frames.\n\t */\n\tframe_table_length = pletoh32(&hdr.frametablelength);\n\tframe_table_size = frame_table_length / (guint32)sizeof (guint32);\n\tif ((frame_table_size * sizeof (guint32)) != frame_table_length) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netmon: frame table length is %u, which is not a multiple of the size of an entry\",\n\t\t    frame_table_length);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\tif (frame_table_size == 0) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netmon: frame table length is %u, which means it's less than one entry in size\",\n\t\t    frame_table_length);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\t/*\n\t * XXX - clamp the size of the frame table, so that we don't\n\t * attempt to allocate a huge frame table and fail.\n\t *\n\t * Given that file offsets in the frame table are 32-bit,\n\t * a NetMon file cannot be bigger than 2^32 bytes.\n\t * Given that a NetMon 1.x-format packet header is 8 bytes,\n\t * that means a NetMon file cannot have more than\n\t * 512*2^20 packets.  We'll pick that as the limit for\n\t * now; it's 1/8th of a 32-bit address space, which is\n\t * probably not going to exhaust the address space all by\n\t * itself, and probably won't exhaust the backing store.\n\t */\n\tif (frame_table_size > 512*1024*1024) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"netmon: frame table length is %u, which is larger than we support\",\n\t\t    frame_table_length);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\tif (file_seek(wth->fh, frame_table_offset, SEEK_SET, err) == -1) {\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\n\t/*\n\t * Sanity check the comment table information before we bother to allocate\n\t * large chunks of memory for the frame table\n\t */\n\tif (comment_table_size > 0) {\n\t\t/*\n\t\t * XXX - clamp the size of the comment table, so that we don't\n\t\t * attempt to allocate a huge comment table and fail.\n\t\t *\n\t\t * Just use same size requires as frame table\n\t\t */\n\t\tif (comment_table_size > 512*1024*1024) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: comment table size is %u, which is larger than we support\",\n\t\t\t\tcomment_table_size);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tif (comment_table_size < 17) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: comment table size is %u, which is too small to use\",\n\t\t\t\tcomment_table_size);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tif (comment_table_offset > file_size) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: comment table offset (%u) is larger than file\",\n\t\t\t\tcomment_table_offset);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * Sanity check the process info table information before we bother to allocate\n\t * large chunks of memory for the frame table\n\t */\n\tif ((process_info_table_offset > 0) && (process_info_table_count > 0)) {\n\t\t/*\n\t\t * XXX - clamp the size of the process info table, so that we don't\n\t\t * attempt to allocate a huge process info table and fail.\n\t\t */\n\t\tif (process_info_table_count > 512*1024) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: process info table size is %u, which is larger than we support\",\n\t\t\t\tprocess_info_table_count);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tif (process_info_table_offset > file_size) {\n\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t*err_info = g_strdup_printf(\"netmon: process info table offset (%u) is larger than file\",\n\t\t\t\tprocess_info_table_offset);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * Return back to the frame table offset\n\t */\n\tif (file_seek(wth->fh, frame_table_offset, SEEK_SET, err) == -1) {\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\n\t/*\n\t * Sanity check the process info table information before we bother to allocate\n\t * large chunks of memory for the frame table\n\t */\n\n\tframe_table = (guint32 *)g_try_malloc(frame_table_length);\n\tif (frame_table_length != 0 && frame_table == NULL) {\n\t\t*err = ENOMEM;\t/* we assume we're out of memory */\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\tif (!wtap_read_bytes(wth->fh, frame_table, frame_table_length,\n\t    err, err_info)) {\n\t\tg_free(frame_table);\n\t\treturn WTAP_OPEN_ERROR;\n\t}\n\tnetmon->frame_table_size = frame_table_size;\n\tnetmon->frame_table = frame_table;\n\n\tif (comment_table_size > 0) {\n\t\tcomment_table = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, netmonrec_comment_destroy);\n\t\tif (comment_table == NULL) {\n\t\t\t\t*err = ENOMEM;\t/* we assume we're out of memory */\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\t/* Make sure the file contains the full comment section */\n\t\tif (file_seek(wth->fh, comment_table_offset+comment_table_size, SEEK_SET, err) == -1) {\n\t\t\tg_hash_table_destroy(comment_table);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tif (file_seek(wth->fh, comment_table_offset, SEEK_SET, err) == -1) {\n\t\t\t/* Shouldn't fail... */\n\t\t\tg_hash_table_destroy(comment_table);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\twhile (comment_table_size > 16) {\n\t\t\tstruct netmonrec_comment_header comment_header;\n\t\t\tguint32 desc_length;\n\n\t\t\t/* Read the first 12 bytes of the structure */\n\t\t\tif (!wtap_read_bytes(wth->fh, &comment_header, 12, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tcomment_table_size -= 12;\n\n\t\t\t/* Make sure comment size is sane */\n\t\t\tif (pletoh32(&comment_header.titleLength) == 0) {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netmon: comment title size can't be 0\");\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tif (pletoh32(&comment_header.titleLength) > comment_table_size) {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup_printf(\"netmon: comment title size is %u, which is larger than the entire comment section (%d)\",\n\t\t\t\t\t\tpletoh32(&comment_header.titleLength), comment_table_size);\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tcomment_rec = g_new0(struct netmonrec_comment, 1);\n\t\t\tcomment_rec->numFramePerComment = pletoh32(&comment_header.numFramePerComment);\n\t\t\tcomment_rec->frameOffset = pletoh32(&comment_header.frameOffset);\n\t\t\tcomment_rec->titleLength = pletoh32(&comment_header.titleLength);\n\t\t\tcomment_rec->title = (guint8*)g_malloc(comment_rec->titleLength);\n\n\t\t\tg_hash_table_insert(comment_table, GUINT_TO_POINTER(comment_rec->frameOffset), comment_rec);\n\n\t\t\t/* Read the comment title */\n\t\t\tif (!wtap_read_bytes(wth->fh, comment_rec->title, comment_rec->titleLength, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tcomment_table_size -= comment_rec->titleLength;\n\n\t\t\tif (comment_table_size < 4) {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netmon: corrupt comment section\");\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tif (!wtap_read_bytes(wth->fh, &desc_length, 4, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tcomment_table_size -= 4;\n\n\t\t\tcomment_rec->descLength = pletoh32(&desc_length);\n\t\t\tif (comment_rec->descLength > 0) {\n\t\t\t\t/* Make sure comment size is sane */\n\t\t\t\tif (comment_rec->descLength > comment_table_size) {\n\t\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t\t*err_info = g_strdup_printf(\"netmon: comment description size is %u, which is larger than the entire comment section (%d)\",\n\t\t\t\t\t\t\t\tcomment_rec->descLength, comment_table_size);\n\t\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\n\t\t\t\tcomment_rec->description = (guint8*)g_malloc(comment_rec->descLength);\n\n\t\t\t\t/* Read the comment description */\n\t\t\t\tif (!wtap_read_bytes(wth->fh, comment_rec->description, comment_rec->descLength, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(comment_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\n\t\t\t\tcomment_table_size -= comment_rec->descLength;\n\t\t\t}\n\t\t}\n\t\tnetmon->comment_table = comment_table;\n\t}\n\n\tif ((process_info_table_offset > 0) && (process_info_table_count > 0)) {\n\t\tguint16 version;\n\n\t\t/* Go to the process table offset */\n\t\tif (file_seek(wth->fh, process_info_table_offset, SEEK_SET, err) == -1) {\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\tprocess_info_table = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, netmonrec_process_info_destroy);\n\t\tif (process_info_table == NULL) {\n\t\t\t*err = ENOMEM;\t/* we assume we're out of memory */\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\t/* Read the version (ignored for now) */\n\t\tif (!wtap_read_bytes(wth->fh, &version, 2, err, err_info)) {\n\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\treturn WTAP_OPEN_ERROR;\n\t\t}\n\n\t\twhile (process_info_table_count > 0)\n\t\t{\n\t\t\tstruct netmonrec_process_info* process_info;\n\t\t\tguint32 tmp32;\n\t\t\tguint16 tmp16;\n\n\t\t\tprocess_info = g_new0(struct netmonrec_process_info, 1);\n\n\t\t\t/* Read path */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tprocess_info->pathSize = pletoh32(&tmp32);\n\t\t\tif (process_info->pathSize > 260) {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup_printf(\"netmon: Path size for process info record is %u, which is larger than allowed max value (260)\",\n\t\t\t\t\t\t\tprocess_info->pathSize);\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tprocess_info->path = (guint8*)g_malloc(process_info->pathSize);\n\t\t\tif (!wtap_read_bytes(wth->fh, process_info->path, process_info->pathSize, err, err_info)) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\t/* Read icon (currently not saved) */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\tprocess_info->iconSize = pletoh32(&tmp32);\n\n\t\t\t/* XXX - skip the icon for now */\n\t\t\tif (file_seek(wth->fh, process_info->iconSize, SEEK_CUR, err) == -1) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->iconSize = 0;\n\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {\n\t\t\t\tg_free(process_info);\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->pid = pletoh32(&tmp32);\n\n\t\t\t/* XXX - Currently index process information by PID */\n\t\t\tg_hash_table_insert(process_info_table, GUINT_TO_POINTER(process_info->pid), process_info);\n\n\t\t\t/* Read local port */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->localPort = pletoh16(&tmp16);\n\n\t\t\t/* Skip padding */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\t/* Read remote port */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->remotePort = pletoh16(&tmp16);\n\n\t\t\t/* Skip padding */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\n\t\t\t/* Determine IP version */\n\t\t\tif (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {\n\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t}\n\t\t\tprocess_info->isIPv6 = ((pletoh32(&tmp32) == 0) ? FALSE : TRUE);\n\n\t\t\tif (process_info->isIPv6) {\n\t\t\t\tif (!wtap_read_bytes(wth->fh, &process_info->localAddr.ipv6, 16, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\t\t\t\tif (!wtap_read_bytes(wth->fh, &process_info->remoteAddr.ipv6, 16, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tguint8 ipbuffer[16];\n\t\t\t\tif (!wtap_read_bytes(wth->fh, ipbuffer, 16, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\t\t\t\tprocess_info->localAddr.ipv4 = pletoh32(ipbuffer);\n\n\t\t\t\tif (!wtap_read_bytes(wth->fh, ipbuffer, 16, err, err_info)) {\n\t\t\t\t\tg_hash_table_destroy(process_info_table);\n\t\t\t\t\treturn WTAP_OPEN_ERROR;\n\t\t\t\t}\n\t\t\t\tprocess_info->remoteAddr.ipv4 = pletoh32(ipbuffer);\n\t\t\t}\n\n\t\t\tprocess_info_table_count--;\n\t\t}\n\n\t\tnetmon->process_info_table = process_info_table;\n\t}\n\n#ifdef WORDS_BIGENDIAN\n\t/*\n\t * OK, now byte-swap the frame table.\n\t */\n\tfor (i = 0; i < frame_table_size; i++)\n\t\tframe_table[i] = pletoh32(&frame_table[i]);\n#endif\n\n\t/* Set up to start reading at the first frame. */\n\tnetmon->current_frame = 0;\n\tswitch (netmon->version_major) {\n\n\tcase 1:\n\t\t/*\n\t\t * Version 1.x of the file format supports\n\t\t * millisecond precision.\n\t\t */\n\t\twth->file_tsprec = WTAP_TSPREC_MSEC;\n\t\tbreak;\n\n\tcase 2:\n\t\t/*\n\t\t * Version 1.x of the file format supports\n\t\t * 100-nanosecond precision; we don't\n\t\t * currently support that, so say\n\t\t * \"nanosecond precision\" for now.\n\t\t */\n\t\twth->file_tsprec = WTAP_TSPREC_NSEC;\n\t\tbreak;\n\t}\n\treturn WTAP_OPEN_MINE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -307,7 +307,7 @@\n \t\t\t\treturn WTAP_OPEN_ERROR;\n \t\t\t}\n \n-\t\t\tcomment_rec = g_new(struct netmonrec_comment, 1);\n+\t\t\tcomment_rec = g_new0(struct netmonrec_comment, 1);\n \t\t\tcomment_rec->numFramePerComment = pletoh32(&comment_header.numFramePerComment);\n \t\t\tcomment_rec->frameOffset = pletoh32(&comment_header.frameOffset);\n \t\t\tcomment_rec->titleLength = pletoh32(&comment_header.titleLength);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tcomment_rec = g_new(struct netmonrec_comment, 1);"
            ],
            "added_lines": [
                "\t\t\tcomment_rec = g_new0(struct netmonrec_comment, 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25565",
        "func_name": "gssapi/gss-ntlmssp/ntlm_decode_target_info",
        "description": "GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM authentication. Prior to version 1.2.0, an incorrect free when decoding target information can trigger a denial of service. The error condition incorrectly assumes the `cb` and `sh` buffers contain a copy of the data that needs to be freed. However, that is not the case. This vulnerability can be triggered via the main `gss_accept_sec_context` entry point. This will likely trigger an assertion failure in `free`, causing a denial-of-service. This issue is fixed in version 1.2.0.",
        "git_url": "https://github.com/gssapi/gss-ntlmssp/commit/c16100f60907a2de92bcb676f303b81facee0f64",
        "commit_title": "GHSL-2023-012: Incorrect free when decoding target",
        "commit_text": " Incorrect free when decoding target information (GHSL-2023-012)  Fixes defect GHSL-2023-012 found by the GitHub Security Lab team via oss-fuzz.  The error condition incorrectly assumed the cb and sh buffers would contain a copy of the data that needed to freed. However that is not the case.  This will generally cause an assertion when trying to free a pointer that was never allocated, and potentially memory corruption depending on the contents fo the target_info buffer.  This may cause a DoS condition. ",
        "func_before": "int ntlm_decode_target_info(struct ntlm_ctx *ctx, struct ntlm_buffer *buffer,\n                            char **nb_computer_name, char **nb_domain_name,\n                            char **dns_computer_name, char **dns_domain_name,\n                            char **dns_tree_name, char **av_target_name,\n                            uint32_t *av_flags, uint64_t *av_timestamp,\n                            struct ntlm_buffer *av_single_host,\n                            struct ntlm_buffer *av_cb)\n{\n    struct wire_av_pair *av_pair;\n    uint16_t av_id = (uint16_t)-1;\n    uint16_t av_len = (uint16_t)-1;\n    struct ntlm_buffer sh = { NULL, 0 };\n    struct ntlm_buffer cb = { NULL, 0 };\n    char *nb_computer = NULL;\n    char *nb_domain = NULL;\n    char *dns_computer = NULL;\n    char *dns_domain = NULL;\n    char *dns_tree = NULL;\n    char *av_target = NULL;\n    size_t data_offs = 0;\n    uint64_t timestamp = 0;\n    uint32_t flags = 0;\n    int ret = 0;\n\n    while (data_offs + 4 <= buffer->length) {\n        av_pair = (struct wire_av_pair *)&buffer->data[data_offs];\n        data_offs += 4;\n        av_id = le16toh(av_pair->av_id);\n        av_len = le16toh(av_pair->av_len);\n        if (av_len > buffer->length - data_offs) {\n            ret = ERR_DECODE;\n            goto done;\n        }\n        data_offs += av_len;\n\n        switch (av_id) {\n        case MSV_AV_CHANNEL_BINDINGS:\n            if (!av_cb) continue;\n            cb.data = av_pair->value;\n            cb.length = av_len;\n            break;\n        case MSV_AV_TARGET_NAME:\n            if (!av_target_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &av_target);\n            if (ret) goto done;\n            break;\n        case MSV_AV_SINGLE_HOST:\n            if (!av_single_host) continue;\n            sh.data = av_pair->value;\n            sh.length = av_len;\n            break;\n        case MSV_AV_TIMESTAMP:\n            if (!av_timestamp) continue;\n            memcpy(&timestamp, av_pair->value, sizeof(timestamp));\n            timestamp = le64toh(timestamp);\n            break;\n        case MSV_AV_FLAGS:\n            if (!av_flags) continue;\n            memcpy(&flags, av_pair->value, sizeof(flags));\n            flags = le32toh(flags);\n            break;\n        case MSV_AV_DNS_TREE_NAME:\n            if (!dns_tree_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_tree);\n            if (ret) goto done;\n            break;\n        case MSV_AV_DNS_DOMAIN_NAME:\n            if (!dns_domain_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_domain);\n            if (ret) goto done;\n            break;\n        case MSV_AV_DNS_COMPUTER_NAME:\n            if (!dns_computer_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_computer);\n            if (ret) goto done;\n            break;\n        case MSV_AV_NB_DOMAIN_NAME:\n            if (!nb_domain_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &nb_domain);\n            if (ret) goto done;\n            break;\n        case MSV_AV_NB_COMPUTER_NAME:\n            if (!nb_computer_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &nb_computer);\n            if (ret) goto done;\n            break;\n        default:\n            /* unknown av_pair, or EOL */\n            break;\n        }\n        if (av_id == MSV_AV_EOL) break;\n    }\n\n    if (av_id != MSV_AV_EOL || av_len != 0) {\n        ret = ERR_DECODE;\n    }\n\ndone:\n    if (ret) {\n        ntlm_free_buffer_data(&sh);\n        ntlm_free_buffer_data(&cb);\n        safefree(nb_computer);\n        safefree(nb_domain);\n        safefree(dns_computer);\n        safefree(dns_domain);\n        safefree(dns_tree);\n        safefree(av_target);\n    } else {\n        if (nb_computer_name) *nb_computer_name = nb_computer;\n        if (nb_domain_name) *nb_domain_name = nb_domain;\n        if (dns_computer_name) *dns_computer_name = dns_computer;\n        if (dns_domain_name) *dns_domain_name = dns_domain;\n        if (dns_tree_name) *dns_tree_name = dns_tree;\n        if (av_target_name) *av_target_name = av_target;\n        if (av_timestamp) *av_timestamp = timestamp;\n        if (av_single_host) *av_single_host = sh;\n        if (av_flags) *av_flags = flags;\n        if (av_cb) *av_cb = cb;\n    }\n    return ret;\n}",
        "func": "int ntlm_decode_target_info(struct ntlm_ctx *ctx, struct ntlm_buffer *buffer,\n                            char **nb_computer_name, char **nb_domain_name,\n                            char **dns_computer_name, char **dns_domain_name,\n                            char **dns_tree_name, char **av_target_name,\n                            uint32_t *av_flags, uint64_t *av_timestamp,\n                            struct ntlm_buffer *av_single_host,\n                            struct ntlm_buffer *av_cb)\n{\n    struct wire_av_pair *av_pair;\n    uint16_t av_id = (uint16_t)-1;\n    uint16_t av_len = (uint16_t)-1;\n    struct ntlm_buffer sh = { NULL, 0 };\n    struct ntlm_buffer cb = { NULL, 0 };\n    char *nb_computer = NULL;\n    char *nb_domain = NULL;\n    char *dns_computer = NULL;\n    char *dns_domain = NULL;\n    char *dns_tree = NULL;\n    char *av_target = NULL;\n    size_t data_offs = 0;\n    uint64_t timestamp = 0;\n    uint32_t flags = 0;\n    int ret = 0;\n\n    while (data_offs + 4 <= buffer->length) {\n        av_pair = (struct wire_av_pair *)&buffer->data[data_offs];\n        data_offs += 4;\n        av_id = le16toh(av_pair->av_id);\n        av_len = le16toh(av_pair->av_len);\n        if (av_len > buffer->length - data_offs) {\n            ret = ERR_DECODE;\n            goto done;\n        }\n        data_offs += av_len;\n\n        switch (av_id) {\n        case MSV_AV_CHANNEL_BINDINGS:\n            if (!av_cb) continue;\n            cb.data = av_pair->value;\n            cb.length = av_len;\n            break;\n        case MSV_AV_TARGET_NAME:\n            if (!av_target_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &av_target);\n            if (ret) goto done;\n            break;\n        case MSV_AV_SINGLE_HOST:\n            if (!av_single_host) continue;\n            sh.data = av_pair->value;\n            sh.length = av_len;\n            break;\n        case MSV_AV_TIMESTAMP:\n            if (!av_timestamp) continue;\n            memcpy(&timestamp, av_pair->value, sizeof(timestamp));\n            timestamp = le64toh(timestamp);\n            break;\n        case MSV_AV_FLAGS:\n            if (!av_flags) continue;\n            memcpy(&flags, av_pair->value, sizeof(flags));\n            flags = le32toh(flags);\n            break;\n        case MSV_AV_DNS_TREE_NAME:\n            if (!dns_tree_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_tree);\n            if (ret) goto done;\n            break;\n        case MSV_AV_DNS_DOMAIN_NAME:\n            if (!dns_domain_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_domain);\n            if (ret) goto done;\n            break;\n        case MSV_AV_DNS_COMPUTER_NAME:\n            if (!dns_computer_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &dns_computer);\n            if (ret) goto done;\n            break;\n        case MSV_AV_NB_DOMAIN_NAME:\n            if (!nb_domain_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &nb_domain);\n            if (ret) goto done;\n            break;\n        case MSV_AV_NB_COMPUTER_NAME:\n            if (!nb_computer_name) continue;\n            ret = ntlm_decode_av_pair_u16l_str(ctx, av_pair, &nb_computer);\n            if (ret) goto done;\n            break;\n        default:\n            /* unknown av_pair, or EOL */\n            break;\n        }\n        if (av_id == MSV_AV_EOL) break;\n    }\n\n    if (av_id != MSV_AV_EOL || av_len != 0) {\n        ret = ERR_DECODE;\n    }\n\ndone:\n    if (ret) {\n        safefree(nb_computer);\n        safefree(nb_domain);\n        safefree(dns_computer);\n        safefree(dns_domain);\n        safefree(dns_tree);\n        safefree(av_target);\n    } else {\n        if (nb_computer_name) *nb_computer_name = nb_computer;\n        if (nb_domain_name) *nb_domain_name = nb_domain;\n        if (dns_computer_name) *dns_computer_name = dns_computer;\n        if (dns_domain_name) *dns_domain_name = dns_domain;\n        if (dns_tree_name) *dns_tree_name = dns_tree;\n        if (av_target_name) *av_target_name = av_target;\n        if (av_timestamp) *av_timestamp = timestamp;\n        if (av_single_host) *av_single_host = sh;\n        if (av_flags) *av_flags = flags;\n        if (av_cb) *av_cb = cb;\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -97,8 +97,6 @@\n \n done:\n     if (ret) {\n-        ntlm_free_buffer_data(&sh);\n-        ntlm_free_buffer_data(&cb);\n         safefree(nb_computer);\n         safefree(nb_domain);\n         safefree(dns_computer);",
        "diff_line_info": {
            "deleted_lines": [
                "        ntlm_free_buffer_data(&sh);",
                "        ntlm_free_buffer_data(&cb);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2019-20170",
        "func_name": "gpac/ReadGF_IPMPX_MutualAuthentication",
        "description": "An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There is an invalid pointer dereference in the function GF_IPMPX_AUTH_Delete() in odf/ipmpx_code.c.",
        "git_url": "https://github.com/gpac/gpac/commit/16856430287cc10f495eb241910b4dc45b193e03",
        "commit_title": "fix ipmpx crash (#1328)",
        "commit_text": "",
        "func_before": "static GF_Err ReadGF_IPMPX_MutualAuthentication(GF_BitStream *bs, GF_IPMPX_Data *_p, u32 size)\n{\n\tGF_Err e;\n\tu32 i, count;\n\tBool requestNegotiation, successNegotiation, inclAuthenticationData, inclAuthCodes;\n\tGF_IPMPX_MutualAuthentication *p = (GF_IPMPX_MutualAuthentication *)_p;\n\n\trequestNegotiation = (Bool)gf_bs_read_int(bs, 1);\n\tsuccessNegotiation = (Bool)gf_bs_read_int(bs, 1);\n\tp->failedNegotiation =  (Bool)gf_bs_read_int(bs, 1);\n\tinclAuthenticationData = (Bool)gf_bs_read_int(bs, 1);\n\tinclAuthCodes = (Bool)gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 3);\n\n\tif (requestNegotiation) {\n\t\tcount = gf_bs_read_int(bs, 8);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_IPMPX_Authentication *auth;\n\t\t\te = GF_IPMPX_AUTH_Parse(bs, &auth);\n\t\t\tif (e) return e;\n\t\t\tgf_list_add(p->candidateAlgorithms, auth);\n\t\t}\n\t}\n\tif (successNegotiation) {\n\t\tcount = gf_bs_read_int(bs, 8);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_IPMPX_Authentication *auth;\n\t\t\te = GF_IPMPX_AUTH_Parse(bs, &auth);\n\t\t\tif (e) return e;\n\t\t\tgf_list_add(p->agreedAlgorithms, auth);\n\t\t}\n\t}\n\tif (inclAuthenticationData) p->AuthenticationData = GF_IPMPX_GetByteArray(bs);\n\tif (inclAuthCodes) {\n\t\t/*unspecified in spec, IM1 uses 8 bits*/\n\t\tu32 type = gf_bs_read_int(bs, 8);\n\t\tswitch (type) {\n\t\tcase 0x01:\n\t\t\tcount = gf_bs_read_int(bs, 8);\n\t\t\tp->certType = gf_bs_read_int(bs, 32);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_IPMPX_ByteArray *ipd = GF_IPMPX_GetByteArray(bs);\n\t\t\t\tif (ipd) gf_list_add(p->certificates, ipd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\te = GF_IPMPX_AUTH_Parse(bs, (GF_IPMPX_Authentication**) &p->publicKey);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\tcase 0xFE:\n\t\t\tp->opaque = GF_IPMPX_GetByteArray(bs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\te = gf_ipmpx_data_parse(bs, (GF_IPMPX_Data **) &p->trustData);\n\t\tif (e) return e;\n\t\tp->authCodes = GF_IPMPX_GetByteArray(bs);\n\t}\n\treturn GF_OK;\n}",
        "func": "static GF_Err ReadGF_IPMPX_MutualAuthentication(GF_BitStream *bs, GF_IPMPX_Data *_p, u32 size)\n{\n\tGF_Err e;\n\tu32 i, count;\n\tBool requestNegotiation, successNegotiation, inclAuthenticationData, inclAuthCodes;\n\tGF_IPMPX_MutualAuthentication *p = (GF_IPMPX_MutualAuthentication *)_p;\n\n\trequestNegotiation = (Bool)gf_bs_read_int(bs, 1);\n\tsuccessNegotiation = (Bool)gf_bs_read_int(bs, 1);\n\tp->failedNegotiation =  (Bool)gf_bs_read_int(bs, 1);\n\tinclAuthenticationData = (Bool)gf_bs_read_int(bs, 1);\n\tinclAuthCodes = (Bool)gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 3);\n\n\tif (requestNegotiation) {\n\t\tcount = gf_bs_read_int(bs, 8);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_IPMPX_Authentication *auth;\n\t\t\te = GF_IPMPX_AUTH_Parse(bs, &auth);\n\t\t\tif (e) return e;\n\t\t\tgf_list_add(p->candidateAlgorithms, auth);\n\t\t}\n\t}\n\tif (successNegotiation) {\n\t\tcount = gf_bs_read_int(bs, 8);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_IPMPX_Authentication *auth = NULL;\n\t\t\te = GF_IPMPX_AUTH_Parse(bs, &auth);\n\t\t\tif (e) return e;\n\t\t\tgf_list_add(p->agreedAlgorithms, auth);\n\t\t}\n\t}\n\tif (inclAuthenticationData) p->AuthenticationData = GF_IPMPX_GetByteArray(bs);\n\tif (inclAuthCodes) {\n\t\t/*unspecified in spec, IM1 uses 8 bits*/\n\t\tu32 type = gf_bs_read_int(bs, 8);\n\t\tswitch (type) {\n\t\tcase 0x01:\n\t\t\tcount = gf_bs_read_int(bs, 8);\n\t\t\tp->certType = gf_bs_read_int(bs, 32);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_IPMPX_ByteArray *ipd = GF_IPMPX_GetByteArray(bs);\n\t\t\t\tif (ipd) gf_list_add(p->certificates, ipd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\te = GF_IPMPX_AUTH_Parse(bs, (GF_IPMPX_Authentication**) &p->publicKey);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\tcase 0xFE:\n\t\t\tp->opaque = GF_IPMPX_GetByteArray(bs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\te = gf_ipmpx_data_parse(bs, (GF_IPMPX_Data **) &p->trustData);\n\t\tif (e) return e;\n\t\tp->authCodes = GF_IPMPX_GetByteArray(bs);\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n \tif (successNegotiation) {\n \t\tcount = gf_bs_read_int(bs, 8);\n \t\tfor (i=0; i<count; i++) {\n-\t\t\tGF_IPMPX_Authentication *auth;\n+\t\t\tGF_IPMPX_Authentication *auth = NULL;\n \t\t\te = GF_IPMPX_AUTH_Parse(bs, &auth);\n \t\t\tif (e) return e;\n \t\t\tgf_list_add(p->agreedAlgorithms, auth);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tGF_IPMPX_Authentication *auth;"
            ],
            "added_lines": [
                "\t\t\tGF_IPMPX_Authentication *auth = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48425",
        "func_name": "torvalds/linux/ntfs_read_mft",
        "description": "In the Linux kernel through 6.2.7, fs/ntfs3/inode.c has an invalid kfree because it does not validate MFT flags before replaying logs.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=467333af2f7b95eeaa61a5b5369a80063cd971fd",
        "commit_title": "Log load and replay is part of the metadata handle flow during mount",
        "commit_text": "operation. The $MFT record will be loaded and used while replaying logs. However, a malformed $MFT record, say, has RECORD_FLAG_DIR flag set and contains an ATTR_ROOT attribute will misguide kernel to treat it as a directory, and try to free the allocated resources when the corresponding inode is freed, which will cause an invalid kfree because the memory hasn't actually been allocated.  [  101.368647] BUG: KASAN: invalid-free in kvfree+0x2c/0x40 [  101.369457] [  101.369986] CPU: 0 PID: 198 Comm: mount Not tainted 6.0.0-rc7+ #5 [  101.370529] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 [  101.371362] Call Trace: [  101.371795]  <TASK> [  101.372157]  dump_stack_lvl+0x49/0x63 [  101.372658]  print_report.cold+0xf5/0x689 [  101.373022]  ? ni_write_inode+0x754/0xd90 [  101.373378]  ? kvfree+0x2c/0x40 [  101.373698]  kasan_report_invalid_free+0x77/0xf0 [  101.374058]  ? kvfree+0x2c/0x40 [  101.374352]  ? kvfree+0x2c/0x40 [  101.374668]  __kasan_slab_free+0x189/0x1b0 [  101.374992]  ? kvfree+0x2c/0x40 [  101.375271]  kfree+0x168/0x3b0 [  101.375717]  kvfree+0x2c/0x40 [  101.376002]  indx_clear+0x26/0x60 [  101.376316]  ni_clear+0xc5/0x290 [  101.376661]  ntfs_evict_inode+0x45/0x70 [  101.377001]  evict+0x199/0x280 [  101.377432]  iput.part.0+0x286/0x320 [  101.377819]  iput+0x32/0x50 [  101.378166]  ntfs_loadlog_and_replay+0x143/0x320 [  101.378656]  ? ntfs_bio_fill_1+0x510/0x510 [  101.378968]  ? iput.part.0+0x286/0x320 [  101.379367]  ntfs_fill_super+0xecb/0x1ba0 [  101.379729]  ? put_ntfs+0x1d0/0x1d0 [  101.380046]  ? vsprintf+0x20/0x20 [  101.380542]  ? mutex_unlock+0x81/0xd0 [  101.380914]  ? set_blocksize+0x95/0x150 [  101.381597]  get_tree_bdev+0x232/0x370 [  101.382254]  ? put_ntfs+0x1d0/0x1d0 [  101.382699]  ntfs_fs_get_tree+0x15/0x20 [  101.383094]  vfs_get_tree+0x4c/0x130 [  101.383675]  path_mount+0x654/0xfe0 [  101.384203]  ? putname+0x80/0xa0 [  101.384540]  ? finish_automount+0x2e0/0x2e0 [  101.384943]  ? putname+0x80/0xa0 [  101.385362]  ? kmem_cache_free+0x1c4/0x440 [  101.385968]  ? putname+0x80/0xa0 [  101.386666]  do_mount+0xd6/0xf0 [  101.387228]  ? path_mount+0xfe0/0xfe0 [  101.387585]  ? __kasan_check_write+0x14/0x20 [  101.387979]  __x64_sys_mount+0xca/0x110 [  101.388436]  do_syscall_64+0x3b/0x90 [  101.388757]  entry_SYSCALL_64_after_hwframe+0x63/0xcd [  101.389289] RIP: 0033:0x7fa0f70e948a [  101.390048] Code: 48 8b 0d 11 fa 2a 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 49 89 ca b8 a5 00 00 008 [  101.391297] RSP: 002b:00007ffc24fdecc8 EFLAGS: 00000202 ORIG_RAX: 00000000000000a5 [  101.391988] RAX: ffffffffffffffda RBX: 000055932c183060 RCX: 00007fa0f70e948a [  101.392494] RDX: 000055932c183260 RSI: 000055932c1832e0 RDI: 000055932c18bce0 [  101.393053] RBP: 0000000000000000 R08: 000055932c183280 R09: 0000000000000020 [  101.393577] R10: 00000000c0ed0000 R11: 0000000000000202 R12: 000055932c18bce0 [  101.394044] R13: 000055932c183260 R14: 0000000000000000 R15: 00000000ffffffff [  101.394747]  </TASK> [  101.395402] [  101.396047] Allocated by task 198: [  101.396724]  kasan_save_stack+0x26/0x50 [  101.397400]  __kasan_slab_alloc+0x6d/0x90 [  101.397974]  kmem_cache_alloc_lru+0x192/0x5a0 [  101.398524]  ntfs_alloc_inode+0x23/0x70 [  101.399137]  alloc_inode+0x3b/0xf0 [  101.399534]  iget5_locked+0x54/0xa0 [  101.400026]  ntfs_iget5+0xaf/0x1780 [  101.400414]  ntfs_loadlog_and_replay+0xe5/0x320 [  101.400883]  ntfs_fill_super+0xecb/0x1ba0 [  101.401313]  get_tree_bdev+0x232/0x370 [  101.401774]  ntfs_fs_get_tree+0x15/0x20 [  101.402224]  vfs_get_tree+0x4c/0x130 [  101.402673]  path_mount+0x654/0xfe0 [  101.403160]  do_mount+0xd6/0xf0 [  101.403537]  __x64_sys_mount+0xca/0x110 [  101.404058]  do_syscall_64+0x3b/0x90 [  101.404333]  entry_SYSCALL_64_after_hwframe+0x63/0xcd [  101.404816] [  101.405067] The buggy address belongs to the object at ffff888008cc9ea0 [  101.405067]  which belongs to the cache ntfs_inode_cache of size 992 [  101.406171] The buggy address is located 232 bytes inside of [  101.406171]  992-byte region [ffff888008cc9ea0, ffff888008cca280) [  101.406995] [  101.408559] The buggy address belongs to the physical page: [  101.409320] page:00000000dccf19dd refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x8cc8 [  101.410654] head:00000000dccf19dd order:2 compound_mapcount:0 compound_pincount:0 [  101.411533] flags: 0xfffffc0010200(slab|head|node=0|zone=1|lastcpupid=0x1fffff) [  101.412665] raw: 000fffffc0010200 0000000000000000 dead000000000122 ffff888003695140 [  101.413209] raw: 0000000000000000 00000000800e000e 00000001ffffffff 0000000000000000 [  101.413799] page dumped because: kasan: bad access detected [  101.414213] [  101.414427] Memory state around the buggy address: [  101.414991]  ffff888008cc9e80: fc fc fc fc 00 00 00 00 00 00 00 00 00 00 00 00 [  101.415785]  ffff888008cc9f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [  101.416933] >ffff888008cc9f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [  101.417857]                       ^ [  101.418566]  ffff888008cca000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 [  101.419704]  ffff888008cca080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ",
        "func_before": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tis_root = true;\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
        "func": "static struct inode *ntfs_read_mft(struct inode *inode,\n\t\t\t\t   const struct cpu_str *name,\n\t\t\t\t   const struct MFT_REF *ref)\n{\n\tint err = 0;\n\tstruct ntfs_inode *ni = ntfs_i(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ntfs_sb_info *sbi = sb->s_fs_info;\n\tmode_t mode = 0;\n\tstruct ATTR_STD_INFO5 *std5 = NULL;\n\tstruct ATTR_LIST_ENTRY *le;\n\tstruct ATTRIB *attr;\n\tbool is_match = false;\n\tbool is_root = false;\n\tbool is_dir;\n\tunsigned long ino = inode->i_ino;\n\tu32 rp_fa = 0, asize, t32;\n\tu16 roff, rsize, names = 0;\n\tconst struct ATTR_FILE_NAME *fname = NULL;\n\tconst struct INDEX_ROOT *root;\n\tstruct REPARSE_DATA_BUFFER rp; // 0x18 bytes\n\tu64 t64;\n\tstruct MFT_REC *rec;\n\tstruct runs_tree *run;\n\n\tinode->i_op = NULL;\n\t/* Setup 'uid' and 'gid' */\n\tinode->i_uid = sbi->options->fs_uid;\n\tinode->i_gid = sbi->options->fs_gid;\n\n\terr = mi_init(&ni->mi, sbi, ino);\n\tif (err)\n\t\tgoto out;\n\n\tif (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) {\n\t\tt64 = sbi->mft.lbo >> sbi->cluster_bits;\n\t\tt32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size);\n\t\tsbi->mft.ni = ni;\n\t\tinit_rwsem(&ni->file.run_lock);\n\n\t\tif (!run_add_entry(&ni->file.run, 0, t64, t32, true)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mi_read(&ni->mi, ino == MFT_REC_MFT);\n\n\tif (err)\n\t\tgoto out;\n\n\trec = ni->mi.mrec;\n\n\tif (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) {\n\t\t;\n\t} else if (ref->seq != rec->seq) {\n\t\terr = -EINVAL;\n\t\tntfs_err(sb, \"MFT: r=%lx, expect seq=%x instead of %x!\", ino,\n\t\t\t le16_to_cpu(ref->seq), le16_to_cpu(rec->seq));\n\t\tgoto out;\n\t} else if (!is_rec_inuse(rec)) {\n\t\terr = -ESTALE;\n\t\tntfs_err(sb, \"Inode r=%x is not in use!\", (u32)ino);\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(rec->total) != sbi->record_size) {\n\t\t/* Bad inode? */\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!is_rec_base(rec)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Record should contain $I30 root. */\n\tis_dir = rec->flags & RECORD_FLAG_DIR;\n\n\t/* MFT_REC_MFT is not a dir */\n\tif (is_dir && ino == MFT_REC_MFT) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tinode->i_generation = le16_to_cpu(rec->seq);\n\n\t/* Enumerate all struct Attributes MFT. */\n\tle = NULL;\n\tattr = NULL;\n\n\t/*\n\t * To reduce tab pressure use goto instead of\n\t * while( (attr = ni_enum_attr_ex(ni, attr, &le, NULL) ))\n\t */\nnext_attr:\n\trun = NULL;\n\terr = -EINVAL;\n\tattr = ni_enum_attr_ex(ni, attr, &le, NULL);\n\tif (!attr)\n\t\tgoto end_enum;\n\n\tif (le && le->vcn) {\n\t\t/* This is non primary attribute segment. Ignore if not MFT. */\n\t\tif (ino != MFT_REC_MFT || attr->type != ATTR_DATA)\n\t\t\tgoto next_attr;\n\n\t\trun = &ni->file.run;\n\t\tasize = le32_to_cpu(attr->size);\n\t\tgoto attr_unpack_run;\n\t}\n\n\troff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off);\n\trsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size);\n\tasize = le32_to_cpu(attr->size);\n\n\tif (le16_to_cpu(attr->name_off) + attr->name_len > asize)\n\t\tgoto out;\n\n\tif (attr->non_res) {\n\t\tt64 = le64_to_cpu(attr->nres.alloc_size);\n\t\tif (le64_to_cpu(attr->nres.data_size) > t64 ||\n\t\t    le64_to_cpu(attr->nres.valid_size) > t64)\n\t\t\tgoto out;\n\t}\n\n\tswitch (attr->type) {\n\tcase ATTR_STD:\n\t\tif (attr->non_res ||\n\t\t    asize < sizeof(struct ATTR_STD_INFO) + roff ||\n\t\t    rsize < sizeof(struct ATTR_STD_INFO))\n\t\t\tgoto out;\n\n\t\tif (std5)\n\t\t\tgoto next_attr;\n\n\t\tstd5 = Add2Ptr(attr, roff);\n\n#ifdef STATX_BTIME\n\t\tnt2kernel(std5->cr_time, &ni->i_crtime);\n#endif\n\t\tnt2kernel(std5->a_time, &inode->i_atime);\n\t\tnt2kernel(std5->c_time, &inode->i_ctime);\n\t\tnt2kernel(std5->m_time, &inode->i_mtime);\n\n\t\tni->std_fa = std5->fa;\n\n\t\tif (asize >= sizeof(struct ATTR_STD_INFO5) + roff &&\n\t\t    rsize >= sizeof(struct ATTR_STD_INFO5))\n\t\t\tni->std_security_id = std5->security_id;\n\t\tgoto next_attr;\n\n\tcase ATTR_LIST:\n\t\tif (attr->name_len || le || ino == MFT_REC_LOG)\n\t\t\tgoto out;\n\n\t\terr = ntfs_load_attr_list(ni, attr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tle = NULL;\n\t\tattr = NULL;\n\t\tgoto next_attr;\n\n\tcase ATTR_NAME:\n\t\tif (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff ||\n\t\t    rsize < SIZEOF_ATTRIBUTE_FILENAME)\n\t\t\tgoto out;\n\n\t\tfname = Add2Ptr(attr, roff);\n\t\tif (fname->type == FILE_NAME_DOS)\n\t\t\tgoto next_attr;\n\n\t\tnames += 1;\n\t\tif (name && name->len == fname->name_len &&\n\t\t    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,\n\t\t\t\t\tNULL, false))\n\t\t\tis_match = true;\n\n\t\tgoto next_attr;\n\n\tcase ATTR_DATA:\n\t\tif (is_dir) {\n\t\t\t/* Ignore data attribute in dir record. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (ino == MFT_REC_BADCLUST && !attr->non_res)\n\t\t\tgoto next_attr;\n\n\t\tif (attr->name_len &&\n\t\t    ((ino != MFT_REC_BADCLUST || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(BAD_NAME) ||\n\t\t      memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) &&\n\t\t     (ino != MFT_REC_SECURE || !attr->non_res ||\n\t\t      attr->name_len != ARRAY_SIZE(SDS_NAME) ||\n\t\t      memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) {\n\t\t\t/* File contains stream attribute. Ignore it. */\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tif (is_attr_sparsed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE;\n\n\t\tif (is_attr_compressed(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_COMPRESSED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED;\n\n\t\tif (is_attr_encrypted(attr))\n\t\t\tni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED;\n\t\telse\n\t\t\tni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED;\n\n\t\tif (!attr->non_res) {\n\t\t\tni->i_valid = inode->i_size = rsize;\n\t\t\tinode_set_bytes(inode, rsize);\n\t\t}\n\n\t\tmode = S_IFREG | (0777 & sbi->options->fs_fmask_inv);\n\n\t\tif (!attr->non_res) {\n\t\t\tni->ni_flags |= NI_FLAG_RESIDENT;\n\t\t\tgoto next_attr;\n\t\t}\n\n\t\tinode_set_bytes(inode, attr_ondisk_size(attr));\n\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tif (!attr->nres.alloc_size)\n\t\t\tgoto next_attr;\n\n\t\trun = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run\n\t\t\t\t\t    : &ni->file.run;\n\t\tbreak;\n\n\tcase ATTR_ROOT:\n\t\tif (attr->non_res)\n\t\t\tgoto out;\n\n\t\troot = Add2Ptr(attr, roff);\n\n\t\tif (attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tif (root->type != ATTR_NAME ||\n\t\t    root->rule != NTFS_COLLATION_TYPE_FILENAME)\n\t\t\tgoto out;\n\n\t\tif (!is_dir)\n\t\t\tgoto next_attr;\n\n\t\tis_root = true;\n\t\tni->ni_flags |= NI_FLAG_DIR;\n\n\t\terr = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmode = sb->s_root\n\t\t\t       ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv))\n\t\t\t       : (S_IFDIR | 0777);\n\t\tgoto next_attr;\n\n\tcase ATTR_ALLOC:\n\t\tif (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) ||\n\t\t    memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)))\n\t\t\tgoto next_attr;\n\n\t\tinode->i_size = le64_to_cpu(attr->nres.data_size);\n\t\tni->i_valid = le64_to_cpu(attr->nres.valid_size);\n\t\tinode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size));\n\n\t\trun = &ni->dir.alloc_run;\n\t\tbreak;\n\n\tcase ATTR_BITMAP:\n\t\tif (ino == MFT_REC_MFT) {\n\t\t\tif (!attr->non_res)\n\t\t\t\tgoto out;\n#ifndef CONFIG_NTFS3_64BIT_CLUSTER\n\t\t\t/* 0x20000000 = 2^32 / 8 */\n\t\t\tif (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000)\n\t\t\t\tgoto out;\n#endif\n\t\t\trun = &sbi->mft.bitmap.run;\n\t\t\tbreak;\n\t\t} else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) &&\n\t\t\t   !memcmp(attr_name(attr), I30_NAME,\n\t\t\t\t   sizeof(I30_NAME)) &&\n\t\t\t   attr->non_res) {\n\t\t\trun = &ni->dir.bitmap_run;\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_REPARSE:\n\t\tif (attr->name_len)\n\t\t\tgoto next_attr;\n\n\t\trp_fa = ni_parse_reparse(ni, attr, &rp);\n\t\tswitch (rp_fa) {\n\t\tcase REPARSE_LINK:\n\t\t\t/*\n\t\t\t * Normal symlink.\n\t\t\t * Assume one unicode symbol == one utf8.\n\t\t\t */\n\t\t\tinode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer\n\t\t\t\t\t\t\t    .PrintNameLength) /\n\t\t\t\t\tsizeof(u16);\n\n\t\t\tni->i_valid = inode->i_size;\n\n\t\t\t/* Clear directory bit. */\n\t\t\tif (ni->ni_flags & NI_FLAG_DIR) {\n\t\t\t\tindx_clear(&ni->dir);\n\t\t\t\tmemset(&ni->dir, 0, sizeof(ni->dir));\n\t\t\t\tni->ni_flags &= ~NI_FLAG_DIR;\n\t\t\t} else {\n\t\t\t\trun_close(&ni->file.run);\n\t\t\t}\n\t\t\tmode = S_IFLNK | 0777;\n\t\t\tis_dir = false;\n\t\t\tif (attr->non_res) {\n\t\t\t\trun = &ni->file.run;\n\t\t\t\tgoto attr_unpack_run; // Double break.\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase REPARSE_COMPRESSED:\n\t\t\tbreak;\n\n\t\tcase REPARSE_DEDUPLICATED:\n\t\t\tbreak;\n\t\t}\n\t\tgoto next_attr;\n\n\tcase ATTR_EA_INFO:\n\t\tif (!attr->name_len &&\n\t\t    resident_data_ex(attr, sizeof(struct EA_INFO))) {\n\t\t\tni->ni_flags |= NI_FLAG_EA;\n\t\t\t/*\n\t\t\t * ntfs_get_wsl_perm updates inode->i_uid, inode->i_gid, inode->i_mode\n\t\t\t */\n\t\t\tinode->i_mode = mode;\n\t\t\tntfs_get_wsl_perm(inode);\n\t\t\tmode = inode->i_mode;\n\t\t}\n\t\tgoto next_attr;\n\n\tdefault:\n\t\tgoto next_attr;\n\t}\n\nattr_unpack_run:\n\troff = le16_to_cpu(attr->nres.run_off);\n\n\tif (roff > asize) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tt64 = le64_to_cpu(attr->nres.svcn);\n\n\terr = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn),\n\t\t\t    t64, Add2Ptr(attr, roff), asize - roff);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tgoto next_attr;\n\nend_enum:\n\n\tif (!std5)\n\t\tgoto out;\n\n\tif (!is_match && name) {\n\t\t/* Reuse rec as buffer for ascii name. */\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (std5->fa & FILE_ATTRIBUTE_READONLY)\n\t\tmode &= ~0222;\n\n\tif (!names) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (names != le16_to_cpu(rec->hard_links)) {\n\t\t/* Correct minor error on the fly. Do not mark inode as dirty. */\n\t\trec->hard_links = cpu_to_le16(names);\n\t\tni->mi.dirty = true;\n\t}\n\n\tset_nlink(inode, names);\n\n\tif (S_ISDIR(mode)) {\n\t\tni->std_fa |= FILE_ATTRIBUTE_DIRECTORY;\n\n\t\t/*\n\t\t * Dot and dot-dot should be included in count but was not\n\t\t * included in enumeration.\n\t\t * Usually a hard links to directories are disabled.\n\t\t */\n\t\tinode->i_op = &ntfs_dir_inode_operations;\n\t\tinode->i_fop = &ntfs_dir_operations;\n\t\tni->i_valid = 0;\n\t} else if (S_ISLNK(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_link_inode_operations;\n\t\tinode->i_fop = NULL;\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISREG(mode)) {\n\t\tni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t\tinode->i_fop = &ntfs_file_operations;\n\t\tinode->i_mapping->a_ops =\n\t\t\tis_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops;\n\t\tif (ino != MFT_REC_MFT)\n\t\t\tinit_rwsem(&ni->file.run_lock);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) ||\n\t\t   S_ISSOCK(mode)) {\n\t\tinode->i_op = &ntfs_special_inode_operations;\n\t\tinit_special_inode(inode, mode, inode->i_rdev);\n\t} else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) &&\n\t\t   fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) {\n\t\t/* Records in $Extend are not a files or general directories. */\n\t\tinode->i_op = &ntfs_file_inode_operations;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((sbi->options->sys_immutable &&\n\t     (std5->fa & FILE_ATTRIBUTE_SYSTEM)) &&\n\t    !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) {\n\t\tinode->i_flags |= S_IMMUTABLE;\n\t} else {\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tinode->i_mode = mode;\n\tif (!(ni->ni_flags & NI_FLAG_EA)) {\n\t\t/* If no xattr then no security (stored in xattr). */\n\t\tinode->i_flags |= S_NOSEC;\n\t}\n\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tunlock_new_inode(inode);\n\n\treturn inode;\n\nout:\n\tif (ino == MFT_REC_MFT && !sb->s_root)\n\t\tsbi->mft.ni = NULL;\n\n\tiget_failed(inode);\n\treturn ERR_PTR(err);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,12 @@\n \n \t/* Record should contain $I30 root. */\n \tis_dir = rec->flags & RECORD_FLAG_DIR;\n+\n+\t/* MFT_REC_MFT is not a dir */\n+\tif (is_dir && ino == MFT_REC_MFT) {\n+\t\terr = -EINVAL;\n+\t\tgoto out;\n+\t}\n \n \tinode->i_generation = le16_to_cpu(rec->seq);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t/* MFT_REC_MFT is not a dir */",
                "\tif (is_dir && ino == MFT_REC_MFT) {",
                "\t\terr = -EINVAL;",
                "\t\tgoto out;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11930",
        "func_name": "facebook/hhvm/php_mb_parse_encoding",
        "description": "An invalid free in mb_detect_order can cause the application to crash or potentially result in remote code execution. This issue affects HHVM versions prior to 3.30.12, all versions between 4.0.0 and 4.8.5, all versions between 4.9.0 and 4.23.1, as well as 4.24.0, 4.25.0, 4.26.0, 4.27.0, 4.28.0, and 4.28.1.",
        "git_url": "https://github.com/facebook/hhvm/commit/524d2e60cfe910406ec6109e4286d7edd545ab36",
        "commit_title": "ext_mbstring: Fix invalid free() in php_mb_parse_encoding",
        "commit_text": " Summary: A chunk of memory allocated by 'req::calloc_noptrs' was being freed by 'free'. The former internally calls 'calloc' and returns a pointer at an index sizeof(MallocNode) inside the allocated buffer. This led to freeing invalid memory.  CVE-2019-11930  Reviewed By: jjergus  Differential Revision: D18179908  fbshipit-source-id: 0e3fe77628e0b9dee8361e712b8abac59ae5ed22",
        "func_before": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}",
        "func": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      req::free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n   }\n   if (!ret) {\n     if (return_list && *return_list) {\n-      free(*return_list);\n+      req::free(*return_list);\n       *return_list = nullptr;\n     }\n     return_size = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "      free(*return_list);"
            ],
            "added_lines": [
                "      req::free(*return_list);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28941",
        "func_name": "torvalds/linux/spk_ttyio_ldisc_open",
        "description": "An issue was discovered in drivers/accessibility/speakup/spk_ttyio.c in the Linux kernel through 5.9.9. Local attackers on systems with the speakup driver could cause a local denial of service attack, aka CID-d41227544427. This occurs because of an invalid free when the line discipline is used more than once.",
        "git_url": "https://github.com/torvalds/linux/commit/d4122754442799187d5d537a9c039a49a67e57f1",
        "commit_title": "speakup: Do not let the line discipline be used several times",
        "commit_text": " Speakup has only one speakup_tty variable to store the tty it is managing. This makes sense since its codebase currently assumes that there is only one user who controls the screen reading.  That however means that we have to forbid using the line discipline several times, otherwise the second closure would try to free a NULL ldisc_data, leading to  general protection fault: 0000 [#1] SMP KASAN PTI RIP: 0010:spk_ttyio_ldisc_close+0x2c/0x60 Call Trace:  tty_ldisc_release+0xa2/0x340  tty_release_struct+0x17/0xd0  tty_release+0x9d9/0xcc0  __fput+0x231/0x740  task_work_run+0x12c/0x1a0  do_exit+0x9b5/0x2230  ? release_task+0x1240/0x1240  ? __do_page_fault+0x562/0xa30  do_group_exit+0xd5/0x2a0  __x64_sys_exit_group+0x35/0x40  do_syscall_64+0x89/0x2b0  ? page_fault+0x8/0x30  entry_SYSCALL_64_after_hwframe+0x44/0xa9  Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20201110183541.fzgnlwhjpgqzjeth@function",
        "func_before": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\n\treturn 0;\n}",
        "func": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&speakup_tty_mutex);\n\tif (speakup_tty) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -EBUSY;\n\t}\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data) {\n\t\tspeakup_tty = NULL;\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\tmutex_unlock(&speakup_tty_mutex);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,15 +4,25 @@\n \n \tif (!tty->ops->write)\n \t\treturn -EOPNOTSUPP;\n+\n+\tmutex_lock(&speakup_tty_mutex);\n+\tif (speakup_tty) {\n+\t\tmutex_unlock(&speakup_tty_mutex);\n+\t\treturn -EBUSY;\n+\t}\n \tspeakup_tty = tty;\n \n \tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n-\tif (!ldisc_data)\n+\tif (!ldisc_data) {\n+\t\tspeakup_tty = NULL;\n+\t\tmutex_unlock(&speakup_tty_mutex);\n \t\treturn -ENOMEM;\n+\t}\n \n \tinit_completion(&ldisc_data->completion);\n \tldisc_data->buf_free = true;\n \tspeakup_tty->disc_data = ldisc_data;\n+\tmutex_unlock(&speakup_tty_mutex);\n \n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!ldisc_data)"
            ],
            "added_lines": [
                "",
                "\tmutex_lock(&speakup_tty_mutex);",
                "\tif (speakup_tty) {",
                "\t\tmutex_unlock(&speakup_tty_mutex);",
                "\t\treturn -EBUSY;",
                "\t}",
                "\tif (!ldisc_data) {",
                "\t\tspeakup_tty = NULL;",
                "\t\tmutex_unlock(&speakup_tty_mutex);",
                "\t}",
                "\tmutex_unlock(&speakup_tty_mutex);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21401",
        "func_name": "nanopb/pb_release_union_field",
        "description": "Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds.",
        "git_url": "https://github.com/nanopb/nanopb/commit/e2f0ccf939d9f82931d085acb6df8e9a182a4261",
        "commit_title": "Fix invalid free() with oneof (#647)",
        "commit_text": " Nanopb would call free() or realloc() on an invalid (attacker controlled) pointer value when all the following conditions are true:  - PB_ENABLE_MALLOC is defined at the compile time - Message definition contains an oneof field, and the oneof   contains at least one pointer type field and at least one   non-pointer type field. - Data being decoded first contains a non-pointer value for   the oneof field, and later contains an overwriting pointer   value.  Depending on message layout, the bug may not be exploitable in all cases, but it is known to be exploitable at least with string and bytes fields. Actual security impact will also depend on the heap implementation used.",
        "func_before": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; /* Previous which_ value */\n    pb_size_t new_tag = field->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n\n    pb_release_single_field(&old_field);\n\n    return true;\n}",
        "func": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; /* Previous which_ value */\n    pb_size_t new_tag = field->tag; /* New which_ value */\n\n    if (old_tag == 0)\n        return true; /* Ok, no old data in union */\n\n    if (old_tag == new_tag)\n        return true; /* Ok, old data is of same type => merge */\n\n    /* Release old data. The find can fail if the message struct contains\n     * invalid data. */\n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n\n    pb_release_single_field(&old_field);\n\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        /* Initialize the pointer to NULL to make sure it is valid\n         * even in case of error return. */\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,5 +17,13 @@\n \n     pb_release_single_field(&old_field);\n \n+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n+    {\n+        /* Initialize the pointer to NULL to make sure it is valid\n+         * even in case of error return. */\n+        *(void**)field->pField = NULL;\n+        field->pData = NULL;\n+    }\n+\n     return true;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)",
                "    {",
                "        /* Initialize the pointer to NULL to make sure it is valid",
                "         * even in case of error return. */",
                "        *(void**)field->pField = NULL;",
                "        field->pData = NULL;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-24028",
        "func_name": "facebook/fbthrift/write",
        "description": "An invalid free in Thrift's table-based serialization can cause the application to crash or potentially result in code execution or other undesirable effects. This issue affects Facebook Thrift prior to v2021.02.22.00.",
        "git_url": "https://github.com/facebook/fbthrift/commit/bfda1efa547dce11a38592820916db01b05b9339",
        "commit_title": "Fix handling of invalid union data in table-based serializer",
        "commit_text": " Summary: Fix handling of invalid union data in the table-based serializer. Previously if the input contained duplicate union data, previous active member of the union was overwritten without calling the destructor of the old object, potentially causing a memory leak. In addition to that, if the second piece of data was incomplete the wrong destructor would be called during stack unwinding causing a segfault, data corruption or other undesirable effects.  Fix the issue by clearing the union if there is an active member.  Also fix the type of the data member that holds the active field id (it's `int`, not `FieldID`).  Reviewed By: yfeldblum  Differential Revision: D26440248  fbshipit-source-id: fae9ab96566cf07e14dabe9663b2beb680a01bb4",
        "func_before": "size_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}",
        "func": "size_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& activeId = getActiveId(object, structInfo);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        activeId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == activeId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,14 +4,13 @@\n   size_t written = iprot->writeStructBegin(structInfo.name);\n   if (UNLIKELY(structInfo.unionExt != nullptr)) {\n     const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n-    const auto& unionId =\n-        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n+    const auto& activeId = getActiveId(object, structInfo);\n     const FieldInfo* found = std::lower_bound(\n         structInfo.fieldInfos,\n         end,\n-        unionId,\n+        activeId,\n         [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n-    if (found < end && found->id == unionId) {\n+    if (found < end && found->id == activeId) {\n       const OptionalThriftValue value = getValue(*found->typeInfo, object);\n       if (value.hasValue()) {\n         written += writeField(iprot, *found, value.value());",
        "diff_line_info": {
            "deleted_lines": [
                "    const auto& unionId =",
                "        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);",
                "        unionId,",
                "    if (found < end && found->id == unionId) {"
            ],
            "added_lines": [
                "    const auto& activeId = getActiveId(object, structInfo);",
                "        activeId,",
                "    if (found < end && found->id == activeId) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-24028",
        "func_name": "facebook/fbthrift/read",
        "description": "An invalid free in Thrift's table-based serialization can cause the application to crash or potentially result in code execution or other undesirable effects. This issue affects Facebook Thrift prior to v2021.02.22.00.",
        "git_url": "https://github.com/facebook/fbthrift/commit/bfda1efa547dce11a38592820916db01b05b9339",
        "commit_title": "Fix handling of invalid union data in table-based serializer",
        "commit_text": " Summary: Fix handling of invalid union data in the table-based serializer. Previously if the input contained duplicate union data, previous active member of the union was overwritten without calling the destructor of the old object, potentially causing a memory leak. In addition to that, if the second piece of data was incomplete the wrong destructor would be called during stack unwinding causing a segfault, data corruption or other undesirable effects.  Fix the issue by clearing the union if there is an active member.  Also fix the type of the data member that holds the active field id (it's `int`, not `FieldID`).  Reviewed By: yfeldblum  Differential Revision: D26440248  fbshipit-source-id: fae9ab96566cf07e14dabe9663b2beb680a01bb4",
        "func_before": "void read(Protocol_* iprot, const StructInfo& structInfo, void* object) {\n  DCHECK(object);\n  ProtocolReaderStructReadState<Protocol_> readState;\n  readState.readStructBegin(iprot);\n\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n    // Found it.\n    if (fieldInfo) {\n      void* unionVal = getMember(*fieldInfo, object);\n      // Default construct and placement new into the member union.\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n          unionVal);\n      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n      const_cast<FieldID&>(activeUnionMemberId(\n          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;\n  }\n\n  // Define out of loop to call advanceToNextField after the loop ends.\n  FieldID prevFieldId = 0;\n\n  // The index of the expected field in the struct layout.\n  std::int16_t index = 0;\n\n  // Every time advanceToNextField reports a field mismatch, either because the\n  // field is missing or if the serialized fields are not sorted (protocols\n  // don't guarantee a specific field order), we search for the field info\n  // matching the read bytes. Then we resume from the one past the found field\n  // to reduce the number of scans we have to do if the fields are sorted which\n  // is a common case. When we increment index past the number of fields we\n  // utilize the same search logic with a field info of type TType::T_STOP.\n  for (;; ++index) {\n    auto* fieldInfo = index < structInfo.numFields\n        ? &structInfo.fieldInfos[index]\n        : &kStopMarker;\n    // Try to match the next field in order against the current bytes.\n    if (UNLIKELY(!readState.advanceToNextField(\n            iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {\n      // Loop to skip until we find a match for both field id/name and type.\n      for (;;) {\n        readState.afterAdvanceFailure(iprot);\n        if (readState.atStop()) {\n          // Already at stop, return immediately.\n          readState.readStructEnd(iprot);\n          return;\n        }\n        fieldInfo = findFieldInfo(iprot, readState, structInfo);\n        // Found it.\n        if (fieldInfo) {\n          // Set the index to the field next in order to the found field.\n          index = fieldInfo - structInfo.fieldInfos;\n          break;\n        }\n        skip(iprot, readState);\n      }\n    } else if (UNLIKELY(index >= structInfo.numFields)) {\n      // We are at stop and have tried all of the fields, so return.\n      readState.readStructEnd(iprot);\n      return;\n    }\n    // Id and type are what we expect, try read.\n    prevFieldId = fieldInfo->id;\n    read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));\n    if (fieldInfo->issetOffset > 0) {\n      const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;\n    }\n  }\n}",
        "func": "void read(Protocol_* iprot, const StructInfo& structInfo, void* object) {\n  DCHECK(object);\n  ProtocolReaderStructReadState<Protocol_> readState;\n  readState.readStructBegin(iprot);\n\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    if (const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo)) {\n      auto& activeId = const_cast<int&>(getActiveId(object, structInfo));\n      if (activeId != 0) {\n        structInfo.unionExt->clear(object);\n      }\n      void* value = getMember(*fieldInfo, object);\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](value);\n      read(iprot, *fieldInfo->typeInfo, readState, value);\n      activeId = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;\n  }\n\n  // Define out of loop to call advanceToNextField after the loop ends.\n  FieldID prevFieldId = 0;\n\n  // The index of the expected field in the struct layout.\n  std::int16_t index = 0;\n\n  // Every time advanceToNextField reports a field mismatch, either because the\n  // field is missing or if the serialized fields are not sorted (protocols\n  // don't guarantee a specific field order), we search for the field info\n  // matching the read bytes. Then we resume from the one past the found field\n  // to reduce the number of scans we have to do if the fields are sorted which\n  // is a common case. When we increment index past the number of fields we\n  // utilize the same search logic with a field info of type TType::T_STOP.\n  for (;; ++index) {\n    auto* fieldInfo = index < structInfo.numFields\n        ? &structInfo.fieldInfos[index]\n        : &kStopMarker;\n    // Try to match the next field in order against the current bytes.\n    if (UNLIKELY(!readState.advanceToNextField(\n            iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {\n      // Loop to skip until we find a match for both field id/name and type.\n      for (;;) {\n        readState.afterAdvanceFailure(iprot);\n        if (readState.atStop()) {\n          // Already at stop, return immediately.\n          readState.readStructEnd(iprot);\n          return;\n        }\n        fieldInfo = findFieldInfo(iprot, readState, structInfo);\n        // Found it.\n        if (fieldInfo) {\n          // Set the index to the field next in order to the found field.\n          index = fieldInfo - structInfo.fieldInfos;\n          break;\n        }\n        skip(iprot, readState);\n      }\n    } else if (UNLIKELY(index >= structInfo.numFields)) {\n      // We are at stop and have tried all of the fields, so return.\n      readState.readStructEnd(iprot);\n      return;\n    }\n    // Id and type are what we expect, try read.\n    prevFieldId = fieldInfo->id;\n    read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));\n    if (fieldInfo->issetOffset > 0) {\n      const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,16 +11,15 @@\n       readState.readStructEnd(iprot);\n       return;\n     }\n-    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n-    // Found it.\n-    if (fieldInfo) {\n-      void* unionVal = getMember(*fieldInfo, object);\n-      // Default construct and placement new into the member union.\n-      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n-          unionVal);\n-      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n-      const_cast<FieldID&>(activeUnionMemberId(\n-          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n+    if (const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo)) {\n+      auto& activeId = const_cast<int&>(getActiveId(object, structInfo));\n+      if (activeId != 0) {\n+        structInfo.unionExt->clear(object);\n+      }\n+      void* value = getMember(*fieldInfo, object);\n+      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](value);\n+      read(iprot, *fieldInfo->typeInfo, readState, value);\n+      activeId = fieldInfo->id;\n     } else {\n       skip(iprot, readState);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);",
                "    // Found it.",
                "    if (fieldInfo) {",
                "      void* unionVal = getMember(*fieldInfo, object);",
                "      // Default construct and placement new into the member union.",
                "      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](",
                "          unionVal);",
                "      read(iprot, *fieldInfo->typeInfo, readState, unionVal);",
                "      const_cast<FieldID&>(activeUnionMemberId(",
                "          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;"
            ],
            "added_lines": [
                "    if (const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo)) {",
                "      auto& activeId = const_cast<int&>(getActiveId(object, structInfo));",
                "      if (activeId != 0) {",
                "        structInfo.unionExt->clear(object);",
                "      }",
                "      void* value = getMember(*fieldInfo, object);",
                "      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](value);",
                "      read(iprot, *fieldInfo->typeInfo, readState, value);",
                "      activeId = fieldInfo->id;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11105",
        "func_name": "USCiLab/cereal/CEREAL_SAVE_FUNCTION_NAME",
        "description": "An issue was discovered in USC iLab cereal through 1.3.0. It employs caching of std::shared_ptr values, using the raw pointer address as a unique identifier. This becomes problematic if an std::shared_ptr variable goes out of scope and is freed, and a new std::shared_ptr is allocated at the same address. Serialization fidelity thereby becomes dependent upon memory layout. In short, serialized std::shared_ptr variables cannot always be expected to serialize back into their original values. This can have any number of consequences, depending on the context within which this manifests.",
        "git_url": "https://github.com/USCiLab/cereal/commit/3e8b9cab82dc4a596dc3bcfe7437946395ad782b",
        "commit_title": "Store a copy of each serialized shared_ptr within the archive to prevent the shared_ptr to be freed to early.",
        "commit_text": " The archives use the memory address pointed by the shared_ptr as a unique id which must not be reused during lifetime of the archive. Therefore, the archives stores a copy of it. This problem was also reported as CVE-2020-11105.",
        "func_before": "inline\n  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::shared_ptr<T> const &> const & wrapper )\n  {\n    auto & ptr = wrapper.ptr;\n\n    uint32_t id = ar.registerSharedPointer( ptr.get() );\n    ar( CEREAL_NVP_(\"id\", id) );\n\n    if( id & detail::msb_32bit )\n    {\n      ar( CEREAL_NVP_(\"data\", *ptr) );\n    }\n  }",
        "func": "inline\n  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::shared_ptr<T> const &> const & wrapper )\n  {\n    auto & ptr = wrapper.ptr;\n\n    uint32_t id = ar.registerSharedPointer( ptr );\n    ar( CEREAL_NVP_(\"id\", id) );\n\n    if( id & detail::msb_32bit )\n    {\n      ar( CEREAL_NVP_(\"data\", *ptr) );\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n   {\n     auto & ptr = wrapper.ptr;\n \n-    uint32_t id = ar.registerSharedPointer( ptr.get() );\n+    uint32_t id = ar.registerSharedPointer( ptr );\n     ar( CEREAL_NVP_(\"id\", id) );\n \n     if( id & detail::msb_32bit )",
        "diff_line_info": {
            "deleted_lines": [
                "    uint32_t id = ar.registerSharedPointer( ptr.get() );"
            ],
            "added_lines": [
                "    uint32_t id = ar.registerSharedPointer( ptr );"
            ]
        }
    }
]