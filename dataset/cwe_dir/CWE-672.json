[
    {
        "cve_id": "CVE-2020-25221",
        "func_name": "torvalds/linux/get_gate_page",
        "description": "get_gate_page in mm/gup.c in the Linux kernel 5.7.x and 5.8.x before 5.8.7 allows privilege escalation because of incorrect reference counting (caused by gate page mishandling) of the struct page that backs the vsyscall page. The result is a refcount underflow. This can be triggered by any 64-bit process that can use ptrace() or process_vm_readv(), aka CID-9fa2dd946743.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=9fa2dd946743ae6f30dc4830da19147bf100a7f2",
        "commit_title": "Gate pages were missed when converting from get to pin_user_pages().",
        "commit_text": "This can lead to refcount imbalances.  This is reliably and quickly reproducible running the x86 selftests when vsyscall=emulate is enabled (the default).  Fix by using try_grab_page() with appropriate flags passed.  The long story:  Today, pin_user_pages() and get_user_pages() are similar interfaces for manipulating page reference counts.  However, \"pins\" use a \"bias\" value and manipulate the actual reference count by 1024 instead of 1 used by plain \"gets\".  That means that pin_user_pages() must be matched with unpin_user_pages() and can't be mixed with a plain put_user_pages() or put_page().  Enter gate pages, like the vsyscall page.  They are pages usually in the kernel image, but which are mapped to userspace.  Userspace is allowed access to them, including interfaces using get/pin_user_pages().  The refcount of these kernel pages is manipulated just like a normal user page on the get/pin side so that the put/unpin side can work the same for normal user pages or gate pages.  get_gate_page() uses try_get_page() which only bumps the refcount by 1, not 1024, even if called in the pin_user_pages() path.  If someone pins a gate page, this happens:  \tpin_user_pages() \t\tget_gate_page() \t\t\ttry_get_page() // bump refcount +1 \t... some time later \tunpin_user_pages() \t\tpage_ref_sub_and_test(page, 1024))  ... and boom, we get a refcount off by 1023.  This is reliably and quickly reproducible running the x86 selftests when booted with vsyscall=emulate (the default).  The selftests use ptrace(), but I suspect anything using pin_user_pages() on gate pages could hit this.  To fix it, simply use try_grab_page() instead of try_get_page(), and pass 'gup_flags' in so that FOLL_PIN can be respected.  This bug traces back to the very beginning of the FOLL_PIN support in commit 3faa52c03f44 (\"mm/gup: track FOLL_PIN pages\"), which showed up in the 5.7 release.  Cc: x86@kernel.org Cc: Jann Horn <jannh@google.com> Cc: Andrew Morton <akpm@linux-foundation.org> Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com> ",
        "func_before": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tif (pgd_none(*pgd))\n\t\treturn -EFAULT;\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d))\n\t\treturn -EFAULT;\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud))\n\t\treturn -EFAULT;\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t}\n\tif (unlikely(!try_get_page(*page))) {\n\t\tret = -ENOMEM;\n\t\tgoto unmap;\n\t}\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}",
        "func": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tif (pgd_none(*pgd))\n\t\treturn -EFAULT;\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d))\n\t\treturn -EFAULT;\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud))\n\t\treturn -EFAULT;\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t}\n\tif (unlikely(!try_grab_page(*page, gup_flags))) {\n\t\tret = -ENOMEM;\n\t\tgoto unmap;\n\t}\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,7 @@\n \t\t\tgoto unmap;\n \t\t*page = pte_page(*pte);\n \t}\n-\tif (unlikely(!try_get_page(*page))) {\n+\tif (unlikely(!try_grab_page(*page, gup_flags))) {\n \t\tret = -ENOMEM;\n \t\tgoto unmap;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (unlikely(!try_get_page(*page))) {"
            ],
            "added_lines": [
                "\tif (unlikely(!try_grab_page(*page, gup_flags))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15691",
        "func_name": "CendioOssman/tigervnc/ZRLE_DECODE",
        "description": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
        "git_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40",
        "commit_title": "Make ZlibInStream more robust against failures",
        "commit_text": " Move the checks around to avoid missing cases where we might access memory that is no longer valid. Also avoid touching the underlying stream implicitly (e.g. via the destructor) as it might also no longer be valid.  A malicious server could theoretically use this for remote code execution in the client.  Issue found by Pavel Cheremushkin from Kaspersky Lab",
        "func_before": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n\n      if (!rle) {\n        if (palSize == 0) {\n\n          // raw\n\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n\n        } else {\n\n          // packed pixels\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n\n          PIXEL_T* ptr = buf;\n\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n\n      } else {\n\n        if (palSize == 0) {\n\n          // plain RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n\n            while (len-- > 0) *ptr++ = pix;\n\n          }\n        } else {\n\n          // palette RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n\n            index &= 127;\n\n            PIXEL_T pix = palette[index];\n\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n\n      pb->imageRect(pf, t, buf);\n    }\n  }\n\n  zis->removeUnderlying();\n}",
        "func": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n\n      if (!rle) {\n        if (palSize == 0) {\n\n          // raw\n\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n\n        } else {\n\n          // packed pixels\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n\n          PIXEL_T* ptr = buf;\n\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n\n      } else {\n\n        if (palSize == 0) {\n\n          // plain RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n\n            while (len-- > 0) *ptr++ = pix;\n\n          }\n        } else {\n\n          // palette RLE\n\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n\n            index &= 127;\n\n            PIXEL_T pix = palette[index];\n\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n\n      pb->imageRect(pf, t, buf);\n    }\n  }\n\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -126,5 +126,6 @@\n     }\n   }\n \n-  zis->removeUnderlying();\n+  zis->flushUnderlying();\n+  zis->setUnderlying(NULL, 0);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  zis->removeUnderlying();"
            ],
            "added_lines": [
                "  zis->flushUnderlying();",
                "  zis->setUnderlying(NULL, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15691",
        "func_name": "CendioOssman/tigervnc/CMsgReader::readExtendedClipboard",
        "description": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
        "git_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40",
        "commit_title": "Make ZlibInStream more robust against failures",
        "commit_text": " Move the checks around to avoid missing cases where we might access memory that is no longer valid. Also avoid touching the underlying stream implicitly (e.g. via the destructor) as it might also no longer be valid.  A malicious server could theoretically use this for remote code execution in the client.  Issue found by Pavel Cheremushkin from Kaspersky Lab",
        "func_before": "void CMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.removeUnderlying();\n\n    handler->handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}",
        "func": "void CMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.flushUnderlying();\n    zis.setUnderlying(NULL, 0);\n\n    handler->handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -64,7 +64,8 @@\n       num++;\n     }\n \n-    zis.removeUnderlying();\n+    zis.flushUnderlying();\n+    zis.setUnderlying(NULL, 0);\n \n     handler->handleClipboardProvide(flags, lengths, buffers);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    zis.removeUnderlying();"
            ],
            "added_lines": [
                "    zis.flushUnderlying();",
                "    zis.setUnderlying(NULL, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15691",
        "func_name": "CendioOssman/tigervnc/TightDecoder::decodeRect",
        "description": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
        "git_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40",
        "commit_title": "Make ZlibInStream more robust against failures",
        "commit_text": " Move the checks around to avoid missing cases where we might access memory that is no longer valid. Also avoid touching the underlying stream implicitly (e.g. via the destructor) as it might also no longer be valid.  A malicious server could theoretically use this for remote code execution in the client.  Issue found by Pavel Cheremushkin from Kaspersky Lab",
        "func_before": "void TightDecoder::decodeRect(const Rect& r, const void* buffer,\n                              size_t buflen, const ServerParams& server,\n                              ModifiablePixelBuffer* pb)\n{\n  const rdr::U8* bufptr;\n  const PixelFormat& pf = server.pf();\n\n  rdr::U8 comp_ctl;\n\n  bufptr = (const rdr::U8*)buffer;\n\n  assert(buflen >= 1);\n\n  comp_ctl = *bufptr;\n  bufptr += 1;\n  buflen -= 1;\n\n  // Reset zlib streams if we are told by the server to do so.\n  for (int i = 0; i < 4; i++) {\n    if (comp_ctl & 1) {\n      zis[i].reset();\n    }\n    comp_ctl >>= 1;\n  }\n\n  // \"Fill\" compression type.\n  if (comp_ctl == tightFill) {\n    if (pf.is888()) {\n      rdr::U8 pix[4];\n\n      assert(buflen >= 3);\n\n      pf.bufferFromRGB(pix, bufptr, 1);\n      pb->fillRect(pf, r, pix);\n    } else {\n      assert(buflen >= (size_t)pf.bpp/8);\n      pb->fillRect(pf, r, bufptr);\n    }\n    return;\n  }\n\n  // \"JPEG\" compression type.\n  if (comp_ctl == tightJpeg) {\n    rdr::U32 len;\n\n    int stride;\n    rdr::U8 *buf;\n\n    JpegDecompressor jd;\n\n    assert(buflen >= 4);\n\n    memcpy(&len, bufptr, 4);\n    bufptr += 4;\n    buflen -= 4;\n\n    // We always use direct decoding with JPEG images\n    buf = pb->getBufferRW(r, &stride);\n    jd.decompress(bufptr, len, buf, stride, r, pb->getPF());\n    pb->commitBufferRW(r);\n    return;\n  }\n\n  // Quit on unsupported compression type.\n  assert(comp_ctl <= tightMaxSubencoding);\n\n  // \"Basic\" compression type.\n\n  int palSize = 0;\n  rdr::U8 palette[256 * 4];\n  bool useGradient = false;\n\n  if ((comp_ctl & tightExplicitFilter) != 0) {\n    rdr::U8 filterId;\n\n    assert(buflen >= 1);\n\n    filterId = *bufptr;\n    bufptr += 1;\n    buflen -= 1;\n\n    switch (filterId) {\n    case tightFilterPalette:\n      assert(buflen >= 1);\n\n      palSize = *bufptr + 1;\n      bufptr += 1;\n      buflen -= 1;\n\n      if (pf.is888()) {\n        size_t len = palSize * 3;\n        rdr::U8Array tightPalette(len);\n\n        assert(buflen >= len);\n\n        memcpy(tightPalette.buf, bufptr, len);\n        bufptr += len;\n        buflen -= len;\n\n        pf.bufferFromRGB(palette, tightPalette.buf, palSize);\n      } else {\n        size_t len;\n\n        len = palSize * pf.bpp/8;\n\n        assert(buflen >= len);\n\n        memcpy(palette, bufptr, len);\n        bufptr += len;\n        buflen -= len;\n      }\n      break;\n    case tightFilterGradient:\n      useGradient = true;\n      break;\n    case tightFilterCopy:\n      break;\n    default:\n      assert(false);\n    }\n  }\n\n  // Determine if the data should be decompressed or just copied.\n  size_t rowSize, dataSize;\n  rdr::U8* netbuf;\n\n  netbuf = NULL;\n\n  if (palSize != 0) {\n    if (palSize <= 2)\n      rowSize = (r.width() + 7) / 8;\n    else\n      rowSize = r.width();\n  } else if (pf.is888()) {\n    rowSize = r.width() * 3;\n  } else {\n    rowSize = r.width() * pf.bpp/8;\n  }\n\n  dataSize = r.height() * rowSize;\n\n  if (dataSize < TIGHT_MIN_TO_COMPRESS)\n    assert(buflen >= dataSize);\n  else {\n    rdr::U32 len;\n    int streamId;\n    rdr::MemInStream* ms;\n\n    assert(buflen >= 4);\n\n    memcpy(&len, bufptr, 4);\n    bufptr += 4;\n    buflen -= 4;\n\n    assert(buflen >= len);\n\n    streamId = comp_ctl & 0x03;\n    ms = new rdr::MemInStream(bufptr, len);\n    zis[streamId].setUnderlying(ms, len);\n\n    // Allocate buffer and decompress the data\n    netbuf = new rdr::U8[dataSize];\n\n    zis[streamId].readBytes(netbuf, dataSize);\n\n    zis[streamId].removeUnderlying();\n    delete ms;\n\n    bufptr = netbuf;\n    buflen = dataSize;\n  }\n\n  // Time to decode the actual data\n  bool directDecode;\n\n  rdr::U8* outbuf;\n  int stride;\n\n  if (pb->getPF().equal(pf)) {\n    // Decode directly into the framebuffer (fast path)\n    directDecode = true;\n  } else {\n    // Decode into an intermediate buffer and use pixel translation\n    directDecode = false;\n  }\n\n  if (directDecode)\n    outbuf = pb->getBufferRW(r, &stride);\n  else {\n    outbuf = new rdr::U8[r.area() * (pf.bpp/8)];\n    stride = r.width();\n  }\n\n  if (palSize == 0) {\n    // Truecolor data\n    if (useGradient) {\n      if (pf.is888())\n        FilterGradient24(bufptr, pf, (rdr::U32*)outbuf, stride, r);\n      else {\n        switch (pf.bpp) {\n        case 8:\n          assert(false);\n          break;\n        case 16:\n          FilterGradient(bufptr, pf, (rdr::U16*)outbuf, stride, r);\n          break;\n        case 32:\n          FilterGradient(bufptr, pf, (rdr::U32*)outbuf, stride, r);\n          break;\n        }\n      }\n    } else {\n      // Copy\n      rdr::U8* ptr = outbuf;\n      const rdr::U8* srcPtr = bufptr;\n      int w = r.width();\n      int h = r.height();\n      if (pf.is888()) {\n        while (h > 0) {\n          pf.bufferFromRGB(ptr, srcPtr, w);\n          ptr += stride * pf.bpp/8;\n          srcPtr += w * 3;\n          h--;\n        }\n      } else {\n        while (h > 0) {\n          memcpy(ptr, srcPtr, w * pf.bpp/8);\n          ptr += stride * pf.bpp/8;\n          srcPtr += w * pf.bpp/8;\n          h--;\n        }\n      }\n    }\n  } else {\n    // Indexed color\n    switch (pf.bpp) {\n    case 8:\n      FilterPalette((const rdr::U8*)palette, palSize,\n                    bufptr, (rdr::U8*)outbuf, stride, r);\n      break;\n    case 16:\n      FilterPalette((const rdr::U16*)palette, palSize,\n                    bufptr, (rdr::U16*)outbuf, stride, r);\n      break;\n    case 32:\n      FilterPalette((const rdr::U32*)palette, palSize,\n                    bufptr, (rdr::U32*)outbuf, stride, r);\n      break;\n    }\n  }\n\n  if (directDecode)\n    pb->commitBufferRW(r);\n  else {\n    pb->imageRect(pf, r, outbuf);\n    delete [] outbuf;\n  }\n\n  delete [] netbuf;\n}",
        "func": "void TightDecoder::decodeRect(const Rect& r, const void* buffer,\n                              size_t buflen, const ServerParams& server,\n                              ModifiablePixelBuffer* pb)\n{\n  const rdr::U8* bufptr;\n  const PixelFormat& pf = server.pf();\n\n  rdr::U8 comp_ctl;\n\n  bufptr = (const rdr::U8*)buffer;\n\n  assert(buflen >= 1);\n\n  comp_ctl = *bufptr;\n  bufptr += 1;\n  buflen -= 1;\n\n  // Reset zlib streams if we are told by the server to do so.\n  for (int i = 0; i < 4; i++) {\n    if (comp_ctl & 1) {\n      zis[i].reset();\n    }\n    comp_ctl >>= 1;\n  }\n\n  // \"Fill\" compression type.\n  if (comp_ctl == tightFill) {\n    if (pf.is888()) {\n      rdr::U8 pix[4];\n\n      assert(buflen >= 3);\n\n      pf.bufferFromRGB(pix, bufptr, 1);\n      pb->fillRect(pf, r, pix);\n    } else {\n      assert(buflen >= (size_t)pf.bpp/8);\n      pb->fillRect(pf, r, bufptr);\n    }\n    return;\n  }\n\n  // \"JPEG\" compression type.\n  if (comp_ctl == tightJpeg) {\n    rdr::U32 len;\n\n    int stride;\n    rdr::U8 *buf;\n\n    JpegDecompressor jd;\n\n    assert(buflen >= 4);\n\n    memcpy(&len, bufptr, 4);\n    bufptr += 4;\n    buflen -= 4;\n\n    // We always use direct decoding with JPEG images\n    buf = pb->getBufferRW(r, &stride);\n    jd.decompress(bufptr, len, buf, stride, r, pb->getPF());\n    pb->commitBufferRW(r);\n    return;\n  }\n\n  // Quit on unsupported compression type.\n  assert(comp_ctl <= tightMaxSubencoding);\n\n  // \"Basic\" compression type.\n\n  int palSize = 0;\n  rdr::U8 palette[256 * 4];\n  bool useGradient = false;\n\n  if ((comp_ctl & tightExplicitFilter) != 0) {\n    rdr::U8 filterId;\n\n    assert(buflen >= 1);\n\n    filterId = *bufptr;\n    bufptr += 1;\n    buflen -= 1;\n\n    switch (filterId) {\n    case tightFilterPalette:\n      assert(buflen >= 1);\n\n      palSize = *bufptr + 1;\n      bufptr += 1;\n      buflen -= 1;\n\n      if (pf.is888()) {\n        size_t len = palSize * 3;\n        rdr::U8Array tightPalette(len);\n\n        assert(buflen >= len);\n\n        memcpy(tightPalette.buf, bufptr, len);\n        bufptr += len;\n        buflen -= len;\n\n        pf.bufferFromRGB(palette, tightPalette.buf, palSize);\n      } else {\n        size_t len;\n\n        len = palSize * pf.bpp/8;\n\n        assert(buflen >= len);\n\n        memcpy(palette, bufptr, len);\n        bufptr += len;\n        buflen -= len;\n      }\n      break;\n    case tightFilterGradient:\n      useGradient = true;\n      break;\n    case tightFilterCopy:\n      break;\n    default:\n      assert(false);\n    }\n  }\n\n  // Determine if the data should be decompressed or just copied.\n  size_t rowSize, dataSize;\n  rdr::U8* netbuf;\n\n  netbuf = NULL;\n\n  if (palSize != 0) {\n    if (palSize <= 2)\n      rowSize = (r.width() + 7) / 8;\n    else\n      rowSize = r.width();\n  } else if (pf.is888()) {\n    rowSize = r.width() * 3;\n  } else {\n    rowSize = r.width() * pf.bpp/8;\n  }\n\n  dataSize = r.height() * rowSize;\n\n  if (dataSize < TIGHT_MIN_TO_COMPRESS)\n    assert(buflen >= dataSize);\n  else {\n    rdr::U32 len;\n    int streamId;\n    rdr::MemInStream* ms;\n\n    assert(buflen >= 4);\n\n    memcpy(&len, bufptr, 4);\n    bufptr += 4;\n    buflen -= 4;\n\n    assert(buflen >= len);\n\n    streamId = comp_ctl & 0x03;\n    ms = new rdr::MemInStream(bufptr, len);\n    zis[streamId].setUnderlying(ms, len);\n\n    // Allocate buffer and decompress the data\n    netbuf = new rdr::U8[dataSize];\n\n    zis[streamId].readBytes(netbuf, dataSize);\n\n    zis[streamId].flushUnderlying();\n    zis[streamId].setUnderlying(NULL, 0);\n    delete ms;\n\n    bufptr = netbuf;\n    buflen = dataSize;\n  }\n\n  // Time to decode the actual data\n  bool directDecode;\n\n  rdr::U8* outbuf;\n  int stride;\n\n  if (pb->getPF().equal(pf)) {\n    // Decode directly into the framebuffer (fast path)\n    directDecode = true;\n  } else {\n    // Decode into an intermediate buffer and use pixel translation\n    directDecode = false;\n  }\n\n  if (directDecode)\n    outbuf = pb->getBufferRW(r, &stride);\n  else {\n    outbuf = new rdr::U8[r.area() * (pf.bpp/8)];\n    stride = r.width();\n  }\n\n  if (palSize == 0) {\n    // Truecolor data\n    if (useGradient) {\n      if (pf.is888())\n        FilterGradient24(bufptr, pf, (rdr::U32*)outbuf, stride, r);\n      else {\n        switch (pf.bpp) {\n        case 8:\n          assert(false);\n          break;\n        case 16:\n          FilterGradient(bufptr, pf, (rdr::U16*)outbuf, stride, r);\n          break;\n        case 32:\n          FilterGradient(bufptr, pf, (rdr::U32*)outbuf, stride, r);\n          break;\n        }\n      }\n    } else {\n      // Copy\n      rdr::U8* ptr = outbuf;\n      const rdr::U8* srcPtr = bufptr;\n      int w = r.width();\n      int h = r.height();\n      if (pf.is888()) {\n        while (h > 0) {\n          pf.bufferFromRGB(ptr, srcPtr, w);\n          ptr += stride * pf.bpp/8;\n          srcPtr += w * 3;\n          h--;\n        }\n      } else {\n        while (h > 0) {\n          memcpy(ptr, srcPtr, w * pf.bpp/8);\n          ptr += stride * pf.bpp/8;\n          srcPtr += w * pf.bpp/8;\n          h--;\n        }\n      }\n    }\n  } else {\n    // Indexed color\n    switch (pf.bpp) {\n    case 8:\n      FilterPalette((const rdr::U8*)palette, palSize,\n                    bufptr, (rdr::U8*)outbuf, stride, r);\n      break;\n    case 16:\n      FilterPalette((const rdr::U16*)palette, palSize,\n                    bufptr, (rdr::U16*)outbuf, stride, r);\n      break;\n    case 32:\n      FilterPalette((const rdr::U32*)palette, palSize,\n                    bufptr, (rdr::U32*)outbuf, stride, r);\n      break;\n    }\n  }\n\n  if (directDecode)\n    pb->commitBufferRW(r);\n  else {\n    pb->imageRect(pf, r, outbuf);\n    delete [] outbuf;\n  }\n\n  delete [] netbuf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -163,7 +163,8 @@\n \n     zis[streamId].readBytes(netbuf, dataSize);\n \n-    zis[streamId].removeUnderlying();\n+    zis[streamId].flushUnderlying();\n+    zis[streamId].setUnderlying(NULL, 0);\n     delete ms;\n \n     bufptr = netbuf;",
        "diff_line_info": {
            "deleted_lines": [
                "    zis[streamId].removeUnderlying();"
            ],
            "added_lines": [
                "    zis[streamId].flushUnderlying();",
                "    zis[streamId].setUnderlying(NULL, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15691",
        "func_name": "CendioOssman/tigervnc/SMsgReader::readExtendedClipboard",
        "description": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
        "git_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40",
        "commit_title": "Make ZlibInStream more robust against failures",
        "commit_text": " Move the checks around to avoid missing cases where we might access memory that is no longer valid. Also avoid touching the underlying stream implicitly (e.g. via the destructor) as it might also no longer be valid.  A malicious server could theoretically use this for remote code execution in the client.  Issue found by Pavel Cheremushkin from Kaspersky Lab",
        "func_before": "void SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.removeUnderlying();\n\n    handler->handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}",
        "func": "void SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n\n    zis.setUnderlying(is, len - 4);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n\n    zis.flushUnderlying();\n    zis.setUnderlying(NULL, 0);\n\n    handler->handleClipboardProvide(flags, lengths, buffers);\n\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -64,7 +64,8 @@\n       num++;\n     }\n \n-    zis.removeUnderlying();\n+    zis.flushUnderlying();\n+    zis.setUnderlying(NULL, 0);\n \n     handler->handleClipboardProvide(flags, lengths, buffers);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    zis.removeUnderlying();"
            ],
            "added_lines": [
                "    zis.flushUnderlying();",
                "    zis.setUnderlying(NULL, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15691",
        "func_name": "CendioOssman/tigervnc/ZlibInStream::overrun",
        "description": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
        "git_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40",
        "commit_title": "Make ZlibInStream more robust against failures",
        "commit_text": " Move the checks around to avoid missing cases where we might access memory that is no longer valid. Also avoid touching the underlying stream implicitly (e.g. via the destructor) as it might also no longer be valid.  A malicious server could theoretically use this for remote code execution in the client.  Issue found by Pavel Cheremushkin from Kaspersky Lab",
        "func_before": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}",
        "func": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,6 @@\n {\n   if (itemSize > bufSize)\n     throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n-  if (!underlying)\n-    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n \n   if (end - ptr != 0)\n     memmove(start, ptr, end - ptr);",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!underlying)",
                "    throw Exception(\"ZlibInStream overrun: no underlying stream\");"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2019-15691",
        "func_name": "CendioOssman/tigervnc/ZlibInStream::decompress",
        "description": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
        "git_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40",
        "commit_title": "Make ZlibInStream more robust against failures",
        "commit_text": " Move the checks around to avoid missing cases where we might access memory that is no longer valid. Also avoid touching the underlying stream implicitly (e.g. via the destructor) as it might also no longer be valid.  A malicious server could theoretically use this for remote code execution in the client.  Issue found by Pavel Cheremushkin from Kaspersky Lab",
        "func_before": "bool ZlibInStream::decompress(bool wait)\n{\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}",
        "func": "bool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n bool ZlibInStream::decompress(bool wait)\n {\n+  if (!underlying)\n+    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n+\n   zs->next_out = (U8*)end;\n   zs->avail_out = start + bufSize - end;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (!underlying)",
                "    throw Exception(\"ZlibInStream overrun: no underlying stream\");",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15691",
        "func_name": "CendioOssman/tigervnc/ZlibInStream::deinit",
        "description": "TigerVNC version prior to 1.10.1 is vulnerable to stack use-after-return, which occurs due to incorrect usage of stack memory in ZRLEDecoder. If decoding routine would throw an exception, ZRLEDecoder may try to access stack variable, which has been already freed during the process of stack unwinding. Exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.",
        "git_url": "https://github.com/CendioOssman/tigervnc/commit/d61a767d6842b530ffb532ddd5a3d233119aad40",
        "commit_title": "Make ZlibInStream more robust against failures",
        "commit_text": " Move the checks around to avoid missing cases where we might access memory that is no longer valid. Also avoid touching the underlying stream implicitly (e.g. via the destructor) as it might also no longer be valid.  A malicious server could theoretically use this for remote code execution in the client.  Issue found by Pavel Cheremushkin from Kaspersky Lab",
        "func_before": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}",
        "func": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  setUnderlying(NULL, 0);\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n void ZlibInStream::deinit()\n {\n   assert(zs != NULL);\n-  removeUnderlying();\n+  setUnderlying(NULL, 0);\n   inflateEnd(zs);\n   delete zs;\n   zs = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "  removeUnderlying();"
            ],
            "added_lines": [
                "  setUnderlying(NULL, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19480",
        "func_name": "OpenSC/sc_pkcs15_decode_prkdf_entry",
        "description": "An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/pkcs15-prkey.c has an incorrect free operation in sc_pkcs15_decode_prkdf_entry.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/6ce6152284c47ba9b1d4fe8ff9d2e6a3f5ee02c7",
        "commit_title": "pkcs15-prkey: Simplify cleaning memory after failure",
        "commit_text": " https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=18478",
        "func_before": "int sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card,\n\t\t\t\t struct sc_pkcs15_object *obj,\n\t\t\t\t const u8 ** buf, size_t *buflen)\n{\n\tsc_context_t *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_prkey_info info;\n\tint r, i, gostr3410_params[3];\n\tstruct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams;\n\tsize_t usage_len = sizeof(info.usage);\n\tsize_t af_len = sizeof(info.access_flags);\n\tstruct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR];\n\tstruct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR];\n\tstruct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE];\n\tstruct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE];\n\tstruct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr};\n\tstruct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr};\n\tstruct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr};\n\tstruct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr };\n\n\tsc_copy_asn1_entry(c_asn1_prkey, asn1_prkey);\n\tsc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms);\n\n\tsc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr);\n\tsc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr);\n\tsc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr);\n\tsc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr);\n\n\tsc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr);\n\tsc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr);\n\n\tsc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0);\n\n\tsc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0);\n\n\tfor (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++)\n\t\tsc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0);\n\n\t/* Fill in defaults */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.key_reference = -1;\n\tinfo.native = 1;\n\tmemset(gostr3410_params, 0, sizeof(gostr3410_params));\n\n\tr = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen);\n\tif (r < 0) {\n\t\t/* This might have allocated something. If so, clear it now */\n\t\tif (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT &&\n\t\t\tasn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) {\n\t\t\tfree(asn1_com_prkey_attr[0].parm);\n\t\t}\n\t}\n\tif (r == SC_ERROR_ASN1_END_OF_CONTENTS)\n\t\treturn r;\n\tLOG_TEST_RET(ctx, r, \"PrKey DF ASN.1 decoding failed\");\n\tif (asn1_prkey[0].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_RSA;\n\t}\n\telse if (asn1_prkey[1].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_EC;\n\t}\n\telse if (asn1_prkey[2].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_DSA;\n\t\t/* If the value was indirect-protected, mark the path */\n\t\tif (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT)\n\t\t\tinfo.path.type = SC_PATH_TYPE_PATH_PROT;\n\t}\n\telse if (asn1_prkey[3].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410;\n\t\tassert(info.modulus_length == 0);\n\t\tinfo.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE;\n\t\tassert(info.params.len == 0);\n\t\tinfo.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams);\n\t\tinfo.params.data = malloc(info.params.len);\n\t\tif (info.params.data == NULL)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tassert(sizeof(*keyinfo_gostparams) == info.params.len);\n\t\tkeyinfo_gostparams = info.params.data;\n\t\tkeyinfo_gostparams->gostr3410 = gostr3410_params[0];\n\t\tkeyinfo_gostparams->gostr3411 = gostr3410_params[1];\n\t\tkeyinfo_gostparams->gost28147 = gostr3410_params[2];\n\t}\n\telse {\n\t\tsc_log(ctx, \"Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry.\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT);\n\t}\n\n\tif (!p15card->app || !p15card->app->ddo.aid.len)   {\n\t\tr = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path);\n\t\tif (r < 0) {\n\t\t\tsc_pkcs15_free_key_params(&info.params);\n\t\t\treturn r;\n\t\t}\n\t}\n\telse   {\n\t\tinfo.path.aid = p15card->app->ddo.aid;\n\t}\n\tsc_log(ctx, \"PrivKey path '%s'\", sc_print_path(&info.path));\n\n\t/* OpenSC 0.11.4 and older encoded \"keyReference\" as a negative value.\n\t * Fixed in 0.11.5 we need to add a hack, so old cards continue to work. */\n\tif (info.key_reference < -1)\n\t\tinfo.key_reference += 256;\n\n\t/* Check the auth_id - if not present, try and find it in access rules */\n\tif ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) {\n\t\tsc_log(ctx, \"Private key %s has no auth ID - checking AccessControlRules\",\n\t\t\t\tsc_pkcs15_print_id(&info.id));\n\n\t\t/* Search in the access_rules for an appropriate auth ID */\n\t\tfor (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) {\n\t\t\t/* If access_mode is one of the private key usage modes */\n\t\t\tif (obj->access_rules[i].access_mode &\n\t\t\t\t\t(SC_PKCS15_ACCESS_RULE_MODE_EXECUTE |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) {\n\t\t\t\tif (obj->access_rules[i].auth_id.len != 0) {\n\t\t\t\t\t/* Found an auth ID to use for private key access */\n\t\t\t\t\tobj->auth_id = obj->access_rules[i].auth_id;\n\t\t\t\t\tsc_log(ctx, \"Auth ID found - %s\",\n\t\t\t\t\t\t sc_pkcs15_print_id(&obj->auth_id));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* No auth ID found */\n\t\tif (i == SC_PKCS15_MAX_ACCESS_RULES)\n\t\t\tsc_log(ctx, \"Warning: No auth ID found\");\n\t}\n\n\tobj->data = malloc(sizeof(info));\n\tif (obj->data == NULL) {\n\t\tsc_pkcs15_free_key_params(&info.params);\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tmemcpy(obj->data, &info, sizeof(info));\n\n\tsc_log(ctx, \"Key Subject %s\", sc_dump_hex(info.subject.value, info.subject.len));\n\tsc_log(ctx, \"Key path %s\", sc_print_path(&info.path));\n\treturn 0;\n}",
        "func": "int sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card,\n\t\t\t\t struct sc_pkcs15_object *obj,\n\t\t\t\t const u8 ** buf, size_t *buflen)\n{\n\tsc_context_t *ctx = p15card->card->ctx;\n\tstruct sc_pkcs15_prkey_info info;\n\tint r, i, gostr3410_params[3];\n\tstruct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams;\n\tsize_t usage_len = sizeof(info.usage);\n\tsize_t af_len = sizeof(info.access_flags);\n\tstruct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE];\n\tstruct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR];\n\tstruct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR];\n\tstruct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE];\n\tstruct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE];\n\tstruct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr};\n\tstruct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr};\n\tstruct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr};\n\tstruct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr };\n\n\tsc_copy_asn1_entry(c_asn1_prkey, asn1_prkey);\n\tsc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms);\n\n\tsc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr);\n\tsc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr);\n\tsc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr);\n\tsc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr);\n\tsc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr);\n\tsc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr);\n\n\tsc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr);\n\tsc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr);\n\n\tsc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0);\n\tsc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0);\n\tsc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0);\n\n\tsc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0);\n\tsc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0);\n\n\tfor (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++)\n\t\tsc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0);\n\tsc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0);\n\n\t/* Fill in defaults */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.key_reference = -1;\n\tinfo.native = 1;\n\tmemset(gostr3410_params, 0, sizeof(gostr3410_params));\n\n\tr = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen);\n\tif (r < 0) {\n\t\t/* This might have allocated something. If so, clear it now */\n\t\tfree(info.subject.value);\n\t}\n\tif (r == SC_ERROR_ASN1_END_OF_CONTENTS)\n\t\treturn r;\n\tLOG_TEST_RET(ctx, r, \"PrKey DF ASN.1 decoding failed\");\n\tif (asn1_prkey[0].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_RSA;\n\t}\n\telse if (asn1_prkey[1].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_EC;\n\t}\n\telse if (asn1_prkey[2].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_DSA;\n\t\t/* If the value was indirect-protected, mark the path */\n\t\tif (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT)\n\t\t\tinfo.path.type = SC_PATH_TYPE_PATH_PROT;\n\t}\n\telse if (asn1_prkey[3].flags & SC_ASN1_PRESENT) {\n\t\tobj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410;\n\t\tassert(info.modulus_length == 0);\n\t\tinfo.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE;\n\t\tassert(info.params.len == 0);\n\t\tinfo.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams);\n\t\tinfo.params.data = malloc(info.params.len);\n\t\tif (info.params.data == NULL)\n\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tassert(sizeof(*keyinfo_gostparams) == info.params.len);\n\t\tkeyinfo_gostparams = info.params.data;\n\t\tkeyinfo_gostparams->gostr3410 = gostr3410_params[0];\n\t\tkeyinfo_gostparams->gostr3411 = gostr3410_params[1];\n\t\tkeyinfo_gostparams->gost28147 = gostr3410_params[2];\n\t}\n\telse {\n\t\tsc_log(ctx, \"Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry.\");\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT);\n\t}\n\n\tif (!p15card->app || !p15card->app->ddo.aid.len)   {\n\t\tr = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path);\n\t\tif (r < 0) {\n\t\t\tsc_pkcs15_free_key_params(&info.params);\n\t\t\treturn r;\n\t\t}\n\t}\n\telse   {\n\t\tinfo.path.aid = p15card->app->ddo.aid;\n\t}\n\tsc_log(ctx, \"PrivKey path '%s'\", sc_print_path(&info.path));\n\n\t/* OpenSC 0.11.4 and older encoded \"keyReference\" as a negative value.\n\t * Fixed in 0.11.5 we need to add a hack, so old cards continue to work. */\n\tif (info.key_reference < -1)\n\t\tinfo.key_reference += 256;\n\n\t/* Check the auth_id - if not present, try and find it in access rules */\n\tif ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) {\n\t\tsc_log(ctx, \"Private key %s has no auth ID - checking AccessControlRules\",\n\t\t\t\tsc_pkcs15_print_id(&info.id));\n\n\t\t/* Search in the access_rules for an appropriate auth ID */\n\t\tfor (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) {\n\t\t\t/* If access_mode is one of the private key usage modes */\n\t\t\tif (obj->access_rules[i].access_mode &\n\t\t\t\t\t(SC_PKCS15_ACCESS_RULE_MODE_EXECUTE |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT |\n\t\t\t\t\t SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) {\n\t\t\t\tif (obj->access_rules[i].auth_id.len != 0) {\n\t\t\t\t\t/* Found an auth ID to use for private key access */\n\t\t\t\t\tobj->auth_id = obj->access_rules[i].auth_id;\n\t\t\t\t\tsc_log(ctx, \"Auth ID found - %s\",\n\t\t\t\t\t\t sc_pkcs15_print_id(&obj->auth_id));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* No auth ID found */\n\t\tif (i == SC_PKCS15_MAX_ACCESS_RULES)\n\t\t\tsc_log(ctx, \"Warning: No auth ID found\");\n\t}\n\n\tobj->data = malloc(sizeof(info));\n\tif (obj->data == NULL) {\n\t\tsc_pkcs15_free_key_params(&info.params);\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tmemcpy(obj->data, &info, sizeof(info));\n\n\tsc_log(ctx, \"Key Subject %s\", sc_dump_hex(info.subject.value, info.subject.len));\n\tsc_log(ctx, \"Key path %s\", sc_print_path(&info.path));\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -91,10 +91,7 @@\n \tr = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen);\n \tif (r < 0) {\n \t\t/* This might have allocated something. If so, clear it now */\n-\t\tif (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT &&\n-\t\t\tasn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) {\n-\t\t\tfree(asn1_com_prkey_attr[0].parm);\n-\t\t}\n+\t\tfree(info.subject.value);\n \t}\n \tif (r == SC_ERROR_ASN1_END_OF_CONTENTS)\n \t\treturn r;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT &&",
                "\t\t\tasn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) {",
                "\t\t\tfree(asn1_com_prkey_attr[0].parm);",
                "\t\t}"
            ],
            "added_lines": [
                "\t\tfree(info.subject.value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3547",
        "func_name": "torvalds/linux/pipe_rdwr_open",
        "description": "Multiple race conditions in fs/pipe.c in the Linux kernel before 2.6.32-rc6 allow local users to cause a denial of service (NULL pointer dereference and system crash) or gain privileges by attempting to open an anonymous pipe via a /proc/*/fd/ pathname.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=ad3960243e55320d74195fb85c975e0a8cc4466c",
        "commit_title": "This patch fixes a null pointer exception in pipe_rdwr_open() which",
        "commit_text": "generates the stack trace:  > Unable to handle kernel NULL pointer dereference at 0000000000000028 RIP: >  [<ffffffff802899a5>] pipe_rdwr_open+0x35/0x70 >  [<ffffffff8028125c>] __dentry_open+0x13c/0x230 >  [<ffffffff8028143d>] do_filp_open+0x2d/0x40 >  [<ffffffff802814aa>] do_sys_open+0x5a/0x100 >  [<ffffffff8021faf3>] sysenter_do_call+0x1b/0x67  The failure mode is triggered by an attempt to open an anonymous pipe via /proc/pid/fd/* as exemplified by this script:  ============================================================= while : ; do    { echo y ; sleep 1 ; } | { while read ; do echo z$REPLY; done ; } &    PID=$!    OUT=$(ps -efl | grep 'sleep 1' | grep -v grep |         { read PID REST ; echo $PID; } )    OUT=\"${OUT%% *}\"    DELAY=$((RANDOM * 1000 / 32768))    usleep $((DELAY * 1000 + RANDOM % 1000 ))    echo n > /proc/$OUT/fd/1                 # Trigger defect done =============================================================  Note that the failure window is quite small and I could only reliably reproduce the defect by inserting a small delay in pipe_rdwr_open(). For example:   static int  pipe_rdwr_open(struct inode *inode, struct file *filp)  {        msleep(100);        mutex_lock(&inode->i_mutex);  Although the defect was observed in pipe_rdwr_open(), I think it makes sense to replicate the change through all the pipe_*_open() functions.  The core of the change is to verify that inode->i_pipe has not been released before attempting to manipulate it. If inode->i_pipe is no longer present, return ENOENT to indicate so.  The comment about potentially using atomic_t for i_pipe->readers and i_pipe->writers has also been removed because it is no longer relevant in this context. The inode->i_mutex lock must be used so that inode->i_pipe can be dealt with correctly.  Cc: stable@kernel.org ",
        "func_before": "static int\npipe_rdwr_open(struct inode *inode, struct file *filp)\n{\n\tmutex_lock(&inode->i_mutex);\n\tif (filp->f_mode & FMODE_READ)\n\t\tinode->i_pipe->readers++;\n\tif (filp->f_mode & FMODE_WRITE)\n\t\tinode->i_pipe->writers++;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn 0;\n}",
        "func": "static int\npipe_rdwr_open(struct inode *inode, struct file *filp)\n{\n\tint ret = -ENOENT;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (inode->i_pipe) {\n\t\tret = 0;\n\t\tif (filp->f_mode & FMODE_READ)\n\t\t\tinode->i_pipe->readers++;\n\t\tif (filp->f_mode & FMODE_WRITE)\n\t\t\tinode->i_pipe->writers++;\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,19 @@\n static int\n pipe_rdwr_open(struct inode *inode, struct file *filp)\n {\n+\tint ret = -ENOENT;\n+\n \tmutex_lock(&inode->i_mutex);\n-\tif (filp->f_mode & FMODE_READ)\n-\t\tinode->i_pipe->readers++;\n-\tif (filp->f_mode & FMODE_WRITE)\n-\t\tinode->i_pipe->writers++;\n+\n+\tif (inode->i_pipe) {\n+\t\tret = 0;\n+\t\tif (filp->f_mode & FMODE_READ)\n+\t\t\tinode->i_pipe->readers++;\n+\t\tif (filp->f_mode & FMODE_WRITE)\n+\t\t\tinode->i_pipe->writers++;\n+\t}\n+\n \tmutex_unlock(&inode->i_mutex);\n \n-\treturn 0;\n+\treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (filp->f_mode & FMODE_READ)",
                "\t\tinode->i_pipe->readers++;",
                "\tif (filp->f_mode & FMODE_WRITE)",
                "\t\tinode->i_pipe->writers++;",
                "\treturn 0;"
            ],
            "added_lines": [
                "\tint ret = -ENOENT;",
                "",
                "",
                "\tif (inode->i_pipe) {",
                "\t\tret = 0;",
                "\t\tif (filp->f_mode & FMODE_READ)",
                "\t\t\tinode->i_pipe->readers++;",
                "\t\tif (filp->f_mode & FMODE_WRITE)",
                "\t\t\tinode->i_pipe->writers++;",
                "\t}",
                "",
                "\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3547",
        "func_name": "torvalds/linux/pipe_write_open",
        "description": "Multiple race conditions in fs/pipe.c in the Linux kernel before 2.6.32-rc6 allow local users to cause a denial of service (NULL pointer dereference and system crash) or gain privileges by attempting to open an anonymous pipe via a /proc/*/fd/ pathname.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=ad3960243e55320d74195fb85c975e0a8cc4466c",
        "commit_title": "This patch fixes a null pointer exception in pipe_rdwr_open() which",
        "commit_text": "generates the stack trace:  > Unable to handle kernel NULL pointer dereference at 0000000000000028 RIP: >  [<ffffffff802899a5>] pipe_rdwr_open+0x35/0x70 >  [<ffffffff8028125c>] __dentry_open+0x13c/0x230 >  [<ffffffff8028143d>] do_filp_open+0x2d/0x40 >  [<ffffffff802814aa>] do_sys_open+0x5a/0x100 >  [<ffffffff8021faf3>] sysenter_do_call+0x1b/0x67  The failure mode is triggered by an attempt to open an anonymous pipe via /proc/pid/fd/* as exemplified by this script:  ============================================================= while : ; do    { echo y ; sleep 1 ; } | { while read ; do echo z$REPLY; done ; } &    PID=$!    OUT=$(ps -efl | grep 'sleep 1' | grep -v grep |         { read PID REST ; echo $PID; } )    OUT=\"${OUT%% *}\"    DELAY=$((RANDOM * 1000 / 32768))    usleep $((DELAY * 1000 + RANDOM % 1000 ))    echo n > /proc/$OUT/fd/1                 # Trigger defect done =============================================================  Note that the failure window is quite small and I could only reliably reproduce the defect by inserting a small delay in pipe_rdwr_open(). For example:   static int  pipe_rdwr_open(struct inode *inode, struct file *filp)  {        msleep(100);        mutex_lock(&inode->i_mutex);  Although the defect was observed in pipe_rdwr_open(), I think it makes sense to replicate the change through all the pipe_*_open() functions.  The core of the change is to verify that inode->i_pipe has not been released before attempting to manipulate it. If inode->i_pipe is no longer present, return ENOENT to indicate so.  The comment about potentially using atomic_t for i_pipe->readers and i_pipe->writers has also been removed because it is no longer relevant in this context. The inode->i_mutex lock must be used so that inode->i_pipe can be dealt with correctly.  Cc: stable@kernel.org ",
        "func_before": "static int\npipe_write_open(struct inode *inode, struct file *filp)\n{\n\tmutex_lock(&inode->i_mutex);\n\tinode->i_pipe->writers++;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn 0;\n}",
        "func": "static int\npipe_write_open(struct inode *inode, struct file *filp)\n{\n\tint ret = -ENOENT;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (inode->i_pipe) {\n\t\tret = 0;\n\t\tinode->i_pipe->writers++;\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,16 @@\n static int\n pipe_write_open(struct inode *inode, struct file *filp)\n {\n+\tint ret = -ENOENT;\n+\n \tmutex_lock(&inode->i_mutex);\n-\tinode->i_pipe->writers++;\n+\n+\tif (inode->i_pipe) {\n+\t\tret = 0;\n+\t\tinode->i_pipe->writers++;\n+\t}\n+\n \tmutex_unlock(&inode->i_mutex);\n \n-\treturn 0;\n+\treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tinode->i_pipe->writers++;",
                "\treturn 0;"
            ],
            "added_lines": [
                "\tint ret = -ENOENT;",
                "",
                "",
                "\tif (inode->i_pipe) {",
                "\t\tret = 0;",
                "\t\tinode->i_pipe->writers++;",
                "\t}",
                "",
                "\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3547",
        "func_name": "torvalds/linux/pipe_read_open",
        "description": "Multiple race conditions in fs/pipe.c in the Linux kernel before 2.6.32-rc6 allow local users to cause a denial of service (NULL pointer dereference and system crash) or gain privileges by attempting to open an anonymous pipe via a /proc/*/fd/ pathname.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=ad3960243e55320d74195fb85c975e0a8cc4466c",
        "commit_title": "This patch fixes a null pointer exception in pipe_rdwr_open() which",
        "commit_text": "generates the stack trace:  > Unable to handle kernel NULL pointer dereference at 0000000000000028 RIP: >  [<ffffffff802899a5>] pipe_rdwr_open+0x35/0x70 >  [<ffffffff8028125c>] __dentry_open+0x13c/0x230 >  [<ffffffff8028143d>] do_filp_open+0x2d/0x40 >  [<ffffffff802814aa>] do_sys_open+0x5a/0x100 >  [<ffffffff8021faf3>] sysenter_do_call+0x1b/0x67  The failure mode is triggered by an attempt to open an anonymous pipe via /proc/pid/fd/* as exemplified by this script:  ============================================================= while : ; do    { echo y ; sleep 1 ; } | { while read ; do echo z$REPLY; done ; } &    PID=$!    OUT=$(ps -efl | grep 'sleep 1' | grep -v grep |         { read PID REST ; echo $PID; } )    OUT=\"${OUT%% *}\"    DELAY=$((RANDOM * 1000 / 32768))    usleep $((DELAY * 1000 + RANDOM % 1000 ))    echo n > /proc/$OUT/fd/1                 # Trigger defect done =============================================================  Note that the failure window is quite small and I could only reliably reproduce the defect by inserting a small delay in pipe_rdwr_open(). For example:   static int  pipe_rdwr_open(struct inode *inode, struct file *filp)  {        msleep(100);        mutex_lock(&inode->i_mutex);  Although the defect was observed in pipe_rdwr_open(), I think it makes sense to replicate the change through all the pipe_*_open() functions.  The core of the change is to verify that inode->i_pipe has not been released before attempting to manipulate it. If inode->i_pipe is no longer present, return ENOENT to indicate so.  The comment about potentially using atomic_t for i_pipe->readers and i_pipe->writers has also been removed because it is no longer relevant in this context. The inode->i_mutex lock must be used so that inode->i_pipe can be dealt with correctly.  Cc: stable@kernel.org ",
        "func_before": "static int\npipe_read_open(struct inode *inode, struct file *filp)\n{\n\t/* We could have perhaps used atomic_t, but this and friends\n\t   below are the only places.  So it doesn't seem worthwhile.  */\n\tmutex_lock(&inode->i_mutex);\n\tinode->i_pipe->readers++;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn 0;\n}",
        "func": "static int\npipe_read_open(struct inode *inode, struct file *filp)\n{\n\tint ret = -ENOENT;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (inode->i_pipe) {\n\t\tret = 0;\n\t\tinode->i_pipe->readers++;\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,16 @@\n static int\n pipe_read_open(struct inode *inode, struct file *filp)\n {\n-\t/* We could have perhaps used atomic_t, but this and friends\n-\t   below are the only places.  So it doesn't seem worthwhile.  */\n+\tint ret = -ENOENT;\n+\n \tmutex_lock(&inode->i_mutex);\n-\tinode->i_pipe->readers++;\n+\n+\tif (inode->i_pipe) {\n+\t\tret = 0;\n+\t\tinode->i_pipe->readers++;\n+\t}\n+\n \tmutex_unlock(&inode->i_mutex);\n \n-\treturn 0;\n+\treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* We could have perhaps used atomic_t, but this and friends",
                "\t   below are the only places.  So it doesn't seem worthwhile.  */",
                "\tinode->i_pipe->readers++;",
                "\treturn 0;"
            ],
            "added_lines": [
                "\tint ret = -ENOENT;",
                "",
                "",
                "\tif (inode->i_pipe) {",
                "\t\tret = 0;",
                "\t\tinode->i_pipe->readers++;",
                "\t}",
                "",
                "\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-23638",
        "func_name": "squid-cache/squid/Server::clientWriteDone",
        "description": "Squid is a caching proxy for the Web. Due to an expired pointer reference bug, Squid prior to version 6.6 is vulnerable to a Denial of Service attack against Cache Manager error responses. This problem allows a trusted client to perform Denial of Service when generating error pages for Client Manager reports. Squid older than 5.0.5 have not been tested and should be assumed to be vulnerable. All Squid-5.x up to and including 5.9 are vulnerable. All Squid-6.x up to and including 6.5 are vulnerable. This bug is fixed by Squid version 6.6. In addition, patches addressing this problem for the stable releases can be found in Squid's patch archives. As a workaround, prevent access to Cache Manager using Squid's main access control: `http_access deny manager`.",
        "git_url": "https://github.com/squid-cache/squid/commit/290ae202883ac28a48867079c2fb34c40efd382b",
        "commit_title": "Just close after a write(2) response sending error (#1582)",
        "commit_text": "     FATAL: assertion failed: Http1Server.cc:322: \"rep\"  2015 commit 21cd322 started to continue ClientStream processing after socket write(2) failures. In most cases, the code still \"worked\". For example, initiateClose() would close the client-Squid connection, and connStateClosed() would be called before Store has a chance to deliver response body data requested by pullData() in writeComplete().  However, that response body data could sometimes reach Server, and handleReply() would assert because startOfOutput() says that we have not written the headers, but ClientStream state (i.e. a nil `rep` parameter) says that we have. These assertion can be triggered by disabling initiateClose(), and they can probably be triggered by traffic as well.  Now, after a Comm::Write() error, we terminateAll() client transactions on the failed connection[^1] and do not call afterClientWrite() that is not equipped to handle I/O errors and would continue ClientStream processing if called.  This bug was discovered and detailed by Joshua Rogers at https://megamansec.github.io/Squid-Security-Audit/stream-assert.html where it was filed as \"Implicit Assertion in Stream Handling\".  [^1]: We terminateAll() instead of potentially postponing closure with initiateClose() because the failed client-Squid connection most likely cannot be salvaged for, say, reading the remainder of the request body.",
        "func_before": "void\nServer::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n\n    /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n\n    Must(io.conn->fd == clientConnection->fd);\n\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n\n    afterClientWrite(io.size); // update state\n    writeSomeData(); // maybe schedules another write\n}",
        "func": "void\nServer::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n\n    /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n\n    Must(io.conn->fd == clientConnection->fd);\n\n    if (io.flag) {\n        debugs(33, 2, \"bailing after a write failure: \" << xstrerr(io.xerrno));\n        LogTagsErrors lte;\n        lte.timedout = io.xerrno == ETIMEDOUT;\n        lte.aborted = !lte.timedout; // intentionally true for zero io.xerrno\n        terminateAll(Error(ERR_WRITE_ERROR, SysErrorDetail::NewIfAny(io.xerrno)), lte);\n        return;\n    }\n\n    afterClientWrite(io.size); // update state\n    writeSomeData(); // maybe schedules another write\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,8 +13,14 @@\n \n     Must(io.conn->fd == clientConnection->fd);\n \n-    if (io.flag && pipeline.front())\n-        pipeline.front()->initiateClose(\"write failure\");\n+    if (io.flag) {\n+        debugs(33, 2, \"bailing after a write failure: \" << xstrerr(io.xerrno));\n+        LogTagsErrors lte;\n+        lte.timedout = io.xerrno == ETIMEDOUT;\n+        lte.aborted = !lte.timedout; // intentionally true for zero io.xerrno\n+        terminateAll(Error(ERR_WRITE_ERROR, SysErrorDetail::NewIfAny(io.xerrno)), lte);\n+        return;\n+    }\n \n     afterClientWrite(io.size); // update state\n     writeSomeData(); // maybe schedules another write",
        "diff_line_info": {
            "deleted_lines": [
                "    if (io.flag && pipeline.front())",
                "        pipeline.front()->initiateClose(\"write failure\");"
            ],
            "added_lines": [
                "    if (io.flag) {",
                "        debugs(33, 2, \"bailing after a write failure: \" << xstrerr(io.xerrno));",
                "        LogTagsErrors lte;",
                "        lte.timedout = io.xerrno == ETIMEDOUT;",
                "        lte.aborted = !lte.timedout; // intentionally true for zero io.xerrno",
                "        terminateAll(Error(ERR_WRITE_ERROR, SysErrorDetail::NewIfAny(io.xerrno)), lte);",
                "        return;",
                "    }"
            ]
        }
    }
]