[
    {
        "cve_id": "CVE-2018-20843",
        "func_name": "libexpat/setElementTypePrefix",
        "description": "In libexpat in Expat before 2.2.7, XML input including XML names that contain a large number of colons could make the XML parser consume a high amount of RAM and CPU resources while processing (enough to be usable for denial-of-service attacks).",
        "git_url": "https://github.com/libexpat/libexpat/commit/11f8838bf99ea0a6f0b76f9760c43704d00c4ff6",
        "commit_title": "xmlparse.c: Fix extraction of namespace prefix from XML name (#186)",
        "commit_text": "",
        "func_before": "static int\nsetElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n\n    }\n  }\n  return 1;\n}",
        "func": "static int\nsetElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n      break;\n    }\n  }\n  return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n       else\n         poolDiscard(&dtd->pool);\n       elementType->prefix = prefix;\n-\n+      break;\n     }\n   }\n   return 1;",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "      break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1915",
        "func_name": "owasp-modsecurity/ModSecurity/cmd_hash_engine",
        "description": "ModSecurity before 2.7.3 allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via an XML external entity declaration in conjunction with an entity reference, aka an XML External Entity (XXE) vulnerability.",
        "git_url": "https://github.com/owasp-modsecurity/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "commit_title": "Added SecXmlExternalEntity",
        "commit_text": "",
        "func_before": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n\n    return NULL;\n}",
        "func": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SexHashEngine: %s\", p1);\n\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n         dcfg->hash_is_enabled = HASH_DISABLED;\n         dcfg->hash_enforcement = HASH_DISABLED;\n     }\n-    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n+    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SexHashEngine: %s\", p1);\n \n     return NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);"
            ],
            "added_lines": [
                "    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SexHashEngine: %s\", p1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1915",
        "func_name": "owasp-modsecurity/ModSecurity/init_directory_config",
        "description": "ModSecurity before 2.7.3 allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via an XML external entity declaration in conjunction with an entity reference, aka an XML External Entity (XXE) vulnerability.",
        "git_url": "https://github.com/owasp-modsecurity/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "commit_title": "Added SecXmlExternalEntity",
        "commit_text": "",
        "func_before": "void init_directory_config(directory_config *dcfg)\n{\n    if (dcfg == NULL) return;\n\n    if (dcfg->is_enabled == NOT_SET) dcfg->is_enabled = 0;\n\n    if (dcfg->reqbody_access == NOT_SET) dcfg->reqbody_access = 0;\n    if (dcfg->reqintercept_oe == NOT_SET) dcfg->reqintercept_oe = 0;\n    if (dcfg->reqbody_buffering == NOT_SET) dcfg->reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF;\n    if (dcfg->reqbody_inmemory_limit == NOT_SET)\n        dcfg->reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT;\n    if (dcfg->reqbody_limit == NOT_SET) dcfg->reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT;\n    if (dcfg->reqbody_no_files_limit == NOT_SET) dcfg->reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT;\n    if (dcfg->resbody_access == NOT_SET) dcfg->resbody_access = 0;\n    if (dcfg->of_limit == NOT_SET) dcfg->of_limit = RESPONSE_BODY_DEFAULT_LIMIT;\n    if (dcfg->if_limit_action == NOT_SET) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT;\n    if (dcfg->of_limit_action == NOT_SET) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT;\n\n    if (dcfg->of_mime_types == NOT_SET_P) {\n        dcfg->of_mime_types = apr_table_make(dcfg->mp, 3);\n        if (dcfg->of_mime_types_cleared != 1) {\n            apr_table_setn(dcfg->of_mime_types, \"text/plain\", \"1\");\n            apr_table_setn(dcfg->of_mime_types, \"text/html\", \"1\");\n        }\n    }\n\n    if (dcfg->debuglog_fd == NOT_SET_P) dcfg->debuglog_fd = NULL;\n    if (dcfg->debuglog_name == NOT_SET_P) dcfg->debuglog_name = NULL;\n    if (dcfg->debuglog_level == NOT_SET) dcfg->debuglog_level = 0;\n\n    if (dcfg->cookie_format == NOT_SET) dcfg->cookie_format = 0;\n    if (dcfg->argument_separator == NOT_SET) dcfg->argument_separator = '&';\n    if (dcfg->cookiev0_separator == NOT_SET_P) dcfg->cookiev0_separator = NULL;\n\n    if (dcfg->rule_inheritance == NOT_SET) dcfg->rule_inheritance = 1;\n\n    /* audit log variables */\n    if (dcfg->auditlog_flag == NOT_SET) dcfg->auditlog_flag = 0;\n    if (dcfg->auditlog_type == NOT_SET) dcfg->auditlog_type = AUDITLOG_SERIAL;\n    if (dcfg->max_rule_time == NOT_SET) dcfg->max_rule_time = 0;\n    if (dcfg->auditlog_dirperms == NOT_SET) dcfg->auditlog_dirperms = CREATEMODE_DIR;\n    if (dcfg->auditlog_fileperms == NOT_SET) dcfg->auditlog_fileperms = CREATEMODE;\n    if (dcfg->auditlog_fd == NOT_SET_P) dcfg->auditlog_fd = NULL;\n    if (dcfg->auditlog2_fd == NOT_SET_P) dcfg->auditlog2_fd = NULL;\n    if (dcfg->auditlog_name == NOT_SET_P) dcfg->auditlog_name = NULL;\n    if (dcfg->auditlog2_name == NOT_SET_P) dcfg->auditlog2_name = NULL;\n    if (dcfg->auditlog_storage_dir == NOT_SET_P) dcfg->auditlog_storage_dir = NULL;\n    if (dcfg->auditlog_parts == NOT_SET_P) dcfg->auditlog_parts = \"ABCFHZ\";\n    if (dcfg->auditlog_relevant_regex == NOT_SET_P) dcfg->auditlog_relevant_regex = NULL;\n\n    /* Upload */\n    if (dcfg->tmp_dir == NOT_SET_P) dcfg->tmp_dir = guess_tmp_dir(dcfg->mp);\n    if (dcfg->upload_dir == NOT_SET_P) dcfg->upload_dir = NULL;\n    if (dcfg->upload_keep_files == NOT_SET) dcfg->upload_keep_files = KEEP_FILES_OFF;\n    if (dcfg->upload_validates_files == NOT_SET) dcfg->upload_validates_files = 0;\n    if (dcfg->upload_filemode == NOT_SET) dcfg->upload_filemode = 0600;\n    if (dcfg->upload_file_limit == NOT_SET) dcfg->upload_file_limit = 100;\n\n    /* Misc */\n    if (dcfg->data_dir == NOT_SET_P) dcfg->data_dir = NULL;\n    if (dcfg->webappid == NOT_SET_P) dcfg->webappid = \"default\";\n    if (dcfg->sensor_id == NOT_SET_P) dcfg->sensor_id = \"default\";\n    if (dcfg->httpBlkey == NOT_SET_P) dcfg->httpBlkey = NULL;\n\n    /* Content injection. */\n    if (dcfg->content_injection_enabled == NOT_SET) dcfg->content_injection_enabled = 0;\n\n    /* Stream inspection */\n    if (dcfg->stream_inbody_inspection == NOT_SET) dcfg->stream_inbody_inspection = 0;\n    if (dcfg->stream_outbody_inspection == NOT_SET) dcfg->stream_outbody_inspection = 0;\n\n    /* Geo Lookup */\n    if (dcfg->geo == NOT_SET_P) dcfg->geo = NULL;\n\n    /* Gsb Lookup */\n    if (dcfg->gsb == NOT_SET_P) dcfg->gsb = NULL;\n\n    /* Unicode Map */\n    if (dcfg->u_map == NOT_SET_P) dcfg->u_map = NULL;\n\n    /* Cache */\n    if (dcfg->cache_trans == NOT_SET) dcfg->cache_trans = MODSEC_CACHE_DISABLED;\n    if (dcfg->cache_trans_incremental == NOT_SET) dcfg->cache_trans_incremental = 0;\n    if (dcfg->cache_trans_min == (apr_size_t)NOT_SET) dcfg->cache_trans_min = 32;\n    if (dcfg->cache_trans_max == (apr_size_t)NOT_SET) dcfg->cache_trans_max = 1024;\n    if (dcfg->cache_trans_maxitems == (apr_size_t)NOT_SET) dcfg->cache_trans_maxitems = 512;\n\n    if (dcfg->request_encoding == NOT_SET_P) dcfg->request_encoding = NULL;\n\n    if (dcfg->disable_backend_compression == NOT_SET) dcfg->disable_backend_compression = 0;\n\n    if (dcfg->col_timeout == NOT_SET) dcfg->col_timeout = 3600;\n\n    /* Hash */\n    if (dcfg->crypto_key == NOT_SET_P) dcfg->crypto_key = getkey(dcfg->mp);\n    if (dcfg->crypto_key_len == NOT_SET) dcfg->crypto_key_len = strlen(dcfg->crypto_key);\n    if (dcfg->crypto_key_add == NOT_SET) dcfg->crypto_key_add = HASH_KEYONLY;\n    if (dcfg->crypto_param_name == NOT_SET_P) dcfg->crypto_param_name = \"crypt\";\n    if (dcfg->hash_is_enabled == NOT_SET) dcfg->hash_is_enabled = HASH_DISABLED;\n    if (dcfg->hash_enforcement == NOT_SET) dcfg->hash_enforcement = HASH_DISABLED;\n    if (dcfg->crypto_hash_href_rx == NOT_SET) dcfg->crypto_hash_href_rx = 0;\n    if (dcfg->crypto_hash_faction_rx == NOT_SET) dcfg->crypto_hash_faction_rx = 0;\n    if (dcfg->crypto_hash_location_rx == NOT_SET) dcfg->crypto_hash_location_rx = 0;\n    if (dcfg->crypto_hash_iframesrc_rx == NOT_SET) dcfg->crypto_hash_iframesrc_rx = 0;\n    if (dcfg->crypto_hash_framesrc_rx == NOT_SET) dcfg->crypto_hash_framesrc_rx = 0;\n    if (dcfg->crypto_hash_href_pm == NOT_SET) dcfg->crypto_hash_href_pm = 0;\n    if (dcfg->crypto_hash_faction_pm == NOT_SET) dcfg->crypto_hash_faction_pm = 0;\n    if (dcfg->crypto_hash_location_pm == NOT_SET) dcfg->crypto_hash_location_pm = 0;\n    if (dcfg->crypto_hash_iframesrc_pm == NOT_SET) dcfg->crypto_hash_iframesrc_pm = 0;\n    if (dcfg->crypto_hash_framesrc_pm == NOT_SET) dcfg->crypto_hash_framesrc_pm = 0;\n\n}",
        "func": "void init_directory_config(directory_config *dcfg)\n{\n    if (dcfg == NULL) return;\n\n    if (dcfg->is_enabled == NOT_SET) dcfg->is_enabled = 0;\n\n    if (dcfg->reqbody_access == NOT_SET) dcfg->reqbody_access = 0;\n    if (dcfg->reqintercept_oe == NOT_SET) dcfg->reqintercept_oe = 0;\n    if (dcfg->reqbody_buffering == NOT_SET) dcfg->reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF;\n    if (dcfg->reqbody_inmemory_limit == NOT_SET)\n        dcfg->reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT;\n    if (dcfg->reqbody_limit == NOT_SET) dcfg->reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT;\n    if (dcfg->reqbody_no_files_limit == NOT_SET) dcfg->reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT;\n    if (dcfg->resbody_access == NOT_SET) dcfg->resbody_access = 0;\n    if (dcfg->of_limit == NOT_SET) dcfg->of_limit = RESPONSE_BODY_DEFAULT_LIMIT;\n    if (dcfg->if_limit_action == NOT_SET) dcfg->if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT;\n    if (dcfg->of_limit_action == NOT_SET) dcfg->of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT;\n\n    if (dcfg->of_mime_types == NOT_SET_P) {\n        dcfg->of_mime_types = apr_table_make(dcfg->mp, 3);\n        if (dcfg->of_mime_types_cleared != 1) {\n            apr_table_setn(dcfg->of_mime_types, \"text/plain\", \"1\");\n            apr_table_setn(dcfg->of_mime_types, \"text/html\", \"1\");\n        }\n    }\n\n    if (dcfg->debuglog_fd == NOT_SET_P) dcfg->debuglog_fd = NULL;\n    if (dcfg->debuglog_name == NOT_SET_P) dcfg->debuglog_name = NULL;\n    if (dcfg->debuglog_level == NOT_SET) dcfg->debuglog_level = 0;\n\n    if (dcfg->cookie_format == NOT_SET) dcfg->cookie_format = 0;\n    if (dcfg->argument_separator == NOT_SET) dcfg->argument_separator = '&';\n    if (dcfg->cookiev0_separator == NOT_SET_P) dcfg->cookiev0_separator = NULL;\n\n    if (dcfg->rule_inheritance == NOT_SET) dcfg->rule_inheritance = 1;\n\n    /* audit log variables */\n    if (dcfg->auditlog_flag == NOT_SET) dcfg->auditlog_flag = 0;\n    if (dcfg->auditlog_type == NOT_SET) dcfg->auditlog_type = AUDITLOG_SERIAL;\n    if (dcfg->max_rule_time == NOT_SET) dcfg->max_rule_time = 0;\n    if (dcfg->auditlog_dirperms == NOT_SET) dcfg->auditlog_dirperms = CREATEMODE_DIR;\n    if (dcfg->auditlog_fileperms == NOT_SET) dcfg->auditlog_fileperms = CREATEMODE;\n    if (dcfg->auditlog_fd == NOT_SET_P) dcfg->auditlog_fd = NULL;\n    if (dcfg->auditlog2_fd == NOT_SET_P) dcfg->auditlog2_fd = NULL;\n    if (dcfg->auditlog_name == NOT_SET_P) dcfg->auditlog_name = NULL;\n    if (dcfg->auditlog2_name == NOT_SET_P) dcfg->auditlog2_name = NULL;\n    if (dcfg->auditlog_storage_dir == NOT_SET_P) dcfg->auditlog_storage_dir = NULL;\n    if (dcfg->auditlog_parts == NOT_SET_P) dcfg->auditlog_parts = \"ABCFHZ\";\n    if (dcfg->auditlog_relevant_regex == NOT_SET_P) dcfg->auditlog_relevant_regex = NULL;\n\n    /* Upload */\n    if (dcfg->tmp_dir == NOT_SET_P) dcfg->tmp_dir = guess_tmp_dir(dcfg->mp);\n    if (dcfg->upload_dir == NOT_SET_P) dcfg->upload_dir = NULL;\n    if (dcfg->upload_keep_files == NOT_SET) dcfg->upload_keep_files = KEEP_FILES_OFF;\n    if (dcfg->upload_validates_files == NOT_SET) dcfg->upload_validates_files = 0;\n    if (dcfg->upload_filemode == NOT_SET) dcfg->upload_filemode = 0600;\n    if (dcfg->upload_file_limit == NOT_SET) dcfg->upload_file_limit = 100;\n\n    /* Misc */\n    if (dcfg->data_dir == NOT_SET_P) dcfg->data_dir = NULL;\n    if (dcfg->webappid == NOT_SET_P) dcfg->webappid = \"default\";\n    if (dcfg->sensor_id == NOT_SET_P) dcfg->sensor_id = \"default\";\n    if (dcfg->httpBlkey == NOT_SET_P) dcfg->httpBlkey = NULL;\n\n    /* Content injection. */\n    if (dcfg->content_injection_enabled == NOT_SET) dcfg->content_injection_enabled = 0;\n\n    /* Stream inspection */\n    if (dcfg->stream_inbody_inspection == NOT_SET) dcfg->stream_inbody_inspection = 0;\n    if (dcfg->stream_outbody_inspection == NOT_SET) dcfg->stream_outbody_inspection = 0;\n\n    /* Geo Lookup */\n    if (dcfg->geo == NOT_SET_P) dcfg->geo = NULL;\n\n    /* Gsb Lookup */\n    if (dcfg->gsb == NOT_SET_P) dcfg->gsb = NULL;\n\n    /* Unicode Map */\n    if (dcfg->u_map == NOT_SET_P) dcfg->u_map = NULL;\n\n    /* Cache */\n    if (dcfg->cache_trans == NOT_SET) dcfg->cache_trans = MODSEC_CACHE_DISABLED;\n    if (dcfg->cache_trans_incremental == NOT_SET) dcfg->cache_trans_incremental = 0;\n    if (dcfg->cache_trans_min == (apr_size_t)NOT_SET) dcfg->cache_trans_min = 32;\n    if (dcfg->cache_trans_max == (apr_size_t)NOT_SET) dcfg->cache_trans_max = 1024;\n    if (dcfg->cache_trans_maxitems == (apr_size_t)NOT_SET) dcfg->cache_trans_maxitems = 512;\n\n    if (dcfg->request_encoding == NOT_SET_P) dcfg->request_encoding = NULL;\n\n    if (dcfg->disable_backend_compression == NOT_SET) dcfg->disable_backend_compression = 0;\n\n    if (dcfg->col_timeout == NOT_SET) dcfg->col_timeout = 3600;\n\n    /* Hash */\n    if (dcfg->crypto_key == NOT_SET_P) dcfg->crypto_key = getkey(dcfg->mp);\n    if (dcfg->crypto_key_len == NOT_SET) dcfg->crypto_key_len = strlen(dcfg->crypto_key);\n    if (dcfg->crypto_key_add == NOT_SET) dcfg->crypto_key_add = HASH_KEYONLY;\n    if (dcfg->crypto_param_name == NOT_SET_P) dcfg->crypto_param_name = \"crypt\";\n    if (dcfg->hash_is_enabled == NOT_SET) dcfg->hash_is_enabled = HASH_DISABLED;\n    if (dcfg->hash_enforcement == NOT_SET) dcfg->hash_enforcement = HASH_DISABLED;\n    if (dcfg->crypto_hash_href_rx == NOT_SET) dcfg->crypto_hash_href_rx = 0;\n    if (dcfg->crypto_hash_faction_rx == NOT_SET) dcfg->crypto_hash_faction_rx = 0;\n    if (dcfg->crypto_hash_location_rx == NOT_SET) dcfg->crypto_hash_location_rx = 0;\n    if (dcfg->crypto_hash_iframesrc_rx == NOT_SET) dcfg->crypto_hash_iframesrc_rx = 0;\n    if (dcfg->crypto_hash_framesrc_rx == NOT_SET) dcfg->crypto_hash_framesrc_rx = 0;\n    if (dcfg->crypto_hash_href_pm == NOT_SET) dcfg->crypto_hash_href_pm = 0;\n    if (dcfg->crypto_hash_faction_pm == NOT_SET) dcfg->crypto_hash_faction_pm = 0;\n    if (dcfg->crypto_hash_location_pm == NOT_SET) dcfg->crypto_hash_location_pm = 0;\n    if (dcfg->crypto_hash_iframesrc_pm == NOT_SET) dcfg->crypto_hash_iframesrc_pm = 0;\n    if (dcfg->crypto_hash_framesrc_pm == NOT_SET) dcfg->crypto_hash_framesrc_pm = 0;\n\n    /* xml external entity */\n    if (dcfg->xml_external_entity == NOT_SET) dcfg->xml_external_entity = 0;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -109,4 +109,7 @@\n     if (dcfg->crypto_hash_iframesrc_pm == NOT_SET) dcfg->crypto_hash_iframesrc_pm = 0;\n     if (dcfg->crypto_hash_framesrc_pm == NOT_SET) dcfg->crypto_hash_framesrc_pm = 0;\n \n+    /* xml external entity */\n+    if (dcfg->xml_external_entity == NOT_SET) dcfg->xml_external_entity = 0;\n+\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* xml external entity */",
                "    if (dcfg->xml_external_entity == NOT_SET) dcfg->xml_external_entity = 0;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1915",
        "func_name": "owasp-modsecurity/ModSecurity/merge_directory_configs",
        "description": "ModSecurity before 2.7.3 allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via an XML external entity declaration in conjunction with an entity reference, aka an XML External Entity (XXE) vulnerability.",
        "git_url": "https://github.com/owasp-modsecurity/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "commit_title": "Added SecXmlExternalEntity",
        "commit_text": "",
        "func_before": "void *merge_directory_configs(apr_pool_t *mp, void *_parent, void *_child)\n{\n    directory_config *parent = (directory_config *)_parent;\n    directory_config *child = (directory_config *)_child;\n    directory_config *merged = create_directory_config(mp, NULL);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Merge parent %pp child %pp RESULT %pp\", _parent, _child, merged);\n    #endif\n\n    if (merged == NULL) return NULL;\n\n    /* Use values from the child configuration where possible,\n     * otherwise use the parent's.\n     */\n\n    merged->is_enabled = (child->is_enabled == NOT_SET\n        ? parent->is_enabled : child->is_enabled);\n\n    /* IO parameters */\n    merged->reqbody_access = (child->reqbody_access == NOT_SET\n        ? parent->reqbody_access : child->reqbody_access);\n    merged->reqbody_buffering = (child->reqbody_buffering == NOT_SET\n        ? parent->reqbody_buffering : child->reqbody_buffering);\n    merged->reqbody_inmemory_limit = (child->reqbody_inmemory_limit == NOT_SET\n        ? parent->reqbody_inmemory_limit : child->reqbody_inmemory_limit);\n    merged->reqbody_limit = (child->reqbody_limit == NOT_SET\n        ? parent->reqbody_limit : child->reqbody_limit);\n    merged->reqbody_no_files_limit = (child->reqbody_no_files_limit == NOT_SET\n        ? parent->reqbody_no_files_limit : child->reqbody_no_files_limit);\n    merged->resbody_access = (child->resbody_access == NOT_SET\n        ? parent->resbody_access : child->resbody_access);\n\n    merged->of_limit = (child->of_limit == NOT_SET\n        ? parent->of_limit : child->of_limit);\n    merged->if_limit_action = (child->if_limit_action == NOT_SET\n        ? parent->if_limit_action : child->if_limit_action);\n    merged->of_limit_action = (child->of_limit_action == NOT_SET\n        ? parent->of_limit_action : child->of_limit_action);\n    merged->reqintercept_oe = (child->reqintercept_oe == NOT_SET\n        ? parent->reqintercept_oe : child->reqintercept_oe);\n\n    if (child->of_mime_types != NOT_SET_P) {\n        /* Child added to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            /* The list of MIME types was cleared in the child,\n             * which means the parent's MIME types went away and\n             * we should not take them into consideration here.\n             */\n            merged->of_mime_types = child->of_mime_types;\n            merged->of_mime_types_cleared = 1;\n        } else {\n            /* Add MIME types defined in the child to those\n             * defined in the parent context.\n             */\n            if (parent->of_mime_types == NOT_SET_P) {\n                merged->of_mime_types = child->of_mime_types;\n                merged->of_mime_types_cleared = NOT_SET;\n            } else {\n                merged->of_mime_types = apr_table_overlay(mp, parent->of_mime_types,\n                    child->of_mime_types);\n                if (merged->of_mime_types == NULL) return NULL;\n            }\n        }\n    } else {\n        /* Child did not add to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            merged->of_mime_types_cleared = 1;\n        } else {\n            merged->of_mime_types = parent->of_mime_types;\n            merged->of_mime_types_cleared = parent->of_mime_types_cleared;\n        }\n    }\n\n    /* debug log */\n    if (child->debuglog_fd == NOT_SET_P) {\n        merged->debuglog_name = parent->debuglog_name;\n        merged->debuglog_fd = parent->debuglog_fd;\n    } else {\n        merged->debuglog_name = child->debuglog_name;\n        merged->debuglog_fd = child->debuglog_fd;\n    }\n\n    merged->debuglog_level = (child->debuglog_level == NOT_SET\n        ? parent->debuglog_level : child->debuglog_level);\n\n    merged->cookie_format = (child->cookie_format == NOT_SET\n        ? parent->cookie_format : child->cookie_format);\n    merged->argument_separator = (child->argument_separator == NOT_SET\n        ? parent->argument_separator : child->argument_separator);\n    merged->cookiev0_separator = (child->cookiev0_separator == NOT_SET_P\n        ? parent->cookiev0_separator : child->cookiev0_separator);\n\n\n    /* rule inheritance */\n    if ((child->rule_inheritance == NOT_SET)||(child->rule_inheritance == 1)) {\n        merged->rule_inheritance = parent->rule_inheritance;\n        if ((child->ruleset == NULL)&&(parent->ruleset == NULL)) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"No rules in this context.\");\n            #endif\n\n            /* Do nothing, there are no rules in either context. */\n        } else\n        if (child->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent rules in this context.\");\n            #endif\n\n            /* Copy the rules from the parent context. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n        } else\n        if (parent->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using child rules in this context.\");\n            #endif\n\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        } else {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent then child rules in this context.\");\n            #endif\n\n            /* Copy parent rules, then add child rules to it. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n\n            apr_array_cat(merged->ruleset->phase_request_headers,\n                child->ruleset->phase_request_headers);\n            apr_array_cat(merged->ruleset->phase_request_body,\n                child->ruleset->phase_request_body);\n            apr_array_cat(merged->ruleset->phase_response_headers,\n                child->ruleset->phase_response_headers);\n            apr_array_cat(merged->ruleset->phase_response_body,\n                child->ruleset->phase_response_body);\n            apr_array_cat(merged->ruleset->phase_logging,\n                child->ruleset->phase_logging);\n        }\n    } else {\n        merged->rule_inheritance = 0;\n        if (child->ruleset != NULL) {\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        }\n    }\n\n    /* Merge rule exceptions. */\n    merged->rule_exceptions = apr_array_append(mp, parent->rule_exceptions,\n        child->rule_exceptions);\n\n    merged->hash_method = apr_array_append(mp, parent->hash_method,\n        child->hash_method);\n\n    /* audit log variables */\n    merged->auditlog_flag = (child->auditlog_flag == NOT_SET\n        ? parent->auditlog_flag : child->auditlog_flag);\n    merged->auditlog_type = (child->auditlog_type == NOT_SET\n        ? parent->auditlog_type : child->auditlog_type);\n    merged->max_rule_time = (child->max_rule_time == NOT_SET\n        ? parent->max_rule_time : child->max_rule_time);\n    merged->auditlog_dirperms = (child->auditlog_dirperms == NOT_SET\n        ? parent->auditlog_dirperms : child->auditlog_dirperms);\n    merged->auditlog_fileperms = (child->auditlog_fileperms == NOT_SET\n        ? parent->auditlog_fileperms : child->auditlog_fileperms);\n    if (child->auditlog_fd != NOT_SET_P) {\n        merged->auditlog_fd = child->auditlog_fd;\n        merged->auditlog_name = child->auditlog_name;\n    } else {\n        merged->auditlog_fd = parent->auditlog_fd;\n        merged->auditlog_name = parent->auditlog_name;\n    }\n    if (child->auditlog2_fd != NOT_SET_P) {\n        merged->auditlog2_fd = child->auditlog2_fd;\n        merged->auditlog2_name = child->auditlog2_name;\n    } else {\n        merged->auditlog2_fd = parent->auditlog2_fd;\n        merged->auditlog2_name = parent->auditlog2_name;\n    }\n    merged->auditlog_storage_dir = (child->auditlog_storage_dir == NOT_SET_P\n        ? parent->auditlog_storage_dir : child->auditlog_storage_dir);\n    merged->auditlog_parts = (child->auditlog_parts == NOT_SET_P\n        ? parent->auditlog_parts : child->auditlog_parts);\n    merged->auditlog_relevant_regex = (child->auditlog_relevant_regex == NOT_SET_P\n        ? parent->auditlog_relevant_regex : child->auditlog_relevant_regex);\n\n    /* Upload */\n    merged->tmp_dir = (child->tmp_dir == NOT_SET_P\n        ? parent->tmp_dir : child->tmp_dir);\n    merged->upload_dir = (child->upload_dir == NOT_SET_P\n        ? parent->upload_dir : child->upload_dir);\n    merged->upload_keep_files = (child->upload_keep_files == NOT_SET\n        ? parent->upload_keep_files : child->upload_keep_files);\n    merged->upload_validates_files = (child->upload_validates_files == NOT_SET\n        ? parent->upload_validates_files : child->upload_validates_files);\n    merged->upload_filemode = (child->upload_filemode == NOT_SET\n        ? parent->upload_filemode : child->upload_filemode);\n    merged->upload_file_limit = (child->upload_file_limit == NOT_SET\n        ? parent->upload_file_limit : child->upload_file_limit);\n\n    /* Misc */\n    merged->data_dir = (child->data_dir == NOT_SET_P\n        ? parent->data_dir : child->data_dir);\n    merged->webappid = (child->webappid == NOT_SET_P\n        ? parent->webappid : child->webappid);\n    merged->sensor_id = (child->sensor_id == NOT_SET_P\n        ? parent->sensor_id : child->sensor_id);\n    merged->httpBlkey = (child->httpBlkey == NOT_SET_P\n        ? parent->httpBlkey : child->httpBlkey);\n\n    /* Content injection. */\n    merged->content_injection_enabled = (child->content_injection_enabled == NOT_SET\n        ? parent->content_injection_enabled : child->content_injection_enabled);\n\n    /* Stream inspection */\n    merged->stream_inbody_inspection = (child->stream_inbody_inspection == NOT_SET\n        ? parent->stream_inbody_inspection : child->stream_inbody_inspection);\n    merged->stream_outbody_inspection = (child->stream_outbody_inspection == NOT_SET\n        ? parent->stream_outbody_inspection : child->stream_outbody_inspection);\n\n    /* Geo Lookup */\n    merged->geo = (child->geo == NOT_SET_P\n        ? parent->geo : child->geo);\n\n    /* Gsb Lookup */\n    merged->gsb = (child->gsb == NOT_SET_P\n        ? parent->gsb : child->gsb);\n\n    /* Unicode Map */\n    merged->u_map = (child->u_map == NOT_SET_P\n        ? parent->u_map : child->u_map);\n\n    /* Cache */\n    merged->cache_trans = (child->cache_trans == NOT_SET\n        ? parent->cache_trans : child->cache_trans);\n    merged->cache_trans_incremental = (child->cache_trans_incremental == NOT_SET\n        ? parent->cache_trans_incremental : child->cache_trans_incremental);\n    merged->cache_trans_min = (child->cache_trans_min == (apr_size_t)NOT_SET\n        ? parent->cache_trans_min : child->cache_trans_min);\n    merged->cache_trans_max = (child->cache_trans_max == (apr_size_t)NOT_SET\n        ? parent->cache_trans_max : child->cache_trans_max);\n    merged->cache_trans_maxitems = (child->cache_trans_maxitems == (apr_size_t)NOT_SET\n        ? parent->cache_trans_maxitems : child->cache_trans_maxitems);\n\n    /* Merge component signatures. */\n    merged->component_signatures = apr_array_append(mp, parent->component_signatures,\n        child->component_signatures);\n\n    merged->request_encoding = (child->request_encoding == NOT_SET_P\n        ? parent->request_encoding : child->request_encoding);\n\n    merged->disable_backend_compression = (child->disable_backend_compression == NOT_SET\n        ? parent->disable_backend_compression : child->disable_backend_compression);\n\n    merged->col_timeout = (child->col_timeout == NOT_SET\n        ? parent->col_timeout : child->col_timeout);\n\n    /* Hash */\n    merged->crypto_key = (child->crypto_key == NOT_SET_P\n        ? parent->crypto_key : child->crypto_key);\n    merged->crypto_key_len = (child->crypto_key_len == NOT_SET\n        ? parent->crypto_key_len : child->crypto_key_len);\n    merged->crypto_key_add = (child->crypto_key_add == NOT_SET\n        ? parent->crypto_key_add : child->crypto_key_add);\n    merged->crypto_param_name = (child->crypto_param_name == NOT_SET_P\n        ? parent->crypto_param_name : child->crypto_param_name);\n    merged->hash_is_enabled = (child->hash_is_enabled == NOT_SET\n        ? parent->hash_is_enabled : child->hash_is_enabled);\n    merged->hash_enforcement = (child->hash_enforcement == NOT_SET\n        ? parent->hash_enforcement : child->hash_enforcement);\n    merged->crypto_hash_href_rx = (child->crypto_hash_href_rx == NOT_SET\n        ? parent->crypto_hash_href_rx : child->crypto_hash_href_rx);\n    merged->crypto_hash_faction_rx = (child->crypto_hash_faction_rx == NOT_SET\n        ? parent->crypto_hash_faction_rx : child->crypto_hash_faction_rx);\n    merged->crypto_hash_location_rx = (child->crypto_hash_location_rx == NOT_SET\n        ? parent->crypto_hash_location_rx : child->crypto_hash_location_rx);\n    merged->crypto_hash_iframesrc_rx = (child->crypto_hash_iframesrc_rx == NOT_SET\n        ? parent->crypto_hash_iframesrc_rx : child->crypto_hash_iframesrc_rx);\n    merged->crypto_hash_framesrc_rx = (child->crypto_hash_framesrc_rx == NOT_SET\n        ? parent->crypto_hash_framesrc_rx : child->crypto_hash_framesrc_rx);\n    merged->crypto_hash_href_pm = (child->crypto_hash_href_pm == NOT_SET\n        ? parent->crypto_hash_href_pm : child->crypto_hash_href_pm);\n    merged->crypto_hash_faction_pm = (child->crypto_hash_faction_pm == NOT_SET\n        ? parent->crypto_hash_faction_pm : child->crypto_hash_faction_pm);\n    merged->crypto_hash_location_pm = (child->crypto_hash_location_pm == NOT_SET\n        ? parent->crypto_hash_location_pm : child->crypto_hash_location_pm);\n    merged->crypto_hash_iframesrc_pm = (child->crypto_hash_iframesrc_pm == NOT_SET\n        ? parent->crypto_hash_iframesrc_pm : child->crypto_hash_iframesrc_pm);\n    merged->crypto_hash_framesrc_pm = (child->crypto_hash_framesrc_pm == NOT_SET\n        ? parent->crypto_hash_framesrc_pm : child->crypto_hash_framesrc_pm);\n\n    return merged;\n}",
        "func": "void *merge_directory_configs(apr_pool_t *mp, void *_parent, void *_child)\n{\n    directory_config *parent = (directory_config *)_parent;\n    directory_config *child = (directory_config *)_child;\n    directory_config *merged = create_directory_config(mp, NULL);\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Merge parent %pp child %pp RESULT %pp\", _parent, _child, merged);\n    #endif\n\n    if (merged == NULL) return NULL;\n\n    /* Use values from the child configuration where possible,\n     * otherwise use the parent's.\n     */\n\n    merged->is_enabled = (child->is_enabled == NOT_SET\n        ? parent->is_enabled : child->is_enabled);\n\n    /* IO parameters */\n    merged->reqbody_access = (child->reqbody_access == NOT_SET\n        ? parent->reqbody_access : child->reqbody_access);\n    merged->reqbody_buffering = (child->reqbody_buffering == NOT_SET\n        ? parent->reqbody_buffering : child->reqbody_buffering);\n    merged->reqbody_inmemory_limit = (child->reqbody_inmemory_limit == NOT_SET\n        ? parent->reqbody_inmemory_limit : child->reqbody_inmemory_limit);\n    merged->reqbody_limit = (child->reqbody_limit == NOT_SET\n        ? parent->reqbody_limit : child->reqbody_limit);\n    merged->reqbody_no_files_limit = (child->reqbody_no_files_limit == NOT_SET\n        ? parent->reqbody_no_files_limit : child->reqbody_no_files_limit);\n    merged->resbody_access = (child->resbody_access == NOT_SET\n        ? parent->resbody_access : child->resbody_access);\n\n    merged->of_limit = (child->of_limit == NOT_SET\n        ? parent->of_limit : child->of_limit);\n    merged->if_limit_action = (child->if_limit_action == NOT_SET\n        ? parent->if_limit_action : child->if_limit_action);\n    merged->of_limit_action = (child->of_limit_action == NOT_SET\n        ? parent->of_limit_action : child->of_limit_action);\n    merged->reqintercept_oe = (child->reqintercept_oe == NOT_SET\n        ? parent->reqintercept_oe : child->reqintercept_oe);\n\n    if (child->of_mime_types != NOT_SET_P) {\n        /* Child added to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            /* The list of MIME types was cleared in the child,\n             * which means the parent's MIME types went away and\n             * we should not take them into consideration here.\n             */\n            merged->of_mime_types = child->of_mime_types;\n            merged->of_mime_types_cleared = 1;\n        } else {\n            /* Add MIME types defined in the child to those\n             * defined in the parent context.\n             */\n            if (parent->of_mime_types == NOT_SET_P) {\n                merged->of_mime_types = child->of_mime_types;\n                merged->of_mime_types_cleared = NOT_SET;\n            } else {\n                merged->of_mime_types = apr_table_overlay(mp, parent->of_mime_types,\n                    child->of_mime_types);\n                if (merged->of_mime_types == NULL) return NULL;\n            }\n        }\n    } else {\n        /* Child did not add to the table */\n\n        if (child->of_mime_types_cleared == 1) {\n            merged->of_mime_types_cleared = 1;\n        } else {\n            merged->of_mime_types = parent->of_mime_types;\n            merged->of_mime_types_cleared = parent->of_mime_types_cleared;\n        }\n    }\n\n    /* debug log */\n    if (child->debuglog_fd == NOT_SET_P) {\n        merged->debuglog_name = parent->debuglog_name;\n        merged->debuglog_fd = parent->debuglog_fd;\n    } else {\n        merged->debuglog_name = child->debuglog_name;\n        merged->debuglog_fd = child->debuglog_fd;\n    }\n\n    merged->debuglog_level = (child->debuglog_level == NOT_SET\n        ? parent->debuglog_level : child->debuglog_level);\n\n    merged->cookie_format = (child->cookie_format == NOT_SET\n        ? parent->cookie_format : child->cookie_format);\n    merged->argument_separator = (child->argument_separator == NOT_SET\n        ? parent->argument_separator : child->argument_separator);\n    merged->cookiev0_separator = (child->cookiev0_separator == NOT_SET_P\n        ? parent->cookiev0_separator : child->cookiev0_separator);\n\n\n    /* rule inheritance */\n    if ((child->rule_inheritance == NOT_SET)||(child->rule_inheritance == 1)) {\n        merged->rule_inheritance = parent->rule_inheritance;\n        if ((child->ruleset == NULL)&&(parent->ruleset == NULL)) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"No rules in this context.\");\n            #endif\n\n            /* Do nothing, there are no rules in either context. */\n        } else\n        if (child->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent rules in this context.\");\n            #endif\n\n            /* Copy the rules from the parent context. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n        } else\n        if (parent->ruleset == NULL) {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using child rules in this context.\");\n            #endif\n\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        } else {\n            #ifdef DEBUG_CONF\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Using parent then child rules in this context.\");\n            #endif\n\n            /* Copy parent rules, then add child rules to it. */\n            merged->ruleset = msre_ruleset_create(parent->ruleset->engine, mp);\n            copy_rules(mp, parent->ruleset, merged->ruleset, child->rule_exceptions);\n\n            apr_array_cat(merged->ruleset->phase_request_headers,\n                child->ruleset->phase_request_headers);\n            apr_array_cat(merged->ruleset->phase_request_body,\n                child->ruleset->phase_request_body);\n            apr_array_cat(merged->ruleset->phase_response_headers,\n                child->ruleset->phase_response_headers);\n            apr_array_cat(merged->ruleset->phase_response_body,\n                child->ruleset->phase_response_body);\n            apr_array_cat(merged->ruleset->phase_logging,\n                child->ruleset->phase_logging);\n        }\n    } else {\n        merged->rule_inheritance = 0;\n        if (child->ruleset != NULL) {\n            /* Copy child rules. */\n            merged->ruleset = msre_ruleset_create(child->ruleset->engine, mp);\n            merged->ruleset->phase_request_headers = apr_array_copy(mp,\n                child->ruleset->phase_request_headers);\n            merged->ruleset->phase_request_body = apr_array_copy(mp,\n                child->ruleset->phase_request_body);\n            merged->ruleset->phase_response_headers = apr_array_copy(mp,\n                child->ruleset->phase_response_headers);\n            merged->ruleset->phase_response_body = apr_array_copy(mp,\n                child->ruleset->phase_response_body);\n            merged->ruleset->phase_logging = apr_array_copy(mp,\n                child->ruleset->phase_logging);\n        }\n    }\n\n    /* Merge rule exceptions. */\n    merged->rule_exceptions = apr_array_append(mp, parent->rule_exceptions,\n        child->rule_exceptions);\n\n    merged->hash_method = apr_array_append(mp, parent->hash_method,\n        child->hash_method);\n\n    /* audit log variables */\n    merged->auditlog_flag = (child->auditlog_flag == NOT_SET\n        ? parent->auditlog_flag : child->auditlog_flag);\n    merged->auditlog_type = (child->auditlog_type == NOT_SET\n        ? parent->auditlog_type : child->auditlog_type);\n    merged->max_rule_time = (child->max_rule_time == NOT_SET\n        ? parent->max_rule_time : child->max_rule_time);\n    merged->auditlog_dirperms = (child->auditlog_dirperms == NOT_SET\n        ? parent->auditlog_dirperms : child->auditlog_dirperms);\n    merged->auditlog_fileperms = (child->auditlog_fileperms == NOT_SET\n        ? parent->auditlog_fileperms : child->auditlog_fileperms);\n    if (child->auditlog_fd != NOT_SET_P) {\n        merged->auditlog_fd = child->auditlog_fd;\n        merged->auditlog_name = child->auditlog_name;\n    } else {\n        merged->auditlog_fd = parent->auditlog_fd;\n        merged->auditlog_name = parent->auditlog_name;\n    }\n    if (child->auditlog2_fd != NOT_SET_P) {\n        merged->auditlog2_fd = child->auditlog2_fd;\n        merged->auditlog2_name = child->auditlog2_name;\n    } else {\n        merged->auditlog2_fd = parent->auditlog2_fd;\n        merged->auditlog2_name = parent->auditlog2_name;\n    }\n    merged->auditlog_storage_dir = (child->auditlog_storage_dir == NOT_SET_P\n        ? parent->auditlog_storage_dir : child->auditlog_storage_dir);\n    merged->auditlog_parts = (child->auditlog_parts == NOT_SET_P\n        ? parent->auditlog_parts : child->auditlog_parts);\n    merged->auditlog_relevant_regex = (child->auditlog_relevant_regex == NOT_SET_P\n        ? parent->auditlog_relevant_regex : child->auditlog_relevant_regex);\n\n    /* Upload */\n    merged->tmp_dir = (child->tmp_dir == NOT_SET_P\n        ? parent->tmp_dir : child->tmp_dir);\n    merged->upload_dir = (child->upload_dir == NOT_SET_P\n        ? parent->upload_dir : child->upload_dir);\n    merged->upload_keep_files = (child->upload_keep_files == NOT_SET\n        ? parent->upload_keep_files : child->upload_keep_files);\n    merged->upload_validates_files = (child->upload_validates_files == NOT_SET\n        ? parent->upload_validates_files : child->upload_validates_files);\n    merged->upload_filemode = (child->upload_filemode == NOT_SET\n        ? parent->upload_filemode : child->upload_filemode);\n    merged->upload_file_limit = (child->upload_file_limit == NOT_SET\n        ? parent->upload_file_limit : child->upload_file_limit);\n\n    /* Misc */\n    merged->data_dir = (child->data_dir == NOT_SET_P\n        ? parent->data_dir : child->data_dir);\n    merged->webappid = (child->webappid == NOT_SET_P\n        ? parent->webappid : child->webappid);\n    merged->sensor_id = (child->sensor_id == NOT_SET_P\n        ? parent->sensor_id : child->sensor_id);\n    merged->httpBlkey = (child->httpBlkey == NOT_SET_P\n        ? parent->httpBlkey : child->httpBlkey);\n\n    /* Content injection. */\n    merged->content_injection_enabled = (child->content_injection_enabled == NOT_SET\n        ? parent->content_injection_enabled : child->content_injection_enabled);\n\n    /* Stream inspection */\n    merged->stream_inbody_inspection = (child->stream_inbody_inspection == NOT_SET\n        ? parent->stream_inbody_inspection : child->stream_inbody_inspection);\n    merged->stream_outbody_inspection = (child->stream_outbody_inspection == NOT_SET\n        ? parent->stream_outbody_inspection : child->stream_outbody_inspection);\n\n    /* Geo Lookup */\n    merged->geo = (child->geo == NOT_SET_P\n        ? parent->geo : child->geo);\n\n    /* Gsb Lookup */\n    merged->gsb = (child->gsb == NOT_SET_P\n        ? parent->gsb : child->gsb);\n\n    /* Unicode Map */\n    merged->u_map = (child->u_map == NOT_SET_P\n        ? parent->u_map : child->u_map);\n\n    /* Cache */\n    merged->cache_trans = (child->cache_trans == NOT_SET\n        ? parent->cache_trans : child->cache_trans);\n    merged->cache_trans_incremental = (child->cache_trans_incremental == NOT_SET\n        ? parent->cache_trans_incremental : child->cache_trans_incremental);\n    merged->cache_trans_min = (child->cache_trans_min == (apr_size_t)NOT_SET\n        ? parent->cache_trans_min : child->cache_trans_min);\n    merged->cache_trans_max = (child->cache_trans_max == (apr_size_t)NOT_SET\n        ? parent->cache_trans_max : child->cache_trans_max);\n    merged->cache_trans_maxitems = (child->cache_trans_maxitems == (apr_size_t)NOT_SET\n        ? parent->cache_trans_maxitems : child->cache_trans_maxitems);\n\n    /* Merge component signatures. */\n    merged->component_signatures = apr_array_append(mp, parent->component_signatures,\n        child->component_signatures);\n\n    merged->request_encoding = (child->request_encoding == NOT_SET_P\n        ? parent->request_encoding : child->request_encoding);\n\n    merged->disable_backend_compression = (child->disable_backend_compression == NOT_SET\n        ? parent->disable_backend_compression : child->disable_backend_compression);\n\n    merged->col_timeout = (child->col_timeout == NOT_SET\n        ? parent->col_timeout : child->col_timeout);\n\n    /* Hash */\n    merged->crypto_key = (child->crypto_key == NOT_SET_P\n        ? parent->crypto_key : child->crypto_key);\n    merged->crypto_key_len = (child->crypto_key_len == NOT_SET\n        ? parent->crypto_key_len : child->crypto_key_len);\n    merged->crypto_key_add = (child->crypto_key_add == NOT_SET\n        ? parent->crypto_key_add : child->crypto_key_add);\n    merged->crypto_param_name = (child->crypto_param_name == NOT_SET_P\n        ? parent->crypto_param_name : child->crypto_param_name);\n    merged->hash_is_enabled = (child->hash_is_enabled == NOT_SET\n        ? parent->hash_is_enabled : child->hash_is_enabled);\n    merged->hash_enforcement = (child->hash_enforcement == NOT_SET\n        ? parent->hash_enforcement : child->hash_enforcement);\n    merged->crypto_hash_href_rx = (child->crypto_hash_href_rx == NOT_SET\n        ? parent->crypto_hash_href_rx : child->crypto_hash_href_rx);\n    merged->crypto_hash_faction_rx = (child->crypto_hash_faction_rx == NOT_SET\n        ? parent->crypto_hash_faction_rx : child->crypto_hash_faction_rx);\n    merged->crypto_hash_location_rx = (child->crypto_hash_location_rx == NOT_SET\n        ? parent->crypto_hash_location_rx : child->crypto_hash_location_rx);\n    merged->crypto_hash_iframesrc_rx = (child->crypto_hash_iframesrc_rx == NOT_SET\n        ? parent->crypto_hash_iframesrc_rx : child->crypto_hash_iframesrc_rx);\n    merged->crypto_hash_framesrc_rx = (child->crypto_hash_framesrc_rx == NOT_SET\n        ? parent->crypto_hash_framesrc_rx : child->crypto_hash_framesrc_rx);\n    merged->crypto_hash_href_pm = (child->crypto_hash_href_pm == NOT_SET\n        ? parent->crypto_hash_href_pm : child->crypto_hash_href_pm);\n    merged->crypto_hash_faction_pm = (child->crypto_hash_faction_pm == NOT_SET\n        ? parent->crypto_hash_faction_pm : child->crypto_hash_faction_pm);\n    merged->crypto_hash_location_pm = (child->crypto_hash_location_pm == NOT_SET\n        ? parent->crypto_hash_location_pm : child->crypto_hash_location_pm);\n    merged->crypto_hash_iframesrc_pm = (child->crypto_hash_iframesrc_pm == NOT_SET\n        ? parent->crypto_hash_iframesrc_pm : child->crypto_hash_iframesrc_pm);\n    merged->crypto_hash_framesrc_pm = (child->crypto_hash_framesrc_pm == NOT_SET\n        ? parent->crypto_hash_framesrc_pm : child->crypto_hash_framesrc_pm);\n\n    /* xml external entity */\n    merged->xml_external_entity = (child->xml_external_entity == NOT_SET\n        ? parent->xml_external_entity : child->xml_external_entity);\n\n    return merged;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -312,5 +312,9 @@\n     merged->crypto_hash_framesrc_pm = (child->crypto_hash_framesrc_pm == NOT_SET\n         ? parent->crypto_hash_framesrc_pm : child->crypto_hash_framesrc_pm);\n \n+    /* xml external entity */\n+    merged->xml_external_entity = (child->xml_external_entity == NOT_SET\n+        ? parent->xml_external_entity : child->xml_external_entity);\n+\n     return merged;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* xml external entity */",
                "    merged->xml_external_entity = (child->xml_external_entity == NOT_SET",
                "        ? parent->xml_external_entity : child->xml_external_entity);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1915",
        "func_name": "owasp-modsecurity/ModSecurity/create_directory_config",
        "description": "ModSecurity before 2.7.3 allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via an XML external entity declaration in conjunction with an entity reference, aka an XML External Entity (XXE) vulnerability.",
        "git_url": "https://github.com/owasp-modsecurity/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "commit_title": "Added SecXmlExternalEntity",
        "commit_text": "",
        "func_before": "void *create_directory_config(apr_pool_t *mp, char *path)\n{\n    directory_config *dcfg = (directory_config *)apr_pcalloc(mp, sizeof(directory_config));\n    if (dcfg == NULL) return NULL;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Created directory config %pp path %s\", dcfg, path);\n    #endif\n\n    dcfg->mp = mp;\n    dcfg->is_enabled = NOT_SET;\n\n    dcfg->reqbody_access = NOT_SET;\n    dcfg->reqintercept_oe = NOT_SET;\n    dcfg->reqbody_buffering = NOT_SET;\n    dcfg->reqbody_inmemory_limit = NOT_SET;\n    dcfg->reqbody_limit = NOT_SET;\n    dcfg->reqbody_no_files_limit = NOT_SET;\n    dcfg->resbody_access = NOT_SET;\n\n    dcfg->debuglog_name = NOT_SET_P;\n    dcfg->debuglog_level = NOT_SET;\n    dcfg->debuglog_fd = NOT_SET_P;\n\n    dcfg->of_limit = NOT_SET;\n    dcfg->if_limit_action = NOT_SET;\n    dcfg->of_limit_action = NOT_SET;\n    dcfg->of_mime_types = NOT_SET_P;\n    dcfg->of_mime_types_cleared = NOT_SET;\n\n    dcfg->cookie_format = NOT_SET;\n    dcfg->argument_separator = NOT_SET;\n    dcfg->cookiev0_separator = NOT_SET_P;\n\n    dcfg->rule_inheritance = NOT_SET;\n    dcfg->rule_exceptions = apr_array_make(mp, 16, sizeof(rule_exception *));\n    dcfg->hash_method = apr_array_make(mp, 16, sizeof(hash_method *));\n\n    /* audit log variables */\n    dcfg->auditlog_flag = NOT_SET;\n    dcfg->auditlog_type = NOT_SET;\n    dcfg->max_rule_time = NOT_SET;\n    dcfg->auditlog_dirperms = NOT_SET;\n    dcfg->auditlog_fileperms = NOT_SET;\n    dcfg->auditlog_name = NOT_SET_P;\n    dcfg->auditlog2_name = NOT_SET_P;\n    dcfg->auditlog_fd = NOT_SET_P;\n    dcfg->auditlog2_fd = NOT_SET_P;\n    dcfg->auditlog_storage_dir = NOT_SET_P;\n    dcfg->auditlog_parts = NOT_SET_P;\n    dcfg->auditlog_relevant_regex = NOT_SET_P;\n\n    dcfg->ruleset = NULL;\n\n    /* Upload */\n    dcfg->tmp_dir = NOT_SET_P;\n    dcfg->upload_dir = NOT_SET_P;\n    dcfg->upload_keep_files = NOT_SET;\n    dcfg->upload_validates_files = NOT_SET;\n    dcfg->upload_filemode = NOT_SET;\n    dcfg->upload_file_limit = NOT_SET;\n\n    /* These are only used during the configuration process. */\n    dcfg->tmp_chain_starter = NULL;\n    dcfg->tmp_default_actionset = NULL;\n    dcfg->tmp_rule_placeholders = NULL;\n\n    /* Misc */\n    dcfg->data_dir = NOT_SET_P;\n    dcfg->webappid = NOT_SET_P;\n    dcfg->sensor_id = NOT_SET_P;\n    dcfg->httpBlkey = NOT_SET_P;\n\n    /* Content injection. */\n    dcfg->content_injection_enabled = NOT_SET;\n\n    /* Stream inspection */\n    dcfg->stream_inbody_inspection = NOT_SET;\n    dcfg->stream_outbody_inspection = NOT_SET;\n\n    /* Geo Lookups */\n    dcfg->geo = NOT_SET_P;\n\n    /* Gsb Lookups */\n    dcfg->gsb = NOT_SET_P;\n\n    /* Unicode Map */\n    dcfg->u_map = NOT_SET_P;\n\n    /* Cache */\n    dcfg->cache_trans = NOT_SET;\n    dcfg->cache_trans_incremental = NOT_SET;\n    dcfg->cache_trans_min = NOT_SET;\n    dcfg->cache_trans_max = NOT_SET;\n    dcfg->cache_trans_maxitems = NOT_SET;\n\n    /* Rule ids */\n    dcfg->rule_id_htab = apr_hash_make(mp);\n    dcfg->component_signatures = apr_array_make(mp, 16, sizeof(char *));\n\n    dcfg->request_encoding = NOT_SET_P;\n    dcfg->disable_backend_compression = NOT_SET;\n\n    /* Collection timeout */\n    dcfg->col_timeout = NOT_SET;\n\n    dcfg->crypto_key = NOT_SET_P;\n    dcfg->crypto_key_len = NOT_SET;\n    dcfg->crypto_key_add = NOT_SET;\n    dcfg->crypto_param_name = NOT_SET_P;\n    dcfg->hash_is_enabled = NOT_SET;\n    dcfg->hash_enforcement = NOT_SET;\n    dcfg->crypto_hash_href_rx = NOT_SET;\n    dcfg->crypto_hash_faction_rx = NOT_SET;\n    dcfg->crypto_hash_location_rx = NOT_SET;\n    dcfg->crypto_hash_iframesrc_rx = NOT_SET;\n    dcfg->crypto_hash_framesrc_rx = NOT_SET;\n    dcfg->crypto_hash_href_pm = NOT_SET;\n    dcfg->crypto_hash_faction_pm = NOT_SET;\n    dcfg->crypto_hash_location_pm = NOT_SET;\n    dcfg->crypto_hash_iframesrc_pm = NOT_SET;\n    dcfg->crypto_hash_framesrc_pm = NOT_SET;\n\n\n    return dcfg;\n}",
        "func": "void *create_directory_config(apr_pool_t *mp, char *path)\n{\n    directory_config *dcfg = (directory_config *)apr_pcalloc(mp, sizeof(directory_config));\n    if (dcfg == NULL) return NULL;\n\n    #ifdef DEBUG_CONF\n    ap_log_perror(APLOG_MARK, APLOG_STARTUP|APLOG_NOERRNO, 0, mp, \"Created directory config %pp path %s\", dcfg, path);\n    #endif\n\n    dcfg->mp = mp;\n    dcfg->is_enabled = NOT_SET;\n\n    dcfg->reqbody_access = NOT_SET;\n    dcfg->reqintercept_oe = NOT_SET;\n    dcfg->reqbody_buffering = NOT_SET;\n    dcfg->reqbody_inmemory_limit = NOT_SET;\n    dcfg->reqbody_limit = NOT_SET;\n    dcfg->reqbody_no_files_limit = NOT_SET;\n    dcfg->resbody_access = NOT_SET;\n\n    dcfg->debuglog_name = NOT_SET_P;\n    dcfg->debuglog_level = NOT_SET;\n    dcfg->debuglog_fd = NOT_SET_P;\n\n    dcfg->of_limit = NOT_SET;\n    dcfg->if_limit_action = NOT_SET;\n    dcfg->of_limit_action = NOT_SET;\n    dcfg->of_mime_types = NOT_SET_P;\n    dcfg->of_mime_types_cleared = NOT_SET;\n\n    dcfg->cookie_format = NOT_SET;\n    dcfg->argument_separator = NOT_SET;\n    dcfg->cookiev0_separator = NOT_SET_P;\n\n    dcfg->rule_inheritance = NOT_SET;\n    dcfg->rule_exceptions = apr_array_make(mp, 16, sizeof(rule_exception *));\n    dcfg->hash_method = apr_array_make(mp, 16, sizeof(hash_method *));\n\n    /* audit log variables */\n    dcfg->auditlog_flag = NOT_SET;\n    dcfg->auditlog_type = NOT_SET;\n    dcfg->max_rule_time = NOT_SET;\n    dcfg->auditlog_dirperms = NOT_SET;\n    dcfg->auditlog_fileperms = NOT_SET;\n    dcfg->auditlog_name = NOT_SET_P;\n    dcfg->auditlog2_name = NOT_SET_P;\n    dcfg->auditlog_fd = NOT_SET_P;\n    dcfg->auditlog2_fd = NOT_SET_P;\n    dcfg->auditlog_storage_dir = NOT_SET_P;\n    dcfg->auditlog_parts = NOT_SET_P;\n    dcfg->auditlog_relevant_regex = NOT_SET_P;\n\n    dcfg->ruleset = NULL;\n\n    /* Upload */\n    dcfg->tmp_dir = NOT_SET_P;\n    dcfg->upload_dir = NOT_SET_P;\n    dcfg->upload_keep_files = NOT_SET;\n    dcfg->upload_validates_files = NOT_SET;\n    dcfg->upload_filemode = NOT_SET;\n    dcfg->upload_file_limit = NOT_SET;\n\n    /* These are only used during the configuration process. */\n    dcfg->tmp_chain_starter = NULL;\n    dcfg->tmp_default_actionset = NULL;\n    dcfg->tmp_rule_placeholders = NULL;\n\n    /* Misc */\n    dcfg->data_dir = NOT_SET_P;\n    dcfg->webappid = NOT_SET_P;\n    dcfg->sensor_id = NOT_SET_P;\n    dcfg->httpBlkey = NOT_SET_P;\n\n    /* Content injection. */\n    dcfg->content_injection_enabled = NOT_SET;\n\n    /* Stream inspection */\n    dcfg->stream_inbody_inspection = NOT_SET;\n    dcfg->stream_outbody_inspection = NOT_SET;\n\n    /* Geo Lookups */\n    dcfg->geo = NOT_SET_P;\n\n    /* Gsb Lookups */\n    dcfg->gsb = NOT_SET_P;\n\n    /* Unicode Map */\n    dcfg->u_map = NOT_SET_P;\n\n    /* Cache */\n    dcfg->cache_trans = NOT_SET;\n    dcfg->cache_trans_incremental = NOT_SET;\n    dcfg->cache_trans_min = NOT_SET;\n    dcfg->cache_trans_max = NOT_SET;\n    dcfg->cache_trans_maxitems = NOT_SET;\n\n    /* Rule ids */\n    dcfg->rule_id_htab = apr_hash_make(mp);\n    dcfg->component_signatures = apr_array_make(mp, 16, sizeof(char *));\n\n    dcfg->request_encoding = NOT_SET_P;\n    dcfg->disable_backend_compression = NOT_SET;\n\n    /* Collection timeout */\n    dcfg->col_timeout = NOT_SET;\n\n    dcfg->crypto_key = NOT_SET_P;\n    dcfg->crypto_key_len = NOT_SET;\n    dcfg->crypto_key_add = NOT_SET;\n    dcfg->crypto_param_name = NOT_SET_P;\n    dcfg->hash_is_enabled = NOT_SET;\n    dcfg->hash_enforcement = NOT_SET;\n    dcfg->crypto_hash_href_rx = NOT_SET;\n    dcfg->crypto_hash_faction_rx = NOT_SET;\n    dcfg->crypto_hash_location_rx = NOT_SET;\n    dcfg->crypto_hash_iframesrc_rx = NOT_SET;\n    dcfg->crypto_hash_framesrc_rx = NOT_SET;\n    dcfg->crypto_hash_href_pm = NOT_SET;\n    dcfg->crypto_hash_faction_pm = NOT_SET;\n    dcfg->crypto_hash_location_pm = NOT_SET;\n    dcfg->crypto_hash_iframesrc_pm = NOT_SET;\n    dcfg->crypto_hash_framesrc_pm = NOT_SET;\n\n\n    /* xml external entity */\n    dcfg->xml_external_entity = NOT_SET;\n\n    return dcfg;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -122,5 +122,8 @@\n     dcfg->crypto_hash_framesrc_pm = NOT_SET;\n \n \n+    /* xml external entity */\n+    dcfg->xml_external_entity = NOT_SET;\n+\n     return dcfg;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* xml external entity */",
                "    dcfg->xml_external_entity = NOT_SET;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1915",
        "func_name": "owasp-modsecurity/ModSecurity/xml_init",
        "description": "ModSecurity before 2.7.3 allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via an XML external entity declaration in conjunction with an entity reference, aka an XML External Entity (XXE) vulnerability.",
        "git_url": "https://github.com/owasp-modsecurity/ModSecurity/commit/d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe",
        "commit_title": "Added SecXmlExternalEntity",
        "commit_text": "",
        "func_before": "int xml_init(modsec_rec *msr, char **error_msg) {\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n\n    return 1;\n}",
        "func": "int xml_init(modsec_rec *msr, char **error_msg) {\n    xmlParserInputBufferCreateFilenameFunc entity;\n\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n\n    if(msr->txcfg->xml_external_entity == 0)    {\n        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);\n    }\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,15 @@\n int xml_init(modsec_rec *msr, char **error_msg) {\n+    xmlParserInputBufferCreateFilenameFunc entity;\n+\n     if (error_msg == NULL) return -1;\n     *error_msg = NULL;\n \n     msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n     if (msr->xml == NULL) return -1;\n \n+    if(msr->txcfg->xml_external_entity == 0)    {\n+        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);\n+    }\n+\n     return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    xmlParserInputBufferCreateFilenameFunc entity;",
                "",
                "    if(msr->txcfg->xml_external_entity == 0)    {",
                "        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1824",
        "func_name": "php/php-src/soap_xmlParseFile",
        "description": "The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",
        "git_url": "https://github.com/php/php-src/commit/afe98b7829d50806559acac9b530acb8283c3bf4",
        "commit_title": "Disabled external entities loading",
        "commit_text": "",
        "func_before": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}",
        "func": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->options -= XML_PARSE_DTDLOAD;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n \tPG(allow_url_fopen) = old_allow_url_fopen;\n \tif (ctxt) {\n \t\tctxt->keepBlanks = 0;\n+\t\tctxt->options -= XML_PARSE_DTDLOAD;\n \t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n \t\tctxt->sax->comment = soap_Comment;\n \t\tctxt->sax->warning = NULL;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tctxt->options -= XML_PARSE_DTDLOAD;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1824",
        "func_name": "php/php-src/soap_xmlParseMemory",
        "description": "The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",
        "git_url": "https://github.com/php/php-src/commit/afe98b7829d50806559acac9b530acb8283c3bf4",
        "commit_title": "Disabled external entities loading",
        "commit_text": "",
        "func_before": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
        "func": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tctxt->options -= XML_PARSE_DTDLOAD;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n */\n \tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n \tif (ctxt) {\n+\t\tctxt->options -= XML_PARSE_DTDLOAD;\n \t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n \t\tctxt->sax->comment = soap_Comment;\n \t\tctxt->sax->warning = NULL;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tctxt->options -= XML_PARSE_DTDLOAD;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1824",
        "func_name": "php/php-src/soap_xmlParseFile",
        "description": "The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",
        "git_url": "https://github.com/php/php-src/commit/188c196d4da60bdde9190d2fc532650d17f7af2d",
        "commit_title": "Proper bit reset code",
        "commit_text": "",
        "func_before": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->options -= XML_PARSE_DTDLOAD;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}",
        "func": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\n/*\n\txmlInitParser();\n*/\n\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->options &= ~XML_PARSE_DTDLOAD;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \tPG(allow_url_fopen) = old_allow_url_fopen;\n \tif (ctxt) {\n \t\tctxt->keepBlanks = 0;\n-\t\tctxt->options -= XML_PARSE_DTDLOAD;\n+\t\tctxt->options &= ~XML_PARSE_DTDLOAD;\n \t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n \t\tctxt->sax->comment = soap_Comment;\n \t\tctxt->sax->warning = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tctxt->options -= XML_PARSE_DTDLOAD;"
            ],
            "added_lines": [
                "\t\tctxt->options &= ~XML_PARSE_DTDLOAD;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1824",
        "func_name": "php/php-src/soap_xmlParseMemory",
        "description": "The SOAP parser in PHP before 5.3.22 and 5.4.x before 5.4.12 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.",
        "git_url": "https://github.com/php/php-src/commit/188c196d4da60bdde9190d2fc532650d17f7af2d",
        "commit_title": "Proper bit reset code",
        "commit_text": "",
        "func_before": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tctxt->options -= XML_PARSE_DTDLOAD;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
        "func": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n*/\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tctxt->options &= ~XML_PARSE_DTDLOAD;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n */\n \tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n \tif (ctxt) {\n-\t\tctxt->options -= XML_PARSE_DTDLOAD;\n+\t\tctxt->options &= ~XML_PARSE_DTDLOAD;\n \t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n \t\tctxt->sax->comment = soap_Comment;\n \t\tctxt->sax->warning = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tctxt->options -= XML_PARSE_DTDLOAD;"
            ],
            "added_lines": [
                "\t\tctxt->options &= ~XML_PARSE_DTDLOAD;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-10082",
        "func_name": "UIKit0/libplist/plist_from_xml",
        "description": "A vulnerability classified as problematic has been found in UIKit0 libplist 1.12. This affects the function plist_from_xml of the file src/xplist.c of the component XML Handler. The manipulation leads to xml external entity reference. The patch is named c086cb139af7c82845f6d565e636073ff4b37440. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-221499.",
        "git_url": "https://github.com/UIKit0/libplist/commit/c086cb139af7c82845f6d565e636073ff4b37440",
        "commit_title": "xplist: Fix limited but possible XXE security vulnerability with XML plists",
        "commit_text": " By using a specifically crafted XML file an attacker could use plistutil to issue a GET request to an arbitrary URL or disclose a local file. The crafted XML file would be using a custom DTD with an external entity reference pointing to the file. Practical abuse is limited but let's still fix it nevertheless. Related to CVE-2013-0339 for libxml2 and CWE-827. Reported by Loc Bnis from calypt.com. Thanks!",
        "func_before": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}",
        "func": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability */\n    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);\n\n    /* read XML from memory and disable network access for security reasons */\n    xmlDocPtr plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL, XML_PARSE_NONET);\n    if (plist_doc) {\n        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n        xml_to_node(root_node, plist);\n        xmlFreeDoc(plist_doc);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,14 @@\n PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n {\n-    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n-    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n+    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability */\n+    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);\n \n-    xml_to_node(root_node, plist);\n-    xmlFreeDoc(plist_doc);\n+    /* read XML from memory and disable network access for security reasons */\n+    xmlDocPtr plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL, XML_PARSE_NONET);\n+    if (plist_doc) {\n+        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n+\n+        xml_to_node(root_node, plist);\n+        xmlFreeDoc(plist_doc);\n+    }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);",
                "    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);",
                "    xml_to_node(root_node, plist);",
                "    xmlFreeDoc(plist_doc);"
            ],
            "added_lines": [
                "    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability */",
                "    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);",
                "    /* read XML from memory and disable network access for security reasons */",
                "    xmlDocPtr plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL, XML_PARSE_NONET);",
                "    if (plist_doc) {",
                "        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);",
                "",
                "        xml_to_node(root_node, plist);",
                "        xmlFreeDoc(plist_doc);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7375",
        "func_name": "android/xmlParsePEReference",
        "description": "A flaw in libxml2 allows remote XML entity inclusion with default parser flags (i.e., when the caller did not request entity substitution, DTD validation, external DTD subset loading, or default DTD attributes). Depending on the context, this may expose a higher-risk attack surface in libxml2 not usually reachable with default parser flags, and expose content from local files, HTTP, or FTP servers (which might be otherwise unreachable).",
        "git_url": "https://android.googlesource.com/platform/external/libxml2/+/308396a55280f69ad4112d4f9892f4cbeff042aa",
        "commit_title": "DO NOT MERGE: Add validation for eternal enities",
        "commit_text": " https://bugzilla.gnome.org/show_bug.cgi?id=780691  Bug: 36556310 (cherry picked from commit bef9af3d89d241bcb518c20cba6da2a2fd9ba049) ",
        "func_before": "void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParsePEReference: no name\\n\");\n\treturn;\n    }\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t\t  \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n\t} else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\t} else {\n\t    /*\n\t     * TODO !!!\n\t     * handle the extra spaces added before and after\n\t     * c.f. http://www.w3.org/TR/REC-xml#as-PE\n\t     */\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t\t(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n\t\t(IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n\t\tif (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t    /*\n\t\t     * The XML REC instructs us to stop parsing\n\t\t     * right here\n\t\t     */\n\t\t    xmlHaltParser(ctxt);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}",
        "func": "void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParsePEReference: no name\\n\");\n\treturn;\n    }\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t\t  \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n\t} else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\t} else {\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n\t        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n\t        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n\t        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n\t        (ctxt->replaceEntities == 0) &&\n\t        (ctxt->validate == 0))\n\t        return;\n\t    /*\n\t     * TODO !!!\n\t     * handle the extra spaces added before and after\n\t     * c.f. http://www.w3.org/TR/REC-xml#as-PE\n\t     */\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t\t(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n\t\t(IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n\t\tif (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t    /*\n\t\t     * The XML REC instructs us to stop parsing\n\t\t     * right here\n\t\t     */\n\t\t    xmlHaltParser(ctxt);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,14 @@\n \t    if (xmlPushInput(ctxt, input) < 0)\n \t\treturn;\n \t} else {\n+\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n+\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n+\t        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n+\t        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n+\t        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n+\t        (ctxt->replaceEntities == 0) &&\n+\t        (ctxt->validate == 0))\n+\t        return;\n \t    /*\n \t     * TODO !!!\n \t     * handle the extra spaces added before and after",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&",
                "\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&",
                "\t        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&",
                "\t        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&",
                "\t        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&",
                "\t        (ctxt->replaceEntities == 0) &&",
                "\t        (ctxt->validate == 0))",
                "\t        return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7375",
        "func_name": "GNOME/libxml2/xmlParsePEReference",
        "description": "A flaw in libxml2 allows remote XML entity inclusion with default parser flags (i.e., when the caller did not request entity substitution, DTD validation, external DTD subset loading, or default DTD attributes). Depending on the context, this may expose a higher-risk attack surface in libxml2 not usually reachable with default parser flags, and expose content from local files, HTTP, or FTP servers (which might be otherwise unreachable).",
        "git_url": "https://github.com/GNOME/libxml2/commit/90ccb58242866b0ba3edbef8fe44214a101c2b3e",
        "commit_title": "Prevent unwanted external entity reference",
        "commit_text": " For https://bugzilla.gnome.org/show_bug.cgi?id=780691  * parser.c: add a specific check to avoid PE reference",
        "func_before": "void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParsePEReference: no name\\n\");\n\treturn;\n    }\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t\t  \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n\t} else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\t} else {\n\t    /*\n\t     * TODO !!!\n\t     * handle the extra spaces added before and after\n\t     * c.f. http://www.w3.org/TR/REC-xml#as-PE\n\t     */\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t\t(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n\t\t(IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n\t\tif (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t    /*\n\t\t     * The XML REC instructs us to stop parsing\n\t\t     * right here\n\t\t     */\n\t\t    xmlHaltParser(ctxt);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}",
        "func": "void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParsePEReference: no name\\n\");\n\treturn;\n    }\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t\t  \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n\t} else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\t} else {\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n\t\t(ctxt->replaceEntities == 0) &&\n\t\t(ctxt->validate == 0))\n\t\treturn;\n\n\t    /*\n\t     * TODO !!!\n\t     * handle the extra spaces added before and after\n\t     * c.f. http://www.w3.org/TR/REC-xml#as-PE\n\t     */\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t\t(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n\t\t(IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n\t\tif (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t    /*\n\t\t     * The XML REC instructs us to stop parsing\n\t\t     * right here\n\t\t     */\n\t\t    xmlHaltParser(ctxt);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,15 @@\n \t    if (xmlPushInput(ctxt, input) < 0)\n \t\treturn;\n \t} else {\n+\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n+\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n+\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n+\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n+\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n+\t\t(ctxt->replaceEntities == 0) &&\n+\t\t(ctxt->validate == 0))\n+\t\treturn;\n+\n \t    /*\n \t     * TODO !!!\n \t     * handle the extra spaces added before and after",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&",
                "\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&",
                "\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&",
                "\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&",
                "\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&",
                "\t\t(ctxt->replaceEntities == 0) &&",
                "\t\t(ctxt->validate == 0))",
                "\t\treturn;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26247",
        "func_name": "sparklemotion/nokogiri/init_xml_relax_ng",
        "description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "commit_title": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions",
        "commit_text": " I'm trying out a new pattern, which is that the parsed object carries around the ParseOptions it was created with, which should make some testing a bit easier.  I'm also not implementing the \"config block\" pattern in use for Documents, because I think the UX is weird and I'm hoping to change everything to use kwargs in a 2.0 release, anyway.",
        "func_before": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n\n  cNokogiriXmlRelaxNG = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}",
        "func": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n\n  cNokogiriXmlRelaxNG = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n   cNokogiriXmlRelaxNG = klass;\n \n-  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n-  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n+  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n+  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n   rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);",
                "  rb_define_singleton_method(klass, \"from_document\", from_document, 1);"
            ],
            "added_lines": [
                "  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);",
                "  rb_define_singleton_method(klass, \"from_document\", from_document, -1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26247",
        "func_name": "sparklemotion/nokogiri/from_document",
        "description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "commit_title": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions",
        "commit_text": " I'm trying out a new pattern, which is that the parsed object carries around the ParseOptions it was created with, which should make some testing a bit easier.  I'm also not implementing the \"config block\" pattern in use for Documents, because I think the UX is weird and I'm hoping to change everything to use kwargs in a 2.0 release, anyway.",
        "func_before": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  /* In case someone passes us a node. ugh. */\n  doc = doc->doc;\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
        "func": "static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; /* In case someone passes us a node. ugh. */\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,22 @@\n-static VALUE from_document(VALUE klass, VALUE document)\n+static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n {\n+  VALUE document;\n+  VALUE parse_options;\n   xmlDocPtr doc;\n   xmlRelaxNGParserCtxtPtr ctx;\n   xmlRelaxNGPtr schema;\n   VALUE errors;\n   VALUE rb_schema;\n+  int scanned_args = 0;\n+\n+  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n \n   Data_Get_Struct(document, xmlDoc, doc);\n+  doc = doc->doc; /* In case someone passes us a node. ugh. */\n \n-  /* In case someone passes us a node. ugh. */\n-  doc = doc->doc;\n+  if (scanned_args == 1) {\n+    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n+  }\n \n   ctx = xmlRelaxNGNewDocParserCtxt(doc);\n \n@@ -41,6 +48,7 @@\n \n   rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n   rb_iv_set(rb_schema, \"@errors\", errors);\n+  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n \n   return rb_schema;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static VALUE from_document(VALUE klass, VALUE document)",
                "  /* In case someone passes us a node. ugh. */",
                "  doc = doc->doc;"
            ],
            "added_lines": [
                "static VALUE from_document(int argc, VALUE *argv, VALUE klass)",
                "  VALUE document;",
                "  VALUE parse_options;",
                "  int scanned_args = 0;",
                "",
                "  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);",
                "  doc = doc->doc; /* In case someone passes us a node. ugh. */",
                "  if (scanned_args == 1) {",
                "    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));",
                "  }",
                "  rb_iv_set(rb_schema, \"@parse_options\", parse_options);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26247",
        "func_name": "sparklemotion/nokogiri/read_memory",
        "description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "commit_title": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions",
        "commit_text": " I'm trying out a new pattern, which is that the parsed object carries around the ParseOptions it was created with, which should make some testing a bit easier.  I'm also not implementing the \"config block\" pattern in use for Documents, because I think the UX is weird and I'm hoping to change everything to use kwargs in a 2.0 release, anyway.",
        "func_before": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  xmlRelaxNGPtr schema;\n  VALUE errors = rb_ary_new();\n  VALUE rb_schema;\n\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
        "func": "static VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,21 @@\n-static VALUE read_memory(VALUE klass, VALUE content)\n+static VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n {\n-  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n-      (const char *)StringValuePtr(content),\n-      (int)RSTRING_LEN(content)\n-  );\n+  VALUE content;\n+  VALUE parse_options;\n+  xmlRelaxNGParserCtxtPtr ctx;\n   xmlRelaxNGPtr schema;\n-  VALUE errors = rb_ary_new();\n+  VALUE errors;\n   VALUE rb_schema;\n+  int scanned_args = 0;\n \n+  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n+  if (scanned_args == 1) {\n+    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n+  }\n+\n+  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n+\n+  errors = rb_ary_new();\n   xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n \n #ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n@@ -35,6 +43,7 @@\n \n   rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n   rb_iv_set(rb_schema, \"@errors\", errors);\n+  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n \n   return rb_schema;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static VALUE read_memory(VALUE klass, VALUE content)",
                "  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(",
                "      (const char *)StringValuePtr(content),",
                "      (int)RSTRING_LEN(content)",
                "  );",
                "  VALUE errors = rb_ary_new();"
            ],
            "added_lines": [
                "static VALUE read_memory(int argc, VALUE *argv, VALUE klass)",
                "  VALUE content;",
                "  VALUE parse_options;",
                "  xmlRelaxNGParserCtxtPtr ctx;",
                "  VALUE errors;",
                "  int scanned_args = 0;",
                "  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);",
                "  if (scanned_args == 1) {",
                "    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));",
                "  }",
                "",
                "  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));",
                "",
                "  errors = rb_ary_new();",
                "  rb_iv_set(rb_schema, \"@parse_options\", parse_options);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26247",
        "func_name": "sparklemotion/nokogiri/init_xml_schema",
        "description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "commit_title": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions",
        "commit_text": " I'm trying out a new pattern, which is that the parsed object carries around the ParseOptions it was created with, which should make some testing a bit easier.  I'm also not implementing the \"config block\" pattern in use for Documents, because I think the UX is weird and I'm hoping to change everything to use kwargs in a 2.0 release, anyway.",
        "func_before": "void init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n\n  cNokogiriXmlSchema = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}",
        "func": "void init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n\n  cNokogiriXmlSchema = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,8 @@\n \n   cNokogiriXmlSchema = klass;\n \n-  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n-  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n+  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n+  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n \n   rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n   rb_define_private_method(klass, \"validate_file\",     validate_file, 1);",
        "diff_line_info": {
            "deleted_lines": [
                "  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);",
                "  rb_define_singleton_method(klass, \"from_document\", from_document, 1);"
            ],
            "added_lines": [
                "  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);",
                "  rb_define_singleton_method(klass, \"from_document\", from_document, -1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26247",
        "func_name": "sparklemotion/nokogiri/from_document",
        "description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "commit_title": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions",
        "commit_text": " I'm trying out a new pattern, which is that the parsed object carries around the ParseOptions it was created with, which should make some testing a bit easier.  I'm also not implementing the \"config block\" pattern in use for Documents, because I think the UX is weird and I'm hoping to change everything to use kwargs in a 2.0 release, anyway.",
        "func_before": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  /* In case someone passes us a node. ugh. */\n  doc = doc->doc;\n\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n\n  return Qnil;\n}",
        "func": "static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  int parse_options_int;\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; /* In case someone passes us a node. ugh. */\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n\n  return Qnil;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,24 @@\n-static VALUE from_document(VALUE klass, VALUE document)\n+static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n {\n+  VALUE document;\n+  VALUE parse_options;\n+  int parse_options_int;\n   xmlDocPtr doc;\n   xmlSchemaParserCtxtPtr ctx;\n   xmlSchemaPtr schema;\n   VALUE errors;\n   VALUE rb_schema;\n+  int scanned_args = 0;\n+\n+  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n \n   Data_Get_Struct(document, xmlDoc, doc);\n+  doc = doc->doc; /* In case someone passes us a node. ugh. */\n \n-  /* In case someone passes us a node. ugh. */\n-  doc = doc->doc;\n+  if (scanned_args == 1) {\n+    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n+  }\n+  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n \n   if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n     rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n@@ -45,6 +54,7 @@\n \n   rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n   rb_iv_set(rb_schema, \"@errors\", errors);\n+  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n \n   return rb_schema;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "static VALUE from_document(VALUE klass, VALUE document)",
                "  /* In case someone passes us a node. ugh. */",
                "  doc = doc->doc;"
            ],
            "added_lines": [
                "static VALUE from_document(int argc, VALUE *argv, VALUE klass)",
                "  VALUE document;",
                "  VALUE parse_options;",
                "  int parse_options_int;",
                "  int scanned_args = 0;",
                "",
                "  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);",
                "  doc = doc->doc; /* In case someone passes us a node. ugh. */",
                "  if (scanned_args == 1) {",
                "    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));",
                "  }",
                "  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));",
                "  rb_iv_set(rb_schema, \"@parse_options\", parse_options);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26247",
        "func_name": "sparklemotion/nokogiri/read_memory",
        "description": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b",
        "commit_title": "feat: XML::Schema and RelaxNG creation accept optional ParseOptions",
        "commit_text": " I'm trying out a new pattern, which is that the parsed object carries around the ParseOptions it was created with, which should make some testing a bit easier.  I'm also not implementing the \"config block\" pattern in use for Documents, because I think the UX is weird and I'm hoping to change everything to use kwargs in a 2.0 release, anyway.",
        "func_before": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n   schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
        "func": "static VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  int parse_options_int;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n\n  ctx = xmlSchemaNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n    );\n#endif\n\n   schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,23 @@\n-static VALUE read_memory(VALUE klass, VALUE content)\n+static VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n {\n+  VALUE content;\n+  VALUE parse_options;\n+  int parse_options_int;\n+  xmlSchemaParserCtxtPtr ctx;\n   xmlSchemaPtr schema;\n-  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n-      (const char *)StringValuePtr(content),\n-      (int)RSTRING_LEN(content)\n-  );\n+  VALUE errors;\n   VALUE rb_schema;\n-  VALUE errors = rb_ary_new();\n+  int scanned_args = 0;\n+\n+  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n+  if (scanned_args == 1) {\n+    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n+  }\n+  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n+\n+  ctx = xmlSchemaNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n+\n+  errors = rb_ary_new();\n   xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n \n #ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n@@ -14,7 +25,7 @@\n     ctx,\n     Nokogiri_error_array_pusher,\n     (void *)errors\n-  );\n+    );\n #endif\n \n    schema = xmlSchemaParse(ctx);\n@@ -34,6 +45,7 @@\n \n   rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n   rb_iv_set(rb_schema, \"@errors\", errors);\n+  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n \n   return rb_schema;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static VALUE read_memory(VALUE klass, VALUE content)",
                "  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(",
                "      (const char *)StringValuePtr(content),",
                "      (int)RSTRING_LEN(content)",
                "  );",
                "  VALUE errors = rb_ary_new();",
                "  );"
            ],
            "added_lines": [
                "static VALUE read_memory(int argc, VALUE *argv, VALUE klass)",
                "  VALUE content;",
                "  VALUE parse_options;",
                "  int parse_options_int;",
                "  xmlSchemaParserCtxtPtr ctx;",
                "  VALUE errors;",
                "  int scanned_args = 0;",
                "",
                "  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);",
                "  if (scanned_args == 1) {",
                "    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));",
                "  }",
                "  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));",
                "",
                "  ctx = xmlSchemaNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));",
                "",
                "  errors = rb_ary_new();",
                "    );",
                "  rb_iv_set(rb_schema, \"@parse_options\", parse_options);"
            ]
        }
    }
]