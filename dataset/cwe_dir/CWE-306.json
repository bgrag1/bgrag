[
    {
        "cve_id": "CVE-2021-41104",
        "func_name": "esphome/set_auth_username",
        "description": "ESPHome is a system to control the ESP8266/ESP32. Anyone with web_server enabled and HTTP basic auth configured on version 2021.9.1 or older is vulnerable to an issue in which `web_server` allows over-the-air (OTA) updates without checking user defined basic auth username & password. This issue is patched in version 2021.9.2. As a workaround, one may disable or remove `web_server`.",
        "git_url": "https://github.com/esphome/esphome/commit/207cde1667d8c799a197b78ca8a5a14de8d5ca1e",
        "commit_title": "Fix lint issues in web_server_base",
        "commit_text": "",
        "func_before": "void set_auth_username(std::string auth_username) { credentials_.username = auth_username; }",
        "func": "void set_auth_username(std::string auth_username) { credentials_.username = std::move(auth_username); }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1 +1 @@\n-void set_auth_username(std::string auth_username) { credentials_.username = auth_username; }\n+void set_auth_username(std::string auth_username) { credentials_.username = std::move(auth_username); }",
        "diff_line_info": {
            "deleted_lines": [
                "void set_auth_username(std::string auth_username) { credentials_.username = auth_username; }"
            ],
            "added_lines": [
                "void set_auth_username(std::string auth_username) { credentials_.username = std::move(auth_username); }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41104",
        "func_name": "esphome/set_auth_password",
        "description": "ESPHome is a system to control the ESP8266/ESP32. Anyone with web_server enabled and HTTP basic auth configured on version 2021.9.1 or older is vulnerable to an issue in which `web_server` allows over-the-air (OTA) updates without checking user defined basic auth username & password. This issue is patched in version 2021.9.2. As a workaround, one may disable or remove `web_server`.",
        "git_url": "https://github.com/esphome/esphome/commit/207cde1667d8c799a197b78ca8a5a14de8d5ca1e",
        "commit_title": "Fix lint issues in web_server_base",
        "commit_text": "",
        "func_before": "void set_auth_password(std::string auth_password) { credentials_.password = auth_password; }",
        "func": "void set_auth_password(std::string auth_password) { credentials_.password = std::move(auth_password); }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1 +1 @@\n-void set_auth_password(std::string auth_password) { credentials_.password = auth_password; }\n+void set_auth_password(std::string auth_password) { credentials_.password = std::move(auth_password); }",
        "diff_line_info": {
            "deleted_lines": [
                "void set_auth_password(std::string auth_password) { credentials_.password = auth_password; }"
            ],
            "added_lines": [
                "void set_auth_password(std::string auth_password) { credentials_.password = std::move(auth_password); }"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7271",
        "func_name": "sddm/Greeter::start",
        "description": "Simple Desktop Display Manager (SDDM) before 0.10.0 allows local users to log in as user \"sddm\" without authentication.",
        "git_url": "https://github.com/sddm/sddm/commit/71b921d9304cdfae47bcd587bf0b6b1dd971c8f3",
        "commit_title": "Never try to login as the user SDDM",
        "commit_text": "",
        "func_before": "bool Greeter::start() {\n        // check flag\n        if (m_started)\n            return false;\n\n        if (daemonApp->testing()) {\n            // create process\n            m_process = new QProcess(this);\n\n            // delete process on finish\n            connect(m_process, SIGNAL(finished(int,QProcess::ExitStatus)), this, SLOT(finished()));\n\n            connect(m_process, SIGNAL(readyReadStandardOutput()), SLOT(onReadyReadStandardOutput()));\n            connect(m_process, SIGNAL(readyReadStandardError()), SLOT(onReadyReadStandardError()));\n\n            // log message\n            qDebug() << \"Greeter starting...\";\n\n            // set process environment\n            QProcessEnvironment env = QProcessEnvironment::systemEnvironment();\n            env.insert(\"DISPLAY\", m_display->name());\n            env.insert(\"XAUTHORITY\", m_authPath);\n            env.insert(\"XCURSOR_THEME\", mainConfig.Theme.CursorTheme.get());\n            m_process->setProcessEnvironment(env);\n\n            // start greeter\n            QStringList args;\n            if (daemonApp->testing())\n                args << \"--test-mode\";\n            args << \"--socket\" << m_socket\n                 << \"--theme\" << m_theme;\n            m_process->start(QString(\"%1/sddm-greeter\").arg(BIN_INSTALL_DIR), args);\n\n            //if we fail to start bail immediately, and don't block in waitForStarted\n            if (m_process->state() == QProcess::NotRunning) {\n                qCritical() << \"Greeter failed to launch.\";\n                return false;\n            }\n            // wait for greeter to start\n            if (!m_process->waitForStarted()) {\n                // log message\n                qCritical() << \"Failed to start greeter.\";\n\n                // return fail\n                return false;\n            }\n\n            // log message\n            qDebug() << \"Greeter started.\";\n\n            // set flag\n            m_started = true;\n        } else {\n            // authentication\n            m_auth = new Auth(this);\n            m_auth->setVerbose(true);\n            connect(m_auth, SIGNAL(requestChanged()), this, SLOT(onRequestChanged()));\n            connect(m_auth, SIGNAL(session(bool)), this, SLOT(onSessionStarted(bool)));\n            connect(m_auth, SIGNAL(finished(Auth::HelperExitStatus)), this, SLOT(onHelperFinished(Auth::HelperExitStatus)));\n            connect(m_auth, SIGNAL(info(QString,Auth::Info)), this, SLOT(authInfo(QString,Auth::Info)));\n            connect(m_auth, SIGNAL(error(QString,Auth::Error)), this, SLOT(authError(QString,Auth::Error)));\n\n            // greeter command\n            QStringList args;\n            args << QString(\"%1/sddm-greeter\").arg(BIN_INSTALL_DIR);\n            args << \"--socket\" << m_socket\n                 << \"--theme\" << m_theme;\n\n            // greeter environment\n            QProcessEnvironment env;\n            env.insert(\"PATH\", mainConfig.Users.DefaultPath.get());\n            env.insert(\"DISPLAY\", m_display->name());\n            env.insert(\"XAUTHORITY\", m_authPath);\n            env.insert(\"XCURSOR_THEME\", mainConfig.Theme.CursorTheme.get());\n            env.insert(\"XDG_SEAT\", m_display->seat()->name());\n            env.insert(\"XDG_SEAT_PATH\", daemonApp->displayManager()->seatPath(m_display->seat()->name()));\n            env.insert(\"XDG_SESSION_PATH\", daemonApp->displayManager()->sessionPath(QString(\"Session%1\").arg(daemonApp->newSessionId())));\n            env.insert(\"XDG_VTNR\", QString::number(m_display->terminalId()));\n            env.insert(\"XDG_SESSION_CLASS\", \"greeter\");\n            env.insert(\"XDG_SESSION_TYPE\", m_display->sessionType());\n            m_auth->insertEnvironment(env);\n\n            // log message\n            qDebug() << \"Greeter starting...\";\n\n            // start greeter\n            m_auth->setUser(\"sddm\");\n            m_auth->setSession(args.join(\" \"));\n            m_auth->start();\n        }\n\n        // return success\n        return true;\n    }",
        "func": "bool Greeter::start() {\n        // check flag\n        if (m_started)\n            return false;\n\n        if (daemonApp->testing()) {\n            // create process\n            m_process = new QProcess(this);\n\n            // delete process on finish\n            connect(m_process, SIGNAL(finished(int,QProcess::ExitStatus)), this, SLOT(finished()));\n\n            connect(m_process, SIGNAL(readyReadStandardOutput()), SLOT(onReadyReadStandardOutput()));\n            connect(m_process, SIGNAL(readyReadStandardError()), SLOT(onReadyReadStandardError()));\n\n            // log message\n            qDebug() << \"Greeter starting...\";\n\n            // set process environment\n            QProcessEnvironment env = QProcessEnvironment::systemEnvironment();\n            env.insert(\"DISPLAY\", m_display->name());\n            env.insert(\"XAUTHORITY\", m_authPath);\n            env.insert(\"XCURSOR_THEME\", mainConfig.Theme.CursorTheme.get());\n            m_process->setProcessEnvironment(env);\n\n            // start greeter\n            QStringList args;\n            if (daemonApp->testing())\n                args << \"--test-mode\";\n            args << \"--socket\" << m_socket\n                 << \"--theme\" << m_theme;\n            m_process->start(QString(\"%1/sddm-greeter\").arg(BIN_INSTALL_DIR), args);\n\n            //if we fail to start bail immediately, and don't block in waitForStarted\n            if (m_process->state() == QProcess::NotRunning) {\n                qCritical() << \"Greeter failed to launch.\";\n                return false;\n            }\n            // wait for greeter to start\n            if (!m_process->waitForStarted()) {\n                // log message\n                qCritical() << \"Failed to start greeter.\";\n\n                // return fail\n                return false;\n            }\n\n            // log message\n            qDebug() << \"Greeter started.\";\n\n            // set flag\n            m_started = true;\n        } else {\n            // authentication\n            m_auth = new Auth(this);\n            m_auth->setVerbose(true);\n            connect(m_auth, SIGNAL(requestChanged()), this, SLOT(onRequestChanged()));\n            connect(m_auth, SIGNAL(session(bool)), this, SLOT(onSessionStarted(bool)));\n            connect(m_auth, SIGNAL(finished(Auth::HelperExitStatus)), this, SLOT(onHelperFinished(Auth::HelperExitStatus)));\n            connect(m_auth, SIGNAL(info(QString,Auth::Info)), this, SLOT(authInfo(QString,Auth::Info)));\n            connect(m_auth, SIGNAL(error(QString,Auth::Error)), this, SLOT(authError(QString,Auth::Error)));\n\n            // greeter command\n            QStringList args;\n            args << QString(\"%1/sddm-greeter\").arg(BIN_INSTALL_DIR);\n            args << \"--socket\" << m_socket\n                 << \"--theme\" << m_theme;\n\n            // greeter environment\n            QProcessEnvironment env;\n            env.insert(\"PATH\", mainConfig.Users.DefaultPath.get());\n            env.insert(\"DISPLAY\", m_display->name());\n            env.insert(\"XAUTHORITY\", m_authPath);\n            env.insert(\"XCURSOR_THEME\", mainConfig.Theme.CursorTheme.get());\n            env.insert(\"XDG_SEAT\", m_display->seat()->name());\n            env.insert(\"XDG_SEAT_PATH\", daemonApp->displayManager()->seatPath(m_display->seat()->name()));\n            env.insert(\"XDG_SESSION_PATH\", daemonApp->displayManager()->sessionPath(QString(\"Session%1\").arg(daemonApp->newSessionId())));\n            env.insert(\"XDG_VTNR\", QString::number(m_display->terminalId()));\n            env.insert(\"XDG_SESSION_CLASS\", \"greeter\");\n            env.insert(\"XDG_SESSION_TYPE\", m_display->sessionType());\n            m_auth->insertEnvironment(env);\n\n            // log message\n            qDebug() << \"Greeter starting...\";\n\n            // start greeter\n            m_auth->setUser(\"sddm\");\n            m_auth->setGreeter(true);\n            m_auth->setSession(args.join(\" \"));\n            m_auth->start();\n        }\n\n        // return success\n        return true;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,6 +85,7 @@\n \n             // start greeter\n             m_auth->setUser(\"sddm\");\n+            m_auth->setGreeter(true);\n             m_auth->setSession(args.join(\" \"));\n             m_auth->start();\n         }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            m_auth->setGreeter(true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7271",
        "func_name": "sddm/Display::login",
        "description": "Simple Desktop Display Manager (SDDM) before 0.10.0 allows local users to log in as user \"sddm\" without authentication.",
        "git_url": "https://github.com/sddm/sddm/commit/71b921d9304cdfae47bcd587bf0b6b1dd971c8f3",
        "commit_title": "Never try to login as the user SDDM",
        "commit_text": "",
        "func_before": "void Display::login(QLocalSocket *socket, const QString &user, const QString &password, const QString &session) {\n        m_socket = socket;\n        startAuth(user, password, session);\n    }",
        "func": "void Display::login(QLocalSocket *socket, const QString &user, const QString &password, const QString &session) {\n        m_socket = socket;\n\n        //the SDDM user has special priveledges that skip password checking so that we can load the greeter\n        //block ever trying to log in as the SDDM user\n        if (user == \"sddm\") {\n            return;\n        }\n\n        startAuth(user, password, session);\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,11 @@\n void Display::login(QLocalSocket *socket, const QString &user, const QString &password, const QString &session) {\n         m_socket = socket;\n+\n+        //the SDDM user has special priveledges that skip password checking so that we can load the greeter\n+        //block ever trying to log in as the SDDM user\n+        if (user == \"sddm\") {\n+            return;\n+        }\n+\n         startAuth(user, password, session);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        //the SDDM user has special priveledges that skip password checking so that we can load the greeter",
                "        //block ever trying to log in as the SDDM user",
                "        if (user == \"sddm\") {",
                "            return;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7271",
        "func_name": "sddm/Auth::start",
        "description": "Simple Desktop Display Manager (SDDM) before 0.10.0 allows local users to log in as user \"sddm\" without authentication.",
        "git_url": "https://github.com/sddm/sddm/commit/71b921d9304cdfae47bcd587bf0b6b1dd971c8f3",
        "commit_title": "Never try to login as the user SDDM",
        "commit_text": "",
        "func_before": "void Auth::start() {\n        QStringList args;\n        args << \"--socket\" << SocketServer::instance()->fullServerName();\n        args << \"--id\" << QString(\"%1\").arg(d->id);\n        if (!d->sessionPath.isEmpty())\n            args << \"--start\" << d->sessionPath;\n        if (!d->user.isEmpty())\n            args << \"--user\" << d->user;\n        if (d->autologin)\n            args << \"--autologin\";\n        d->child->start(QString(\"%1/sddm-helper\").arg(LIBEXEC_INSTALL_DIR), args);\n    }",
        "func": "void Auth::start() {\n        QStringList args;\n        args << \"--socket\" << SocketServer::instance()->fullServerName();\n        args << \"--id\" << QString(\"%1\").arg(d->id);\n        if (!d->sessionPath.isEmpty())\n            args << \"--start\" << d->sessionPath;\n        if (!d->user.isEmpty())\n            args << \"--user\" << d->user;\n        if (d->autologin)\n            args << \"--autologin\";\n        if (d->greeter)\n            args << \"--greeter\";\n        d->child->start(QString(\"%1/sddm-helper\").arg(LIBEXEC_INSTALL_DIR), args);\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,5 +8,7 @@\n             args << \"--user\" << d->user;\n         if (d->autologin)\n             args << \"--autologin\";\n+        if (d->greeter)\n+            args << \"--greeter\";\n         d->child->start(QString(\"%1/sddm-helper\").arg(LIBEXEC_INSTALL_DIR), args);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (d->greeter)",
                "            args << \"--greeter\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7271",
        "func_name": "sddm/PamBackend::start",
        "description": "Simple Desktop Display Manager (SDDM) before 0.10.0 allows local users to log in as user \"sddm\" without authentication.",
        "git_url": "https://github.com/sddm/sddm/commit/71b921d9304cdfae47bcd587bf0b6b1dd971c8f3",
        "commit_title": "Never try to login as the user SDDM",
        "commit_text": "",
        "func_before": "bool PamBackend::start(const QString &user) {\n        bool result;\n\n        QString service = \"sddm\";\n\n        if (user == \"sddm\")\n            service = \"sddm-greeter\";\n        else if (m_app->session()->path().isEmpty())\n            service = \"sddm-check\";\n        else if (m_autologin)\n            service = \"sddm-autologin\";\n        result = m_pam->start(service, user);\n\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }",
        "func": "bool PamBackend::start(const QString &user) {\n        bool result;\n\n        QString service = \"sddm\";\n\n        if (m_greeter)\n            service = \"sddm-greeter\";\n        else if (m_app->session()->path().isEmpty())\n            service = \"sddm-check\";\n        else if (m_autologin)\n            service = \"sddm-autologin\";\n        result = m_pam->start(service, user);\n\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \n         QString service = \"sddm\";\n \n-        if (user == \"sddm\")\n+        if (m_greeter)\n             service = \"sddm-greeter\";\n         else if (m_app->session()->path().isEmpty())\n             service = \"sddm-check\";",
        "diff_line_info": {
            "deleted_lines": [
                "        if (user == \"sddm\")"
            ],
            "added_lines": [
                "        if (m_greeter)"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7271",
        "func_name": "sddm/HelperApp::setUp",
        "description": "Simple Desktop Display Manager (SDDM) before 0.10.0 allows local users to log in as user \"sddm\" without authentication.",
        "git_url": "https://github.com/sddm/sddm/commit/71b921d9304cdfae47bcd587bf0b6b1dd971c8f3",
        "commit_title": "Never try to login as the user SDDM",
        "commit_text": "",
        "func_before": "void HelperApp::setUp() {\n        QStringList args = QCoreApplication::arguments();\n        QString server;\n        int pos;\n\n        if ((pos = args.indexOf(\"--socket\")) >= 0) {\n            if (pos >= args.length() - 1) {\n                qCritical() << \"This application is not supposed to be executed manually\";\n                exit(Auth::HELPER_OTHER_ERROR);\n                return;\n            }\n            server = args[pos + 1];\n        }\n\n        if ((pos = args.indexOf(\"--id\")) >= 0) {\n            if (pos >= args.length() - 1) {\n                qCritical() << \"This application is not supposed to be executed manually\";\n                exit(Auth::HELPER_OTHER_ERROR);\n                return;\n            }\n            m_id = QString(args[pos + 1]).toLongLong();\n        }\n\n        if ((pos = args.indexOf(\"--start\")) >= 0) {\n            if (pos >= args.length() - 1) {\n                qCritical() << \"This application is not supposed to be executed manually\";\n                exit(Auth::HELPER_OTHER_ERROR);\n                return;\n            }\n            m_session->setPath(args[pos + 1]);\n        }\n\n        if ((pos = args.indexOf(\"--user\")) >= 0) {\n            if (pos >= args.length() - 1) {\n                qCritical() << \"This application is not supposed to be executed manually\";\n                exit(Auth::HELPER_OTHER_ERROR);\n                return;\n            }\n            m_user = args[pos + 1];\n        }\n\n        if ((pos = args.indexOf(\"--autologin\")) >= 0) {\n            m_backend->setAutologin(true);\n        }\n\n        if (server.isEmpty() || m_id <= 0) {\n            qCritical() << \"This application is not supposed to be executed manually\";\n            exit(Auth::HELPER_OTHER_ERROR);\n            return;\n        }\n\n        connect(m_socket, SIGNAL(connected()), this, SLOT(doAuth()));\n        connect(m_session, SIGNAL(finished(int)), this, SLOT(sessionFinished(int)));\n        m_socket->connectToServer(server, QIODevice::ReadWrite | QIODevice::Unbuffered);\n    }",
        "func": "void HelperApp::setUp() {\n        QStringList args = QCoreApplication::arguments();\n        QString server;\n        int pos;\n\n        if ((pos = args.indexOf(\"--socket\")) >= 0) {\n            if (pos >= args.length() - 1) {\n                qCritical() << \"This application is not supposed to be executed manually\";\n                exit(Auth::HELPER_OTHER_ERROR);\n                return;\n            }\n            server = args[pos + 1];\n        }\n\n        if ((pos = args.indexOf(\"--id\")) >= 0) {\n            if (pos >= args.length() - 1) {\n                qCritical() << \"This application is not supposed to be executed manually\";\n                exit(Auth::HELPER_OTHER_ERROR);\n                return;\n            }\n            m_id = QString(args[pos + 1]).toLongLong();\n        }\n\n        if ((pos = args.indexOf(\"--start\")) >= 0) {\n            if (pos >= args.length() - 1) {\n                qCritical() << \"This application is not supposed to be executed manually\";\n                exit(Auth::HELPER_OTHER_ERROR);\n                return;\n            }\n            m_session->setPath(args[pos + 1]);\n        }\n\n        if ((pos = args.indexOf(\"--user\")) >= 0) {\n            if (pos >= args.length() - 1) {\n                qCritical() << \"This application is not supposed to be executed manually\";\n                exit(Auth::HELPER_OTHER_ERROR);\n                return;\n            }\n            m_user = args[pos + 1];\n        }\n\n        if ((pos = args.indexOf(\"--autologin\")) >= 0) {\n            m_backend->setAutologin(true);\n        }\n\n        if ((pos == args.indexOf(\"--greeter\")) >= 0) {\n            m_backend->setGreeter(true);\n        }\n\n        if (server.isEmpty() || m_id <= 0) {\n            qCritical() << \"This application is not supposed to be executed manually\";\n            exit(Auth::HELPER_OTHER_ERROR);\n            return;\n        }\n\n        connect(m_socket, SIGNAL(connected()), this, SLOT(doAuth()));\n        connect(m_session, SIGNAL(finished(int)), this, SLOT(sessionFinished(int)));\n        m_socket->connectToServer(server, QIODevice::ReadWrite | QIODevice::Unbuffered);\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,6 +43,10 @@\n             m_backend->setAutologin(true);\n         }\n \n+        if ((pos == args.indexOf(\"--greeter\")) >= 0) {\n+            m_backend->setGreeter(true);\n+        }\n+\n         if (server.isEmpty() || m_id <= 0) {\n             qCritical() << \"This application is not supposed to be executed manually\";\n             exit(Auth::HELPER_OTHER_ERROR);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if ((pos == args.indexOf(\"--greeter\")) >= 0) {",
                "            m_backend->setGreeter(true);",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29226",
        "func_name": "envoyproxy/envoy/OAuth2Filter::decodeHeaders",
        "description": "Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter implementation does not include a mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing access in the presence of any access token attached to the request. Users are advised to upgrade. There is no known workaround for this issue.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/7ffda4e809dec74449ebc330cebb9d2f4ab61360",
        "commit_title": "oauth2: do not blindly accept requests with a token in the Authorization headera (781)",
        "commit_text": " The logic was broken because it assumed an additional call would be performed to the auth server, which isn't the case. Per the filter documentation, a request is only considered subsequently authenticated if there's valid cookie that was set after the access token was received from the auth server:  https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/oauth2_filter  More info about how to validate an access token (which we don't do, per above):  https://www.oauth.com/oauth2-servers/token-introspection-endpoint/ https://datatracker.ietf.org/doc/html/rfc7662  Also fix the fact that ee shouldn't be calling continueDecoding() after decoder_callbacks_->encodeHeaders(). ",
        "func_before": "Http::FilterHeadersStatus OAuth2Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool) {\n\n  // The following 2 headers are guaranteed for regular requests. The asserts are helpful when\n  // writing test code to not forget these important variables in mock requests\n  const Http::HeaderEntry* host_header = headers.Host();\n  ASSERT(host_header != nullptr);\n  host_ = host_header->value().getStringView();\n\n  const Http::HeaderEntry* path_header = headers.Path();\n  ASSERT(path_header != nullptr);\n  const absl::string_view path_str = path_header->value().getStringView();\n\n  // We should check if this is a sign out request.\n  if (config_->signoutPath().match(path_header->value().getStringView())) {\n    return signOutUser(headers);\n  }\n\n  if (canSkipOAuth(headers)) {\n    // Update the path header with the query string parameters after a successful OAuth login.\n    // This is necessary if a website requests multiple resources which get redirected to the\n    // auth server. A cached login on the authorization server side will set cookies\n    // correctly but cause a race condition on future requests that have their location set\n    // to the callback path.\n\n    if (config_->redirectPathMatcher().match(path_str)) {\n      Http::Utility::QueryParams query_parameters = Http::Utility::parseQueryString(path_str);\n\n      const auto state =\n          Http::Utility::PercentEncoding::decode(query_parameters.at(queryParamsState()));\n      Http::Utility::Url state_url;\n      if (!state_url.initialize(state, false)) {\n        sendUnauthorizedResponse();\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n      // Avoid infinite redirect storm\n      if (config_->redirectPathMatcher().match(state_url.pathAndQueryParams())) {\n        sendUnauthorizedResponse();\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n      Http::ResponseHeaderMapPtr response_headers{\n          Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n              {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))},\n               {Http::Headers::get().Location, state}})};\n      decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_RACE);\n    }\n\n    // Continue on with the filter stack.\n    return Http::FilterHeadersStatus::Continue;\n  }\n\n  // Save the request headers for later modification if needed.\n  if (config_->forwardBearerToken()) {\n    request_headers_ = &headers;\n  }\n\n  // If a bearer token is supplied as a header or param, we ingest it here and kick off the\n  // user resolution immediately. Note this comes after HMAC validation, so technically this\n  // header is sanitized in a way, as the validation check forces the correct Bearer Cookie value.\n  access_token_ = extractAccessToken(headers);\n  if (!access_token_.empty()) {\n    found_bearer_token_ = true;\n    finishFlow();\n    return Http::FilterHeadersStatus::Continue;\n  }\n\n  // If no access token and this isn't the callback URI, redirect to acquire credentials.\n  //\n  // The following conditional could be replaced with a regex pattern-match,\n  // if we're concerned about strict matching against the callback path.\n  if (!config_->redirectPathMatcher().match(path_str)) {\n    Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n        {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n    // Construct the correct scheme. We default to https since this is a requirement for OAuth to\n    // succeed. However, if a downstream client explicitly declares the \"http\" scheme for whatever\n    // reason, we also use \"http\" when constructing our redirect uri to the authorization server.\n    auto scheme = Http::Headers::get().SchemeValues.Https;\n\n    const auto* scheme_header = headers.Scheme();\n    if ((scheme_header != nullptr &&\n         scheme_header->value().getStringView() == Http::Headers::get().SchemeValues.Http)) {\n      scheme = Http::Headers::get().SchemeValues.Http;\n    }\n\n    const std::string base_path = absl::StrCat(scheme, \"://\", host_);\n    const std::string state_path = absl::StrCat(base_path, headers.Path()->value().getStringView());\n    const std::string escaped_state = Http::Utility::PercentEncoding::encode(state_path, \":/=&?\");\n\n    Formatter::FormatterImpl formatter(config_->redirectUri());\n    const auto redirect_uri = formatter.format(headers, *Http::ResponseHeaderMapImpl::create(),\n                                               *Http::ResponseTrailerMapImpl::create(),\n                                               decoder_callbacks_->streamInfo(), \"\");\n    const std::string escaped_redirect_uri =\n        Http::Utility::PercentEncoding::encode(redirect_uri, \":/=&?\");\n\n    const std::string new_url = fmt::format(\n        AuthorizationEndpointFormat, config_->authorizationEndpoint(), config_->clientId(),\n        config_->encodedAuthScopes(), escaped_redirect_uri, escaped_state);\n\n    response_headers->setLocation(new_url + config_->encodedResourceQueryParams());\n    decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_FOR_CREDENTIALS);\n\n    config_->stats().oauth_unauthorized_rq_.inc();\n\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // At this point, we *are* on /_oauth. We believe this request comes from the authorization\n  // server and we expect the query strings to contain the information required to get the access\n  // token\n  const auto query_parameters = Http::Utility::parseQueryString(path_str);\n  if (query_parameters.find(queryParamsError()) != query_parameters.end()) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // if the data we need is not present on the URL, stop execution\n  if (query_parameters.find(queryParamsCode()) == query_parameters.end() ||\n      query_parameters.find(queryParamsState()) == query_parameters.end()) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  auth_code_ = query_parameters.at(queryParamsCode());\n  state_ = Http::Utility::PercentEncoding::decode(query_parameters.at(queryParamsState()));\n\n  Http::Utility::Url state_url;\n  if (!state_url.initialize(state_, false)) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  Formatter::FormatterImpl formatter(config_->redirectUri());\n  const auto redirect_uri = formatter.format(headers, *Http::ResponseHeaderMapImpl::create(),\n                                             *Http::ResponseTrailerMapImpl::create(),\n                                             decoder_callbacks_->streamInfo(), \"\");\n  oauth_client_->asyncGetAccessToken(auth_code_, config_->clientId(), config_->clientSecret(),\n                                     redirect_uri);\n\n  // pause while we await the next step from the OAuth server\n  return Http::FilterHeadersStatus::StopAllIterationAndBuffer;\n}",
        "func": "Http::FilterHeadersStatus OAuth2Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool) {\n  // Sanitize the Authorization header, since we have no way to validate its content. Also,\n  // if token forwarding is enabled, this header will be set based on what is on the HMAC cookie\n  // before forwarding the request upstream.\n  headers.removeInline(authorization_handle.handle());\n\n  // The following 2 headers are guaranteed for regular requests. The asserts are helpful when\n  // writing test code to not forget these important variables in mock requests\n  const Http::HeaderEntry* host_header = headers.Host();\n  ASSERT(host_header != nullptr);\n  host_ = host_header->value().getStringView();\n\n  const Http::HeaderEntry* path_header = headers.Path();\n  ASSERT(path_header != nullptr);\n  const absl::string_view path_str = path_header->value().getStringView();\n\n  // We should check if this is a sign out request.\n  if (config_->signoutPath().match(path_header->value().getStringView())) {\n    return signOutUser(headers);\n  }\n\n  if (canSkipOAuth(headers)) {\n    // Update the path header with the query string parameters after a successful OAuth login.\n    // This is necessary if a website requests multiple resources which get redirected to the\n    // auth server. A cached login on the authorization server side will set cookies\n    // correctly but cause a race condition on future requests that have their location set\n    // to the callback path.\n\n    if (config_->redirectPathMatcher().match(path_str)) {\n      Http::Utility::QueryParams query_parameters = Http::Utility::parseQueryString(path_str);\n\n      const auto state =\n          Http::Utility::PercentEncoding::decode(query_parameters.at(queryParamsState()));\n      Http::Utility::Url state_url;\n      if (!state_url.initialize(state, false)) {\n        sendUnauthorizedResponse();\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n      // Avoid infinite redirect storm\n      if (config_->redirectPathMatcher().match(state_url.pathAndQueryParams())) {\n        sendUnauthorizedResponse();\n        return Http::FilterHeadersStatus::StopIteration;\n      }\n      Http::ResponseHeaderMapPtr response_headers{\n          Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n              {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))},\n               {Http::Headers::get().Location, state}})};\n      decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_RACE);\n    }\n\n    // Continue on with the filter stack.\n    return Http::FilterHeadersStatus::Continue;\n  }\n\n  // Save the request headers for later modification if needed.\n  if (config_->forwardBearerToken()) {\n    request_headers_ = &headers;\n  }\n\n  // If this isn't the callback URI, redirect to acquire credentials.\n  //\n  // The following conditional could be replaced with a regex pattern-match,\n  // if we're concerned about strict matching against the callback path.\n  if (!config_->redirectPathMatcher().match(path_str)) {\n    Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n        {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n    // Construct the correct scheme. We default to https since this is a requirement for OAuth to\n    // succeed. However, if a downstream client explicitly declares the \"http\" scheme for whatever\n    // reason, we also use \"http\" when constructing our redirect uri to the authorization server.\n    auto scheme = Http::Headers::get().SchemeValues.Https;\n\n    const auto* scheme_header = headers.Scheme();\n    if ((scheme_header != nullptr &&\n         scheme_header->value().getStringView() == Http::Headers::get().SchemeValues.Http)) {\n      scheme = Http::Headers::get().SchemeValues.Http;\n    }\n\n    const std::string base_path = absl::StrCat(scheme, \"://\", host_);\n    const std::string state_path = absl::StrCat(base_path, headers.Path()->value().getStringView());\n    const std::string escaped_state = Http::Utility::PercentEncoding::encode(state_path, \":/=&?\");\n\n    Formatter::FormatterImpl formatter(config_->redirectUri());\n    const auto redirect_uri = formatter.format(headers, *Http::ResponseHeaderMapImpl::create(),\n                                               *Http::ResponseTrailerMapImpl::create(),\n                                               decoder_callbacks_->streamInfo(), \"\");\n    const std::string escaped_redirect_uri =\n        Http::Utility::PercentEncoding::encode(redirect_uri, \":/=&?\");\n\n    const std::string new_url = fmt::format(\n        AuthorizationEndpointFormat, config_->authorizationEndpoint(), config_->clientId(),\n        config_->encodedAuthScopes(), escaped_redirect_uri, escaped_state);\n\n    response_headers->setLocation(new_url + config_->encodedResourceQueryParams());\n    decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_FOR_CREDENTIALS);\n\n    config_->stats().oauth_unauthorized_rq_.inc();\n\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // At this point, we *are* on /_oauth. We believe this request comes from the authorization\n  // server and we expect the query strings to contain the information required to get the access\n  // token\n  const auto query_parameters = Http::Utility::parseQueryString(path_str);\n  if (query_parameters.find(queryParamsError()) != query_parameters.end()) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // if the data we need is not present on the URL, stop execution\n  if (query_parameters.find(queryParamsCode()) == query_parameters.end() ||\n      query_parameters.find(queryParamsState()) == query_parameters.end()) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  auth_code_ = query_parameters.at(queryParamsCode());\n  state_ = Http::Utility::PercentEncoding::decode(query_parameters.at(queryParamsState()));\n\n  Http::Utility::Url state_url;\n  if (!state_url.initialize(state_, false)) {\n    sendUnauthorizedResponse();\n    return Http::FilterHeadersStatus::StopIteration;\n  }\n\n  Formatter::FormatterImpl formatter(config_->redirectUri());\n  const auto redirect_uri = formatter.format(headers, *Http::ResponseHeaderMapImpl::create(),\n                                             *Http::ResponseTrailerMapImpl::create(),\n                                             decoder_callbacks_->streamInfo(), \"\");\n  oauth_client_->asyncGetAccessToken(auth_code_, config_->clientId(), config_->clientSecret(),\n                                     redirect_uri);\n\n  // pause while we await the next step from the OAuth server\n  return Http::FilterHeadersStatus::StopAllIterationAndBuffer;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,8 @@\n Http::FilterHeadersStatus OAuth2Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool) {\n+  // Sanitize the Authorization header, since we have no way to validate its content. Also,\n+  // if token forwarding is enabled, this header will be set based on what is on the HMAC cookie\n+  // before forwarding the request upstream.\n+  headers.removeInline(authorization_handle.handle());\n \n   // The following 2 headers are guaranteed for regular requests. The asserts are helpful when\n   // writing test code to not forget these important variables in mock requests\n@@ -53,17 +57,7 @@\n     request_headers_ = &headers;\n   }\n \n-  // If a bearer token is supplied as a header or param, we ingest it here and kick off the\n-  // user resolution immediately. Note this comes after HMAC validation, so technically this\n-  // header is sanitized in a way, as the validation check forces the correct Bearer Cookie value.\n-  access_token_ = extractAccessToken(headers);\n-  if (!access_token_.empty()) {\n-    found_bearer_token_ = true;\n-    finishFlow();\n-    return Http::FilterHeadersStatus::Continue;\n-  }\n-\n-  // If no access token and this isn't the callback URI, redirect to acquire credentials.\n+  // If this isn't the callback URI, redirect to acquire credentials.\n   //\n   // The following conditional could be replaced with a regex pattern-match,\n   // if we're concerned about strict matching against the callback path.",
        "diff_line_info": {
            "deleted_lines": [
                "  // If a bearer token is supplied as a header or param, we ingest it here and kick off the",
                "  // user resolution immediately. Note this comes after HMAC validation, so technically this",
                "  // header is sanitized in a way, as the validation check forces the correct Bearer Cookie value.",
                "  access_token_ = extractAccessToken(headers);",
                "  if (!access_token_.empty()) {",
                "    found_bearer_token_ = true;",
                "    finishFlow();",
                "    return Http::FilterHeadersStatus::Continue;",
                "  }",
                "",
                "  // If no access token and this isn't the callback URI, redirect to acquire credentials."
            ],
            "added_lines": [
                "  // Sanitize the Authorization header, since we have no way to validate its content. Also,",
                "  // if token forwarding is enabled, this header will be set based on what is on the HMAC cookie",
                "  // before forwarding the request upstream.",
                "  headers.removeInline(authorization_handle.handle());",
                "  // If this isn't the callback URI, redirect to acquire credentials."
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29226",
        "func_name": "envoyproxy/envoy/OAuth2Filter::finishFlow",
        "description": "Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter implementation does not include a mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing access in the presence of any access token attached to the request. Users are advised to upgrade. There is no known workaround for this issue.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/7ffda4e809dec74449ebc330cebb9d2f4ab61360",
        "commit_title": "oauth2: do not blindly accept requests with a token in the Authorization headera (781)",
        "commit_text": " The logic was broken because it assumed an additional call would be performed to the auth server, which isn't the case. Per the filter documentation, a request is only considered subsequently authenticated if there's valid cookie that was set after the access token was received from the auth server:  https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/oauth2_filter  More info about how to validate an access token (which we don't do, per above):  https://www.oauth.com/oauth2-servers/token-introspection-endpoint/ https://datatracker.ietf.org/doc/html/rfc7662  Also fix the fact that ee shouldn't be calling continueDecoding() after decoder_callbacks_->encodeHeaders(). ",
        "func_before": "void OAuth2Filter::finishFlow() {\n\n  // We have fully completed the entire OAuth flow, whether through Authorization header or from\n  // user redirection to the auth server.\n  if (found_bearer_token_) {\n    if (config_->forwardBearerToken()) {\n      setBearerToken(*request_headers_, access_token_);\n    }\n    config_->stats().oauth_success_.inc();\n    decoder_callbacks_->continueDecoding();\n    return;\n  }\n\n  std::string token_payload;\n  if (config_->forwardBearerToken()) {\n    token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_);\n  } else {\n    token_payload = absl::StrCat(host_, new_expires_);\n  }\n\n  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();\n\n  auto token_secret = config_->tokenSecret();\n  std::vector<uint8_t> token_secret_vec(token_secret.begin(), token_secret.end());\n  const std::string pre_encoded_token =\n      Hex::encode(crypto_util.getSha256Hmac(token_secret_vec, token_payload));\n  std::string encoded_token;\n  absl::Base64Escape(pre_encoded_token, &encoded_token);\n\n  // We use HTTP Only cookies for the HMAC and Expiry.\n  const std::string cookie_tail = fmt::format(CookieTailFormatString, new_expires_);\n  const std::string cookie_tail_http_only =\n      fmt::format(CookieTailHttpOnlyFormatString, new_expires_);\n\n  // At this point we have all of the pieces needed to authorize a user that did not originally\n  // have a bearer access token. Now, we construct a redirect request to return the user to their\n  // previous state and additionally set the OAuth cookies in browser.\n  // The redirection should result in successfully passing this filter.\n  Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n  const CookieNames& cookie_names = config_->cookieNames();\n\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_hmac_, \"=\", encoded_token, cookie_tail_http_only));\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_expires_, \"=\", new_expires_, cookie_tail_http_only));\n\n  // If opted-in, we also create a new Bearer cookie for the authorization token provided by the\n  // auth server.\n  if (config_->forwardBearerToken()) {\n    response_headers->addReferenceKey(\n        Http::Headers::get().SetCookie,\n        absl::StrCat(cookie_names.bearer_token_, \"=\", access_token_, cookie_tail));\n    if (id_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"IdToken=\", id_token_, cookie_tail));\n    }\n\n    if (refresh_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"RefreshToken=\", refresh_token_, cookie_tail));\n    }\n  }\n\n  response_headers->setLocation(state_);\n\n  decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN);\n  config_->stats().oauth_success_.inc();\n  decoder_callbacks_->continueDecoding();\n}",
        "func": "void OAuth2Filter::finishFlow() {\n  std::string token_payload;\n  if (config_->forwardBearerToken()) {\n    token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_);\n  } else {\n    token_payload = absl::StrCat(host_, new_expires_);\n  }\n\n  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();\n\n  auto token_secret = config_->tokenSecret();\n  std::vector<uint8_t> token_secret_vec(token_secret.begin(), token_secret.end());\n  const std::string pre_encoded_token =\n      Hex::encode(crypto_util.getSha256Hmac(token_secret_vec, token_payload));\n  std::string encoded_token;\n  absl::Base64Escape(pre_encoded_token, &encoded_token);\n\n  // We use HTTP Only cookies for the HMAC and Expiry.\n  const std::string cookie_tail = fmt::format(CookieTailFormatString, new_expires_);\n  const std::string cookie_tail_http_only =\n      fmt::format(CookieTailHttpOnlyFormatString, new_expires_);\n\n  // At this point we have all of the pieces needed to authorize a user.\n  // Now, we construct a redirect request to return the user to their\n  // previous state and additionally set the OAuth cookies in browser.\n  // The redirection should result in successfully passing this filter.\n  Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n      {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})};\n\n  const CookieNames& cookie_names = config_->cookieNames();\n\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_hmac_, \"=\", encoded_token, cookie_tail_http_only));\n  response_headers->addReferenceKey(\n      Http::Headers::get().SetCookie,\n      absl::StrCat(cookie_names.oauth_expires_, \"=\", new_expires_, cookie_tail_http_only));\n\n  // If opted-in, we also create a new Bearer cookie for the authorization token provided by the\n  // auth server.\n  if (config_->forwardBearerToken()) {\n    response_headers->addReferenceKey(\n        Http::Headers::get().SetCookie,\n        absl::StrCat(cookie_names.bearer_token_, \"=\", access_token_, cookie_tail));\n    if (id_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"IdToken=\", id_token_, cookie_tail));\n    }\n\n    if (refresh_token_ != EMPTY_STRING) {\n      response_headers->addReferenceKey(Http::Headers::get().SetCookie,\n                                        absl::StrCat(\"RefreshToken=\", refresh_token_, cookie_tail));\n    }\n  }\n\n  response_headers->setLocation(state_);\n\n  decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN);\n  config_->stats().oauth_success_.inc();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,16 +1,4 @@\n void OAuth2Filter::finishFlow() {\n-\n-  // We have fully completed the entire OAuth flow, whether through Authorization header or from\n-  // user redirection to the auth server.\n-  if (found_bearer_token_) {\n-    if (config_->forwardBearerToken()) {\n-      setBearerToken(*request_headers_, access_token_);\n-    }\n-    config_->stats().oauth_success_.inc();\n-    decoder_callbacks_->continueDecoding();\n-    return;\n-  }\n-\n   std::string token_payload;\n   if (config_->forwardBearerToken()) {\n     token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_);\n@@ -32,8 +20,8 @@\n   const std::string cookie_tail_http_only =\n       fmt::format(CookieTailHttpOnlyFormatString, new_expires_);\n \n-  // At this point we have all of the pieces needed to authorize a user that did not originally\n-  // have a bearer access token. Now, we construct a redirect request to return the user to their\n+  // At this point we have all of the pieces needed to authorize a user.\n+  // Now, we construct a redirect request to return the user to their\n   // previous state and additionally set the OAuth cookies in browser.\n   // The redirection should result in successfully passing this filter.\n   Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>(\n@@ -69,5 +57,4 @@\n \n   decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN);\n   config_->stats().oauth_success_.inc();\n-  decoder_callbacks_->continueDecoding();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "  // We have fully completed the entire OAuth flow, whether through Authorization header or from",
                "  // user redirection to the auth server.",
                "  if (found_bearer_token_) {",
                "    if (config_->forwardBearerToken()) {",
                "      setBearerToken(*request_headers_, access_token_);",
                "    }",
                "    config_->stats().oauth_success_.inc();",
                "    decoder_callbacks_->continueDecoding();",
                "    return;",
                "  }",
                "",
                "  // At this point we have all of the pieces needed to authorize a user that did not originally",
                "  // have a bearer access token. Now, we construct a redirect request to return the user to their",
                "  decoder_callbacks_->continueDecoding();"
            ],
            "added_lines": [
                "  // At this point we have all of the pieces needed to authorize a user.",
                "  // Now, we construct a redirect request to return the user to their"
            ]
        }
    }
]