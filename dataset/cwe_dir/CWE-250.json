[
    {
        "cve_id": "CVE-2021-41035",
        "func_name": "eclipse-openj9/openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "description": "In Eclipse Openj9 before version 0.29.0, the JVM does not throw IllegalAccessError for MethodHandles that invoke inaccessible interface methods.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/c6e0d9296ff9a3084965d83e207403de373c0bad",
        "commit_title": "Throw IAE when an InterfaceHandle thunk finds a non-public method",
        "commit_text": " The interface dispatch implemented by InterfaceHandle is supposed to throw IllegalAccessError (IAE) when the dispatched callee is not public, just like the dispatch performed by invokeinterface.",
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,12 @@\n          break;\n    TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n    UDATA *itableArray = (UDATA*)(itableEntry+1);\n-   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n+   UDATA vTableOffset = itableArray[itableIndex];\n+   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n+   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n+      return -1;\n+\n+   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n #if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n    struct\n       {",
        "diff_line_info": {
            "deleted_lines": [
                "   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);"
            ],
            "added_lines": [
                "   UDATA vTableOffset = itableArray[itableIndex];",
                "   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);",
                "   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)",
                "      return -1;",
                "",
                "   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);"
            ]
        }
    }
]