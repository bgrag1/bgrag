[
    {
        "cve_id": "CVE-2023-50255",
        "func_name": "linuxdeepin/deepin-compressor/LibzipPlugin::extractEntry",
        "description": "Deepin-Compressor is the default archive manager of Deepin Linux OS. Prior to 5.12.21, there's a path traversal vulnerability in deepin-compressor that can be exploited to achieve Remote Command Execution on the target system upon opening crafted archives. Users are advised to update to version 5.12.21 which addresses the issue. There are no known workarounds for this vulnerability.\n",
        "git_url": "https://github.com/linuxdeepin/deepin-compressor/commit/82f668c78c133873f5094cfab6e4eabc0b70e4b6",
        "commit_title": "fix: Zip Path Traversal",
        "commit_text": " Zip Path Traversal  Bug: https://pms.uniontech.com/bug-view-232873.html  Log: Zip Path Traversal",
        "func_before": "ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)\n{\n    zip_stat_t statBuffer;\n    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {\n        return ET_FileReadError;\n    }\n\n    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // 解压文件名（压缩包中）\n    if(strFileName.contains(QLatin1Char('\\\\')))\n        strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n    QString strOriginName = strFileName;\n\n    // 针对文件夹名称过长的情况，直接提示解压失败，文件夹名称过长\n//    QStringList listPath = strFileName.split(QDir::separator());\n//    listPath.removeLast();\n//    for (int i = 0; i < listPath.count(); ++i) {\n//        if (NAME_MAX < QString(listPath[i]).toLocal8Bit().length()) {\n//            emit signalCurFileName(strFileName); // 发送当前正在解压的文件名\n//            return ET_LongNameError;\n//        }\n//    }\n\n    QString strFilePath;\n    QString strTempFileName = strFileName;\n    int iIndex = strFileName.lastIndexOf(QDir::separator());\n\n    if (iIndex >= 0) {\n        strFilePath = strFileName.left(iIndex);   // bug114527 left函数参数为截取的字符串长度\n        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);\n    }\n\n    QString tempFilePathName;\n    if(!m_bDlnfs) {\n        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);\n        if(sDir.length() > 0) {\n           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;\n           if(strFileName.endsWith(QDir::separator())) {\n               strFileName = sDir;\n           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {\n               strFileName = sDir + strTempFileName;\n           }\n           if(!m_mapLongDirName.isEmpty()) {\n               bHandleLongName = true;\n           }\n        }\n        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {\n            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);\n\n            // 保存文件路径，不同目录下的同名文件分开计数,文件解压结束后才添加计数，\n            tempFilePathName = strFilePath + QDir::separator() + strTemp;   // 路径加截取后的文件名\n            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {\n                return ET_LongNameError;\n            }\n            bHandleLongName = true;\n            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();\n            if(10 < sSuffix.length()){\n                sSuffix = QFileInfo(strTempFileName).suffix();\n                if(10 < sSuffix.length()) {\n                    sSuffix = sSuffix.right(10);\n                }\n            }\n            strTempFileName = strTemp + QString(\"(%1)\").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + \".\" + sSuffix;\n\n            strFileName = strTempFileName;\n            if (iIndex >= 0) {\n                strFileName = strFilePath + QDir::separator() + strTempFileName;\n            }\n\n        }\n    }\n\n    // 提取\n    if (!options.strDestination.isEmpty()) {\n        if(bHandleLongName) {\n            int nCnt = options.strDestination.count(QDir::separator());\n            int nIndex = 0;\n            for(int i = 0; i < nCnt; i++){\n                nIndex = strFileName.indexOf(QDir::separator(), nIndex);\n                nIndex++;\n            }\n            strFileName = strFileName.remove(0, nIndex);\n        } else {\n            strFileName = strFileName.remove(0, options.strDestination.size());\n        }\n    }\n\n\n    if (bHandleLongName) {\n        emit signalCurFileName(strOriginName); // 发送当前正在解压的文件名\n    } else {\n        emit signalCurFileName(strFileName); // 发送当前正在解压的文件名\n    }\n\n    bool bIsDirectory = strFileName.endsWith(QDir::separator());    // 是否为文件夹\n\n    // 判断解压路径是否存在，不存在则创建文件夹\n    if (QDir().exists(options.strTargetPath) == false)\n        QDir().mkpath(options.strTargetPath);\n\n    // 解压完整文件名（含路径）\n    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;\n\n    QFile file(strDestFileName);\n\n    // Store parent mtime.\n    QString parentDir;\n    if (strFileName.endsWith(QDir::separator())) {\n        QDir pDir = QFileInfo(strDestFileName).dir();\n        pDir.cdUp();\n        parentDir = pDir.path();\n    } else {\n        parentDir = QFileInfo(strDestFileName).path();\n    }\n    // For top-level items, don't restore parent dir mtime.\n    const bool restoreParentMtime = (parentDir != options.strTargetPath);\n\n    time_t parent_mtime;\n    if (restoreParentMtime) {\n        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;\n    }\n\n    // 获取外部信息（权限）\n    zip_uint8_t opsys;\n    zip_uint32_t attributes;\n    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {\n        emit error((\"Failed to read metadata for entry: %1\"));\n    }\n\n    // 从压缩包中获取文件权限\n    mode_t value = mode_t();\n    switch (opsys) {\n    case ZIP_OPSYS_UNIX:\n        value = attributes >> 16;\n        break;\n    default:    // TODO: non-UNIX.\n        break;\n    }\n    bool isLink = false;\n    if(S_ISLNK(value)) {\n        isLink = true;\n    }\n    QFileDevice::Permissions per = getPermissions(value);\n\n    if (bIsDirectory && !isLink) {     // 文件夹\n        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())\n            return ET_LongNameError;\n\n        QDir dir;\n        dir.mkpath(strDestFileName);\n\n        // 文件夹加可执行权限\n        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;\n    } else if(isLink) { //软连接解压\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        char buf[READBYTES] = {0};\n        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n        if (readBytes > 0) {\n            QString strBuf = QString(buf).toLocal8Bit();\n            if (QFile::link(strBuf, strDestFileName)) {\n                qInfo() << \"Symlink's created:\" << buf << strFileName;\n            } else {\n                qInfo() << \"Can't create symlink\" << buf << strFileName;\n            }\n        }\n        file.close();\n        zip_fclose(zipFile);\n    } else {        // 普通文件\n\n        // 判断是否有同名文件\n        if (file.exists()) {\n            if (m_bSkipAll) {       // 全部跳过\n                m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数\n                return ET_NoError;\n            } else {\n                if (!m_bOverwriteAll) {     // 若不是全部覆盖，单条处理\n\n                    OverwriteQuery query(strDestFileName);\n\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit signalCancel();\n                        return ET_UserCancelOpertion;\n                    } else if (query.responseSkip()) {\n                        m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数\n                        return ET_NoError;\n                    } else if (query.responseSkipAll()) {\n                        m_bSkipAll = true;\n                        m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数\n                        return ET_NoError;\n                    }  else if (query.responseOverwriteAll()) {\n                        m_bOverwriteAll = true;\n                    }\n                }\n            }\n        }\n\n        if (bHandleLongName) {\n            m_setLongName << strFileName;\n        }\n\n        // 若文件存在且不是可写权限，重新创建一个文件\n        if (file.exists() && !file.isWritable()) {\n            file.remove();\n            file.setFileName(strDestFileName);\n            file.setPermissions(QFileDevice::WriteUser);\n        }\n\n        // 对文件路径做判断，防止特殊包未先解压出文件夹，导致解压失败\n        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)\n            QDir().mkpath(QFileInfo(strDestFileName).path());\n\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        // 错误处理\n        if (nullptr == zipFile) {\n            int iErr = zip_error_code_zip(zip_get_error(archive));\n            if (ZIP_ER_WRONGPASSWD == iErr) {//密码错误\n\n                // 对密码编码的探测\n                bool bCheckFinished = false;\n                int iCodecIndex = 0;\n                while (nullptr == zipFile && false == bCheckFinished) {\n                    if (m_listCodecs.length() == iCodecIndex) {\n                        bCheckFinished = true;\n                        if (file.exists()) {\n                            file.remove();\n                        }\n\n                        return ET_WrongPassword;\n                    } else {\n                        // 115645 【专业版】【1060】【归档管理器】【5.12.0.2】无法解压中文密码的zip压缩包（含有长名称）\n                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());\n                        iCodecIndex++;\n                        zip_error_clear(archive);\n                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n                        iErr = zip_error_code_zip(zip_get_error(archive));\n                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {//密码正确\n                            bCheckFinished = true;\n                        }\n                    }\n                }\n            } else if (ZIP_ER_NOPASSWD == iErr) {   // 无密码输入\n                return ET_NeedPassword;\n            } else {\n                return ET_FileOpenError;\n            }\n        }\n\n        // 以只写的方式打开待解压的文件\n        if (file.open(QIODevice::WriteOnly) == false) {\n            zip_fclose(zipFile);\n\n            QList<QString> entryNameList = strDestFileName.split('/');\n            foreach (auto &tmp, entryNameList) {\n                // 判断文件名是否过长\n                if (NAME_MAX < tmp.toLocal8Bit().length()) {\n                    return ET_LongNameError;\n                }\n            }\n\n            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n            return ET_FileWriteError;\n        }\n\n        // 写文件\n        QDataStream out(&file);\n        zip_int64_t sum = 0;\n        char buf[READBYTES];\n        int writeSize = 0;\n        double dScale = 1;\n        // 右键解压时按照文件比例计算大小\n        if (!options.bExistList) {\n            dScale = double(statBuffer.comp_size) / statBuffer.size;\n        }\n        while (sum != zip_int64_t(statBuffer.size)) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                break;\n            }\n\n            if (m_bPause) { //解压暂停\n                sleep(1);\n                continue;\n            }\n\n            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n\n            if (readBytes < 0) {\n                file.close();\n                zip_fclose(zipFile);\n                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                return ET_FileWriteError;\n            }\n\n            if (out.writeRawData(buf, int(readBytes)) != readBytes) {\n                file.close();\n                zip_fclose(zipFile);\n\n                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  // 小于readBytes作为磁盘空间不足的判断标准\n                    return ET_InsufficientDiskSpace;\n                } else {\n                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                    return ET_FileWriteError;\n                }\n            }\n\n            sum += readBytes;\n            writeSize += readBytes;\n\n            // 计算进度并显示（右键快捷解压使用压缩包大小，计算比例）\n            qExtractSize += readBytes * dScale;\n            emit signalprogress((double(qExtractSize)) * m_dScaleSize);\n        }\n\n        file.close();\n        zip_fclose(zipFile);\n    }\n    if(!isLink) {\n        // 设置文件/文件夹权限\n        file.setPermissions(per);\n\n        // Set mtime for entry.\n        utimbuf times;\n        times.modtime = statBuffer.mtime;\n        utime(strDestFileName.toUtf8().constData(), &times);\n\n        if (restoreParentMtime) {\n            // Restore mtime for parent dir.\n            times.modtime = parent_mtime;\n            utime(parentDir.toUtf8().constData(), &times);\n        }\n    }\n    m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数\n    return ET_NoError;\n}",
        "func": "ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)\n{\n    zip_stat_t statBuffer;\n    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {\n        return ET_FileReadError;\n    }\n\n    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // 解压文件名（压缩包中）\n    //fix 232873\n    if(strFileName.indexOf(\"../\") != -1) {\n        qInfo() << \"skipped ../ path component(s) in \" << strFileName;\n        strFileName = strFileName.replace(\"../\", \"\");\n    }\n    if(strFileName.contains(QLatin1Char('\\\\')))\n        strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n    QString strOriginName = strFileName;\n\n    // 针对文件夹名称过长的情况，直接提示解压失败，文件夹名称过长\n//    QStringList listPath = strFileName.split(QDir::separator());\n//    listPath.removeLast();\n//    for (int i = 0; i < listPath.count(); ++i) {\n//        if (NAME_MAX < QString(listPath[i]).toLocal8Bit().length()) {\n//            emit signalCurFileName(strFileName); // 发送当前正在解压的文件名\n//            return ET_LongNameError;\n//        }\n//    }\n\n    QString strFilePath;\n    QString strTempFileName = strFileName;\n    int iIndex = strFileName.lastIndexOf(QDir::separator());\n\n    if (iIndex >= 0) {\n        strFilePath = strFileName.left(iIndex);   // bug114527 left函数参数为截取的字符串长度\n        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);\n    }\n\n    QString tempFilePathName;\n    if(!m_bDlnfs) {\n        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);\n        if(sDir.length() > 0) {\n           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;\n           if(strFileName.endsWith(QDir::separator())) {\n               strFileName = sDir;\n           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {\n               strFileName = sDir + strTempFileName;\n           }\n           if(!m_mapLongDirName.isEmpty()) {\n               bHandleLongName = true;\n           }\n        }\n        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {\n            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);\n\n            // 保存文件路径，不同目录下的同名文件分开计数,文件解压结束后才添加计数，\n            tempFilePathName = strFilePath + QDir::separator() + strTemp;   // 路径加截取后的文件名\n            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {\n                return ET_LongNameError;\n            }\n            bHandleLongName = true;\n            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();\n            if(10 < sSuffix.length()){\n                sSuffix = QFileInfo(strTempFileName).suffix();\n                if(10 < sSuffix.length()) {\n                    sSuffix = sSuffix.right(10);\n                }\n            }\n            strTempFileName = strTemp + QString(\"(%1)\").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + \".\" + sSuffix;\n\n            strFileName = strTempFileName;\n            if (iIndex >= 0) {\n                strFileName = strFilePath + QDir::separator() + strTempFileName;\n            }\n\n        }\n    }\n\n    // 提取\n    if (!options.strDestination.isEmpty()) {\n        if(bHandleLongName) {\n            int nCnt = options.strDestination.count(QDir::separator());\n            int nIndex = 0;\n            for(int i = 0; i < nCnt; i++){\n                nIndex = strFileName.indexOf(QDir::separator(), nIndex);\n                nIndex++;\n            }\n            strFileName = strFileName.remove(0, nIndex);\n        } else {\n            strFileName = strFileName.remove(0, options.strDestination.size());\n        }\n    }\n\n\n    if (bHandleLongName) {\n        emit signalCurFileName(strOriginName); // 发送当前正在解压的文件名\n    } else {\n        emit signalCurFileName(strFileName); // 发送当前正在解压的文件名\n    }\n\n    bool bIsDirectory = strFileName.endsWith(QDir::separator());    // 是否为文件夹\n\n    // 判断解压路径是否存在，不存在则创建文件夹\n    if (QDir().exists(options.strTargetPath) == false)\n        QDir().mkpath(options.strTargetPath);\n\n    // 解压完整文件名（含路径）\n    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;\n\n    QFile file(strDestFileName);\n\n    // Store parent mtime.\n    QString parentDir;\n    if (strFileName.endsWith(QDir::separator())) {\n        QDir pDir = QFileInfo(strDestFileName).dir();\n        pDir.cdUp();\n        parentDir = pDir.path();\n    } else {\n        parentDir = QFileInfo(strDestFileName).path();\n    }\n    // For top-level items, don't restore parent dir mtime.\n    const bool restoreParentMtime = (parentDir != options.strTargetPath);\n\n    time_t parent_mtime;\n    if (restoreParentMtime) {\n        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;\n    }\n\n    // 获取外部信息（权限）\n    zip_uint8_t opsys;\n    zip_uint32_t attributes;\n    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {\n        emit error((\"Failed to read metadata for entry: %1\"));\n    }\n\n    // 从压缩包中获取文件权限\n    mode_t value = mode_t();\n    switch (opsys) {\n    case ZIP_OPSYS_UNIX:\n        value = attributes >> 16;\n        break;\n    default:    // TODO: non-UNIX.\n        break;\n    }\n    bool isLink = false;\n    if(S_ISLNK(value)) {\n        isLink = true;\n    }\n    QFileDevice::Permissions per = getPermissions(value);\n\n    if (bIsDirectory && !isLink) {     // 文件夹\n        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())\n            return ET_LongNameError;\n\n        QDir dir;\n        dir.mkpath(strDestFileName);\n\n        // 文件夹加可执行权限\n        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;\n    } else if(isLink) { //软连接解压\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        char buf[READBYTES] = {0};\n        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n        if (readBytes > 0) {\n            QString strBuf = QString(buf).toLocal8Bit();\n            if (QFile::link(strBuf, strDestFileName)) {\n                qInfo() << \"Symlink's created:\" << buf << strFileName;\n            } else {\n                qInfo() << \"Can't create symlink\" << buf << strFileName;\n            }\n        }\n        file.close();\n        zip_fclose(zipFile);\n    } else {        // 普通文件\n\n        // 判断是否有同名文件\n        if (file.exists()) {\n            if (m_bSkipAll) {       // 全部跳过\n                m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数\n                return ET_NoError;\n            } else {\n                if (!m_bOverwriteAll) {     // 若不是全部覆盖，单条处理\n\n                    OverwriteQuery query(strDestFileName);\n\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit signalCancel();\n                        return ET_UserCancelOpertion;\n                    } else if (query.responseSkip()) {\n                        m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数\n                        return ET_NoError;\n                    } else if (query.responseSkipAll()) {\n                        m_bSkipAll = true;\n                        m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数\n                        return ET_NoError;\n                    }  else if (query.responseOverwriteAll()) {\n                        m_bOverwriteAll = true;\n                    }\n                }\n            }\n        }\n\n        if (bHandleLongName) {\n            m_setLongName << strFileName;\n        }\n\n        // 若文件存在且不是可写权限，重新创建一个文件\n        if (file.exists() && !file.isWritable()) {\n            file.remove();\n            file.setFileName(strDestFileName);\n            file.setPermissions(QFileDevice::WriteUser);\n        }\n\n        // 对文件路径做判断，防止特殊包未先解压出文件夹，导致解压失败\n        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)\n            QDir().mkpath(QFileInfo(strDestFileName).path());\n\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        // 错误处理\n        if (nullptr == zipFile) {\n            int iErr = zip_error_code_zip(zip_get_error(archive));\n            if (ZIP_ER_WRONGPASSWD == iErr) {//密码错误\n\n                // 对密码编码的探测\n                bool bCheckFinished = false;\n                int iCodecIndex = 0;\n                while (nullptr == zipFile && false == bCheckFinished) {\n                    if (m_listCodecs.length() == iCodecIndex) {\n                        bCheckFinished = true;\n                        if (file.exists()) {\n                            file.remove();\n                        }\n\n                        return ET_WrongPassword;\n                    } else {\n                        // 115645 【专业版】【1060】【归档管理器】【5.12.0.2】无法解压中文密码的zip压缩包（含有长名称）\n                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());\n                        iCodecIndex++;\n                        zip_error_clear(archive);\n                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n                        iErr = zip_error_code_zip(zip_get_error(archive));\n                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {//密码正确\n                            bCheckFinished = true;\n                        }\n                    }\n                }\n            } else if (ZIP_ER_NOPASSWD == iErr) {   // 无密码输入\n                return ET_NeedPassword;\n            } else {\n                return ET_FileOpenError;\n            }\n        }\n\n        // 以只写的方式打开待解压的文件\n        if (file.open(QIODevice::WriteOnly) == false) {\n            zip_fclose(zipFile);\n\n            QList<QString> entryNameList = strDestFileName.split('/');\n            foreach (auto &tmp, entryNameList) {\n                // 判断文件名是否过长\n                if (NAME_MAX < tmp.toLocal8Bit().length()) {\n                    return ET_LongNameError;\n                }\n            }\n\n            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n            return ET_FileWriteError;\n        }\n\n        // 写文件\n        QDataStream out(&file);\n        zip_int64_t sum = 0;\n        char buf[READBYTES];\n        int writeSize = 0;\n        double dScale = 1;\n        // 右键解压时按照文件比例计算大小\n        if (!options.bExistList) {\n            dScale = double(statBuffer.comp_size) / statBuffer.size;\n        }\n        while (sum != zip_int64_t(statBuffer.size)) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                break;\n            }\n\n            if (m_bPause) { //解压暂停\n                sleep(1);\n                continue;\n            }\n\n            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n\n            if (readBytes < 0) {\n                file.close();\n                zip_fclose(zipFile);\n                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                return ET_FileWriteError;\n            }\n\n            if (out.writeRawData(buf, int(readBytes)) != readBytes) {\n                file.close();\n                zip_fclose(zipFile);\n\n                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  // 小于readBytes作为磁盘空间不足的判断标准\n                    return ET_InsufficientDiskSpace;\n                } else {\n                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                    return ET_FileWriteError;\n                }\n            }\n\n            sum += readBytes;\n            writeSize += readBytes;\n\n            // 计算进度并显示（右键快捷解压使用压缩包大小，计算比例）\n            qExtractSize += readBytes * dScale;\n            emit signalprogress((double(qExtractSize)) * m_dScaleSize);\n        }\n\n        file.close();\n        zip_fclose(zipFile);\n    }\n    if(!isLink) {\n        // 设置文件/文件夹权限\n        file.setPermissions(per);\n\n        // Set mtime for entry.\n        utimbuf times;\n        times.modtime = statBuffer.mtime;\n        utime(strDestFileName.toUtf8().constData(), &times);\n\n        if (restoreParentMtime) {\n            // Restore mtime for parent dir.\n            times.modtime = parent_mtime;\n            utime(parentDir.toUtf8().constData(), &times);\n        }\n    }\n    m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数\n    return ET_NoError;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,11 @@\n     }\n \n     strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // 解压文件名（压缩包中）\n+    //fix 232873\n+    if(strFileName.indexOf(\"../\") != -1) {\n+        qInfo() << \"skipped ../ path component(s) in \" << strFileName;\n+        strFileName = strFileName.replace(\"../\", \"\");\n+    }\n     if(strFileName.contains(QLatin1Char('\\\\')))\n         strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n     QString strOriginName = strFileName;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    //fix 232873",
                "    if(strFileName.indexOf(\"../\") != -1) {",
                "        qInfo() << \"skipped ../ path component(s) in \" << strFileName;",
                "        strFileName = strFileName.replace(\"../\", \"\");",
                "    }"
            ]
        }
    }
]