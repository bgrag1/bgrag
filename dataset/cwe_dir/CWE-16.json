[
    {
        "cve_id": "CVE-2012-1909",
        "func_name": "sipa/bitcoin/CTransaction::DisconnectInputs",
        "description": "The Bitcoin protocol, as used in bitcoind before 0.4.4, wxBitcoin, Bitcoin-Qt, and other programs, does not properly handle multiple transactions with the same identifier, which allows remote attackers to cause a denial of service (unspendable transaction) by leveraging the ability to create a duplicate coinbase transaction.",
        "git_url": "https://github.com/sipa/bitcoin/commit/a206b0ea12eb4606b93323268fc81a4f1f952531",
        "commit_title": "Do not allow overwriting unspent transactions (BIP 30)",
        "commit_text": " Introduce the following network rule:  * a block is not valid if it contains a transaction whose hash    already exists in the block chain, unless all that transaction's    outputs were already spent before said block.  Warning: this is effectively a network rule change, with potential risk for forking the block chain. Leaving this unfixed carries the same risk however, for attackers that can cause a reorganisation in part of the network.  Thanks to Russell O'Connor and Ben Reeves.",
        "func_before": "bool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    if (!txdb.EraseTxIndex(*this))\n        return error(\"DisconnectInputs() : EraseTxPos failed\");\n\n    return true;\n}",
        "func": "bool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,8 +25,10 @@\n     }\n \n     // Remove transaction from index\n-    if (!txdb.EraseTxIndex(*this))\n-        return error(\"DisconnectInputs() : EraseTxPos failed\");\n+    // This can fail if a duplicate of this transaction was in a chain that got\n+    // reorganized away. This is only possible if this transaction was completely\n+    // spent, so erasing it would be a no-op anway.\n+    txdb.EraseTxIndex(*this);\n \n     return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!txdb.EraseTxIndex(*this))",
                "        return error(\"DisconnectInputs() : EraseTxPos failed\");"
            ],
            "added_lines": [
                "    // This can fail if a duplicate of this transaction was in a chain that got",
                "    // reorganized away. This is only possible if this transaction was completely",
                "    // spent, so erasing it would be a no-op anway.",
                "    txdb.EraseTxIndex(*this);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-1909",
        "func_name": "sipa/bitcoin/CBlock::ConnectBlock",
        "description": "The Bitcoin protocol, as used in bitcoind before 0.4.4, wxBitcoin, Bitcoin-Qt, and other programs, does not properly handle multiple transactions with the same identifier, which allows remote attackers to cause a denial of service (unspendable transaction) by leveraging the ability to create a duplicate coinbase transaction.",
        "git_url": "https://github.com/sipa/bitcoin/commit/a206b0ea12eb4606b93323268fc81a4f1f952531",
        "commit_title": "Do not allow overwriting unspent transactions (BIP 30)",
        "commit_text": " Introduce the following network rule:  * a block is not valid if it contains a transaction whose hash    already exists in the block chain, unless all that transaction's    outputs were already spent before said block.  Warning: this is effectively a network rule change, with potential risk for forking the block chain. Leaving this unfixed carries the same risk however, for attackers that can cause a reorganisation in part of the network.  Thanks to Russell O'Connor and Ben Reeves.",
        "func_before": "bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Check it again in case a previous version let a bad block in\n    if (!CheckBlock())\n        return false;\n\n    // To avoid being on the short end of a block-chain split,\n    // don't do secondary validation of pay-to-script-hash transactions\n    // until blocks with timestamps after paytoscripthashtime (see init.cpp for default).\n    // This code can be removed once a super-majority of the network has upgraded.\n    int64 nEvalSwitchTime = GetArg(\"-paytoscripthashtime\", std::numeric_limits<int64_t>::max());\n    bool fStrictPayToScriptHash = (pindex->nTime >= nEvalSwitchTime);\n\n    //// issue here: it doesn't know the version\n    unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64 nFees = 0;\n    int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK);\n\n        MapPrevTx mapInputs;\n        if (!tx.IsCoinBase())\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            if (fStrictPayToScriptHash)\n            {\n                // Add in sigops done by pay-to-script-hash inputs;\n                // this is to prevent a \"rogue miner\" from creating\n                // an incredibly-expensive-to-validate block.\n                nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n                if (nSigOps > MAX_BLOCK_SIGOPS)\n                    return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n            }\n\n            nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n\n            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n                return false;\n        }\n\n        mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n        return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}",
        "func": "bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Check it again in case a previous version let a bad block in\n    if (!CheckBlock())\n        return false;\n\n    // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n    // unless those are already completely spent.\n    // If such overwrites are allowed, coinbases and transactions depending upon those\n    // can be duplicated to remove the ability to spend the first instance -- even after\n    // being sent to another address.\n    // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n    // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n    // already refuses previously-known transaction id's entirely.\n    // This rule applies to all blocks whose timestamp is after March 15, 2012, 0:00 UTC.\n    // On testnet it is enabled as of februari 20, 2012, 0:00 UTC.\n    if (pindex->nTime > 1331769600 || (fTestNet && pindex->nTime > 1329696000))\n        BOOST_FOREACH(CTransaction& tx, vtx)\n        {\n            CTxIndex txindexOld;\n            if (txdb.ReadTxIndex(tx.GetHash(), txindexOld))\n                BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                    if (pos.IsNull())\n                        return false;\n        }\n\n    // To avoid being on the short end of a block-chain split,\n    // don't do secondary validation of pay-to-script-hash transactions\n    // until blocks with timestamps after paytoscripthashtime (see init.cpp for default).\n    // This code can be removed once a super-majority of the network has upgraded.\n    int64 nEvalSwitchTime = GetArg(\"-paytoscripthashtime\", std::numeric_limits<int64_t>::max());\n    bool fStrictPayToScriptHash = (pindex->nTime >= nEvalSwitchTime);\n\n    //// issue here: it doesn't know the version\n    unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64 nFees = 0;\n    int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK);\n\n        MapPrevTx mapInputs;\n        if (!tx.IsCoinBase())\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            if (fStrictPayToScriptHash)\n            {\n                // Add in sigops done by pay-to-script-hash inputs;\n                // this is to prevent a \"rogue miner\" from creating\n                // an incredibly-expensive-to-validate block.\n                nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n                if (nSigOps > MAX_BLOCK_SIGOPS)\n                    return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n            }\n\n            nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n\n            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n                return false;\n        }\n\n        mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n        return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,26 @@\n     // Check it again in case a previous version let a bad block in\n     if (!CheckBlock())\n         return false;\n+\n+    // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n+    // unless those are already completely spent.\n+    // If such overwrites are allowed, coinbases and transactions depending upon those\n+    // can be duplicated to remove the ability to spend the first instance -- even after\n+    // being sent to another address.\n+    // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n+    // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n+    // already refuses previously-known transaction id's entirely.\n+    // This rule applies to all blocks whose timestamp is after March 15, 2012, 0:00 UTC.\n+    // On testnet it is enabled as of februari 20, 2012, 0:00 UTC.\n+    if (pindex->nTime > 1331769600 || (fTestNet && pindex->nTime > 1329696000))\n+        BOOST_FOREACH(CTransaction& tx, vtx)\n+        {\n+            CTxIndex txindexOld;\n+            if (txdb.ReadTxIndex(tx.GetHash(), txindexOld))\n+                BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n+                    if (pos.IsNull())\n+                        return false;\n+        }\n \n     // To avoid being on the short end of a block-chain split,\n     // don't do secondary validation of pay-to-script-hash transactions",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    // Do not allow blocks that contain transactions which 'overwrite' older transactions,",
                "    // unless those are already completely spent.",
                "    // If such overwrites are allowed, coinbases and transactions depending upon those",
                "    // can be duplicated to remove the ability to spend the first instance -- even after",
                "    // being sent to another address.",
                "    // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.",
                "    // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool",
                "    // already refuses previously-known transaction id's entirely.",
                "    // This rule applies to all blocks whose timestamp is after March 15, 2012, 0:00 UTC.",
                "    // On testnet it is enabled as of februari 20, 2012, 0:00 UTC.",
                "    if (pindex->nTime > 1331769600 || (fTestNet && pindex->nTime > 1329696000))",
                "        BOOST_FOREACH(CTransaction& tx, vtx)",
                "        {",
                "            CTxIndex txindexOld;",
                "            if (txdb.ReadTxIndex(tx.GetHash(), txindexOld))",
                "                BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)",
                "                    if (pos.IsNull())",
                "                        return false;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0957",
        "func_name": "torvalds/linux/override_release",
        "description": "The override_release function in kernel/sys.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from kernel stack memory via a uname system call in conjunction with a UNAME26 personality.",
        "git_url": "https://github.com/torvalds/linux/commit/2702b1526c7278c4d65d78de209a465d4de2885e",
        "commit_title": "kernel/sys.c: fix stack memory content leak via UNAME26",
        "commit_text": " Calling uname() with the UNAME26 personality set allows a leak of kernel stack contents.  This fixes it by defensively calculating the length of copy_to_user() call, making the len argument unsigned, and initializing the stack buffer to zero (now technically unneeded, but hey, overkill).  CVE-2012-0957  Cc: Andi Kleen <ak@linux.intel.com> Cc: PaX Team <pageexec@freemail.hu> Cc: Brad Spengler <spender@grsecurity.net> Cc: <stable@vger.kernel.org>",
        "func_before": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}",
        "func": "static int override_release(char __user *release, size_t len)\n{\n\tint ret = 0;\n\n\tif (current->personality & UNAME26) {\n\t\tconst char *rest = UTS_RELEASE;\n\t\tchar buf[65] = { 0 };\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\tsize_t copy;\n\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tcopy = min(sizeof(buf), max_t(size_t, 1, len));\n\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, copy + 1);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,13 @@\n-static int override_release(char __user *release, int len)\n+static int override_release(char __user *release, size_t len)\n {\n \tint ret = 0;\n-\tchar buf[65];\n \n \tif (current->personality & UNAME26) {\n-\t\tchar *rest = UTS_RELEASE;\n+\t\tconst char *rest = UTS_RELEASE;\n+\t\tchar buf[65] = { 0 };\n \t\tint ndots = 0;\n \t\tunsigned v;\n+\t\tsize_t copy;\n \n \t\twhile (*rest) {\n \t\t\tif (*rest == '.' && ++ndots >= 3)\n@@ -16,8 +17,9 @@\n \t\t\trest++;\n \t\t}\n \t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n-\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n-\t\tret = copy_to_user(release, buf, len);\n+\t\tcopy = min(sizeof(buf), max_t(size_t, 1, len));\n+\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);\n+\t\tret = copy_to_user(release, buf, copy + 1);\n \t}\n \treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int override_release(char __user *release, int len)",
                "\tchar buf[65];",
                "\t\tchar *rest = UTS_RELEASE;",
                "\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);",
                "\t\tret = copy_to_user(release, buf, len);"
            ],
            "added_lines": [
                "static int override_release(char __user *release, size_t len)",
                "\t\tconst char *rest = UTS_RELEASE;",
                "\t\tchar buf[65] = { 0 };",
                "\t\tsize_t copy;",
                "\t\tcopy = min(sizeof(buf), max_t(size_t, 1, len));",
                "\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);",
                "\t\tret = copy_to_user(release, buf, copy + 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1184",
        "func_name": "torvalds/linux/selinux_ip_postroute_iptables_compat",
        "description": "The selinux_ip_postroute_iptables_compat function in security/selinux/hooks.c in the SELinux subsystem in the Linux kernel before 2.6.27.22, and 2.6.28.x before 2.6.28.10, when compat_net is enabled, omits calls to avc_has_perm for the (1) node and (2) port, which allows local users to bypass intended restrictions on network traffic.  NOTE: this was incorrectly reported as an issue fixed in 2.6.27.21.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/stable/linux.git;a=commit;h=910c9e41186762de3717baaf392ab5ff0c454496",
        "commit_title": "Not upstream in 2.6.30, as the function was removed there, making this a",
        "commit_text": "non-issue.  Node and port send checks can skip in the compat_net=1 case. This bug was introduced in commit effad8d.   ",
        "func_before": "static int selinux_ip_postroute_iptables_compat(struct sock *sk,\n\t\t\t\t\t\tint ifindex,\n\t\t\t\t\t\tstruct avc_audit_data *ad,\n\t\t\t\t\t\tu16 family, char *addrp)\n{\n\tint err;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 sk_class;\n\tu32 netif_perm, node_perm, send_perm;\n\tu32 port_sid, node_sid, if_sid, sk_sid;\n\n\tsk_sid = sksec->sid;\n\tsk_class = sksec->sclass;\n\n\tswitch (sk_class) {\n\tcase SECCLASS_UDP_SOCKET:\n\t\tnetif_perm = NETIF__UDP_SEND;\n\t\tnode_perm = NODE__UDP_SEND;\n\t\tsend_perm = UDP_SOCKET__SEND_MSG;\n\t\tbreak;\n\tcase SECCLASS_TCP_SOCKET:\n\t\tnetif_perm = NETIF__TCP_SEND;\n\t\tnode_perm = NODE__TCP_SEND;\n\t\tsend_perm = TCP_SOCKET__SEND_MSG;\n\t\tbreak;\n\tcase SECCLASS_DCCP_SOCKET:\n\t\tnetif_perm = NETIF__DCCP_SEND;\n\t\tnode_perm = NODE__DCCP_SEND;\n\t\tsend_perm = DCCP_SOCKET__SEND_MSG;\n\t\tbreak;\n\tdefault:\n\t\tnetif_perm = NETIF__RAWIP_SEND;\n\t\tnode_perm = NODE__RAWIP_SEND;\n\t\tsend_perm = 0;\n\t\tbreak;\n\t}\n\n\terr = sel_netif_sid(ifindex, &if_sid);\n\tif (err)\n\t\treturn err;\n\terr = avc_has_perm(sk_sid, if_sid, SECCLASS_NETIF, netif_perm, ad);\n\t\treturn err;\n\n\terr = sel_netnode_sid(addrp, family, &node_sid);\n\tif (err)\n\t\treturn err;\n\terr = avc_has_perm(sk_sid, node_sid, SECCLASS_NODE, node_perm, ad);\n\tif (err)\n\t\treturn err;\n\n\tif (send_perm != 0)\n\t\treturn 0;\n\n\terr = sel_netport_sid(sk->sk_protocol,\n\t\t\t      ntohs(ad->u.net.dport), &port_sid);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in\"\n\t\t       \" selinux_ip_postroute_iptables_compat(),\"\n\t\t       \" network port label not found\\n\");\n\t\treturn err;\n\t}\n\treturn avc_has_perm(sk_sid, port_sid, sk_class, send_perm, ad);\n}",
        "func": "static int selinux_ip_postroute_iptables_compat(struct sock *sk,\n\t\t\t\t\t\tint ifindex,\n\t\t\t\t\t\tstruct avc_audit_data *ad,\n\t\t\t\t\t\tu16 family, char *addrp)\n{\n\tint err;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 sk_class;\n\tu32 netif_perm, node_perm, send_perm;\n\tu32 port_sid, node_sid, if_sid, sk_sid;\n\n\tsk_sid = sksec->sid;\n\tsk_class = sksec->sclass;\n\n\tswitch (sk_class) {\n\tcase SECCLASS_UDP_SOCKET:\n\t\tnetif_perm = NETIF__UDP_SEND;\n\t\tnode_perm = NODE__UDP_SEND;\n\t\tsend_perm = UDP_SOCKET__SEND_MSG;\n\t\tbreak;\n\tcase SECCLASS_TCP_SOCKET:\n\t\tnetif_perm = NETIF__TCP_SEND;\n\t\tnode_perm = NODE__TCP_SEND;\n\t\tsend_perm = TCP_SOCKET__SEND_MSG;\n\t\tbreak;\n\tcase SECCLASS_DCCP_SOCKET:\n\t\tnetif_perm = NETIF__DCCP_SEND;\n\t\tnode_perm = NODE__DCCP_SEND;\n\t\tsend_perm = DCCP_SOCKET__SEND_MSG;\n\t\tbreak;\n\tdefault:\n\t\tnetif_perm = NETIF__RAWIP_SEND;\n\t\tnode_perm = NODE__RAWIP_SEND;\n\t\tsend_perm = 0;\n\t\tbreak;\n\t}\n\n\terr = sel_netif_sid(ifindex, &if_sid);\n\tif (err)\n\t\treturn err;\n\terr = avc_has_perm(sk_sid, if_sid, SECCLASS_NETIF, netif_perm, ad);\n\tif (err)\n\t\treturn err;\n\n\terr = sel_netnode_sid(addrp, family, &node_sid);\n\tif (err)\n\t\treturn err;\n\terr = avc_has_perm(sk_sid, node_sid, SECCLASS_NODE, node_perm, ad);\n\tif (err)\n\t\treturn err;\n\n\tif (send_perm != 0)\n\t\treturn 0;\n\n\terr = sel_netport_sid(sk->sk_protocol,\n\t\t\t      ntohs(ad->u.net.dport), &port_sid);\n\tif (unlikely(err)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in\"\n\t\t       \" selinux_ip_postroute_iptables_compat(),\"\n\t\t       \" network port label not found\\n\");\n\t\treturn err;\n\t}\n\treturn avc_has_perm(sk_sid, port_sid, sk_class, send_perm, ad);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,7 @@\n \tif (err)\n \t\treturn err;\n \terr = avc_has_perm(sk_sid, if_sid, SECCLASS_NETIF, netif_perm, ad);\n+\tif (err)\n \t\treturn err;\n \n \terr = sel_netnode_sid(addrp, family, &node_sid);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (err)"
            ]
        }
    }
]