[
    {
        "cve_id": "CVE-2019-16714",
        "func_name": "torvalds/linux/rds6_inc_info_copy",
        "description": "In the Linux kernel before 5.2.14, rds6_inc_info_copy in net/rds/recv.c allows attackers to obtain sensitive information from kernel stack memory because tos and flags fields are not initialized.",
        "git_url": "https://github.com/torvalds/linux/commit/7d0a06586b2686ba80c4a2da5f91cb10ffbea736",
        "commit_title": "net/rds: Fix info leak in rds6_inc_info_copy()",
        "commit_text": " The rds6_inc_info_copy() function has a couple struct members which are leaking stack information.  The ->tos field should hold actual information and the ->flags field needs to be zeroed out. ",
        "func_before": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n\n\tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n\n\tif (flip) {\n\t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n\t\tminfo6.fport = inc->i_hdr.h_dport;\n\t}\n\n\trds_info_copy(iter, &minfo6, sizeof(minfo6));\n}",
        "func": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n\n\tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n\tminfo6.tos = inc->i_conn->c_tos;\n\n\tif (flip) {\n\t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n\t\tminfo6.fport = inc->i_hdr.h_dport;\n\t}\n\n\tminfo6.flags = 0;\n\n\trds_info_copy(iter, &minfo6, sizeof(minfo6));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n \n \tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n \tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n+\tminfo6.tos = inc->i_conn->c_tos;\n \n \tif (flip) {\n \t\tminfo6.laddr = *daddr;\n@@ -20,5 +21,7 @@\n \t\tminfo6.fport = inc->i_hdr.h_dport;\n \t}\n \n+\tminfo6.flags = 0;\n+\n \trds_info_copy(iter, &minfo6, sizeof(minfo6));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tminfo6.tos = inc->i_conn->c_tos;",
                "\tminfo6.flags = 0;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0382",
        "func_name": "torvalds/linux/__tipc_sendmsg",
        "description": "An information leak flaw was found due to uninitialized memory in the Linux kernel's TIPC protocol subsystem, in the way a user sends a TIPC datagram to one or more destinations. This flaw allows a local user to read some kernel memory. This issue is limited to no more than 7 bytes, and the user cannot control what is read. This flaw affects the Linux kernel versions prior to 5.17-rc1.",
        "git_url": "https://github.com/torvalds/linux/commit/d6d86830705f173fca6087a3e67ceaf68db80523",
        "commit_title": "net ticp:fix a kernel-infoleak in __tipc_sendmsg()",
        "commit_text": " struct tipc_socket_addr.ref has a 4-byte hole,and __tipc_getname() currently copying it to user space,causing kernel-infoleak.  BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] BUG: KMSAN: kernel-infoleak in instrument_copy_to_user include/linux/instrumented.h:121 [inline] lib/usercopy.c:33 BUG: KMSAN: kernel-infoleak in _copy_to_user+0x1c9/0x270 lib/usercopy.c:33 lib/usercopy.c:33  instrument_copy_to_user include/linux/instrumented.h:121 [inline]  instrument_copy_to_user include/linux/instrumented.h:121 [inline] lib/usercopy.c:33  _copy_to_user+0x1c9/0x270 lib/usercopy.c:33 lib/usercopy.c:33  copy_to_user include/linux/uaccess.h:209 [inline]  copy_to_user include/linux/uaccess.h:209 [inline] net/socket.c:287  move_addr_to_user+0x3f6/0x600 net/socket.c:287 net/socket.c:287  __sys_getpeername+0x470/0x6b0 net/socket.c:1987 net/socket.c:1987  __do_sys_getpeername net/socket.c:1997 [inline]  __se_sys_getpeername net/socket.c:1994 [inline]  __do_sys_getpeername net/socket.c:1997 [inline] net/socket.c:1994  __se_sys_getpeername net/socket.c:1994 [inline] net/socket.c:1994  __x64_sys_getpeername+0xda/0x120 net/socket.c:1994 net/socket.c:1994  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_x64 arch/x86/entry/common.c:51 [inline] arch/x86/entry/common.c:82  do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x44/0xae  Uninit was stored to memory at:  tipc_getname+0x575/0x5e0 net/tipc/socket.c:757 net/tipc/socket.c:757  __sys_getpeername+0x3b3/0x6b0 net/socket.c:1984 net/socket.c:1984  __do_sys_getpeername net/socket.c:1997 [inline]  __se_sys_getpeername net/socket.c:1994 [inline]  __do_sys_getpeername net/socket.c:1997 [inline] net/socket.c:1994  __se_sys_getpeername net/socket.c:1994 [inline] net/socket.c:1994  __x64_sys_getpeername+0xda/0x120 net/socket.c:1994 net/socket.c:1994  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_x64 arch/x86/entry/common.c:51 [inline] arch/x86/entry/common.c:82  do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x44/0xae  Uninit was stored to memory at:  msg_set_word net/tipc/msg.h:212 [inline]  msg_set_destport net/tipc/msg.h:619 [inline]  msg_set_word net/tipc/msg.h:212 [inline] net/tipc/socket.c:1486  msg_set_destport net/tipc/msg.h:619 [inline] net/tipc/socket.c:1486  __tipc_sendmsg+0x44fa/0x5890 net/tipc/socket.c:1486 net/tipc/socket.c:1486  tipc_sendmsg+0xeb/0x140 net/tipc/socket.c:1402 net/tipc/socket.c:1402  sock_sendmsg_nosec net/socket.c:704 [inline]  sock_sendmsg net/socket.c:724 [inline]  sock_sendmsg_nosec net/socket.c:704 [inline] net/socket.c:2409  sock_sendmsg net/socket.c:724 [inline] net/socket.c:2409  ____sys_sendmsg+0xe11/0x12c0 net/socket.c:2409 net/socket.c:2409  ___sys_sendmsg net/socket.c:2463 [inline]  ___sys_sendmsg net/socket.c:2463 [inline] net/socket.c:2492  __sys_sendmsg+0x704/0x840 net/socket.c:2492 net/socket.c:2492  __do_sys_sendmsg net/socket.c:2501 [inline]  __se_sys_sendmsg net/socket.c:2499 [inline]  __do_sys_sendmsg net/socket.c:2501 [inline] net/socket.c:2499  __se_sys_sendmsg net/socket.c:2499 [inline] net/socket.c:2499  __x64_sys_sendmsg+0xe2/0x120 net/socket.c:2499 net/socket.c:2499  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_x64 arch/x86/entry/common.c:51 [inline] arch/x86/entry/common.c:82  do_syscall_64+0x54/0xd0 arch/x86/entry/common.c:82 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x44/0xae  Local variable skaddr created at:  __tipc_sendmsg+0x2d0/0x5890 net/tipc/socket.c:1419 net/tipc/socket.c:1419  tipc_sendmsg+0xeb/0x140 net/tipc/socket.c:1402 net/tipc/socket.c:1402  Bytes 4-7 of 16 are uninitialized Memory access of size 16 starts at ffff888113753e00 Data copied to user address 0000000020000280  Link: https://lore.kernel.org/r/1640918123-14547-1-git-send-email-tcs.kernel@gmail.com",
        "func_before": "static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name;\n\tlong timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT);\n\tstruct list_head *clinks = &tsk->cong_links;\n\tbool syn = !tipc_sk_type_connectionless(sk);\n\tstruct tipc_group *grp = tsk->group;\n\tstruct tipc_msg *hdr = &tsk->phdr;\n\tstruct tipc_socket_addr skaddr;\n\tstruct sk_buff_head pkts;\n\tint atype, mtu, rc;\n\n\tif (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))\n\t\treturn -EMSGSIZE;\n\n\tif (ua) {\n\t\tif (!tipc_uaddr_valid(ua, m->msg_namelen))\n\t\t\treturn -EINVAL;\n\t\tatype = ua->addrtype;\n\t}\n\n\t/* If socket belongs to a communication group follow other paths */\n\tif (grp) {\n\t\tif (!ua)\n\t\t\treturn tipc_send_group_bcast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\treturn tipc_send_group_anycast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SOCKET_ADDR)\n\t\t\treturn tipc_send_group_unicast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_RANGE)\n\t\t\treturn tipc_send_group_mcast(sock, m, dlen, timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ua) {\n\t\tua = (struct tipc_uaddr *)&tsk->peer;\n\t\tif (!syn && ua->family != AF_TIPC)\n\t\t\treturn -EDESTADDRREQ;\n\t\tatype = ua->addrtype;\n\t}\n\n\tif (unlikely(syn)) {\n\t\tif (sk->sk_state == TIPC_LISTEN)\n\t\t\treturn -EPIPE;\n\t\tif (sk->sk_state != TIPC_OPEN)\n\t\t\treturn -EISCONN;\n\t\tif (tsk->published)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\ttsk->conn_addrtype = atype;\n\t\tmsg_set_syn(hdr, 1);\n\t}\n\n\t/* Determine destination */\n\tif (atype == TIPC_SERVICE_RANGE) {\n\t\treturn tipc_sendmcast(sock, ua, m, dlen, timeout);\n\t} else if (atype == TIPC_SERVICE_ADDR) {\n\t\tskaddr.node = ua->lookup_node;\n\t\tua->scope = tipc_node2scope(skaddr.node);\n\t\tif (!tipc_nametbl_lookup_anycast(net, ua, &skaddr))\n\t\t\treturn -EHOSTUNREACH;\n\t} else if (atype == TIPC_SOCKET_ADDR) {\n\t\tskaddr = ua->sk;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Block or return if destination link is congested */\n\trc = tipc_wait_for_cond(sock, &timeout,\n\t\t\t\t!tipc_dest_find(clinks, skaddr.node, 0));\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\t/* Finally build message header */\n\tmsg_set_destnode(hdr, skaddr.node);\n\tmsg_set_destport(hdr, skaddr.ref);\n\tif (atype == TIPC_SERVICE_ADDR) {\n\t\tmsg_set_type(hdr, TIPC_NAMED_MSG);\n\t\tmsg_set_hdr_sz(hdr, NAMED_H_SIZE);\n\t\tmsg_set_nametype(hdr, ua->sa.type);\n\t\tmsg_set_nameinst(hdr, ua->sa.instance);\n\t\tmsg_set_lookup_scope(hdr, ua->scope);\n\t} else { /* TIPC_SOCKET_ADDR */\n\t\tmsg_set_type(hdr, TIPC_DIRECT_MSG);\n\t\tmsg_set_lookup_scope(hdr, 0);\n\t\tmsg_set_hdr_sz(hdr, BASIC_H_SIZE);\n\t}\n\n\t/* Add message body */\n\t__skb_queue_head_init(&pkts);\n\tmtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true);\n\trc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);\n\tif (unlikely(rc != dlen))\n\t\treturn rc;\n\tif (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) {\n\t\t__skb_queue_purge(&pkts);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Send message */\n\ttrace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, \" \");\n\trc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid);\n\tif (unlikely(rc == -ELINKCONG)) {\n\t\ttipc_dest_push(clinks, skaddr.node, 0);\n\t\ttsk->cong_link_cnt++;\n\t\trc = 0;\n\t}\n\n\tif (unlikely(syn && !rc)) {\n\t\ttipc_set_sk_state(sk, TIPC_CONNECTING);\n\t\tif (dlen && timeout) {\n\t\t\ttimeout = msecs_to_jiffies(timeout);\n\t\t\ttipc_wait_for_connect(sock, &timeout);\n\t\t}\n\t}\n\n\treturn rc ? rc : dlen;\n}",
        "func": "static int __tipc_sendmsg(struct socket *sock, struct msghdr *m, size_t dlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct tipc_uaddr *ua = (struct tipc_uaddr *)m->msg_name;\n\tlong timeout = sock_sndtimeo(sk, m->msg_flags & MSG_DONTWAIT);\n\tstruct list_head *clinks = &tsk->cong_links;\n\tbool syn = !tipc_sk_type_connectionless(sk);\n\tstruct tipc_group *grp = tsk->group;\n\tstruct tipc_msg *hdr = &tsk->phdr;\n\tstruct tipc_socket_addr skaddr;\n\tstruct sk_buff_head pkts;\n\tint atype, mtu, rc;\n\n\tif (unlikely(dlen > TIPC_MAX_USER_MSG_SIZE))\n\t\treturn -EMSGSIZE;\n\n\tif (ua) {\n\t\tif (!tipc_uaddr_valid(ua, m->msg_namelen))\n\t\t\treturn -EINVAL;\n\t\tatype = ua->addrtype;\n\t}\n\n\t/* If socket belongs to a communication group follow other paths */\n\tif (grp) {\n\t\tif (!ua)\n\t\t\treturn tipc_send_group_bcast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\treturn tipc_send_group_anycast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SOCKET_ADDR)\n\t\t\treturn tipc_send_group_unicast(sock, m, dlen, timeout);\n\t\tif (atype == TIPC_SERVICE_RANGE)\n\t\t\treturn tipc_send_group_mcast(sock, m, dlen, timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ua) {\n\t\tua = (struct tipc_uaddr *)&tsk->peer;\n\t\tif (!syn && ua->family != AF_TIPC)\n\t\t\treturn -EDESTADDRREQ;\n\t\tatype = ua->addrtype;\n\t}\n\n\tif (unlikely(syn)) {\n\t\tif (sk->sk_state == TIPC_LISTEN)\n\t\t\treturn -EPIPE;\n\t\tif (sk->sk_state != TIPC_OPEN)\n\t\t\treturn -EISCONN;\n\t\tif (tsk->published)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (atype == TIPC_SERVICE_ADDR)\n\t\t\ttsk->conn_addrtype = atype;\n\t\tmsg_set_syn(hdr, 1);\n\t}\n\n\tmemset(&skaddr, 0, sizeof(skaddr));\n\n\t/* Determine destination */\n\tif (atype == TIPC_SERVICE_RANGE) {\n\t\treturn tipc_sendmcast(sock, ua, m, dlen, timeout);\n\t} else if (atype == TIPC_SERVICE_ADDR) {\n\t\tskaddr.node = ua->lookup_node;\n\t\tua->scope = tipc_node2scope(skaddr.node);\n\t\tif (!tipc_nametbl_lookup_anycast(net, ua, &skaddr))\n\t\t\treturn -EHOSTUNREACH;\n\t} else if (atype == TIPC_SOCKET_ADDR) {\n\t\tskaddr = ua->sk;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Block or return if destination link is congested */\n\trc = tipc_wait_for_cond(sock, &timeout,\n\t\t\t\t!tipc_dest_find(clinks, skaddr.node, 0));\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\t/* Finally build message header */\n\tmsg_set_destnode(hdr, skaddr.node);\n\tmsg_set_destport(hdr, skaddr.ref);\n\tif (atype == TIPC_SERVICE_ADDR) {\n\t\tmsg_set_type(hdr, TIPC_NAMED_MSG);\n\t\tmsg_set_hdr_sz(hdr, NAMED_H_SIZE);\n\t\tmsg_set_nametype(hdr, ua->sa.type);\n\t\tmsg_set_nameinst(hdr, ua->sa.instance);\n\t\tmsg_set_lookup_scope(hdr, ua->scope);\n\t} else { /* TIPC_SOCKET_ADDR */\n\t\tmsg_set_type(hdr, TIPC_DIRECT_MSG);\n\t\tmsg_set_lookup_scope(hdr, 0);\n\t\tmsg_set_hdr_sz(hdr, BASIC_H_SIZE);\n\t}\n\n\t/* Add message body */\n\t__skb_queue_head_init(&pkts);\n\tmtu = tipc_node_get_mtu(net, skaddr.node, tsk->portid, true);\n\trc = tipc_msg_build(hdr, m, 0, dlen, mtu, &pkts);\n\tif (unlikely(rc != dlen))\n\t\treturn rc;\n\tif (unlikely(syn && !tipc_msg_skb_clone(&pkts, &sk->sk_write_queue))) {\n\t\t__skb_queue_purge(&pkts);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Send message */\n\ttrace_tipc_sk_sendmsg(sk, skb_peek(&pkts), TIPC_DUMP_SK_SNDQ, \" \");\n\trc = tipc_node_xmit(net, &pkts, skaddr.node, tsk->portid);\n\tif (unlikely(rc == -ELINKCONG)) {\n\t\ttipc_dest_push(clinks, skaddr.node, 0);\n\t\ttsk->cong_link_cnt++;\n\t\trc = 0;\n\t}\n\n\tif (unlikely(syn && !rc)) {\n\t\ttipc_set_sk_state(sk, TIPC_CONNECTING);\n\t\tif (dlen && timeout) {\n\t\t\ttimeout = msecs_to_jiffies(timeout);\n\t\t\ttipc_wait_for_connect(sock, &timeout);\n\t\t}\n\t}\n\n\treturn rc ? rc : dlen;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,6 +53,8 @@\n \t\t\ttsk->conn_addrtype = atype;\n \t\tmsg_set_syn(hdr, 1);\n \t}\n+\n+\tmemset(&skaddr, 0, sizeof(skaddr));\n \n \t/* Determine destination */\n \tif (atype == TIPC_SERVICE_RANGE) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tmemset(&skaddr, 0, sizeof(skaddr));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3804",
        "func_name": "cockpit-project/cockpit/base64_decode_string",
        "description": "It was found that cockpit before version 184 used glib's base64 decode functionality incorrectly resulting in a denial of service attack. An unauthenticated attacker could send a specially crafted request with an invalid base64-encoded cookie which could cause the web service to crash.",
        "git_url": "https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9",
        "commit_title": "ws: Fix bug parsing invalid base64 headers",
        "commit_text": " The len parameter to g_base64_decode_inplace() is a inout\r parameter, and needs to be initialized. Lets just use\r the simpler g_base64_decode() function. This fixes a segfault.\r \r Closes #10819",
        "func_before": "static char *\nbase64_decode_string (const char *enc)\n{\n  if (enc == NULL)\n    return NULL;\n\n  char *dec = g_strdup (enc);\n  gsize len;\n  g_base64_decode_inplace (dec, &len);\n  dec[len] = '\\0';\n  return dec;\n}",
        "func": "static gchar *\nbase64_decode_string (const char *enc)\n{\n  gchar *dec;\n  gsize len;\n\n  if (enc == NULL)\n    return NULL;\n\n  dec = (gchar *)g_base64_decode (enc, &len);\n  if (dec)\n    dec[len] = '\\0';\n\n  return dec;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,15 @@\n-static char *\n+static gchar *\n base64_decode_string (const char *enc)\n {\n+  gchar *dec;\n+  gsize len;\n+\n   if (enc == NULL)\n     return NULL;\n \n-  char *dec = g_strdup (enc);\n-  gsize len;\n-  g_base64_decode_inplace (dec, &len);\n-  dec[len] = '\\0';\n+  dec = (gchar *)g_base64_decode (enc, &len);\n+  if (dec)\n+    dec[len] = '\\0';\n+\n   return dec;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static char *",
                "  char *dec = g_strdup (enc);",
                "  gsize len;",
                "  g_base64_decode_inplace (dec, &len);",
                "  dec[len] = '\\0';"
            ],
            "added_lines": [
                "static gchar *",
                "  gchar *dec;",
                "  gsize len;",
                "",
                "  dec = (gchar *)g_base64_decode (enc, &len);",
                "  if (dec)",
                "    dec[len] = '\\0';",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29968",
        "func_name": "torvalds/linux/io_rw_init_file",
        "description": "An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file in fs/io_uring.c lacks initialization of kiocb->private.",
        "git_url": "https://github.com/torvalds/linux/commit/32452a3eb8b64e01e2be717f518c0be046975b9d",
        "commit_title": "io_uring: fix uninitialized field in rw io_kiocb",
        "commit_text": " io_rw_init_file does not initialize kiocb->private, so when iocb_bio_iopoll reads kiocb->private it can contain uninitialized data. ",
        "func_before": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}",
        "func": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->private = NULL;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,7 @@\n \t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n \t\t\treturn -EOPNOTSUPP;\n \n+\t\tkiocb->private = NULL;\n \t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n \t\tkiocb->ki_complete = io_complete_rw_iopoll;\n \t\treq->iopoll_completed = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tkiocb->private = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3297",
        "func_name": "kernel/git/netdev/net/eql_g_master_cfg",
        "description": "The eql_g_master_cfg function in drivers/net/eql.c in the Linux kernel before 2.6.36-rc5 does not properly initialize a certain structure member, which allows local users to obtain potentially sensitive information from kernel stack memory via an EQL_GETMASTRCFG ioctl call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net.git;a=commit;h=44467187dc22fdd33a1a06ea0ba86ce20be3fe3c",
        "commit_title": "Fixed formatting (tabs and line breaks).",
        "commit_text": " The EQL_GETMASTRCFG device ioctl allows unprivileged users to read 16 bytes of uninitialized stack memory, because the \"master_name\" member of the master_config_t struct declared on the stack in eql_g_master_cfg() is not altered or zeroed before being copied back to the user.  This patch takes care of it.  ",
        "func_before": "static int eql_g_master_cfg(struct net_device *dev, master_config_t __user *mcp)\n{\n\tequalizer_t *eql;\n\tmaster_config_t mc;\n\n\tif (eql_is_master(dev)) {\n\t\teql = netdev_priv(dev);\n\t\tmc.max_slaves = eql->max_slaves;\n\t\tmc.min_slaves = eql->min_slaves;\n\t\tif (copy_to_user(mcp, &mc, sizeof (master_config_t)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "func": "static int eql_g_master_cfg(struct net_device *dev, master_config_t __user *mcp)\n{\n\tequalizer_t *eql;\n\tmaster_config_t mc;\n\n\tmemset(&mc, 0, sizeof(master_config_t));\n\n\tif (eql_is_master(dev)) {\n\t\teql = netdev_priv(dev);\n\t\tmc.max_slaves = eql->max_slaves;\n\t\tmc.min_slaves = eql->min_slaves;\n\t\tif (copy_to_user(mcp, &mc, sizeof (master_config_t)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,8 @@\n {\n \tequalizer_t *eql;\n \tmaster_config_t mc;\n+\n+\tmemset(&mc, 0, sizeof(master_config_t));\n \n \tif (eql_is_master(dev)) {\n \t\teql = netdev_priv(dev);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tmemset(&mc, 0, sizeof(master_config_t));"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4078",
        "func_name": "torvalds/linux/sisfb_ioctl",
        "description": "The sisfb_ioctl function in drivers/video/sis/sis_main.c in the Linux kernel before 2.6.36-rc6 does not properly initialize a certain structure member, which allows local users to obtain potentially sensitive information from kernel stack memory via an FBIOGET_VBLANK ioctl call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=fd02db9de73faebc51240619c7c7f99bee9f65c7",
        "commit_title": "The FBIOGET_VBLANK device ioctl allows unprivileged users to read 16 bytes",
        "commit_text": "of uninitialized stack memory, because the \"reserved\" member of the fb_vblank struct declared on the stack is not altered or zeroed before being copied back to the user.  This patch takes care of it.  Cc: Thomas Winischhofer <thomas@winischhofer.net> Cc: <stable@kernel.org> ",
        "func_before": "static int\tsisfb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct sis_video_info\t*ivideo = (struct sis_video_info *)info->par;\n\tstruct sis_memreq\tsismemreq;\n\tstruct fb_vblank\tsisvbblank;\n\tu32\t\t\tgpu32 = 0;\n#ifndef __user\n#define __user\n#endif\n\tu32 __user \t\t*argp = (u32 __user *)arg;\n\n\tswitch(cmd) {\n\t   case FBIO_ALLOC:\n\t\tif(!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\n\t\tif(copy_from_user(&sismemreq, (void __user *)arg, sizeof(sismemreq)))\n\t\t\treturn -EFAULT;\n\n\t\tsis_malloc(&sismemreq);\n\n\t\tif(copy_to_user((void __user *)arg, &sismemreq, sizeof(sismemreq))) {\n\t\t\tsis_free((u32)sismemreq.offset);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbreak;\n\n\t   case FBIO_FREE:\n\t\tif(!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tsis_free(gpu32);\n\t\tbreak;\n\n\t   case FBIOGET_VBLANK:\n\t\tsisvbblank.count = 0;\n\t\tsisvbblank.flags = sisfb_setupvbblankflags(ivideo, &sisvbblank.vcount, &sisvbblank.hcount);\n\n\t\tif(copy_to_user((void __user *)arg, &sisvbblank, sizeof(sisvbblank)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\t   case SISFB_GET_INFO_SIZE:\n\t\treturn put_user(sizeof(struct sisfb_info), argp);\n\n\t   case SISFB_GET_INFO_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t   case SISFB_GET_INFO:  /* For communication with X driver */\n\t\tivideo->sisfb_infoblock.sisfb_id         = SISFB_ID;\n\t\tivideo->sisfb_infoblock.sisfb_version    = VER_MAJOR;\n\t\tivideo->sisfb_infoblock.sisfb_revision   = VER_MINOR;\n\t\tivideo->sisfb_infoblock.sisfb_patchlevel = VER_LEVEL;\n\t\tivideo->sisfb_infoblock.chip_id = ivideo->chip_id;\n\t\tivideo->sisfb_infoblock.sisfb_pci_vendor = ivideo->chip_vendor;\n\t\tivideo->sisfb_infoblock.memory = ivideo->video_size / 1024;\n\t\tivideo->sisfb_infoblock.heapstart = ivideo->heapstart / 1024;\n\t\tif(ivideo->modechanged) {\n\t\t\tivideo->sisfb_infoblock.fbvidmode = ivideo->mode_no;\n\t\t} else {\n\t\t\tivideo->sisfb_infoblock.fbvidmode = ivideo->modeprechange;\n\t\t}\n\t\tivideo->sisfb_infoblock.sisfb_caps = ivideo->caps;\n\t\tivideo->sisfb_infoblock.sisfb_tqlen = ivideo->cmdQueueSize / 1024;\n\t\tivideo->sisfb_infoblock.sisfb_pcibus = ivideo->pcibus;\n\t\tivideo->sisfb_infoblock.sisfb_pcislot = ivideo->pcislot;\n\t\tivideo->sisfb_infoblock.sisfb_pcifunc = ivideo->pcifunc;\n\t\tivideo->sisfb_infoblock.sisfb_lcdpdc = ivideo->detectedpdc;\n\t\tivideo->sisfb_infoblock.sisfb_lcdpdca = ivideo->detectedpdca;\n\t\tivideo->sisfb_infoblock.sisfb_lcda = ivideo->detectedlcda;\n\t\tivideo->sisfb_infoblock.sisfb_vbflags = ivideo->vbflags;\n\t\tivideo->sisfb_infoblock.sisfb_currentvbflags = ivideo->currentvbflags;\n\t\tivideo->sisfb_infoblock.sisfb_scalelcd = ivideo->SiS_Pr.UsePanelScaler;\n\t\tivideo->sisfb_infoblock.sisfb_specialtiming = ivideo->SiS_Pr.SiS_CustomT;\n\t\tivideo->sisfb_infoblock.sisfb_haveemi = ivideo->SiS_Pr.HaveEMI ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_haveemilcd = ivideo->SiS_Pr.HaveEMILCD ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_emi30 = ivideo->SiS_Pr.EMI_30;\n\t\tivideo->sisfb_infoblock.sisfb_emi31 = ivideo->SiS_Pr.EMI_31;\n\t\tivideo->sisfb_infoblock.sisfb_emi32 = ivideo->SiS_Pr.EMI_32;\n\t\tivideo->sisfb_infoblock.sisfb_emi33 = ivideo->SiS_Pr.EMI_33;\n\t\tivideo->sisfb_infoblock.sisfb_tvxpos = (u16)(ivideo->tvxpos + 32);\n\t\tivideo->sisfb_infoblock.sisfb_tvypos = (u16)(ivideo->tvypos + 32);\n\t\tivideo->sisfb_infoblock.sisfb_heapsize = ivideo->sisfb_heap_size / 1024;\n\t\tivideo->sisfb_infoblock.sisfb_videooffset = ivideo->video_offset;\n\t\tivideo->sisfb_infoblock.sisfb_curfstn = ivideo->curFSTN;\n\t\tivideo->sisfb_infoblock.sisfb_curdstn = ivideo->curDSTN;\n\t\tivideo->sisfb_infoblock.sisfb_vbflags2 = ivideo->vbflags2;\n\t\tivideo->sisfb_infoblock.sisfb_can_post = ivideo->sisfb_can_post ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_card_posted = ivideo->sisfb_card_posted ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_was_boot_device = ivideo->sisfb_was_boot_device ? 1 : 0;\n\n\t\tif(copy_to_user((void __user *)arg, &ivideo->sisfb_infoblock,\n\t\t\t\t\t\tsizeof(ivideo->sisfb_infoblock)))\n\t\t\treturn -EFAULT;\n\n\t        break;\n\n\t   case SISFB_GET_VBRSTATUS_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t   case SISFB_GET_VBRSTATUS:\n\t\tif(sisfb_CheckVBRetrace(ivideo))\n\t\t\treturn put_user((u32)1, argp);\n\t\telse\n\t\t\treturn put_user((u32)0, argp);\n\n\t   case SISFB_GET_AUTOMAXIMIZE_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t   case SISFB_GET_AUTOMAXIMIZE:\n\t\tif(ivideo->sisfb_max)\n\t\t\treturn put_user((u32)1, argp);\n\t\telse\n\t\t\treturn put_user((u32)0, argp);\n\n\t   case SISFB_SET_AUTOMAXIMIZE_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t   case SISFB_SET_AUTOMAXIMIZE:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tivideo->sisfb_max = (gpu32) ? 1 : 0;\n\t\tbreak;\n\n\t   case SISFB_SET_TVPOSOFFSET:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tsisfb_set_TVxposoffset(ivideo, ((int)(gpu32 >> 16)) - 32);\n\t\tsisfb_set_TVyposoffset(ivideo, ((int)(gpu32 & 0xffff)) - 32);\n\t\tbreak;\n\n\t   case SISFB_GET_TVPOSOFFSET:\n\t\treturn put_user((u32)(((ivideo->tvxpos+32)<<16)|((ivideo->tvypos+32)&0xffff)),\n\t\t\t\t\t\t\targp);\n\n\t   case SISFB_COMMAND:\n\t\tif(copy_from_user(&ivideo->sisfb_command, (void __user *)arg,\n\t\t\t\t\t\t\tsizeof(struct sisfb_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tsisfb_handle_command(ivideo, &ivideo->sisfb_command);\n\n\t\tif(copy_to_user((void __user *)arg, &ivideo->sisfb_command,\n\t\t\t\t\t\t\tsizeof(struct sisfb_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\t   case SISFB_SET_LOCK:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tivideo->sisfblocked = (gpu32) ? 1 : 0;\n\t\tbreak;\n\n\t   default:\n#ifdef SIS_NEW_CONFIG_COMPAT\n\t\treturn -ENOIOCTLCMD;\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}",
        "func": "static int\tsisfb_ioctl(struct fb_info *info, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct sis_video_info\t*ivideo = (struct sis_video_info *)info->par;\n\tstruct sis_memreq\tsismemreq;\n\tstruct fb_vblank\tsisvbblank;\n\tu32\t\t\tgpu32 = 0;\n#ifndef __user\n#define __user\n#endif\n\tu32 __user \t\t*argp = (u32 __user *)arg;\n\n\tswitch(cmd) {\n\t   case FBIO_ALLOC:\n\t\tif(!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\n\t\tif(copy_from_user(&sismemreq, (void __user *)arg, sizeof(sismemreq)))\n\t\t\treturn -EFAULT;\n\n\t\tsis_malloc(&sismemreq);\n\n\t\tif(copy_to_user((void __user *)arg, &sismemreq, sizeof(sismemreq))) {\n\t\t\tsis_free((u32)sismemreq.offset);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbreak;\n\n\t   case FBIO_FREE:\n\t\tif(!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tsis_free(gpu32);\n\t\tbreak;\n\n\t   case FBIOGET_VBLANK:\n\n\t\tmemset(&sisvbblank, 0, sizeof(struct fb_vblank));\n\n\t\tsisvbblank.count = 0;\n\t\tsisvbblank.flags = sisfb_setupvbblankflags(ivideo, &sisvbblank.vcount, &sisvbblank.hcount);\n\n\t\tif(copy_to_user((void __user *)arg, &sisvbblank, sizeof(sisvbblank)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\t   case SISFB_GET_INFO_SIZE:\n\t\treturn put_user(sizeof(struct sisfb_info), argp);\n\n\t   case SISFB_GET_INFO_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t   case SISFB_GET_INFO:  /* For communication with X driver */\n\t\tivideo->sisfb_infoblock.sisfb_id         = SISFB_ID;\n\t\tivideo->sisfb_infoblock.sisfb_version    = VER_MAJOR;\n\t\tivideo->sisfb_infoblock.sisfb_revision   = VER_MINOR;\n\t\tivideo->sisfb_infoblock.sisfb_patchlevel = VER_LEVEL;\n\t\tivideo->sisfb_infoblock.chip_id = ivideo->chip_id;\n\t\tivideo->sisfb_infoblock.sisfb_pci_vendor = ivideo->chip_vendor;\n\t\tivideo->sisfb_infoblock.memory = ivideo->video_size / 1024;\n\t\tivideo->sisfb_infoblock.heapstart = ivideo->heapstart / 1024;\n\t\tif(ivideo->modechanged) {\n\t\t\tivideo->sisfb_infoblock.fbvidmode = ivideo->mode_no;\n\t\t} else {\n\t\t\tivideo->sisfb_infoblock.fbvidmode = ivideo->modeprechange;\n\t\t}\n\t\tivideo->sisfb_infoblock.sisfb_caps = ivideo->caps;\n\t\tivideo->sisfb_infoblock.sisfb_tqlen = ivideo->cmdQueueSize / 1024;\n\t\tivideo->sisfb_infoblock.sisfb_pcibus = ivideo->pcibus;\n\t\tivideo->sisfb_infoblock.sisfb_pcislot = ivideo->pcislot;\n\t\tivideo->sisfb_infoblock.sisfb_pcifunc = ivideo->pcifunc;\n\t\tivideo->sisfb_infoblock.sisfb_lcdpdc = ivideo->detectedpdc;\n\t\tivideo->sisfb_infoblock.sisfb_lcdpdca = ivideo->detectedpdca;\n\t\tivideo->sisfb_infoblock.sisfb_lcda = ivideo->detectedlcda;\n\t\tivideo->sisfb_infoblock.sisfb_vbflags = ivideo->vbflags;\n\t\tivideo->sisfb_infoblock.sisfb_currentvbflags = ivideo->currentvbflags;\n\t\tivideo->sisfb_infoblock.sisfb_scalelcd = ivideo->SiS_Pr.UsePanelScaler;\n\t\tivideo->sisfb_infoblock.sisfb_specialtiming = ivideo->SiS_Pr.SiS_CustomT;\n\t\tivideo->sisfb_infoblock.sisfb_haveemi = ivideo->SiS_Pr.HaveEMI ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_haveemilcd = ivideo->SiS_Pr.HaveEMILCD ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_emi30 = ivideo->SiS_Pr.EMI_30;\n\t\tivideo->sisfb_infoblock.sisfb_emi31 = ivideo->SiS_Pr.EMI_31;\n\t\tivideo->sisfb_infoblock.sisfb_emi32 = ivideo->SiS_Pr.EMI_32;\n\t\tivideo->sisfb_infoblock.sisfb_emi33 = ivideo->SiS_Pr.EMI_33;\n\t\tivideo->sisfb_infoblock.sisfb_tvxpos = (u16)(ivideo->tvxpos + 32);\n\t\tivideo->sisfb_infoblock.sisfb_tvypos = (u16)(ivideo->tvypos + 32);\n\t\tivideo->sisfb_infoblock.sisfb_heapsize = ivideo->sisfb_heap_size / 1024;\n\t\tivideo->sisfb_infoblock.sisfb_videooffset = ivideo->video_offset;\n\t\tivideo->sisfb_infoblock.sisfb_curfstn = ivideo->curFSTN;\n\t\tivideo->sisfb_infoblock.sisfb_curdstn = ivideo->curDSTN;\n\t\tivideo->sisfb_infoblock.sisfb_vbflags2 = ivideo->vbflags2;\n\t\tivideo->sisfb_infoblock.sisfb_can_post = ivideo->sisfb_can_post ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_card_posted = ivideo->sisfb_card_posted ? 1 : 0;\n\t\tivideo->sisfb_infoblock.sisfb_was_boot_device = ivideo->sisfb_was_boot_device ? 1 : 0;\n\n\t\tif(copy_to_user((void __user *)arg, &ivideo->sisfb_infoblock,\n\t\t\t\t\t\tsizeof(ivideo->sisfb_infoblock)))\n\t\t\treturn -EFAULT;\n\n\t        break;\n\n\t   case SISFB_GET_VBRSTATUS_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t   case SISFB_GET_VBRSTATUS:\n\t\tif(sisfb_CheckVBRetrace(ivideo))\n\t\t\treturn put_user((u32)1, argp);\n\t\telse\n\t\t\treturn put_user((u32)0, argp);\n\n\t   case SISFB_GET_AUTOMAXIMIZE_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t   case SISFB_GET_AUTOMAXIMIZE:\n\t\tif(ivideo->sisfb_max)\n\t\t\treturn put_user((u32)1, argp);\n\t\telse\n\t\t\treturn put_user((u32)0, argp);\n\n\t   case SISFB_SET_AUTOMAXIMIZE_OLD:\n\t\tif(ivideo->warncount++ < 10)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"sisfb: Deprecated ioctl call received - update your application!\\n\");\n\t   case SISFB_SET_AUTOMAXIMIZE:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tivideo->sisfb_max = (gpu32) ? 1 : 0;\n\t\tbreak;\n\n\t   case SISFB_SET_TVPOSOFFSET:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tsisfb_set_TVxposoffset(ivideo, ((int)(gpu32 >> 16)) - 32);\n\t\tsisfb_set_TVyposoffset(ivideo, ((int)(gpu32 & 0xffff)) - 32);\n\t\tbreak;\n\n\t   case SISFB_GET_TVPOSOFFSET:\n\t\treturn put_user((u32)(((ivideo->tvxpos+32)<<16)|((ivideo->tvypos+32)&0xffff)),\n\t\t\t\t\t\t\targp);\n\n\t   case SISFB_COMMAND:\n\t\tif(copy_from_user(&ivideo->sisfb_command, (void __user *)arg,\n\t\t\t\t\t\t\tsizeof(struct sisfb_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tsisfb_handle_command(ivideo, &ivideo->sisfb_command);\n\n\t\tif(copy_to_user((void __user *)arg, &ivideo->sisfb_command,\n\t\t\t\t\t\t\tsizeof(struct sisfb_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\t   case SISFB_SET_LOCK:\n\t\tif(get_user(gpu32, argp))\n\t\t\treturn -EFAULT;\n\n\t\tivideo->sisfblocked = (gpu32) ? 1 : 0;\n\t\tbreak;\n\n\t   default:\n#ifdef SIS_NEW_CONFIG_COMPAT\n\t\treturn -ENOIOCTLCMD;\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,9 @@\n \t\tbreak;\n \n \t   case FBIOGET_VBLANK:\n+\n+\t\tmemset(&sisvbblank, 0, sizeof(struct fb_vblank));\n+\n \t\tsisvbblank.count = 0;\n \t\tsisvbblank.flags = sisfb_setupvbblankflags(ivideo, &sisvbblank.vcount, &sisvbblank.hcount);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\tmemset(&sisvbblank, 0, sizeof(struct fb_vblank));",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4080",
        "func_name": "torvalds/linux/snd_hdsp_hwdep_ioctl",
        "description": "The snd_hdsp_hwdep_ioctl function in sound/pci/rme9652/hdsp.c in the Linux kernel before 2.6.36-rc6 does not initialize a certain structure, which allows local users to obtain potentially sensitive information from kernel stack memory via an SNDRV_HDSP_IOCTL_GET_CONFIG_INFO ioctl call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=e68d3b316ab7b02a074edc4f770e6a746390cb7d",
        "commit_title": "The SNDRV_HDSP_IOCTL_GET_CONFIG_INFO and",
        "commit_text": "SNDRV_HDSP_IOCTL_GET_CONFIG_INFO ioctls in hdspm.c and hdsp.c allow unprivileged users to read uninitialized kernel stack memory, because several fields of the hdsp{m}_config_info structs declared on the stack are not altered or zeroed before being copied back to the user.  This patch takes care of it.  Cc: <stable@kernel.org> ",
        "func_before": "static int snd_hdsp_hwdep_ioctl(struct snd_hwdep *hw, struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hdsp *hdsp = (struct hdsp *)hw->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SNDRV_HDSP_IOCTL_GET_PEAK_RMS: {\n\t\tstruct hdsp_peak_rms __user *peak_rms = (struct hdsp_peak_rms __user *)arg;\n\n\t\terr = hdsp_check_for_iobox(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = hdsp_check_for_firmware(hdsp, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!(hdsp->state & HDSP_FirmwareLoaded)) {\n\t\t\tsnd_printk(KERN_ERR \"Hammerfall-DSP: firmware needs to be uploaded to the card.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (hdsp->io_type) {\n\t\tcase H9652:\n\t\t\treturn hdsp_9652_get_peak(hdsp, peak_rms);\n\t\tcase H9632:\n\t\t\treturn hdsp_9632_get_peak(hdsp, peak_rms);\n\t\tdefault:\n\t\t\treturn hdsp_get_peak(hdsp, peak_rms);\n\t\t}\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_CONFIG_INFO: {\n\t\tstruct hdsp_config_info info;\n\t\tunsigned long flags;\n\t\tint i;\n\n\t\terr = hdsp_check_for_iobox(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = hdsp_check_for_firmware(hdsp, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tspin_lock_irqsave(&hdsp->lock, flags);\n\t\tinfo.pref_sync_ref = (unsigned char)hdsp_pref_sync_ref(hdsp);\n\t\tinfo.wordclock_sync_check = (unsigned char)hdsp_wc_sync_check(hdsp);\n\t\tif (hdsp->io_type != H9632)\n\t\t    info.adatsync_sync_check = (unsigned char)hdsp_adatsync_sync_check(hdsp);\n\t\tinfo.spdif_sync_check = (unsigned char)hdsp_spdif_sync_check(hdsp);\n\t\tfor (i = 0; i < ((hdsp->io_type != Multiface && hdsp->io_type != H9632) ? 3 : 1); ++i)\n\t\t\tinfo.adat_sync_check[i] = (unsigned char)hdsp_adat_sync_check(hdsp, i);\n\t\tinfo.spdif_in = (unsigned char)hdsp_spdif_in(hdsp);\n\t\tinfo.spdif_out = (unsigned char)hdsp_spdif_out(hdsp);\n\t\tinfo.spdif_professional = (unsigned char)hdsp_spdif_professional(hdsp);\n\t\tinfo.spdif_emphasis = (unsigned char)hdsp_spdif_emphasis(hdsp);\n\t\tinfo.spdif_nonaudio = (unsigned char)hdsp_spdif_nonaudio(hdsp);\n\t\tinfo.spdif_sample_rate = hdsp_spdif_sample_rate(hdsp);\n\t\tinfo.system_sample_rate = hdsp->system_sample_rate;\n\t\tinfo.autosync_sample_rate = hdsp_external_sample_rate(hdsp);\n\t\tinfo.system_clock_mode = (unsigned char)hdsp_system_clock_mode(hdsp);\n\t\tinfo.clock_source = (unsigned char)hdsp_clock_source(hdsp);\n\t\tinfo.autosync_ref = (unsigned char)hdsp_autosync_ref(hdsp);\n\t\tinfo.line_out = (unsigned char)hdsp_line_out(hdsp);\n\t\tif (hdsp->io_type == H9632) {\n\t\t\tinfo.da_gain = (unsigned char)hdsp_da_gain(hdsp);\n\t\t\tinfo.ad_gain = (unsigned char)hdsp_ad_gain(hdsp);\n\t\t\tinfo.phone_gain = (unsigned char)hdsp_phone_gain(hdsp);\n\t\t\tinfo.xlr_breakout_cable = (unsigned char)hdsp_xlr_breakout_cable(hdsp);\n\n\t\t}\n\t\tif (hdsp->io_type == H9632 || hdsp->io_type == H9652)\n\t\t\tinfo.analog_extension_board = (unsigned char)hdsp_aeb(hdsp);\n\t\tspin_unlock_irqrestore(&hdsp->lock, flags);\n\t\tif (copy_to_user(argp, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_9632_AEB: {\n\t\tstruct hdsp_9632_aeb h9632_aeb;\n\n\t\tif (hdsp->io_type != H9632) return -EINVAL;\n\t\th9632_aeb.aebi = hdsp->ss_in_channels - H9632_SS_CHANNELS;\n\t\th9632_aeb.aebo = hdsp->ss_out_channels - H9632_SS_CHANNELS;\n\t\tif (copy_to_user(argp, &h9632_aeb, sizeof(h9632_aeb)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_VERSION: {\n\t\tstruct hdsp_version hdsp_version;\n\t\tint err;\n\n\t\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;\n\t\tif (hdsp->io_type == Undefined) {\n\t\t\tif ((err = hdsp_get_iobox_version(hdsp)) < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\thdsp_version.io_type = hdsp->io_type;\n\t\thdsp_version.firmware_rev = hdsp->firmware_rev;\n\t\tif ((err = copy_to_user(argp, &hdsp_version, sizeof(hdsp_version))))\n\t\t    \treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE: {\n\t\tstruct hdsp_firmware __user *firmware;\n\t\tu32 __user *firmware_data;\n\t\tint err;\n\n\t\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;\n\t\t/* SNDRV_HDSP_IOCTL_GET_VERSION must have been called */\n\t\tif (hdsp->io_type == Undefined) return -EINVAL;\n\n\t\tif (hdsp->state & (HDSP_FirmwareCached | HDSP_FirmwareLoaded))\n\t\t\treturn -EBUSY;\n\n\t\tsnd_printk(KERN_INFO \"Hammerfall-DSP: initializing firmware upload\\n\");\n\t\tfirmware = (struct hdsp_firmware __user *)argp;\n\n\t\tif (get_user(firmware_data, &firmware->firmware_data))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdsp_check_for_iobox (hdsp))\n\t\t\treturn -EIO;\n\n\t\tif (copy_from_user(hdsp->firmware_cache, firmware_data, sizeof(hdsp->firmware_cache)) != 0)\n\t\t\treturn -EFAULT;\n\n\t\thdsp->state |= HDSP_FirmwareCached;\n\n\t\tif ((err = snd_hdsp_load_firmware_from_cache(hdsp)) < 0)\n\t\t\treturn err;\n\n\t\tif (!(hdsp->state & HDSP_InitializationComplete)) {\n\t\t\tif ((err = snd_hdsp_enable_io(hdsp)) < 0)\n\t\t\t\treturn err;\n\n\t\t\tsnd_hdsp_initialize_channels(hdsp);\n\t\t\tsnd_hdsp_initialize_midi_flush(hdsp);\n\n\t\t\tif ((err = snd_hdsp_create_alsa_devices(hdsp->card, hdsp)) < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"Hammerfall-DSP: error creating alsa devices\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_MIXER: {\n\t\tstruct hdsp_mixer __user *mixer = (struct hdsp_mixer __user *)argp;\n\t\tif (copy_to_user(mixer->matrix, hdsp->mixer_matrix, sizeof(unsigned short)*HDSP_MATRIX_MIXER_SIZE))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
        "func": "static int snd_hdsp_hwdep_ioctl(struct snd_hwdep *hw, struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hdsp *hdsp = (struct hdsp *)hw->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SNDRV_HDSP_IOCTL_GET_PEAK_RMS: {\n\t\tstruct hdsp_peak_rms __user *peak_rms = (struct hdsp_peak_rms __user *)arg;\n\n\t\terr = hdsp_check_for_iobox(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = hdsp_check_for_firmware(hdsp, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!(hdsp->state & HDSP_FirmwareLoaded)) {\n\t\t\tsnd_printk(KERN_ERR \"Hammerfall-DSP: firmware needs to be uploaded to the card.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (hdsp->io_type) {\n\t\tcase H9652:\n\t\t\treturn hdsp_9652_get_peak(hdsp, peak_rms);\n\t\tcase H9632:\n\t\t\treturn hdsp_9632_get_peak(hdsp, peak_rms);\n\t\tdefault:\n\t\t\treturn hdsp_get_peak(hdsp, peak_rms);\n\t\t}\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_CONFIG_INFO: {\n\t\tstruct hdsp_config_info info;\n\t\tunsigned long flags;\n\t\tint i;\n\n\t\terr = hdsp_check_for_iobox(hdsp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = hdsp_check_for_firmware(hdsp, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tspin_lock_irqsave(&hdsp->lock, flags);\n\t\tinfo.pref_sync_ref = (unsigned char)hdsp_pref_sync_ref(hdsp);\n\t\tinfo.wordclock_sync_check = (unsigned char)hdsp_wc_sync_check(hdsp);\n\t\tif (hdsp->io_type != H9632)\n\t\t    info.adatsync_sync_check = (unsigned char)hdsp_adatsync_sync_check(hdsp);\n\t\tinfo.spdif_sync_check = (unsigned char)hdsp_spdif_sync_check(hdsp);\n\t\tfor (i = 0; i < ((hdsp->io_type != Multiface && hdsp->io_type != H9632) ? 3 : 1); ++i)\n\t\t\tinfo.adat_sync_check[i] = (unsigned char)hdsp_adat_sync_check(hdsp, i);\n\t\tinfo.spdif_in = (unsigned char)hdsp_spdif_in(hdsp);\n\t\tinfo.spdif_out = (unsigned char)hdsp_spdif_out(hdsp);\n\t\tinfo.spdif_professional = (unsigned char)hdsp_spdif_professional(hdsp);\n\t\tinfo.spdif_emphasis = (unsigned char)hdsp_spdif_emphasis(hdsp);\n\t\tinfo.spdif_nonaudio = (unsigned char)hdsp_spdif_nonaudio(hdsp);\n\t\tinfo.spdif_sample_rate = hdsp_spdif_sample_rate(hdsp);\n\t\tinfo.system_sample_rate = hdsp->system_sample_rate;\n\t\tinfo.autosync_sample_rate = hdsp_external_sample_rate(hdsp);\n\t\tinfo.system_clock_mode = (unsigned char)hdsp_system_clock_mode(hdsp);\n\t\tinfo.clock_source = (unsigned char)hdsp_clock_source(hdsp);\n\t\tinfo.autosync_ref = (unsigned char)hdsp_autosync_ref(hdsp);\n\t\tinfo.line_out = (unsigned char)hdsp_line_out(hdsp);\n\t\tif (hdsp->io_type == H9632) {\n\t\t\tinfo.da_gain = (unsigned char)hdsp_da_gain(hdsp);\n\t\t\tinfo.ad_gain = (unsigned char)hdsp_ad_gain(hdsp);\n\t\t\tinfo.phone_gain = (unsigned char)hdsp_phone_gain(hdsp);\n\t\t\tinfo.xlr_breakout_cable = (unsigned char)hdsp_xlr_breakout_cable(hdsp);\n\n\t\t}\n\t\tif (hdsp->io_type == H9632 || hdsp->io_type == H9652)\n\t\t\tinfo.analog_extension_board = (unsigned char)hdsp_aeb(hdsp);\n\t\tspin_unlock_irqrestore(&hdsp->lock, flags);\n\t\tif (copy_to_user(argp, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_9632_AEB: {\n\t\tstruct hdsp_9632_aeb h9632_aeb;\n\n\t\tif (hdsp->io_type != H9632) return -EINVAL;\n\t\th9632_aeb.aebi = hdsp->ss_in_channels - H9632_SS_CHANNELS;\n\t\th9632_aeb.aebo = hdsp->ss_out_channels - H9632_SS_CHANNELS;\n\t\tif (copy_to_user(argp, &h9632_aeb, sizeof(h9632_aeb)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_VERSION: {\n\t\tstruct hdsp_version hdsp_version;\n\t\tint err;\n\n\t\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;\n\t\tif (hdsp->io_type == Undefined) {\n\t\t\tif ((err = hdsp_get_iobox_version(hdsp)) < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\thdsp_version.io_type = hdsp->io_type;\n\t\thdsp_version.firmware_rev = hdsp->firmware_rev;\n\t\tif ((err = copy_to_user(argp, &hdsp_version, sizeof(hdsp_version))))\n\t\t    \treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE: {\n\t\tstruct hdsp_firmware __user *firmware;\n\t\tu32 __user *firmware_data;\n\t\tint err;\n\n\t\tif (hdsp->io_type == H9652 || hdsp->io_type == H9632) return -EINVAL;\n\t\t/* SNDRV_HDSP_IOCTL_GET_VERSION must have been called */\n\t\tif (hdsp->io_type == Undefined) return -EINVAL;\n\n\t\tif (hdsp->state & (HDSP_FirmwareCached | HDSP_FirmwareLoaded))\n\t\t\treturn -EBUSY;\n\n\t\tsnd_printk(KERN_INFO \"Hammerfall-DSP: initializing firmware upload\\n\");\n\t\tfirmware = (struct hdsp_firmware __user *)argp;\n\n\t\tif (get_user(firmware_data, &firmware->firmware_data))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdsp_check_for_iobox (hdsp))\n\t\t\treturn -EIO;\n\n\t\tif (copy_from_user(hdsp->firmware_cache, firmware_data, sizeof(hdsp->firmware_cache)) != 0)\n\t\t\treturn -EFAULT;\n\n\t\thdsp->state |= HDSP_FirmwareCached;\n\n\t\tif ((err = snd_hdsp_load_firmware_from_cache(hdsp)) < 0)\n\t\t\treturn err;\n\n\t\tif (!(hdsp->state & HDSP_InitializationComplete)) {\n\t\t\tif ((err = snd_hdsp_enable_io(hdsp)) < 0)\n\t\t\t\treturn err;\n\n\t\t\tsnd_hdsp_initialize_channels(hdsp);\n\t\t\tsnd_hdsp_initialize_midi_flush(hdsp);\n\n\t\t\tif ((err = snd_hdsp_create_alsa_devices(hdsp->card, hdsp)) < 0) {\n\t\t\t\tsnd_printk(KERN_ERR \"Hammerfall-DSP: error creating alsa devices\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase SNDRV_HDSP_IOCTL_GET_MIXER: {\n\t\tstruct hdsp_mixer __user *mixer = (struct hdsp_mixer __user *)argp;\n\t\tif (copy_to_user(mixer->matrix, hdsp->mixer_matrix, sizeof(unsigned short)*HDSP_MATRIX_MIXER_SIZE))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,6 +43,7 @@\n \t\tif (err < 0)\n \t\t\treturn err;\n \n+\t\tmemset(&info, 0, sizeof(info));\n \t\tspin_lock_irqsave(&hdsp->lock, flags);\n \t\tinfo.pref_sync_ref = (unsigned char)hdsp_pref_sync_ref(hdsp);\n \t\tinfo.wordclock_sync_check = (unsigned char)hdsp_wc_sync_check(hdsp);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tmemset(&info, 0, sizeof(info));"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4080",
        "func_name": "torvalds/linux/snd_hdspm_hwdep_ioctl",
        "description": "The snd_hdsp_hwdep_ioctl function in sound/pci/rme9652/hdsp.c in the Linux kernel before 2.6.36-rc6 does not initialize a certain structure, which allows local users to obtain potentially sensitive information from kernel stack memory via an SNDRV_HDSP_IOCTL_GET_CONFIG_INFO ioctl call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=e68d3b316ab7b02a074edc4f770e6a746390cb7d",
        "commit_title": "The SNDRV_HDSP_IOCTL_GET_CONFIG_INFO and",
        "commit_text": "SNDRV_HDSP_IOCTL_GET_CONFIG_INFO ioctls in hdspm.c and hdsp.c allow unprivileged users to read uninitialized kernel stack memory, because several fields of the hdsp{m}_config_info structs declared on the stack are not altered or zeroed before being copied back to the user.  This patch takes care of it.  Cc: <stable@kernel.org> ",
        "func_before": "static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct hdspm *hdspm = hw->private_data;\n\tstruct hdspm_mixer_ioctl mixer;\n\tstruct hdspm_config_info info;\n\tstruct hdspm_version hdspm_version;\n\tstruct hdspm_peak_rms_ioctl rms;\n\n\tswitch (cmd) {\n\n\tcase SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:\n\t\tif (copy_from_user(&rms, (void __user *)arg, sizeof(rms)))\n\t\t\treturn -EFAULT;\n\t\t/* maybe there is a chance to memorymap in future\n\t\t * so dont touch just copy\n\t\t */\n\t\tif(copy_to_user_fromio((void __user *)rms.peak,\n\t\t\t\t       hdspm->iobase+HDSPM_MADI_peakrmsbase,\n\t\t\t\t       sizeof(struct hdspm_peak_rms)) != 0 )\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t\t\n\n\tcase SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:\n\n\t\tspin_lock_irq(&hdspm->lock);\n\t\tinfo.pref_sync_ref = hdspm_pref_sync_ref(hdspm);\n\t\tinfo.wordclock_sync_check = hdspm_wc_sync_check(hdspm);\n\n\t\tinfo.system_sample_rate = hdspm->system_sample_rate;\n\t\tinfo.autosync_sample_rate =\n\t\t    hdspm_external_sample_rate(hdspm);\n\t\tinfo.system_clock_mode = hdspm_system_clock_mode(hdspm);\n\t\tinfo.clock_source = hdspm_clock_source(hdspm);\n\t\tinfo.autosync_ref = hdspm_autosync_ref(hdspm);\n\t\tinfo.line_out = hdspm_line_out(hdspm);\n\t\tinfo.passthru = 0;\n\t\tspin_unlock_irq(&hdspm->lock);\n\t\tif (copy_to_user((void __user *) arg, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_VERSION:\n\t\thdspm_version.firmware_rev = hdspm->firmware_rev;\n\t\tif (copy_to_user((void __user *) arg, &hdspm_version,\n\t\t\t\t sizeof(hdspm_version)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_MIXER:\n\t\tif (copy_from_user(&mixer, (void __user *)arg, sizeof(mixer)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,\n\t\t\t\t sizeof(struct hdspm_mixer)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
        "func": "static int snd_hdspm_hwdep_ioctl(struct snd_hwdep * hw, struct file *file,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct hdspm *hdspm = hw->private_data;\n\tstruct hdspm_mixer_ioctl mixer;\n\tstruct hdspm_config_info info;\n\tstruct hdspm_version hdspm_version;\n\tstruct hdspm_peak_rms_ioctl rms;\n\n\tswitch (cmd) {\n\n\tcase SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:\n\t\tif (copy_from_user(&rms, (void __user *)arg, sizeof(rms)))\n\t\t\treturn -EFAULT;\n\t\t/* maybe there is a chance to memorymap in future\n\t\t * so dont touch just copy\n\t\t */\n\t\tif(copy_to_user_fromio((void __user *)rms.peak,\n\t\t\t\t       hdspm->iobase+HDSPM_MADI_peakrmsbase,\n\t\t\t\t       sizeof(struct hdspm_peak_rms)) != 0 )\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t\t\n\n\tcase SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tspin_lock_irq(&hdspm->lock);\n\t\tinfo.pref_sync_ref = hdspm_pref_sync_ref(hdspm);\n\t\tinfo.wordclock_sync_check = hdspm_wc_sync_check(hdspm);\n\n\t\tinfo.system_sample_rate = hdspm->system_sample_rate;\n\t\tinfo.autosync_sample_rate =\n\t\t    hdspm_external_sample_rate(hdspm);\n\t\tinfo.system_clock_mode = hdspm_system_clock_mode(hdspm);\n\t\tinfo.clock_source = hdspm_clock_source(hdspm);\n\t\tinfo.autosync_ref = hdspm_autosync_ref(hdspm);\n\t\tinfo.line_out = hdspm_line_out(hdspm);\n\t\tinfo.passthru = 0;\n\t\tspin_unlock_irq(&hdspm->lock);\n\t\tif (copy_to_user((void __user *) arg, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_VERSION:\n\t\thdspm_version.firmware_rev = hdspm->firmware_rev;\n\t\tif (copy_to_user((void __user *) arg, &hdspm_version,\n\t\t\t\t sizeof(hdspm_version)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SNDRV_HDSPM_IOCTL_GET_MIXER:\n\t\tif (copy_from_user(&mixer, (void __user *)arg, sizeof(mixer)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,\n\t\t\t\t sizeof(struct hdspm_mixer)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,7 @@\n \n \tcase SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO:\n \n+\t\tmemset(&info, 0, sizeof(info));\n \t\tspin_lock_irq(&hdspm->lock);\n \t\tinfo.pref_sync_ref = hdspm_pref_sync_ref(hdspm);\n \t\tinfo.wordclock_sync_check = hdspm_wc_sync_check(hdspm);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tmemset(&info, 0, sizeof(info));"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4082",
        "func_name": "torvalds/linux/viafb_ioctl_get_viafb_info",
        "description": "The viafb_ioctl_get_viafb_info function in drivers/video/via/ioctl.c in the Linux kernel before 2.6.36-rc5 does not properly initialize a certain structure member, which allows local users to obtain potentially sensitive information from kernel stack memory via a VIAFB_GET_INFO ioctl call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=b4aaa78f4c2f9cde2f335b14f4ca30b01f9651ca",
        "commit_title": "The VIAFB_GET_INFO device ioctl allows unprivileged users to read 246",
        "commit_text": "bytes of uninitialized stack memory, because the \"reserved\" member of the viafb_ioctl_info struct declared on the stack is not altered or zeroed before being copied back to the user.  This patch takes care of it.  ",
        "func_before": "int viafb_ioctl_get_viafb_info(u_long arg)\n{\n\tstruct viafb_ioctl_info viainfo;\n\n\tviainfo.viafb_id = VIAID;\n\tviainfo.vendor_id = PCI_VIA_VENDOR_ID;\n\n\tswitch (viaparinfo->chip_info->gfx_chip_name) {\n\tcase UNICHROME_CLE266:\n\t\tviainfo.device_id = UNICHROME_CLE266_DID;\n\t\tbreak;\n\n\tcase UNICHROME_K400:\n\t\tviainfo.device_id = UNICHROME_K400_DID;\n\t\tbreak;\n\n\tcase UNICHROME_K800:\n\t\tviainfo.device_id = UNICHROME_K800_DID;\n\t\tbreak;\n\n\tcase UNICHROME_PM800:\n\t\tviainfo.device_id = UNICHROME_PM800_DID;\n\t\tbreak;\n\n\tcase UNICHROME_CN700:\n\t\tviainfo.device_id = UNICHROME_CN700_DID;\n\t\tbreak;\n\n\tcase UNICHROME_CX700:\n\t\tviainfo.device_id = UNICHROME_CX700_DID;\n\t\tbreak;\n\n\tcase UNICHROME_K8M890:\n\t\tviainfo.device_id = UNICHROME_K8M890_DID;\n\t\tbreak;\n\n\tcase UNICHROME_P4M890:\n\t\tviainfo.device_id = UNICHROME_P4M890_DID;\n\t\tbreak;\n\n\tcase UNICHROME_P4M900:\n\t\tviainfo.device_id = UNICHROME_P4M900_DID;\n\t\tbreak;\n\t}\n\n\tviainfo.version = VERSION_MAJOR;\n\tviainfo.revision = VERSION_MINOR;\n\n\tif (copy_to_user((void __user *)arg, &viainfo, sizeof(viainfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "func": "int viafb_ioctl_get_viafb_info(u_long arg)\n{\n\tstruct viafb_ioctl_info viainfo;\n\n\tmemset(&viainfo, 0, sizeof(struct viafb_ioctl_info));\n\n\tviainfo.viafb_id = VIAID;\n\tviainfo.vendor_id = PCI_VIA_VENDOR_ID;\n\n\tswitch (viaparinfo->chip_info->gfx_chip_name) {\n\tcase UNICHROME_CLE266:\n\t\tviainfo.device_id = UNICHROME_CLE266_DID;\n\t\tbreak;\n\n\tcase UNICHROME_K400:\n\t\tviainfo.device_id = UNICHROME_K400_DID;\n\t\tbreak;\n\n\tcase UNICHROME_K800:\n\t\tviainfo.device_id = UNICHROME_K800_DID;\n\t\tbreak;\n\n\tcase UNICHROME_PM800:\n\t\tviainfo.device_id = UNICHROME_PM800_DID;\n\t\tbreak;\n\n\tcase UNICHROME_CN700:\n\t\tviainfo.device_id = UNICHROME_CN700_DID;\n\t\tbreak;\n\n\tcase UNICHROME_CX700:\n\t\tviainfo.device_id = UNICHROME_CX700_DID;\n\t\tbreak;\n\n\tcase UNICHROME_K8M890:\n\t\tviainfo.device_id = UNICHROME_K8M890_DID;\n\t\tbreak;\n\n\tcase UNICHROME_P4M890:\n\t\tviainfo.device_id = UNICHROME_P4M890_DID;\n\t\tbreak;\n\n\tcase UNICHROME_P4M900:\n\t\tviainfo.device_id = UNICHROME_P4M900_DID;\n\t\tbreak;\n\t}\n\n\tviainfo.version = VERSION_MAJOR;\n\tviainfo.revision = VERSION_MINOR;\n\n\tif (copy_to_user((void __user *)arg, &viainfo, sizeof(viainfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n int viafb_ioctl_get_viafb_info(u_long arg)\n {\n \tstruct viafb_ioctl_info viainfo;\n+\n+\tmemset(&viainfo, 0, sizeof(struct viafb_ioctl_info));\n \n \tviainfo.viafb_id = VIAID;\n \tviainfo.vendor_id = PCI_VIA_VENDOR_ID;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tmemset(&viainfo, 0, sizeof(struct viafb_ioctl_info));"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4083",
        "func_name": "torvalds/linux/copy_semid_to_user",
        "description": "The copy_semid_to_user function in ipc/sem.c in the Linux kernel before 2.6.36 does not initialize a certain structure, which allows local users to obtain potentially sensitive information from kernel stack memory via a (1) IPC_INFO, (2) SEM_INFO, (3) IPC_STAT, or (4) SEM_STAT command in a semctl system call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=982f7c2b2e6a28f8f266e075d92e19c0dd4c6e56",
        "commit_title": "The semctl syscall has several code paths that lead to the leakage of",
        "commit_text": "uninitialized kernel stack memory (namely the IPC_INFO, SEM_INFO, IPC_STAT, and SEM_STAT commands) during the use of the older, obsolete version of the semid_ds struct.  The copy_semid_to_user() function declares a semid_ds struct on the stack and copies it back to the user without initializing or zeroing the \"sem_base\", \"sem_pending\", \"sem_pending_last\", and \"undo\" pointers, allowing the leakage of 16 bytes of kernel stack memory.  The code is still reachable on 32-bit systems - when calling semctl() newer glibc's automatically OR the IPC command with the IPC_64 flag, but invoking the syscall directly allows users to use the older versions of the struct.  Cc: Manfred Spraul <manfred@colorfullife.com> ",
        "func_before": "static unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct semid_ds out;\n\n\t\tipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);\n\n\t\tout.sem_otime\t= in->sem_otime;\n\t\tout.sem_ctime\t= in->sem_ctime;\n\t\tout.sem_nsems\t= in->sem_nsems;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "func": "static unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct semid_ds out;\n\n\t\tmemset(&out, 0, sizeof(out));\n\n\t\tipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);\n\n\t\tout.sem_otime\t= in->sem_otime;\n\t\tout.sem_ctime\t= in->sem_ctime;\n\t\tout.sem_nsems\t= in->sem_nsems;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,8 @@\n \tcase IPC_OLD:\n \t    {\n \t\tstruct semid_ds out;\n+\n+\t\tmemset(&out, 0, sizeof(out));\n \n \t\tipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\tmemset(&out, 0, sizeof(out));"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3876",
        "func_name": "torvalds/linux/packet_getname_spkt",
        "description": "net/packet/af_packet.c in the Linux kernel before 2.6.37-rc2 does not properly initialize certain structure members, which allows local users to obtain potentially sensitive information from kernel stack memory by leveraging the CAP_NET_RAW capability to read copies of the applicable structures.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=67286640f638f5ad41a946b9a3dc75327950248f",
        "commit_title": "packet_getname_spkt() doesn't initialize all members of sa_data field of",
        "commit_text": "sockaddr struct if strlen(dev->name) < 13.  This structure is then copied to userland.  It leads to leaking of contents of kernel stack memory. We have to fully fill sa_data with strncpy() instead of strlcpy().  The same with packet_getname(): it doesn't initialize sll_pkttype field of sockaddr_ll.  Set it to zero.  ",
        "func_before": "static int packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t       int *uaddr_len, int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk\t= sock->sk;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tuaddr->sa_family = AF_PACKET;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), pkt_sk(sk)->ifindex);\n\tif (dev)\n\t\tstrlcpy(uaddr->sa_data, dev->name, 15);\n\telse\n\t\tmemset(uaddr->sa_data, 0, 14);\n\trcu_read_unlock();\n\t*uaddr_len = sizeof(*uaddr);\n\n\treturn 0;\n}",
        "func": "static int packet_getname_spkt(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t       int *uaddr_len, int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk\t= sock->sk;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tuaddr->sa_family = AF_PACKET;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), pkt_sk(sk)->ifindex);\n\tif (dev)\n\t\tstrncpy(uaddr->sa_data, dev->name, 14);\n\telse\n\t\tmemset(uaddr->sa_data, 0, 14);\n\trcu_read_unlock();\n\t*uaddr_len = sizeof(*uaddr);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \trcu_read_lock();\n \tdev = dev_get_by_index_rcu(sock_net(sk), pkt_sk(sk)->ifindex);\n \tif (dev)\n-\t\tstrlcpy(uaddr->sa_data, dev->name, 15);\n+\t\tstrncpy(uaddr->sa_data, dev->name, 14);\n \telse\n \t\tmemset(uaddr->sa_data, 0, 14);\n \trcu_read_unlock();",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tstrlcpy(uaddr->sa_data, dev->name, 15);"
            ],
            "added_lines": [
                "\t\tstrncpy(uaddr->sa_data, dev->name, 14);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3876",
        "func_name": "torvalds/linux/packet_getname",
        "description": "net/packet/af_packet.c in the Linux kernel before 2.6.37-rc2 does not properly initialize certain structure members, which allows local users to obtain potentially sensitive information from kernel stack memory by leveraging the CAP_NET_RAW capability to read copies of the applicable structures.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=67286640f638f5ad41a946b9a3dc75327950248f",
        "commit_title": "packet_getname_spkt() doesn't initialize all members of sa_data field of",
        "commit_text": "sockaddr struct if strlen(dev->name) < 13.  This structure is then copied to userland.  It leads to leaking of contents of kernel stack memory. We have to fully fill sa_data with strncpy() instead of strlcpy().  The same with packet_getname(): it doesn't initialize sll_pkttype field of sockaddr_ll.  Set it to zero.  ",
        "func_before": "static int packet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ll *, sll, uaddr);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_ifindex = po->ifindex;\n\tsll->sll_protocol = po->num;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), po->ifindex);\n\tif (dev) {\n\t\tsll->sll_hatype = dev->type;\n\t\tsll->sll_halen = dev->addr_len;\n\t\tmemcpy(sll->sll_addr, dev->dev_addr, dev->addr_len);\n\t} else {\n\t\tsll->sll_hatype = 0;\t/* Bad: we have no ARPHRD_UNSPEC */\n\t\tsll->sll_halen = 0;\n\t}\n\trcu_read_unlock();\n\t*uaddr_len = offsetof(struct sockaddr_ll, sll_addr) + sll->sll_halen;\n\n\treturn 0;\n}",
        "func": "static int packet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct net_device *dev;\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ll *, sll, uaddr);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_ifindex = po->ifindex;\n\tsll->sll_protocol = po->num;\n\tsll->sll_pkttype = 0;\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(sock_net(sk), po->ifindex);\n\tif (dev) {\n\t\tsll->sll_hatype = dev->type;\n\t\tsll->sll_halen = dev->addr_len;\n\t\tmemcpy(sll->sll_addr, dev->dev_addr, dev->addr_len);\n\t} else {\n\t\tsll->sll_hatype = 0;\t/* Bad: we have no ARPHRD_UNSPEC */\n\t\tsll->sll_halen = 0;\n\t}\n\trcu_read_unlock();\n\t*uaddr_len = offsetof(struct sockaddr_ll, sll_addr) + sll->sll_halen;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n \tsll->sll_family = AF_PACKET;\n \tsll->sll_ifindex = po->ifindex;\n \tsll->sll_protocol = po->num;\n+\tsll->sll_pkttype = 0;\n \trcu_read_lock();\n \tdev = dev_get_by_index_rcu(sock_net(sk), po->ifindex);\n \tif (dev) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tsll->sll_pkttype = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3877",
        "func_name": "torvalds/linux/get_name",
        "description": "The get_name function in net/tipc/socket.c in the Linux kernel before 2.6.37-rc2 does not initialize a certain structure, which allows local users to obtain potentially sensitive information from kernel stack memory by reading a copy of this structure.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=88f8a5e3e7defccd3925cabb1ee4d3994e5cdb52",
        "commit_title": "Structure sockaddr_tipc is copied to userland with padding bytes after",
        "commit_text": "\"id\" field in union field \"name\" unitialized.  It leads to leaking of contents of kernel stack memory.  We have to initialize them to zero.  ",
        "func_before": "static int get_name(struct socket *sock, struct sockaddr *uaddr,\n\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_tipc *addr = (struct sockaddr_tipc *)uaddr;\n\tstruct tipc_sock *tsock = tipc_sk(sock->sk);\n\n\tif (peer) {\n\t\tif ((sock->state != SS_CONNECTED) &&\n\t\t\t((peer != 2) || (sock->state != SS_DISCONNECTING)))\n\t\t\treturn -ENOTCONN;\n\t\taddr->addr.id.ref = tsock->peer_name.ref;\n\t\taddr->addr.id.node = tsock->peer_name.node;\n\t} else {\n\t\ttipc_ownidentity(tsock->p->ref, &addr->addr.id);\n\t}\n\n\t*uaddr_len = sizeof(*addr);\n\taddr->addrtype = TIPC_ADDR_ID;\n\taddr->family = AF_TIPC;\n\taddr->scope = 0;\n\taddr->addr.name.domain = 0;\n\n\treturn 0;\n}",
        "func": "static int get_name(struct socket *sock, struct sockaddr *uaddr,\n\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_tipc *addr = (struct sockaddr_tipc *)uaddr;\n\tstruct tipc_sock *tsock = tipc_sk(sock->sk);\n\n\tmemset(addr, 0, sizeof(*addr));\n\tif (peer) {\n\t\tif ((sock->state != SS_CONNECTED) &&\n\t\t\t((peer != 2) || (sock->state != SS_DISCONNECTING)))\n\t\t\treturn -ENOTCONN;\n\t\taddr->addr.id.ref = tsock->peer_name.ref;\n\t\taddr->addr.id.node = tsock->peer_name.node;\n\t} else {\n\t\ttipc_ownidentity(tsock->p->ref, &addr->addr.id);\n\t}\n\n\t*uaddr_len = sizeof(*addr);\n\taddr->addrtype = TIPC_ADDR_ID;\n\taddr->family = AF_TIPC;\n\taddr->scope = 0;\n\taddr->addr.name.domain = 0;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tstruct sockaddr_tipc *addr = (struct sockaddr_tipc *)uaddr;\n \tstruct tipc_sock *tsock = tipc_sk(sock->sk);\n \n+\tmemset(addr, 0, sizeof(*addr));\n \tif (peer) {\n \t\tif ((sock->state != SS_CONNECTED) &&\n \t\t\t((peer != 2) || (sock->state != SS_DISCONNECTING)))",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tmemset(addr, 0, sizeof(*addr));"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4649",
        "func_name": "torvalds/linux/ib_uverbs_poll_cq",
        "description": "Integer overflow in the ib_uverbs_poll_cq function in drivers/infiniband/core/uverbs_cmd.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact via a large value of a certain structure member.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=7182afea8d1afd432a17c18162cc3fd441d0da93",
        "commit_title": "In ib_uverbs_poll_cq() code there is a potential integer overflow if",
        "commit_text": "userspace passes in a large cmd.ne.  The calls to kmalloc() would allocate smaller buffers than intended, leading to memory corruption. There iss also an information leak if resp wasn't all used. Unprivileged userspace may call this function, although only if an RDMA device that uses this function is present.  Fix this by copying CQ entries one at a time, which avoids the allocation entirely, and also by moving this copying into a function that makes sure to initialize all memory copied to userspace.  Special thanks to Jason Gunthorpe <jgunthorpe@obsidianresearch.com> for his help and advice.  Cc: <stable@kernel.org>  [ Monkey around with things a bit to avoid bad code generation by gcc   when designated initializers are used.  - Roland ]  ",
        "func_before": "ssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,\n\t\t\t  const char __user *buf, int in_len,\n\t\t\t  int out_len)\n{\n\tstruct ib_uverbs_poll_cq       cmd;\n\tstruct ib_uverbs_poll_cq_resp *resp;\n\tstruct ib_cq                  *cq;\n\tstruct ib_wc                  *wc;\n\tint                            ret = 0;\n\tint                            i;\n\tint                            rsize;\n\n\tif (copy_from_user(&cmd, buf, sizeof cmd))\n\t\treturn -EFAULT;\n\n\twc = kmalloc(cmd.ne * sizeof *wc, GFP_KERNEL);\n\tif (!wc)\n\t\treturn -ENOMEM;\n\n\trsize = sizeof *resp + cmd.ne * sizeof(struct ib_uverbs_wc);\n\tresp = kmalloc(rsize, GFP_KERNEL);\n\tif (!resp) {\n\t\tret = -ENOMEM;\n\t\tgoto out_wc;\n\t}\n\n\tcq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\n\tif (!cq) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tresp->count = ib_poll_cq(cq, cmd.ne, wc);\n\n\tput_cq_read(cq);\n\n\tfor (i = 0; i < resp->count; i++) {\n\t\tresp->wc[i].wr_id \t   = wc[i].wr_id;\n\t\tresp->wc[i].status \t   = wc[i].status;\n\t\tresp->wc[i].opcode \t   = wc[i].opcode;\n\t\tresp->wc[i].vendor_err \t   = wc[i].vendor_err;\n\t\tresp->wc[i].byte_len \t   = wc[i].byte_len;\n\t\tresp->wc[i].ex.imm_data    = (__u32 __force) wc[i].ex.imm_data;\n\t\tresp->wc[i].qp_num \t   = wc[i].qp->qp_num;\n\t\tresp->wc[i].src_qp \t   = wc[i].src_qp;\n\t\tresp->wc[i].wc_flags \t   = wc[i].wc_flags;\n\t\tresp->wc[i].pkey_index \t   = wc[i].pkey_index;\n\t\tresp->wc[i].slid \t   = wc[i].slid;\n\t\tresp->wc[i].sl \t\t   = wc[i].sl;\n\t\tresp->wc[i].dlid_path_bits = wc[i].dlid_path_bits;\n\t\tresp->wc[i].port_num \t   = wc[i].port_num;\n\t}\n\n\tif (copy_to_user((void __user *) (unsigned long) cmd.response, resp, rsize))\n\t\tret = -EFAULT;\n\nout:\n\tkfree(resp);\n\nout_wc:\n\tkfree(wc);\n\treturn ret ? ret : in_len;\n}",
        "func": "ssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,\n\t\t\t  const char __user *buf, int in_len,\n\t\t\t  int out_len)\n{\n\tstruct ib_uverbs_poll_cq       cmd;\n\tstruct ib_uverbs_poll_cq_resp  resp;\n\tu8 __user                     *header_ptr;\n\tu8 __user                     *data_ptr;\n\tstruct ib_cq                  *cq;\n\tstruct ib_wc                   wc;\n\tint                            ret;\n\n\tif (copy_from_user(&cmd, buf, sizeof cmd))\n\t\treturn -EFAULT;\n\n\tcq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\n\tif (!cq)\n\t\treturn -EINVAL;\n\n\t/* we copy a struct ib_uverbs_poll_cq_resp to user space */\n\theader_ptr = (void __user *)(unsigned long) cmd.response;\n\tdata_ptr = header_ptr + sizeof resp;\n\n\tmemset(&resp, 0, sizeof resp);\n\twhile (resp.count < cmd.ne) {\n\t\tret = ib_poll_cq(cq, 1, &wc);\n\t\tif (ret < 0)\n\t\t\tgoto out_put;\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tret = copy_wc_to_user(data_ptr, &wc);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\n\t\tdata_ptr += sizeof(struct ib_uverbs_wc);\n\t\t++resp.count;\n\t}\n\n\tif (copy_to_user(header_ptr, &resp, sizeof resp)) {\n\t\tret = -EFAULT;\n\t\tgoto out_put;\n\t}\n\n\tret = in_len;\n\nout_put:\n\tput_cq_read(cq);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,61 +3,48 @@\n \t\t\t  int out_len)\n {\n \tstruct ib_uverbs_poll_cq       cmd;\n-\tstruct ib_uverbs_poll_cq_resp *resp;\n+\tstruct ib_uverbs_poll_cq_resp  resp;\n+\tu8 __user                     *header_ptr;\n+\tu8 __user                     *data_ptr;\n \tstruct ib_cq                  *cq;\n-\tstruct ib_wc                  *wc;\n-\tint                            ret = 0;\n-\tint                            i;\n-\tint                            rsize;\n+\tstruct ib_wc                   wc;\n+\tint                            ret;\n \n \tif (copy_from_user(&cmd, buf, sizeof cmd))\n \t\treturn -EFAULT;\n \n-\twc = kmalloc(cmd.ne * sizeof *wc, GFP_KERNEL);\n-\tif (!wc)\n-\t\treturn -ENOMEM;\n+\tcq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\n+\tif (!cq)\n+\t\treturn -EINVAL;\n \n-\trsize = sizeof *resp + cmd.ne * sizeof(struct ib_uverbs_wc);\n-\tresp = kmalloc(rsize, GFP_KERNEL);\n-\tif (!resp) {\n-\t\tret = -ENOMEM;\n-\t\tgoto out_wc;\n+\t/* we copy a struct ib_uverbs_poll_cq_resp to user space */\n+\theader_ptr = (void __user *)(unsigned long) cmd.response;\n+\tdata_ptr = header_ptr + sizeof resp;\n+\n+\tmemset(&resp, 0, sizeof resp);\n+\twhile (resp.count < cmd.ne) {\n+\t\tret = ib_poll_cq(cq, 1, &wc);\n+\t\tif (ret < 0)\n+\t\t\tgoto out_put;\n+\t\tif (!ret)\n+\t\t\tbreak;\n+\n+\t\tret = copy_wc_to_user(data_ptr, &wc);\n+\t\tif (ret)\n+\t\t\tgoto out_put;\n+\n+\t\tdata_ptr += sizeof(struct ib_uverbs_wc);\n+\t\t++resp.count;\n \t}\n \n-\tcq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\n-\tif (!cq) {\n-\t\tret = -EINVAL;\n-\t\tgoto out;\n+\tif (copy_to_user(header_ptr, &resp, sizeof resp)) {\n+\t\tret = -EFAULT;\n+\t\tgoto out_put;\n \t}\n \n-\tresp->count = ib_poll_cq(cq, cmd.ne, wc);\n+\tret = in_len;\n \n+out_put:\n \tput_cq_read(cq);\n-\n-\tfor (i = 0; i < resp->count; i++) {\n-\t\tresp->wc[i].wr_id \t   = wc[i].wr_id;\n-\t\tresp->wc[i].status \t   = wc[i].status;\n-\t\tresp->wc[i].opcode \t   = wc[i].opcode;\n-\t\tresp->wc[i].vendor_err \t   = wc[i].vendor_err;\n-\t\tresp->wc[i].byte_len \t   = wc[i].byte_len;\n-\t\tresp->wc[i].ex.imm_data    = (__u32 __force) wc[i].ex.imm_data;\n-\t\tresp->wc[i].qp_num \t   = wc[i].qp->qp_num;\n-\t\tresp->wc[i].src_qp \t   = wc[i].src_qp;\n-\t\tresp->wc[i].wc_flags \t   = wc[i].wc_flags;\n-\t\tresp->wc[i].pkey_index \t   = wc[i].pkey_index;\n-\t\tresp->wc[i].slid \t   = wc[i].slid;\n-\t\tresp->wc[i].sl \t\t   = wc[i].sl;\n-\t\tresp->wc[i].dlid_path_bits = wc[i].dlid_path_bits;\n-\t\tresp->wc[i].port_num \t   = wc[i].port_num;\n-\t}\n-\n-\tif (copy_to_user((void __user *) (unsigned long) cmd.response, resp, rsize))\n-\t\tret = -EFAULT;\n-\n-out:\n-\tkfree(resp);\n-\n-out_wc:\n-\tkfree(wc);\n-\treturn ret ? ret : in_len;\n+\treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct ib_uverbs_poll_cq_resp *resp;",
                "\tstruct ib_wc                  *wc;",
                "\tint                            ret = 0;",
                "\tint                            i;",
                "\tint                            rsize;",
                "\twc = kmalloc(cmd.ne * sizeof *wc, GFP_KERNEL);",
                "\tif (!wc)",
                "\t\treturn -ENOMEM;",
                "\trsize = sizeof *resp + cmd.ne * sizeof(struct ib_uverbs_wc);",
                "\tresp = kmalloc(rsize, GFP_KERNEL);",
                "\tif (!resp) {",
                "\t\tret = -ENOMEM;",
                "\t\tgoto out_wc;",
                "\tcq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);",
                "\tif (!cq) {",
                "\t\tret = -EINVAL;",
                "\t\tgoto out;",
                "\tresp->count = ib_poll_cq(cq, cmd.ne, wc);",
                "",
                "\tfor (i = 0; i < resp->count; i++) {",
                "\t\tresp->wc[i].wr_id \t   = wc[i].wr_id;",
                "\t\tresp->wc[i].status \t   = wc[i].status;",
                "\t\tresp->wc[i].opcode \t   = wc[i].opcode;",
                "\t\tresp->wc[i].vendor_err \t   = wc[i].vendor_err;",
                "\t\tresp->wc[i].byte_len \t   = wc[i].byte_len;",
                "\t\tresp->wc[i].ex.imm_data    = (__u32 __force) wc[i].ex.imm_data;",
                "\t\tresp->wc[i].qp_num \t   = wc[i].qp->qp_num;",
                "\t\tresp->wc[i].src_qp \t   = wc[i].src_qp;",
                "\t\tresp->wc[i].wc_flags \t   = wc[i].wc_flags;",
                "\t\tresp->wc[i].pkey_index \t   = wc[i].pkey_index;",
                "\t\tresp->wc[i].slid \t   = wc[i].slid;",
                "\t\tresp->wc[i].sl \t\t   = wc[i].sl;",
                "\t\tresp->wc[i].dlid_path_bits = wc[i].dlid_path_bits;",
                "\t\tresp->wc[i].port_num \t   = wc[i].port_num;",
                "\t}",
                "",
                "\tif (copy_to_user((void __user *) (unsigned long) cmd.response, resp, rsize))",
                "\t\tret = -EFAULT;",
                "",
                "out:",
                "\tkfree(resp);",
                "",
                "out_wc:",
                "\tkfree(wc);",
                "\treturn ret ? ret : in_len;"
            ],
            "added_lines": [
                "\tstruct ib_uverbs_poll_cq_resp  resp;",
                "\tu8 __user                     *header_ptr;",
                "\tu8 __user                     *data_ptr;",
                "\tstruct ib_wc                   wc;",
                "\tint                            ret;",
                "\tcq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);",
                "\tif (!cq)",
                "\t\treturn -EINVAL;",
                "\t/* we copy a struct ib_uverbs_poll_cq_resp to user space */",
                "\theader_ptr = (void __user *)(unsigned long) cmd.response;",
                "\tdata_ptr = header_ptr + sizeof resp;",
                "",
                "\tmemset(&resp, 0, sizeof resp);",
                "\twhile (resp.count < cmd.ne) {",
                "\t\tret = ib_poll_cq(cq, 1, &wc);",
                "\t\tif (ret < 0)",
                "\t\t\tgoto out_put;",
                "\t\tif (!ret)",
                "\t\t\tbreak;",
                "",
                "\t\tret = copy_wc_to_user(data_ptr, &wc);",
                "\t\tif (ret)",
                "\t\t\tgoto out_put;",
                "",
                "\t\tdata_ptr += sizeof(struct ib_uverbs_wc);",
                "\t\t++resp.count;",
                "\tif (copy_to_user(header_ptr, &resp, sizeof resp)) {",
                "\t\tret = -EFAULT;",
                "\t\tgoto out_put;",
                "\tret = in_len;",
                "out_put:",
                "\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9511",
        "func_name": "android/XfrmController::ipSecSetEncapSocketOwner",
        "description": "In ipSecSetEncapSocketOwner of XfrmController.cpp, there is a possible failure to initialize a security feature due to uninitialized data. This could lead to local denial of service of IPsec on sockets with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-9.0 Android ID: A-111650288",
        "git_url": "https://android.googlesource.com/platform/system/netd/+/931418b16c7197ca2df34c2a5609e49791125abe",
        "commit_title": "Set optlen for UDP-encap check in XfrmController",
        "commit_text": " When setting the socket owner for an encap socket XfrmController will first attempt to verify that the socket has the UDP-encap socket option set. When doing so it would pass in an uninitialized optlen parameter which could cause the call to not modify the option value if the optlen happened to be too short. So for example if the stack happened to contain a zero where optlen was located the check would fail and the socket owner would not be changed.  Fix this by setting optlen to the size of the option value parameter.  Test: run cts -m CtsNetTestCases BUG: 111650288 (cherry picked from commit fc42a105147310bd680952d4b71fe32974bd8506) ",
        "func_before": "netdutils::Status XfrmController::ipSecSetEncapSocketOwner(const android::base::unique_fd& socket,\n                                                           int newUid, uid_t callerUid) {\n    ALOGD(\"XfrmController:%s, line=%d\", __FUNCTION__, __LINE__);\n\n    const int fd = socket.get();\n    struct stat info;\n    if (fstat(fd, &info)) {\n        return netdutils::statusFromErrno(errno, \"Failed to stat socket file descriptor\");\n    }\n    if (info.st_uid != callerUid) {\n        return netdutils::statusFromErrno(EPERM, \"fchown disabled for non-owner calls\");\n    }\n    if (S_ISSOCK(info.st_mode) == 0) {\n        return netdutils::statusFromErrno(EINVAL, \"File descriptor was not a socket\");\n    }\n\n    int optval;\n    socklen_t optlen;\n    netdutils::Status status =\n        getSyscallInstance().getsockopt(Fd(socket), IPPROTO_UDP, UDP_ENCAP, &optval, &optlen);\n    if (status != netdutils::status::ok) {\n        return status;\n    }\n    if (optval != UDP_ENCAP_ESPINUDP && optval != UDP_ENCAP_ESPINUDP_NON_IKE) {\n        return netdutils::statusFromErrno(EINVAL, \"Socket did not have UDP-encap sockopt set\");\n    }\n    if (fchown(fd, newUid, -1)) {\n        return netdutils::statusFromErrno(errno, \"Failed to fchown socket file descriptor\");\n    }\n\n    return netdutils::status::ok;\n}",
        "func": "netdutils::Status XfrmController::ipSecSetEncapSocketOwner(const android::base::unique_fd& socket,\n                                                           int newUid, uid_t callerUid) {\n    ALOGD(\"XfrmController:%s, line=%d\", __FUNCTION__, __LINE__);\n\n    const int fd = socket.get();\n    struct stat info;\n    if (fstat(fd, &info)) {\n        return netdutils::statusFromErrno(errno, \"Failed to stat socket file descriptor\");\n    }\n    if (info.st_uid != callerUid) {\n        return netdutils::statusFromErrno(EPERM, \"fchown disabled for non-owner calls\");\n    }\n    if (S_ISSOCK(info.st_mode) == 0) {\n        return netdutils::statusFromErrno(EINVAL, \"File descriptor was not a socket\");\n    }\n\n    int optval;\n    socklen_t optlen = sizeof(optval);\n    netdutils::Status status =\n        getSyscallInstance().getsockopt(Fd(socket), IPPROTO_UDP, UDP_ENCAP, &optval, &optlen);\n    if (status != netdutils::status::ok) {\n        return status;\n    }\n    if (optval != UDP_ENCAP_ESPINUDP && optval != UDP_ENCAP_ESPINUDP_NON_IKE) {\n        return netdutils::statusFromErrno(EINVAL, \"Socket did not have UDP-encap sockopt set\");\n    }\n    if (fchown(fd, newUid, -1)) {\n        return netdutils::statusFromErrno(errno, \"Failed to fchown socket file descriptor\");\n    }\n\n    return netdutils::status::ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     }\n \n     int optval;\n-    socklen_t optlen;\n+    socklen_t optlen = sizeof(optval);\n     netdutils::Status status =\n         getSyscallInstance().getsockopt(Fd(socket), IPPROTO_UDP, UDP_ENCAP, &optval, &optlen);\n     if (status != netdutils::status::ok) {",
        "diff_line_info": {
            "deleted_lines": [
                "    socklen_t optlen;"
            ],
            "added_lines": [
                "    socklen_t optlen = sizeof(optval);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/getFieldAt",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "static jobject\ngetFieldAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjobject returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\tjfieldID fieldID = NULL;\n\tUDATA cpType = J9CPTYPE_UNUSED;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9RAMConstantRef *ramConstantRef = NULL;\n\t\tjclass jlClass = NULL;\n\t\t\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\nretry:\n\t\tramConstantRef = NULL;\n\t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n\t\tif (OK == result) {\n\t\t\tJ9ROMFieldShape *resolvedField = NULL;\n\t\t\tUDATA offset = 0;\n\t\t\tJ9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop);\n\t\t\tJ9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass);\n\t\t\tswitch (cpType) {\n\t\t\tcase J9CPTYPE_FIELD: {\n\t\t\t\t/* Try to resolve as instance field, then as a static */\n\t\t\t\toffset = (UDATA) vmFunctions->resolveInstanceFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n\t\t\t\tif (NULL == resolvedField) {\n\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n\t\t\t\t\toffset = (UDATA) fieldAddress - (UDATA) cpClass->ramStatics;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tresult = WRONG_CP_ENTRY_TYPE_EXCEPTION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != resolvedField) {\n\t\t\t\tJ9ROMFieldRef *romFieldRef = NULL;\n\t\t\t\tJ9Class *declaringClass = NULL;\n\t\t\t\tresult = getROMCPItem(vmThread, constantPoolOop, cpIndex, cpType, (J9ROMConstantPoolItem **) &romFieldRef);\n\t\t\t\tif (OK == result) {\n\t\t\t\t\tresult = getJ9ClassAt(vmThread, constantPoolOop, romFieldRef->classRefCPIndex, resolveFlags, &declaringClass);\n\t\t\t\t}\n\t\t\t\tif (OK == result) {\n\t\t\t\t\tUDATA inconsistentData = 0;\n\t\t\t\t\tfieldID = (jfieldID) vmFunctions->getJNIFieldID(vmThread, declaringClass, resolvedField, offset, &inconsistentData);\n\t\t\t\t\tif (0 != inconsistentData) {\n\t\t\t\t\t\t/* Hotswap occurred - the resolvedField is not from declaringClass->romClass.\n\t\t\t\t\t\t * Need to restart the operation.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\n\t\t\t\t\tjlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\n\t\tif (NULL != fieldID) {\n\t\t\tif (NULL != jlClass) {\n\t\t\t\t/* The isStatic argument is ignored. */\n\t\t\t\treturnValue = (*env)->ToReflectedField(env, jlClass, fieldID, FALSE);\n\t\t\t} else {\n\t\t\t\tvmFunctions->throwNativeOOMError(env, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
        "func": "static jobject\ngetFieldAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjobject returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\tjfieldID fieldID = NULL;\n\tUDATA cpType = J9CPTYPE_UNUSED;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9RAMConstantRef *ramConstantRef = NULL;\n\t\tjclass jlClass = NULL;\n\t\t\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\nretry:\n\t\tramConstantRef = NULL;\n\t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n\t\tif (OK == result) {\n\t\t\tJ9ROMFieldShape *resolvedField = NULL;\n\t\t\tUDATA offset = 0;\n\t\t\tJ9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop);\n\t\t\tJ9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass);\n\t\t\tswitch (cpType) {\n\t\t\tcase J9CPTYPE_FIELD: {\n\t\t\t\t/* Try to resolve as instance field, then as a static */\n\t\t\t\toffset = (UDATA) vmFunctions->resolveInstanceFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n\t\t\t\tif (NULL == resolvedField) {\n\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRefInto(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField, NULL);\n\t\t\t\t\toffset = (UDATA) fieldAddress - (UDATA) cpClass->ramStatics;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tresult = WRONG_CP_ENTRY_TYPE_EXCEPTION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != resolvedField) {\n\t\t\t\tJ9ROMFieldRef *romFieldRef = NULL;\n\t\t\t\tJ9Class *declaringClass = NULL;\n\t\t\t\tresult = getROMCPItem(vmThread, constantPoolOop, cpIndex, cpType, (J9ROMConstantPoolItem **) &romFieldRef);\n\t\t\t\tif (OK == result) {\n\t\t\t\t\tresult = getJ9ClassAt(vmThread, constantPoolOop, romFieldRef->classRefCPIndex, resolveFlags, &declaringClass);\n\t\t\t\t}\n\t\t\t\tif (OK == result) {\n\t\t\t\t\tUDATA inconsistentData = 0;\n\t\t\t\t\tfieldID = (jfieldID) vmFunctions->getJNIFieldID(vmThread, declaringClass, resolvedField, offset, &inconsistentData);\n\t\t\t\t\tif (0 != inconsistentData) {\n\t\t\t\t\t\t/* Hotswap occurred - the resolvedField is not from declaringClass->romClass.\n\t\t\t\t\t\t * Need to restart the operation.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\n\t\t\t\t\tjlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\n\t\tif (NULL != fieldID) {\n\t\t\tif (NULL != jlClass) {\n\t\t\t\t/* The isStatic argument is ignored. */\n\t\t\t\treturnValue = (*env)->ToReflectedField(env, jlClass, fieldID, FALSE);\n\t\t\t} else {\n\t\t\t\tvmFunctions->throwNativeOOMError(env, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \t\tjclass jlClass = NULL;\n \t\t\n \t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n+\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n retry:\n \t\tramConstantRef = NULL;\n \t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n@@ -26,7 +27,7 @@\n \t\t\t\t/* Try to resolve as instance field, then as a static */\n \t\t\t\toffset = (UDATA) vmFunctions->resolveInstanceFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n \t\t\t\tif (NULL == resolvedField) {\n-\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);\n+\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRefInto(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField, NULL);\n \t\t\t\t\toffset = (UDATA) fieldAddress - (UDATA) cpClass->ramStatics;\n \t\t\t\t}\n \t\t\t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRef(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField);"
            ],
            "added_lines": [
                "\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);",
                "\t\t\t\t\tvoid *fieldAddress = vmFunctions->resolveStaticFieldRefInto(vmThread, NULL, constantPool, cpIndex, resolveFlags, &resolvedField, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/Java_sun_reflect_ConstantPool_getClassAtIfLoaded0",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "jclass JNICALL\nJava_sun_reflect_ConstantPool_getClassAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n}",
        "func": "jclass JNICALL\nJava_sun_reflect_ConstantPool_getClassAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n jclass JNICALL\n Java_sun_reflect_ConstantPool_getClassAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n {\n-\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n+\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);"
            ],
            "added_lines": [
                "\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/getMethodAt",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "static jobject\ngetMethodAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjobject returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\tjmethodID methodID = NULL;\n\tUDATA cpType = J9CPTYPE_UNUSED;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9RAMConstantRef *ramConstantRef = NULL;\n\t\tjclass jlClass = NULL;\n\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n\t\tif (OK == result) {\n\t\t\tJ9Method *method = NULL;\n\t\t\tJ9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop);\n\t\t\tJ9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass);\n\t\t\tswitch (cpType) {\n\t\t\tcase J9CPTYPE_HANDLE_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INSTANCE_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INTERFACE_INSTANCE_METHOD:\n\t\t\t\t/* Check for resolved special first, then try to resolve as virtual, then special and then static */\n\t\t\t\tmethod = ((J9RAMMethodRef *) ramConstantRef)->method;\n\t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n\t\t\t\t\tif (0 == vmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method)) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\tmethod = vmFunctions->resolveSpecialMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL == method) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\t/* Do not update the cp entry for type J9CPTYPE_INSTANCE_METHOD when resolving the method ref as\n\t\t\t\t\t\t * a static method as this may crash if an invokespecial bytecode targets this cpEntry.  The\n\t\t\t\t\t\t * contract for J9CPTYPE_INSTANCE_METHOD requires that the cpEntry->method will only be a\n\t\t\t\t\t\t * non-static method.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase J9CPTYPE_STATIC_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INTERFACE_STATIC_METHOD:\n\t\t\t\tmethod = ((J9RAMStaticMethodRef *) ramConstantRef)->method;\n\t\t\t\t/* TODO is this the right check for an unresolved method? Can I check against vm->initialMethods.initialStaticMethod */\n\t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\t\tif (NULL == method) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\tvmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase J9CPTYPE_INTERFACE_METHOD:\n\t\t\t\t/* TODO check for resolved and lookup in itable */\n\t\t\t\tmethod = vmFunctions->resolveInterfaceMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = WRONG_CP_ENTRY_TYPE_EXCEPTION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != method) {\n\t\t\t\tmethodID = (jmethodID) vmFunctions->getJNIMethodID(vmThread, method);\n\t\t\t\tjlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject);\n\t\t\t}\n\t\t}\n\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\n\t\tif (NULL != methodID) {\n\t\t\tif (NULL != jlClass) {\n\t\t\t\tconst jboolean isStatic = (J9CPTYPE_STATIC_METHOD == cpType) || (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType);\n\t\t\t\treturnValue = (*env)->ToReflectedMethod(env, jlClass, methodID, isStatic);\n\t\t\t} else {\n\t\t\t\tvmFunctions->throwNativeOOMError(env, 0, 0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
        "func": "static jobject\ngetMethodAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjobject returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\tjmethodID methodID = NULL;\n\tUDATA cpType = J9CPTYPE_UNUSED;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9RAMConstantRef *ramConstantRef = NULL;\n\t\tjclass jlClass = NULL;\n\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n\t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n\t\tif (OK == result) {\n\t\t\tJ9Method *method = NULL;\n\t\t\tJ9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop);\n\t\t\tJ9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass);\n\t\t\tswitch (cpType) {\n\t\t\tcase J9CPTYPE_HANDLE_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INSTANCE_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INTERFACE_INSTANCE_METHOD:\n\t\t\t\t/* Check for resolved special first, then try to resolve as virtual, then special and then static */\n\t\t\t\tmethod = ((J9RAMMethodRef *) ramConstantRef)->method;\n\t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n\t\t\t\t\tif (0 == vmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method)) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\tmethod = vmFunctions->resolveSpecialMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL == method) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\t/* Do not update the cp entry for type J9CPTYPE_INSTANCE_METHOD when resolving the method ref as\n\t\t\t\t\t\t * a static method as this may crash if an invokespecial bytecode targets this cpEntry.  The\n\t\t\t\t\t\t * contract for J9CPTYPE_INSTANCE_METHOD requires that the cpEntry->method will only be a\n\t\t\t\t\t\t * non-static method.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase J9CPTYPE_STATIC_METHOD: /* fall through */\n\t\t\tcase J9CPTYPE_INTERFACE_STATIC_METHOD:\n\t\t\t\tmethod = ((J9RAMStaticMethodRef *) ramConstantRef)->method;\n\t\t\t\t/* TODO is this the right check for an unresolved method? Can I check against vm->initialMethods.initialStaticMethod */\n\t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);\n\t\t\t\t\tif (NULL == method) {\n\t\t\t\t\t\tclearException(vmThread);\n\t\t\t\t\t\tvmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase J9CPTYPE_INTERFACE_METHOD:\n\t\t\t\t/* TODO check for resolved and lookup in itable */\n\t\t\t\tmethod = vmFunctions->resolveInterfaceMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = WRONG_CP_ENTRY_TYPE_EXCEPTION;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (NULL != method) {\n\t\t\t\tmethodID = (jmethodID) vmFunctions->getJNIMethodID(vmThread, method);\n\t\t\t\tjlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject);\n\t\t\t}\n\t\t}\n\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\n\t\tif (NULL != methodID) {\n\t\t\tif (NULL != jlClass) {\n\t\t\t\tconst jboolean isStatic = (J9CPTYPE_STATIC_METHOD == cpType) || (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType);\n\t\t\t\treturnValue = (*env)->ToReflectedMethod(env, jlClass, methodID, isStatic);\n\t\t\t} else {\n\t\t\t\tvmFunctions->throwNativeOOMError(env, 0, 0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \t\tjclass jlClass = NULL;\n \n \t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n+\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n \t\tresult = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef);\n \t\tif (OK == result) {\n \t\t\tJ9Method *method = NULL;\n@@ -45,7 +46,7 @@\n \t\t\t\tmethod = ((J9RAMStaticMethodRef *) ramConstantRef)->method;\n \t\t\t\t/* TODO is this the right check for an unresolved method? Can I check against vm->initialMethods.initialStaticMethod */\n \t\t\t\tif ((NULL == method) || (NULL == method->constantPool)) {\n-\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRef(vmThread, constantPool, cpIndex, resolveFlags);\n+\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);\n \t\t\t\t\tif (NULL == method) {\n \t\t\t\t\t\tclearException(vmThread);\n \t\t\t\t\t\tvmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRef(vmThread, constantPool, cpIndex, resolveFlags);"
            ],
            "added_lines": [
                "\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);",
                "\t\t\t\t\tmethod = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/Java_sun_reflect_ConstantPool_getMethodAt0",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "jobject JNICALL\nJava_sun_reflect_ConstantPool_getMethodAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n}",
        "func": "jobject JNICALL\nJava_sun_reflect_ConstantPool_getMethodAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getMethodAt(env, constantPoolOop, cpIndex, 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n jobject JNICALL\n Java_sun_reflect_ConstantPool_getMethodAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n {\n-\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n+\treturn getMethodAt(env, constantPoolOop, cpIndex, 0);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);"
            ],
            "added_lines": [
                "\treturn getMethodAt(env, constantPoolOop, cpIndex, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/getClassAt",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "static jclass\ngetClassAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjclass returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9Class *clazz = NULL;\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresult = getJ9ClassAt(vmThread, constantPoolOop, cpIndex, resolveFlags, &clazz);\n\t\tif (NULL != clazz) {\n\t\t\treturnValue = vmFunctions->j9jni_createLocalRef(env, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n\t\t}\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
        "func": "static jclass\ngetClassAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags)\n{\n\tjclass returnValue = NULL;\n\tJ9VMThread *vmThread = (J9VMThread *) env;\n\tJ9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions;\n\tSunReflectCPResult result = NULL_POINTER_EXCEPTION;\n\n\tif (NULL != constantPoolOop) {\n\t\tJ9Class *clazz = NULL;\n\t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n\t\tresult = getJ9ClassAt(vmThread, constantPoolOop, cpIndex, resolveFlags, &clazz);\n\t\tif (NULL != clazz) {\n\t\t\treturnValue = vmFunctions->j9jni_createLocalRef(env, J9VM_J9CLASS_TO_HEAPCLASS(clazz));\n\t\t}\n\t\tvmFunctions->internalExitVMToJNI(vmThread);\n\t}\n\n\tcheckResult(env, result);\n\n\treturn returnValue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,7 @@\n \tif (NULL != constantPoolOop) {\n \t\tJ9Class *clazz = NULL;\n \t\tvmFunctions->internalEnterVMFromJNI(vmThread);\n+\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);\n \t\tresult = getJ9ClassAt(vmThread, constantPoolOop, cpIndex, resolveFlags, &clazz);\n \t\tif (NULL != clazz) {\n \t\t\treturnValue = vmFunctions->j9jni_createLocalRef(env, J9VM_J9CLASS_TO_HEAPCLASS(clazz));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tresolveFlags |= (J9_RESOLVE_FLAG_NO_THROW_ON_FAIL | J9_RESOLVE_FLAG_NO_CLASS_INIT | J9_RESOLVE_FLAG_NO_CP_UPDATE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/Java_sun_reflect_ConstantPool_getMethodAtIfLoaded0",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "jobject JNICALL\nJava_sun_reflect_ConstantPool_getMethodAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n}",
        "func": "jobject JNICALL\nJava_sun_reflect_ConstantPool_getMethodAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n jobject JNICALL\n Java_sun_reflect_ConstantPool_getMethodAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n {\n-\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n+\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);"
            ],
            "added_lines": [
                "\treturn getMethodAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/Java_sun_reflect_ConstantPool_getFieldAt0",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "jobject JNICALL\nJava_sun_reflect_ConstantPool_getFieldAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n}",
        "func": "jobject JNICALL\nJava_sun_reflect_ConstantPool_getFieldAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getFieldAt(env, constantPoolOop, cpIndex, 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n jobject JNICALL\n Java_sun_reflect_ConstantPool_getFieldAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n {\n-\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n+\treturn getFieldAt(env, constantPoolOop, cpIndex, 0);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);"
            ],
            "added_lines": [
                "\treturn getFieldAt(env, constantPoolOop, cpIndex, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/Java_sun_reflect_ConstantPool_getClassAt0",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "jclass JNICALL\nJava_sun_reflect_ConstantPool_getClassAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n}",
        "func": "jclass JNICALL\nJava_sun_reflect_ConstantPool_getClassAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getClassAt(env, constantPoolOop, cpIndex, 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n jclass JNICALL\n Java_sun_reflect_ConstantPool_getClassAt0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n {\n-\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n+\treturn getClassAt(env, constantPoolOop, cpIndex, 0);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn getClassAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_RUNTIME_RESOLVE | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);"
            ],
            "added_lines": [
                "\treturn getClassAt(env, constantPoolOop, cpIndex, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/Java_sun_reflect_ConstantPool_getFieldAtIfLoaded0",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "jobject JNICALL\nJava_sun_reflect_ConstantPool_getFieldAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n}",
        "func": "jobject JNICALL\nJava_sun_reflect_ConstantPool_getFieldAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n{\n\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n jobject JNICALL\n Java_sun_reflect_ConstantPool_getFieldAtIfLoaded0(JNIEnv *env, jobject unusedObject, jobject constantPoolOop, jint cpIndex)\n {\n-\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n+\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);"
            ],
            "added_lines": [
                "\treturn getFieldAt(env, constantPoolOop, cpIndex, J9_RESOLVE_FLAG_NO_CLASS_LOAD);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveSpecialSplitMethodRef",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "J9Method *   \nresolveSpecialSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags)\n{\n\tU_16 cpIndex = *(U_16 *)(J9ROMCLASS_SPECIALSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex);\n\tJ9Method *method = ramCP->ramClass->specialSplitMethodTable[splitTableIndex];\n\t\n\tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialSpecialMethod) {\n\t\tmethod = resolveSpecialMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, NULL);\n\n\t\tif (NULL != method) {\n\t\t\tramCP->ramClass->specialSplitMethodTable[splitTableIndex] = method;\n\t\t}\n\t}\n\treturn method;\n}",
        "func": "J9Method *   \nresolveSpecialSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags)\n{\n\tU_16 cpIndex = *(U_16 *)(J9ROMCLASS_SPECIALSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex);\n\tJ9Method *method = ramCP->ramClass->specialSplitMethodTable[splitTableIndex];\n\t\n\tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialSpecialMethod) {\n\t\tmethod = resolveSpecialMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, NULL);\n\n\t\tif ((NULL != method) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\tramCP->ramClass->specialSplitMethodTable[splitTableIndex] = method;\n\t\t}\n\t}\n\treturn method;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialSpecialMethod) {\n \t\tmethod = resolveSpecialMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, NULL);\n \n-\t\tif (NULL != method) {\n+\t\tif ((NULL != method) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\tramCP->ramClass->specialSplitMethodTable[splitTableIndex] = method;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (NULL != method) {"
            ],
            "added_lines": [
                "\t\tif ((NULL != method) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveMethodTypeRefInto",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "j9object_t   \nresolveMethodTypeRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMMethodTypeRef *ramCPEntry) {\n\tj9object_t methodType;\n\tJ9ROMMethodTypeRef *romMethodTypeRef = NULL;\n\tJ9UTF8 *lookupSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n\n\t/* Check if already resolved */\n\tif (ramCPEntry->type != NULL) {\n\t\treturn ramCPEntry->type;\n\t}\n\n\t/* Return NULL if not able to run java code. The only way to resolve\n\t * a MethodType object is to call-in using MethodType.fromMethodDescriptorString()\n\t * which runs Java code.\n\t */\n\tif (!canRunJavaCode) {\n\t\treturn NULL;\n\t}\n\n\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t */\n\tromMethodTypeRef = ((J9ROMMethodTypeRef *) &(J9_ROM_CP_FROM_CP(ramCP)[cpIndex]));\n\tlookupSig = J9ROMMETHODTYPEREF_SIGNATURE(romMethodTypeRef);\n\tsendFromMethodDescriptorString(vmThread, lookupSig, J9_CLASS_FROM_CP(ramCP)->classLoader, NULL);\n\tmethodType = (j9object_t) vmThread->returnValue;\n\n\t/* check if an exception is already pending */\n\tif (threadEventsPending(vmThread)) {\n\t\t/* Already a pending exception */\n\t\tmethodType = NULL;\n\t} else if (methodType == NULL) {\n\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\tj9object_t lookupSigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(lookupSig), J9UTF8_LENGTH(lookupSig), 0);\n\t\tif (throwException) {\n\t\t\tif (NULL == vmThread->currentException) {\n\t\t\t\tsetCurrentException(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t}\n\t\t} else {\n\t\t\tVM_VMHelpers::clearException(vmThread);\n\t\t}\n\t}\n\n\t/* perform visibility checks for the returnType and all parameters */\n\tif (NULL != methodType) {\n\t\t/* check returnType */\n\t\tJ9Class *senderClass = ramCP->ramClass;\n\t\tJ9Class *returnTypeClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(vmThread, methodType));\n\t\tJ9Class *illegalClass = NULL;\n\t\tIDATA visibilityReturnCode = 0;\n\n\t\tif (J9ROMCLASS_IS_ARRAY(senderClass->romClass)) {\n\t\t\tsenderClass = ((J9ArrayClass *)senderClass)->leafComponentType;\n\t\t}\n\t\tif (J9ROMCLASS_IS_ARRAY(returnTypeClass->romClass)) {\n\t\t\treturnTypeClass = ((J9ArrayClass *)returnTypeClass)->leafComponentType;\n\t\t}\n\n\t\tvisibilityReturnCode = checkVisibility(vmThread, senderClass, returnTypeClass, returnTypeClass->romClass->modifiers, lookupOptions);\n\n\t\tif (J9_VISIBILITY_ALLOWED != visibilityReturnCode) {\n\t\t\tillegalClass = returnTypeClass;\n\t\t} else {\n\t\t\t/* check paramTypes */\n\t\t\tj9object_t argTypesObject = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(vmThread, methodType);\n\t\t\tU_32 typeCount = J9INDEXABLEOBJECT_SIZE(vmThread, argTypesObject);\n\n\t\t\tfor (UDATA i = 0; i < typeCount; i++) {\n\t\t\t\tJ9Class *paramClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9JAVAARRAYOFOBJECT_LOAD(vmThread, argTypesObject, i));\n\n\t\t\t\tif (J9ROMCLASS_IS_ARRAY(paramClass->romClass)) {\n\t\t\t\t\tparamClass = ((J9ArrayClass *)paramClass)->leafComponentType;\n\t\t\t\t}\n\n\t\t\t\tvisibilityReturnCode = checkVisibility(vmThread, senderClass, paramClass, paramClass->romClass->modifiers, lookupOptions);\n\n\t\t\t\tif (J9_VISIBILITY_ALLOWED != visibilityReturnCode) {\n\t\t\t\t\tillegalClass = paramClass;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (NULL != illegalClass) {\n\t\t\tif (throwException) {\n\t\t\t\tchar *errorMsg = illegalAccessMessage(vmThread, illegalClass->romClass->modifiers, senderClass, illegalClass, visibilityReturnCode);\n\t\t\t\tif (NULL == errorMsg) {\n\t\t\t\t\tsetNativeOutOfMemoryError(vmThread, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTrc_VM_sendResolveMethodTypeRefInto_Exception(vmThread, senderClass, illegalClass, visibilityReturnCode);\n\t\t\tmethodType = NULL;\n\t\t}\n\t}\n\n\t/* Only write the value in if its not null */\n\tif (NULL != methodType ) {\n\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\tj9object_t *methodTypeObjectP = &ramCPEntry->type;\n\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\tJ9STATIC_OBJECT_STORE(vmThread, clazz, methodTypeObjectP, methodType);\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Exit(vmThread, methodType);\n\n\treturn methodType;\n}",
        "func": "j9object_t   \nresolveMethodTypeRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMMethodTypeRef *ramCPEntry) {\n\tj9object_t methodType;\n\tJ9ROMMethodTypeRef *romMethodTypeRef = NULL;\n\tJ9UTF8 *lookupSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n\n\t/* Check if already resolved */\n\tif (ramCPEntry->type != NULL) {\n\t\treturn ramCPEntry->type;\n\t}\n\n\t/* Return NULL if not able to run java code. The only way to resolve\n\t * a MethodType object is to call-in using MethodType.fromMethodDescriptorString()\n\t * which runs Java code.\n\t */\n\tif (!canRunJavaCode) {\n\t\treturn NULL;\n\t}\n\n\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t */\n\tromMethodTypeRef = ((J9ROMMethodTypeRef *) &(J9_ROM_CP_FROM_CP(ramCP)[cpIndex]));\n\tlookupSig = J9ROMMETHODTYPEREF_SIGNATURE(romMethodTypeRef);\n\tsendFromMethodDescriptorString(vmThread, lookupSig, J9_CLASS_FROM_CP(ramCP)->classLoader, NULL);\n\tmethodType = (j9object_t) vmThread->returnValue;\n\n\t/* check if an exception is already pending */\n\tif (threadEventsPending(vmThread)) {\n\t\t/* Already a pending exception */\n\t\tmethodType = NULL;\n\t} else if (methodType == NULL) {\n\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\tj9object_t lookupSigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(lookupSig), J9UTF8_LENGTH(lookupSig), 0);\n\t\tif (throwException) {\n\t\t\tif (NULL == vmThread->currentException) {\n\t\t\t\tsetCurrentException(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t}\n\t\t} else {\n\t\t\tVM_VMHelpers::clearException(vmThread);\n\t\t}\n\t}\n\n\t/* perform visibility checks for the returnType and all parameters */\n\tif (NULL != methodType) {\n\t\t/* check returnType */\n\t\tJ9Class *senderClass = ramCP->ramClass;\n\t\tJ9Class *returnTypeClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9VMJAVALANGINVOKEMETHODTYPE_RTYPE(vmThread, methodType));\n\t\tJ9Class *illegalClass = NULL;\n\t\tIDATA visibilityReturnCode = 0;\n\n\t\tif (J9ROMCLASS_IS_ARRAY(senderClass->romClass)) {\n\t\t\tsenderClass = ((J9ArrayClass *)senderClass)->leafComponentType;\n\t\t}\n\t\tif (J9ROMCLASS_IS_ARRAY(returnTypeClass->romClass)) {\n\t\t\treturnTypeClass = ((J9ArrayClass *)returnTypeClass)->leafComponentType;\n\t\t}\n\n\t\tvisibilityReturnCode = checkVisibility(vmThread, senderClass, returnTypeClass, returnTypeClass->romClass->modifiers, lookupOptions);\n\n\t\tif (J9_VISIBILITY_ALLOWED != visibilityReturnCode) {\n\t\t\tillegalClass = returnTypeClass;\n\t\t} else {\n\t\t\t/* check paramTypes */\n\t\t\tj9object_t argTypesObject = J9VMJAVALANGINVOKEMETHODTYPE_PTYPES(vmThread, methodType);\n\t\t\tU_32 typeCount = J9INDEXABLEOBJECT_SIZE(vmThread, argTypesObject);\n\n\t\t\tfor (UDATA i = 0; i < typeCount; i++) {\n\t\t\t\tJ9Class *paramClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9JAVAARRAYOFOBJECT_LOAD(vmThread, argTypesObject, i));\n\n\t\t\t\tif (J9ROMCLASS_IS_ARRAY(paramClass->romClass)) {\n\t\t\t\t\tparamClass = ((J9ArrayClass *)paramClass)->leafComponentType;\n\t\t\t\t}\n\n\t\t\t\tvisibilityReturnCode = checkVisibility(vmThread, senderClass, paramClass, paramClass->romClass->modifiers, lookupOptions);\n\n\t\t\t\tif (J9_VISIBILITY_ALLOWED != visibilityReturnCode) {\n\t\t\t\t\tillegalClass = paramClass;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (NULL != illegalClass) {\n\t\t\tif (throwException) {\n\t\t\t\tchar *errorMsg = illegalAccessMessage(vmThread, illegalClass->romClass->modifiers, senderClass, illegalClass, visibilityReturnCode);\n\t\t\t\tif (NULL == errorMsg) {\n\t\t\t\t\tsetNativeOutOfMemoryError(vmThread, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTrc_VM_sendResolveMethodTypeRefInto_Exception(vmThread, senderClass, illegalClass, visibilityReturnCode);\n\t\t\tmethodType = NULL;\n\t\t}\n\t}\n\n\t/* Only write the value in if its not null */\n\tif ((NULL != methodType) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\tj9object_t *methodTypeObjectP = &ramCPEntry->type;\n\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\tJ9STATIC_OBJECT_STORE(vmThread, clazz, methodTypeObjectP, methodType);\n\t}\n\n\tTrc_VM_sendResolveMethodTypeRefInto_Exit(vmThread, methodType);\n\n\treturn methodType;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -108,7 +108,7 @@\n \t}\n \n \t/* Only write the value in if its not null */\n-\tif (NULL != methodType ) {\n+\tif ((NULL != methodType) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n \t\tj9object_t *methodTypeObjectP = &ramCPEntry->type;\n \t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (NULL != methodType ) {"
            ],
            "added_lines": [
                "\tif ((NULL != methodType) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveVirtualMethodRefInto",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "UDATA   \nresolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9Method **resolvedMethod, J9RAMVirtualMethodRef *ramCPEntry)\n{\n\tUDATA vTableOffset = 0;\n\tJ9ROMMethodRef *romMethodRef = NULL;\n\tJ9Class *resolvedClass = NULL;\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveVirtualMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags, resolvedMethod);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (NULL != resolvedClass) {\n\t\tJ9ROMNameAndSignature *nameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\t\tU_32 *cpShapeDescription = NULL;\n\t\tJ9Method *method = NULL;\n\t\tJ9Class *cpClass = NULL;\n\n\t\t/* Stack allocate a byte array for MethodHandle & VarHandle method name and signature. The array size is:\n\t\t *  - J9ROMNameAndSignature\n\t\t *  - Modified method name\n\t\t *      - U_16 for J9UTF8 length\n\t\t *      - 26 bytes for the original method name (\"compareAndExchangeAcquire\" is the longest)\n\t\t *      - 5 bytes for \"_impl\".\n\t\t *  - J9UTF8 for empty signature\n\t\t */\n\t\tU_8 onStackNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 26 + 5) + sizeof(J9UTF8)];\n\n\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n\t\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\t\tcpClass = NULL;\n\t\t} else {\n\t\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n\t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t\tJ9UTF8 nullSignature = {0};\n\t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {\n\t\t\t/**\n\t\t\t * Check for MH intrinsic methods\n\t\t\t *\n\t\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t\t * These methods have special INL send targets\n\t\t\t */\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t\t/* Create new J9NameAndSignature */\n\t\t\t\t((J9NameAndSignature *)onStackNAS)->name = nameUTF;\n\t\t\t\t((J9NameAndSignature *)onStackNAS)->signature = &nullSignature;\n\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t\t}\n\t\t}\n#elif defined(J9VM_OPT_METHOD_HANDLE) /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {\n\t\t\t/*\n\t\t\t* Check for MH.invoke and MH.invokeExact.\n\t\t\t*\n\t\t\t* Methodrefs corresponding to those methods already have their methodIndex set to index into\n\t\t\t* cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n\t\t\t* and storing the result into the cpClass->methodTypes table.\n\t\t\t*/\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\t\tif ((J9CPTYPE_HANDLE_METHOD == J9_CP_TYPE(cpShapeDescription, cpIndex))\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invoke\")\n\t\t\t) {\n\t\t\t\tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef *)&ramCP[cpIndex];\n\t\t\t\tUDATA methodTypeIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n\t\t\t\tj9object_t methodType = NULL;\n\n\t\t\t\t/* Return NULL if not allowed to run java code. The only way to resolve\n\t\t\t\t * a MethodType object is to call-in using MethodType.fromMethodDescriptorString()\n\t\t\t\t * which runs Java code.\n\t\t\t\t */\n\t\t\t\tif (!canRunJavaCode) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* Throw LinkageError if more than 255 stack slots are\n\t\t\t\t * required by the MethodType and the MethodHandle.\n\t\t\t\t */\n\t\t\t\tif (MAX_STACK_SLOTS == (ramMethodRef->methodIndexAndArgCount & MAX_STACK_SLOTS)) {\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tsetCurrentExceptionNLS(vmStruct, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, J9NLS_VM_TOO_MANY_ARGUMENTS);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t\t\t\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t\t\t\t */\n\t\t\t\tsendFromMethodDescriptorString(vmStruct, sigUTF, J9_CLASS_FROM_CP(ramCP)->classLoader, NULL);\n\t\t\t\tmethodType = (j9object_t) vmStruct->returnValue;\n\n\t\t\t\t/* check if an exception is already pending */\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t/* Already a pending exception */\n\t\t\t\t\tmethodType = NULL;\n\t\t\t\t} else if (NULL == methodType) {\n\t\t\t\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\t\t\t\tj9object_t lookupSigString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Only write the value in if its not null */\n\t\t\t\tif (NULL != methodType) {\n\t\t\t\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\t\t\t\tj9object_t *methodTypeObjectP = clazz->methodTypes + methodTypeIndex;\n\t\t\t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\t\t\t\tJ9STATIC_OBJECT_STORE(vmStruct, clazz, methodTypeObjectP, methodType);\n\n\t\t\t\t\t/* Record vTableOffset for the exit tracepoint. */\n\t\t\t\t\tvTableOffset = methodTypeIndex;\n\t\t\t\t}\n\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (resolvedClass == J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(vm)) {\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\t\tU_8* initialMethodName = J9UTF8_DATA(nameUTF);\n\t\t\tU_16 initialMethodNameLength = J9UTF8_LENGTH(nameUTF);\n\t\t\tBOOLEAN isVarHandle = FALSE;\n\n\t\t\tswitch (initialMethodNameLength) {\n\t\t\tcase 3:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"get\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"set\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAdd\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getVolatile\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setVolatile\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSetRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAddAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAddRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAnd\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXor\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 22:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOrAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOrRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetPlain\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 23:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAndAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAndRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXorAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXorRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 25:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchangeAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchangeRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOr\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchange\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isVarHandle) {\n\t\t\t\tJ9UTF8 *modifiedMethodName = (J9UTF8 *)(onStackNAS + sizeof(J9ROMNameAndSignature));\n\t\t\t\tJ9UTF8 *modifiedMethodSig = (J9UTF8 *)(onStackNAS + sizeof(onStackNAS) - sizeof(J9UTF8));\n\t\t\t\tmemset(onStackNAS, 0, sizeof(onStackNAS));\n\n\t\t\t\t/* Create new J9ROMNameAndSignature */\n\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)onStackNAS;\n\t\t\t\tNNSRP_SET(nameAndSig->name, modifiedMethodName);\n\t\t\t\tNNSRP_SET(nameAndSig->signature, modifiedMethodSig);\n\n\t\t\t\t/* Change method name to include the suffix \"_impl\", which are the methods with VarHandle send targets. */\n\t\t\t\tJ9UTF8_SET_LENGTH(modifiedMethodName, initialMethodNameLength + 5);\n\t\t\t\tmemcpy(J9UTF8_DATA(modifiedMethodName), initialMethodName, initialMethodNameLength);\n\t\t\t\tmemcpy(J9UTF8_DATA(modifiedMethodName) + initialMethodNameLength, \"_impl\", 5);\n\n\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n\n\t\t\t\t/* Redirect resolution to VarHandleInternal */\n\t\t\t\tresolvedClass = VM_VMHelpers::getSuperclass(resolvedClass);\n\n\t\t\t\t/* Ensure visibility passes */\n\t\t\t\tcpClass = resolvedClass;\n\n\t\t\t\t/* Resolve the MethodType. */\n\t\t\t\tif (canRunJavaCode) {\n\t\t\t\t\tj9object_t methodType = NULL;\n\t\t\t\t\tJ9Class *ramClass = ramCP->ramClass;\n\t\t\t\t\tJ9ROMClass *romClass = ramClass->romClass;\n\t\t\t\t\tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef *)&ramCP[cpIndex];\n\n\t\t\t\t\t/* Throw LinkageError if more than 255 stack slots are\n\t\t\t\t\t * required by the MethodType and the MethodHandle.\n\t\t\t\t\t */\n\t\t\t\t\tif (MAX_STACK_SLOTS == (ramMethodRef->methodIndexAndArgCount & MAX_STACK_SLOTS)) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentExceptionNLS(vmStruct, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, J9NLS_VM_TOO_MANY_ARGUMENTS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t\t\t\t\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t\t\t\t\t *\n\t\t\t\t\t * NB! An extra VarHandle argument is appended to the MethodType's argument list,\n\t\t\t\t\t * so the returned MethodType doesn't represent the provided method signature.\n\t\t\t\t\t * E.g. the MethodType for \"(I)I\" will have the following descriptor string:\n\t\t\t\t\t *     \"(Ijava/lang/invoke/VarHandle;)I\"\n\t\t\t\t\t */\n\t\t\t\t\tsendFromMethodDescriptorString(vmStruct, sigUTF, J9_CLASS_FROM_CP(ramCP)->classLoader, J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(vm));\n\t\t\t\t\tmethodType = (j9object_t)vmStruct->returnValue;\n\n\t\t\t\t\t/* Check if an exception is already pending */\n\t\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t\t/* Already a pending exception */\n\t\t\t\t\t\tmethodType = NULL;\n\t\t\t\t\t} else if (NULL == methodType) {\n\t\t\t\t\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\t\t\t\t\tj9object_t lookupSigString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Store MethodType in cache */\n\t\t\t\t\tif (NULL != methodType) {\n\t\t\t\t\t\tU_32 methodTypeIndex = VM_VMHelpers::lookupVarHandleMethodTypeCacheIndex(romClass, cpIndex);\n\t\t\t\t\t\tj9object_t *methodTypeObjectP = ramClass->varHandleMethodTypes + methodTypeIndex;\n\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(vmStruct, ramClass, methodTypeObjectP, methodType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n\t\tTrc_VM_Assert_ShouldNeverHappen();\n#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n\n\t\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\t\tTrc_VM_resolveVirtualMethodRef_lookupMethod(vmStruct, method);\n\n\t\t/* If method is NULL, the exception has already been set. */\n\t\tif (NULL != method) {\n\t\t\tJ9ROMMethod* romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(method);\n\t\t\t/* Only allow non-interface method to call invokePrivate, private interface method should use \"invokeInterface\" bytecode\n\t\t\t * The else case will throw ICCE for private interface method \n\t\t\t */\n\t\t\tif (!J9ROMMETHOD_HAS_VTABLE(romMethod) && J9_ARE_NO_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n\t\t\t\t/* Private method found, will not be in vTable, point vTable index to invokePrivate */\n\t\t\t\tif (NULL != ramCPEntry) {\n\t\t\t\t\tramCPEntry->method = method;\n\t\t\t\t\tUDATA methodIndexAndArgCount = J9VTABLE_INVOKE_PRIVATE_OFFSET << 8;\n\t\t\t\t\tmethodIndexAndArgCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n\t\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndexAndArgCount;\n\t\t\t\t}\n\t\t\t\tif (NULL != resolvedMethod) {\n\t\t\t\t\t/* save away method for callee */\n\t\t\t\t\t*resolvedMethod = method;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Fill in the constant pool entry. Don't bother checking for failure on the vtable index, since we know the method is there. */\n\t\t\t\tvTableOffset = getVTableOffsetForMethod(method, resolvedClass, vmStruct);\n\t\t\t\tif (0 == vTableOffset) {\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tj9object_t errorString = methodToString(vmStruct, method);\n\t\t\t\t\t\tif (NULL != errorString) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, (UDATA *)errorString);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ramCPEntry != NULL) {\n\t\t\t\t\t\tUDATA argSlotCount = vTableOffset << 8;\n\t\t\t\t\t\targSlotCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n\t\t\t\t\t\tramCPEntry->methodIndexAndArgCount = argSlotCount;\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL != resolvedMethod) {\n\t\t\t\t\t\t/* save away method for callee */\n\t\t\t\t\t\t*resolvedMethod = method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#if defined(J9VM_OPT_METHOD_HANDLE)\ndone:\n#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n\tTrc_VM_resolveVirtualMethodRef_Exit(vmStruct, vTableOffset);\n\treturn vTableOffset;\n}",
        "func": "UDATA   \nresolveVirtualMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9Method **resolvedMethod, J9RAMVirtualMethodRef *ramCPEntry)\n{\n\tUDATA vTableOffset = 0;\n\tJ9ROMMethodRef *romMethodRef = NULL;\n\tJ9Class *resolvedClass = NULL;\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveVirtualMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags, resolvedMethod);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (NULL != resolvedClass) {\n\t\tJ9ROMNameAndSignature *nameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\t\tU_32 *cpShapeDescription = NULL;\n\t\tJ9Method *method = NULL;\n\t\tJ9Class *cpClass = NULL;\n\n\t\t/* Stack allocate a byte array for MethodHandle & VarHandle method name and signature. The array size is:\n\t\t *  - J9ROMNameAndSignature\n\t\t *  - Modified method name\n\t\t *      - U_16 for J9UTF8 length\n\t\t *      - 26 bytes for the original method name (\"compareAndExchangeAcquire\" is the longest)\n\t\t *      - 5 bytes for \"_impl\".\n\t\t *  - J9UTF8 for empty signature\n\t\t */\n\t\tU_8 onStackNAS[sizeof(J9ROMNameAndSignature) + (sizeof(U_16) + 26 + 5) + sizeof(J9UTF8)];\n\n\t\tlookupOptions |= J9_LOOK_VIRTUAL;\n\t\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\t\tcpClass = NULL;\n\t\t} else {\n\t\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\t\tcpShapeDescription = J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass);\n\t\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t\tJ9UTF8 nullSignature = {0};\n\t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {\n\t\t\t/**\n\t\t\t * Check for MH intrinsic methods\n\t\t\t *\n\t\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t\t * These methods have special INL send targets\n\t\t\t */\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t\t/* Create new J9NameAndSignature */\n\t\t\t\t((J9NameAndSignature *)onStackNAS)->name = nameUTF;\n\t\t\t\t((J9NameAndSignature *)onStackNAS)->signature = &nullSignature;\n\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t\t}\n\t\t}\n#elif defined(J9VM_OPT_METHOD_HANDLE) /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\t\tif ((NULL != cpShapeDescription) && (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vm))) {\n\t\t\t/*\n\t\t\t* Check for MH.invoke and MH.invokeExact.\n\t\t\t*\n\t\t\t* Methodrefs corresponding to those methods already have their methodIndex set to index into\n\t\t\t* cpClass->methodTypes. We resolve them by calling into MethodType.fromMethodDescriptorString()\n\t\t\t* and storing the result into the cpClass->methodTypes table.\n\t\t\t*/\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\t\tif ((J9CPTYPE_HANDLE_METHOD == J9_CP_TYPE(cpShapeDescription, cpIndex))\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invoke\")\n\t\t\t) {\n\t\t\t\tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef *)&ramCP[cpIndex];\n\t\t\t\tUDATA methodTypeIndex = ramMethodRef->methodIndexAndArgCount >> 8;\n\t\t\t\tj9object_t methodType = NULL;\n\n\t\t\t\t/* Return NULL if not allowed to run java code. The only way to resolve\n\t\t\t\t * a MethodType object is to call-in using MethodType.fromMethodDescriptorString()\n\t\t\t\t * which runs Java code.\n\t\t\t\t */\n\t\t\t\tif (!canRunJavaCode) {\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* Throw LinkageError if more than 255 stack slots are\n\t\t\t\t * required by the MethodType and the MethodHandle.\n\t\t\t\t */\n\t\t\t\tif (MAX_STACK_SLOTS == (ramMethodRef->methodIndexAndArgCount & MAX_STACK_SLOTS)) {\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tsetCurrentExceptionNLS(vmStruct, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, J9NLS_VM_TOO_MANY_ARGUMENTS);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t\t\t\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t\t\t\t */\n\t\t\t\tsendFromMethodDescriptorString(vmStruct, sigUTF, J9_CLASS_FROM_CP(ramCP)->classLoader, NULL);\n\t\t\t\tmethodType = (j9object_t) vmStruct->returnValue;\n\n\t\t\t\t/* check if an exception is already pending */\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t/* Already a pending exception */\n\t\t\t\t\tmethodType = NULL;\n\t\t\t\t} else if (NULL == methodType) {\n\t\t\t\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\t\t\t\tj9object_t lookupSigString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Only write the value in if its not null */\n\t\t\t\tif (NULL != methodType) {\n\t\t\t\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\t\t\t\tj9object_t *methodTypeObjectP = clazz->methodTypes + methodTypeIndex;\n\t\t\t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\t\t\t\tJ9STATIC_OBJECT_STORE(vmStruct, clazz, methodTypeObjectP, methodType);\n\n\t\t\t\t\t/* Record vTableOffset for the exit tracepoint. */\n\t\t\t\t\tvTableOffset = methodTypeIndex;\n\t\t\t\t}\n\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (resolvedClass == J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(vm)) {\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tJ9UTF8 *sigUTF = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\t\tU_8* initialMethodName = J9UTF8_DATA(nameUTF);\n\t\t\tU_16 initialMethodNameLength = J9UTF8_LENGTH(nameUTF);\n\t\t\tBOOLEAN isVarHandle = FALSE;\n\n\t\t\tswitch (initialMethodNameLength) {\n\t\t\tcase 3:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"get\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"set\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setOpaque\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAdd\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getVolatile\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"setVolatile\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndSetRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAddAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndAddRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAnd\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXor\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 22:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOrAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOrRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetPlain\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 23:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAndAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseAndRelease\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXorAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseXorRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSetRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 25:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchangeAcquire\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchangeRelease\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"getAndBitwiseOr\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"weakCompareAndSet\")\n\t\t\t\t || J9UTF8_LITERAL_EQUALS(initialMethodName, initialMethodNameLength, \"compareAndExchange\")\n\t\t\t\t) {\n\t\t\t\t\tisVarHandle = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isVarHandle) {\n\t\t\t\tJ9UTF8 *modifiedMethodName = (J9UTF8 *)(onStackNAS + sizeof(J9ROMNameAndSignature));\n\t\t\t\tJ9UTF8 *modifiedMethodSig = (J9UTF8 *)(onStackNAS + sizeof(onStackNAS) - sizeof(J9UTF8));\n\t\t\t\tmemset(onStackNAS, 0, sizeof(onStackNAS));\n\n\t\t\t\t/* Create new J9ROMNameAndSignature */\n\t\t\t\tnameAndSig = (J9ROMNameAndSignature *)onStackNAS;\n\t\t\t\tNNSRP_SET(nameAndSig->name, modifiedMethodName);\n\t\t\t\tNNSRP_SET(nameAndSig->signature, modifiedMethodSig);\n\n\t\t\t\t/* Change method name to include the suffix \"_impl\", which are the methods with VarHandle send targets. */\n\t\t\t\tJ9UTF8_SET_LENGTH(modifiedMethodName, initialMethodNameLength + 5);\n\t\t\t\tmemcpy(J9UTF8_DATA(modifiedMethodName), initialMethodName, initialMethodNameLength);\n\t\t\t\tmemcpy(J9UTF8_DATA(modifiedMethodName) + initialMethodNameLength, \"_impl\", 5);\n\n\t\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\t\tlookupOptions |= J9_LOOK_PARTIAL_SIGNATURE;\n\n\t\t\t\t/* Redirect resolution to VarHandleInternal */\n\t\t\t\tresolvedClass = VM_VMHelpers::getSuperclass(resolvedClass);\n\n\t\t\t\t/* Ensure visibility passes */\n\t\t\t\tcpClass = resolvedClass;\n\n\t\t\t\t/* Resolve the MethodType. */\n\t\t\t\tif (canRunJavaCode) {\n\t\t\t\t\tj9object_t methodType = NULL;\n\t\t\t\t\tJ9Class *ramClass = ramCP->ramClass;\n\t\t\t\t\tJ9ROMClass *romClass = ramClass->romClass;\n\t\t\t\t\tJ9RAMMethodRef *ramMethodRef = (J9RAMMethodRef *)&ramCP[cpIndex];\n\n\t\t\t\t\t/* Throw LinkageError if more than 255 stack slots are\n\t\t\t\t\t * required by the MethodType and the MethodHandle.\n\t\t\t\t\t */\n\t\t\t\t\tif (MAX_STACK_SLOTS == (ramMethodRef->methodIndexAndArgCount & MAX_STACK_SLOTS)) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentExceptionNLS(vmStruct, J9VMCONSTANTPOOL_JAVALANGLINKAGEERROR, J9NLS_VM_TOO_MANY_ARGUMENTS);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Call VM Entry point to create the MethodType - Result is put into the\n\t\t\t\t\t * vmThread->returnValue as entry points don't \"return\" in the expected way\n\t\t\t\t\t *\n\t\t\t\t\t * NB! An extra VarHandle argument is appended to the MethodType's argument list,\n\t\t\t\t\t * so the returned MethodType doesn't represent the provided method signature.\n\t\t\t\t\t * E.g. the MethodType for \"(I)I\" will have the following descriptor string:\n\t\t\t\t\t *     \"(Ijava/lang/invoke/VarHandle;)I\"\n\t\t\t\t\t */\n\t\t\t\t\tsendFromMethodDescriptorString(vmStruct, sigUTF, J9_CLASS_FROM_CP(ramCP)->classLoader, J9VMJAVALANGINVOKEVARHANDLE_OR_NULL(vm));\n\t\t\t\t\tmethodType = (j9object_t)vmStruct->returnValue;\n\n\t\t\t\t\t/* Check if an exception is already pending */\n\t\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t\t/* Already a pending exception */\n\t\t\t\t\t\tmethodType = NULL;\n\t\t\t\t\t} else if (NULL == methodType) {\n\t\t\t\t\t\t/* Resolved MethodType was null - throw NPE that includes the lookupSignature from the NaS */\n\t\t\t\t\t\tj9object_t lookupSigString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(sigUTF), J9UTF8_LENGTH(sigUTF), 0);\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, (UDATA*)lookupSigString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Store MethodType in cache */\n\t\t\t\t\tif (NULL != methodType) {\n\t\t\t\t\t\tU_32 methodTypeIndex = VM_VMHelpers::lookupVarHandleMethodTypeCacheIndex(romClass, cpIndex);\n\t\t\t\t\t\tj9object_t *methodTypeObjectP = ramClass->varHandleMethodTypes + methodTypeIndex;\n\t\t\t\t\t\tJ9STATIC_OBJECT_STORE(vmStruct, ramClass, methodTypeObjectP, methodType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else /* defined(J9VM_OPT_METHOD_HANDLE) */\n\t\tTrc_VM_Assert_ShouldNeverHappen();\n#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n\n\t\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\t\tTrc_VM_resolveVirtualMethodRef_lookupMethod(vmStruct, method);\n\n\t\t/* If method is NULL, the exception has already been set. */\n\t\tif (NULL != method) {\n\t\t\tJ9ROMMethod* romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(method);\n\t\t\t/* Only allow non-interface method to call invokePrivate, private interface method should use \"invokeInterface\" bytecode\n\t\t\t * The else case will throw ICCE for private interface method \n\t\t\t */\n\t\t\tif (!J9ROMMETHOD_HAS_VTABLE(romMethod) && J9_ARE_NO_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n\t\t\t\t/* Private method found, will not be in vTable, point vTable index to invokePrivate */\n\t\t\t\tif (NULL != ramCPEntry) {\n\t\t\t\t\tramCPEntry->method = method;\n\t\t\t\t\tUDATA methodIndexAndArgCount = J9VTABLE_INVOKE_PRIVATE_OFFSET << 8;\n\t\t\t\t\tmethodIndexAndArgCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n\t\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndexAndArgCount;\n\t\t\t\t}\n\t\t\t\tif (NULL != resolvedMethod) {\n\t\t\t\t\t/* save away method for callee */\n\t\t\t\t\t*resolvedMethod = method;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Fill in the constant pool entry. Don't bother checking for failure on the vtable index, since we know the method is there. */\n\t\t\t\tvTableOffset = getVTableOffsetForMethod(method, resolvedClass, vmStruct);\n\t\t\t\tif (0 == vTableOffset) {\n\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\tj9object_t errorString = methodToString(vmStruct, method);\n\t\t\t\t\t\tif (NULL != errorString) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, (UDATA *)errorString);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t\t\t\tUDATA argSlotCount = vTableOffset << 8;\n\t\t\t\t\t\targSlotCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n\t\t\t\t\t\tramCPEntry->methodIndexAndArgCount = argSlotCount;\n\t\t\t\t\t}\n\t\t\t\t\tif (NULL != resolvedMethod) {\n\t\t\t\t\t\t/* save away method for callee */\n\t\t\t\t\t\t*resolvedMethod = method;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#if defined(J9VM_OPT_METHOD_HANDLE)\ndone:\n#endif /* defined(J9VM_OPT_METHOD_HANDLE) */\n\tTrc_VM_resolveVirtualMethodRef_Exit(vmStruct, vTableOffset);\n\treturn vTableOffset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -352,7 +352,7 @@\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tif (ramCPEntry != NULL) {\n+\t\t\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\t\t\t\tUDATA argSlotCount = vTableOffset << 8;\n \t\t\t\t\t\targSlotCount |= (ramCPEntry->methodIndexAndArgCount & 255);\n \t\t\t\t\t\tramCPEntry->methodIndexAndArgCount = argSlotCount;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tif (ramCPEntry != NULL) {"
            ],
            "added_lines": [
                "\t\t\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveMethodHandleRefInto",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "j9object_t   \nresolveMethodHandleRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMMethodHandleRef *ramCPEntry) {\n\tJ9ROMMethodHandleRef *romMethodHandleRef;\n\tU_32 fieldOrMethodIndex;\n\tJ9ROMMethodRef *cpItem;\n\tJ9Class *definingClass;\n\tJ9ROMNameAndSignature* nameAndSig;\n\tj9object_t methodHandle = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\n\t/* Check if already resolved */\n\tif (ramCPEntry->methodHandle != NULL) {\n\t\treturn ramCPEntry->methodHandle;\n\t}\n\n\t/* Return NULL if not allowed to run java code */\n\tif (!canRunJavaCode) {\n\t\treturn NULL;\n\t}\n\n\t/* Use normal field/method resolution to validate whether we can see the method/field to\n\t * get a MethodHandle on it and ensure that appropriate exceptions are thrown.\n\t * MethodHandle.invoke{Exact,Generic} is a special case as resolution can't succeed.\n\t */\n\n\tromMethodHandleRef = ((J9ROMMethodHandleRef *) &(J9_ROM_CP_FROM_CP(ramCP)[cpIndex]));\n\tfieldOrMethodIndex = romMethodHandleRef->methodOrFieldRefIndex;\n\n\t/* Shift the handleTypeAndCpType to remove the cpType */\n\tswitch(romMethodHandleRef->handleTypeAndCpType >> J9DescriptionCpTypeShift) {\n\t/* Instance Fields */\n\tcase MH_REF_GETFIELD:\n\tcase MH_REF_PUTFIELD:\n\t\tif (resolveInstanceFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == -1) {\n\t\t\t/* field resolution failed - exception should be set */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t/* Static Fields */\n\tcase MH_REF_GETSTATIC:\n\tcase MH_REF_PUTSTATIC:\n\t\tif (resolveStaticFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {\n\t\t\t/* field resolution failed - exception should be set */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\n\tcase MH_REF_INVOKEVIRTUAL:\n\t\t/* InvokeVirtual */\n\t{\n\t\t/*\n\t\t * Given that MethodHandle invokeExact() & invoke() are @PolymorphicSignature methods,\n\t\t * skip method/signature checking to enable MethodHandle invocation only when the resolved class is MethodHandle\n\t\t * and the corresponding method is invokeExact() or invoke().\n\t\t */\n\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *) &((J9_ROM_CP_FROM_CP(ramCP))[fieldOrMethodIndex]);\n\t\tJ9Class *resolvedClass = NULL;\n\n\t\tresolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\tif (NULL == resolvedClass) {\n\t\t\tgoto _done;\n\t\t}\n\n\t\t/* Assumes that if this is MethodHandle, the class was successfully resolved but the method was not */\n\t\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmThread->javaVM)) {\n\t\t\t/* This is MethodHandle - confirm name is either invokeExact or invoke */\n\t\t\tJ9ROMNameAndSignature* nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invoke\")\n\t\t\t) {\n\t\t\t\t/* valid - must be resolvable */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (resolveVirtualMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == 0) {\n\t\t\t/* private methods don't end up in the vtable - we need to determine if invokeSpecial is\n\t\t\t * appropriate here.\n\t\t\t */\n\t\t\tJ9RAMSpecialMethodRef ramSpecialMethodRef;\n\n\t\t\t/* Clear the exception and let the resolveSpecialMethodRef set an exception if necessary */\n\t\t\tVM_VMHelpers::clearException(vmThread);\n\t\t\t\n\t\t\tmemset(&ramSpecialMethodRef, 0, sizeof(J9RAMSpecialMethodRef));\n\t\t\tif (resolveSpecialMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, &ramSpecialMethodRef) == NULL) {\n\t\t\t\t/* Only the class and {Name, Signature} are used by the java code so it is safe to use the fake specialMethodRef */\n\t\t\t\tgoto _done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MH_REF_INVOKESTATIC:\n\t\t/* InvokeStatic */\n\t\tif (resolveStaticMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase MH_REF_INVOKESPECIAL:\n\tcase MH_REF_NEWINVOKESPECIAL:\n\t\t/* InvokeSpecial */\n\t\tif (resolveSpecialMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\t/* Note: this can't find any polymorphic signature versions MethodHandle.invoke{Exact, Generic} */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase MH_REF_INVOKEINTERFACE:\n\t\t/* InvokeInterface */\n\t\tif (resolveInterfaceMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* cpItem will be either a field or a method ref - they both have the same shape so\n\t * we can pretend it is always a methodref\n\t */\n\tcpItem = (J9ROMMethodRef *) &(J9_ROM_CP_FROM_CP(ramCP)[fieldOrMethodIndex]);\n\tdefiningClass = ((J9RAMClassRef *) &(ramCP[cpItem->classRefCPIndex]))->value;\n\tif (definingClass == NULL) {\n\t\tif (throwException) {\n\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t}\n\t\tgoto _done;\n\t}\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(cpItem);\n\n\tsendResolveMethodHandle(vmThread, cpIndex, ramCP, definingClass, nameAndSig);\n\tmethodHandle = (j9object_t) vmThread->returnValue;\n\n\t/* check if an exception is already pending */\n\tif (threadEventsPending(vmThread)) {\n\t\t/* Already a pending exception */\n\t\tmethodHandle = NULL;\n\t} else if (methodHandle == NULL) {\n\t\tif (throwException) {\n\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t}\n\t}\n\n\t/* Only write the value in if its not null */\n\tif (NULL != methodHandle) {\n\t\tmethodHandle = vmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_asConstantPoolObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvmThread, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmethodHandle, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tJ9_GC_ALLOCATE_OBJECT_TENURED | J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE | J9_GC_ALLOCATE_OBJECT_HASHED);\n\t\tif (NULL == methodHandle) {\n\t\t\tif (throwException) {\n\t\t\t\tsetHeapOutOfMemoryError(vmThread);\n\t\t\t}\n\t\t} else {\n\t\t\tj9object_t *methodHandleObjectP = &ramCPEntry->methodHandle;\n\t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\t\tJ9STATIC_OBJECT_STORE(vmThread,  J9_CLASS_FROM_CP(ramCP), methodHandleObjectP, methodHandle);\n\t\t}\n\t}\n\n_done:\n\n\treturn methodHandle;\n}",
        "func": "j9object_t   \nresolveMethodHandleRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMMethodHandleRef *ramCPEntry) {\n\tJ9ROMMethodHandleRef *romMethodHandleRef;\n\tU_32 fieldOrMethodIndex;\n\tJ9ROMMethodRef *cpItem;\n\tJ9Class *definingClass;\n\tJ9ROMNameAndSignature* nameAndSig;\n\tj9object_t methodHandle = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\n\t/* Check if already resolved */\n\tif (ramCPEntry->methodHandle != NULL) {\n\t\treturn ramCPEntry->methodHandle;\n\t}\n\n\t/* Return NULL if not allowed to run java code */\n\tif (!canRunJavaCode) {\n\t\treturn NULL;\n\t}\n\n\t/* Use normal field/method resolution to validate whether we can see the method/field to\n\t * get a MethodHandle on it and ensure that appropriate exceptions are thrown.\n\t * MethodHandle.invoke{Exact,Generic} is a special case as resolution can't succeed.\n\t */\n\n\tromMethodHandleRef = ((J9ROMMethodHandleRef *) &(J9_ROM_CP_FROM_CP(ramCP)[cpIndex]));\n\tfieldOrMethodIndex = romMethodHandleRef->methodOrFieldRefIndex;\n\n\t/* Shift the handleTypeAndCpType to remove the cpType */\n\tswitch(romMethodHandleRef->handleTypeAndCpType >> J9DescriptionCpTypeShift) {\n\t/* Instance Fields */\n\tcase MH_REF_GETFIELD:\n\tcase MH_REF_PUTFIELD:\n\t\tif (resolveInstanceFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == -1) {\n\t\t\t/* field resolution failed - exception should be set */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t/* Static Fields */\n\tcase MH_REF_GETSTATIC:\n\tcase MH_REF_PUTSTATIC:\n\t\tif (resolveStaticFieldRefInto(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL, NULL) == NULL) {\n\t\t\t/* field resolution failed - exception should be set */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\n\tcase MH_REF_INVOKEVIRTUAL:\n\t\t/* InvokeVirtual */\n\t{\n\t\t/*\n\t\t * Given that MethodHandle invokeExact() & invoke() are @PolymorphicSignature methods,\n\t\t * skip method/signature checking to enable MethodHandle invocation only when the resolved class is MethodHandle\n\t\t * and the corresponding method is invokeExact() or invoke().\n\t\t */\n\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *) &((J9_ROM_CP_FROM_CP(ramCP))[fieldOrMethodIndex]);\n\t\tJ9Class *resolvedClass = NULL;\n\n\t\tresolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\tif (NULL == resolvedClass) {\n\t\t\tgoto _done;\n\t\t}\n\n\t\t/* Assumes that if this is MethodHandle, the class was successfully resolved but the method was not */\n\t\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmThread->javaVM)) {\n\t\t\t/* This is MethodHandle - confirm name is either invokeExact or invoke */\n\t\t\tJ9ROMNameAndSignature* nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\t\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t\tif (J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invokeExact\")\n\t\t\t|| J9UTF8_LITERAL_EQUALS(J9UTF8_DATA(nameUTF), J9UTF8_LENGTH(nameUTF), \"invoke\")\n\t\t\t) {\n\t\t\t\t/* valid - must be resolvable */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (resolveVirtualMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == 0) {\n\t\t\t/* private methods don't end up in the vtable - we need to determine if invokeSpecial is\n\t\t\t * appropriate here.\n\t\t\t */\n\t\t\tJ9RAMSpecialMethodRef ramSpecialMethodRef;\n\n\t\t\t/* Clear the exception and let the resolveSpecialMethodRef set an exception if necessary */\n\t\t\tVM_VMHelpers::clearException(vmThread);\n\t\t\t\n\t\t\tmemset(&ramSpecialMethodRef, 0, sizeof(J9RAMSpecialMethodRef));\n\t\t\tif (resolveSpecialMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, &ramSpecialMethodRef) == NULL) {\n\t\t\t\t/* Only the class and {Name, Signature} are used by the java code so it is safe to use the fake specialMethodRef */\n\t\t\t\tgoto _done;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MH_REF_INVOKESTATIC:\n\t\t/* InvokeStatic */\n\t\tif (resolveStaticMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase MH_REF_INVOKESPECIAL:\n\tcase MH_REF_NEWINVOKESPECIAL:\n\t\t/* InvokeSpecial */\n\t\tif (resolveSpecialMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\t/* Note: this can't find any polymorphic signature versions MethodHandle.invoke{Exact, Generic} */\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\tcase MH_REF_INVOKEINTERFACE:\n\t\t/* InvokeInterface */\n\t\tif (resolveInterfaceMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n\t\t\tgoto _done;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* cpItem will be either a field or a method ref - they both have the same shape so\n\t * we can pretend it is always a methodref\n\t */\n\tcpItem = (J9ROMMethodRef *) &(J9_ROM_CP_FROM_CP(ramCP)[fieldOrMethodIndex]);\n\tdefiningClass = ((J9RAMClassRef *) &(ramCP[cpItem->classRefCPIndex]))->value;\n\tif (definingClass == NULL) {\n\t\tif (throwException) {\n\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t}\n\t\tgoto _done;\n\t}\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(cpItem);\n\n\tsendResolveMethodHandle(vmThread, cpIndex, ramCP, definingClass, nameAndSig);\n\tmethodHandle = (j9object_t) vmThread->returnValue;\n\n\t/* check if an exception is already pending */\n\tif (threadEventsPending(vmThread)) {\n\t\t/* Already a pending exception */\n\t\tmethodHandle = NULL;\n\t} else if (methodHandle == NULL) {\n\t\tif (throwException) {\n\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t}\n\t}\n\n\t/* Only write the value in if its not null */\n\tif (NULL != methodHandle) {\n\t\tmethodHandle = vmThread->javaVM->memoryManagerFunctions->j9gc_objaccess_asConstantPoolObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvmThread, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmethodHandle, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tJ9_GC_ALLOCATE_OBJECT_TENURED | J9_GC_ALLOCATE_OBJECT_NON_INSTRUMENTABLE | J9_GC_ALLOCATE_OBJECT_HASHED);\n\t\tif (NULL == methodHandle) {\n\t\t\tif (throwException) {\n\t\t\t\tsetHeapOutOfMemoryError(vmThread);\n\t\t\t}\n\t\t} else if ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\tj9object_t *methodHandleObjectP = &ramCPEntry->methodHandle;\n\t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\t\tJ9STATIC_OBJECT_STORE(vmThread,  J9_CLASS_FROM_CP(ramCP), methodHandleObjectP, methodHandle);\n\t\t}\n\t}\n\n_done:\n\n\treturn methodHandle;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,7 @@\n \t/* Static Fields */\n \tcase MH_REF_GETSTATIC:\n \tcase MH_REF_PUTSTATIC:\n-\t\tif (resolveStaticFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {\n+\t\tif (resolveStaticFieldRefInto(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL, NULL) == NULL) {\n \t\t\t/* field resolution failed - exception should be set */\n \t\t\tgoto _done;\n \t\t}\n@@ -95,7 +95,7 @@\n \t}\n \tcase MH_REF_INVOKESTATIC:\n \t\t/* InvokeStatic */\n-\t\tif (resolveStaticMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {\n+\t\tif (resolveStaticMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {\n \t\t\tgoto _done;\n \t\t}\n \t\tbreak;\n@@ -151,7 +151,7 @@\n \t\t\tif (throwException) {\n \t\t\t\tsetHeapOutOfMemoryError(vmThread);\n \t\t\t}\n-\t\t} else {\n+\t\t} else if ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\tj9object_t *methodHandleObjectP = &ramCPEntry->methodHandle;\n \t\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n \t\t\tJ9STATIC_OBJECT_STORE(vmThread,  J9_CLASS_FROM_CP(ramCP), methodHandleObjectP, methodHandle);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (resolveStaticFieldRef(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {",
                "\t\tif (resolveStaticMethodRef(vmThread, ramCP, fieldOrMethodIndex, resolveFlags) == NULL) {",
                "\t\t} else {"
            ],
            "added_lines": [
                "\t\tif (resolveStaticFieldRefInto(vmThread, NULL, ramCP, fieldOrMethodIndex, resolveFlags, NULL, NULL) == NULL) {",
                "\t\tif (resolveStaticMethodRefInto(vmThread, ramCP, fieldOrMethodIndex, resolveFlags, NULL) == NULL) {",
                "\t\t} else if ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveStaticMethodRefInto",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif (NULL != ramCPEntry)\n\t{\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "func": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -149,8 +149,7 @@\n \t\t\t}\n \t\t}\n \t}\n-\tif (NULL != ramCPEntry)\n-\t{\n+\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\tramCPEntry->method = method;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (NULL != ramCPEntry)",
                "\t{"
            ],
            "added_lines": [
                "\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveStaticMethodRef",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "J9Method *   \nresolveStaticMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\t/* Bit of magic here, the resulting method must be in vmStruct->floatTemp1 in the CLINIT case\n\t * as resolveHelper expects to find it there.\n\t */\n\tJ9RAMStaticMethodRef *ramStaticMethodRef = (J9RAMStaticMethodRef *)&vmStruct->floatTemp1;\n\tJ9Method *method;\n\n\tmethod = resolveStaticMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, ramStaticMethodRef);\n\t\n\tif (method != NULL) {\n\t\t/* Check for <clinit> case. */\n\t\tif (((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT)\n\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n\t\t) {\n\t\t\treturn (J9Method *) -1;\n\t\t} else {\n\t\t\t((J9RAMStaticMethodRef *)&ramCP[cpIndex])->method = ramStaticMethodRef->method;\n\t\t}\n\t}\n\n\treturn method;\n}",
        "func": "J9Method *   \nresolveStaticMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\t/* Bit of magic here, the resulting method must be in vmStruct->floatTemp1 in the CLINIT case\n\t * as resolveHelper expects to find it there.\n\t */\n\tJ9RAMStaticMethodRef *ramStaticMethodRef = (J9RAMStaticMethodRef *)&vmStruct->floatTemp1;\n\tJ9Method *method;\n\n\tmethod = resolveStaticMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, ramStaticMethodRef);\n\t\n\tif (method != NULL) {\n\t\t/* Check for <clinit> case. */\n\t\tif (((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT)\n\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n\t\t) {\n\t\t\treturn (J9Method *) -1;\n\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t((J9RAMStaticMethodRef *)&ramCP[cpIndex])->method = ramStaticMethodRef->method;\n\t\t}\n\t}\n\n\treturn method;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n \t\t) {\n \t\t\treturn (J9Method *) -1;\n-\t\t} else {\n+\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\t((J9RAMStaticMethodRef *)&ramCP[cpIndex])->method = ramStaticMethodRef->method;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t} else {"
            ],
            "added_lines": [
                "\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveStringRef",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "j9object_t   \nresolveStringRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\tJ9UTF8 *utf8Wrapper;\n\tj9object_t stringRef;\n\tJ9ROMStringRef *romStringRef;\n\n\tTrc_VM_resolveStringRef_Entry(vmStruct, cpIndex, ramCP);\n\n\tromStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex];\n\tutf8Wrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef);\n\t\n\tTrc_VM_resolveStringRef_utf8(vmStruct, &utf8Wrapper, J9UTF8_LENGTH(utf8Wrapper), J9UTF8_DATA(utf8Wrapper));\n\n\t/* Create a new string */\n\tstringRef = vmStruct->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(utf8Wrapper), J9UTF8_LENGTH(utf8Wrapper), J9_STR_TENURE | J9_STR_INTERN);\n\t\n\t/* If stringRef is NULL, the exception has already been set. */\n\tif (stringRef != NULL) {\n\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9RAMStringRef *ramStringRef = (J9RAMStringRef *)&ramCP[cpIndex];\n\t\tj9object_t *stringObjectP = &ramStringRef->stringObject;\n\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\tJ9STATIC_OBJECT_STORE(vmStruct, clazz, stringObjectP, stringRef);\n\t}\n\n\tTrc_VM_resolveStringRef_Exit(vmStruct, stringRef);\n\n\treturn stringRef;\n}",
        "func": "j9object_t   \nresolveStringRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\tJ9UTF8 *utf8Wrapper;\n\tj9object_t stringRef;\n\tJ9ROMStringRef *romStringRef;\n\n\tTrc_VM_resolveStringRef_Entry(vmStruct, cpIndex, ramCP);\n\n\tromStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex];\n\tutf8Wrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef);\n\t\n\tTrc_VM_resolveStringRef_utf8(vmStruct, &utf8Wrapper, J9UTF8_LENGTH(utf8Wrapper), J9UTF8_DATA(utf8Wrapper));\n\n\t/* Create a new string */\n\tstringRef = vmStruct->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(utf8Wrapper), J9UTF8_LENGTH(utf8Wrapper), J9_STR_TENURE | J9_STR_INTERN);\n\t\n\t/* If stringRef is NULL, the exception has already been set. */\n\tif ((NULL != stringRef) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9RAMStringRef *ramStringRef = (J9RAMStringRef *)&ramCP[cpIndex];\n\t\tj9object_t *stringObjectP = &ramStringRef->stringObject;\n\t\t/* Overwriting NULL with an immortal pointer, so no exception can occur */\n\t\tJ9STATIC_OBJECT_STORE(vmStruct, clazz, stringObjectP, stringRef);\n\t}\n\n\tTrc_VM_resolveStringRef_Exit(vmStruct, stringRef);\n\n\treturn stringRef;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \tstringRef = vmStruct->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(utf8Wrapper), J9UTF8_LENGTH(utf8Wrapper), J9_STR_TENURE | J9_STR_INTERN);\n \t\n \t/* If stringRef is NULL, the exception has already been set. */\n-\tif (stringRef != NULL) {\n+\tif ((NULL != stringRef) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\tJ9Class *clazz = J9_CLASS_FROM_CP(ramCP);\n \t\tJ9RAMStringRef *ramStringRef = (J9RAMStringRef *)&ramCP[cpIndex];\n \t\tj9object_t *stringObjectP = &ramStringRef->stringObject;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (stringRef != NULL) {"
            ],
            "added_lines": [
                "\tif ((NULL != stringRef) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveInterfaceMethodRefInto",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "J9Method *   \nresolveInterfaceMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMInterfaceMethodRef *ramCPEntry)\n{\n\tJ9Method *returnValue = NULL;\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *interfaceClass;\n\tJ9ROMNameAndSignature *nameAndSig;\n\tJ9Method *method;\n\tJ9Class *cpClass;\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveInterfaceMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tinterfaceClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If interfaceClass is NULL, the exception has already been set. */\n\tif (interfaceClass == NULL) {\n\t\tgoto done;\n\t}\n\n\tif ((interfaceClass->romClass->modifiers & J9AccInterface) != J9AccInterface) {\n\t\tif (throwException) {\n\t\t\tJ9UTF8 *className = J9ROMCLASS_CLASSNAME(interfaceClass->romClass);\n\t\t\tj9object_t detailMessage = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(className), J9UTF8_LENGTH(className), J9_STR_XLAT);\n\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, (UDATA *)detailMessage);\n\t\t}\n\t\tgoto done;\n\t}\n\t\n\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\tlookupOptions |= J9_LOOK_INTERFACE;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t}\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, interfaceClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveInterfaceMethodRef_lookupMethod(vmStruct, method);\n\t\n\t/* If method is NULL, the exception has already been set. */\n\tif (method != NULL) {\n\t\tif (ramCPEntry != NULL) {\n\t\t\tJ9RAMInterfaceMethodRef *ramInterfaceMethodRef = (J9RAMInterfaceMethodRef *)&ramCP[cpIndex];\n\t\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\t\tUDATA methodIndex = 0;\n\t\t\tUDATA oldArgCount = ramInterfaceMethodRef->methodIndexAndArgCount & 255;\n\t\t\tUDATA tagBits = 0;\n\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(method);\n\t\t\tif (J9_ARE_ANY_BITS_SET(methodClass->romClass->modifiers, J9AccInterface)) {\n\t\t\t\t/* Resolved method is in an interface class */\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccPrivate)) {\n\t\t\t\t\t/* Resolved method is a private interface method which does not appear in the\n\t\t\t\t\t * vTable or iTable.  Use the index into ramMethods in interfaceClass. This is\n\t\t\t\t\t * only allowed in JDK11 and beyond.\n\t\t\t\t\t */\n\t\t\t\t\tif (J2SE_VERSION(vm) < J2SE_V11) {\nnonpublic:\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetIllegalAccessErrorNonPublicInvokeInterface(vmStruct, method);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tmethodIndex = (method - methodClass->ramMethods);\n\t\t\t\t\ttagBits |= J9_ITABLE_INDEX_METHOD_INDEX;\n\t\t\t\t} else {\n\t\t\t\t\t/* Resolved method is a public interface method which appears in the\n\t\t\t\t\t * vTable and iTable.  Use the iTable index in interfaceClass.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = getITableIndexForMethod(method, interfaceClass);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Resolved method is in Object */\n\t\t\t\tAssert_VM_true(methodClass == J9VMJAVALANGOBJECT_OR_NULL(vm));\n\t\t\t\t/* Interfaces inherit only public methods from Object */\n\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccPublic)) {\n\t\t\t\t\tgoto nonpublic;\n\t\t\t\t}\n\t\t\t\tif (J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n\t\t\t\t\t/* Resolved method is in the vTable, so it must be invoked via the\n\t\t\t\t\t * receiver's vTable.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = getVTableOffsetForMethod(method, methodClass, vmStruct);\n\t\t\t\t} else {\n\t\t\t\t\t/* Resolved method is not in the vTable, so invoke it directly\n\t\t\t\t\t * via the index into ramMethods in Object.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = (method - methodClass->ramMethods);\n\t\t\t\t\ttagBits |= J9_ITABLE_INDEX_METHOD_INDEX;\n\t\t\t\t}\n\t\t\t\ttagBits |= J9_ITABLE_INDEX_OBJECT;\n\t\t\t}\n\t\t\t/* Ensure methodIndex can be shifted without losing any bits */\n\t\t\tAssert_VM_true(methodIndex < ((UDATA)1 << ((sizeof(UDATA) * 8) - J9_ITABLE_INDEX_SHIFT)));\n\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;\n\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;\n\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;\n\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;\n\t\t}\n\t\t/* indicate success */\n\t\treturnValue = method;\n\t}\n\ndone:\n\tTrc_VM_resolveInterfaceMethodRef_Exit(vmStruct, returnValue);\n\treturn returnValue;\n}",
        "func": "J9Method *   \nresolveInterfaceMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMInterfaceMethodRef *ramCPEntry)\n{\n\tJ9Method *returnValue = NULL;\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *interfaceClass;\n\tJ9ROMNameAndSignature *nameAndSig;\n\tJ9Method *method;\n\tJ9Class *cpClass;\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveInterfaceMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tinterfaceClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If interfaceClass is NULL, the exception has already been set. */\n\tif (interfaceClass == NULL) {\n\t\tgoto done;\n\t}\n\n\tif ((interfaceClass->romClass->modifiers & J9AccInterface) != J9AccInterface) {\n\t\tif (throwException) {\n\t\t\tJ9UTF8 *className = J9ROMCLASS_CLASSNAME(interfaceClass->romClass);\n\t\t\tj9object_t detailMessage = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(className), J9UTF8_LENGTH(className), J9_STR_XLAT);\n\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, (UDATA *)detailMessage);\n\t\t}\n\t\tgoto done;\n\t}\n\t\n\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\tlookupOptions |= J9_LOOK_INTERFACE;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t}\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, interfaceClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveInterfaceMethodRef_lookupMethod(vmStruct, method);\n\t\n\t/* If method is NULL, the exception has already been set. */\n\tif (method != NULL) {\n\t\tif (ramCPEntry != NULL) {\n\t\t\tJ9RAMInterfaceMethodRef *ramInterfaceMethodRef = (J9RAMInterfaceMethodRef *)&ramCP[cpIndex];\n\t\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\t\tUDATA methodIndex = 0;\n\t\t\tUDATA oldArgCount = ramInterfaceMethodRef->methodIndexAndArgCount & 255;\n\t\t\tUDATA tagBits = 0;\n\t\t\tJ9ROMMethod *romMethod = J9_ROM_METHOD_FROM_RAM_METHOD(method);\n\t\t\tif (J9_ARE_ANY_BITS_SET(methodClass->romClass->modifiers, J9AccInterface)) {\n\t\t\t\t/* Resolved method is in an interface class */\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(romMethod->modifiers, J9AccPrivate)) {\n\t\t\t\t\t/* Resolved method is a private interface method which does not appear in the\n\t\t\t\t\t * vTable or iTable.  Use the index into ramMethods in interfaceClass. This is\n\t\t\t\t\t * only allowed in JDK11 and beyond.\n\t\t\t\t\t */\n\t\t\t\t\tif (J2SE_VERSION(vm) < J2SE_V11) {\nnonpublic:\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetIllegalAccessErrorNonPublicInvokeInterface(vmStruct, method);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tmethodIndex = (method - methodClass->ramMethods);\n\t\t\t\t\ttagBits |= J9_ITABLE_INDEX_METHOD_INDEX;\n\t\t\t\t} else {\n\t\t\t\t\t/* Resolved method is a public interface method which appears in the\n\t\t\t\t\t * vTable and iTable.  Use the iTable index in interfaceClass.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = getITableIndexForMethod(method, interfaceClass);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Resolved method is in Object */\n\t\t\t\tAssert_VM_true(methodClass == J9VMJAVALANGOBJECT_OR_NULL(vm));\n\t\t\t\t/* Interfaces inherit only public methods from Object */\n\t\t\t\tif (J9_ARE_NO_BITS_SET(romMethod->modifiers, J9AccPublic)) {\n\t\t\t\t\tgoto nonpublic;\n\t\t\t\t}\n\t\t\t\tif (J9ROMMETHOD_HAS_VTABLE(romMethod)) {\n\t\t\t\t\t/* Resolved method is in the vTable, so it must be invoked via the\n\t\t\t\t\t * receiver's vTable.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = getVTableOffsetForMethod(method, methodClass, vmStruct);\n\t\t\t\t} else {\n\t\t\t\t\t/* Resolved method is not in the vTable, so invoke it directly\n\t\t\t\t\t * via the index into ramMethods in Object.\n\t\t\t\t\t */\n\t\t\t\t\tmethodIndex = (method - methodClass->ramMethods);\n\t\t\t\t\ttagBits |= J9_ITABLE_INDEX_METHOD_INDEX;\n\t\t\t\t}\n\t\t\t\ttagBits |= J9_ITABLE_INDEX_OBJECT;\n\t\t\t}\n\t\t\t/* Ensure methodIndex can be shifted without losing any bits */\n\t\t\tAssert_VM_true(methodIndex < ((UDATA)1 << ((sizeof(UDATA) * 8) - J9_ITABLE_INDEX_SHIFT)));\n\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;\n\t\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;\n\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;\n\t\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;\n\t\t\t}\n\t\t}\n\t\t/* indicate success */\n\t\treturnValue = method;\n\t}\n\ndone:\n\tTrc_VM_resolveInterfaceMethodRef_Exit(vmStruct, returnValue);\n\treturn returnValue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -109,10 +109,12 @@\n \t\t\t}\n \t\t\t/* Ensure methodIndex can be shifted without losing any bits */\n \t\t\tAssert_VM_true(methodIndex < ((UDATA)1 << ((sizeof(UDATA) * 8) - J9_ITABLE_INDEX_SHIFT)));\n-\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;\n-\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;\n-\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;\n-\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;\n+\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n+\t\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;\n+\t\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;\n+\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;\n+\t\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;\n+\t\t\t}\n \t\t}\n \t\t/* indicate success */\n \t\treturnValue = method;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;",
                "\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;",
                "\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;",
                "\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;"
            ],
            "added_lines": [
                "\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {",
                "\t\t\t\tmethodIndex <<= J9_ITABLE_INDEX_SHIFT;",
                "\t\t\t\tmethodIndex = methodIndex | tagBits | oldArgCount;",
                "\t\t\t\tramCPEntry->methodIndexAndArgCount = methodIndex;",
                "\t\t\t\tramCPEntry->interfaceClass = (UDATA)interfaceClass;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveStaticFieldRef",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "void *   \nresolveStaticFieldRef(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField)\n{\n\t/* Bit of magic here, the resulting field must be in vmStruct->floatTemp1 in the CLINIT case\n\t * as resolveHelper expects to find it there.\n\t */\n\tJ9RAMStaticFieldRef *ramStaticFieldRef = (J9RAMStaticFieldRef *)&vmStruct->floatTemp1;\n\tvoid *staticAddress;\n\n\tstaticAddress = resolveStaticFieldRefInto(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField, ramStaticFieldRef);\n\t\n\tif (staticAddress != NULL) {\n\t\t/* Check for <clinit> case. */\n\t\tif ((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT) {\n\t\t\tJ9Class *clazz = J9RAMSTATICFIELDREF_CLASS(ramStaticFieldRef);\n\t\t\tif (clazz->initializeStatus == (UDATA)vmStruct) {\n\t\t\t\treturn (void *) -1;\n\t\t\t}\n\t\t}\n\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;\n\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;\n\t}\n\n\treturn staticAddress;\n}",
        "func": "void *   \nresolveStaticFieldRef(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField)\n{\n\t/* Bit of magic here, the resulting field must be in vmStruct->floatTemp1 in the CLINIT case\n\t * as resolveHelper expects to find it there.\n\t */\n\tJ9RAMStaticFieldRef *ramStaticFieldRef = (J9RAMStaticFieldRef *)&vmStruct->floatTemp1;\n\tvoid *staticAddress;\n\n\tstaticAddress = resolveStaticFieldRefInto(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField, ramStaticFieldRef);\n\t\n\tif (staticAddress != NULL) {\n\t\t/* Check for <clinit> case. */\n\t\tif ((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT) {\n\t\t\tJ9Class *clazz = J9RAMSTATICFIELDREF_CLASS(ramStaticFieldRef);\n\t\t\tif (clazz->initializeStatus == (UDATA)vmStruct) {\n\t\t\t\treturn (void *) -1;\n\t\t\t}\n\t\t}\n\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;\n\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;\n\t\t}\n\t}\n\n\treturn staticAddress;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,10 @@\n \t\t\t\treturn (void *) -1;\n \t\t\t}\n \t\t}\n-\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;\n-\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;\n+\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n+\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;\n+\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;\n+\t\t}\n \t}\n \n \treturn staticAddress;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;",
                "\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;"
            ],
            "added_lines": [
                "\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {",
                "\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->valueOffset = ramStaticFieldRef->valueOffset;",
                "\t\t\t((J9RAMStaticFieldRef *)&ramCP[cpIndex])->flagsAndClass = ramStaticFieldRef->flagsAndClass;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveStaticSplitMethodRef",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "J9Method *   \nresolveStaticSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags)\n{\n\tJ9RAMStaticMethodRef *ramStaticMethodRef = (J9RAMStaticMethodRef *)&vmStruct->floatTemp1;\n\tU_16 cpIndex = *(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex);\n\tJ9Method *method = ramCP->ramClass->staticSplitMethodTable[splitTableIndex];\n\n\tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialStaticMethod) {\n\t\tmethod = resolveStaticMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, ramStaticMethodRef);\n\n\t\tif (NULL != method) {\n\t\t\t/* Check for <clinit> case. */\n\t\t\tif (((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT)\n\t\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n\t\t\t) {\n\t\t\t\treturn (J9Method *) -1;\n\t\t\t} else {\n\t\t\t\tramCP->ramClass->staticSplitMethodTable[splitTableIndex] = method;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn method;\n}",
        "func": "J9Method *   \nresolveStaticSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags)\n{\n\tJ9RAMStaticMethodRef *ramStaticMethodRef = (J9RAMStaticMethodRef *)&vmStruct->floatTemp1;\n\tU_16 cpIndex = *(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex);\n\tJ9Method *method = ramCP->ramClass->staticSplitMethodTable[splitTableIndex];\n\n\tif (method == (J9Method*)vmStruct->javaVM->initialMethods.initialStaticMethod) {\n\t\tmethod = resolveStaticMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, ramStaticMethodRef);\n\n\t\tif (NULL != method) {\n\t\t\t/* Check for <clinit> case. */\n\t\t\tif (((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT)\n\t\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n\t\t\t) {\n\t\t\t\treturn (J9Method *) -1;\n\t\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\t\t\t\n\t\t\t\tramCP->ramClass->staticSplitMethodTable[splitTableIndex] = method;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn method;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \t\t\t\t&& (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct)\n \t\t\t) {\n \t\t\t\treturn (J9Method *) -1;\n-\t\t\t} else {\n+\t\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\t\t\t\n \t\t\t\tramCP->ramClass->staticSplitMethodTable[splitTableIndex] = method;\n \t\t\t}\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t} else {"
            ],
            "added_lines": [
                "\t\t\t} else if (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\t\t\t"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveOpenJDKInvokeHandle",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "j9object_t\nresolveOpenJDKInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n\tj9object_t result = *invokeCache;\n\n\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n\n\tif ((NULL == result) && canRunJavaCode) {\n\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\t\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\t\t/* Resolve the class. */\n\t\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\tif (resolvedClass != NULL) {\n\t\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n\t\t\tresult = (j9object_t)vmThread->returnValue;\n\n\t\t\tif (vmThread->currentException != NULL) {\n\t\t\t\t/* Already a pending exception */\n\t\t\t\tresult = NULL;\n\t\t\t} else if (result == NULL) {\n\t\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t\t} else {\n\t\t\t\t/* Only write the value in if it is not null */\n\t\t\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n\n\t\t\t\t/* Ensure that result array elements are written before the array reference is stored */\n\t\t\t\tVM_AtomicSupport::writeBarrier();\n\t\t\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, ramClass, invokeCache, NULL, result)) {\n\t\t\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n\t\t\t\t\tresult = *invokeCache;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tTrc_VM_resolveInvokeHandle_Exit(vmThread, result);\n\treturn result;\n#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tTrc_VM_Assert_ShouldNeverHappen();\n\treturn NULL;\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n}",
        "func": "j9object_t\nresolveOpenJDKInvokeHandle(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tbool canRunJavaCode = J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME | J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tJ9RAMMethodRef *ramCPEntry = (J9RAMMethodRef*)ramCP + cpIndex;\n\tUDATA invokeCacheIndex = ramCPEntry->methodIndexAndArgCount >> 8;\n\tJ9Class *ramClass = J9_CLASS_FROM_CP(ramCP);\n\tj9object_t *invokeCache = ramClass->invokeCache + invokeCacheIndex;\n\tj9object_t result = *invokeCache;\n\n\tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n\n\tAssert_VM_true(J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE));\n\n\tif ((NULL == result) && canRunJavaCode) {\n\t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\t\tJ9ROMNameAndSignature *nameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\t\t/* Resolve the class. */\n\t\tJ9Class *resolvedClass = resolveClassRef(vmThread, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\tif (resolvedClass != NULL) {\n\t\t\tsendResolveOpenJDKInvokeHandle(vmThread, ramCP, cpIndex, MH_REF_INVOKEVIRTUAL, resolvedClass, nameAndSig);\n\t\t\tresult = (j9object_t)vmThread->returnValue;\n\n\t\t\tif (vmThread->currentException != NULL) {\n\t\t\t\t/* Already a pending exception */\n\t\t\t\tresult = NULL;\n\t\t\t} else if (result == NULL) {\n\t\t\t\tsetCurrentExceptionUTF(vmThread, J9VMCONSTANTPOOL_JAVALANGNULLPOINTEREXCEPTION, NULL);\n\t\t\t} else {\n\t\t\t\t/* Only write the value in if it is not null */\n\t\t\t\tJ9MemoryManagerFunctions *gcFuncs = vmThread->javaVM->memoryManagerFunctions;\n\n\t\t\t\t/* Ensure that result array elements are written before the array reference is stored */\n\t\t\t\tVM_AtomicSupport::writeBarrier();\n\t\t\t\tif (0 == gcFuncs->j9gc_objaccess_staticCompareAndSwapObject(vmThread, ramClass, invokeCache, NULL, result)) {\n\t\t\t\t\t/* Another thread beat this thread to updating the call site, ensure both threads return the same method handle. */\n\t\t\t\t\tresult = *invokeCache;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tTrc_VM_resolveInvokeHandle_Exit(vmThread, result);\n\treturn result;\n#else /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tTrc_VM_Assert_ShouldNeverHappen();\n\treturn NULL;\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,8 @@\n \tj9object_t result = *invokeCache;\n \n \tTrc_VM_resolveInvokeHandle_Entry(vmThread, ramCP, cpIndex, resolveFlags);\n+\n+\tAssert_VM_true(J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE));\n \n \tif ((NULL == result) && canRunJavaCode) {\n \t\tJ9ROMMethodRef *romMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tAssert_VM_true(J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveStaticFieldRefInto",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "void *    \nresolveStaticFieldRefInto(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField, J9RAMStaticFieldRef *ramCPEntry)\n{\n\tvoid *staticAddress;\n\tJ9ROMFieldRef *romFieldRef;\n\tJ9Class *resolvedClass;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticFieldRef_Entry(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField);\n\ntryAgain:\n\tstaticAddress = NULL;\n\n\t/* Get the class.  Stop immediately if an exception occurs. */\n\tromFieldRef = (J9ROMFieldRef *)&ramCP->romConstantPool[cpIndex];\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romFieldRef->classRefCPIndex, resolveFlags);\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (resolvedClass != NULL) {\n\t\tJ9JavaVM *javaVM = vmStruct->javaVM;\n\t\tJ9Class *classFromCP = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9ROMFieldShape *field;\n\t\tJ9Class *definingClass;\n\t\tJ9ROMNameAndSignature *nameAndSig;\n\t\tJ9UTF8 *name;\n\t\tJ9UTF8 *signature;\n\t\tIDATA checkResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\t\tIDATA badMemberModifier = 0;\n\t\tJ9Class *targetClass = NULL;\n\t\tUDATA modifiers = 0;\n\t\tJ9Class *localClassAndFlags = NULL;\n\t\tUDATA initStatus = 0;\n\n\t\t/* ensure that the class is visible */\n\t\tcheckResult = checkVisibility(vmStruct, classFromCP, resolvedClass, resolvedClass->romClass->modifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\ttargetClass = resolvedClass;\n\t\t\tbadMemberModifier = resolvedClass->romClass->modifiers;\n\t\t\tgoto illegalAccess;\n\t\t}\n\n\t\t/* Get the field address. */\n\t\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romFieldRef);\n\t\tname = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\tsignature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\tstaticAddress = staticFieldAddress(vmStruct, resolvedClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(signature), J9UTF8_LENGTH(signature), &definingClass, (UDATA *)&field, lookupOptions, classFromCP);\n\t\t/* Stop if an exception occurred. */\n\t\tif (staticAddress != NULL) {\n\t\t\tmodifiers = field->modifiers;\n\t\t\tlocalClassAndFlags = definingClass;\n\t\t\tinitStatus = definingClass->initializeStatus;\n\n\t\t\tif (resolvedField != NULL) {\n\t\t\t\t/* save away field for callee */\n\t\t\t\t*resolvedField = field;\n\t\t\t}\n\n\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\t\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA) vmStruct) {\n\t\t\t\t\t/* Initialize the class if java code is allowed */\n\t\t\t\t\tif (canRunJavaCode) {\n\t\t\t\t\t\tUDATA preCount = javaVM->hotSwapCount;\n\n\t\t\t\t\t\tinitializeClass(vmStruct, definingClass);\n\t\t\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preCount != javaVM->hotSwapCount) {\n\t\t\t\t\t\t\tgoto tryAgain;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER) != 0 && (modifiers & J9AccFinal) != 0) {\n\t\t\t\tcheckResult = checkVisibility(vmStruct, classFromCP, definingClass, J9AccPrivate, lookupOptions | J9_LOOK_NO_NESTMATES);\n\t\t\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t\t\ttargetClass = definingClass;\n\t\t\t\t\tbadMemberModifier = J9AccPrivate;\nillegalAccess:\n\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\tif (canRunJavaCode && !threadEventsPending(vmStruct)) {\n\t\t\t\t\t\tchar *errorMsg = NULL;\n\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, badMemberModifier, classFromCP, targetClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, -1, classFromCP, targetClass, checkResult);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\t\t\tj9mem_free_memory(errorMsg);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (!finalFieldSetAllowed(vmStruct, true, method, definingClass, classFromCP, field, canRunJavaCode)) {\n\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t} else { /* finalFieldSetAllowed */\n\t\t\t\t\tif (jitCompileTimeResolve) {\n\t\t\t\t\t\t/* Don't report the final field modification for JIT compile-time resolves.\n\t\t\t\t\t\t * Reporting may deadlock due to interaction between safepoint and ClassUnloadMutex.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tVM_VMHelpers::reportFinalFieldModified(vmStruct, definingClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* check class constraints */\n\t\t\tif ((javaVM->runtimeFlags & J9_RUNTIME_VERIFY) != 0) {\n\t\t\t\tJ9ClassLoader *cl1 = classFromCP->classLoader;\n\t\t\t\tJ9ClassLoader *cl2 = definingClass->classLoader;\n\n\t\t\t\tif (cl1 == NULL) {\n\t\t\t\t\tcl1 = javaVM->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (cl1 != cl2) {\n\t\t\t\t\tJ9UTF8 *fieldSignature = J9ROMFIELDSHAPE_SIGNATURE(field);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(vmStruct, cl1, cl2, signature, fieldSignature) != 0) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGVERIFYERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* If this is a JIT compile-time resolve, do not allow fields declared in uninitialized classes. */\n\t\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (ramCPEntry != NULL) {\n\t\t\t\tUDATA localClassAndFlagsData = (UDATA)localClassAndFlags;\n\t\t\t\t/* Add bits to the class for base type and double wide field. */\n\t\t\t\tif ((modifiers & J9FieldFlagObject) != J9FieldFlagObject) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefBaseType;\n\t\t\t\t\tif ((modifiers & J9FieldSizeDouble) == J9FieldSizeDouble) {\n\t\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefDouble;\n\t\t\t\t\t} else if (J9FieldTypeBoolean == (modifiers & J9FieldTypeMask)) {\n\t\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefBoolean;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Set the volatile, final and setter bits in the flags as needed */\n\t\t\t\tif ((modifiers & J9AccVolatile) == J9AccVolatile) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefVolatile;\n\t\t\t\t}\n\t\t\t\tif ((modifiers & J9AccFinal) == J9AccFinal) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefFinal;\n\t\t\t\t}\n\t\t\t\tif (0 != (resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER)) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefPutResolved;\n\t\t\t\t}\n\t\t\t\t/* Swap the class address bits and the flag bits. */\n\t\t\t\tramCPEntry->flagsAndClass = J9FLAGSANDCLASS_FROM_CLASSANDFLAGS(localClassAndFlagsData);\n\t\t\t\t/* Set the high bit in valueOffset to ensure that a resolved static field ref is always interpreted as an unresolved instance fieldref. */\n\t\t\t\tramCPEntry->valueOffset = ((UDATA) staticAddress - (UDATA) localClassAndFlags->ramStatics) | (UDATA) IDATA_MIN;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveStaticFieldRef_Exit(vmStruct, staticAddress);\n\treturn staticAddress;\n}",
        "func": "void *    \nresolveStaticFieldRefInto(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField, J9RAMStaticFieldRef *ramCPEntry)\n{\n\tvoid *staticAddress;\n\tJ9ROMFieldRef *romFieldRef;\n\tJ9Class *resolvedClass;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticFieldRef_Entry(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField);\n\ntryAgain:\n\tstaticAddress = NULL;\n\n\t/* Get the class.  Stop immediately if an exception occurs. */\n\tromFieldRef = (J9ROMFieldRef *)&ramCP->romConstantPool[cpIndex];\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romFieldRef->classRefCPIndex, resolveFlags);\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (resolvedClass != NULL) {\n\t\tJ9JavaVM *javaVM = vmStruct->javaVM;\n\t\tJ9Class *classFromCP = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9ROMFieldShape *field;\n\t\tJ9Class *definingClass;\n\t\tJ9ROMNameAndSignature *nameAndSig;\n\t\tJ9UTF8 *name;\n\t\tJ9UTF8 *signature;\n\t\tIDATA checkResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\t\tIDATA badMemberModifier = 0;\n\t\tJ9Class *targetClass = NULL;\n\t\tUDATA modifiers = 0;\n\t\tJ9Class *localClassAndFlags = NULL;\n\t\tUDATA initStatus = 0;\n\n\t\t/* ensure that the class is visible */\n\t\tcheckResult = checkVisibility(vmStruct, classFromCP, resolvedClass, resolvedClass->romClass->modifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\ttargetClass = resolvedClass;\n\t\t\tbadMemberModifier = resolvedClass->romClass->modifiers;\n\t\t\tgoto illegalAccess;\n\t\t}\n\n\t\t/* Get the field address. */\n\t\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romFieldRef);\n\t\tname = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\tsignature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n\t\tstaticAddress = staticFieldAddress(vmStruct, resolvedClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(signature), J9UTF8_LENGTH(signature), &definingClass, (UDATA *)&field, lookupOptions, classFromCP);\n\t\t/* Stop if an exception occurred. */\n\t\tif (staticAddress != NULL) {\n\t\t\tmodifiers = field->modifiers;\n\t\t\tlocalClassAndFlags = definingClass;\n\t\t\tinitStatus = definingClass->initializeStatus;\n\n\t\t\tif (resolvedField != NULL) {\n\t\t\t\t/* save away field for callee */\n\t\t\t\t*resolvedField = field;\n\t\t\t}\n\n\t\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\t\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA) vmStruct) {\n\t\t\t\t\t/* Initialize the class if java code is allowed */\n\t\t\t\t\tif (canRunJavaCode) {\n\t\t\t\t\t\tUDATA preCount = javaVM->hotSwapCount;\n\n\t\t\t\t\t\tinitializeClass(vmStruct, definingClass);\n\t\t\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preCount != javaVM->hotSwapCount) {\n\t\t\t\t\t\t\tgoto tryAgain;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER) != 0 && (modifiers & J9AccFinal) != 0) {\n\t\t\t\tcheckResult = checkVisibility(vmStruct, classFromCP, definingClass, J9AccPrivate, lookupOptions | J9_LOOK_NO_NESTMATES);\n\t\t\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t\t\ttargetClass = definingClass;\n\t\t\t\t\tbadMemberModifier = J9AccPrivate;\nillegalAccess:\n\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\tif (canRunJavaCode && !threadEventsPending(vmStruct)) {\n\t\t\t\t\t\tchar *errorMsg = NULL;\n\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, badMemberModifier, classFromCP, targetClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, -1, classFromCP, targetClass, checkResult);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\t\t\tj9mem_free_memory(errorMsg);\n\t\t\t\t\t}\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (!finalFieldSetAllowed(vmStruct, true, method, definingClass, classFromCP, field, canRunJavaCode)) {\n\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t} else { /* finalFieldSetAllowed */\n\t\t\t\t\tif (jitCompileTimeResolve) {\n\t\t\t\t\t\t/* Don't report the final field modification for JIT compile-time resolves.\n\t\t\t\t\t\t * Reporting may deadlock due to interaction between safepoint and ClassUnloadMutex.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tVM_VMHelpers::reportFinalFieldModified(vmStruct, definingClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* check class constraints */\n\t\t\tif ((javaVM->runtimeFlags & J9_RUNTIME_VERIFY) != 0) {\n\t\t\t\tJ9ClassLoader *cl1 = classFromCP->classLoader;\n\t\t\t\tJ9ClassLoader *cl2 = definingClass->classLoader;\n\n\t\t\t\tif (cl1 == NULL) {\n\t\t\t\t\tcl1 = javaVM->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (cl1 != cl2) {\n\t\t\t\t\tJ9UTF8 *fieldSignature = J9ROMFIELDSHAPE_SIGNATURE(field);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(vmStruct, cl1, cl2, signature, fieldSignature) != 0) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGVERIFYERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstaticAddress = NULL;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* If this is a JIT compile-time resolve, do not allow fields declared in uninitialized classes. */\n\t\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t\tUDATA localClassAndFlagsData = (UDATA)localClassAndFlags;\n\t\t\t\t/* Add bits to the class for base type and double wide field. */\n\t\t\t\tif ((modifiers & J9FieldFlagObject) != J9FieldFlagObject) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefBaseType;\n\t\t\t\t\tif ((modifiers & J9FieldSizeDouble) == J9FieldSizeDouble) {\n\t\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefDouble;\n\t\t\t\t\t} else if (J9FieldTypeBoolean == (modifiers & J9FieldTypeMask)) {\n\t\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefBoolean;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Set the volatile, final and setter bits in the flags as needed */\n\t\t\t\tif ((modifiers & J9AccVolatile) == J9AccVolatile) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefVolatile;\n\t\t\t\t}\n\t\t\t\tif ((modifiers & J9AccFinal) == J9AccFinal) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefFinal;\n\t\t\t\t}\n\t\t\t\tif (0 != (resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER)) {\n\t\t\t\t\tlocalClassAndFlagsData |= J9StaticFieldRefPutResolved;\n\t\t\t\t}\n\t\t\t\t/* Swap the class address bits and the flag bits. */\n\t\t\t\tramCPEntry->flagsAndClass = J9FLAGSANDCLASS_FROM_CLASSANDFLAGS(localClassAndFlagsData);\n\t\t\t\t/* Set the high bit in valueOffset to ensure that a resolved static field ref is always interpreted as an unresolved instance fieldref. */\n\t\t\t\tramCPEntry->valueOffset = ((UDATA) staticAddress - (UDATA) localClassAndFlags->ramStatics) | (UDATA) IDATA_MIN;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveStaticFieldRef_Exit(vmStruct, staticAddress);\n\treturn staticAddress;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -146,7 +146,7 @@\n \t\t\t\tgoto done;\n \t\t\t}\n \n-\t\t\tif (ramCPEntry != NULL) {\n+\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\t\tUDATA localClassAndFlagsData = (UDATA)localClassAndFlags;\n \t\t\t\t/* Add bits to the class for base type and double wide field. */\n \t\t\t\tif ((modifiers & J9FieldFlagObject) != J9FieldFlagObject) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (ramCPEntry != NULL) {"
            ],
            "added_lines": [
                "\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveInstanceFieldRefInto",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "IDATA   \nresolveInstanceFieldRefInto(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField, J9RAMFieldRef *ramCPEntry)\n{\n\tIDATA fieldOffset = -1;\n\tJ9ROMFieldRef *romFieldRef;\n\tJ9Class *resolvedClass;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveInstanceFieldRef_Entry(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField);\n\t\n\t/* Get the class.  Stop immediately if an exception occurs. */\n\tromFieldRef = (J9ROMFieldRef *)&ramCP->romConstantPool[cpIndex];\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romFieldRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If clazz is NULL, the exception has already been set. */\n\tif (resolvedClass != NULL) {\n\t\tJ9JavaVM *javaVM = vmStruct->javaVM;\n\t\tJ9Class *classFromCP = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9ROMFieldShape *field;\n\t\tJ9Class *definingClass;\n\t\tJ9ROMNameAndSignature *nameAndSig;\n\t\tJ9UTF8 *name;\n\t\tJ9UTF8 *signature;\n\t\tIDATA checkResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\t\tIDATA badMemberModifier = 0;\n\t\tJ9Class *targetClass = NULL;\n\t\tUDATA modifiers = 0;\n\t\tchar *nlsStr = NULL;\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\tUDATA fieldIndex = 0;\n\t\tbool fccEntryFieldNotSet = true;\n\t\tJ9Class *flattenableClass = NULL;\n\t\tJ9FlattenedClassCache *flattenedClassCache = NULL;\n#endif\t\t\n\t\tbool isWithField = false;\n\t\tJ9Class *currentTargetClass = NULL;\n\t\tJ9Class *currentSenderClass = NULL;\n\n\t\t/* ensure that the class is visible */\n\t\tcheckResult = checkVisibility(vmStruct, classFromCP, resolvedClass, resolvedClass->romClass->modifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\tbadMemberModifier = resolvedClass->romClass->modifiers;\n\t\t\ttargetClass = resolvedClass;\n\t\t\tgoto illegalAccess;\n\t\t}\n\t\t/* Reset checkResult to the default error case */\n\t\tcheckResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\n\t\t/* Get the field address. */\n\t\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romFieldRef);\n\t\tname = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\tsignature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\tisWithField = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_WITH_FIELD);\n\t\t/**\n\t\t * This is an optimization that searches for a field offset in the FCC. \n\t\t * If the offset is found there is no need to repeat the process. \n\t\t * Also, since this optimization is only done for ValueTypes, \n\t\t * the resolvedClass will always be the class that owns the field, \n\t\t * since ValueType superclasses can not have fields.\n\t\t */\n\t\tif (J9_IS_J9CLASS_VALUETYPE(resolvedClass)) {\n\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {\n\t\t\t\tflattenedClassCache = resolvedClass->flattenedClassCache;\n\t\t\t\tfieldIndex = findIndexInFlattenedClassCache(flattenedClassCache, nameAndSig);\n\t\t\t\tAssert_VM_false(UDATA_MAX == fieldIndex);\n\t\t\t\tJ9FlattenedClassCacheEntry * flattenedClassCacheEntry = J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex);\n\t\t\t\tfieldOffset = flattenedClassCacheEntry->offset;\n\t\t\t\tif (-1 != fieldOffset) {\n\t\t\t\t\tdefiningClass = resolvedClass;\n\t\t\t\t\tfield = flattenedClassCacheEntry->field;\n\t\t\t\t\tflattenableClass = J9_VM_FCC_CLASS_FROM_ENTRY(flattenedClassCacheEntry);\n\t\t\t\t\tfccEntryFieldNotSet = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fccEntryFieldNotSet) \n#endif\n\t\t{\n\t\t\tfieldOffset = instanceFieldOffsetWithSourceClass(vmStruct, resolvedClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(signature), J9UTF8_LENGTH(signature), &definingClass, (UDATA *)&field, lookupOptions, classFromCP);\n\t\t}\n\t\t/* Stop if an exception occurred. */\n\t\tif (fieldOffset != -1) {\n\t\t\tcurrentTargetClass = J9_CURRENT_CLASS(resolvedClass);\n\t\t\tcurrentSenderClass = J9_CURRENT_CLASS(classFromCP);\n\t\t\tmodifiers = field->modifiers;\n\n\t\t\t/* Add the field checking to ensure IllegalAccessError\n\t\t\t * gets thrown out in the case of protected field if in different packages\n\t\t\t */\n\t\t\tif (J9_ARE_ALL_BITS_SET(modifiers, J9AccProtected)\n\t\t\t&& J9_ARE_NO_BITS_SET(modifiers, J9AccStatic)\n\t\t\t&& !J9ROMCLASS_IS_ARRAY(currentTargetClass->romClass)\n\t\t\t&& isSameOrSuperClassOf(definingClass, currentSenderClass)\n\t\t\t&& (definingClass->packageID != currentSenderClass->packageID)\n\t\t\t&& !isSameOrSuperClassOf(currentSenderClass, currentTargetClass)\n\t\t\t&& !isSameOrSuperClassOf(currentTargetClass, currentSenderClass)\n\t\t\t) {\n\t\t\t\tbadMemberModifier = modifiers;\n\t\t\t\ttargetClass = currentTargetClass;\n\t\t\t\tgoto illegalAccess;\n\t\t\t}\n\n\t\t\tif ((modifiers & J9AccFinal) != 0) {\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_FIELD_SETTER)\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\t\t|| isWithField\n#endif /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n\t\t\t\t) {\n\t\t\t\t\tcheckResult = checkVisibility(vmStruct, classFromCP, definingClass, J9AccPrivate, isWithField ? lookupOptions : (lookupOptions | J9_LOOK_NO_NESTMATES));\n\t\t\t\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t\t\t\tbadMemberModifier = J9AccPrivate;\n\t\t\t\t\t\ttargetClass = definingClass;\nillegalAccess:\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\t\t\t\tnlsStr = illegalAccessMessage(vmStruct, badMemberModifier, classFromCP, targetClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnlsStr = illegalAccessMessage(vmStruct, -1, classFromCP, targetClass, checkResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, nlsStr);\n\t\t\t\t\t\t\tj9mem_free_memory(nlsStr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\t\t\t\t/* The withfield bytecode is allowed to set a final field. However, the invoker of withfield must have private access\n\t\t\t\t\t\t\t * to the field (similar to a constructor setting a final field). The private access check is done above, so if we get\n\t\t\t\t\t\t\t * to this point we can skip the finalFieldSetAllowed() if we know its a withfield */\n\t\t\t\t\t\t\t!isWithField &&\n#endif\n\t\t\t\t\t\t\t!finalFieldSetAllowed(vmStruct, false, method, definingClass, classFromCP, field, canRunJavaCode)\n\t\t\t\t\t) {\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* check class constraints */\n\t\t\tif ((javaVM->runtimeFlags & J9_RUNTIME_VERIFY) != 0) {\n\t\t\t\tJ9ClassLoader *cl1 = classFromCP->classLoader;\n\t\t\t\tJ9ClassLoader *cl2 = definingClass->classLoader;\n\n\t\t\t\tif (cl1 == NULL) {\n\t\t\t\t\tcl1 = javaVM->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (cl1 != cl2) {\n\t\t\t\t\tJ9UTF8 *fieldSignature = J9ROMFIELDSHAPE_SIGNATURE(field);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(vmStruct, cl1, cl2, signature, fieldSignature) != 0) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGVERIFYERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (ramCPEntry != NULL) {\n\t\t\t\tUDATA valueOffset = fieldOffset;\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {\n\t\t\t\t\tif (fccEntryFieldNotSet) {\n\t\t\t\t\t\tflattenedClassCache = definingClass->flattenedClassCache;\n\t\t\t\t\t\tfieldIndex = findIndexInFlattenedClassCache(flattenedClassCache, nameAndSig);\n\t\t\t\t\t\tflattenableClass = J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex)->clazz;\n\t\t\t\t\t}\n\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(flattenableClass->classFlags, J9ClassIsFlattened)) {\n\t\t\t\t\t\tif (fccEntryFieldNotSet) {\n\t\t\t\t\t\t\tJ9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex)->offset = valueOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodifiers |= J9FieldFlagFlattened;\n\t\t\t\t\t\tvalueOffset = (UDATA) J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex);\n\t\t\t\t\t\t/* offset must be written to flattenedClassCache before fieldref is marked as resolved */\n\t\t\t\t\t\tissueWriteBarrier();\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* Sign extend the resolved constant to make sure that it is always larger than valueOffset field */\n\t\t\t\tmodifiers |= (UDATA)(IDATA)(I_32) J9FieldFlagResolved;\n\t\t\t\tif (0 != (resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER)) {\n\t\t\t\t\tmodifiers |= J9FieldFlagPutResolved;\n\t\t\t\t}\n\t\t\t\tramCPEntry->valueOffset = valueOffset;\n\t\t\t\tramCPEntry->flags = modifiers;\n\t\t\t}\n\n\t\t\tif (resolvedField != NULL) {\n\t\t\t\t*resolvedField = field;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveInstanceFieldRef_Exit(vmStruct, fieldOffset);\n\treturn fieldOffset;\n}",
        "func": "IDATA   \nresolveInstanceFieldRefInto(J9VMThread *vmStruct, J9Method *method, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9ROMFieldShape **resolvedField, J9RAMFieldRef *ramCPEntry)\n{\n\tIDATA fieldOffset = -1;\n\tJ9ROMFieldRef *romFieldRef;\n\tJ9Class *resolvedClass;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveInstanceFieldRef_Entry(vmStruct, method, ramCP, cpIndex, resolveFlags, resolvedField);\n\t\n\t/* Get the class.  Stop immediately if an exception occurs. */\n\tromFieldRef = (J9ROMFieldRef *)&ramCP->romConstantPool[cpIndex];\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romFieldRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If clazz is NULL, the exception has already been set. */\n\tif (resolvedClass != NULL) {\n\t\tJ9JavaVM *javaVM = vmStruct->javaVM;\n\t\tJ9Class *classFromCP = J9_CLASS_FROM_CP(ramCP);\n\t\tJ9ROMFieldShape *field;\n\t\tJ9Class *definingClass;\n\t\tJ9ROMNameAndSignature *nameAndSig;\n\t\tJ9UTF8 *name;\n\t\tJ9UTF8 *signature;\n\t\tIDATA checkResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\t\tIDATA badMemberModifier = 0;\n\t\tJ9Class *targetClass = NULL;\n\t\tUDATA modifiers = 0;\n\t\tchar *nlsStr = NULL;\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\tUDATA fieldIndex = 0;\n\t\tbool fccEntryFieldNotSet = true;\n\t\tJ9Class *flattenableClass = NULL;\n\t\tJ9FlattenedClassCache *flattenedClassCache = NULL;\n#endif\t\t\n\t\tbool isWithField = false;\n\t\tJ9Class *currentTargetClass = NULL;\n\t\tJ9Class *currentSenderClass = NULL;\n\n\t\t/* ensure that the class is visible */\n\t\tcheckResult = checkVisibility(vmStruct, classFromCP, resolvedClass, resolvedClass->romClass->modifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\tbadMemberModifier = resolvedClass->romClass->modifiers;\n\t\t\ttargetClass = resolvedClass;\n\t\t\tgoto illegalAccess;\n\t\t}\n\t\t/* Reset checkResult to the default error case */\n\t\tcheckResult = J9_VISIBILITY_NON_MODULE_ACCESS_ERROR;\n\n\t\t/* Get the field address. */\n\t\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romFieldRef);\n\t\tname = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\tsignature = J9ROMNAMEANDSIGNATURE_SIGNATURE(nameAndSig);\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\tisWithField = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_WITH_FIELD);\n\t\t/**\n\t\t * This is an optimization that searches for a field offset in the FCC. \n\t\t * If the offset is found there is no need to repeat the process. \n\t\t * Also, since this optimization is only done for ValueTypes, \n\t\t * the resolvedClass will always be the class that owns the field, \n\t\t * since ValueType superclasses can not have fields.\n\t\t */\n\t\tif (J9_IS_J9CLASS_VALUETYPE(resolvedClass)) {\n\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {\n\t\t\t\tflattenedClassCache = resolvedClass->flattenedClassCache;\n\t\t\t\tfieldIndex = findIndexInFlattenedClassCache(flattenedClassCache, nameAndSig);\n\t\t\t\tAssert_VM_false(UDATA_MAX == fieldIndex);\n\t\t\t\tJ9FlattenedClassCacheEntry * flattenedClassCacheEntry = J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex);\n\t\t\t\tfieldOffset = flattenedClassCacheEntry->offset;\n\t\t\t\tif (-1 != fieldOffset) {\n\t\t\t\t\tdefiningClass = resolvedClass;\n\t\t\t\t\tfield = flattenedClassCacheEntry->field;\n\t\t\t\t\tflattenableClass = J9_VM_FCC_CLASS_FROM_ENTRY(flattenedClassCacheEntry);\n\t\t\t\t\tfccEntryFieldNotSet = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fccEntryFieldNotSet) \n#endif\n\t\t{\n\t\t\tfieldOffset = instanceFieldOffsetWithSourceClass(vmStruct, resolvedClass, J9UTF8_DATA(name), J9UTF8_LENGTH(name), J9UTF8_DATA(signature), J9UTF8_LENGTH(signature), &definingClass, (UDATA *)&field, lookupOptions, classFromCP);\n\t\t}\n\t\t/* Stop if an exception occurred. */\n\t\tif (fieldOffset != -1) {\n\t\t\tcurrentTargetClass = J9_CURRENT_CLASS(resolvedClass);\n\t\t\tcurrentSenderClass = J9_CURRENT_CLASS(classFromCP);\n\t\t\tmodifiers = field->modifiers;\n\n\t\t\t/* Add the field checking to ensure IllegalAccessError\n\t\t\t * gets thrown out in the case of protected field if in different packages\n\t\t\t */\n\t\t\tif (J9_ARE_ALL_BITS_SET(modifiers, J9AccProtected)\n\t\t\t&& J9_ARE_NO_BITS_SET(modifiers, J9AccStatic)\n\t\t\t&& !J9ROMCLASS_IS_ARRAY(currentTargetClass->romClass)\n\t\t\t&& isSameOrSuperClassOf(definingClass, currentSenderClass)\n\t\t\t&& (definingClass->packageID != currentSenderClass->packageID)\n\t\t\t&& !isSameOrSuperClassOf(currentSenderClass, currentTargetClass)\n\t\t\t&& !isSameOrSuperClassOf(currentTargetClass, currentSenderClass)\n\t\t\t) {\n\t\t\t\tbadMemberModifier = modifiers;\n\t\t\t\ttargetClass = currentTargetClass;\n\t\t\t\tgoto illegalAccess;\n\t\t\t}\n\n\t\t\tif ((modifiers & J9AccFinal) != 0) {\n\t\t\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_FIELD_SETTER)\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\t\t|| isWithField\n#endif /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n\t\t\t\t) {\n\t\t\t\t\tcheckResult = checkVisibility(vmStruct, classFromCP, definingClass, J9AccPrivate, isWithField ? lookupOptions : (lookupOptions | J9_LOOK_NO_NESTMATES));\n\t\t\t\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t\t\t\tbadMemberModifier = J9AccPrivate;\n\t\t\t\t\t\ttargetClass = definingClass;\nillegalAccess:\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\t\t\t\tnlsStr = illegalAccessMessage(vmStruct, badMemberModifier, classFromCP, targetClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnlsStr = illegalAccessMessage(vmStruct, -1, classFromCP, targetClass, checkResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, nlsStr);\n\t\t\t\t\t\t\tj9mem_free_memory(nlsStr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\t\t\t\t/* The withfield bytecode is allowed to set a final field. However, the invoker of withfield must have private access\n\t\t\t\t\t\t\t * to the field (similar to a constructor setting a final field). The private access check is done above, so if we get\n\t\t\t\t\t\t\t * to this point we can skip the finalFieldSetAllowed() if we know its a withfield */\n\t\t\t\t\t\t\t!isWithField &&\n#endif\n\t\t\t\t\t\t\t!finalFieldSetAllowed(vmStruct, false, method, definingClass, classFromCP, field, canRunJavaCode)\n\t\t\t\t\t) {\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* check class constraints */\n\t\t\tif ((javaVM->runtimeFlags & J9_RUNTIME_VERIFY) != 0) {\n\t\t\t\tJ9ClassLoader *cl1 = classFromCP->classLoader;\n\t\t\t\tJ9ClassLoader *cl2 = definingClass->classLoader;\n\n\t\t\t\tif (cl1 == NULL) {\n\t\t\t\t\tcl1 = javaVM->systemClassLoader;\n\t\t\t\t}\n\t\t\t\tif (cl1 != cl2) {\n\t\t\t\t\tJ9UTF8 *fieldSignature = J9ROMFIELDSHAPE_SIGNATURE(field);\n\t\t\t\t\tif (j9bcv_checkClassLoadingConstraintsForSignature(vmStruct, cl1, cl2, signature, fieldSignature) != 0) {\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGVERIFYERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfieldOffset = -1;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\t\tUDATA valueOffset = fieldOffset;\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\t\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {\n\t\t\t\t\tif (fccEntryFieldNotSet) {\n\t\t\t\t\t\tflattenedClassCache = definingClass->flattenedClassCache;\n\t\t\t\t\t\tfieldIndex = findIndexInFlattenedClassCache(flattenedClassCache, nameAndSig);\n\t\t\t\t\t\tflattenableClass = J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex)->clazz;\n\t\t\t\t\t}\n\t\t\t\t\tif (J9_ARE_ALL_BITS_SET(flattenableClass->classFlags, J9ClassIsFlattened)) {\n\t\t\t\t\t\tif (fccEntryFieldNotSet) {\n\t\t\t\t\t\t\tJ9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex)->offset = valueOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodifiers |= J9FieldFlagFlattened;\n\t\t\t\t\t\tvalueOffset = (UDATA) J9_VM_FCC_ENTRY_FROM_FCC(flattenedClassCache, fieldIndex);\n\t\t\t\t\t\t/* offset must be written to flattenedClassCache before fieldref is marked as resolved */\n\t\t\t\t\t\tissueWriteBarrier();\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* Sign extend the resolved constant to make sure that it is always larger than valueOffset field */\n\t\t\t\tmodifiers |= (UDATA)(IDATA)(I_32) J9FieldFlagResolved;\n\t\t\t\tif (0 != (resolveFlags & J9_RESOLVE_FLAG_FIELD_SETTER)) {\n\t\t\t\t\tmodifiers |= J9FieldFlagPutResolved;\n\t\t\t\t}\n\t\t\t\tramCPEntry->valueOffset = valueOffset;\n\t\t\t\tramCPEntry->flags = modifiers;\n\t\t\t}\n\n\t\t\tif (resolvedField != NULL) {\n\t\t\t\t*resolvedField = field;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tTrc_VM_resolveInstanceFieldRef_Exit(vmStruct, fieldOffset);\n\treturn fieldOffset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -171,7 +171,7 @@\n \t\t\t\t}\n \t\t\t}\n \t\t\n-\t\t\tif (ramCPEntry != NULL) {\n+\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\t\t\tUDATA valueOffset = fieldOffset;\n #if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n \t\t\t\tif ('Q' == J9UTF8_DATA(signature)[0]) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (ramCPEntry != NULL) {"
            ],
            "added_lines": [
                "\t\t\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveClassRef",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "J9Class *   \nresolveClassRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tJ9ClassLoader *bootstrapClassLoader = vm->systemClassLoader;\n\tJ9Class *currentClass = NULL;\n\tJ9RAMClassRef *ramClassRefWrapper = NULL;\n\tJ9Class *resolvedClass = NULL;\n\tJ9Class *accessClass = NULL;\n\tJ9UTF8 *classNameWrapper = NULL;\n\tU_16 classNameLength = 0;\n\tU_8 *classNameData = NULL;\n\tJ9ROMStringRef *romStringRef = NULL;\n\tJ9ClassLoader *classLoader = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\tUDATA findClassFlags = 0;\n\tUDATA accessModifiers = 0;\n\tj9object_t detailString = NULL;\n\tTrc_VM_resolveClassRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tramClassRefWrapper = (J9RAMClassRef *)&ramCP[cpIndex];\n\tresolvedClass = ramClassRefWrapper->value;\n\t/* If resolving for \"new\", check if the class is instantiable */\n\tif ((NULL != resolvedClass) && (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INSTANTIABLE) || J9ROMCLASS_ALLOCATES_VIA_NEW(resolvedClass->romClass))) {\n\t\t/* ensure that the caller can safely read the modifiers field if it so desires */\n\t\tissueReadBarrier();\n\t\tgoto done;\n\t}\n\n\tromStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex];\n\tclassNameWrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef);\n\tclassNameLength = J9UTF8_LENGTH(classNameWrapper);\n\tclassNameData = J9UTF8_DATA(classNameWrapper);\n\n\tcurrentClass = J9_CLASS_FROM_CP(ramCP);\n\tclassLoader = currentClass->classLoader;\n\tif (NULL == classLoader) {\n\t\tclassLoader = bootstrapClassLoader;\n\t}\n\n\tTrc_VM_resolveClassRef_lookup(vmStruct, classNameLength, classNameData);\n\n\tif (canRunJavaCode) {\n\t\tif (throwException) {\n\t\t\tfindClassFlags = J9_FINDCLASS_FLAG_THROW_ON_FAIL;\n\t\t}\n\t} else {\n\t\tfindClassFlags = J9_FINDCLASS_FLAG_EXISTING_ONLY;\n\t}\n\n\tif (ramClassRefWrapper->modifiers == (UDATA)-1) {\n\t\tif ((findClassFlags & J9_FINDCLASS_FLAG_THROW_ON_FAIL) == J9_FINDCLASS_FLAG_THROW_ON_FAIL) {\n\t\t\tdetailString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, classNameData, classNameLength, 0);\n\t\t\tif (throwException) {\n\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNOCLASSDEFFOUNDERROR, (UDATA *)detailString);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\tif ((';' == *(char *)(classNameData + (classNameLength - 1)))\n\t\t&& ('Q' == *(char *)classNameData)\n\t) {\n\t\t/* we are dealing with signature envelope, extract the name from it */\n\t\tclassNameData += 1;\n\t\tclassNameLength -= 2;\n\t}\n#endif /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n\n\tresolvedClass = internalFindClassUTF8(vmStruct, classNameData, classNameLength,\n\t\t\tclassLoader, findClassFlags);\n\n\t/* Check for frame pop before permanently invalidating the CP entry */\n\tif (J9_ARE_ANY_BITS_SET(vmStruct->publicFlags, J9_PUBLIC_FLAGS_POP_FRAMES_INTERRUPT)) {\n\t\tgoto bail;\n\t}\n\n\tif (NULL == resolvedClass) {\n\t\tj9object_t exception = vmStruct->currentException;\n\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */\n\t\tif (NULL != exception) {\n\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {\n\t\t\t\tramClassRefWrapper->modifiers = -1;\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* Perform a package access check from the current class to the resolved class.\n\t * No check is required if any of the following is true:\n\t * \t\t- the current class and resolved class are identical\n\t * \t\t- the current class was loaded by the bootstrap class loader\n\t * \t\t- the current class and resolved class are in same module\n\t */\n\tif ((currentClass != resolvedClass) \n\t\t&& (classLoader != bootstrapClassLoader)\n\t\t&& requirePackageAccessCheck(vm, classLoader, currentClass->module, resolvedClass)\n\t) {\n\t\t/* AOT resolves class refs inside J9Classes which have not yet\n\t\t * had the java/lang/Class associated with them.  canRunJavaCode must be false\n\t\t * in this case.  The protectionDomain object is only used if canRunJavaCode\n\t\t * is true, so don't bother fetching it in the false case.\n\t\t */\n\t\tj9object_t protectionDomain = NULL;\n\t\tif (canRunJavaCode) {\n\t\t\tj9object_t classObject = J9VM_J9CLASS_TO_HEAPCLASS(currentClass);\n\t\t\tAssert_VM_notNull(classObject);\n\t\t\tprotectionDomain = J9VMJAVALANGCLASS_PROTECTIONDOMAIN(vmStruct, classObject);\n\t\t}\n\t\tif (!packageAccessIsLegal(vmStruct, resolvedClass, protectionDomain, canRunJavaCode)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (jitCompileTimeResolve) {\n\t\tif (J9_ARE_NO_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n\t\t\tif (J9ClassInitSucceeded != resolvedClass->initializeStatus) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check access permissions */\n\taccessModifiers = resolvedClass->romClass->modifiers;\n\tif (J9ROMCLASS_IS_ARRAY(resolvedClass->romClass)) {\n\t\taccessClass = ((J9ArrayClass *)resolvedClass)->leafComponentType;\n\t\taccessModifiers = accessClass->romClass->modifiers;\n\t} else {\n\t\taccessClass = resolvedClass;\n\t}\n\t{\n\t\tIDATA checkResult = checkVisibility(vmStruct, J9_CLASS_FROM_CP(ramCP), accessClass, accessModifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t/* Check for pending exception for (ie. Nesthost class loading/verify), do not overwrite these exceptions */\n\t\t\tif (canRunJavaCode && (!VM_VMHelpers::exceptionPending(vmStruct))) {\n\t\t\t\tchar *errorMsg = NULL;\n\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, accessModifiers, J9_CLASS_FROM_CP(ramCP), accessClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t} else {\n\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, -1, J9_CLASS_FROM_CP(ramCP), accessClass, checkResult);\n\t\t\t\t}\n\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\tj9mem_free_memory(errorMsg);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\taccessModifiers = resolvedClass->romClass->modifiers;\n\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INSTANTIABLE)) {\n\t\tif (!J9ROMCLASS_ALLOCATES_VIA_NEW(resolvedClass->romClass)) {\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tsetCurrentException(vmStruct, J9_EX_CTOR_CLASS + J9VMCONSTANTPOOL_JAVALANGINSTANTIATIONERROR,\n\t\t\t\t\t\t(UDATA *)resolvedClass->classObject);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\t\n\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INIT_CLASS)) {\n\t\tUDATA initStatus = resolvedClass->initializeStatus;\n\t\tif ((J9ClassInitSucceeded != initStatus) && ((UDATA)vmStruct != initStatus)) {\n\t\t\tUDATA preCount = vm->hotSwapCount;\n\n\t\t\t/* No need to check for JITCompileTimeResolve, since it wouldn't have got this far\n\t\t\t * if the class weren't already initialized.\n\t\t\t */\n\t\t\tinitializeClass(vmStruct, resolvedClass);\n\t\t\tif (J9_ARE_ANY_BITS_SET(vmStruct->publicFlags, J9_PUBLIC_FLAGS_POP_FRAMES_INTERRUPT)) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (NULL != vmStruct->currentException) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (preCount != vm->hotSwapCount) {\n\t\t\t\tgoto tryAgain;\n\t\t\t}\n\t\t}\n\t}\n\n\tramClassRefWrapper->value = resolvedClass;\n\tramClassRefWrapper->modifiers = accessModifiers;\n\ndone:\n\tTrc_VM_resolveClassRef_Exit(vmStruct, resolvedClass);\n\treturn resolvedClass; \nbail:\n\tresolvedClass = NULL;\n\tgoto done;\n}",
        "func": "J9Class *   \nresolveClassRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags)\n{\n\tJ9JavaVM *vm = vmStruct->javaVM;\n\tJ9ClassLoader *bootstrapClassLoader = vm->systemClassLoader;\n\tJ9Class *currentClass = NULL;\n\tJ9RAMClassRef *ramClassRefWrapper = NULL;\n\tJ9Class *resolvedClass = NULL;\n\tJ9Class *accessClass = NULL;\n\tJ9UTF8 *classNameWrapper = NULL;\n\tU_16 classNameLength = 0;\n\tU_8 *classNameData = NULL;\n\tJ9ROMStringRef *romStringRef = NULL;\n\tJ9ClassLoader *classLoader = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\tUDATA findClassFlags = 0;\n\tUDATA accessModifiers = 0;\n\tj9object_t detailString = NULL;\n\tTrc_VM_resolveClassRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tramClassRefWrapper = (J9RAMClassRef *)&ramCP[cpIndex];\n\tresolvedClass = ramClassRefWrapper->value;\n\t/* If resolving for \"new\", check if the class is instantiable */\n\tif ((NULL != resolvedClass) && (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INSTANTIABLE) || J9ROMCLASS_ALLOCATES_VIA_NEW(resolvedClass->romClass))) {\n\t\t/* ensure that the caller can safely read the modifiers field if it so desires */\n\t\tissueReadBarrier();\n\t\tgoto done;\n\t}\n\n\tromStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex];\n\tclassNameWrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef);\n\tclassNameLength = J9UTF8_LENGTH(classNameWrapper);\n\tclassNameData = J9UTF8_DATA(classNameWrapper);\n\n\tcurrentClass = J9_CLASS_FROM_CP(ramCP);\n\tclassLoader = currentClass->classLoader;\n\tif (NULL == classLoader) {\n\t\tclassLoader = bootstrapClassLoader;\n\t}\n\n\tTrc_VM_resolveClassRef_lookup(vmStruct, classNameLength, classNameData);\n\n\tif (canRunJavaCode) {\n\t\tif (throwException) {\n\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_THROW_ON_FAIL;\n\t\t}\n\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_LOAD)) {\n\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\t\t\n\t\t}\n\t} else {\n\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\n\t}\n\n\tif (ramClassRefWrapper->modifiers == (UDATA)-1) {\n\t\tif ((findClassFlags & J9_FINDCLASS_FLAG_THROW_ON_FAIL) == J9_FINDCLASS_FLAG_THROW_ON_FAIL) {\n\t\t\tdetailString = vm->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, classNameData, classNameLength, 0);\n\t\t\tif (throwException) {\n\t\t\t\tif (NULL == vmStruct->currentException) {\n\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGNOCLASSDEFFOUNDERROR, (UDATA *)detailString);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVM_VMHelpers::clearException(vmStruct);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n#if defined(J9VM_OPT_VALHALLA_VALUE_TYPES)\n\tif ((';' == *(char *)(classNameData + (classNameLength - 1)))\n\t\t&& ('Q' == *(char *)classNameData)\n\t) {\n\t\t/* we are dealing with signature envelope, extract the name from it */\n\t\tclassNameData += 1;\n\t\tclassNameLength -= 2;\n\t}\n#endif /* defined(J9VM_OPT_VALHALLA_VALUE_TYPES) */\n\n\tresolvedClass = internalFindClassUTF8(vmStruct, classNameData, classNameLength,\n\t\t\tclassLoader, findClassFlags);\n\n\t/* Check for frame pop before permanently invalidating the CP entry */\n\tif (J9_ARE_ANY_BITS_SET(vmStruct->publicFlags, J9_PUBLIC_FLAGS_POP_FRAMES_INTERRUPT)) {\n\t\tgoto bail;\n\t}\n\n\tif (NULL == resolvedClass) {\n\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\t\tj9object_t exception = vmStruct->currentException;\n\t\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */\n\t\t\tif (NULL != exception) {\n\t\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {\n\t\t\t\t\tramClassRefWrapper->modifiers = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Perform a package access check from the current class to the resolved class.\n\t * No check is required if any of the following is true:\n\t * \t\t- the current class and resolved class are identical\n\t * \t\t- the current class was loaded by the bootstrap class loader\n\t * \t\t- the current class and resolved class are in same module\n\t */\n\tif ((currentClass != resolvedClass) \n\t\t&& (classLoader != bootstrapClassLoader)\n\t\t&& requirePackageAccessCheck(vm, classLoader, currentClass->module, resolvedClass)\n\t) {\n\t\t/* AOT resolves class refs inside J9Classes which have not yet\n\t\t * had the java/lang/Class associated with them.  canRunJavaCode must be false\n\t\t * in this case.  The protectionDomain object is only used if canRunJavaCode\n\t\t * is true, so don't bother fetching it in the false case.\n\t\t */\n\t\tj9object_t protectionDomain = NULL;\n\t\tif (canRunJavaCode) {\n\t\t\tj9object_t classObject = J9VM_J9CLASS_TO_HEAPCLASS(currentClass);\n\t\t\tAssert_VM_notNull(classObject);\n\t\t\tprotectionDomain = J9VMJAVALANGCLASS_PROTECTIONDOMAIN(vmStruct, classObject);\n\t\t}\n\t\tif (!packageAccessIsLegal(vmStruct, resolvedClass, protectionDomain, canRunJavaCode)) {\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (jitCompileTimeResolve) {\n\t\tif (J9_ARE_NO_BITS_SET(resolvedClass->romClass->modifiers, J9AccInterface)) {\n\t\t\tif (J9ClassInitSucceeded != resolvedClass->initializeStatus) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check access permissions */\n\taccessModifiers = resolvedClass->romClass->modifiers;\n\tif (J9ROMCLASS_IS_ARRAY(resolvedClass->romClass)) {\n\t\taccessClass = ((J9ArrayClass *)resolvedClass)->leafComponentType;\n\t\taccessModifiers = accessClass->romClass->modifiers;\n\t} else {\n\t\taccessClass = resolvedClass;\n\t}\n\t{\n\t\tIDATA checkResult = checkVisibility(vmStruct, J9_CLASS_FROM_CP(ramCP), accessClass, accessModifiers, lookupOptions);\n\t\tif (checkResult < J9_VISIBILITY_ALLOWED) {\n\t\t\t/* Check for pending exception for (ie. Nesthost class loading/verify), do not overwrite these exceptions */\n\t\t\tif (canRunJavaCode && (!VM_VMHelpers::exceptionPending(vmStruct))) {\n\t\t\t\tchar *errorMsg = NULL;\n\t\t\t\tPORT_ACCESS_FROM_VMC(vmStruct);\n\t\t\t\tif (J9_VISIBILITY_NON_MODULE_ACCESS_ERROR == checkResult) {\n\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, accessModifiers, J9_CLASS_FROM_CP(ramCP), accessClass, J9_VISIBILITY_NON_MODULE_ACCESS_ERROR);\n\t\t\t\t} else {\n\t\t\t\t\terrorMsg = illegalAccessMessage(vmStruct, -1, J9_CLASS_FROM_CP(ramCP), accessClass, checkResult);\n\t\t\t\t}\n\t\t\t\tsetCurrentExceptionUTF(vmStruct, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, errorMsg);\n\t\t\t\tj9mem_free_memory(errorMsg);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\taccessModifiers = resolvedClass->romClass->modifiers;\n\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INSTANTIABLE)) {\n\t\tif (!J9ROMCLASS_ALLOCATES_VIA_NEW(resolvedClass->romClass)) {\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tsetCurrentException(vmStruct, J9_EX_CTOR_CLASS + J9VMCONSTANTPOOL_JAVALANGINSTANTIATIONERROR,\n\t\t\t\t\t\t(UDATA *)resolvedClass->classObject);\n\t\t\t}\n\t\t\tgoto bail;\n\t\t}\n\t}\n\t\n\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_INIT_CLASS)) {\n\t\tUDATA initStatus = resolvedClass->initializeStatus;\n\t\tif ((J9ClassInitSucceeded != initStatus) && ((UDATA)vmStruct != initStatus)) {\n\t\t\tUDATA preCount = vm->hotSwapCount;\n\n\t\t\t/* No need to check for JITCompileTimeResolve, since it wouldn't have got this far\n\t\t\t * if the class weren't already initialized.\n\t\t\t */\n\t\t\tinitializeClass(vmStruct, resolvedClass);\n\t\t\tif (J9_ARE_ANY_BITS_SET(vmStruct->publicFlags, J9_PUBLIC_FLAGS_POP_FRAMES_INTERRUPT)) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (NULL != vmStruct->currentException) {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (preCount != vm->hotSwapCount) {\n\t\t\t\tgoto tryAgain;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramClassRefWrapper->value = resolvedClass;\n\t\tramClassRefWrapper->modifiers = accessModifiers;\n\t}\n\ndone:\n\tTrc_VM_resolveClassRef_Exit(vmStruct, resolvedClass);\n\treturn resolvedClass; \nbail:\n\tresolvedClass = NULL;\n\tgoto done;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,10 +53,13 @@\n \n \tif (canRunJavaCode) {\n \t\tif (throwException) {\n-\t\t\tfindClassFlags = J9_FINDCLASS_FLAG_THROW_ON_FAIL;\n+\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_THROW_ON_FAIL;\n+\t\t}\n+\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_LOAD)) {\n+\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\t\t\n \t\t}\n \t} else {\n-\t\tfindClassFlags = J9_FINDCLASS_FLAG_EXISTING_ONLY;\n+\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\n \t}\n \n \tif (ramClassRefWrapper->modifiers == (UDATA)-1) {\n@@ -92,14 +95,16 @@\n \t}\n \n \tif (NULL == resolvedClass) {\n-\t\tj9object_t exception = vmStruct->currentException;\n-\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */\n-\t\tif (NULL != exception) {\n-\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {\n-\t\t\t\tramClassRefWrapper->modifiers = -1;\n-\t\t\t}\n-\t\t}\n-\t\tgoto done;\n+\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n+\t\t\tj9object_t exception = vmStruct->currentException;\n+\t\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */\n+\t\t\tif (NULL != exception) {\n+\t\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {\n+\t\t\t\t\tramClassRefWrapper->modifiers = -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tgoto done;\n+\t\t}\n \t}\n \n \t/* Perform a package access check from the current class to the resolved class.\n@@ -195,8 +200,10 @@\n \t\t}\n \t}\n \n-\tramClassRefWrapper->value = resolvedClass;\n-\tramClassRefWrapper->modifiers = accessModifiers;\n+\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n+\t\tramClassRefWrapper->value = resolvedClass;\n+\t\tramClassRefWrapper->modifiers = accessModifiers;\n+\t}\n \n done:\n \tTrc_VM_resolveClassRef_Exit(vmStruct, resolvedClass);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tfindClassFlags = J9_FINDCLASS_FLAG_THROW_ON_FAIL;",
                "\t\tfindClassFlags = J9_FINDCLASS_FLAG_EXISTING_ONLY;",
                "\t\tj9object_t exception = vmStruct->currentException;",
                "\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */",
                "\t\tif (NULL != exception) {",
                "\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {",
                "\t\t\t\tramClassRefWrapper->modifiers = -1;",
                "\t\t\t}",
                "\t\t}",
                "\t\tgoto done;",
                "\tramClassRefWrapper->value = resolvedClass;",
                "\tramClassRefWrapper->modifiers = accessModifiers;"
            ],
            "added_lines": [
                "\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_THROW_ON_FAIL;",
                "\t\t}",
                "\t\tif (J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_LOAD)) {",
                "\t\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;\t\t",
                "\t\tfindClassFlags |= J9_FINDCLASS_FLAG_EXISTING_ONLY;",
                "\t\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {",
                "\t\t\tj9object_t exception = vmStruct->currentException;",
                "\t\t\t/* Class not found - if NoClassDefFoundError was thrown, mark this ref as permanently unresolveable */",
                "\t\t\tif (NULL != exception) {",
                "\t\t\t\tif (instanceOfOrCheckCast(J9OBJECT_CLAZZ(vmStruct, exception), J9VMJAVALANGLINKAGEERROR_OR_NULL(vm))) {",
                "\t\t\t\t\tramClassRefWrapper->modifiers = -1;",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t\tgoto done;",
                "\t\t}",
                "\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {",
                "\t\tramClassRefWrapper->value = resolvedClass;",
                "\t\tramClassRefWrapper->modifiers = accessModifiers;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28167",
        "func_name": "eclipse-openj9/openj9/resolveSpecialMethodRefInto",
        "description": "In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/840f3af31a5b8d2d395d9367c826ed756e380fb9",
        "commit_title": "Correctly load/initialize classes when using ConstantPool",
        "commit_text": " - do not load classes in the \"ifLoaded\" calls - never intitialize classes in the natives - do not update the constant pool when querying from the natives   [ci skip] ",
        "func_before": "J9Method *   \nresolveSpecialMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMSpecialMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Class *currentClass;\n\tJ9ROMNameAndSignature *nameAndSig;\n\tJ9Method *method = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveSpecialMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\n\t/* Find the targetted method. */\n\tcurrentClass = J9_CLASS_FROM_CP(ramCP);\n\t/* Obtain the most recent class version. ramCP->class might be pointing at an old\n\t * class version after a possible HCR in the resolveClassRef above. Reaching for vtable slots in\n\t * the old version will cause bogosity as they are never initialized by fastHCR */\n\tcurrentClass = J9_CURRENT_CLASS(currentClass);\n\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\n\t/* REASON FOR THE J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS:\n\t * Virtual invocation modes may still find a method in the receiver's vtable that resolves the default method conflict.\n\t * If not, the method in the vtable will be a special method for throwing the exception.\n\t *\n\t * Special invocations (defender supersends) will not look at the receiver's vtable, but instead invoke the result of javaLookupMethod.\n\t * Default method conflicts must therefore be handled by the lookup code.\n\t */\n\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) != J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t}\n\n\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t/* This check is only required in Java9 and there have been applications that\n\t\t * fail when this check is enabled on Java8.\n\t\t */\n\t\tif (currentClass != NULL) {\n\t\t\tif ((resolvedClass->romClass != NULL) && (currentClass->romClass != NULL)) {\n\t\t\t\t/* Ensure the cpType is taken from the original class.  The cpIndex\n\t\t\t\t * and J9Class must match, even if a redefinition occurs, or the\n\t\t\t\t * check may incorrectly fail.\n\t\t\t\t */\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramCP)->romClass), cpIndex);\n\t\t\t\tif (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface)) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\nincompat:\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, currentClass, lookupOptions);\n\t\n\tTrc_VM_resolveSpecialMethodRef_lookupMethod(vmStruct, method);\n\t\n\tif (method == NULL) {\n\t\tgoto done;\n\t} else {\n\t\t/* JVMS 4.9.2: If resolvedClass is an interface, ensure that it is a DIRECT superinterface\n\t\t * of currentClass (or resolvedClass == currentClass).\n\t\t */\n\t\tif (!isDirectSuperInterface(vmStruct, resolvedClass, currentClass)) {\n\t\t\tif (throwException) {\n\t\t\t\tsetIncompatibleClassChangeErrorInvalidDefenderSupersend(vmStruct, resolvedClass, currentClass);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Select the correct method for invocation - ignore visibility in the super send case */\n\tmethod = getMethodForSpecialSend(vmStruct, currentClass, resolvedClass, method, lookupOptions | J9_LOOK_NO_VISIBILITY_CHECK | J9_LOOK_IGNORE_INCOMPATIBLE_METHODS);\n\tif (NULL == method) {\n\t\tgoto done;\n\t}\n\n\tif (NULL != ramCPEntry) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveSpecialMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "func": "J9Method *   \nresolveSpecialMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMSpecialMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Class *currentClass;\n\tJ9ROMNameAndSignature *nameAndSig;\n\tJ9Method *method = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveSpecialMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\t\n\t/* If resolvedClass is NULL, the exception has already been set. */\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\n\t/* Find the targetted method. */\n\tcurrentClass = J9_CLASS_FROM_CP(ramCP);\n\t/* Obtain the most recent class version. ramCP->class might be pointing at an old\n\t * class version after a possible HCR in the resolveClassRef above. Reaching for vtable slots in\n\t * the old version will cause bogosity as they are never initialized by fastHCR */\n\tcurrentClass = J9_CURRENT_CLASS(currentClass);\n\tnameAndSig = J9ROMFIELDREF_NAMEANDSIGNATURE(romMethodRef);\n\n\t/* REASON FOR THE J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS:\n\t * Virtual invocation modes may still find a method in the receiver's vtable that resolves the default method conflict.\n\t * If not, the method in the vtable will be a special method for throwing the exception.\n\t *\n\t * Special invocations (defender supersends) will not look at the receiver's vtable, but instead invoke the result of javaLookupMethod.\n\t * Default method conflicts must therefore be handled by the lookup code.\n\t */\n\tlookupOptions |= (J9_LOOK_VIRTUAL | J9_LOOK_ALLOW_FWD | J9_LOOK_HANDLE_DEFAULT_METHOD_CONFLICTS);\n\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) != J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\t}\n\n\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t/* This check is only required in Java9 and there have been applications that\n\t\t * fail when this check is enabled on Java8.\n\t\t */\n\t\tif (currentClass != NULL) {\n\t\t\tif ((resolvedClass->romClass != NULL) && (currentClass->romClass != NULL)) {\n\t\t\t\t/* Ensure the cpType is taken from the original class.  The cpIndex\n\t\t\t\t * and J9Class must match, even if a redefinition occurs, or the\n\t\t\t\t * check may incorrectly fail.\n\t\t\t\t */\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(J9_CLASS_FROM_CP(ramCP)->romClass), cpIndex);\n\t\t\t\tif (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface)) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\nincompat:\n\t\t\t\t\t\tif (throwException) {\n\t\t\t\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, currentClass, lookupOptions);\n\t\n\tTrc_VM_resolveSpecialMethodRef_lookupMethod(vmStruct, method);\n\t\n\tif (method == NULL) {\n\t\tgoto done;\n\t} else {\n\t\t/* JVMS 4.9.2: If resolvedClass is an interface, ensure that it is a DIRECT superinterface\n\t\t * of currentClass (or resolvedClass == currentClass).\n\t\t */\n\t\tif (!isDirectSuperInterface(vmStruct, resolvedClass, currentClass)) {\n\t\t\tif (throwException) {\n\t\t\t\tsetIncompatibleClassChangeErrorInvalidDefenderSupersend(vmStruct, resolvedClass, currentClass);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Select the correct method for invocation - ignore visibility in the super send case */\n\tmethod = getMethodForSpecialSend(vmStruct, currentClass, resolvedClass, method, lookupOptions | J9_LOOK_NO_VISIBILITY_CHECK | J9_LOOK_IGNORE_INCOMPATIBLE_METHODS);\n\tif (NULL == method) {\n\t\tgoto done;\n\t}\n\n\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveSpecialMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -112,7 +112,7 @@\n \t\tgoto done;\n \t}\n \n-\tif (NULL != ramCPEntry) {\n+\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n \t\tramCPEntry->method = method;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (NULL != ramCPEntry) {"
            ],
            "added_lines": [
                "\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22898",
        "func_name": "curl/suboption",
        "description": "curl 7.7 through 7.76.1 suffers from an information disclosure when the `-t` command line option, known as `CURLOPT_TELNETOPTIONS` in libcurl, is used to send variable=content pairs to TELNET servers. Due to a flaw in the option parser for sending NEW_ENV variables, libcurl could be made to pass on uninitialized data from a stack based buffer to the server, resulting in potentially revealing sensitive internal information to the server using a clear-text network protocol.",
        "git_url": "https://github.com/curl/curl/commit/39ce47f219b09c380b81f89fe54ac586c8db6bde",
        "commit_title": "telnet: check sscanf() for correct number of matches",
        "commit_text": " CVE-2021-22898  Bug: https://curl.se/docs/CVE-2021-22898.html",
        "func_before": "static void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = \"\";\n  char varval[128] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn->subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn->subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn->telnet_vars; v; v = v->next) {\n        size_t tmplen = (strlen(v->data) + 1);\n        /* Add the variable only if it fits */\n        if(len + tmplen < (int)sizeof(temp)-6) {\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {\n            msnprintf((char *)&temp[len], sizeof(temp) - len,\n                      \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&temp[len], sizeof(temp) - len,\n                \"%c%c\", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n  }\n  return;\n}",
        "func": "static void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = \"\";\n  char varval[128] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn->subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn->subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                \"%c%c%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn->telnet_vars; v; v = v->next) {\n        size_t tmplen = (strlen(v->data) + 1);\n        /* Add the variable only if it fits */\n        if(len + tmplen < (int)sizeof(temp)-6) {\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2) {\n            msnprintf((char *)&temp[len], sizeof(temp) - len,\n                      \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&temp[len], sizeof(temp) - len,\n                \"%c%c\", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"Sending data failed (%d)\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n  }\n  return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,7 +46,7 @@\n         size_t tmplen = (strlen(v->data) + 1);\n         /* Add the variable only if it fits */\n         if(len + tmplen < (int)sizeof(temp)-6) {\n-          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {\n+          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2) {\n             msnprintf((char *)&temp[len], sizeof(temp) - len,\n                       \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                       CURL_NEW_ENV_VALUE, varval);",
        "diff_line_info": {
            "deleted_lines": [
                "          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {"
            ],
            "added_lines": [
                "          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-34693",
        "func_name": "torvalds/linux/bcm_rx_changed",
        "description": "net/can/bcm.c in the Linux kernel through 5.12.10 allows local users to obtain sensitive information from kernel stack memory because parts of a data structure are uninitialized.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=5e87ddbe3942e27e939bdc02deb8579b0cbd8ecc",
        "commit_title": "On 64-bit systems, struct bcm_msg_head has an added padding of 4 bytes between",
        "commit_text": "struct members count and ival1. Even though all struct members are initialized, the 4-byte hole will contain data from the kernel stack. This patch zeroes out struct bcm_msg_head before usage, preventing infoleaks to userspace.  Link: https://lore.kernel.org/r/trinity-7c1b2e82-e34f-4885-8060-2cd7a13769ce-1623532166177@3c-app-gmx-bs52 Cc: linux-stable <stable@vger.kernel.org> ",
        "func_before": "static void bcm_rx_changed(struct bcm_op *op, struct canfd_frame *data)\n{\n\tstruct bcm_msg_head head;\n\n\t/* update statistics */\n\top->frames_filtered++;\n\n\t/* prevent statistics overflow */\n\tif (op->frames_filtered > ULONG_MAX/100)\n\t\top->frames_filtered = op->frames_abs = 0;\n\n\t/* this element is not throttled anymore */\n\tdata->flags &= (BCM_CAN_FLAGS_MASK|RX_RECV);\n\n\thead.opcode  = RX_CHANGED;\n\thead.flags   = op->flags;\n\thead.count   = op->count;\n\thead.ival1   = op->ival1;\n\thead.ival2   = op->ival2;\n\thead.can_id  = op->can_id;\n\thead.nframes = 1;\n\n\tbcm_send_to_user(op, &head, data, 1);\n}",
        "func": "static void bcm_rx_changed(struct bcm_op *op, struct canfd_frame *data)\n{\n\tstruct bcm_msg_head head;\n\n\t/* update statistics */\n\top->frames_filtered++;\n\n\t/* prevent statistics overflow */\n\tif (op->frames_filtered > ULONG_MAX/100)\n\t\top->frames_filtered = op->frames_abs = 0;\n\n\t/* this element is not throttled anymore */\n\tdata->flags &= (BCM_CAN_FLAGS_MASK|RX_RECV);\n\n\tmemset(&head, 0, sizeof(head));\n\thead.opcode  = RX_CHANGED;\n\thead.flags   = op->flags;\n\thead.count   = op->count;\n\thead.ival1   = op->ival1;\n\thead.ival2   = op->ival2;\n\thead.can_id  = op->can_id;\n\thead.nframes = 1;\n\n\tbcm_send_to_user(op, &head, data, 1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n \t/* this element is not throttled anymore */\n \tdata->flags &= (BCM_CAN_FLAGS_MASK|RX_RECV);\n \n+\tmemset(&head, 0, sizeof(head));\n \thead.opcode  = RX_CHANGED;\n \thead.flags   = op->flags;\n \thead.count   = op->count;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tmemset(&head, 0, sizeof(head));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-34693",
        "func_name": "torvalds/linux/bcm_rx_timeout_handler",
        "description": "net/can/bcm.c in the Linux kernel through 5.12.10 allows local users to obtain sensitive information from kernel stack memory because parts of a data structure are uninitialized.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=5e87ddbe3942e27e939bdc02deb8579b0cbd8ecc",
        "commit_title": "On 64-bit systems, struct bcm_msg_head has an added padding of 4 bytes between",
        "commit_text": "struct members count and ival1. Even though all struct members are initialized, the 4-byte hole will contain data from the kernel stack. This patch zeroes out struct bcm_msg_head before usage, preventing infoleaks to userspace.  Link: https://lore.kernel.org/r/trinity-7c1b2e82-e34f-4885-8060-2cd7a13769ce-1623532166177@3c-app-gmx-bs52 Cc: linux-stable <stable@vger.kernel.org> ",
        "func_before": "static enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\t/* if user wants to be informed, when cyclic CAN-Messages come back */\n\tif ((op->flags & RX_ANNOUNCE_RESUME) && op->last_frames) {\n\t\t/* clear received CAN frames to indicate 'nothing received' */\n\t\tmemset(op->last_frames, 0, op->nframes * op->cfsiz);\n\t}\n\n\t/* create notification to user */\n\tmsg_head.opcode  = RX_TIMEOUT;\n\tmsg_head.flags   = op->flags;\n\tmsg_head.count   = op->count;\n\tmsg_head.ival1   = op->ival1;\n\tmsg_head.ival2   = op->ival2;\n\tmsg_head.can_id  = op->can_id;\n\tmsg_head.nframes = 0;\n\n\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\n\treturn HRTIMER_NORESTART;\n}",
        "func": "static enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\t/* if user wants to be informed, when cyclic CAN-Messages come back */\n\tif ((op->flags & RX_ANNOUNCE_RESUME) && op->last_frames) {\n\t\t/* clear received CAN frames to indicate 'nothing received' */\n\t\tmemset(op->last_frames, 0, op->nframes * op->cfsiz);\n\t}\n\n\t/* create notification to user */\n\tmemset(&msg_head, 0, sizeof(msg_head));\n\tmsg_head.opcode  = RX_TIMEOUT;\n\tmsg_head.flags   = op->flags;\n\tmsg_head.count   = op->count;\n\tmsg_head.ival1   = op->ival1;\n\tmsg_head.ival2   = op->ival2;\n\tmsg_head.can_id  = op->can_id;\n\tmsg_head.nframes = 0;\n\n\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\n\treturn HRTIMER_NORESTART;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n \t}\n \n \t/* create notification to user */\n+\tmemset(&msg_head, 0, sizeof(msg_head));\n \tmsg_head.opcode  = RX_TIMEOUT;\n \tmsg_head.flags   = op->flags;\n \tmsg_head.count   = op->count;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tmemset(&msg_head, 0, sizeof(msg_head));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-34693",
        "func_name": "torvalds/linux/bcm_tx_timeout_handler",
        "description": "net/can/bcm.c in the Linux kernel through 5.12.10 allows local users to obtain sensitive information from kernel stack memory because parts of a data structure are uninitialized.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=5e87ddbe3942e27e939bdc02deb8579b0cbd8ecc",
        "commit_title": "On 64-bit systems, struct bcm_msg_head has an added padding of 4 bytes between",
        "commit_text": "struct members count and ival1. Even though all struct members are initialized, the 4-byte hole will contain data from the kernel stack. This patch zeroes out struct bcm_msg_head before usage, preventing infoleaks to userspace.  Link: https://lore.kernel.org/r/trinity-7c1b2e82-e34f-4885-8060-2cd7a13769ce-1623532166177@3c-app-gmx-bs52 Cc: linux-stable <stable@vger.kernel.org> ",
        "func_before": "static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\tif (op->kt_ival1 && (op->count > 0)) {\n\t\top->count--;\n\t\tif (!op->count && (op->flags & TX_COUNTEVT)) {\n\n\t\t\t/* create notification to user */\n\t\t\tmsg_head.opcode  = TX_EXPIRED;\n\t\t\tmsg_head.flags   = op->flags;\n\t\t\tmsg_head.count   = op->count;\n\t\t\tmsg_head.ival1   = op->ival1;\n\t\t\tmsg_head.ival2   = op->ival2;\n\t\t\tmsg_head.can_id  = op->can_id;\n\t\t\tmsg_head.nframes = 0;\n\n\t\t\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\t\t}\n\t\tbcm_can_tx(op);\n\n\t} else if (op->kt_ival2) {\n\t\tbcm_can_tx(op);\n\t}\n\n\treturn bcm_tx_set_expiry(op, &op->timer) ?\n\t\tHRTIMER_RESTART : HRTIMER_NORESTART;\n}",
        "func": "static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)\n{\n\tstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\n\tstruct bcm_msg_head msg_head;\n\n\tif (op->kt_ival1 && (op->count > 0)) {\n\t\top->count--;\n\t\tif (!op->count && (op->flags & TX_COUNTEVT)) {\n\n\t\t\t/* create notification to user */\n\t\t\tmemset(&msg_head, 0, sizeof(msg_head));\n\t\t\tmsg_head.opcode  = TX_EXPIRED;\n\t\t\tmsg_head.flags   = op->flags;\n\t\t\tmsg_head.count   = op->count;\n\t\t\tmsg_head.ival1   = op->ival1;\n\t\t\tmsg_head.ival2   = op->ival2;\n\t\t\tmsg_head.can_id  = op->can_id;\n\t\t\tmsg_head.nframes = 0;\n\n\t\t\tbcm_send_to_user(op, &msg_head, NULL, 0);\n\t\t}\n\t\tbcm_can_tx(op);\n\n\t} else if (op->kt_ival2) {\n\t\tbcm_can_tx(op);\n\t}\n\n\treturn bcm_tx_set_expiry(op, &op->timer) ?\n\t\tHRTIMER_RESTART : HRTIMER_NORESTART;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n \t\tif (!op->count && (op->flags & TX_COUNTEVT)) {\n \n \t\t\t/* create notification to user */\n+\t\t\tmemset(&msg_head, 0, sizeof(msg_head));\n \t\t\tmsg_head.opcode  = TX_EXPIRED;\n \t\t\tmsg_head.flags   = op->flags;\n \t\t\tmsg_head.count   = op->count;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tmemset(&msg_head, 0, sizeof(msg_head));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19534",
        "func_name": "torvalds/linux/peak_usb_create_dev",
        "description": "In the Linux kernel before 5.3.11, there is an info-leak bug that can be caused by a malicious USB device in the drivers/net/can/usb/peak_usb/pcan_usb_core.c driver, aka CID-f7a1337f0d29.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f7a1337f0d29b98733c8824e165fca3371d7d4fd",
        "commit_title": "Fix a small slab info leak due to a failure to clear the command buffer",
        "commit_text": "at allocation.  The first 16 bytes of the command buffer are always sent to the device in pcan_usb_send_cmd() even though only the first two may have been initialised in case no argument payload is provided (e.g. when waiting for a response).  Cc: stable <stable@vger.kernel.org>     # 3.4 ",
        "func_before": "static int peak_usb_create_dev(const struct peak_usb_adapter *peak_usb_adapter,\n\t\t\t       struct usb_interface *intf, int ctrl_idx)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tint sizeof_candev = peak_usb_adapter->sizeof_dev_private;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tint i, err;\n\tu16 tmp16;\n\n\tif (sizeof_candev < sizeof(struct peak_usb_device))\n\t\tsizeof_candev = sizeof(struct peak_usb_device);\n\n\tnetdev = alloc_candev(sizeof_candev, PCAN_USB_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"%s: couldn't alloc candev\\n\",\n\t\t\tPCAN_USB_DRIVER_NAME);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\t/* allocate a buffer large enough to send commands */\n\tdev->cmd_buf = kmalloc(PCAN_USB_MAX_CMD_LEN, GFP_KERNEL);\n\tif (!dev->cmd_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto lbl_free_candev;\n\t}\n\n\tdev->udev = usb_dev;\n\tdev->netdev = netdev;\n\tdev->adapter = peak_usb_adapter;\n\tdev->ctrl_idx = ctrl_idx;\n\tdev->state = PCAN_USB_STATE_CONNECTED;\n\n\tdev->ep_msg_in = peak_usb_adapter->ep_msg_in;\n\tdev->ep_msg_out = peak_usb_adapter->ep_msg_out[ctrl_idx];\n\n\tdev->can.clock = peak_usb_adapter->clock;\n\tdev->can.bittiming_const = peak_usb_adapter->bittiming_const;\n\tdev->can.do_set_bittiming = peak_usb_set_bittiming;\n\tdev->can.data_bittiming_const = peak_usb_adapter->data_bittiming_const;\n\tdev->can.do_set_data_bittiming = peak_usb_set_data_bittiming;\n\tdev->can.do_set_mode = peak_usb_set_mode;\n\tdev->can.do_get_berr_counter = peak_usb_adapter->do_get_berr_counter;\n\tdev->can.ctrlmode_supported = peak_usb_adapter->ctrlmode_supported;\n\n\tnetdev->netdev_ops = &peak_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\tfor (i = 0; i < PCAN_USB_MAX_TX_URBS; i++)\n\t\tdev->tx_contexts[i].echo_index = PCAN_USB_MAX_TX_URBS;\n\n\tdev->prev_siblings = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, dev);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tnetdev->dev_id = ctrl_idx;\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tdev_err(&intf->dev, \"couldn't register CAN device: %d\\n\", err);\n\t\tgoto lbl_restore_intf_data;\n\t}\n\n\tif (dev->prev_siblings)\n\t\t(dev->prev_siblings)->next_siblings = dev;\n\n\t/* keep hw revision into the netdevice */\n\ttmp16 = le16_to_cpu(usb_dev->descriptor.bcdDevice);\n\tdev->device_rev = tmp16 >> 8;\n\n\tif (dev->adapter->dev_init) {\n\t\terr = dev->adapter->dev_init(dev);\n\t\tif (err)\n\t\t\tgoto lbl_unregister_candev;\n\t}\n\n\t/* set bus off */\n\tif (dev->adapter->dev_set_bus) {\n\t\terr = dev->adapter->dev_set_bus(dev, 0);\n\t\tif (err)\n\t\t\tgoto lbl_unregister_candev;\n\t}\n\n\t/* get device number early */\n\tif (dev->adapter->dev_get_device_id)\n\t\tdev->adapter->dev_get_device_id(dev, &dev->device_number);\n\n\tnetdev_info(netdev, \"attached to %s channel %u (device %u)\\n\",\n\t\t\tpeak_usb_adapter->name, ctrl_idx, dev->device_number);\n\n\treturn 0;\n\nlbl_unregister_candev:\n\tunregister_candev(netdev);\n\nlbl_restore_intf_data:\n\tusb_set_intfdata(intf, dev->prev_siblings);\n\tkfree(dev->cmd_buf);\n\nlbl_free_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n}",
        "func": "static int peak_usb_create_dev(const struct peak_usb_adapter *peak_usb_adapter,\n\t\t\t       struct usb_interface *intf, int ctrl_idx)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tint sizeof_candev = peak_usb_adapter->sizeof_dev_private;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tint i, err;\n\tu16 tmp16;\n\n\tif (sizeof_candev < sizeof(struct peak_usb_device))\n\t\tsizeof_candev = sizeof(struct peak_usb_device);\n\n\tnetdev = alloc_candev(sizeof_candev, PCAN_USB_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"%s: couldn't alloc candev\\n\",\n\t\t\tPCAN_USB_DRIVER_NAME);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\t/* allocate a buffer large enough to send commands */\n\tdev->cmd_buf = kzalloc(PCAN_USB_MAX_CMD_LEN, GFP_KERNEL);\n\tif (!dev->cmd_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto lbl_free_candev;\n\t}\n\n\tdev->udev = usb_dev;\n\tdev->netdev = netdev;\n\tdev->adapter = peak_usb_adapter;\n\tdev->ctrl_idx = ctrl_idx;\n\tdev->state = PCAN_USB_STATE_CONNECTED;\n\n\tdev->ep_msg_in = peak_usb_adapter->ep_msg_in;\n\tdev->ep_msg_out = peak_usb_adapter->ep_msg_out[ctrl_idx];\n\n\tdev->can.clock = peak_usb_adapter->clock;\n\tdev->can.bittiming_const = peak_usb_adapter->bittiming_const;\n\tdev->can.do_set_bittiming = peak_usb_set_bittiming;\n\tdev->can.data_bittiming_const = peak_usb_adapter->data_bittiming_const;\n\tdev->can.do_set_data_bittiming = peak_usb_set_data_bittiming;\n\tdev->can.do_set_mode = peak_usb_set_mode;\n\tdev->can.do_get_berr_counter = peak_usb_adapter->do_get_berr_counter;\n\tdev->can.ctrlmode_supported = peak_usb_adapter->ctrlmode_supported;\n\n\tnetdev->netdev_ops = &peak_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\tfor (i = 0; i < PCAN_USB_MAX_TX_URBS; i++)\n\t\tdev->tx_contexts[i].echo_index = PCAN_USB_MAX_TX_URBS;\n\n\tdev->prev_siblings = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, dev);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tnetdev->dev_id = ctrl_idx;\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tdev_err(&intf->dev, \"couldn't register CAN device: %d\\n\", err);\n\t\tgoto lbl_restore_intf_data;\n\t}\n\n\tif (dev->prev_siblings)\n\t\t(dev->prev_siblings)->next_siblings = dev;\n\n\t/* keep hw revision into the netdevice */\n\ttmp16 = le16_to_cpu(usb_dev->descriptor.bcdDevice);\n\tdev->device_rev = tmp16 >> 8;\n\n\tif (dev->adapter->dev_init) {\n\t\terr = dev->adapter->dev_init(dev);\n\t\tif (err)\n\t\t\tgoto lbl_unregister_candev;\n\t}\n\n\t/* set bus off */\n\tif (dev->adapter->dev_set_bus) {\n\t\terr = dev->adapter->dev_set_bus(dev, 0);\n\t\tif (err)\n\t\t\tgoto lbl_unregister_candev;\n\t}\n\n\t/* get device number early */\n\tif (dev->adapter->dev_get_device_id)\n\t\tdev->adapter->dev_get_device_id(dev, &dev->device_number);\n\n\tnetdev_info(netdev, \"attached to %s channel %u (device %u)\\n\",\n\t\t\tpeak_usb_adapter->name, ctrl_idx, dev->device_number);\n\n\treturn 0;\n\nlbl_unregister_candev:\n\tunregister_candev(netdev);\n\nlbl_restore_intf_data:\n\tusb_set_intfdata(intf, dev->prev_siblings);\n\tkfree(dev->cmd_buf);\n\nlbl_free_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n \tdev = netdev_priv(netdev);\n \n \t/* allocate a buffer large enough to send commands */\n-\tdev->cmd_buf = kmalloc(PCAN_USB_MAX_CMD_LEN, GFP_KERNEL);\n+\tdev->cmd_buf = kzalloc(PCAN_USB_MAX_CMD_LEN, GFP_KERNEL);\n \tif (!dev->cmd_buf) {\n \t\terr = -ENOMEM;\n \t\tgoto lbl_free_candev;",
        "diff_line_info": {
            "deleted_lines": [
                "\tdev->cmd_buf = kmalloc(PCAN_USB_MAX_CMD_LEN, GFP_KERNEL);"
            ],
            "added_lines": [
                "\tdev->cmd_buf = kzalloc(PCAN_USB_MAX_CMD_LEN, GFP_KERNEL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19535",
        "func_name": "torvalds/linux/pcan_usb_fd_init",
        "description": "In the Linux kernel before 5.2.9, there is an info-leak bug that can be caused by a malicious USB device in the drivers/net/can/usb/peak_usb/pcan_usb_fd.c driver, aka CID-30a8beeb3042.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=30a8beeb3042f49d0537b7050fd21b490166a3d9",
        "commit_title": "Uninitialized Kernel memory can leak to USB devices.",
        "commit_text": " Fix by using kzalloc() instead of kmalloc() on the affected buffers.  Cc: linux-stable <stable@vger.kernel.org> ",
        "func_before": "static int pcan_usb_fd_init(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\tint i, err = -ENOMEM;\n\n\t/* do this for 1st channel only */\n\tif (!dev->prev_siblings) {\n\t\t/* allocate netdevices common structure attached to first one */\n\t\tpdev->usb_if = kzalloc(sizeof(*pdev->usb_if), GFP_KERNEL);\n\t\tif (!pdev->usb_if)\n\t\t\tgoto err_out;\n\n\t\t/* allocate command buffer once for all for the interface */\n\t\tpdev->cmd_buffer_addr = kmalloc(PCAN_UFD_CMD_BUFFER_SIZE,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!pdev->cmd_buffer_addr)\n\t\t\tgoto err_out_1;\n\n\t\t/* number of ts msgs to ignore before taking one into account */\n\t\tpdev->usb_if->cm_ignore_count = 5;\n\n\t\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_INFO,\n\t\t\t\t\t    PCAN_USBPRO_INFO_FW,\n\t\t\t\t\t    &pdev->usb_if->fw_info,\n\t\t\t\t\t    sizeof(pdev->usb_if->fw_info));\n\t\tif (err) {\n\t\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\t\"unable to read %s firmware info (err %d)\\n\",\n\t\t\t\tdev->adapter->name, err);\n\t\t\tgoto err_out_2;\n\t\t}\n\n\t\t/* explicit use of dev_xxx() instead of netdev_xxx() here:\n\t\t * information displayed are related to the device itself, not\n\t\t * to the canx (channel) device.\n\t\t */\n\t\tdev_info(dev->netdev->dev.parent,\n\t\t\t \"PEAK-System %s v%u fw v%u.%u.%u (%u channels)\\n\",\n\t\t\t dev->adapter->name, pdev->usb_if->fw_info.hw_version,\n\t\t\t pdev->usb_if->fw_info.fw_version[0],\n\t\t\t pdev->usb_if->fw_info.fw_version[1],\n\t\t\t pdev->usb_if->fw_info.fw_version[2],\n\t\t\t dev->adapter->ctrl_count);\n\n\t\t/* check for ability to switch between ISO/non-ISO modes */\n\t\tif (pdev->usb_if->fw_info.fw_version[0] >= 2) {\n\t\t\t/* firmware >= 2.x supports ISO/non-ISO switching */\n\t\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_FD_NON_ISO;\n\t\t} else {\n\t\t\t/* firmware < 2.x only supports fixed(!) non-ISO */\n\t\t\tdev->can.ctrlmode |= CAN_CTRLMODE_FD_NON_ISO;\n\t\t}\n\n\t\t/* tell the hardware the can driver is running */\n\t\terr = pcan_usb_fd_drv_loaded(dev, 1);\n\t\tif (err) {\n\t\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\t\"unable to tell %s driver is loaded (err %d)\\n\",\n\t\t\t\tdev->adapter->name, err);\n\t\t\tgoto err_out_2;\n\t\t}\n\t} else {\n\t\t/* otherwise, simply copy previous sibling's values */\n\t\tstruct pcan_usb_fd_device *ppdev =\n\t\t\tcontainer_of(dev->prev_siblings,\n\t\t\t\t     struct pcan_usb_fd_device, dev);\n\n\t\tpdev->usb_if = ppdev->usb_if;\n\t\tpdev->cmd_buffer_addr = ppdev->cmd_buffer_addr;\n\n\t\t/* do a copy of the ctrlmode[_supported] too */\n\t\tdev->can.ctrlmode = ppdev->dev.can.ctrlmode;\n\t\tdev->can.ctrlmode_supported = ppdev->dev.can.ctrlmode_supported;\n\t}\n\n\tpdev->usb_if->dev[dev->ctrl_idx] = dev;\n\tdev->device_number =\n\t\tle32_to_cpu(pdev->usb_if->fw_info.dev_id[dev->ctrl_idx]);\n\n\t/* set clock domain */\n\tfor (i = 0; i < ARRAY_SIZE(pcan_usb_fd_clk_freq); i++)\n\t\tif (dev->adapter->clock.freq == pcan_usb_fd_clk_freq[i])\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(pcan_usb_fd_clk_freq)) {\n\t\tdev_warn(dev->netdev->dev.parent,\n\t\t\t \"incompatible clock frequencies\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_out_2;\n\t}\n\n\tpcan_usb_fd_set_clock_domain(dev, i);\n\n\t/* set LED in default state (end of init phase) */\n\tpcan_usb_fd_set_can_led(dev, PCAN_UFD_LED_DEF);\n\n\treturn 0;\n\nerr_out_2:\n\tkfree(pdev->cmd_buffer_addr);\nerr_out_1:\n\tkfree(pdev->usb_if);\nerr_out:\n\treturn err;\n}",
        "func": "static int pcan_usb_fd_init(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\tint i, err = -ENOMEM;\n\n\t/* do this for 1st channel only */\n\tif (!dev->prev_siblings) {\n\t\t/* allocate netdevices common structure attached to first one */\n\t\tpdev->usb_if = kzalloc(sizeof(*pdev->usb_if), GFP_KERNEL);\n\t\tif (!pdev->usb_if)\n\t\t\tgoto err_out;\n\n\t\t/* allocate command buffer once for all for the interface */\n\t\tpdev->cmd_buffer_addr = kzalloc(PCAN_UFD_CMD_BUFFER_SIZE,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!pdev->cmd_buffer_addr)\n\t\t\tgoto err_out_1;\n\n\t\t/* number of ts msgs to ignore before taking one into account */\n\t\tpdev->usb_if->cm_ignore_count = 5;\n\n\t\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_INFO,\n\t\t\t\t\t    PCAN_USBPRO_INFO_FW,\n\t\t\t\t\t    &pdev->usb_if->fw_info,\n\t\t\t\t\t    sizeof(pdev->usb_if->fw_info));\n\t\tif (err) {\n\t\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\t\"unable to read %s firmware info (err %d)\\n\",\n\t\t\t\tdev->adapter->name, err);\n\t\t\tgoto err_out_2;\n\t\t}\n\n\t\t/* explicit use of dev_xxx() instead of netdev_xxx() here:\n\t\t * information displayed are related to the device itself, not\n\t\t * to the canx (channel) device.\n\t\t */\n\t\tdev_info(dev->netdev->dev.parent,\n\t\t\t \"PEAK-System %s v%u fw v%u.%u.%u (%u channels)\\n\",\n\t\t\t dev->adapter->name, pdev->usb_if->fw_info.hw_version,\n\t\t\t pdev->usb_if->fw_info.fw_version[0],\n\t\t\t pdev->usb_if->fw_info.fw_version[1],\n\t\t\t pdev->usb_if->fw_info.fw_version[2],\n\t\t\t dev->adapter->ctrl_count);\n\n\t\t/* check for ability to switch between ISO/non-ISO modes */\n\t\tif (pdev->usb_if->fw_info.fw_version[0] >= 2) {\n\t\t\t/* firmware >= 2.x supports ISO/non-ISO switching */\n\t\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_FD_NON_ISO;\n\t\t} else {\n\t\t\t/* firmware < 2.x only supports fixed(!) non-ISO */\n\t\t\tdev->can.ctrlmode |= CAN_CTRLMODE_FD_NON_ISO;\n\t\t}\n\n\t\t/* tell the hardware the can driver is running */\n\t\terr = pcan_usb_fd_drv_loaded(dev, 1);\n\t\tif (err) {\n\t\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\t\"unable to tell %s driver is loaded (err %d)\\n\",\n\t\t\t\tdev->adapter->name, err);\n\t\t\tgoto err_out_2;\n\t\t}\n\t} else {\n\t\t/* otherwise, simply copy previous sibling's values */\n\t\tstruct pcan_usb_fd_device *ppdev =\n\t\t\tcontainer_of(dev->prev_siblings,\n\t\t\t\t     struct pcan_usb_fd_device, dev);\n\n\t\tpdev->usb_if = ppdev->usb_if;\n\t\tpdev->cmd_buffer_addr = ppdev->cmd_buffer_addr;\n\n\t\t/* do a copy of the ctrlmode[_supported] too */\n\t\tdev->can.ctrlmode = ppdev->dev.can.ctrlmode;\n\t\tdev->can.ctrlmode_supported = ppdev->dev.can.ctrlmode_supported;\n\t}\n\n\tpdev->usb_if->dev[dev->ctrl_idx] = dev;\n\tdev->device_number =\n\t\tle32_to_cpu(pdev->usb_if->fw_info.dev_id[dev->ctrl_idx]);\n\n\t/* set clock domain */\n\tfor (i = 0; i < ARRAY_SIZE(pcan_usb_fd_clk_freq); i++)\n\t\tif (dev->adapter->clock.freq == pcan_usb_fd_clk_freq[i])\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(pcan_usb_fd_clk_freq)) {\n\t\tdev_warn(dev->netdev->dev.parent,\n\t\t\t \"incompatible clock frequencies\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_out_2;\n\t}\n\n\tpcan_usb_fd_set_clock_domain(dev, i);\n\n\t/* set LED in default state (end of init phase) */\n\tpcan_usb_fd_set_can_led(dev, PCAN_UFD_LED_DEF);\n\n\treturn 0;\n\nerr_out_2:\n\tkfree(pdev->cmd_buffer_addr);\nerr_out_1:\n\tkfree(pdev->usb_if);\nerr_out:\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \t\t\tgoto err_out;\n \n \t\t/* allocate command buffer once for all for the interface */\n-\t\tpdev->cmd_buffer_addr = kmalloc(PCAN_UFD_CMD_BUFFER_SIZE,\n+\t\tpdev->cmd_buffer_addr = kzalloc(PCAN_UFD_CMD_BUFFER_SIZE,\n \t\t\t\t\t\tGFP_KERNEL);\n \t\tif (!pdev->cmd_buffer_addr)\n \t\t\tgoto err_out_1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tpdev->cmd_buffer_addr = kmalloc(PCAN_UFD_CMD_BUFFER_SIZE,"
            ],
            "added_lines": [
                "\t\tpdev->cmd_buffer_addr = kzalloc(PCAN_UFD_CMD_BUFFER_SIZE,"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19536",
        "func_name": "torvalds/linux/pcan_usb_pro_drv_loaded",
        "description": "In the Linux kernel before 5.2.9, there is an info-leak bug that can be caused by a malicious USB device in the drivers/net/can/usb/peak_usb/pcan_usb_pro.c driver, aka CID-ead16e53c2f0.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ead16e53c2f0ed946d82d4037c630e2f60f4ab69",
        "commit_title": "Uninitialized Kernel memory can leak to USB devices.",
        "commit_text": " Fix by using kzalloc() instead of kmalloc() on the affected buffers.  Cc: linux-stable <stable@vger.kernel.org> ",
        "func_before": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\n\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\n\treturn err;\n}",
        "func": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\n\tbuffer = kzalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tu8 *buffer;\n \tint err;\n \n-\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n+\tbuffer = kzalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n \tif (!buffer)\n \t\treturn -ENOMEM;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);"
            ],
            "added_lines": [
                "\tbuffer = kzalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_T_content",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_T_content(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 116 \"./asn1/cms/cms.cnf\"\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_T_content(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 117 \"./asn1/cms/cms.cnf\"\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_T_content(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 116 \"./asn1/cms/cms.cnf\"\n+#line 117 \"./asn1/cms/cms.cnf\"\n   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 116 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 117 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_T_eContent",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_T_eContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 120 \"./asn1/cms/cms.cnf\"\n\n  offset = dissect_ber_octet_string(FALSE, actx, tree, tvb, offset, hf_index, &content_tvb);\n\n  if(content_tvb) {\n    proto_item_set_text(actx->created_item, \"eContent (%u bytes)\", tvb_reported_length (content_tvb));\n\n    call_ber_oid_callback(object_identifier_id, content_tvb, 0, actx->pinfo, top_tree ? top_tree : tree, NULL);\n  }\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_T_eContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 121 \"./asn1/cms/cms.cnf\"\n\n  offset = dissect_ber_octet_string(FALSE, actx, tree, tvb, offset, hf_index, &content_tvb);\n\n  if(content_tvb) {\n    proto_item_set_text(actx->created_item, \"eContent (%u bytes)\", tvb_reported_length (content_tvb));\n\n    call_ber_oid_callback(object_identifier_id, content_tvb, 0, actx->pinfo, top_tree ? top_tree : tree, NULL);\n  }\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_T_eContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 120 \"./asn1/cms/cms.cnf\"\n+#line 121 \"./asn1/cms/cms.cnf\"\n \n   offset = dissect_ber_octet_string(FALSE, actx, tree, tvb, offset, hf_index, &content_tvb);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 120 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 121 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_T_attrType",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_T_attrType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 150 \"./asn1/cms/cms.cnf\"\n  const char *name = NULL;\n\n    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);\n\n\n  if(object_identifier_id) {\n    name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);\n    proto_item_append_text(tree, \" (%s)\", name ? name : object_identifier_id);\n  }\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_T_attrType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 151 \"./asn1/cms/cms.cnf\"\n  const char *name = NULL;\n\n    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);\n\n\n  if(object_identifier_id) {\n    name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);\n    proto_item_append_text(tree, \" (%s)\", name ? name : object_identifier_id);\n  }\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_T_attrType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 150 \"./asn1/cms/cms.cnf\"\n+#line 151 \"./asn1/cms/cms.cnf\"\n   const char *name = NULL;\n \n     offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);",
        "diff_line_info": {
            "deleted_lines": [
                "#line 150 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 151 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_T_otherRevInfo",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_T_otherRevInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 144 \"./asn1/cms/cms.cnf\"\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_T_otherRevInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 145 \"./asn1/cms/cms.cnf\"\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_T_otherRevInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 144 \"./asn1/cms/cms.cnf\"\n+#line 145 \"./asn1/cms/cms.cnf\"\n   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 144 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 145 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_ContentType",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "int\ndissect_cms_ContentType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 106 \"./asn1/cms/cms.cnf\"\n  \tconst char *name = NULL;\n\n\t  offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_index, &object_identifier_id);\n\n\n\tif(object_identifier_id) {\n\t\tname = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);\n\t\tproto_item_append_text(tree, \" (%s)\", name ? name : object_identifier_id);\n\t}\n\n\n\n  return offset;\n}",
        "func": "int\ndissect_cms_ContentType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 107 \"./asn1/cms/cms.cnf\"\n  \tconst char *name = NULL;\n\n\t  offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_index, &object_identifier_id);\n\n\n\tif(object_identifier_id) {\n\t\tname = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);\n\t\tproto_item_append_text(tree, \" (%s)\", name ? name : object_identifier_id);\n\t}\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n int\n dissect_cms_ContentType(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 106 \"./asn1/cms/cms.cnf\"\n+#line 107 \"./asn1/cms/cms.cnf\"\n   \tconst char *name = NULL;\n \n \t  offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_index, &object_identifier_id);",
        "diff_line_info": {
            "deleted_lines": [
                "#line 106 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 107 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_T_keyAttr",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_T_keyAttr(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 139 \"./asn1/cms/cms.cnf\"\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_T_keyAttr(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 140 \"./asn1/cms/cms.cnf\"\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_T_keyAttr(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 139 \"./asn1/cms/cms.cnf\"\n+#line 140 \"./asn1/cms/cms.cnf\"\n   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 139 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 140 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_EncryptedContent",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_EncryptedContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 210 \"./asn1/cms/cms.cnf\"\n\ttvbuff_t *encrypted_tvb;\n\tproto_item *item;\n\n  offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,\n                                       &encrypted_tvb);\n\n#line 215 \"./asn1/cms/cms.cnf\"\n\n\titem = actx->created_item;\n\n\tPBE_decrypt_data(object_identifier_id, encrypted_tvb, actx->pinfo, actx, item);\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_EncryptedContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 211 \"./asn1/cms/cms.cnf\"\n\ttvbuff_t *encrypted_tvb;\n\tproto_item *item;\n\n  offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,\n                                       &encrypted_tvb);\n\n#line 216 \"./asn1/cms/cms.cnf\"\n\n\titem = actx->created_item;\n\n\tPBE_decrypt_data(object_identifier_id, encrypted_tvb, actx->pinfo, actx, item);\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,13 @@\n static int\n dissect_cms_EncryptedContent(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 210 \"./asn1/cms/cms.cnf\"\n+#line 211 \"./asn1/cms/cms.cnf\"\n \ttvbuff_t *encrypted_tvb;\n \tproto_item *item;\n \n   offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,\n                                        &encrypted_tvb);\n \n-#line 215 \"./asn1/cms/cms.cnf\"\n+#line 216 \"./asn1/cms/cms.cnf\"\n \n \titem = actx->created_item;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 210 \"./asn1/cms/cms.cnf\"",
                "#line 215 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 211 \"./asn1/cms/cms.cnf\"",
                "#line 216 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_T_parameters",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 193 \"./asn1/cms/cms.cnf\"\n\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 194 \"./asn1/cms/cms.cnf\"\n\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 193 \"./asn1/cms/cms.cnf\"\n+#line 194 \"./asn1/cms/cms.cnf\"\n \n   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 193 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 194 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_T_oriValue",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_T_oriValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 133 \"./asn1/cms/cms.cnf\"\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_T_oriValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 134 \"./asn1/cms/cms.cnf\"\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_T_oriValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 133 \"./asn1/cms/cms.cnf\"\n+#line 134 \"./asn1/cms/cms.cnf\"\n   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 133 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 134 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_RC2ParameterVersion",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_RC2ParameterVersion(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 200 \"./asn1/cms/cms.cnf\"\n  guint32 length = 0;\n\n    offset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,\n                                                &length);\n\n\n  if(cap_tree != NULL)\n    proto_item_append_text(cap_tree, \" (%d bits)\", length);\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_RC2ParameterVersion(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 201 \"./asn1/cms/cms.cnf\"\n  guint32 length = 0;\n\n    offset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,\n                                                &length);\n\n\n  if(cap_tree != NULL)\n    proto_item_append_text(cap_tree, \" (%d bits)\", length);\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_RC2ParameterVersion(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 200 \"./asn1/cms/cms.cnf\"\n+#line 201 \"./asn1/cms/cms.cnf\"\n   guint32 length = 0;\n \n     offset = dissect_ber_integer(implicit_tag, actx, tree, tvb, offset, hf_index,",
        "diff_line_info": {
            "deleted_lines": [
                "#line 200 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 201 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_T_capability",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_T_capability(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 182 \"./asn1/cms/cms.cnf\"\n  const char *name = NULL;\n\n    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);\n\n\n  if(object_identifier_id) {\n    name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);\n    proto_item_append_text(tree, \" %s\", name ? name : object_identifier_id);\n    cap_tree = tree;\n  }\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_T_capability(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 183 \"./asn1/cms/cms.cnf\"\n  const char *name = NULL;\n\n    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);\n\n\n  if(object_identifier_id) {\n    name = oid_resolved_from_string(wmem_packet_scope(), object_identifier_id);\n    proto_item_append_text(tree, \" %s\", name ? name : object_identifier_id);\n    cap_tree = tree;\n  }\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_T_capability(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 182 \"./asn1/cms/cms.cnf\"\n+#line 183 \"./asn1/cms/cms.cnf\"\n   const char *name = NULL;\n \n     offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_cms_attrType, &object_identifier_id);",
        "diff_line_info": {
            "deleted_lines": [
                "#line 182 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 183 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_ContentInfo",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "int\ndissect_cms_ContentInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 97 \"./asn1/cms/cms.cnf\"\n  top_tree = tree;\n    offset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,\n                                   ContentInfo_sequence, hf_index, ett_cms_ContentInfo);\n\n  content_tvb = NULL;\n  top_tree = NULL;\n\n\n\n  return offset;\n}",
        "func": "int\ndissect_cms_ContentInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 97 \"./asn1/cms/cms.cnf\"\n  top_tree = tree;\n    offset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,\n                                   ContentInfo_sequence, hf_index, ett_cms_ContentInfo);\n\n  content_tvb = NULL;\n  object_identifier_id = NULL;\n  top_tree = NULL;\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n                                    ContentInfo_sequence, hf_index, ett_cms_ContentInfo);\n \n   content_tvb = NULL;\n+  object_identifier_id = NULL;\n   top_tree = NULL;\n \n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  object_identifier_id = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_AttributeValue",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_AttributeValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 160 \"./asn1/cms/cms.cnf\"\n\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_AttributeValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 161 \"./asn1/cms/cms.cnf\"\n\n  offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_AttributeValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 160 \"./asn1/cms/cms.cnf\"\n+#line 161 \"./asn1/cms/cms.cnf\"\n \n   offset=call_ber_oid_callback(object_identifier_id, tvb, offset, actx->pinfo, tree, NULL);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 160 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 161 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19553",
        "func_name": "wireshark/dissect_cms_MessageDigest",
        "description": "In Wireshark 3.0.0 to 3.0.6 and 2.6.0 to 2.6.12, the CMS dissector could crash. This was addressed in epan/dissectors/asn1/cms/packet-cms-template.c by ensuring that an object identifier is set to NULL after a ContentInfo dissection.",
        "git_url": "https://github.com/wireshark/wireshark/commit/34d2e0d5318d0a7e9889498c721639e5cbf4ce45",
        "commit_title": "CMS: reset object_identifier_id after dissecting ContentInfo",
        "commit_text": " Bug: 15961 (cherry picked from commit 23850a3342d64b9c9808f14c20bfea6d22b7dc08) Conflicts: \tepan/dissectors/packet-cms.c",
        "func_before": "static int\ndissect_cms_MessageDigest(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 164 \"./asn1/cms/cms.cnf\"\n  proto_item *pi;\n  int old_offset = offset;\n\n    offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,\n                                       NULL);\n\n\n  pi = actx->created_item;\n\n  /* move past TLV */\n  old_offset = get_ber_identifier(tvb, old_offset, NULL, NULL, NULL);\n  old_offset = get_ber_length(tvb, old_offset, NULL, NULL);\n\n  if(content_tvb)\n    cms_verify_msg_digest(pi, content_tvb, x509af_get_last_algorithm_id(), tvb, old_offset);\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_cms_MessageDigest(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 165 \"./asn1/cms/cms.cnf\"\n  proto_item *pi;\n  int old_offset = offset;\n\n    offset = dissect_ber_octet_string(implicit_tag, actx, tree, tvb, offset, hf_index,\n                                       NULL);\n\n\n  pi = actx->created_item;\n\n  /* move past TLV */\n  old_offset = get_ber_identifier(tvb, old_offset, NULL, NULL, NULL);\n  old_offset = get_ber_length(tvb, old_offset, NULL, NULL);\n\n  if(content_tvb)\n    cms_verify_msg_digest(pi, content_tvb, x509af_get_last_algorithm_id(), tvb, old_offset);\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_cms_MessageDigest(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n-#line 164 \"./asn1/cms/cms.cnf\"\n+#line 165 \"./asn1/cms/cms.cnf\"\n   proto_item *pi;\n   int old_offset = offset;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "#line 164 \"./asn1/cms/cms.cnf\""
            ],
            "added_lines": [
                "#line 165 \"./asn1/cms/cms.cnf\""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36513",
        "func_name": "signalwire/freeswitch/our_sofia_event_callback",
        "description": "An issue was discovered in function sofia_handle_sip_i_notify in sofia.c in SignalWire freeswitch before 1.10.6, may allow attackers to view sensitive information due to an uninitialized value.",
        "git_url": "https://github.com/signalwire/freeswitch/commit/bd87b8892c260753af5672b6f865684036f157dc",
        "commit_title": "[mod_sofia] Fixed a few Usage-of-uninitialized value bugs which may cause information discolsure and bypass ACL check",
        "commit_text": "",
        "func_before": "static void our_sofia_event_callback(nua_event_t event,\n\t\t\t\t\t\t  int status,\n\t\t\t\t\t\t  char const *phrase,\n\t\t\t\t\t\t  nua_t *nua, sofia_profile_t *profile, nua_handle_t *nh, sofia_private_t *sofia_private, sip_t const *sip,\n\t\t\t\t\t\t\t\tsofia_dispatch_event_t *de, tagi_t tags[])\n{\n\tstruct private_object *tech_pvt = NULL;\n\tauth_res_t auth_res = AUTH_FORBIDDEN;\n\tswitch_core_session_t *session = NULL;\n\tswitch_channel_t *channel = NULL;\n\tsofia_gateway_t *gateway = NULL;\n\tint locked = 0;\n\tint check_destroy = 1;\n\n\tprofile->last_sip_event = switch_time_now();\n\n\t/* sofia_private will be == &mod_sofia_globals.keep_private whenever a request is done with a new handle that has to be\n\t  freed whenever the request is done */\n\tif (nh && sofia_private == &mod_sofia_globals.keep_private) {\n\t\tif (status >= 300) {\n\t\t\tnua_handle_bind(nh, NULL);\n\t\t\tnua_handle_destroy(nh);\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (sofia_private && sofia_private != &mod_sofia_globals.destroy_private && sofia_private != &mod_sofia_globals.keep_private) {\n\t\tif (!zstr(sofia_private->gateway_name)) {\n\t\t\tif (!(gateway = sofia_reg_find_gateway(sofia_private->gateway_name))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (!zstr(sofia_private->uuid)) {\n\t\t\tif ((session = de->init_session)) {\n\t\t\t\tde->init_session = NULL;\n\t\t\t} else if ((session = de->session) || (session = switch_core_session_locate(sofia_private->uuid))) {\n\t\t\t\ttech_pvt = switch_core_session_get_private(session);\n\t\t\t\tchannel = switch_core_session_get_channel(session);\n\t\t\t\tif (tech_pvt) {\n\t\t\t\t\tswitch_mutex_lock(tech_pvt->sofia_mutex);\n\t\t\t\t\tlocked = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (session != de->session) switch_core_session_rwunlock(session);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (status >= 180 && !*sofia_private->auth_gateway_name) {\n\t\t\t\t\tconst char *gwname = switch_channel_get_variable(channel, \"sip_use_gateway\");\n\t\t\t\t\tif (!zstr(gwname)) {\n\t\t\t\t\t\tswitch_set_string(sofia_private->auth_gateway_name, gwname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!tech_pvt->call_id && sip && sip->sip_call_id && sip->sip_call_id->i_id) {\n\t\t\t\t\ttech_pvt->call_id = switch_core_session_strdup(session, sip->sip_call_id->i_id);\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_call_id\", tech_pvt->call_id);\n\t\t\t\t}\n\n\t\t\t\tif (tech_pvt->gateway_name) {\n\t\t\t\t\tgateway = sofia_reg_find_gateway(tech_pvt->gateway_name);\n\t\t\t\t}\n\n\t\t\t\tif (channel && switch_channel_down(channel)) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"Channel is already hungup.\\n\");\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* we can't find the session it must be hanging up or something else, its too late to do anything with it. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (session && tech_pvt && tech_pvt->watch_headers && sip) {\n\t\tchar msgline[512];\n\t\tint hi;\n\t\tmsg_header_t *h = NULL;\n\t\tif (sip->sip_request) {\n\t\t\th = (msg_header_t *)sip->sip_request;\n\t\t\tmsg_header_field_e(msgline, sizeof(msgline), h, 0);\n\t\t} else if (sip->sip_status) {\n\t\t\th = (msg_header_t *)sip->sip_status;\n\t\t\tmsg_header_field_e(msgline, sizeof(msgline), h, 0);\n\t\t}\n\t\tif (h) {\n\t\t\tsip_unknown_t *un = NULL;\n\t\t\tchar buf[512];\n\t\t\tchar *c = NULL;\n\n\t\t\tmsgline[sizeof(msgline)-1] = '\\0';\n\t\t\tc = strchr(msgline, '\\r');\n\t\t\tif (c) {\n\t\t\t\t*c = '\\0';\n\t\t\t}\n\n\t\t\t/* Faster (ie hash-based) search here would be nice? ie, make watch_headers a hash? */\n\n\t\t\t/* Search first in the valid headers */\n\t\t\tfor (h = h->sh_succ; h; h = h->sh_succ) {\n\t\t\t\tsip_header_t *sh = (sip_header_t *)h;\n\t\t\t\tif (!sh->sh_class->hc_name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (hi = 0; tech_pvt->watch_headers[hi]; hi++) {\n\t\t\t\t\tif (!strcasecmp(tech_pvt->watch_headers[hi], sh->sh_class->hc_name)) {\n\t\t\t\t\t\tmsg_header_field_e(buf, sizeof(buf), h, 0);\n\t\t\t\t\t\tbuf[sizeof(buf)-1] = '\\0';\n\t\t\t\t\t\tnotify_watched_header(session, msgline, sh->sh_class->hc_name, buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Search now in the unknown headers */\n\t\t\tfor (un = sip->sip_unknown; un; un = un->un_next) {\n\t\t\t\tfor (hi = 0; tech_pvt->watch_headers[hi]; hi++) {\n\t\t\t\t\tif (!strcasecmp(tech_pvt->watch_headers[hi], un->un_name)) {\n\t\t\t\t\t\tnotify_watched_header(session, msgline, un->un_name, un->un_value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sofia_test_pflag(profile, PFLAG_AUTH_ALL) && tech_pvt && tech_pvt->key && sip && (event < nua_r_set_params || event > nua_r_authenticate)) {\n\t\tsip_authorization_t const *authorization = NULL;\n\n\t\tif (sip->sip_authorization) {\n\t\t\tauthorization = sip->sip_authorization;\n\t\t} else if (sip->sip_proxy_authorization) {\n\t\t\tauthorization = sip->sip_proxy_authorization;\n\t\t}\n\n\t\tif (authorization) {\n\t\t\tchar network_ip[80];\n\t\t\tint network_port;\n\t\t\tsofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), &network_port);\n\t\t\tauth_res = sofia_reg_parse_auth(profile, authorization, sip, de,\n\t\t\t\t\t\t\t\t\t\t\t(char *) sip->sip_request->rq_method_name, tech_pvt->key, strlen(tech_pvt->key), network_ip, network_port, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\tREG_INVITE, NULL, NULL, NULL, NULL);\n\t\t}\n\n\t\tif ((auth_res != AUTH_OK && auth_res != AUTH_RENEWED)) {\n\t\t\t//switch_channel_hangup(channel, SWITCH_CAUSE_DESTINATION_OUT_OF_ORDER);\n\t\t\tnua_respond(nh, SIP_401_UNAUTHORIZED, TAG_END());\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (channel) {\n\t\t\tswitch_channel_set_variable(channel, \"sip_authorized\", \"true\");\n\t\t}\n\t}\n\n\tif (sip && (status == 401 || status == 407)) {\n\t\tsofia_reg_handle_sip_r_challenge(status, phrase, nua, profile, nh, sofia_private, session, gateway, sip, de, tags);\n\t\tgoto done;\n\t}\n\n\tif (sip && sip->sip_payload && sip->sip_payload->pl_data) {\n\t\tif (sip->sip_payload->pl_len != strlen(sip->sip_payload->pl_data)) {\n\t\t\tsip->sip_payload->pl_data = su_strndup(nua_handle_get_home(nh), sip->sip_payload->pl_data, sip->sip_payload->pl_len);\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase nua_r_get_params:\n\tcase nua_i_fork:\n\tcase nua_r_info:\n\t\tbreak;\n\tcase nua_r_unregister:\n\tcase nua_r_unsubscribe:\n\tcase nua_i_terminated:\n\tcase nua_r_publish:\n\tcase nua_i_error:\n\tcase nua_i_active:\n\tcase nua_r_set_params:\n\tcase nua_i_prack:\n\tcase nua_r_prack:\n\t\tbreak;\n\n\tcase nua_i_cancel:\n\n\t\tif (sip && channel) {\n\t\t\tswitch_channel_set_variable(channel, \"sip_hangup_disposition\", \"recv_cancel\");\n\t\t\tswitch_channel_set_variable(channel, \"sip_invite_failure_status\", \"487\");\n\t\t\tswitch_channel_set_variable(channel, \"sip_invite_failure_phrase\", \"CANCEL\");\n\n\t\t\tif (sip->sip_reason) {\n\t\t\t\tchar *reason_header = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_reason);\n\n\t\t\t\tif (!zstr(reason_header)) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_reason\", reason_header);\n\t\t\t\t\tswitch_channel_set_variable_partner(channel, \"sip_reason\", reason_header);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase nua_r_cancel:\n\t\t{\n\t\t\tif (status > 299 && nh) {\n\t\t\t\tnua_handle_destroy(nh);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase nua_i_ack:\n\t\t{\n\t\t\tif (channel && sip) {\n\t\t\t\tconst char *r_sdp = NULL;\n\t\t\t\tsofia_glue_store_session_id(session, profile, sip, 0);\n\n\t\t\t\tif (sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\t\t\tif (sofia_test_flag(tech_pvt, TFLAG_PASS_ACK)) {\n\t\t\t\t\t\tr_sdp = sip->sip_payload->pl_data;\n\n\t\t\t\t\t\tif (tech_pvt->mparams.last_sdp_str) {\n\t\t\t\t\t\t\ttech_pvt->mparams.prev_sdp_str = tech_pvt->mparams.last_sdp_str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttech_pvt->mparams.last_sdp_str = NULL;\n\n\n\t\t\t\t\t\tif (!zstr(tech_pvt->mparams.prev_sdp_str) && strcmp(tech_pvt->mparams.prev_sdp_str, sip->sip_payload->pl_data)) {\n\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_reinvite_sdp\", sip->sip_payload->pl_data);\n\t\t\t\t\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttech_pvt->mparams.last_sdp_str = tech_pvt->mparams.prev_sdp_str;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_reinvite_sdp\", sip->sip_payload->pl_data);\n\t\t\t\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_to && sip->sip_to->a_tag) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_to_tag\", sip->sip_to->a_tag);\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_from && sip->sip_from->a_tag) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_from_tag\", sip->sip_from->a_tag);\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_cseq && sip->sip_cseq->cs_seq) {\n\t\t\t\t\tchar sip_cseq[40] = \"\";\n\t\t\t\t\tswitch_snprintf(sip_cseq, sizeof(sip_cseq), \"%d\", sip->sip_cseq->cs_seq);\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_cseq\", sip_cseq);\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_call_id && sip->sip_call_id->i_id) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_call_id\", sip->sip_call_id->i_id);\n\t\t\t\t}\n\n\t\t\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"dlg_req_swap_direction\", \"true\");\n\t\t\t\t}\n\n\t\t\t\textract_header_vars(profile, sip, session, nh);\n\t\t\t\tswitch_core_recovery_track(session);\n\t\t\t\tsofia_set_flag(tech_pvt, TFLAG_GOT_ACK);\n\n\t\t\t\tif (switch_channel_test_flag(tech_pvt->channel, CF_PROXY_MEDIA) && r_sdp) {\n\t\t\t\t\tif (sofia_test_pflag(tech_pvt->profile, PFLAG_3PCC_PROXY)) {\n\t\t\t\t\t\tswitch_channel_set_variable_partner(tech_pvt->channel, SWITCH_B_SDP_VARIABLE, r_sdp);\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(tech_pvt->session), SWITCH_LOG_DEBUG, \"3PCC-PROXY, Got my ACK\\n\");\n\t\t\t\t\t\tsofia_media_activate_rtp(tech_pvt);\n\t\t\t\t\t\tswitch_core_media_proxy_remote_addr(tech_pvt->session, r_sdp);\n\t\t\t\t\t\tsofia_set_flag(tech_pvt, TFLAG_3PCC_HAS_ACK);\n\t\t\t\t\t\tsofia_clear_flag(tech_pvt, TFLAG_PASS_ACK);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (sofia_test_flag(tech_pvt, TFLAG_PASS_ACK)) {\n\t\t\t\t\tswitch_core_session_t *other_session;\n\n\t\t\t\t\tsofia_clear_flag(tech_pvt, TFLAG_PASS_ACK);\n\n\t\t\t\t\tif (switch_core_session_get_partner(session, &other_session) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\tif (switch_core_session_compare(session, other_session)) {\n\t\t\t\t\t\t\tprivate_object_t *other_tech_pvt = switch_core_session_get_private(other_session);\n\t\t\t\t\t\t\ttech_send_ack(other_tech_pvt->nh, other_tech_pvt, r_sdp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\tcase nua_r_ack:\n\t\tif (channel)\n\t\t\tswitch_channel_set_flag(channel, CF_MEDIA_ACK);\n\t\tbreak;\n\tcase nua_r_shutdown:\n\t\tif (status >= 200) {\n\t\t\tsofia_set_pflag(profile, PFLAG_SHUTDOWN);\n\t\t\tsu_root_break(profile->s_root);\n\t\t}\n\t\tbreak;\n\tcase nua_r_message:\n\t\tsofia_handle_sip_r_message(status, profile, nh, sip);\n\t\tbreak;\n\tcase nua_r_invite:\n\t\tsofia_handle_sip_r_invite(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_r_options:\n\t\tsofia_handle_sip_r_options(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_bye:\n\t\tsofia_handle_sip_i_bye(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_r_bye:\n\t\tsofia_handle_sip_r_bye(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_r_notify:\n\t\tif (session) {\n\t\t\tsofia_handle_sip_r_notify(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\t}\n\t\tbreak;\n\tcase nua_i_notify:\n\t\tsofia_handle_sip_i_notify(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_r_register:\n\t\tsofia_reg_handle_sip_r_register(status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_options:\n\t\tsofia_handle_sip_i_options(status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_invite:\n\t\tif (session && sofia_private) {\n\t\t\tif (sofia_private->is_call > 1) {\n\t\t\t\tsofia_handle_sip_i_reinvite(session, nua, profile, nh, sofia_private, sip, de, tags);\n\t\t\t} else {\n\t\t\t\tsofia_private->is_call++;\n\t\t\t\tsofia_handle_sip_i_invite(session, nua, profile, nh, sofia_private, sip, de, tags);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase nua_i_publish:\n\t\tsofia_presence_handle_sip_i_publish(nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_register:\n\t\t//nua_respond(nh, SIP_200_OK, SIPTAG_CONTACT(sip->sip_contact), NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());\n\t\t//nua_handle_destroy(nh);\n\t\tsofia_reg_handle_sip_i_register(nua, profile, nh, &sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_state:\n\t\tsofia_handle_sip_i_state(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_message:\n\t\t{\n\t\t\tint handle_message = 1;\n\t\t\tint proxy_message = sofia_test_pflag(profile, PFLAG_PROXY_MESSAGE);\n\n\t\t\tif (!proxy_message && session) {\n\t\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(session);\n\t\t\t\tproxy_message = switch_channel_var_true(channel, \"sip_proxy_message\");\n\t\t\t}\n\n\t\t\tif (proxy_message) {\n\t\t\t\tif (sofia_proxy_sip_i_message(nua, profile, nh, session, sip, de, tags) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\thandle_message = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (handle_message) {\n\t\t\t\tsofia_presence_handle_sip_i_message(status, phrase, nua, profile, nh, session, sofia_private, sip, de, tags);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase nua_i_info:\n\t\t{\n\t\t\tint handle_info = 1;\n\t\t\tint proxy_info = sofia_test_pflag(profile, PFLAG_PROXY_INFO);\n\n\t\t\tif (!proxy_info && session) {\n\t\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(session);\n\t\t\t\tproxy_info = switch_channel_var_true(channel, \"sip_proxy_info\");\n\t\t\t}\n\n\t\t\tif (proxy_info) {\n\t\t\t\tif (sofia_proxy_sip_i_info(nua, profile, nh, session, sip, de, tags) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\thandle_info = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (handle_info) {\n\t\t\t\tsofia_handle_sip_i_info(nua, profile, nh, session, sip, de, tags);\n\t\t\t}\n\n\t\t}\n\t\tbreak;\n\tcase nua_i_update:\n\t\tif (session) {\n\t\t\tsofia_update_callee_id(session, profile, sip, SWITCH_TRUE);\n\t\t}\n\t\tbreak;\n\tcase nua_r_update:\n\t\tif (session && tech_pvt && locked) {\n\t\t\tsofia_clear_flag_locked(tech_pvt, TFLAG_UPDATING_DISPLAY);\n\t\t}\n\t\tbreak;\n\tcase nua_r_refer:\n\t\tif (session) {\n\t\t\tsofia_handle_sip_r_refer(nua, profile, nh, session, status, phrase, sip, de, tags);\n\t\t}\n\t\tbreak;\n\tcase nua_i_refer:\n\t\tif (session) {\n\t\t\tsofia_handle_sip_i_refer(nua, profile, nh, session, sip, de, tags);\n\t\t} else if (sip) {\n\t\t\tconst char *req_user = NULL, *req_host = NULL, *action = NULL, *ref_by_user = NULL, *ref_to_user = NULL, *ref_to_host = NULL;\n\t\t\tchar *refer_to = NULL, *referred_by = NULL, *method = NULL, *full_url = NULL;\n\t\t\tchar *params = NULL, *iparams = NULL;\n\t\t\tswitch_event_t *event;\n\t\t\tchar *tmp;\n\n\t\t\tif (sip->sip_refer_to) {\n\t\t\t\tref_to_user = sip->sip_refer_to->r_url->url_user;\n\t\t\t\tref_to_host = sip->sip_refer_to->r_url->url_host;\n\n\t\t\t\tif (sip->sip_refer_to->r_url->url_params && switch_stristr(\"method=\", sip->sip_refer_to->r_url->url_params)) {\n\t\t\t\t\tparams = su_strdup(nua_handle_home(nh), sip->sip_refer_to->r_url->url_params);\n\t\t\t\t}\n\n\n\t\t\t\tif ((refer_to = sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_refer_to))) {\n\t\t\t\t\tif ((iparams = strchr(refer_to, ';'))) {\n\t\t\t\t\t\t*iparams++ = '\\0';\n\n\t\t\t\t\t\tif (!params || !switch_stristr(\"method=\", params)) {\n\t\t\t\t\t\t\tparams = iparams;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((tmp = sofia_glue_get_url_from_contact(refer_to, 0))) {\n\t\t\t\t\t\trefer_to = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (params) {\n\t\t\t\t\tmethod = switch_find_parameter(params, \"method\", NULL);\n\t\t\t\t\tfull_url = switch_find_parameter(params, \"full_url\", NULL);\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\tif (!method) {\n\t\t\t\tmethod = strdup(\"INVITE\");\n\t\t\t\tswitch_assert(method);\n\t\t\t}\n\n\t\t\tif (!strcasecmp(method, \"INVITE\")) {\n\t\t\t\taction = \"call\";\n\t\t\t} else if (!strcasecmp(method, \"BYE\")) {\n\t\t\t\taction = \"end\";\n\t\t\t} else {\n\t\t\t\taction = method;\n\t\t\t}\n\n\t\t\tif (sip->sip_referred_by) {\n\t\t\t\treferred_by = sofia_glue_get_url_from_contact(sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_referred_by), 0);\n\t\t\t\tref_by_user = sip->sip_referred_by->b_url->url_user;\n\t\t\t} else if(sip->sip_to){\n\t\t\t\treferred_by = sofia_glue_get_url_from_contact(sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_to), 0);\n\t\t\t\tref_by_user = sip->sip_to->a_url->url_user;\n\t\t\t}\n\n\t\t\tif (sip->sip_to) {\n\t\t\t\treq_user = sip->sip_to->a_url->url_user;\n\t\t\t\treq_host = sip->sip_to->a_url->url_host;\n\t\t\t}\n\n\t\t\tif (switch_event_create(&event, SWITCH_EVENT_CALL_SETUP_REQ) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Requesting-Component\", \"mod_sofia\");\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Target-Component\", req_user);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Target-Domain\", req_host);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Request-Action\", action);\n\t\t\t\tswitch_event_add_header(event, SWITCH_STACK_BOTTOM, \"Request-Target\", \"sofia/%s/%s\", profile->name, refer_to);\n\t\t\t\tswitch_event_add_header(event, SWITCH_STACK_BOTTOM, \"Request-Target-URI\", \"%s\", refer_to);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Request-Target-Extension\", ref_to_user);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Request-Target-Domain\", ref_to_host);\n\t\t\t\tif (switch_true(full_url)) {\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"full_url\", \"true\");\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_call_id && sip->sip_call_id->i_id) {\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Request-Call-ID\", sip->sip_call_id->i_id);\n\t\t\t\t}\n\n\t\t\t\tif (!zstr(referred_by)) {\n\t\t\t\t\tswitch_event_add_header(event, SWITCH_STACK_BOTTOM, \"Request-Sender\", \"sofia/%s/%s\", profile->name, referred_by);\n\t\t\t\t}\n\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"var_origination_caller_id_number\", ref_by_user);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"var_origination_caller_id_name\", ref_by_user);\n\t\t\t\tswitch_event_fire(&event);\n\t\t\t}\n\n\n\n\t\t\t{\n\t\t\t\tchar *sql;\n\t\t\t\tsofia_nat_parse_t np = { { 0 } };\n\t\t\t\tchar *contact_str;\n\t\t\t\tchar *proto = \"sip\", *orig_proto = \"sip\";\n\t\t\t\tconst char *call_id, *full_from, *full_to, *full_via, *from_user = NULL, *from_host = NULL, *to_user, *to_host, *full_agent;\n\t\t\t\tchar to_tag[13] = \"\";\n\t\t\t\tchar *event_str = \"refer\";\n\t\t\t\tsip_accept_t *ap = sip->sip_accept;\n\t\t\t\tchar accept_header[256] = \"\";\n\n\t\t\t\tnp.fs_path = 1;\n\t\t\t\tcontact_str = sofia_glue_gen_contact_str(profile, sip, nh, de, &np);\n\n\t\t\t\tcall_id = sip->sip_call_id ? sip->sip_call_id->i_id : \"\";\n\t\t\t\tfull_from = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_from);\n\t\t\t\tfull_to = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_to);\n\t\t\t\tfull_via = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_via);\n\n\t\t\t\tfull_agent = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_user_agent);\n\n\t\t\t\tswitch_stun_random_string(to_tag, 12, NULL);\n\n\t\t\t\tif (sip->sip_from) {\n\t\t\t\t\tfrom_user = sip->sip_from->a_url->url_user;\n\t\t\t\t\tfrom_host = sip->sip_from->a_url->url_host;\n\t\t\t\t} else {\n\t\t\t\t\tfrom_user = \"n/a\";\n\t\t\t\t\tfrom_host = \"n/a\";\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_to) {\n\t\t\t\t\tto_user = sip->sip_to->a_url->url_user;\n\t\t\t\t\tto_host = sip->sip_to->a_url->url_host;\n\t\t\t\t} else {\n\t\t\t\t\tto_user = \"n/a\";\n\t\t\t\t\tto_host = \"n/a\";\n\t\t\t\t}\n\n\t\t\t\twhile (ap) {\n\t\t\t\t\tswitch_snprintf(accept_header + strlen(accept_header), sizeof(accept_header) - strlen(accept_header),\n\t\t\t\t\t\t\t\t\t\"%s%s \", ap->ac_type, ap->ac_next ? \",\" : \"\");\n\t\t\t\t\tap = ap->ac_next;\n\t\t\t\t}\n\n\t\t\t\tsql = switch_mprintf(\"insert into sip_subscriptions \"\n\t\t\t\t\t\t\t\t\t \"(proto,sip_user,sip_host,sub_to_user,sub_to_host,presence_hosts,event,contact,call_id,full_from,\"\n\t\t\t\t\t\t\t\t\t \"full_via,expires,user_agent,accept,profile_name,hostname,network_port,network_ip,version,orig_proto, full_to) \"\n\t\t\t\t\t\t\t\t\t \"values ('%q','%q','%q','%q','%q','%q','%q','%q','%q','%q','%q',%ld,'%q','%q','%q','%q','%d','%q',-1,'%q','%q;tag=%q')\",\n\t\t\t\t\t\t\t\t\t proto, from_user, from_host, to_user, to_host, profile->presence_hosts ? profile->presence_hosts : \"\",\n\t\t\t\t\t\t\t\t\t event_str, contact_str, call_id, full_from, full_via,\n\t\t\t\t\t\t\t\t\t (long) switch_epoch_time_now(NULL) + 60,\n\t\t\t\t\t\t\t\t\t full_agent, accept_header, profile->name, mod_sofia_globals.hostname,\n\t\t\t\t\t\t\t\t\t np.network_port, np.network_ip, orig_proto, full_to, to_tag);\n\n\t\t\t\tswitch_assert(sql != NULL);\n\n\n\t\t\t\tif (mod_sofia_globals.debug_presence > 0 || mod_sofia_globals.debug_sla > 0) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_CRIT, \"%s REFER SUBSCRIBE %s@%s %s@%s\\n%s\\n\",\n\t\t\t\t\t\t\t\t\t  profile->name, from_user, from_host, to_user, to_host, sql);\n\t\t\t\t}\n\n\n\t\t\t\tsofia_glue_execute_sql_now(profile, &sql, SWITCH_TRUE);\n\n\t\t\t\tsip_to_tag(nua_handle_get_home(nh), sip->sip_to, to_tag);\n\t\t\t}\n\n\t\t\tnua_respond(nh, SIP_202_ACCEPTED, SIPTAG_TO(sip->sip_to), NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());\n\t\t\tswitch_safe_free(method);\n\t\t\tswitch_safe_free(full_url);\n\n\t\t}\n\t\tbreak;\n\tcase nua_r_subscribe:\n\t\tsofia_presence_handle_sip_r_subscribe(status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_subscribe:\n\t\tsofia_presence_handle_sip_i_subscribe(status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_media_error:\n\t\t{\n\n\t\t\tif (sofia_private && sofia_private->call_id && sofia_private->network_ip && sofia_private->network_port) {\n\t\t\t\tchar *sql;\n\t\t\t\tswitch_event_t *event = NULL;\n\n\t\t\t\tsql = switch_mprintf(\"delete from sip_registrations where call_id='%q' and network_ip='%q' and network_port='%q'\",\n\t\t\t\t\t\t\t\t\t\t   sofia_private->call_id, sofia_private->network_ip, sofia_private->network_port);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"SOCKET DISCONNECT: %s %s:%s\\n\",\n\t\t\t\t\t\t\t\t  sofia_private->call_id, sofia_private->network_ip, sofia_private->network_port);\n\t\t\t\tsofia_glue_execute_sql(profile, &sql, SWITCH_TRUE);\n\n\t\t\t\tswitch_core_del_registration(sofia_private->user, sofia_private->realm, sofia_private->call_id);\n\n\n\n\t\t\t\tif (switch_event_create(&event, SWITCH_EVENT_PRESENCE_IN) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"proto\", SOFIA_CHAT_PROTO);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"rpid\", \"unknown\");\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"login\", profile->url);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"user-agent\",\n\t\t\t\t\t\t\t\t\t\t\t\t   (sip && sip->sip_user_agent) ? sip->sip_user_agent->g_string : \"unknown\");\n\t\t\t\t\tswitch_event_add_header(event, SWITCH_STACK_BOTTOM, \"from\", \"%s@%s\", sofia_private->user, sofia_private->realm);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"status\", \"Unregistered\");\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"presence-source\", \"register\");\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"event_type\", \"presence\");\n\t\t\t\t\tswitch_event_fire(&event);\n\t\t\t\t}\n\n\n\t\t\t\tif (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_UNREGISTER) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"profile-name\", profile->name);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"from-user\", sofia_private->user);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"from-host\", sofia_private->realm);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"call-id\", sofia_private->call_id);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"rpid\", \"unknown\");\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"reason\", \"socket-disconnection\");\n\t\t\t\t\tswitch_event_fire(&event);\n\t\t\t\t}\n\n\n\t\t\t\tsofia_reg_check_socket(profile, sofia_private->call_id, sofia_private->network_ip, sofia_private->network_port);\n\t\t\t        nua_handle_destroy(nh);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase nua_r_authenticate:\n\n\t\tif (status >= 500) {\n\t\t\tif (sofia_private && !zstr(sofia_private->gateway_name)) {\n\t\t\t\tsofia_gateway_t *gateway = NULL;\n\n\t\t\t\tif ((gateway = sofia_reg_find_gateway(sofia_private->gateway_name))) {\n\t\t\t\t\tgateway->state = REG_STATE_FAILED;\n\t\t\t\t\tgateway->failure_status = status;\n\t\t\t\t\tsofia_reg_release_gateway(gateway);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnua_handle_destroy(nh);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tif (status > 100) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"%s: unknown event %d: %03d %s\\n\", nua_event_name(event), event,\n\t\t\t\t\t\t\t  status, phrase);\n\t\t} else {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"%s: unknown event %d\\n\", nua_event_name(event), event);\n\t\t}\n\t\tbreak;\n\t}\n\n  done:\n\n\tif (tech_pvt && tech_pvt->want_event && event == tech_pvt->want_event) {\n\t\ttech_pvt->want_event = 0;\n\t}\n\n\tif (sofia_private && sofia_private->call_id) {\n\t\tcheck_destroy = 0;\n\t}\n\n\tswitch (event) {\n\tcase nua_i_subscribe:\n\tcase nua_r_notify:\n\t\tcheck_destroy = 0;\n\t\tbreak;\n\n\tcase nua_i_notify:\n\n\t\tif (sip && sip->sip_event && !strcmp(sip->sip_event->o_type, \"dialog\") && sip->sip_event->o_params && !strcmp(sip->sip_event->o_params[0], \"sla\")) {\n\t\t\tcheck_destroy = 0;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((sofia_private && sofia_private == &mod_sofia_globals.destroy_private)) {\n\t\tnua_handle_bind(nh, NULL);\n\t\tnua_handle_destroy(nh);\n\t\tnh = NULL;\n\t}\n\n\tif (check_destroy) {\n\t\tif (nh && ((sofia_private && sofia_private->destroy_nh) || !nua_handle_magic(nh))) {\n\t\t\tif (sofia_private) {\n\t\t\t\tnua_handle_bind(nh, NULL);\n\t\t\t}\n\n\t\t\tif (tech_pvt && (tech_pvt->nh == nh)) {\n\t\t\t\ttech_pvt->nh = NULL;\n\t\t\t}\n\n\t\t\tnua_handle_destroy(nh);\n\t\t\tnh = NULL;\n\t\t}\n\t}\n\n\tif (sofia_private && sofia_private->destroy_me) {\n\t\tif (tech_pvt) {\n\t\t\ttech_pvt->sofia_private = NULL;\n\t\t}\n\n\t\tif (nh) {\n\t\t\tnua_handle_bind(nh, NULL);\n\t\t}\n\t\tsofia_private->destroy_me = 12;\n\t\tsofia_private_free(sofia_private);\n\n\t}\n\n\tif (gateway) {\n\t\tsofia_reg_release_gateway(gateway);\n\t}\n\n\tif (locked && tech_pvt) {\n\t\tswitch_mutex_unlock(tech_pvt->sofia_mutex);\n\t}\n\n\tif (session && session != de->session) {\n\t\tswitch_core_session_rwunlock(session);\n\t}\n}",
        "func": "static void our_sofia_event_callback(nua_event_t event,\n\t\t\t\t\t\t  int status,\n\t\t\t\t\t\t  char const *phrase,\n\t\t\t\t\t\t  nua_t *nua, sofia_profile_t *profile, nua_handle_t *nh, sofia_private_t *sofia_private, sip_t const *sip,\n\t\t\t\t\t\t\t\tsofia_dispatch_event_t *de, tagi_t tags[])\n{\n\tstruct private_object *tech_pvt = NULL;\n\tauth_res_t auth_res = AUTH_FORBIDDEN;\n\tswitch_core_session_t *session = NULL;\n\tswitch_channel_t *channel = NULL;\n\tsofia_gateway_t *gateway = NULL;\n\tint locked = 0;\n\tint check_destroy = 1;\n\n\tprofile->last_sip_event = switch_time_now();\n\n\t/* sofia_private will be == &mod_sofia_globals.keep_private whenever a request is done with a new handle that has to be\n\t  freed whenever the request is done */\n\tif (nh && sofia_private == &mod_sofia_globals.keep_private) {\n\t\tif (status >= 300) {\n\t\t\tnua_handle_bind(nh, NULL);\n\t\t\tnua_handle_destroy(nh);\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (sofia_private && sofia_private != &mod_sofia_globals.destroy_private && sofia_private != &mod_sofia_globals.keep_private) {\n\t\tif (!zstr(sofia_private->gateway_name)) {\n\t\t\tif (!(gateway = sofia_reg_find_gateway(sofia_private->gateway_name))) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (!zstr(sofia_private->uuid)) {\n\t\t\tif ((session = de->init_session)) {\n\t\t\t\tde->init_session = NULL;\n\t\t\t} else if ((session = de->session) || (session = switch_core_session_locate(sofia_private->uuid))) {\n\t\t\t\ttech_pvt = switch_core_session_get_private(session);\n\t\t\t\tchannel = switch_core_session_get_channel(session);\n\t\t\t\tif (tech_pvt) {\n\t\t\t\t\tswitch_mutex_lock(tech_pvt->sofia_mutex);\n\t\t\t\t\tlocked = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (session != de->session) switch_core_session_rwunlock(session);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (status >= 180 && !*sofia_private->auth_gateway_name) {\n\t\t\t\t\tconst char *gwname = switch_channel_get_variable(channel, \"sip_use_gateway\");\n\t\t\t\t\tif (!zstr(gwname)) {\n\t\t\t\t\t\tswitch_set_string(sofia_private->auth_gateway_name, gwname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!tech_pvt->call_id && sip && sip->sip_call_id && sip->sip_call_id->i_id) {\n\t\t\t\t\ttech_pvt->call_id = switch_core_session_strdup(session, sip->sip_call_id->i_id);\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_call_id\", tech_pvt->call_id);\n\t\t\t\t}\n\n\t\t\t\tif (tech_pvt->gateway_name) {\n\t\t\t\t\tgateway = sofia_reg_find_gateway(tech_pvt->gateway_name);\n\t\t\t\t}\n\n\t\t\t\tif (channel && switch_channel_down(channel)) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"Channel is already hungup.\\n\");\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* we can't find the session it must be hanging up or something else, its too late to do anything with it. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (session && tech_pvt && tech_pvt->watch_headers && sip) {\n\t\tchar msgline[512];\n\t\tint hi;\n\t\tmsg_header_t *h = NULL;\n\t\tif (sip->sip_request) {\n\t\t\th = (msg_header_t *)sip->sip_request;\n\t\t\tmsg_header_field_e(msgline, sizeof(msgline), h, 0);\n\t\t} else if (sip->sip_status) {\n\t\t\th = (msg_header_t *)sip->sip_status;\n\t\t\tmsg_header_field_e(msgline, sizeof(msgline), h, 0);\n\t\t}\n\t\tif (h) {\n\t\t\tsip_unknown_t *un = NULL;\n\t\t\tchar buf[512];\n\t\t\tchar *c = NULL;\n\n\t\t\tmsgline[sizeof(msgline)-1] = '\\0';\n\t\t\tc = strchr(msgline, '\\r');\n\t\t\tif (c) {\n\t\t\t\t*c = '\\0';\n\t\t\t}\n\n\t\t\t/* Faster (ie hash-based) search here would be nice? ie, make watch_headers a hash? */\n\n\t\t\t/* Search first in the valid headers */\n\t\t\tfor (h = h->sh_succ; h; h = h->sh_succ) {\n\t\t\t\tsip_header_t *sh = (sip_header_t *)h;\n\t\t\t\tif (!sh->sh_class->hc_name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (hi = 0; tech_pvt->watch_headers[hi]; hi++) {\n\t\t\t\t\tif (!strcasecmp(tech_pvt->watch_headers[hi], sh->sh_class->hc_name)) {\n\t\t\t\t\t\tmsg_header_field_e(buf, sizeof(buf), h, 0);\n\t\t\t\t\t\tbuf[sizeof(buf)-1] = '\\0';\n\t\t\t\t\t\tnotify_watched_header(session, msgline, sh->sh_class->hc_name, buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Search now in the unknown headers */\n\t\t\tfor (un = sip->sip_unknown; un; un = un->un_next) {\n\t\t\t\tfor (hi = 0; tech_pvt->watch_headers[hi]; hi++) {\n\t\t\t\t\tif (!strcasecmp(tech_pvt->watch_headers[hi], un->un_name)) {\n\t\t\t\t\t\tnotify_watched_header(session, msgline, un->un_name, un->un_value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sofia_test_pflag(profile, PFLAG_AUTH_ALL) && tech_pvt && tech_pvt->key && sip && (event < nua_r_set_params || event > nua_r_authenticate)) {\n\t\tsip_authorization_t const *authorization = NULL;\n\n\t\tif (sip->sip_authorization) {\n\t\t\tauthorization = sip->sip_authorization;\n\t\t} else if (sip->sip_proxy_authorization) {\n\t\t\tauthorization = sip->sip_proxy_authorization;\n\t\t}\n\n\t\tif (authorization) {\n\t\t\tchar network_ip[80] = \"\";\n\t\t\tint network_port;\n\t\t\tsofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), &network_port);\n\t\t\tauth_res = sofia_reg_parse_auth(profile, authorization, sip, de,\n\t\t\t\t\t\t\t\t\t\t\t(char *) sip->sip_request->rq_method_name, tech_pvt->key, strlen(tech_pvt->key), network_ip, network_port, NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\tREG_INVITE, NULL, NULL, NULL, NULL);\n\t\t}\n\n\t\tif ((auth_res != AUTH_OK && auth_res != AUTH_RENEWED)) {\n\t\t\t//switch_channel_hangup(channel, SWITCH_CAUSE_DESTINATION_OUT_OF_ORDER);\n\t\t\tnua_respond(nh, SIP_401_UNAUTHORIZED, TAG_END());\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (channel) {\n\t\t\tswitch_channel_set_variable(channel, \"sip_authorized\", \"true\");\n\t\t}\n\t}\n\n\tif (sip && (status == 401 || status == 407)) {\n\t\tsofia_reg_handle_sip_r_challenge(status, phrase, nua, profile, nh, sofia_private, session, gateway, sip, de, tags);\n\t\tgoto done;\n\t}\n\n\tif (sip && sip->sip_payload && sip->sip_payload->pl_data) {\n\t\tif (sip->sip_payload->pl_len != strlen(sip->sip_payload->pl_data)) {\n\t\t\tsip->sip_payload->pl_data = su_strndup(nua_handle_get_home(nh), sip->sip_payload->pl_data, sip->sip_payload->pl_len);\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase nua_r_get_params:\n\tcase nua_i_fork:\n\tcase nua_r_info:\n\t\tbreak;\n\tcase nua_r_unregister:\n\tcase nua_r_unsubscribe:\n\tcase nua_i_terminated:\n\tcase nua_r_publish:\n\tcase nua_i_error:\n\tcase nua_i_active:\n\tcase nua_r_set_params:\n\tcase nua_i_prack:\n\tcase nua_r_prack:\n\t\tbreak;\n\n\tcase nua_i_cancel:\n\n\t\tif (sip && channel) {\n\t\t\tswitch_channel_set_variable(channel, \"sip_hangup_disposition\", \"recv_cancel\");\n\t\t\tswitch_channel_set_variable(channel, \"sip_invite_failure_status\", \"487\");\n\t\t\tswitch_channel_set_variable(channel, \"sip_invite_failure_phrase\", \"CANCEL\");\n\n\t\t\tif (sip->sip_reason) {\n\t\t\t\tchar *reason_header = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_reason);\n\n\t\t\t\tif (!zstr(reason_header)) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_reason\", reason_header);\n\t\t\t\t\tswitch_channel_set_variable_partner(channel, \"sip_reason\", reason_header);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase nua_r_cancel:\n\t\t{\n\t\t\tif (status > 299 && nh) {\n\t\t\t\tnua_handle_destroy(nh);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase nua_i_ack:\n\t\t{\n\t\t\tif (channel && sip) {\n\t\t\t\tconst char *r_sdp = NULL;\n\t\t\t\tsofia_glue_store_session_id(session, profile, sip, 0);\n\n\t\t\t\tif (sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\t\t\tif (sofia_test_flag(tech_pvt, TFLAG_PASS_ACK)) {\n\t\t\t\t\t\tr_sdp = sip->sip_payload->pl_data;\n\n\t\t\t\t\t\tif (tech_pvt->mparams.last_sdp_str) {\n\t\t\t\t\t\t\ttech_pvt->mparams.prev_sdp_str = tech_pvt->mparams.last_sdp_str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttech_pvt->mparams.last_sdp_str = NULL;\n\n\n\t\t\t\t\t\tif (!zstr(tech_pvt->mparams.prev_sdp_str) && strcmp(tech_pvt->mparams.prev_sdp_str, sip->sip_payload->pl_data)) {\n\t\t\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_reinvite_sdp\", sip->sip_payload->pl_data);\n\t\t\t\t\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttech_pvt->mparams.last_sdp_str = tech_pvt->mparams.prev_sdp_str;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_reinvite_sdp\", sip->sip_payload->pl_data);\n\t\t\t\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_to && sip->sip_to->a_tag) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_to_tag\", sip->sip_to->a_tag);\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_from && sip->sip_from->a_tag) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_from_tag\", sip->sip_from->a_tag);\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_cseq && sip->sip_cseq->cs_seq) {\n\t\t\t\t\tchar sip_cseq[40] = \"\";\n\t\t\t\t\tswitch_snprintf(sip_cseq, sizeof(sip_cseq), \"%d\", sip->sip_cseq->cs_seq);\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_cseq\", sip_cseq);\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_call_id && sip->sip_call_id->i_id) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_call_id\", sip->sip_call_id->i_id);\n\t\t\t\t}\n\n\t\t\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"dlg_req_swap_direction\", \"true\");\n\t\t\t\t}\n\n\t\t\t\textract_header_vars(profile, sip, session, nh);\n\t\t\t\tswitch_core_recovery_track(session);\n\t\t\t\tsofia_set_flag(tech_pvt, TFLAG_GOT_ACK);\n\n\t\t\t\tif (switch_channel_test_flag(tech_pvt->channel, CF_PROXY_MEDIA) && r_sdp) {\n\t\t\t\t\tif (sofia_test_pflag(tech_pvt->profile, PFLAG_3PCC_PROXY)) {\n\t\t\t\t\t\tswitch_channel_set_variable_partner(tech_pvt->channel, SWITCH_B_SDP_VARIABLE, r_sdp);\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(tech_pvt->session), SWITCH_LOG_DEBUG, \"3PCC-PROXY, Got my ACK\\n\");\n\t\t\t\t\t\tsofia_media_activate_rtp(tech_pvt);\n\t\t\t\t\t\tswitch_core_media_proxy_remote_addr(tech_pvt->session, r_sdp);\n\t\t\t\t\t\tsofia_set_flag(tech_pvt, TFLAG_3PCC_HAS_ACK);\n\t\t\t\t\t\tsofia_clear_flag(tech_pvt, TFLAG_PASS_ACK);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (sofia_test_flag(tech_pvt, TFLAG_PASS_ACK)) {\n\t\t\t\t\tswitch_core_session_t *other_session;\n\n\t\t\t\t\tsofia_clear_flag(tech_pvt, TFLAG_PASS_ACK);\n\n\t\t\t\t\tif (switch_core_session_get_partner(session, &other_session) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\tif (switch_core_session_compare(session, other_session)) {\n\t\t\t\t\t\t\tprivate_object_t *other_tech_pvt = switch_core_session_get_private(other_session);\n\t\t\t\t\t\t\ttech_send_ack(other_tech_pvt->nh, other_tech_pvt, r_sdp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\tcase nua_r_ack:\n\t\tif (channel)\n\t\t\tswitch_channel_set_flag(channel, CF_MEDIA_ACK);\n\t\tbreak;\n\tcase nua_r_shutdown:\n\t\tif (status >= 200) {\n\t\t\tsofia_set_pflag(profile, PFLAG_SHUTDOWN);\n\t\t\tsu_root_break(profile->s_root);\n\t\t}\n\t\tbreak;\n\tcase nua_r_message:\n\t\tsofia_handle_sip_r_message(status, profile, nh, sip);\n\t\tbreak;\n\tcase nua_r_invite:\n\t\tsofia_handle_sip_r_invite(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_r_options:\n\t\tsofia_handle_sip_r_options(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_bye:\n\t\tsofia_handle_sip_i_bye(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_r_bye:\n\t\tsofia_handle_sip_r_bye(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_r_notify:\n\t\tif (session) {\n\t\t\tsofia_handle_sip_r_notify(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\t}\n\t\tbreak;\n\tcase nua_i_notify:\n\t\tsofia_handle_sip_i_notify(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_r_register:\n\t\tsofia_reg_handle_sip_r_register(status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_options:\n\t\tsofia_handle_sip_i_options(status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_invite:\n\t\tif (session && sofia_private) {\n\t\t\tif (sofia_private->is_call > 1) {\n\t\t\t\tsofia_handle_sip_i_reinvite(session, nua, profile, nh, sofia_private, sip, de, tags);\n\t\t\t} else {\n\t\t\t\tsofia_private->is_call++;\n\t\t\t\tsofia_handle_sip_i_invite(session, nua, profile, nh, sofia_private, sip, de, tags);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase nua_i_publish:\n\t\tsofia_presence_handle_sip_i_publish(nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_register:\n\t\t//nua_respond(nh, SIP_200_OK, SIPTAG_CONTACT(sip->sip_contact), NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());\n\t\t//nua_handle_destroy(nh);\n\t\tsofia_reg_handle_sip_i_register(nua, profile, nh, &sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_state:\n\t\tsofia_handle_sip_i_state(session, status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_message:\n\t\t{\n\t\t\tint handle_message = 1;\n\t\t\tint proxy_message = sofia_test_pflag(profile, PFLAG_PROXY_MESSAGE);\n\n\t\t\tif (!proxy_message && session) {\n\t\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(session);\n\t\t\t\tproxy_message = switch_channel_var_true(channel, \"sip_proxy_message\");\n\t\t\t}\n\n\t\t\tif (proxy_message) {\n\t\t\t\tif (sofia_proxy_sip_i_message(nua, profile, nh, session, sip, de, tags) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\thandle_message = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (handle_message) {\n\t\t\t\tsofia_presence_handle_sip_i_message(status, phrase, nua, profile, nh, session, sofia_private, sip, de, tags);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase nua_i_info:\n\t\t{\n\t\t\tint handle_info = 1;\n\t\t\tint proxy_info = sofia_test_pflag(profile, PFLAG_PROXY_INFO);\n\n\t\t\tif (!proxy_info && session) {\n\t\t\t\tswitch_channel_t *channel = switch_core_session_get_channel(session);\n\t\t\t\tproxy_info = switch_channel_var_true(channel, \"sip_proxy_info\");\n\t\t\t}\n\n\t\t\tif (proxy_info) {\n\t\t\t\tif (sofia_proxy_sip_i_info(nua, profile, nh, session, sip, de, tags) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\thandle_info = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (handle_info) {\n\t\t\t\tsofia_handle_sip_i_info(nua, profile, nh, session, sip, de, tags);\n\t\t\t}\n\n\t\t}\n\t\tbreak;\n\tcase nua_i_update:\n\t\tif (session) {\n\t\t\tsofia_update_callee_id(session, profile, sip, SWITCH_TRUE);\n\t\t}\n\t\tbreak;\n\tcase nua_r_update:\n\t\tif (session && tech_pvt && locked) {\n\t\t\tsofia_clear_flag_locked(tech_pvt, TFLAG_UPDATING_DISPLAY);\n\t\t}\n\t\tbreak;\n\tcase nua_r_refer:\n\t\tif (session) {\n\t\t\tsofia_handle_sip_r_refer(nua, profile, nh, session, status, phrase, sip, de, tags);\n\t\t}\n\t\tbreak;\n\tcase nua_i_refer:\n\t\tif (session) {\n\t\t\tsofia_handle_sip_i_refer(nua, profile, nh, session, sip, de, tags);\n\t\t} else if (sip) {\n\t\t\tconst char *req_user = NULL, *req_host = NULL, *action = NULL, *ref_by_user = NULL, *ref_to_user = NULL, *ref_to_host = NULL;\n\t\t\tchar *refer_to = NULL, *referred_by = NULL, *method = NULL, *full_url = NULL;\n\t\t\tchar *params = NULL, *iparams = NULL;\n\t\t\tswitch_event_t *event;\n\t\t\tchar *tmp;\n\n\t\t\tif (sip->sip_refer_to) {\n\t\t\t\tref_to_user = sip->sip_refer_to->r_url->url_user;\n\t\t\t\tref_to_host = sip->sip_refer_to->r_url->url_host;\n\n\t\t\t\tif (sip->sip_refer_to->r_url->url_params && switch_stristr(\"method=\", sip->sip_refer_to->r_url->url_params)) {\n\t\t\t\t\tparams = su_strdup(nua_handle_home(nh), sip->sip_refer_to->r_url->url_params);\n\t\t\t\t}\n\n\n\t\t\t\tif ((refer_to = sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_refer_to))) {\n\t\t\t\t\tif ((iparams = strchr(refer_to, ';'))) {\n\t\t\t\t\t\t*iparams++ = '\\0';\n\n\t\t\t\t\t\tif (!params || !switch_stristr(\"method=\", params)) {\n\t\t\t\t\t\t\tparams = iparams;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((tmp = sofia_glue_get_url_from_contact(refer_to, 0))) {\n\t\t\t\t\t\trefer_to = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (params) {\n\t\t\t\t\tmethod = switch_find_parameter(params, \"method\", NULL);\n\t\t\t\t\tfull_url = switch_find_parameter(params, \"full_url\", NULL);\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\tif (!method) {\n\t\t\t\tmethod = strdup(\"INVITE\");\n\t\t\t\tswitch_assert(method);\n\t\t\t}\n\n\t\t\tif (!strcasecmp(method, \"INVITE\")) {\n\t\t\t\taction = \"call\";\n\t\t\t} else if (!strcasecmp(method, \"BYE\")) {\n\t\t\t\taction = \"end\";\n\t\t\t} else {\n\t\t\t\taction = method;\n\t\t\t}\n\n\t\t\tif (sip->sip_referred_by) {\n\t\t\t\treferred_by = sofia_glue_get_url_from_contact(sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_referred_by), 0);\n\t\t\t\tref_by_user = sip->sip_referred_by->b_url->url_user;\n\t\t\t} else if(sip->sip_to){\n\t\t\t\treferred_by = sofia_glue_get_url_from_contact(sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_to), 0);\n\t\t\t\tref_by_user = sip->sip_to->a_url->url_user;\n\t\t\t}\n\n\t\t\tif (sip->sip_to) {\n\t\t\t\treq_user = sip->sip_to->a_url->url_user;\n\t\t\t\treq_host = sip->sip_to->a_url->url_host;\n\t\t\t}\n\n\t\t\tif (switch_event_create(&event, SWITCH_EVENT_CALL_SETUP_REQ) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Requesting-Component\", \"mod_sofia\");\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Target-Component\", req_user);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Target-Domain\", req_host);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Request-Action\", action);\n\t\t\t\tswitch_event_add_header(event, SWITCH_STACK_BOTTOM, \"Request-Target\", \"sofia/%s/%s\", profile->name, refer_to);\n\t\t\t\tswitch_event_add_header(event, SWITCH_STACK_BOTTOM, \"Request-Target-URI\", \"%s\", refer_to);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Request-Target-Extension\", ref_to_user);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Request-Target-Domain\", ref_to_host);\n\t\t\t\tif (switch_true(full_url)) {\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"full_url\", \"true\");\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_call_id && sip->sip_call_id->i_id) {\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"Request-Call-ID\", sip->sip_call_id->i_id);\n\t\t\t\t}\n\n\t\t\t\tif (!zstr(referred_by)) {\n\t\t\t\t\tswitch_event_add_header(event, SWITCH_STACK_BOTTOM, \"Request-Sender\", \"sofia/%s/%s\", profile->name, referred_by);\n\t\t\t\t}\n\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"var_origination_caller_id_number\", ref_by_user);\n\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"var_origination_caller_id_name\", ref_by_user);\n\t\t\t\tswitch_event_fire(&event);\n\t\t\t}\n\n\n\n\t\t\t{\n\t\t\t\tchar *sql;\n\t\t\t\tsofia_nat_parse_t np = { { 0 } };\n\t\t\t\tchar *contact_str;\n\t\t\t\tchar *proto = \"sip\", *orig_proto = \"sip\";\n\t\t\t\tconst char *call_id, *full_from, *full_to, *full_via, *from_user = NULL, *from_host = NULL, *to_user, *to_host, *full_agent;\n\t\t\t\tchar to_tag[13] = \"\";\n\t\t\t\tchar *event_str = \"refer\";\n\t\t\t\tsip_accept_t *ap = sip->sip_accept;\n\t\t\t\tchar accept_header[256] = \"\";\n\n\t\t\t\tnp.fs_path = 1;\n\t\t\t\tcontact_str = sofia_glue_gen_contact_str(profile, sip, nh, de, &np);\n\n\t\t\t\tcall_id = sip->sip_call_id ? sip->sip_call_id->i_id : \"\";\n\t\t\t\tfull_from = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_from);\n\t\t\t\tfull_to = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_to);\n\t\t\t\tfull_via = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_via);\n\n\t\t\t\tfull_agent = sip_header_as_string(nua_handle_get_home(nh), (void *) sip->sip_user_agent);\n\n\t\t\t\tswitch_stun_random_string(to_tag, 12, NULL);\n\n\t\t\t\tif (sip->sip_from) {\n\t\t\t\t\tfrom_user = sip->sip_from->a_url->url_user;\n\t\t\t\t\tfrom_host = sip->sip_from->a_url->url_host;\n\t\t\t\t} else {\n\t\t\t\t\tfrom_user = \"n/a\";\n\t\t\t\t\tfrom_host = \"n/a\";\n\t\t\t\t}\n\n\t\t\t\tif (sip->sip_to) {\n\t\t\t\t\tto_user = sip->sip_to->a_url->url_user;\n\t\t\t\t\tto_host = sip->sip_to->a_url->url_host;\n\t\t\t\t} else {\n\t\t\t\t\tto_user = \"n/a\";\n\t\t\t\t\tto_host = \"n/a\";\n\t\t\t\t}\n\n\t\t\t\twhile (ap) {\n\t\t\t\t\tswitch_snprintf(accept_header + strlen(accept_header), sizeof(accept_header) - strlen(accept_header),\n\t\t\t\t\t\t\t\t\t\"%s%s \", ap->ac_type, ap->ac_next ? \",\" : \"\");\n\t\t\t\t\tap = ap->ac_next;\n\t\t\t\t}\n\n\t\t\t\tsql = switch_mprintf(\"insert into sip_subscriptions \"\n\t\t\t\t\t\t\t\t\t \"(proto,sip_user,sip_host,sub_to_user,sub_to_host,presence_hosts,event,contact,call_id,full_from,\"\n\t\t\t\t\t\t\t\t\t \"full_via,expires,user_agent,accept,profile_name,hostname,network_port,network_ip,version,orig_proto, full_to) \"\n\t\t\t\t\t\t\t\t\t \"values ('%q','%q','%q','%q','%q','%q','%q','%q','%q','%q','%q',%ld,'%q','%q','%q','%q','%d','%q',-1,'%q','%q;tag=%q')\",\n\t\t\t\t\t\t\t\t\t proto, from_user, from_host, to_user, to_host, profile->presence_hosts ? profile->presence_hosts : \"\",\n\t\t\t\t\t\t\t\t\t event_str, contact_str, call_id, full_from, full_via,\n\t\t\t\t\t\t\t\t\t (long) switch_epoch_time_now(NULL) + 60,\n\t\t\t\t\t\t\t\t\t full_agent, accept_header, profile->name, mod_sofia_globals.hostname,\n\t\t\t\t\t\t\t\t\t np.network_port, np.network_ip, orig_proto, full_to, to_tag);\n\n\t\t\t\tswitch_assert(sql != NULL);\n\n\n\t\t\t\tif (mod_sofia_globals.debug_presence > 0 || mod_sofia_globals.debug_sla > 0) {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_CRIT, \"%s REFER SUBSCRIBE %s@%s %s@%s\\n%s\\n\",\n\t\t\t\t\t\t\t\t\t  profile->name, from_user, from_host, to_user, to_host, sql);\n\t\t\t\t}\n\n\n\t\t\t\tsofia_glue_execute_sql_now(profile, &sql, SWITCH_TRUE);\n\n\t\t\t\tsip_to_tag(nua_handle_get_home(nh), sip->sip_to, to_tag);\n\t\t\t}\n\n\t\t\tnua_respond(nh, SIP_202_ACCEPTED, SIPTAG_TO(sip->sip_to), NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());\n\t\t\tswitch_safe_free(method);\n\t\t\tswitch_safe_free(full_url);\n\n\t\t}\n\t\tbreak;\n\tcase nua_r_subscribe:\n\t\tsofia_presence_handle_sip_r_subscribe(status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_subscribe:\n\t\tsofia_presence_handle_sip_i_subscribe(status, phrase, nua, profile, nh, sofia_private, sip, de, tags);\n\t\tbreak;\n\tcase nua_i_media_error:\n\t\t{\n\n\t\t\tif (sofia_private && sofia_private->call_id && sofia_private->network_ip && sofia_private->network_port) {\n\t\t\t\tchar *sql;\n\t\t\t\tswitch_event_t *event = NULL;\n\n\t\t\t\tsql = switch_mprintf(\"delete from sip_registrations where call_id='%q' and network_ip='%q' and network_port='%q'\",\n\t\t\t\t\t\t\t\t\t\t   sofia_private->call_id, sofia_private->network_ip, sofia_private->network_port);\n\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG1, \"SOCKET DISCONNECT: %s %s:%s\\n\",\n\t\t\t\t\t\t\t\t  sofia_private->call_id, sofia_private->network_ip, sofia_private->network_port);\n\t\t\t\tsofia_glue_execute_sql(profile, &sql, SWITCH_TRUE);\n\n\t\t\t\tswitch_core_del_registration(sofia_private->user, sofia_private->realm, sofia_private->call_id);\n\n\n\n\t\t\t\tif (switch_event_create(&event, SWITCH_EVENT_PRESENCE_IN) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"proto\", SOFIA_CHAT_PROTO);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"rpid\", \"unknown\");\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"login\", profile->url);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"user-agent\",\n\t\t\t\t\t\t\t\t\t\t\t\t   (sip && sip->sip_user_agent) ? sip->sip_user_agent->g_string : \"unknown\");\n\t\t\t\t\tswitch_event_add_header(event, SWITCH_STACK_BOTTOM, \"from\", \"%s@%s\", sofia_private->user, sofia_private->realm);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"status\", \"Unregistered\");\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"presence-source\", \"register\");\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"event_type\", \"presence\");\n\t\t\t\t\tswitch_event_fire(&event);\n\t\t\t\t}\n\n\n\t\t\t\tif (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_UNREGISTER) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"profile-name\", profile->name);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"from-user\", sofia_private->user);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"from-host\", sofia_private->realm);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"call-id\", sofia_private->call_id);\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"rpid\", \"unknown\");\n\t\t\t\t\tswitch_event_add_header_string(event, SWITCH_STACK_BOTTOM, \"reason\", \"socket-disconnection\");\n\t\t\t\t\tswitch_event_fire(&event);\n\t\t\t\t}\n\n\n\t\t\t\tsofia_reg_check_socket(profile, sofia_private->call_id, sofia_private->network_ip, sofia_private->network_port);\n\t\t\t        nua_handle_destroy(nh);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase nua_r_authenticate:\n\n\t\tif (status >= 500) {\n\t\t\tif (sofia_private && !zstr(sofia_private->gateway_name)) {\n\t\t\t\tsofia_gateway_t *gateway = NULL;\n\n\t\t\t\tif ((gateway = sofia_reg_find_gateway(sofia_private->gateway_name))) {\n\t\t\t\t\tgateway->state = REG_STATE_FAILED;\n\t\t\t\t\tgateway->failure_status = status;\n\t\t\t\t\tsofia_reg_release_gateway(gateway);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnua_handle_destroy(nh);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tif (status > 100) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"%s: unknown event %d: %03d %s\\n\", nua_event_name(event), event,\n\t\t\t\t\t\t\t  status, phrase);\n\t\t} else {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"%s: unknown event %d\\n\", nua_event_name(event), event);\n\t\t}\n\t\tbreak;\n\t}\n\n  done:\n\n\tif (tech_pvt && tech_pvt->want_event && event == tech_pvt->want_event) {\n\t\ttech_pvt->want_event = 0;\n\t}\n\n\tif (sofia_private && sofia_private->call_id) {\n\t\tcheck_destroy = 0;\n\t}\n\n\tswitch (event) {\n\tcase nua_i_subscribe:\n\tcase nua_r_notify:\n\t\tcheck_destroy = 0;\n\t\tbreak;\n\n\tcase nua_i_notify:\n\n\t\tif (sip && sip->sip_event && !strcmp(sip->sip_event->o_type, \"dialog\") && sip->sip_event->o_params && !strcmp(sip->sip_event->o_params[0], \"sla\")) {\n\t\t\tcheck_destroy = 0;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((sofia_private && sofia_private == &mod_sofia_globals.destroy_private)) {\n\t\tnua_handle_bind(nh, NULL);\n\t\tnua_handle_destroy(nh);\n\t\tnh = NULL;\n\t}\n\n\tif (check_destroy) {\n\t\tif (nh && ((sofia_private && sofia_private->destroy_nh) || !nua_handle_magic(nh))) {\n\t\t\tif (sofia_private) {\n\t\t\t\tnua_handle_bind(nh, NULL);\n\t\t\t}\n\n\t\t\tif (tech_pvt && (tech_pvt->nh == nh)) {\n\t\t\t\ttech_pvt->nh = NULL;\n\t\t\t}\n\n\t\t\tnua_handle_destroy(nh);\n\t\t\tnh = NULL;\n\t\t}\n\t}\n\n\tif (sofia_private && sofia_private->destroy_me) {\n\t\tif (tech_pvt) {\n\t\t\ttech_pvt->sofia_private = NULL;\n\t\t}\n\n\t\tif (nh) {\n\t\t\tnua_handle_bind(nh, NULL);\n\t\t}\n\t\tsofia_private->destroy_me = 12;\n\t\tsofia_private_free(sofia_private);\n\n\t}\n\n\tif (gateway) {\n\t\tsofia_reg_release_gateway(gateway);\n\t}\n\n\tif (locked && tech_pvt) {\n\t\tswitch_mutex_unlock(tech_pvt->sofia_mutex);\n\t}\n\n\tif (session && session != de->session) {\n\t\tswitch_core_session_rwunlock(session);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -130,7 +130,7 @@\n \t\t}\n \n \t\tif (authorization) {\n-\t\t\tchar network_ip[80];\n+\t\t\tchar network_ip[80] = \"\";\n \t\t\tint network_port;\n \t\t\tsofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), &network_port);\n \t\t\tauth_res = sofia_reg_parse_auth(profile, authorization, sip, de,",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tchar network_ip[80];"
            ],
            "added_lines": [
                "\t\t\tchar network_ip[80] = \"\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36513",
        "func_name": "signalwire/freeswitch/sofia_handle_sip_i_notify",
        "description": "An issue was discovered in function sofia_handle_sip_i_notify in sofia.c in SignalWire freeswitch before 1.10.6, may allow attackers to view sensitive information due to an uninitialized value.",
        "git_url": "https://github.com/signalwire/freeswitch/commit/bd87b8892c260753af5672b6f865684036f157dc",
        "commit_title": "[mod_sofia] Fixed a few Usage-of-uninitialized value bugs which may cause information discolsure and bypass ACL check",
        "commit_text": "",
        "func_before": "void sofia_handle_sip_i_notify(switch_core_session_t *session, int status,\n\t\t\t\t\t\t\t   char const *phrase,\n\t\t\t\t\t\t\t   nua_t *nua, sofia_profile_t *profile, nua_handle_t *nh, sofia_private_t *sofia_private, sip_t const *sip,\n\t\t\t\t\t\t\t\tsofia_dispatch_event_t *de, tagi_t tags[])\n{\n\tswitch_channel_t *channel = NULL;\n\tprivate_object_t *tech_pvt = NULL;\n\tswitch_event_t *s_event = NULL;\n\tsofia_gateway_subscription_t *gw_sub_ptr;\n\tint sub_state;\n\tsofia_gateway_t *gateway = NULL;\n\tconst char *session_id_header = sofia_glue_session_id_header(session, profile);\n\n\ttl_gets(tags, NUTAG_SUBSTATE_REF(sub_state), TAG_END());\n\n\t/* make sure we have a proper event */\n\tif (!sip || !sip->sip_event) {\n\t\tgoto error;\n\t}\n\n\t/* Automatically return a 200 OK for Event: keep-alive */\n\tif (!strcasecmp(sip->sip_event->o_type, \"keep-alive\")) {\n\t\t/* XXX MTK - is this right? in this case isn't sofia is already sending a 200 itself also? */\n\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t\tgoto end;\n\t}\n\n\tif (session) {\n\t\tchannel = switch_core_session_get_channel(session);\n\t\tswitch_assert(channel != NULL);\n\t\ttech_pvt = switch_core_session_get_private(session);\n\t\tswitch_assert(tech_pvt != NULL);\n\t}\n\n\n\tif (tech_pvt && tech_pvt->proxy_refer_uuid && sofia_test_pflag(profile, PFLAG_PROXY_REFER) && sip->sip_payload && sip->sip_payload->pl_data &&\n\t\tsip->sip_content_type && sip->sip_content_type->c_type && switch_stristr(\"sipfrag\", sip->sip_content_type->c_type)) {\n\n\t\tif (sofia_pass_notify(session, tech_pvt->proxy_refer_uuid, sip->sip_payload->pl_data) == SWITCH_STATUS_SUCCESS) {\n\t\t\tif (tech_pvt->proxy_refer_msg) {\n\t\t\t\tmsg_ref_destroy(tech_pvt->proxy_refer_msg);\n\t\t\t\ttech_pvt->proxy_refer_msg = NULL;\n\t\t\t}\n\t\t\ttech_pvt->proxy_refer_msg = msg_ref_create(de->data->e_msg);\n\t\t\t//nua_respond(nh, SIP_202_ACCEPTED, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());\n\t\t} else {\n\t\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_DESTINATION_OUT_OF_ORDER);\n\t\t}\n\n\t\tgoto end;\n\t}\n\n\t/* For additional NOTIFY event packages see http://www.iana.org/assignments/sip-events. */\n\tif (sip->sip_content_type &&\n\t\tsip->sip_content_type->c_type && sip->sip_payload && sip->sip_payload->pl_data && !strcasecmp(sip->sip_event->o_type, \"refer\")) {\n\t\tif (switch_event_create_subclass(&s_event, SWITCH_EVENT_CUSTOM, MY_EVENT_NOTIFY_REFER) == SWITCH_STATUS_SUCCESS) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"content-type\", sip->sip_content_type->c_type);\n\t\t\tswitch_event_add_body(s_event, \"%s\", sip->sip_payload->pl_data);\n\t\t}\n\t}\n\n\t/* add common headers for the NOTIFY to the switch_event and fire if it exists */\n\tif (s_event != NULL) {\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"event-package\", sip->sip_event->o_type);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"event-id\", sip->sip_event->o_id);\n\n\t\tif (sip->sip_contact) {\n\t\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM, \"contact\", \"%s@%s\",\n\t\t\t\t\t\t\t\t\tsip->sip_contact->m_url->url_user, sip->sip_contact->m_url->url_host);\n\t\t}\n\n\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM, \"from\", \"%s@%s\", sip->sip_from->a_url->url_user, sip->sip_from->a_url->url_host);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"from-tag\", sip->sip_from->a_tag);\n\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM, \"to\", \"%s@%s\", sip->sip_to->a_url->url_user, sip->sip_to->a_url->url_host);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"to-tag\", sip->sip_to->a_tag);\n\n\t\tif (sip->sip_call_id && sip->sip_call_id->i_id) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"call-id\", sip->sip_call_id->i_id);\n\t\t}\n\t\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_substate) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"subscription-substate\", sip->sip_subscription_state->ss_substate);\n\t\t}\n\t\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_reason) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"subscription-reason\", sip->sip_subscription_state->ss_reason);\n\t\t}\n\t\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_retry_after) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"subscription-retry-after\", sip->sip_subscription_state->ss_retry_after);\n\t\t}\n\t\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_expires) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"subscription-expires\", sip->sip_subscription_state->ss_expires);\n\t\t}\n\t\tif (session) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"UniqueID\", switch_core_session_get_uuid(session));\n\t\t}\n\t\tswitch_event_fire(&s_event);\n\t}\n\n\tif (!strcasecmp(sip->sip_event->o_type, \"refer\")) {\n\t\tif (session && channel && tech_pvt) {\n\t\t\tif (sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\t\tchar *p;\n\t\t\t\tint status_val = 0;\n\t\t\t\tif ((p = strchr(sip->sip_payload->pl_data, ' '))) {\n\t\t\t\t\tp++;\n\t\t\t\t\tstatus_val = atoi(p);\n\t\t\t\t}\n\t\t\t\tif (!status_val || status_val >= 200) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_refer_reply\", sip->sip_payload->pl_data);\n\t\t\t\t\tif (status_val == 200) {\n\t\t\t\t\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_BLIND_TRANSFER);\n\t\t\t\t\t}\n\t\t\t\t\tif ((int)tech_pvt->want_event == 9999) {\n\t\t\t\t\t\ttech_pvt->want_event = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t}\n\n\t/* if no session, assume it could be an incoming notify from a gateway subscription */\n\tif (session) {\n\t\tif (!zstr(profile->proxy_notify_events) && (!strcasecmp(profile->proxy_notify_events, \"all\") || strstr(profile->proxy_notify_events, sip->sip_event->o_type))) {\n\t\t\tswitch_core_session_t *other_session;\n\t\t\tif (switch_core_session_get_partner(session, &other_session) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tprivate_object_t *other_tech_pvt = switch_core_session_get_private(other_session);\n\t\t\t\tconst char *full_to = NULL;\n\t\t\t\tchar *pl = NULL;\n\t\t\t\tchar *unknown = NULL;\n\n\t\t\t\tfull_to = switch_str_nil(switch_channel_get_variable(switch_core_session_get_channel(other_session), \"sip_full_to\"));\n\t\t\t\tif (sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\t\t\tpl = switch_core_session_strdup(other_session, (char*)sip->sip_payload->pl_data);\n\t\t\t\t}\n\t\t\t\tunknown = sofia_glue_get_non_extra_unknown_headers(sip);\n\t\t\t\tnua_notify(other_tech_pvt->nh, NUTAG_NEWSUB(1), NUTAG_SUBSTATE(nua_substate_active),\n\t\t\t\t\t\t\tTAG_IF((full_to), SIPTAG_TO_STR(full_to)), SIPTAG_SUBSCRIPTION_STATE_STR(\"active\"),\n\t\t\t\t\t\t\tSIPTAG_EVENT_STR(sip->sip_event->o_type), TAG_IF(!zstr(unknown), SIPTAG_HEADER_STR(unknown)),\n\t\t\t\t\t\t\tTAG_IF(!zstr(pl), SIPTAG_PAYLOAD_STR(pl)), \n\t\t\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)),\n\t\t\t\t\t\t\tTAG_END());\n\t\t\t\tswitch_safe_free(unknown);\n\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t}\n\t\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg),\n\t\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t\t\tgoto end;\n\t\t}\n\t\t/* make sure we have a proper \"talk\" event */\n\t\tif (strcasecmp(sip->sip_event->o_type, \"talk\")) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_INBOUND) {\n\t\t\tswitch_channel_answer(channel);\n\t\t\tswitch_channel_set_variable(channel, \"auto_answer_destination\", switch_channel_get_variable(channel, \"destination_number\"));\n\t\t\tswitch_ivr_session_transfer(session, \"auto_answer\", NULL, NULL);\n\t\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg),\n\t\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (!sofia_private || zstr(sofia_private->gateway_name)) {\n\t\tif (profile->debug) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"Gateway information missing Subscription Event: %s\\n\",\n\t\t\t\t\t\t\t  sip->sip_event->o_type);\n\t\t}\n\t\tgoto error;\n\t}\n\n\n\tif (!(gateway = sofia_reg_find_gateway(sofia_private->gateway_name))) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Gateway information missing\\n\");\n\t\tgoto error;\n\t}\n\n\t/* find the corresponding gateway subscription (if any) */\n\tif (!(gw_sub_ptr = sofia_find_gateway_subscription(gateway, sip->sip_event->o_type))) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t  \"Could not find gateway subscription.  Gateway: %s.  Subscription Event: %s\\n\",\n\t\t\t\t\t\t  gateway->name, sip->sip_event->o_type);\n\t\tgoto error;\n\t}\n\n\tif (!(gw_sub_ptr->state == SUB_STATE_SUBED || gw_sub_ptr->state == SUB_STATE_SUBSCRIBE)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_WARNING, \"Ignoring notify due to subscription state: %d\\n\", gw_sub_ptr->state);\n\t\tgoto error;\n\t}\n\n\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_expires) {\n\t\tint delta = atoi(sip->sip_subscription_state->ss_expires);\n\n\t\tdelta /= 2;\n\n\t\tif (delta < 1) {\n\t\t\tdelta = 1;\n\t\t}\n\t\tgw_sub_ptr->expires = switch_epoch_time_now(NULL) + delta;\n\t}\n\n\t/* dispatch freeswitch event */\n\tif (switch_event_create(&s_event, SWITCH_EVENT_NOTIFY_IN) == SWITCH_STATUS_SUCCESS) {\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"event\", sip->sip_event->o_type);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"pl_data\", sip->sip_payload ? sip->sip_payload->pl_data : \"\");\n\t\tif ( sip->sip_content_type != NULL )\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"sip_content_type\", sip->sip_content_type->c_type);\n\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM, \"port\", \"%d\", gateway->profile->sip_port);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"module_name\", \"mod_sofia\");\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"profile_name\", gateway->profile->name);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"profile_uri\", gateway->profile->url);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"gateway_name\", gateway->name);\n\t\tif ( sip->sip_call_info != NULL ) {\n\t\t\tsip_call_info_t *call_info = sip->sip_call_info;\n\t\t\tchar *nua_hold = sip_header_as_string(nua_handle_home(nh), (void *) call_info);\n\t\t\tsize_t cur_len = strlen(nua_hold);\n\t\t\tchar *hold = strdup(nua_hold);\n\t\t\tsu_free(nua_handle_home(nh), nua_hold);\n\n\t\t\twhile ((call_info = call_info->ci_next) != NULL) {\n\t\t\t\tchar *tmp = sip_header_as_string(nua_handle_home(nh), (void *) call_info);\n\t\t\t\tsize_t tmp_len = strlen(tmp);\n\t\t\t\tchar *tmp_hold = realloc(hold, cur_len + tmp_len + 2);\n\t\t\t\tif (!tmp_hold) {\n\t\t\t\t\t/* Avoid leak if realloc failed */\n\t\t\t\t\tfree(hold);\n\t\t\t\t}\n\t\t\t\tswitch_assert(tmp_hold);\n\t\t\t\thold = tmp_hold;\n\t\t\t\tstrncpy(hold + cur_len, \",\", 2);\n\t\t\t\tstrncpy(hold + cur_len + 1, tmp, tmp_len +1);\n\t\t\t\tsu_free(nua_handle_home(nh), tmp);\n\t\t\t\tcur_len = cur_len + tmp_len + 2;\n\t\t\t}\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"Call-Info\", hold);\n\t\t\tswitch_safe_free(hold);\n\t\t}\n\t\tswitch_event_fire(&s_event);\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"dispatched freeswitch event for message-summary NOTIFY\\n\");\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, \"Failed to create event\\n\");\n\t\tgoto error;\n\t}\n\n\tgoto end;\n\n  error:\n\n\n\tif (sip && sip->sip_event && sip->sip_event->o_type && !strcasecmp(sip->sip_event->o_type, \"message-summary\")) {\n\t\t/* unsolicited mwi, just say ok */\n\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg),\n\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)),  TAG_END());\n\n\t\tif (sofia_test_pflag(profile, PFLAG_FORWARD_MWI_NOTIFY)) {\n\t\t\tconst char *mwi_status = NULL;\n\t\t\tchar network_ip[80];\n\t\t\tuint32_t x = 0;\n\t\t\tint acl_ok = 1;\n\t\t\tchar *last_acl = NULL;\n\n\t\t\tif (sip->sip_to && sip->sip_to->a_url->url_user && sip->sip_to->a_url->url_host\n\t\t\t\t&& sip->sip_payload && sip->sip_payload->pl_data ) {\n\n\t\t\t\tsofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), NULL);\n\t\t\t\tfor (x = 0; x < profile->acl_count; x++) {\n\t\t\t\t\tlast_acl = profile->acl[x];\n\t\t\t\t\tif (!(acl_ok = switch_check_network_list_ip(network_ip, last_acl))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( acl_ok )\n\t\t\t\t{\n\t\t\t\t\tmwi_status = switch_stristr(\"Messages-Waiting: \", sip->sip_payload->pl_data);\n\n\t\t\t\t\tif ( mwi_status ) {\n\t\t\t\t\t\tchar *mwi_stat;\n\t\t\t\t\t\tmwi_status += strlen( \"Messages-Waiting: \" );\n\t\t\t\t\t\tmwi_stat = switch_strip_whitespace( mwi_status );\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t\t\t\t  \"Forwarding unsolicited MWI ( %s : %s@%s )\\n\",\n\t\t\t\t\t\t\t\t\t\t  mwi_stat, sip->sip_to->a_url->url_user, sip->sip_to->a_url->url_host );\n\t\t\t\t\t\tif (switch_event_create(&s_event, SWITCH_EVENT_MESSAGE_WAITING) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"MWI-Messages-Waiting\", mwi_stat );\n\t\t\t\t\t\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"MWI-Message-Account\", \"%s@%s\", sip->sip_to->a_url->url_user, sip->sip_to->a_url->url_host );\n\t\t\t\t\t\t\tswitch_event_fire(&s_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch_safe_free(mwi_stat);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"Dropping unsolicited MWI ( %s@%s ) because of ACL\\n\",\n\t\t\t\t\t\t\t\t\t  sip->sip_to->a_url->url_user, sip->sip_to->a_url->url_host );\n\t\t\t\t};\n\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tnua_respond(nh, 481, \"Subscription Does Not Exist\", NUTAG_WITH_THIS_MSG(de->data->e_msg),\n\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t}\n\n  end:\n\n\tif (!gateway && sub_state == nua_substate_terminated && sofia_private && sofia_private != &mod_sofia_globals.destroy_private &&\n\t\tsofia_private != &mod_sofia_globals.keep_private) {\n\t\tsofia_private->destroy_nh = 1;\n\t\tsofia_private->destroy_me = 1;\n\t}\n\n\tif (gateway) {\n\t\tsofia_reg_release_gateway(gateway);\n\t}\n\n}",
        "func": "void sofia_handle_sip_i_notify(switch_core_session_t *session, int status,\n\t\t\t\t\t\t\t   char const *phrase,\n\t\t\t\t\t\t\t   nua_t *nua, sofia_profile_t *profile, nua_handle_t *nh, sofia_private_t *sofia_private, sip_t const *sip,\n\t\t\t\t\t\t\t\tsofia_dispatch_event_t *de, tagi_t tags[])\n{\n\tswitch_channel_t *channel = NULL;\n\tprivate_object_t *tech_pvt = NULL;\n\tswitch_event_t *s_event = NULL;\n\tsofia_gateway_subscription_t *gw_sub_ptr;\n\tint sub_state;\n\tsofia_gateway_t *gateway = NULL;\n\tconst char *session_id_header = sofia_glue_session_id_header(session, profile);\n\n\ttl_gets(tags, NUTAG_SUBSTATE_REF(sub_state), TAG_END());\n\n\t/* make sure we have a proper event */\n\tif (!sip || !sip->sip_event) {\n\t\tgoto error;\n\t}\n\n\t/* Automatically return a 200 OK for Event: keep-alive */\n\tif (!strcasecmp(sip->sip_event->o_type, \"keep-alive\")) {\n\t\t/* XXX MTK - is this right? in this case isn't sofia is already sending a 200 itself also? */\n\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t\tgoto end;\n\t}\n\n\tif (session) {\n\t\tchannel = switch_core_session_get_channel(session);\n\t\tswitch_assert(channel != NULL);\n\t\ttech_pvt = switch_core_session_get_private(session);\n\t\tswitch_assert(tech_pvt != NULL);\n\t}\n\n\n\tif (tech_pvt && tech_pvt->proxy_refer_uuid && sofia_test_pflag(profile, PFLAG_PROXY_REFER) && sip->sip_payload && sip->sip_payload->pl_data &&\n\t\tsip->sip_content_type && sip->sip_content_type->c_type && switch_stristr(\"sipfrag\", sip->sip_content_type->c_type)) {\n\n\t\tif (sofia_pass_notify(session, tech_pvt->proxy_refer_uuid, sip->sip_payload->pl_data) == SWITCH_STATUS_SUCCESS) {\n\t\t\tif (tech_pvt->proxy_refer_msg) {\n\t\t\t\tmsg_ref_destroy(tech_pvt->proxy_refer_msg);\n\t\t\t\ttech_pvt->proxy_refer_msg = NULL;\n\t\t\t}\n\t\t\ttech_pvt->proxy_refer_msg = msg_ref_create(de->data->e_msg);\n\t\t\t//nua_respond(nh, SIP_202_ACCEPTED, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());\n\t\t} else {\n\t\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_DESTINATION_OUT_OF_ORDER);\n\t\t}\n\n\t\tgoto end;\n\t}\n\n\t/* For additional NOTIFY event packages see http://www.iana.org/assignments/sip-events. */\n\tif (sip->sip_content_type &&\n\t\tsip->sip_content_type->c_type && sip->sip_payload && sip->sip_payload->pl_data && !strcasecmp(sip->sip_event->o_type, \"refer\")) {\n\t\tif (switch_event_create_subclass(&s_event, SWITCH_EVENT_CUSTOM, MY_EVENT_NOTIFY_REFER) == SWITCH_STATUS_SUCCESS) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"content-type\", sip->sip_content_type->c_type);\n\t\t\tswitch_event_add_body(s_event, \"%s\", sip->sip_payload->pl_data);\n\t\t}\n\t}\n\n\t/* add common headers for the NOTIFY to the switch_event and fire if it exists */\n\tif (s_event != NULL) {\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"event-package\", sip->sip_event->o_type);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"event-id\", sip->sip_event->o_id);\n\n\t\tif (sip->sip_contact) {\n\t\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM, \"contact\", \"%s@%s\",\n\t\t\t\t\t\t\t\t\tsip->sip_contact->m_url->url_user, sip->sip_contact->m_url->url_host);\n\t\t}\n\n\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM, \"from\", \"%s@%s\", sip->sip_from->a_url->url_user, sip->sip_from->a_url->url_host);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"from-tag\", sip->sip_from->a_tag);\n\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM, \"to\", \"%s@%s\", sip->sip_to->a_url->url_user, sip->sip_to->a_url->url_host);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"to-tag\", sip->sip_to->a_tag);\n\n\t\tif (sip->sip_call_id && sip->sip_call_id->i_id) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"call-id\", sip->sip_call_id->i_id);\n\t\t}\n\t\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_substate) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"subscription-substate\", sip->sip_subscription_state->ss_substate);\n\t\t}\n\t\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_reason) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"subscription-reason\", sip->sip_subscription_state->ss_reason);\n\t\t}\n\t\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_retry_after) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"subscription-retry-after\", sip->sip_subscription_state->ss_retry_after);\n\t\t}\n\t\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_expires) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"subscription-expires\", sip->sip_subscription_state->ss_expires);\n\t\t}\n\t\tif (session) {\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"UniqueID\", switch_core_session_get_uuid(session));\n\t\t}\n\t\tswitch_event_fire(&s_event);\n\t}\n\n\tif (!strcasecmp(sip->sip_event->o_type, \"refer\")) {\n\t\tif (session && channel && tech_pvt) {\n\t\t\tif (sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\t\tchar *p;\n\t\t\t\tint status_val = 0;\n\t\t\t\tif ((p = strchr(sip->sip_payload->pl_data, ' '))) {\n\t\t\t\t\tp++;\n\t\t\t\t\tstatus_val = atoi(p);\n\t\t\t\t}\n\t\t\t\tif (!status_val || status_val >= 200) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"sip_refer_reply\", sip->sip_payload->pl_data);\n\t\t\t\t\tif (status_val == 200) {\n\t\t\t\t\t\tswitch_channel_hangup(channel, SWITCH_CAUSE_BLIND_TRANSFER);\n\t\t\t\t\t}\n\t\t\t\t\tif ((int)tech_pvt->want_event == 9999) {\n\t\t\t\t\t\ttech_pvt->want_event = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t}\n\n\t/* if no session, assume it could be an incoming notify from a gateway subscription */\n\tif (session) {\n\t\tif (!zstr(profile->proxy_notify_events) && (!strcasecmp(profile->proxy_notify_events, \"all\") || strstr(profile->proxy_notify_events, sip->sip_event->o_type))) {\n\t\t\tswitch_core_session_t *other_session;\n\t\t\tif (switch_core_session_get_partner(session, &other_session) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\tprivate_object_t *other_tech_pvt = switch_core_session_get_private(other_session);\n\t\t\t\tconst char *full_to = NULL;\n\t\t\t\tchar *pl = NULL;\n\t\t\t\tchar *unknown = NULL;\n\n\t\t\t\tfull_to = switch_str_nil(switch_channel_get_variable(switch_core_session_get_channel(other_session), \"sip_full_to\"));\n\t\t\t\tif (sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\t\t\tpl = switch_core_session_strdup(other_session, (char*)sip->sip_payload->pl_data);\n\t\t\t\t}\n\t\t\t\tunknown = sofia_glue_get_non_extra_unknown_headers(sip);\n\t\t\t\tnua_notify(other_tech_pvt->nh, NUTAG_NEWSUB(1), NUTAG_SUBSTATE(nua_substate_active),\n\t\t\t\t\t\t\tTAG_IF((full_to), SIPTAG_TO_STR(full_to)), SIPTAG_SUBSCRIPTION_STATE_STR(\"active\"),\n\t\t\t\t\t\t\tSIPTAG_EVENT_STR(sip->sip_event->o_type), TAG_IF(!zstr(unknown), SIPTAG_HEADER_STR(unknown)),\n\t\t\t\t\t\t\tTAG_IF(!zstr(pl), SIPTAG_PAYLOAD_STR(pl)), \n\t\t\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)),\n\t\t\t\t\t\t\tTAG_END());\n\t\t\t\tswitch_safe_free(unknown);\n\t\t\t\tswitch_core_session_rwunlock(other_session);\n\t\t\t}\n\t\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg),\n\t\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t\t\tgoto end;\n\t\t}\n\t\t/* make sure we have a proper \"talk\" event */\n\t\tif (strcasecmp(sip->sip_event->o_type, \"talk\")) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_INBOUND) {\n\t\t\tswitch_channel_answer(channel);\n\t\t\tswitch_channel_set_variable(channel, \"auto_answer_destination\", switch_channel_get_variable(channel, \"destination_number\"));\n\t\t\tswitch_ivr_session_transfer(session, \"auto_answer\", NULL, NULL);\n\t\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg),\n\t\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (!sofia_private || zstr(sofia_private->gateway_name)) {\n\t\tif (profile->debug) {\n\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"Gateway information missing Subscription Event: %s\\n\",\n\t\t\t\t\t\t\t  sip->sip_event->o_type);\n\t\t}\n\t\tgoto error;\n\t}\n\n\n\tif (!(gateway = sofia_reg_find_gateway(sofia_private->gateway_name))) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, \"Gateway information missing\\n\");\n\t\tgoto error;\n\t}\n\n\t/* find the corresponding gateway subscription (if any) */\n\tif (!(gw_sub_ptr = sofia_find_gateway_subscription(gateway, sip->sip_event->o_type))) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_WARNING,\n\t\t\t\t\t\t  \"Could not find gateway subscription.  Gateway: %s.  Subscription Event: %s\\n\",\n\t\t\t\t\t\t  gateway->name, sip->sip_event->o_type);\n\t\tgoto error;\n\t}\n\n\tif (!(gw_sub_ptr->state == SUB_STATE_SUBED || gw_sub_ptr->state == SUB_STATE_SUBSCRIBE)) {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_WARNING, \"Ignoring notify due to subscription state: %d\\n\", gw_sub_ptr->state);\n\t\tgoto error;\n\t}\n\n\tif (sip->sip_subscription_state && sip->sip_subscription_state->ss_expires) {\n\t\tint delta = atoi(sip->sip_subscription_state->ss_expires);\n\n\t\tdelta /= 2;\n\n\t\tif (delta < 1) {\n\t\t\tdelta = 1;\n\t\t}\n\t\tgw_sub_ptr->expires = switch_epoch_time_now(NULL) + delta;\n\t}\n\n\t/* dispatch freeswitch event */\n\tif (switch_event_create(&s_event, SWITCH_EVENT_NOTIFY_IN) == SWITCH_STATUS_SUCCESS) {\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"event\", sip->sip_event->o_type);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"pl_data\", sip->sip_payload ? sip->sip_payload->pl_data : \"\");\n\t\tif ( sip->sip_content_type != NULL )\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"sip_content_type\", sip->sip_content_type->c_type);\n\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM, \"port\", \"%d\", gateway->profile->sip_port);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"module_name\", \"mod_sofia\");\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"profile_name\", gateway->profile->name);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"profile_uri\", gateway->profile->url);\n\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"gateway_name\", gateway->name);\n\t\tif ( sip->sip_call_info != NULL ) {\n\t\t\tsip_call_info_t *call_info = sip->sip_call_info;\n\t\t\tchar *nua_hold = sip_header_as_string(nua_handle_home(nh), (void *) call_info);\n\t\t\tsize_t cur_len = strlen(nua_hold);\n\t\t\tchar *hold = strdup(nua_hold);\n\t\t\tsu_free(nua_handle_home(nh), nua_hold);\n\n\t\t\twhile ((call_info = call_info->ci_next) != NULL) {\n\t\t\t\tchar *tmp = sip_header_as_string(nua_handle_home(nh), (void *) call_info);\n\t\t\t\tsize_t tmp_len = strlen(tmp);\n\t\t\t\tchar *tmp_hold = realloc(hold, cur_len + tmp_len + 2);\n\t\t\t\tif (!tmp_hold) {\n\t\t\t\t\t/* Avoid leak if realloc failed */\n\t\t\t\t\tfree(hold);\n\t\t\t\t}\n\t\t\t\tswitch_assert(tmp_hold);\n\t\t\t\thold = tmp_hold;\n\t\t\t\tstrncpy(hold + cur_len, \",\", 2);\n\t\t\t\tstrncpy(hold + cur_len + 1, tmp, tmp_len +1);\n\t\t\t\tsu_free(nua_handle_home(nh), tmp);\n\t\t\t\tcur_len = cur_len + tmp_len + 2;\n\t\t\t}\n\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"Call-Info\", hold);\n\t\t\tswitch_safe_free(hold);\n\t\t}\n\t\tswitch_event_fire(&s_event);\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"dispatched freeswitch event for message-summary NOTIFY\\n\");\n\t} else {\n\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, \"Failed to create event\\n\");\n\t\tgoto error;\n\t}\n\n\tgoto end;\n\n  error:\n\n\n\tif (sip && sip->sip_event && sip->sip_event->o_type && !strcasecmp(sip->sip_event->o_type, \"message-summary\")) {\n\t\t/* unsolicited mwi, just say ok */\n\t\tnua_respond(nh, SIP_200_OK, NUTAG_WITH_THIS_MSG(de->data->e_msg),\n\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)),  TAG_END());\n\n\t\tif (sofia_test_pflag(profile, PFLAG_FORWARD_MWI_NOTIFY)) {\n\t\t\tconst char *mwi_status = NULL;\n\t\t\tchar network_ip[80] = \"\";\n\t\t\tuint32_t x = 0;\n\t\t\tint acl_ok = 1;\n\t\t\tchar *last_acl = NULL;\n\n\t\t\tif (sip->sip_to && sip->sip_to->a_url->url_user && sip->sip_to->a_url->url_host\n\t\t\t\t&& sip->sip_payload && sip->sip_payload->pl_data ) {\n\n\t\t\t\tsofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), NULL);\n\t\t\t\tfor (x = 0; x < profile->acl_count; x++) {\n\t\t\t\t\tlast_acl = profile->acl[x];\n\t\t\t\t\tif (!(acl_ok = switch_check_network_list_ip(network_ip, last_acl))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( acl_ok )\n\t\t\t\t{\n\t\t\t\t\tmwi_status = switch_stristr(\"Messages-Waiting: \", sip->sip_payload->pl_data);\n\n\t\t\t\t\tif ( mwi_status ) {\n\t\t\t\t\t\tchar *mwi_stat;\n\t\t\t\t\t\tmwi_status += strlen( \"Messages-Waiting: \" );\n\t\t\t\t\t\tmwi_stat = switch_strip_whitespace( mwi_status );\n\n\t\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG,\n\t\t\t\t\t\t\t\t\t\t  \"Forwarding unsolicited MWI ( %s : %s@%s )\\n\",\n\t\t\t\t\t\t\t\t\t\t  mwi_stat, sip->sip_to->a_url->url_user, sip->sip_to->a_url->url_host );\n\t\t\t\t\t\tif (switch_event_create(&s_event, SWITCH_EVENT_MESSAGE_WAITING) == SWITCH_STATUS_SUCCESS) {\n\t\t\t\t\t\t\tswitch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, \"MWI-Messages-Waiting\", mwi_stat );\n\t\t\t\t\t\t\tswitch_event_add_header(s_event, SWITCH_STACK_BOTTOM,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"MWI-Message-Account\", \"%s@%s\", sip->sip_to->a_url->url_user, sip->sip_to->a_url->url_host );\n\t\t\t\t\t\t\tswitch_event_fire(&s_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch_safe_free(mwi_stat);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, \"Dropping unsolicited MWI ( %s@%s ) because of ACL\\n\",\n\t\t\t\t\t\t\t\t\t  sip->sip_to->a_url->url_user, sip->sip_to->a_url->url_host );\n\t\t\t\t};\n\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tnua_respond(nh, 481, \"Subscription Does Not Exist\", NUTAG_WITH_THIS_MSG(de->data->e_msg),\n\t\t\t\t\tTAG_IF(!zstr(session_id_header), SIPTAG_HEADER_STR(session_id_header)), TAG_END());\n\t}\n\n  end:\n\n\tif (!gateway && sub_state == nua_substate_terminated && sofia_private && sofia_private != &mod_sofia_globals.destroy_private &&\n\t\tsofia_private != &mod_sofia_globals.keep_private) {\n\t\tsofia_private->destroy_nh = 1;\n\t\tsofia_private->destroy_me = 1;\n\t}\n\n\tif (gateway) {\n\t\tsofia_reg_release_gateway(gateway);\n\t}\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -254,7 +254,7 @@\n \n \t\tif (sofia_test_pflag(profile, PFLAG_FORWARD_MWI_NOTIFY)) {\n \t\t\tconst char *mwi_status = NULL;\n-\t\t\tchar network_ip[80];\n+\t\t\tchar network_ip[80] = \"\";\n \t\t\tuint32_t x = 0;\n \t\t\tint acl_ok = 1;\n \t\t\tchar *last_acl = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tchar network_ip[80];"
            ],
            "added_lines": [
                "\t\t\tchar network_ip[80] = \"\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36513",
        "func_name": "signalwire/freeswitch/sofia_handle_sip_i_reinvite",
        "description": "An issue was discovered in function sofia_handle_sip_i_notify in sofia.c in SignalWire freeswitch before 1.10.6, may allow attackers to view sensitive information due to an uninitialized value.",
        "git_url": "https://github.com/signalwire/freeswitch/commit/bd87b8892c260753af5672b6f865684036f157dc",
        "commit_title": "[mod_sofia] Fixed a few Usage-of-uninitialized value bugs which may cause information discolsure and bypass ACL check",
        "commit_text": "",
        "func_before": "void sofia_handle_sip_i_reinvite(switch_core_session_t *session,\n\t\t\t\t\t\t\t\t nua_t *nua, sofia_profile_t *profile, nua_handle_t *nh, sofia_private_t *sofia_private, sip_t const *sip,\n\t\t\t\t\t\t\t\tsofia_dispatch_event_t *de,\n\t\t\t\t\t\t\t\t tagi_t tags[])\n{\n\tchar *call_info = NULL;\n\tswitch_channel_t *channel = NULL;\n\tprivate_object_t *tech_pvt = NULL;\n\n\tnua_respond(nh, SIP_100_TRYING, TAG_END());\n\n\tif (session) {\n\t\tchannel = switch_core_session_get_channel(session);\n\t\ttech_pvt = switch_core_session_get_private(session);\n\n\n\t\tif (sip && sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t}\n\t}\n\n\tif (session && profile && sip && sofia_test_pflag(profile, PFLAG_TRACK_CALLS)) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(session);\n\t\tprivate_object_t *tech_pvt = (private_object_t *) switch_core_session_get_private(session);\n\t\tchar network_ip[80];\n\t\tint network_port = 0;\n\t\tchar via_space[2048];\n\t\tchar branch[16] = \"\";\n\n\t\tsofia_glue_store_session_id(session, profile, sip, 0);\n\n\t\tsofia_clear_flag(tech_pvt, TFLAG_GOT_ACK);\n\n\t\tsofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), &network_port);\n\t\tswitch_stun_random_string(branch, sizeof(branch) - 1, \"0123456789abcdef\");\n\n\t\tswitch_snprintf(via_space, sizeof(via_space), \"SIP/2.0/UDP %s;rport=%d;branch=%s\", network_ip, network_port, branch);\n\t\tswitch_channel_set_variable(channel, \"sip_full_via\", via_space);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_network_port\", \"%d\", network_port);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_recieved_port\", \"%d\", network_port);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_via_rport\", \"%d\", network_port);\n\n\t\tswitch_core_recovery_track(session);\n\t}\n\n\tif (profile && sofia_test_pflag(profile, PFLAG_MANAGE_SHARED_APPEARANCE)) {\n\t\tif (channel && sip && sip->sip_call_info) {\n\t\t\tchar *p;\n\t\t\tif ((call_info = sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_call_info))) {\n\t\t\t\tif (switch_stristr(\"appearance\", call_info)) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"presence_call_info_full\", call_info);\n\t\t\t\t\tif ((p = strchr(call_info, ';'))) {\n\t\t\t\t\t\tswitch_channel_set_variable(channel, \"presence_call_info\", p + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsu_free(nua_handle_home(nh), call_info);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (channel) {\n\t\tif (tech_pvt->mparams.last_sdp_str) {\n\t\t\ttech_pvt->mparams.prev_sdp_str = tech_pvt->mparams.last_sdp_str;\n\t\t}\n\t\ttech_pvt->mparams.last_sdp_str = NULL;\n\n\t\tif (sip && sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\tif (!zstr(tech_pvt->mparams.prev_sdp_str) && strcmp(tech_pvt->mparams.prev_sdp_str, sip->sip_payload->pl_data)) {\n\t\t\t\tswitch_channel_set_variable(channel, \"sip_reinvite_sdp\", sip->sip_payload->pl_data);\n\t\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t\t} else {\n\t\t\t\ttech_pvt->mparams.last_sdp_str = tech_pvt->mparams.prev_sdp_str;\n\t\t\t}\n\t\t}\n\n\t\tswitch_channel_execute_on(channel, \"execute_on_sip_reinvite\");\n\t}\n\n}",
        "func": "void sofia_handle_sip_i_reinvite(switch_core_session_t *session,\n\t\t\t\t\t\t\t\t nua_t *nua, sofia_profile_t *profile, nua_handle_t *nh, sofia_private_t *sofia_private, sip_t const *sip,\n\t\t\t\t\t\t\t\tsofia_dispatch_event_t *de,\n\t\t\t\t\t\t\t\t tagi_t tags[])\n{\n\tchar *call_info = NULL;\n\tswitch_channel_t *channel = NULL;\n\tprivate_object_t *tech_pvt = NULL;\n\n\tnua_respond(nh, SIP_100_TRYING, TAG_END());\n\n\tif (session) {\n\t\tchannel = switch_core_session_get_channel(session);\n\t\ttech_pvt = switch_core_session_get_private(session);\n\n\n\t\tif (sip && sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t}\n\t}\n\n\tif (session && profile && sip && sofia_test_pflag(profile, PFLAG_TRACK_CALLS)) {\n\t\tswitch_channel_t *channel = switch_core_session_get_channel(session);\n\t\tprivate_object_t *tech_pvt = (private_object_t *) switch_core_session_get_private(session);\n\t\tchar network_ip[80] = \"\";\n\t\tint network_port = 0;\n\t\tchar via_space[2048];\n\t\tchar branch[16] = \"\";\n\n\t\tsofia_glue_store_session_id(session, profile, sip, 0);\n\n\t\tsofia_clear_flag(tech_pvt, TFLAG_GOT_ACK);\n\n\t\tsofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), &network_port);\n\t\tswitch_stun_random_string(branch, sizeof(branch) - 1, \"0123456789abcdef\");\n\n\t\tswitch_snprintf(via_space, sizeof(via_space), \"SIP/2.0/UDP %s;rport=%d;branch=%s\", network_ip, network_port, branch);\n\t\tswitch_channel_set_variable(channel, \"sip_full_via\", via_space);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_network_port\", \"%d\", network_port);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_recieved_port\", \"%d\", network_port);\n\t\tswitch_channel_set_variable_printf(channel, \"sip_via_rport\", \"%d\", network_port);\n\n\t\tswitch_core_recovery_track(session);\n\t}\n\n\tif (profile && sofia_test_pflag(profile, PFLAG_MANAGE_SHARED_APPEARANCE)) {\n\t\tif (channel && sip && sip->sip_call_info) {\n\t\t\tchar *p;\n\t\t\tif ((call_info = sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_call_info))) {\n\t\t\t\tif (switch_stristr(\"appearance\", call_info)) {\n\t\t\t\t\tswitch_channel_set_variable(channel, \"presence_call_info_full\", call_info);\n\t\t\t\t\tif ((p = strchr(call_info, ';'))) {\n\t\t\t\t\t\tswitch_channel_set_variable(channel, \"presence_call_info\", p + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsu_free(nua_handle_home(nh), call_info);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (channel) {\n\t\tif (tech_pvt->mparams.last_sdp_str) {\n\t\t\ttech_pvt->mparams.prev_sdp_str = tech_pvt->mparams.last_sdp_str;\n\t\t}\n\t\ttech_pvt->mparams.last_sdp_str = NULL;\n\n\t\tif (sip && sip->sip_payload && sip->sip_payload->pl_data) {\n\t\t\tif (!zstr(tech_pvt->mparams.prev_sdp_str) && strcmp(tech_pvt->mparams.prev_sdp_str, sip->sip_payload->pl_data)) {\n\t\t\t\tswitch_channel_set_variable(channel, \"sip_reinvite_sdp\", sip->sip_payload->pl_data);\n\t\t\t\ttech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data);\n\t\t\t} else {\n\t\t\t\ttech_pvt->mparams.last_sdp_str = tech_pvt->mparams.prev_sdp_str;\n\t\t\t}\n\t\t}\n\n\t\tswitch_channel_execute_on(channel, \"execute_on_sip_reinvite\");\n\t}\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n \tif (session && profile && sip && sofia_test_pflag(profile, PFLAG_TRACK_CALLS)) {\n \t\tswitch_channel_t *channel = switch_core_session_get_channel(session);\n \t\tprivate_object_t *tech_pvt = (private_object_t *) switch_core_session_get_private(session);\n-\t\tchar network_ip[80];\n+\t\tchar network_ip[80] = \"\";\n \t\tint network_port = 0;\n \t\tchar via_space[2048];\n \t\tchar branch[16] = \"\";",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tchar network_ip[80];"
            ],
            "added_lines": [
                "\t\tchar network_ip[80] = \"\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3228",
        "func_name": "torvalds/linux/tc_fill_tclass",
        "description": "The tc_fill_tclass function in net/sched/sch_api.c in the tc subsystem in the Linux kernel 2.4.x before 2.4.37.6 and 2.6.x before 2.6.31-rc9 does not initialize certain (1) tcm__pad1 and (2) tcm__pad2 structure members, which might allow local users to obtain sensitive information from kernel memory via unspecified vectors.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=16ebb5e0b36ceadc8186f71d68b0c4fa4b6e781b",
        "commit_title": "Three bytes of uninitialized kernel memory are currently leaked to user",
        "commit_text": " ",
        "func_before": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "func": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad2 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\n\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,8 @@\n \tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n \ttcm = NLMSG_DATA(nlh);\n \ttcm->tcm_family = AF_UNSPEC;\n+\ttcm->tcm__pad1 = 0;\n+\ttcm->tcm__pad2 = 0;\n \ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n \ttcm->tcm_parent = q->handle;\n \ttcm->tcm_handle = q->handle;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\ttcm->tcm__pad1 = 0;",
                "\ttcm->tcm__pad2 = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-20739",
        "func_name": "libvips/im_vips2dz",
        "description": "im_vips2dz in /libvips/libvips/deprecated/im_vips2dz.c in libvips before 8.8.2 has an uninitialized variable which may cause the leakage of remote server path or stack address.",
        "git_url": "https://github.com/libvips/libvips/commit/2ab5aa7bf515135c2b02d42e9a72e4c98e17031a",
        "commit_title": "fix a used-before-set error in im_vips2dz",
        "commit_text": " we were reading an uninited string in a vips7 compatibility wrapper, thanks yifengchen-cc  see https://github.com/libvips/libvips/issues/1419",
        "func_before": "int\nim_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\n\t/* We can't use im_filename_split() --- it assumes that we have a\n\t * filename with an extension before the ':', and filename here is\n\t * actually a dirname.\n\t *\n\t * Just split on the first ':'.\n\t */\n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}",
        "func": "int\nim_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\n\t/* We can't use im_filename_split() --- it assumes that we have a\n\t * filename with an extension before the ':', and filename here is\n\t * actually a dirname.\n\t *\n\t * Just split on the first ':'.\n\t */\n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\telse \n\t\tstrcpy( mode, \"\" ); \n\n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\n\treturn( 0 );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,8 @@\n \t\t*p = '\\0';\n \t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n \t}\n+\telse \n+\t\tstrcpy( mode, \"\" ); \n \n \tstrcpy( buf, mode ); \n \tp = &buf[0];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\telse ",
                "\t\tstrcpy( mode, \"\" ); "
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25016",
        "func_name": "Duncaen/OpenDoas/main",
        "description": "In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.",
        "git_url": "https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168",
        "commit_title": "redo the environment inheritance to not inherit. it was intended to make life easier, but it can be surprising or even unsafe. instead, reset just about everything to the target user's values. ok deraadt martijn Thanks to Sander Bos in particular for pointing out some nasty edge cases.",
        "commit_text": "",
        "func_before": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n#ifdef __OpenBSD__\n\tchar mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];\n#else\n\tchar *mypwbuf = NULL, *targpwbuf = NULL;\n#endif\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n#ifdef USE_BSD_AUTH\n\tchar *login_style = NULL;\n#endif\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n#ifdef USE_BSD_AUTH\n# define OPTSTRING \"a:C:Lnsu:\"\n#else\n# define OPTSTRING \"+C:Lnsu:\"\n#endif\n\n\twhile ((ch = getopt(argc, argv, OPTSTRING)) != -1) {\n\t\tswitch (ch) {\n#ifdef USE_BSD_AUTH\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_BSD_AUTH)\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i == -1);\n#elif defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\tmypwbuf = reallocarray(mypwbuf, sz, sizeof (char));\n\t\tif (mypwbuf == NULL)\n\t\t\terrx(1, \"can't allocate mypwbuf\");\n\t\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sz, &mypw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(\"/etc/doas.conf\", 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(__OpenBSD__) || defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n# ifdef __OpenBSD__\n\t\tauthuser(mypw->pw_name, login_style, rule->options & PERSIST);\n# else\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n# endif\n\t}\n\n# ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n# endif\n\n#elif !defined(USE_PAM)\n\t(void) nflag;\n\tif (!(rule->options & NOPASS)) {\n\t\terrx(1, \"Authorization required\");\n\t}\n#endif /* !(__OpenBSD__ || USE_SHADOW) && !USE_PAM */\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(target, &targpwstore, targpwbuf, sizeof(targpwbuf), &targpw);\n\tif (rv != 0)\n\t\terrx(1, \"no passwd entry for target\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\ttargpwbuf = reallocarray(targpwbuf, sz, sizeof (char));\n\t\tif (targpwbuf == NULL)\n\t\t\terrx(1, \"can't allocate targpwbuf\");\n\t\trv = getpwuid_r(target, &targpwstore, targpwbuf, sz, &targpw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (targpw == NULL)\n\t\terr(1, \"getpwuid_r failed\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_SETUSERCONTEXT\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\n\tenvp = prepenv(rule);\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
        "func": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n#ifdef __OpenBSD__\n\tchar mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];\n#else\n\tchar *mypwbuf = NULL, *targpwbuf = NULL;\n#endif\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n#ifdef USE_BSD_AUTH\n\tchar *login_style = NULL;\n#endif\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n#ifdef USE_BSD_AUTH\n# define OPTSTRING \"a:C:Lnsu:\"\n#else\n# define OPTSTRING \"+C:Lnsu:\"\n#endif\n\n\twhile ((ch = getopt(argc, argv, OPTSTRING)) != -1) {\n\t\tswitch (ch) {\n#ifdef USE_BSD_AUTH\n\t\tcase 'a':\n\t\t\tlogin_style = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_BSD_AUTH)\n\t\t\ti = open(\"/dev/tty\", O_RDWR);\n\t\t\tif (i != -1)\n\t\t\t\tioctl(i, TIOCCLRVERAUTH);\n\t\t\texit(i == -1);\n#elif defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\tmypwbuf = reallocarray(mypwbuf, sz, sizeof (char));\n\t\tif (mypwbuf == NULL)\n\t\t\terrx(1, \"can't allocate mypwbuf\");\n\t\trv = getpwuid_r(uid, &mypwstore, mypwbuf, sz, &mypw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(\"/etc/doas.conf\", 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"failed command for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(__OpenBSD__) || defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n# ifdef __OpenBSD__\n\t\tauthuser(mypw->pw_name, login_style, rule->options & PERSIST);\n# else\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n# endif\n\t}\n\n# ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath getpw exec id\", NULL) == -1)\n\t\terr(1, \"pledge\");\n# endif\n\n#elif !defined(USE_PAM)\n\t(void) nflag;\n\tif (!(rule->options & NOPASS)) {\n\t\terrx(1, \"Authorization required\");\n\t}\n#endif /* !(__OpenBSD__ || USE_SHADOW) && !USE_PAM */\n\n#ifdef __OpenBSD__\n\trv = getpwuid_r(target, &targpwstore, targpwbuf, sizeof(targpwbuf), &targpw);\n\tif (rv != 0)\n\t\terrx(1, \"no passwd entry for target\");\n#else\n\tfor (size_t sz = 1024; sz <= 16*1024; sz *= 2) {\n\t\ttargpwbuf = reallocarray(targpwbuf, sz, sizeof (char));\n\t\tif (targpwbuf == NULL)\n\t\t\terrx(1, \"can't allocate targpwbuf\");\n\t\trv = getpwuid_r(target, &targpwstore, targpwbuf, sz, &targpw);\n\t\tif (rv != ERANGE)\n\t\t\tbreak;\n\t}\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n#endif\n\tif (targpw == NULL)\n\t\terr(1, \"getpwuid_r failed\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_SETUSERCONTEXT\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPATH |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio rpath exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\tif (rule->cmd) {\n\t\t/* do this again after setusercontext reset it */\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -198,6 +198,7 @@\n \n #ifdef HAVE_SETUSERCONTEXT\n \tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n+\t    LOGIN_SETPATH |\n \t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n \t    LOGIN_SETUSER) != 0)\n \t\terrx(1, \"failed to set user context for target\");\n@@ -228,9 +229,10 @@\n \tsyslog(LOG_AUTHPRIV | LOG_INFO, \"%s ran command %s as %s from %s\",\n \t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n \n-\tenvp = prepenv(rule);\n+\tenvp = prepenv(rule, mypw, targpw);\n \n \tif (rule->cmd) {\n+\t\t/* do this again after setusercontext reset it */\n \t\tif (setenv(\"PATH\", safepath, 1) == -1)\n \t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tenvp = prepenv(rule);"
            ],
            "added_lines": [
                "\t    LOGIN_SETPATH |",
                "\tenvp = prepenv(rule, mypw, targpw);",
                "\t\t/* do this again after setusercontext reset it */"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25016",
        "func_name": "Duncaen/OpenDoas/createenv",
        "description": "In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.",
        "git_url": "https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168",
        "commit_title": "redo the environment inheritance to not inherit. it was intended to make life easier, but it can be surprising or even unsafe. instead, reset just about everything to the target user's values. ok deraadt martijn Thanks to Sander Bos in particular for pointing out some nasty edge cases.",
        "commit_text": "",
        "func_before": "static struct env *\ncreateenv(const struct rule *rule)\n{\n\tstruct env *env;\n\tu_int i;\n\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\n\t\t\te = environ[i];\n\n\t\t\t/* ignore invalid or overlong names */\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\t/* ignore any later duplicates */\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn env;\n}",
        "func": "static struct env *\ncreateenv(const struct rule *rule, const struct passwd *mypw,\n    const struct passwd *targpw)\n{\n\tstruct env *env;\n\tu_int i;\n\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\n\taddnode(env, \"DOAS_USER\", mypw->pw_name);\n\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\n\t\t\te = environ[i];\n\n\t\t\t/* ignore invalid or overlong names */\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\t/* ignore any later duplicates */\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstatic const char *copyset[] = {\n\t\t\t\"DISPLAY\", \"TERM\",\n\t\t\tNULL\n\t\t};\n\n\t\taddnode(env, \"HOME\", targpw->pw_dir);\n\t\taddnode(env, \"LOGNAME\", targpw->pw_name);\n\t\taddnode(env, \"PATH\", getenv(\"PATH\"));\n\t\taddnode(env, \"SHELL\", targpw->pw_shell);\n\t\taddnode(env, \"USER\", targpw->pw_name);\n\n\t\tfillenv(env, copyset);\n\t}\n\n\treturn env;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static struct env *\n-createenv(const struct rule *rule)\n+createenv(const struct rule *rule, const struct passwd *mypw,\n+    const struct passwd *targpw)\n {\n \tstruct env *env;\n \tu_int i;\n@@ -9,6 +10,8 @@\n \t\terr(1, NULL);\n \tRB_INIT(&env->root);\n \tenv->count = 0;\n+\n+\taddnode(env, \"DOAS_USER\", mypw->pw_name);\n \n \tif (rule->options & KEEPENV) {\n \t\textern char **environ;\n@@ -38,6 +41,19 @@\n \t\t\t\tenv->count++;\n \t\t\t}\n \t\t}\n+\t} else {\n+\t\tstatic const char *copyset[] = {\n+\t\t\t\"DISPLAY\", \"TERM\",\n+\t\t\tNULL\n+\t\t};\n+\n+\t\taddnode(env, \"HOME\", targpw->pw_dir);\n+\t\taddnode(env, \"LOGNAME\", targpw->pw_name);\n+\t\taddnode(env, \"PATH\", getenv(\"PATH\"));\n+\t\taddnode(env, \"SHELL\", targpw->pw_shell);\n+\t\taddnode(env, \"USER\", targpw->pw_name);\n+\n+\t\tfillenv(env, copyset);\n \t}\n \n \treturn env;",
        "diff_line_info": {
            "deleted_lines": [
                "createenv(const struct rule *rule)"
            ],
            "added_lines": [
                "createenv(const struct rule *rule, const struct passwd *mypw,",
                "    const struct passwd *targpw)",
                "",
                "\taddnode(env, \"DOAS_USER\", mypw->pw_name);",
                "\t} else {",
                "\t\tstatic const char *copyset[] = {",
                "\t\t\t\"DISPLAY\", \"TERM\",",
                "\t\t\tNULL",
                "\t\t};",
                "",
                "\t\taddnode(env, \"HOME\", targpw->pw_dir);",
                "\t\taddnode(env, \"LOGNAME\", targpw->pw_name);",
                "\t\taddnode(env, \"PATH\", getenv(\"PATH\"));",
                "\t\taddnode(env, \"SHELL\", targpw->pw_shell);",
                "\t\taddnode(env, \"USER\", targpw->pw_name);",
                "",
                "\t\tfillenv(env, copyset);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25016",
        "func_name": "Duncaen/OpenDoas/prepenv",
        "description": "In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.",
        "git_url": "https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168",
        "commit_title": "redo the environment inheritance to not inherit. it was intended to make life easier, but it can be surprising or even unsafe. instead, reset just about everything to the target user's values. ok deraadt martijn Thanks to Sander Bos in particular for pointing out some nasty edge cases.",
        "commit_text": "",
        "func_before": "char **\nprepenv(const struct rule *rule)\n{\n\tstatic const char *safeset[] = {\n\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",\n\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",\n\t\tNULL\n\t};\n\tstruct env *env;\n\n\tenv = createenv(rule);\n\n\t/* if we started with blank, fill some defaults then apply rules */\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\n\treturn flattenenv(env);\n}",
        "func": "char **\nprepenv(const struct rule *rule, const struct passwd *mypw,\n    const struct passwd *targpw)\n{\n\tstruct env *env;\n\n\tenv = createenv(rule, mypw, targpw);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\n\treturn flattenenv(env);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,18 +1,10 @@\n char **\n-prepenv(const struct rule *rule)\n+prepenv(const struct rule *rule, const struct passwd *mypw,\n+    const struct passwd *targpw)\n {\n-\tstatic const char *safeset[] = {\n-\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",\n-\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",\n-\t\tNULL\n-\t};\n \tstruct env *env;\n \n-\tenv = createenv(rule);\n-\n-\t/* if we started with blank, fill some defaults then apply rules */\n-\tif (!(rule->options & KEEPENV))\n-\t\tfillenv(env, safeset);\n+\tenv = createenv(rule, mypw, targpw);\n \tif (rule->envlist)\n \t\tfillenv(env, rule->envlist);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "prepenv(const struct rule *rule)",
                "\tstatic const char *safeset[] = {",
                "\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",",
                "\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",",
                "\t\tNULL",
                "\t};",
                "\tenv = createenv(rule);",
                "",
                "\t/* if we started with blank, fill some defaults then apply rules */",
                "\tif (!(rule->options & KEEPENV))",
                "\t\tfillenv(env, safeset);"
            ],
            "added_lines": [
                "prepenv(const struct rule *rule, const struct passwd *mypw,",
                "    const struct passwd *targpw)",
                "\tenv = createenv(rule, mypw, targpw);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25016",
        "func_name": "Duncaen/OpenDoas/main",
        "description": "In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.",
        "git_url": "https://github.com/Duncaen/OpenDoas/commit/d5acd52e2a15c36a8e06f9103d35622933aa422d",
        "commit_title": "correctly reset path for rules without specific command",
        "commit_text": " This is a fixup for commit 01c658f8c45cb92a343be5f32aa6da70b2032168 where the behaviour was changed to not inherit the PATH variable by default.",
        "func_before": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *p;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"+C:Lnsu:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\trv = mygetpwuid_r(uid, &mypwstore, &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"command not permitted for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n\t}\n#elif !defined(USE_PAM)\n\t/* no authentication provider, only allow NOPASS rules */\n\t(void) nflag;\n\tif (!(rule->options & NOPASS))\n\t\terrx(1, \"Authorization required\");\n#endif\n\n\tif ((p = getenv(\"PATH\")) != NULL)\n\t\tformerpath = strdup(p);\n\tif (formerpath == NULL)\n\t\tformerpath = \"\";\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\n\trv = mygetpwuid_r(target, &targpwstore, &targpw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (targpw == NULL)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_LOGIN_CAP_H\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\tif (!(rule->options & NOLOG)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_INFO,\n\t\t    \"%s ran command %s as %s from %s\",\n\t\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\t}\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\t/* setusercontext set path for the next process, so reset it for us */\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t} else {\n\t\tif (setenv(\"PATH\", formerpath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", formerpath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
        "func": "int\nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *p;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"+C:Lnsu:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\trv = mygetpwuid_r(uid, &mypwstore, &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"command not permitted for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n\t}\n#elif !defined(USE_PAM)\n\t/* no authentication provider, only allow NOPASS rules */\n\t(void) nflag;\n\tif (!(rule->options & NOPASS))\n\t\terrx(1, \"Authorization required\");\n#endif\n\n\tif ((p = getenv(\"PATH\")) != NULL)\n\t\tformerpath = strdup(p);\n\tif (formerpath == NULL)\n\t\tformerpath = \"\";\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\n\trv = mygetpwuid_r(target, &targpwstore, &targpw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (targpw == NULL)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_LOGIN_CAP_H\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPATH |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\terr(1, \"failed to set PATH '%s'\", safepath);\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\tif (!(rule->options & NOLOG)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_INFO,\n\t\t    \"%s ran command %s as %s from %s\",\n\t\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\t}\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\t/* setusercontext set path for the next process, so reset it for us */\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t} else {\n\t\tif (setenv(\"PATH\", formerpath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", formerpath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -149,6 +149,7 @@\n \n #ifdef HAVE_LOGIN_CAP_H\n \tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n+\t    LOGIN_SETPATH |\n \t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n \t    LOGIN_SETUSER) != 0)\n \t\terrx(1, \"failed to set user context for target\");\n@@ -159,6 +160,8 @@\n \t\terr(1, \"initgroups\");\n \tif (setresuid(target, target, target) != 0)\n \t\terr(1, \"setresuid\");\n+\tif (setenv(\"PATH\", safepath, 1) == -1)\n+\t\terr(1, \"failed to set PATH '%s'\", safepath);\n #endif\n \n \tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    LOGIN_SETPATH |",
                "\tif (setenv(\"PATH\", safepath, 1) == -1)",
                "\t\terr(1, \"failed to set PATH '%s'\", safepath);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29647",
        "func_name": "torvalds/linux/qrtr_recvmsg",
        "description": "An issue was discovered in the Linux kernel before 5.11.11. qrtr_recvmsg in net/qrtr/qrtr.c allows attackers to obtain sensitive information from kernel memory because of a partially uninitialized data structure, aka CID-50535249f624.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=50535249f624d0072cd885bcdce4e4b6fb770160",
        "commit_title": "struct sockaddr_qrtr has a 2-byte hole, and qrtr_recvmsg() currently",
        "commit_text": "does not clear it before copying kernel data to user space.  It might be too late to name the hole since sockaddr_qrtr structure is uapi.  BUG: KMSAN: kernel-infoleak in kmsan_copy_to_user+0x9c/0xb0 mm/kmsan/kmsan_hooks.c:249 CPU: 0 PID: 29705 Comm: syz-executor.3 Not tainted 5.11.0-rc7-syzkaller #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011 Call Trace:  __dump_stack lib/dump_stack.c:79 [inline]  dump_stack+0x21c/0x280 lib/dump_stack.c:120  kmsan_report+0xfb/0x1e0 mm/kmsan/kmsan_report.c:118  kmsan_internal_check_memory+0x202/0x520 mm/kmsan/kmsan.c:402  kmsan_copy_to_user+0x9c/0xb0 mm/kmsan/kmsan_hooks.c:249  instrument_copy_to_user include/linux/instrumented.h:121 [inline]  _copy_to_user+0x1ac/0x270 lib/usercopy.c:33  copy_to_user include/linux/uaccess.h:209 [inline]  move_addr_to_user+0x3a2/0x640 net/socket.c:237  ____sys_recvmsg+0x696/0xd50 net/socket.c:2575  ___sys_recvmsg net/socket.c:2610 [inline]  do_recvmmsg+0xa97/0x22d0 net/socket.c:2710  __sys_recvmmsg net/socket.c:2789 [inline]  __do_sys_recvmmsg net/socket.c:2812 [inline]  __se_sys_recvmmsg+0x24a/0x410 net/socket.c:2805  __x64_sys_recvmmsg+0x62/0x80 net/socket.c:2805  do_syscall_64+0x9f/0x140 arch/x86/entry/common.c:48  entry_SYSCALL_64_after_hwframe+0x44/0xa9 RIP: 0033:0x465f69 Code: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48 RSP: 002b:00007f43659d6188 EFLAGS: 00000246 ORIG_RAX: 000000000000012b RAX: ffffffffffffffda RBX: 000000000056bf60 RCX: 0000000000465f69 RDX: 0000000000000008 RSI: 0000000020003e40 RDI: 0000000000000003 RBP: 00000000004bfa8f R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000010060 R11: 0000000000000246 R12: 000000000056bf60 R13: 0000000000a9fb1f R14: 00007f43659d6300 R15: 0000000000022000  Local variable ----addr@____sys_recvmsg created at:  ____sys_recvmsg+0x168/0xd50 net/socket.c:2550  ____sys_recvmsg+0x168/0xd50 net/socket.c:2550  Bytes 2-3 of 12 are uninitialized Memory access of size 12 starts at ffff88817c627b40 Data copied to user address 0000000020000140  Cc: Courtney Cavin <courtney.cavin@sonymobile.com> ",
        "func_before": "static int qrtr_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t size, int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\trelease_sock(sk);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb) {\n\t\trelease_sock(sk);\n\t\treturn rc;\n\t}\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = copied;\n\n\tif (addr) {\n\t\taddr->sq_family = AF_QIPCRTR;\n\t\taddr->sq_node = cb->src_node;\n\t\taddr->sq_port = cb->src_port;\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\n\nout:\n\tif (cb->confirm_rx)\n\t\tqrtr_send_resume_tx(cb);\n\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\n\treturn rc;\n}",
        "func": "static int qrtr_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\tsize_t size, int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, msg->msg_name);\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\trelease_sock(sk);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb) {\n\t\trelease_sock(sk);\n\t\treturn rc;\n\t}\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = copied;\n\n\tif (addr) {\n\t\t/* There is an anonymous 2-byte hole after sq_family,\n\t\t * make sure to clear it.\n\t\t */\n\t\tmemset(addr, 0, sizeof(*addr));\n\n\t\taddr->sq_family = AF_QIPCRTR;\n\t\taddr->sq_node = cb->src_node;\n\t\taddr->sq_port = cb->src_port;\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\n\nout:\n\tif (cb->confirm_rx)\n\t\tqrtr_send_resume_tx(cb);\n\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,11 @@\n \trc = copied;\n \n \tif (addr) {\n+\t\t/* There is an anonymous 2-byte hole after sq_family,\n+\t\t * make sure to clear it.\n+\t\t */\n+\t\tmemset(addr, 0, sizeof(*addr));\n+\n \t\taddr->sq_family = AF_QIPCRTR;\n \t\taddr->sq_node = cb->src_node;\n \t\taddr->sq_port = cb->src_port;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/* There is an anonymous 2-byte hole after sq_family,",
                "\t\t * make sure to clear it.",
                "\t\t */",
                "\t\tmemset(addr, 0, sizeof(*addr));",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11494",
        "func_name": "kernel/git/tip/tip/slc_bump",
        "description": "An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=08fadc32ce6239dc75fd5e869590e29bc62bbc28",
        "commit_title": "commit b9258a2cece4ec1f020715fe3554bc2e360f6264 upstream.",
        "commit_text": " struct can_frame contains some padding which is not explicitly zeroed in slc_bump. This uninitialized data will then be transmitted if the stack initialization hardening feature is not enabled (CONFIG_INIT_STACK_ALL).  This commit just zeroes the whole struct including the padding.  Cc: linux-can@vger.kernel.org Cc: netdev@vger.kernel.org Cc: security@kernel.org Cc: wg@grandegger.com Cc: mkl@pengutronix.de Cc: davem@davemloft.net ",
        "func_before": "static void slc_bump(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tcf.can_id = 0;\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 't':\n\t\t/* store dlc ASCII value and terminate SFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 'T':\n\t\tcf.can_id |= CAN_EFF_FLAG;\n\t\t/* store dlc ASCII value and terminate EFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n\t\treturn;\n\n\tcf.can_id |= tmpid;\n\n\t/* get can_dlc from sanitized ASCII value */\n\tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n\t\tcf.can_dlc -= '0';\n\telse\n\t\treturn;\n\n\t*(u64 *) (&cf.data) = 0; /* clear payload */\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf.can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf.can_dlc; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] |= tmp;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(sizeof(struct can_frame) +\n\t\t\t    sizeof(struct can_skb_priv));\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = sl->dev;\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n\n\tmemcpy(skb_put(skb, sizeof(struct can_frame)),\n\t       &cf, sizeof(struct can_frame));\n\tnetif_rx_ni(skb);\n\n\tsl->dev->stats.rx_packets++;\n\tsl->dev->stats.rx_bytes += cf.can_dlc;\n}",
        "func": "static void slc_bump(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 't':\n\t\t/* store dlc ASCII value and terminate SFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf.can_id = CAN_RTR_FLAG;\n\t\t/* fallthrough */\n\tcase 'T':\n\t\tcf.can_id |= CAN_EFF_FLAG;\n\t\t/* store dlc ASCII value and terminate EFF CAN ID string */\n\t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n\t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n\t\t/* point to payload data behind the dlc */\n\t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n\t\treturn;\n\n\tcf.can_id |= tmpid;\n\n\t/* get can_dlc from sanitized ASCII value */\n\tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n\t\tcf.can_dlc -= '0';\n\telse\n\t\treturn;\n\n\t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n\tif (!(cf.can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf.can_dlc; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\treturn;\n\t\t\tcf.data[i] |= tmp;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(sizeof(struct can_frame) +\n\t\t\t    sizeof(struct can_skb_priv));\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = sl->dev;\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n\n\tmemcpy(skb_put(skb, sizeof(struct can_frame)),\n\t       &cf, sizeof(struct can_frame));\n\tnetif_rx_ni(skb);\n\n\tsl->dev->stats.rx_packets++;\n\tsl->dev->stats.rx_bytes += cf.can_dlc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \tu32 tmpid;\n \tchar *cmd = sl->rbuff;\n \n-\tcf.can_id = 0;\n+\tmemset(&cf, 0, sizeof(cf));\n \n \tswitch (*cmd) {\n \tcase 'r':\n@@ -45,8 +45,6 @@\n \telse\n \t\treturn;\n \n-\t*(u64 *) (&cf.data) = 0; /* clear payload */\n-\n \t/* RTR frames may have a dlc > 0 but they never have any data bytes */\n \tif (!(cf.can_id & CAN_RTR_FLAG)) {\n \t\tfor (i = 0; i < cf.can_dlc; i++) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tcf.can_id = 0;",
                "\t*(u64 *) (&cf.data) = 0; /* clear payload */",
                ""
            ],
            "added_lines": [
                "\tmemset(&cf, 0, sizeof(cf));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11740",
        "func_name": "xen-project/xen/alloc_xenoprof_struct",
        "description": "An issue was discovered in xenoprof in Xen through 4.13.x, allowing guest OS users (without active profiling) to obtain sensitive information about other guests. Unprivileged guests can request to map xenoprof buffers, even if profiling has not been enabled for those guests. These buffers were not scrubbed.",
        "git_url": "https://github.com/xen-project/xen/commit/0763a7ebfcdad66cf9e5475a1301eefb29bae9ed",
        "commit_title": "xenoprof: clear buffer intended to be shared with guests",
        "commit_text": " alloc_xenheap_pages() making use of MEMF_no_scrub is fine for Xen internally used allocations, but buffers allocated to be shared with (unpriviliged) guests need to be zapped of their prior content.  This is part of XSA-313. ",
        "func_before": "static int alloc_xenoprof_struct(\n    struct domain *d, int max_samples, int is_passive)\n{\n    struct vcpu *v;\n    int nvcpu, npages, bufsize, max_bufsize;\n    unsigned max_max_samples;\n    int i;\n\n    nvcpu = 0;\n    for_each_vcpu ( d, v )\n        nvcpu++;\n\n    if ( !nvcpu )\n        return -EINVAL;\n\n    d->xenoprof = xzalloc(struct xenoprof);\n    if ( d->xenoprof == NULL )\n    {\n        printk(\"alloc_xenoprof_struct(): memory allocation failed\\n\");\n        return -ENOMEM;\n    }\n\n    d->xenoprof->vcpu = xzalloc_array(struct xenoprof_vcpu, d->max_vcpus);\n    if ( d->xenoprof->vcpu == NULL )\n    {\n        xfree(d->xenoprof);\n        d->xenoprof = NULL;\n        printk(\"alloc_xenoprof_struct(): vcpu array allocation failed\\n\");\n        return -ENOMEM;\n    }\n\n    bufsize = sizeof(struct xenoprof_buf);\n    i = sizeof(struct event_log);\n#ifdef CONFIG_COMPAT\n    d->xenoprof->is_compat = is_pv_32bit_domain(is_passive ? hardware_domain : d);\n    if ( XENOPROF_COMPAT(d->xenoprof) )\n    {\n        bufsize = sizeof(struct compat_oprof_buf);\n        i = sizeof(struct compat_event_log);\n    }\n#endif\n\n    /* reduce max_samples if necessary to limit pages allocated */\n    max_bufsize = (MAX_OPROF_SHARED_PAGES * PAGE_SIZE) / nvcpu;\n    max_max_samples = ( (max_bufsize - bufsize) / i ) + 1;\n    if ( (unsigned)max_samples > max_max_samples )\n        max_samples = max_max_samples;\n\n    bufsize += (max_samples - 1) * i;\n    npages = (nvcpu * bufsize - 1) / PAGE_SIZE + 1;\n\n    d->xenoprof->rawbuf = alloc_xenheap_pages(get_order_from_pages(npages), 0);\n    if ( d->xenoprof->rawbuf == NULL )\n    {\n        xfree(d->xenoprof->vcpu);\n        xfree(d->xenoprof);\n        d->xenoprof = NULL;\n        return -ENOMEM;\n    }\n\n    d->xenoprof->npages = npages;\n    d->xenoprof->nbuf = nvcpu;\n    d->xenoprof->bufsize = bufsize;\n    d->xenoprof->domain_ready = 0;\n    d->xenoprof->domain_type = XENOPROF_DOMAIN_IGNORED;\n\n    /* Update buffer pointers for active vcpus */\n    i = 0;\n    for_each_vcpu ( d, v )\n    {\n        xenoprof_buf_t *buf = (xenoprof_buf_t *)\n            &d->xenoprof->rawbuf[i * bufsize];\n\n        d->xenoprof->vcpu[v->vcpu_id].event_size = max_samples;\n        d->xenoprof->vcpu[v->vcpu_id].buffer = buf;\n        xenoprof_buf(d, buf, event_size) = max_samples;\n        xenoprof_buf(d, buf, vcpu_id) = v->vcpu_id;\n\n        i++;\n        /* in the unlikely case that the number of active vcpus changes */\n        if ( i >= nvcpu )\n            break;\n    }\n    \n    return 0;\n}",
        "func": "static int alloc_xenoprof_struct(\n    struct domain *d, int max_samples, int is_passive)\n{\n    struct vcpu *v;\n    int nvcpu, npages, bufsize, max_bufsize;\n    unsigned max_max_samples;\n    int i;\n\n    nvcpu = 0;\n    for_each_vcpu ( d, v )\n        nvcpu++;\n\n    if ( !nvcpu )\n        return -EINVAL;\n\n    d->xenoprof = xzalloc(struct xenoprof);\n    if ( d->xenoprof == NULL )\n    {\n        printk(\"alloc_xenoprof_struct(): memory allocation failed\\n\");\n        return -ENOMEM;\n    }\n\n    d->xenoprof->vcpu = xzalloc_array(struct xenoprof_vcpu, d->max_vcpus);\n    if ( d->xenoprof->vcpu == NULL )\n    {\n        xfree(d->xenoprof);\n        d->xenoprof = NULL;\n        printk(\"alloc_xenoprof_struct(): vcpu array allocation failed\\n\");\n        return -ENOMEM;\n    }\n\n    bufsize = sizeof(struct xenoprof_buf);\n    i = sizeof(struct event_log);\n#ifdef CONFIG_COMPAT\n    d->xenoprof->is_compat = is_pv_32bit_domain(is_passive ? hardware_domain : d);\n    if ( XENOPROF_COMPAT(d->xenoprof) )\n    {\n        bufsize = sizeof(struct compat_oprof_buf);\n        i = sizeof(struct compat_event_log);\n    }\n#endif\n\n    /* reduce max_samples if necessary to limit pages allocated */\n    max_bufsize = (MAX_OPROF_SHARED_PAGES * PAGE_SIZE) / nvcpu;\n    max_max_samples = ( (max_bufsize - bufsize) / i ) + 1;\n    if ( (unsigned)max_samples > max_max_samples )\n        max_samples = max_max_samples;\n\n    bufsize += (max_samples - 1) * i;\n    npages = (nvcpu * bufsize - 1) / PAGE_SIZE + 1;\n\n    d->xenoprof->rawbuf = alloc_xenheap_pages(get_order_from_pages(npages), 0);\n    if ( d->xenoprof->rawbuf == NULL )\n    {\n        xfree(d->xenoprof->vcpu);\n        xfree(d->xenoprof);\n        d->xenoprof = NULL;\n        return -ENOMEM;\n    }\n\n    for ( i = 0; i < npages; ++i )\n        clear_page(d->xenoprof->rawbuf + i * PAGE_SIZE);\n\n    d->xenoprof->npages = npages;\n    d->xenoprof->nbuf = nvcpu;\n    d->xenoprof->bufsize = bufsize;\n    d->xenoprof->domain_ready = 0;\n    d->xenoprof->domain_type = XENOPROF_DOMAIN_IGNORED;\n\n    /* Update buffer pointers for active vcpus */\n    i = 0;\n    for_each_vcpu ( d, v )\n    {\n        xenoprof_buf_t *buf = (xenoprof_buf_t *)\n            &d->xenoprof->rawbuf[i * bufsize];\n\n        d->xenoprof->vcpu[v->vcpu_id].event_size = max_samples;\n        d->xenoprof->vcpu[v->vcpu_id].buffer = buf;\n        xenoprof_buf(d, buf, event_size) = max_samples;\n        xenoprof_buf(d, buf, vcpu_id) = v->vcpu_id;\n\n        i++;\n        /* in the unlikely case that the number of active vcpus changes */\n        if ( i >= nvcpu )\n            break;\n    }\n    \n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,6 +58,9 @@\n         return -ENOMEM;\n     }\n \n+    for ( i = 0; i < npages; ++i )\n+        clear_page(d->xenoprof->rawbuf + i * PAGE_SIZE);\n+\n     d->xenoprof->npages = npages;\n     d->xenoprof->nbuf = nvcpu;\n     d->xenoprof->bufsize = bufsize;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    for ( i = 0; i < npages; ++i )",
                "        clear_page(d->xenoprof->rawbuf + i * PAGE_SIZE);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11740",
        "func_name": "xen-project/xen/xenoprof_buf_space",
        "description": "An issue was discovered in xenoprof in Xen through 4.13.x, allowing guest OS users (without active profiling) to obtain sensitive information about other guests. Unprivileged guests can request to map xenoprof buffers, even if profiling has not been enabled for those guests. These buffers were not scrubbed.",
        "git_url": "https://github.com/xen-project/xen/commit/50ef9a3cb26e2f9383f6fdfbed361d8f174bae9f",
        "commit_title": "xenoprof: limit consumption of shared buffer data",
        "commit_text": " Since a shared buffer can be written to by the guest, we may only read the head and tail pointers from there (all other fields should only ever be written to). Furthermore, for any particular operation the two values must be read exactly once, with both checks and consumption happening with the thus read values. (The backtrace related xenoprof_buf_space() use in xenoprof_log_event() is an exception: The values used there get re-checked by every subsequent xenoprof_add_sample().)  Since that code needed touching, also fix the double increment of the lost samples count in case the backtrace related xenoprof_add_sample() invocation in xenoprof_log_event() fails.  Where code is being touched anyway, add const as appropriate, but take the opportunity to entirely drop the now unused domain parameter of xenoprof_buf_space().  This is part of XSA-313. ",
        "func_before": "static int xenoprof_buf_space(struct domain *d, xenoprof_buf_t * buf, int size)\n{\n    int head, tail;\n\n    head = xenoprof_buf(d, buf, event_head);\n    tail = xenoprof_buf(d, buf, event_tail);\n\n    return ((tail > head) ? 0 : size) + tail - head - 1;\n}",
        "func": "static int xenoprof_buf_space(int head, int tail, int size)\n{\n    return ((tail > head) ? 0 : size) + tail - head - 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,4 @@\n-static int xenoprof_buf_space(struct domain *d, xenoprof_buf_t * buf, int size)\n+static int xenoprof_buf_space(int head, int tail, int size)\n {\n-    int head, tail;\n-\n-    head = xenoprof_buf(d, buf, event_head);\n-    tail = xenoprof_buf(d, buf, event_tail);\n-\n     return ((tail > head) ? 0 : size) + tail - head - 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int xenoprof_buf_space(struct domain *d, xenoprof_buf_t * buf, int size)",
                "    int head, tail;",
                "",
                "    head = xenoprof_buf(d, buf, event_head);",
                "    tail = xenoprof_buf(d, buf, event_tail);",
                ""
            ],
            "added_lines": [
                "static int xenoprof_buf_space(int head, int tail, int size)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11740",
        "func_name": "xen-project/xen/xenoprof_log_event",
        "description": "An issue was discovered in xenoprof in Xen through 4.13.x, allowing guest OS users (without active profiling) to obtain sensitive information about other guests. Unprivileged guests can request to map xenoprof buffers, even if profiling has not been enabled for those guests. These buffers were not scrubbed.",
        "git_url": "https://github.com/xen-project/xen/commit/50ef9a3cb26e2f9383f6fdfbed361d8f174bae9f",
        "commit_title": "xenoprof: limit consumption of shared buffer data",
        "commit_text": " Since a shared buffer can be written to by the guest, we may only read the head and tail pointers from there (all other fields should only ever be written to). Furthermore, for any particular operation the two values must be read exactly once, with both checks and consumption happening with the thus read values. (The backtrace related xenoprof_buf_space() use in xenoprof_log_event() is an exception: The values used there get re-checked by every subsequent xenoprof_add_sample().)  Since that code needed touching, also fix the double increment of the lost samples count in case the backtrace related xenoprof_add_sample() invocation in xenoprof_log_event() fails.  Where code is being touched anyway, add const as appropriate, but take the opportunity to entirely drop the now unused domain parameter of xenoprof_buf_space().  This is part of XSA-313. ",
        "func_before": "void xenoprof_log_event(struct vcpu *vcpu, const struct cpu_user_regs *regs,\n                        uint64_t pc, int mode, int event)\n{\n    struct domain *d = vcpu->domain;\n    struct xenoprof_vcpu *v;\n    xenoprof_buf_t *buf;\n\n    total_samples++;\n\n    /* Ignore samples of un-monitored domains. */\n    if ( !is_profiled(d) )\n    {\n        others_samples++;\n        return;\n    }\n\n    v = &d->xenoprof->vcpu[vcpu->vcpu_id];\n    if ( v->buffer == NULL )\n    {\n        invalid_buffer_samples++;\n        return;\n    }\n    \n    buf = v->buffer;\n\n    /* Provide backtrace if requested. */\n    if ( backtrace_depth > 0 )\n    {\n        if ( (xenoprof_buf_space(d, buf, v->event_size) < 2) ||\n             !xenoprof_add_sample(d, buf, XENOPROF_ESCAPE_CODE, mode, \n                                  XENOPROF_TRACE_BEGIN) )\n        {\n            xenoprof_buf(d, buf, lost_samples)++;\n            lost_samples++;\n            return;\n        }\n    }\n\n    if ( xenoprof_add_sample(d, buf, pc, mode, event) )\n    {\n        if ( is_active(vcpu->domain) )\n            active_samples++;\n        else\n            passive_samples++;\n        if ( mode == 0 )\n            xenoprof_buf(d, buf, user_samples)++;\n        else if ( mode == 1 )\n            xenoprof_buf(d, buf, kernel_samples)++;\n        else\n            xenoprof_buf(d, buf, xen_samples)++;\n    \n    }\n\n    if ( backtrace_depth > 0 )\n        xenoprof_backtrace(vcpu, regs, backtrace_depth, mode);\n}",
        "func": "void xenoprof_log_event(struct vcpu *vcpu, const struct cpu_user_regs *regs,\n                        uint64_t pc, int mode, int event)\n{\n    struct domain *d = vcpu->domain;\n    struct xenoprof_vcpu *v;\n    xenoprof_buf_t *buf;\n\n    total_samples++;\n\n    /* Ignore samples of un-monitored domains. */\n    if ( !is_profiled(d) )\n    {\n        others_samples++;\n        return;\n    }\n\n    v = &d->xenoprof->vcpu[vcpu->vcpu_id];\n    if ( v->buffer == NULL )\n    {\n        invalid_buffer_samples++;\n        return;\n    }\n    \n    buf = v->buffer;\n\n    /* Provide backtrace if requested. */\n    if ( backtrace_depth > 0 )\n    {\n        if ( xenoprof_buf_space(xenoprof_buf(d, buf, event_head),\n                                xenoprof_buf(d, buf, event_tail),\n                                v->event_size) < 2 )\n        {\n            xenoprof_buf(d, buf, lost_samples)++;\n            lost_samples++;\n            return;\n        }\n\n        /* xenoprof_add_sample() will increment lost_samples on failure */\n        if ( !xenoprof_add_sample(d, v, XENOPROF_ESCAPE_CODE, mode,\n                                  XENOPROF_TRACE_BEGIN) )\n            return;\n    }\n\n    if ( xenoprof_add_sample(d, v, pc, mode, event) )\n    {\n        if ( is_active(vcpu->domain) )\n            active_samples++;\n        else\n            passive_samples++;\n        if ( mode == 0 )\n            xenoprof_buf(d, buf, user_samples)++;\n        else if ( mode == 1 )\n            xenoprof_buf(d, buf, kernel_samples)++;\n        else\n            xenoprof_buf(d, buf, xen_samples)++;\n    \n    }\n\n    if ( backtrace_depth > 0 )\n        xenoprof_backtrace(vcpu, regs, backtrace_depth, mode);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,17 +26,22 @@\n     /* Provide backtrace if requested. */\n     if ( backtrace_depth > 0 )\n     {\n-        if ( (xenoprof_buf_space(d, buf, v->event_size) < 2) ||\n-             !xenoprof_add_sample(d, buf, XENOPROF_ESCAPE_CODE, mode, \n-                                  XENOPROF_TRACE_BEGIN) )\n+        if ( xenoprof_buf_space(xenoprof_buf(d, buf, event_head),\n+                                xenoprof_buf(d, buf, event_tail),\n+                                v->event_size) < 2 )\n         {\n             xenoprof_buf(d, buf, lost_samples)++;\n             lost_samples++;\n             return;\n         }\n+\n+        /* xenoprof_add_sample() will increment lost_samples on failure */\n+        if ( !xenoprof_add_sample(d, v, XENOPROF_ESCAPE_CODE, mode,\n+                                  XENOPROF_TRACE_BEGIN) )\n+            return;\n     }\n \n-    if ( xenoprof_add_sample(d, buf, pc, mode, event) )\n+    if ( xenoprof_add_sample(d, v, pc, mode, event) )\n     {\n         if ( is_active(vcpu->domain) )\n             active_samples++;",
        "diff_line_info": {
            "deleted_lines": [
                "        if ( (xenoprof_buf_space(d, buf, v->event_size) < 2) ||",
                "             !xenoprof_add_sample(d, buf, XENOPROF_ESCAPE_CODE, mode, ",
                "                                  XENOPROF_TRACE_BEGIN) )",
                "    if ( xenoprof_add_sample(d, buf, pc, mode, event) )"
            ],
            "added_lines": [
                "        if ( xenoprof_buf_space(xenoprof_buf(d, buf, event_head),",
                "                                xenoprof_buf(d, buf, event_tail),",
                "                                v->event_size) < 2 )",
                "",
                "        /* xenoprof_add_sample() will increment lost_samples on failure */",
                "        if ( !xenoprof_add_sample(d, v, XENOPROF_ESCAPE_CODE, mode,",
                "                                  XENOPROF_TRACE_BEGIN) )",
                "            return;",
                "    if ( xenoprof_add_sample(d, v, pc, mode, event) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11740",
        "func_name": "xen-project/xen/xenoprof_add_trace",
        "description": "An issue was discovered in xenoprof in Xen through 4.13.x, allowing guest OS users (without active profiling) to obtain sensitive information about other guests. Unprivileged guests can request to map xenoprof buffers, even if profiling has not been enabled for those guests. These buffers were not scrubbed.",
        "git_url": "https://github.com/xen-project/xen/commit/50ef9a3cb26e2f9383f6fdfbed361d8f174bae9f",
        "commit_title": "xenoprof: limit consumption of shared buffer data",
        "commit_text": " Since a shared buffer can be written to by the guest, we may only read the head and tail pointers from there (all other fields should only ever be written to). Furthermore, for any particular operation the two values must be read exactly once, with both checks and consumption happening with the thus read values. (The backtrace related xenoprof_buf_space() use in xenoprof_log_event() is an exception: The values used there get re-checked by every subsequent xenoprof_add_sample().)  Since that code needed touching, also fix the double increment of the lost samples count in case the backtrace related xenoprof_add_sample() invocation in xenoprof_log_event() fails.  Where code is being touched anyway, add const as appropriate, but take the opportunity to entirely drop the now unused domain parameter of xenoprof_buf_space().  This is part of XSA-313. ",
        "func_before": "int xenoprof_add_trace(struct vcpu *vcpu, uint64_t pc, int mode)\n{\n    struct domain *d = vcpu->domain;\n    xenoprof_buf_t *buf = d->xenoprof->vcpu[vcpu->vcpu_id].buffer;\n\n    /* Do not accidentally write an escape code due to a broken frame. */\n    if ( pc == XENOPROF_ESCAPE_CODE )\n    {\n        invalid_buffer_samples++;\n        return 0;\n    }\n\n    return xenoprof_add_sample(d, buf, pc, mode, 0);\n}",
        "func": "int xenoprof_add_trace(struct vcpu *vcpu, uint64_t pc, int mode)\n{\n    struct domain *d = vcpu->domain;\n\n    /* Do not accidentally write an escape code due to a broken frame. */\n    if ( pc == XENOPROF_ESCAPE_CODE )\n    {\n        invalid_buffer_samples++;\n        return 0;\n    }\n\n    return xenoprof_add_sample(d, &d->xenoprof->vcpu[vcpu->vcpu_id],\n                               pc, mode, 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,6 @@\n int xenoprof_add_trace(struct vcpu *vcpu, uint64_t pc, int mode)\n {\n     struct domain *d = vcpu->domain;\n-    xenoprof_buf_t *buf = d->xenoprof->vcpu[vcpu->vcpu_id].buffer;\n \n     /* Do not accidentally write an escape code due to a broken frame. */\n     if ( pc == XENOPROF_ESCAPE_CODE )\n@@ -10,5 +9,6 @@\n         return 0;\n     }\n \n-    return xenoprof_add_sample(d, buf, pc, mode, 0);\n+    return xenoprof_add_sample(d, &d->xenoprof->vcpu[vcpu->vcpu_id],\n+                               pc, mode, 0);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    xenoprof_buf_t *buf = d->xenoprof->vcpu[vcpu->vcpu_id].buffer;",
                "    return xenoprof_add_sample(d, buf, pc, mode, 0);"
            ],
            "added_lines": [
                "    return xenoprof_add_sample(d, &d->xenoprof->vcpu[vcpu->vcpu_id],",
                "                               pc, mode, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11740",
        "func_name": "xen-project/xen/xenoprof_add_sample",
        "description": "An issue was discovered in xenoprof in Xen through 4.13.x, allowing guest OS users (without active profiling) to obtain sensitive information about other guests. Unprivileged guests can request to map xenoprof buffers, even if profiling has not been enabled for those guests. These buffers were not scrubbed.",
        "git_url": "https://github.com/xen-project/xen/commit/50ef9a3cb26e2f9383f6fdfbed361d8f174bae9f",
        "commit_title": "xenoprof: limit consumption of shared buffer data",
        "commit_text": " Since a shared buffer can be written to by the guest, we may only read the head and tail pointers from there (all other fields should only ever be written to). Furthermore, for any particular operation the two values must be read exactly once, with both checks and consumption happening with the thus read values. (The backtrace related xenoprof_buf_space() use in xenoprof_log_event() is an exception: The values used there get re-checked by every subsequent xenoprof_add_sample().)  Since that code needed touching, also fix the double increment of the lost samples count in case the backtrace related xenoprof_add_sample() invocation in xenoprof_log_event() fails.  Where code is being touched anyway, add const as appropriate, but take the opportunity to entirely drop the now unused domain parameter of xenoprof_buf_space().  This is part of XSA-313. ",
        "func_before": "static int xenoprof_add_sample(struct domain *d, xenoprof_buf_t *buf,\n                               uint64_t eip, int mode, int event)\n{\n    int head, tail, size;\n\n    head = xenoprof_buf(d, buf, event_head);\n    tail = xenoprof_buf(d, buf, event_tail);\n    size = xenoprof_buf(d, buf, event_size);\n    \n    /* make sure indexes in shared buffer are sane */\n    if ( (head < 0) || (head >= size) || (tail < 0) || (tail >= size) )\n    {\n        corrupted_buffer_samples++;\n        return 0;\n    }\n\n    if ( xenoprof_buf_space(d, buf, size) > 0 )\n    {\n        xenoprof_buf(d, buf, event_log[head].eip) = eip;\n        xenoprof_buf(d, buf, event_log[head].mode) = mode;\n        xenoprof_buf(d, buf, event_log[head].event) = event;\n        head++;\n        if ( head >= size )\n            head = 0;\n        \n        xenoprof_buf(d, buf, event_head) = head;\n    }\n    else\n    {\n        xenoprof_buf(d, buf, lost_samples)++;\n        lost_samples++;\n        return 0;\n    }\n\n    return 1;\n}",
        "func": "static int xenoprof_add_sample(const struct domain *d,\n                               const struct xenoprof_vcpu *v,\n                               uint64_t eip, int mode, int event)\n{\n    xenoprof_buf_t *buf = v->buffer;\n    int head, tail, size;\n\n    head = xenoprof_buf(d, buf, event_head);\n    tail = xenoprof_buf(d, buf, event_tail);\n    size = v->event_size;\n    \n    /* make sure indexes in shared buffer are sane */\n    if ( (head < 0) || (head >= size) || (tail < 0) || (tail >= size) )\n    {\n        corrupted_buffer_samples++;\n        return 0;\n    }\n\n    if ( xenoprof_buf_space(head, tail, size) > 0 )\n    {\n        xenoprof_buf(d, buf, event_log[head].eip) = eip;\n        xenoprof_buf(d, buf, event_log[head].mode) = mode;\n        xenoprof_buf(d, buf, event_log[head].event) = event;\n        head++;\n        if ( head >= size )\n            head = 0;\n        \n        xenoprof_buf(d, buf, event_head) = head;\n    }\n    else\n    {\n        xenoprof_buf(d, buf, lost_samples)++;\n        lost_samples++;\n        return 0;\n    }\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,13 @@\n-static int xenoprof_add_sample(struct domain *d, xenoprof_buf_t *buf,\n+static int xenoprof_add_sample(const struct domain *d,\n+                               const struct xenoprof_vcpu *v,\n                                uint64_t eip, int mode, int event)\n {\n+    xenoprof_buf_t *buf = v->buffer;\n     int head, tail, size;\n \n     head = xenoprof_buf(d, buf, event_head);\n     tail = xenoprof_buf(d, buf, event_tail);\n-    size = xenoprof_buf(d, buf, event_size);\n+    size = v->event_size;\n     \n     /* make sure indexes in shared buffer are sane */\n     if ( (head < 0) || (head >= size) || (tail < 0) || (tail >= size) )\n@@ -14,7 +16,7 @@\n         return 0;\n     }\n \n-    if ( xenoprof_buf_space(d, buf, size) > 0 )\n+    if ( xenoprof_buf_space(head, tail, size) > 0 )\n     {\n         xenoprof_buf(d, buf, event_log[head].eip) = eip;\n         xenoprof_buf(d, buf, event_log[head].mode) = mode;",
        "diff_line_info": {
            "deleted_lines": [
                "static int xenoprof_add_sample(struct domain *d, xenoprof_buf_t *buf,",
                "    size = xenoprof_buf(d, buf, event_size);",
                "    if ( xenoprof_buf_space(d, buf, size) > 0 )"
            ],
            "added_lines": [
                "static int xenoprof_add_sample(const struct domain *d,",
                "                               const struct xenoprof_vcpu *v,",
                "    xenoprof_buf_t *buf = v->buffer;",
                "    size = v->event_size;",
                "    if ( xenoprof_buf_space(head, tail, size) > 0 )"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21247",
        "func_name": "LibVNC/libvncserver/main",
        "description": "An issue was discovered in LibVNCServer before 0.9.13. There is an information leak (of uninitialized memory contents) in the libvncclient/rfbproto.c ConnectToRFBRepeater function.",
        "git_url": "https://github.com/LibVNC/libvncserver/commit/8b06f835e259652b0ff026898014fc7297ade858",
        "commit_title": "When connecting to a repeater, only send initialised string",
        "commit_text": " Closes #253",
        "func_before": "int main(int argc,char** argv)\n{\n  char *repeaterHost;\n  int repeaterPort, sock;\n  char id[250];\n  rfbClientPtr cl;\n\n  int i,j;\n  uint16_t* f;\n\n  /* Parse command-line arguments */\n  if (argc < 3) {\n    fprintf(stderr,\n      \"Usage: %s <id> <repeater-host> [<repeater-port>]\\n\", argv[0]);\n    exit(1);\n  }\n  snprintf(id, sizeof(id) - 1, \"ID:%s\", argv[1]);\n  repeaterHost = argv[2];\n  repeaterPort = argc < 4 ? 5500 : atoi(argv[3]);\n\n  /* The initialization is identical to simple15.c */\n  rfbScreenInfoPtr server=rfbGetScreen(&argc,argv,400,300,5,3,2);\n  if(!server)\n    return 0;\n  server->frameBuffer=(char*)malloc(400*300*2);\n  f=(uint16_t*)server->frameBuffer;\n  for(j=0;j<300;j++)\n    for(i=0;i<400;i++)\n      f[j*400+i]=/* red */ ((j*32/300) << 10) |\n\t\t /* green */ (((j+400-i)*32/700) << 5) |\n\t\t /* blue */ ((i*32/400));\n\n  /* Now for the repeater-specific part: */\n  server->port = -1; /* do not listen on any port */\n  server->ipv6port = -1; /* do not listen on any port */\n\n  sock = rfbConnectToTcpAddr(repeaterHost, repeaterPort);\n  if (sock < 0) {\n    perror(\"connect to repeater\");\n    return 1;\n  }\n  if (write(sock, id, sizeof(id)) != sizeof(id)) {\n    perror(\"writing id\");\n    return 1;\n  }\n  cl = rfbNewClient(server, sock);\n  if (!cl) {\n    perror(\"new client\");\n    return 1;\n  }\n  cl->reverseConnection = 0;\n  cl->clientGoneHook = clientGone;\n\n  /* Run the server */\n  rfbInitServer(server);\n  rfbRunEventLoop(server,-1,FALSE);\n\n  return 0;\n}",
        "func": "int main(int argc,char** argv)\n{\n  char *repeaterHost;\n  int repeaterPort, sock;\n  char id[250];\n  int idlen;\n  rfbClientPtr cl;\n\n  int i,j;\n  uint16_t* f;\n\n  /* Parse command-line arguments */\n  if (argc < 3) {\n    fprintf(stderr,\n      \"Usage: %s <id> <repeater-host> [<repeater-port>]\\n\", argv[0]);\n    exit(1);\n  }\n  idlen = snprintf(id, sizeof(id) - 1, \"ID:%s\", argv[1]);\n  if(idlen < 0 || idlen >= (int)sizeof(id)) {\n      fprintf(stderr, \"Error, given ID is probably too long.\\n\");\n      return 1;\n  }\n\n  repeaterHost = argv[2];\n  repeaterPort = argc < 4 ? 5500 : atoi(argv[3]);\n\n  /* The initialization is identical to simple15.c */\n  rfbScreenInfoPtr server=rfbGetScreen(&argc,argv,400,300,5,3,2);\n  if(!server)\n    return 0;\n  server->frameBuffer=(char*)malloc(400*300*2);\n  f=(uint16_t*)server->frameBuffer;\n  for(j=0;j<300;j++)\n    for(i=0;i<400;i++)\n      f[j*400+i]=/* red */ ((j*32/300) << 10) |\n\t\t /* green */ (((j+400-i)*32/700) << 5) |\n\t\t /* blue */ ((i*32/400));\n\n  /* Now for the repeater-specific part: */\n  server->port = -1; /* do not listen on any port */\n  server->ipv6port = -1; /* do not listen on any port */\n\n  sock = rfbConnectToTcpAddr(repeaterHost, repeaterPort);\n  if (sock < 0) {\n    perror(\"connect to repeater\");\n    return 1;\n  }\n  if (write(sock, id, idlen+1) != idlen+1) {\n    perror(\"writing id\");\n    return 1;\n  }\n  cl = rfbNewClient(server, sock);\n  if (!cl) {\n    perror(\"new client\");\n    return 1;\n  }\n  cl->reverseConnection = 0;\n  cl->clientGoneHook = clientGone;\n\n  /* Run the server */\n  rfbInitServer(server);\n  rfbRunEventLoop(server,-1,FALSE);\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n   char *repeaterHost;\n   int repeaterPort, sock;\n   char id[250];\n+  int idlen;\n   rfbClientPtr cl;\n \n   int i,j;\n@@ -14,7 +15,12 @@\n       \"Usage: %s <id> <repeater-host> [<repeater-port>]\\n\", argv[0]);\n     exit(1);\n   }\n-  snprintf(id, sizeof(id) - 1, \"ID:%s\", argv[1]);\n+  idlen = snprintf(id, sizeof(id) - 1, \"ID:%s\", argv[1]);\n+  if(idlen < 0 || idlen >= (int)sizeof(id)) {\n+      fprintf(stderr, \"Error, given ID is probably too long.\\n\");\n+      return 1;\n+  }\n+\n   repeaterHost = argv[2];\n   repeaterPort = argc < 4 ? 5500 : atoi(argv[3]);\n \n@@ -39,7 +45,7 @@\n     perror(\"connect to repeater\");\n     return 1;\n   }\n-  if (write(sock, id, sizeof(id)) != sizeof(id)) {\n+  if (write(sock, id, idlen+1) != idlen+1) {\n     perror(\"writing id\");\n     return 1;\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  snprintf(id, sizeof(id) - 1, \"ID:%s\", argv[1]);",
                "  if (write(sock, id, sizeof(id)) != sizeof(id)) {"
            ],
            "added_lines": [
                "  int idlen;",
                "  idlen = snprintf(id, sizeof(id) - 1, \"ID:%s\", argv[1]);",
                "  if(idlen < 0 || idlen >= (int)sizeof(id)) {",
                "      fprintf(stderr, \"Error, given ID is probably too long.\\n\");",
                "      return 1;",
                "  }",
                "",
                "  if (write(sock, id, idlen+1) != idlen+1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21247",
        "func_name": "LibVNC/libvncserver/ConnectToRFBRepeater",
        "description": "An issue was discovered in LibVNCServer before 0.9.13. There is an information leak (of uninitialized memory contents) in the libvncclient/rfbproto.c ConnectToRFBRepeater function.",
        "git_url": "https://github.com/LibVNC/libvncserver/commit/8b06f835e259652b0ff026898014fc7297ade858",
        "commit_title": "When connecting to a repeater, only send initialised string",
        "commit_text": " Closes #253",
        "func_before": "rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);\n  if (client->sock == -1)\n#endif\n  {\n    unsigned int host;\n    if (!StringToIPAddr(repeaterHost, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n      return FALSE;\n    }\n\n    client->sock = ConnectClientToTcpAddr(host, repeaterPort);\n  }\n\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n\n  if (!SetNonBlocking(client->sock))\n    return FALSE;\n\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n\n  /* UltraVNC repeater always report version 000.000 to identify itself */\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n\n  snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n  if (!WriteToRFBServer(client, tmphost, sizeof(tmphost)))\n    return FALSE;\n\n  return TRUE;\n}",
        "func": "rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n  int tmphostlen;\n\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);\n  if (client->sock == -1)\n#endif\n  {\n    unsigned int host;\n    if (!StringToIPAddr(repeaterHost, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n      return FALSE;\n    }\n\n    client->sock = ConnectClientToTcpAddr(host, repeaterPort);\n  }\n\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n\n  if (!SetNonBlocking(client->sock))\n    return FALSE;\n\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n\n  /* UltraVNC repeater always report version 000.000 to identify itself */\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n\n  tmphostlen = snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))\n    return FALSE; /* snprintf error or output truncated */\n\n  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))\n    return FALSE;\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n   rfbProtocolVersionMsg pv;\n   int major,minor;\n   char tmphost[250];\n+  int tmphostlen;\n \n #ifdef LIBVNCSERVER_IPv6\n   client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);\n@@ -38,8 +39,11 @@\n \n   rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n \n-  snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n-  if (!WriteToRFBServer(client, tmphost, sizeof(tmphost)))\n+  tmphostlen = snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n+  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))\n+    return FALSE; /* snprintf error or output truncated */\n+\n+  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))\n     return FALSE;\n \n   return TRUE;",
        "diff_line_info": {
            "deleted_lines": [
                "  snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);",
                "  if (!WriteToRFBServer(client, tmphost, sizeof(tmphost)))"
            ],
            "added_lines": [
                "  int tmphostlen;",
                "  tmphostlen = snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);",
                "  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))",
                "    return FALSE; /* snprintf error or output truncated */",
                "",
                "  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))"
            ]
        }
    }
]