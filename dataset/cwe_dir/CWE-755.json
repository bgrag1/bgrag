[
    {
        "cve_id": "CVE-2022-32990",
        "func_name": "GNOME/gimp/gimp_channel_is_empty",
        "description": "An issue in gimp_layer_invalidate_boundary of GNOME GIMP 2.10.30 allows attackers to trigger an unhandled exception via a crafted XCF file, causing a Denial of Service (DoS).",
        "git_url": "https://github.com/GNOME/gimp/commit/22af0bcfe67c1c86381f33975ca7fdbde6b36b39",
        "commit_title": "app: fix #8230 crash in gimp_layer_invalidate_boundary when channel is NULL",
        "commit_text": " gimp_channel_is_empty returns FALSE if channel is NULL. This causes gimp_layer_invalidate_boundary to crash if the mask channel is NULL.  With a NULL channel gimp_channel_is_empty should return TRUE, just like the similar gimp_image_is_empty does, because returning FALSE here suggests we have a non empty channel.",
        "func_before": "gboolean\ngimp_channel_is_empty (GimpChannel *channel)\n{\n  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), FALSE);\n\n  return GIMP_CHANNEL_GET_CLASS (channel)->is_empty (channel);\n}",
        "func": "gboolean\ngimp_channel_is_empty (GimpChannel *channel)\n{\n  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), TRUE);\n\n  return GIMP_CHANNEL_GET_CLASS (channel)->is_empty (channel);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n gboolean\n gimp_channel_is_empty (GimpChannel *channel)\n {\n-  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), FALSE);\n+  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), TRUE);\n \n   return GIMP_CHANNEL_GET_CLASS (channel)->is_empty (channel);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), FALSE);"
            ],
            "added_lines": [
                "  g_return_val_if_fail (GIMP_IS_CHANNEL (channel), TRUE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3552",
        "func_name": "facebook/fbthrift/skip",
        "description": "C++ Facebook Thrift servers (using cpp2) would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.02.18.00.",
        "git_url": "https://github.com/facebook/fbthrift/commit/c5d6e07588cd03061bc54d451a7fa6e84883d62b",
        "commit_title": "Throw on bad types during skipping data",
        "commit_text": " Summary: The current code silently returns on bad types. In case when we have an invalid data, we may get a container of a large size with a bad type, this would lead to us running long loop doing nothing (though we already can say that the data is invalid).  The new code would throw an exception as soon as we try to skip a value of invalid type.  Fixes CVE-2019-3552  Reviewed By: yfeldblum, stevegury  Differential Revision: D8344920  fbshipit-source-id: f12e8f3442f7ad5e1a81d822380701e929b80f0d",
        "func_before": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}",
        "func": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -88,7 +88,8 @@\n       prot.readListEnd();\n       return;\n     }\n-    default:\n-      return;\n+    default: {\n+      TProtocolException::throwInvalidSkipType(arg_type);\n+    }\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    default:",
                "      return;"
            ],
            "added_lines": [
                "    default: {",
                "      TProtocolException::throwInvalidSkipType(arg_type);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3565",
        "func_name": "facebook/fbthrift/skip",
        "description": "Legacy C++ Facebook Thrift servers (using cpp instead of cpp2) would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.05.06.00.",
        "git_url": "https://github.com/facebook/fbthrift/commit/01686e15ec77ccb4d49a77d5bce3a01601e54d64",
        "commit_title": "Throw on skipping an invalid type.",
        "commit_text": " Summary: Certain values (e.g.) T_STOP should not appear as a skip type. Allowing them to can cause thrift to loop unboundedly.  Reviewed By: spalamarchuk  Differential Revision: D15102451  fbshipit-source-id: c08d52f44f37e9c212d3480233ac217105586c9f",
        "func_before": "uint32_t skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case T_BOOL: {\n      bool boolv;\n      return prot.readBool(boolv);\n    }\n    case T_BYTE: {\n      int8_t bytev = 0;\n      return prot.readByte(bytev);\n    }\n    case T_I16: {\n      int16_t i16;\n      return prot.readI16(i16);\n    }\n    case T_I32: {\n      int32_t i32;\n      return prot.readI32(i32);\n    }\n    case T_I64: {\n      int64_t i64;\n      return prot.readI64(i64);\n    }\n    case T_DOUBLE: {\n      double dub;\n      return prot.readDouble(dub);\n    }\n    case T_FLOAT: {\n      float flt;\n      return prot.readFloat(flt);\n    }\n    case T_STRING: {\n      std::string str;\n      return prot.readBinary(str);\n    }\n    case T_STRUCT: {\n      uint32_t result = 0;\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      result += prot.readStructBegin(name);\n      while (true) {\n        result += prot.readFieldBegin(name, ftype, fid);\n        if (ftype == T_STOP) {\n          break;\n        }\n        result += skip(prot, ftype);\n        result += prot.readFieldEnd();\n      }\n      result += prot.readStructEnd();\n      return result;\n    }\n    case T_MAP: {\n      uint32_t result = 0;\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readMapBegin(keyType, valType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      } else {\n        while (prot.peekMap()) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      }\n      result += prot.readMapEnd();\n      return result;\n    }\n    case T_SET: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readSetBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekSet()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readSetEnd();\n      return result;\n    }\n    case T_LIST: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readListBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default:\n      return 0;\n  }\n}",
        "func": "uint32_t skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case T_BOOL: {\n      bool boolv;\n      return prot.readBool(boolv);\n    }\n    case T_BYTE: {\n      int8_t bytev = 0;\n      return prot.readByte(bytev);\n    }\n    case T_I16: {\n      int16_t i16;\n      return prot.readI16(i16);\n    }\n    case T_I32: {\n      int32_t i32;\n      return prot.readI32(i32);\n    }\n    case T_I64: {\n      int64_t i64;\n      return prot.readI64(i64);\n    }\n    case T_DOUBLE: {\n      double dub;\n      return prot.readDouble(dub);\n    }\n    case T_FLOAT: {\n      float flt;\n      return prot.readFloat(flt);\n    }\n    case T_STRING: {\n      std::string str;\n      return prot.readBinary(str);\n    }\n    case T_STRUCT: {\n      uint32_t result = 0;\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      result += prot.readStructBegin(name);\n      while (true) {\n        result += prot.readFieldBegin(name, ftype, fid);\n        if (ftype == T_STOP) {\n          break;\n        }\n        result += skip(prot, ftype);\n        result += prot.readFieldEnd();\n      }\n      result += prot.readStructEnd();\n      return result;\n    }\n    case T_MAP: {\n      uint32_t result = 0;\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readMapBegin(keyType, valType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      } else {\n        while (prot.peekMap()) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      }\n      result += prot.readMapEnd();\n      return result;\n    }\n    case T_SET: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readSetBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekSet()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readSetEnd();\n      return result;\n    }\n    case T_LIST: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readListBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -106,7 +106,8 @@\n       result += prot.readListEnd();\n       return result;\n     }\n-    default:\n-      return 0;\n+    default: {\n+      TProtocolException::throwInvalidSkipType(arg_type);\n+    }\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    default:",
                "      return 0;"
            ],
            "added_lines": [
                "    default: {",
                "      TProtocolException::throwInvalidSkipType(arg_type);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12449",
        "func_name": "GNOME/gvfs/g_vfs_backend_admin_class_init",
        "description": "An issue was discovered in GNOME gvfs 1.29.4 through 1.41.2. daemon/gvfsbackendadmin.c mishandles a file's user and group ownership during move (and copy with G_FILE_COPY_ALL_METADATA) operations from admin:// to file:// URIs, because root privileges are unavailable.",
        "git_url": "https://github.com/GNOME/gvfs/commit/409619412e11be146a31b9a99ed965925f1aabb8",
        "commit_title": "admin: Ensure correct ownership when moving to file:// uri",
        "commit_text": " User and group is not restored properly when moving (or copying with G_FILE_COPY_ALL_METADATA) from admin:// to file://, because it is handled by GIO fallback code, which doesn't run with root permissions. Let's handle this case with pull method to ensure correct ownership.",
        "func_before": "static void\ng_vfs_backend_admin_class_init (GVfsBackendAdminClass * klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n  GVfsBackendClass *backend_class = G_VFS_BACKEND_CLASS (klass);\n\n  object_class->finalize = do_finalize;\n\n  backend_class->mount = do_mount;\n  backend_class->open_for_read = do_open_for_read;\n  backend_class->query_info = do_query_info;\n  backend_class->query_info_on_read = do_query_info_on_read;\n  backend_class->query_info_on_write = do_query_info_on_write;\n  backend_class->read = do_read;\n  backend_class->create = do_create;\n  backend_class->append_to = do_append_to;\n  backend_class->replace = do_replace;\n  backend_class->write = do_write;\n  backend_class->close_read = do_close_read;\n  backend_class->close_write = do_close_write;\n  backend_class->seek_on_read = do_seek_on_read;\n  backend_class->seek_on_write = do_seek_on_write;\n  backend_class->enumerate = do_enumerate;\n  backend_class->truncate = do_truncate;\n  backend_class->make_directory = do_make_directory;\n  backend_class->make_symlink = do_make_symlink;\n  backend_class->query_fs_info = do_query_fs_info;\n  backend_class->create_dir_monitor = do_create_dir_monitor;\n  backend_class->create_file_monitor = do_create_file_monitor;\n  backend_class->set_display_name = do_set_display_name;\n  backend_class->set_attribute = do_set_attribute;\n  backend_class->delete = do_delete;\n  backend_class->move = do_move;\n  backend_class->query_settable_attributes = do_query_settable_attributes;\n  backend_class->query_writable_namespaces = do_query_writable_namespaces;\n}",
        "func": "static void\ng_vfs_backend_admin_class_init (GVfsBackendAdminClass * klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n  GVfsBackendClass *backend_class = G_VFS_BACKEND_CLASS (klass);\n\n  object_class->finalize = do_finalize;\n\n  backend_class->mount = do_mount;\n  backend_class->open_for_read = do_open_for_read;\n  backend_class->query_info = do_query_info;\n  backend_class->query_info_on_read = do_query_info_on_read;\n  backend_class->query_info_on_write = do_query_info_on_write;\n  backend_class->read = do_read;\n  backend_class->create = do_create;\n  backend_class->append_to = do_append_to;\n  backend_class->replace = do_replace;\n  backend_class->write = do_write;\n  backend_class->close_read = do_close_read;\n  backend_class->close_write = do_close_write;\n  backend_class->seek_on_read = do_seek_on_read;\n  backend_class->seek_on_write = do_seek_on_write;\n  backend_class->enumerate = do_enumerate;\n  backend_class->truncate = do_truncate;\n  backend_class->make_directory = do_make_directory;\n  backend_class->make_symlink = do_make_symlink;\n  backend_class->query_fs_info = do_query_fs_info;\n  backend_class->create_dir_monitor = do_create_dir_monitor;\n  backend_class->create_file_monitor = do_create_file_monitor;\n  backend_class->set_display_name = do_set_display_name;\n  backend_class->set_attribute = do_set_attribute;\n  backend_class->delete = do_delete;\n  backend_class->move = do_move;\n  backend_class->pull = do_pull;\n  backend_class->query_settable_attributes = do_query_settable_attributes;\n  backend_class->query_writable_namespaces = do_query_writable_namespaces;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,7 @@\n   backend_class->set_attribute = do_set_attribute;\n   backend_class->delete = do_delete;\n   backend_class->move = do_move;\n+  backend_class->pull = do_pull;\n   backend_class->query_settable_attributes = do_query_settable_attributes;\n   backend_class->query_writable_namespaces = do_query_writable_namespaces;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  backend_class->pull = do_pull;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12815",
        "func_name": "proftpd/copy_cpto",
        "description": "An arbitrary file copy vulnerability in mod_copy in ProFTPD up to 1.3.5b allows for remote code execution and information disclosure without authentication, a related issue to CVE-2015-3306.",
        "git_url": "https://github.com/proftpd/proftpd/commit/71cd49ea82313f78d52a52d0c628a3770dc96608",
        "commit_title": "Bug #4372: Ensure that mod_copy checks for <Limits> for its SITE CPFR/CPTO",
        "commit_text": "commands.",
        "func_before": "MODRET copy_cpto(cmd_rec *cmd) {\n  register unsigned int i;\n  const char *from, *to = \"\";\n  unsigned char *authenticated = NULL;\n\n  if (copy_engine == FALSE) {\n    return PR_DECLINED(cmd);\n  }\n\n  if (cmd->argc < 3 ||\n      strncasecmp(cmd->argv[1], \"CPTO\", 5) != 0) {\n    return PR_DECLINED(cmd);\n  }\n\n  authenticated = get_param_ptr(cmd->server->conf, \"authenticated\", FALSE);\n  if (authenticated == NULL ||\n      *authenticated == FALSE) {\n    pr_response_add_err(R_530, _(\"Please login with USER and PASS\"));\n\n    pr_cmd_set_errno(cmd, EPERM);\n    errno = EPERM;\n    return PR_ERROR(cmd);\n  }\n\n  CHECK_CMD_MIN_ARGS(cmd, 3);\n\n  from = pr_table_get(session.notes, \"mod_copy.cpfr-path\", NULL);\n  if (from == NULL) {\n    pr_response_add_err(R_503, _(\"Bad sequence of commands\"));\n\n    pr_cmd_set_errno(cmd, EPERM);\n    errno = EPERM;\n    return PR_ERROR(cmd);\n  }\n\n  /* Construct the target file name by concatenating all the parameters after\n   * the \"SITE CPTO\", separating them with spaces.\n   */\n  for (i = 2; i <= cmd->argc-1; i++) {\n    char *decoded_path;\n\n    decoded_path = pr_fs_decode_path2(cmd->tmp_pool, cmd->argv[i],\n      FSIO_DECODE_FL_TELL_ERRORS);\n    if (decoded_path == NULL) {\n      int xerrno = errno;\n\n      pr_log_debug(DEBUG8, \"'%s' failed to decode properly: %s\",\n        (char *) cmd->argv[i], strerror(xerrno));\n      pr_response_add_err(R_550,\n        _(\"%s: Illegal character sequence in filename\"), cmd->arg);\n\n      pr_cmd_set_errno(cmd, xerrno);\n      errno = xerrno;\n      return PR_ERROR(cmd);\n    }\n\n    to = pstrcat(cmd->tmp_pool, to, *to ? \" \" : \"\", decoded_path, NULL);\n  }\n\n  to = dir_canonical_vpath(cmd->tmp_pool, to);\n\n  if (copy_paths(cmd->tmp_pool, from, to) < 0) {\n    int xerrno = errno;\n    const char *err_code = R_550;\n\n    pr_log_debug(DEBUG7, MOD_COPY_VERSION\n      \": error copying '%s' to '%s': %s\", from, to, strerror(xerrno));\n\n    /* Check errno for EDQOUT (or the most appropriate alternative).\n     * (I hate the fact that FTP has a special response code just for\n     * this, and that clients actually expect it.  Special cases are\n     * stupid.)\n     */\n    switch (xerrno) {\n#if defined(EDQUOT)\n      case EDQUOT:\n#endif /* EDQUOT */\n#if defined(EFBIG)\n      case EFBIG:\n#endif /* EFBIG */\n#if defined(ENOSPC)\n      case ENOSPC:\n#endif /* ENOSPC */\n        err_code = R_552;\n        break;\n\n      default:\n        err_code = R_550;\n        break;\n    }\n\n    pr_response_add_err(err_code, \"%s: %s\", (char *) cmd->argv[1],\n      strerror(xerrno));\n\n    pr_cmd_set_errno(cmd, xerrno);\n    errno = xerrno;\n    return PR_ERROR(cmd);\n  }\n\n  pr_response_add(R_250, \"%s\", _(\"Copy successful\"));\n  return PR_HANDLED(cmd);\n}",
        "func": "MODRET copy_cpto(cmd_rec *cmd) {\n  register unsigned int i;\n  const char *from, *to = \"\";\n  char *cmd_name;\n  unsigned char *authenticated = NULL;\n\n  if (copy_engine == FALSE) {\n    return PR_DECLINED(cmd);\n  }\n\n  if (cmd->argc < 3 ||\n      strncasecmp(cmd->argv[1], \"CPTO\", 5) != 0) {\n    return PR_DECLINED(cmd);\n  }\n\n  authenticated = get_param_ptr(cmd->server->conf, \"authenticated\", FALSE);\n  if (authenticated == NULL ||\n      *authenticated == FALSE) {\n    pr_response_add_err(R_530, _(\"Please login with USER and PASS\"));\n\n    pr_cmd_set_errno(cmd, EPERM);\n    errno = EPERM;\n    return PR_ERROR(cmd);\n  }\n\n  CHECK_CMD_MIN_ARGS(cmd, 3);\n\n  from = pr_table_get(session.notes, \"mod_copy.cpfr-path\", NULL);\n  if (from == NULL) {\n    pr_response_add_err(R_503, _(\"Bad sequence of commands\"));\n\n    pr_cmd_set_errno(cmd, EPERM);\n    errno = EPERM;\n    return PR_ERROR(cmd);\n  }\n\n  /* Construct the target file name by concatenating all the parameters after\n   * the \"SITE CPTO\", separating them with spaces.\n   */\n  for (i = 2; i <= cmd->argc-1; i++) {\n    char *decoded_path;\n\n    decoded_path = pr_fs_decode_path2(cmd->tmp_pool, cmd->argv[i],\n      FSIO_DECODE_FL_TELL_ERRORS);\n    if (decoded_path == NULL) {\n      int xerrno = errno;\n\n      pr_log_debug(DEBUG8, \"'%s' failed to decode properly: %s\",\n        (char *) cmd->argv[i], strerror(xerrno));\n      pr_response_add_err(R_550,\n        _(\"%s: Illegal character sequence in filename\"), cmd->arg);\n\n      pr_cmd_set_errno(cmd, xerrno);\n      errno = xerrno;\n      return PR_ERROR(cmd);\n    }\n\n    to = pstrcat(cmd->tmp_pool, to, *to ? \" \" : \"\", decoded_path, NULL);\n  }\n\n  to = dir_canonical_vpath(cmd->tmp_pool, to);\n\n  cmd_name = cmd->argv[0];\n  pr_cmd_set_name(cmd, \"SITE_CPTO\");\n  if (!dir_check(cmd->tmp_pool, cmd, G_WRITE, to, NULL)) {\n    int xerrno = EPERM;\n\n    pr_cmd_set_name(cmd, cmd_name);\n    pr_response_add_err(R_550, \"%s: %s\", to, strerror(xerrno));\n\n    pr_cmd_set_errno(cmd, xerrno);\n    errno = xerrno;\n    return PR_ERROR(cmd);\n  }\n  pr_cmd_set_name(cmd, cmd_name);\n\n  if (copy_paths(cmd->tmp_pool, from, to) < 0) {\n    int xerrno = errno;\n    const char *err_code = R_550;\n\n    pr_log_debug(DEBUG7, MOD_COPY_VERSION\n      \": error copying '%s' to '%s': %s\", from, to, strerror(xerrno));\n\n    /* Check errno for EDQOUT (or the most appropriate alternative).\n     * (I hate the fact that FTP has a special response code just for\n     * this, and that clients actually expect it.  Special cases are\n     * stupid.)\n     */\n    switch (xerrno) {\n#if defined(EDQUOT)\n      case EDQUOT:\n#endif /* EDQUOT */\n#if defined(EFBIG)\n      case EFBIG:\n#endif /* EFBIG */\n#if defined(ENOSPC)\n      case ENOSPC:\n#endif /* ENOSPC */\n        err_code = R_552;\n        break;\n\n      default:\n        err_code = R_550;\n        break;\n    }\n\n    pr_response_add_err(err_code, \"%s: %s\", (char *) cmd->argv[1],\n      strerror(xerrno));\n\n    pr_cmd_set_errno(cmd, xerrno);\n    errno = xerrno;\n    return PR_ERROR(cmd);\n  }\n\n  pr_response_add(R_250, \"%s\", _(\"Copy successful\"));\n  return PR_HANDLED(cmd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n MODRET copy_cpto(cmd_rec *cmd) {\n   register unsigned int i;\n   const char *from, *to = \"\";\n+  char *cmd_name;\n   unsigned char *authenticated = NULL;\n \n   if (copy_engine == FALSE) {\n@@ -59,6 +60,20 @@\n \n   to = dir_canonical_vpath(cmd->tmp_pool, to);\n \n+  cmd_name = cmd->argv[0];\n+  pr_cmd_set_name(cmd, \"SITE_CPTO\");\n+  if (!dir_check(cmd->tmp_pool, cmd, G_WRITE, to, NULL)) {\n+    int xerrno = EPERM;\n+\n+    pr_cmd_set_name(cmd, cmd_name);\n+    pr_response_add_err(R_550, \"%s: %s\", to, strerror(xerrno));\n+\n+    pr_cmd_set_errno(cmd, xerrno);\n+    errno = xerrno;\n+    return PR_ERROR(cmd);\n+  }\n+  pr_cmd_set_name(cmd, cmd_name);\n+\n   if (copy_paths(cmd->tmp_pool, from, to) < 0) {\n     int xerrno = errno;\n     const char *err_code = R_550;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  char *cmd_name;",
                "  cmd_name = cmd->argv[0];",
                "  pr_cmd_set_name(cmd, \"SITE_CPTO\");",
                "  if (!dir_check(cmd->tmp_pool, cmd, G_WRITE, to, NULL)) {",
                "    int xerrno = EPERM;",
                "",
                "    pr_cmd_set_name(cmd, cmd_name);",
                "    pr_response_add_err(R_550, \"%s: %s\", to, strerror(xerrno));",
                "",
                "    pr_cmd_set_errno(cmd, xerrno);",
                "    errno = xerrno;",
                "    return PR_ERROR(cmd);",
                "  }",
                "  pr_cmd_set_name(cmd, cmd_name);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12815",
        "func_name": "proftpd/copy_cpfr",
        "description": "An arbitrary file copy vulnerability in mod_copy in ProFTPD up to 1.3.5b allows for remote code execution and information disclosure without authentication, a related issue to CVE-2015-3306.",
        "git_url": "https://github.com/proftpd/proftpd/commit/71cd49ea82313f78d52a52d0c628a3770dc96608",
        "commit_title": "Bug #4372: Ensure that mod_copy checks for <Limits> for its SITE CPFR/CPTO",
        "commit_text": "commands.",
        "func_before": "MODRET copy_cpfr(cmd_rec *cmd) {\n  register unsigned int i;\n  int res;\n  char *path = \"\";\n  unsigned char *authenticated = NULL;\n\n  if (copy_engine == FALSE) {\n    return PR_DECLINED(cmd);\n  }\n\n  if (cmd->argc < 3 ||\n      strncasecmp(cmd->argv[1], \"CPFR\", 5) != 0) {\n    return PR_DECLINED(cmd);\n  }\n\n  authenticated = get_param_ptr(cmd->server->conf, \"authenticated\", FALSE);\n  if (authenticated == NULL ||\n      *authenticated == FALSE) {\n    pr_response_add_err(R_530, _(\"Please login with USER and PASS\"));\n  \n    pr_cmd_set_errno(cmd, EPERM);\n    errno = EPERM;\n    return PR_ERROR(cmd);\n  }\n\n  CHECK_CMD_MIN_ARGS(cmd, 3);\n\n  /* Construct the target file name by concatenating all the parameters after\n   * the \"SITE CPFR\", separating them with spaces.\n   */\n  for (i = 2; i <= cmd->argc-1; i++) {\n    char *decoded_path;\n\n    decoded_path = pr_fs_decode_path2(cmd->tmp_pool, cmd->argv[i],\n      FSIO_DECODE_FL_TELL_ERRORS);\n    if (decoded_path == NULL) {\n      int xerrno = errno;\n\n      pr_log_debug(DEBUG8, \"'%s' failed to decode properly: %s\",\n        (char *) cmd->argv[i], strerror(xerrno));\n      pr_response_add_err(R_550,\n        _(\"%s: Illegal character sequence in filename\"), cmd->arg);\n\n      pr_cmd_set_errno(cmd, xerrno);\n      errno = xerrno;\n      return PR_ERROR(cmd);\n    }\n\n    path = pstrcat(cmd->tmp_pool, path, *path ? \" \" : \"\", decoded_path, NULL);\n  }\n\n  res = pr_filter_allow_path(CURRENT_CONF, path);\n  switch (res) {\n    case 0:\n      break;\n\n    case PR_FILTER_ERR_FAILS_ALLOW_FILTER:\n      pr_log_debug(DEBUG2, MOD_COPY_VERSION\n        \": 'CPFR %s' denied by PathAllowFilter\", path);\n      pr_response_add_err(R_550, _(\"%s: Forbidden filename\"), path);\n\n      pr_cmd_set_errno(cmd, EPERM);\n      errno = EPERM;\n      return PR_ERROR(cmd);\n\n    case PR_FILTER_ERR_FAILS_DENY_FILTER:\n      pr_log_debug(DEBUG2, MOD_COPY_VERSION\n        \": 'CPFR %s' denied by PathDenyFilter\", path);\n      pr_response_add_err(R_550, _(\"%s: Forbidden filename\"), path);\n\n      pr_cmd_set_errno(cmd, EPERM);\n      errno = EPERM;\n      return PR_ERROR(cmd);\n  }\n\n  /* Allow renaming a symlink, even a dangling one. */\n  path = dir_canonical_vpath(cmd->tmp_pool, path);\n\n  if (!path ||\n      !dir_check_canon(cmd->tmp_pool, cmd, cmd->group, path, NULL) ||\n      !exists2(cmd->tmp_pool, path)) {\n    int xerrno = errno;\n\n    pr_response_add_err(R_550, \"%s: %s\", path, strerror(xerrno));\n\n    pr_cmd_set_errno(cmd, xerrno);\n    errno = xerrno;\n    return PR_ERROR(cmd);\n  }\n\n  if (pr_table_add(session.notes, \"mod_copy.cpfr-path\",\n      pstrdup(session.pool, path), 0) < 0) {\n    pr_trace_msg(trace_channel, 4,\n      \"error adding 'mod_copy.cpfr-path' note: %s\", strerror(errno));\n  }\n\n  pr_response_add(R_350,\n    _(\"File or directory exists, ready for destination name\"));\n  return PR_HANDLED(cmd);\n}",
        "func": "MODRET copy_cpfr(cmd_rec *cmd) {\n  register unsigned int i;\n  int res;\n  char *cmd_name, *path = \"\";\n  unsigned char *authenticated = NULL;\n\n  if (copy_engine == FALSE) {\n    return PR_DECLINED(cmd);\n  }\n\n  if (cmd->argc < 3 ||\n      strncasecmp(cmd->argv[1], \"CPFR\", 5) != 0) {\n    return PR_DECLINED(cmd);\n  }\n\n  authenticated = get_param_ptr(cmd->server->conf, \"authenticated\", FALSE);\n  if (authenticated == NULL ||\n      *authenticated == FALSE) {\n    pr_response_add_err(R_530, _(\"Please login with USER and PASS\"));\n  \n    pr_cmd_set_errno(cmd, EPERM);\n    errno = EPERM;\n    return PR_ERROR(cmd);\n  }\n\n  CHECK_CMD_MIN_ARGS(cmd, 3);\n\n  /* Construct the target file name by concatenating all the parameters after\n   * the \"SITE CPFR\", separating them with spaces.\n   */\n  for (i = 2; i <= cmd->argc-1; i++) {\n    char *decoded_path;\n\n    decoded_path = pr_fs_decode_path2(cmd->tmp_pool, cmd->argv[i],\n      FSIO_DECODE_FL_TELL_ERRORS);\n    if (decoded_path == NULL) {\n      int xerrno = errno;\n\n      pr_log_debug(DEBUG8, \"'%s' failed to decode properly: %s\",\n        (char *) cmd->argv[i], strerror(xerrno));\n      pr_response_add_err(R_550,\n        _(\"%s: Illegal character sequence in filename\"), cmd->arg);\n\n      pr_cmd_set_errno(cmd, xerrno);\n      errno = xerrno;\n      return PR_ERROR(cmd);\n    }\n\n    path = pstrcat(cmd->tmp_pool, path, *path ? \" \" : \"\", decoded_path, NULL);\n  }\n\n  cmd_name = cmd->argv[0];\n  pr_cmd_set_name(cmd, \"SITE_CPFR\");\n  if (!dir_check(cmd->tmp_pool, cmd, G_READ, path, NULL)) {\n    int xerrno = EPERM;\n\n    pr_cmd_set_name(cmd, cmd_name);\n    pr_response_add_err(R_550, \"%s: %s\", (char *) cmd->argv[3],\n      strerror(xerrno));\n\n    pr_cmd_set_errno(cmd, xerrno);\n    errno = xerrno;\n    return PR_ERROR(cmd);\n  }\n  pr_cmd_set_name(cmd, cmd_name);\n\n  res = pr_filter_allow_path(CURRENT_CONF, path);\n  switch (res) {\n    case 0:\n      break;\n\n    case PR_FILTER_ERR_FAILS_ALLOW_FILTER:\n      pr_log_debug(DEBUG2, MOD_COPY_VERSION\n        \": 'CPFR %s' denied by PathAllowFilter\", path);\n      pr_response_add_err(R_550, _(\"%s: Forbidden filename\"), path);\n\n      pr_cmd_set_errno(cmd, EPERM);\n      errno = EPERM;\n      return PR_ERROR(cmd);\n\n    case PR_FILTER_ERR_FAILS_DENY_FILTER:\n      pr_log_debug(DEBUG2, MOD_COPY_VERSION\n        \": 'CPFR %s' denied by PathDenyFilter\", path);\n      pr_response_add_err(R_550, _(\"%s: Forbidden filename\"), path);\n\n      pr_cmd_set_errno(cmd, EPERM);\n      errno = EPERM;\n      return PR_ERROR(cmd);\n  }\n\n  /* Allow renaming a symlink, even a dangling one. */\n  path = dir_canonical_vpath(cmd->tmp_pool, path);\n\n  if (!path ||\n      !dir_check_canon(cmd->tmp_pool, cmd, cmd->group, path, NULL) ||\n      !exists2(cmd->tmp_pool, path)) {\n    int xerrno = errno;\n\n    pr_response_add_err(R_550, \"%s: %s\", path, strerror(xerrno));\n\n    pr_cmd_set_errno(cmd, xerrno);\n    errno = xerrno;\n    return PR_ERROR(cmd);\n  }\n\n  if (pr_table_add(session.notes, \"mod_copy.cpfr-path\",\n      pstrdup(session.pool, path), 0) < 0) {\n    pr_trace_msg(trace_channel, 4,\n      \"error adding 'mod_copy.cpfr-path' note: %s\", strerror(errno));\n  }\n\n  pr_response_add(R_350,\n    _(\"File or directory exists, ready for destination name\"));\n  return PR_HANDLED(cmd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n MODRET copy_cpfr(cmd_rec *cmd) {\n   register unsigned int i;\n   int res;\n-  char *path = \"\";\n+  char *cmd_name, *path = \"\";\n   unsigned char *authenticated = NULL;\n \n   if (copy_engine == FALSE) {\n@@ -48,6 +48,21 @@\n \n     path = pstrcat(cmd->tmp_pool, path, *path ? \" \" : \"\", decoded_path, NULL);\n   }\n+\n+  cmd_name = cmd->argv[0];\n+  pr_cmd_set_name(cmd, \"SITE_CPFR\");\n+  if (!dir_check(cmd->tmp_pool, cmd, G_READ, path, NULL)) {\n+    int xerrno = EPERM;\n+\n+    pr_cmd_set_name(cmd, cmd_name);\n+    pr_response_add_err(R_550, \"%s: %s\", (char *) cmd->argv[3],\n+      strerror(xerrno));\n+\n+    pr_cmd_set_errno(cmd, xerrno);\n+    errno = xerrno;\n+    return PR_ERROR(cmd);\n+  }\n+  pr_cmd_set_name(cmd, cmd_name);\n \n   res = pr_filter_allow_path(CURRENT_CONF, path);\n   switch (res) {",
        "diff_line_info": {
            "deleted_lines": [
                "  char *path = \"\";"
            ],
            "added_lines": [
                "  char *cmd_name, *path = \"\";",
                "",
                "  cmd_name = cmd->argv[0];",
                "  pr_cmd_set_name(cmd, \"SITE_CPFR\");",
                "  if (!dir_check(cmd->tmp_pool, cmd, G_READ, path, NULL)) {",
                "    int xerrno = EPERM;",
                "",
                "    pr_cmd_set_name(cmd, cmd_name);",
                "    pr_response_add_err(R_550, \"%s: %s\", (char *) cmd->argv[3],",
                "      strerror(xerrno));",
                "",
                "    pr_cmd_set_errno(cmd, xerrno);",
                "    errno = xerrno;",
                "    return PR_ERROR(cmd);",
                "  }",
                "  pr_cmd_set_name(cmd, cmd_name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16930",
        "func_name": "zcash/SaplingNotePlaintext::decrypt",
        "description": "Zcashd in Zcash before 2.0.7-3 allows discovery of the IP address of a full node that owns a shielded address, related to mishandling of exceptions during deserialization of note plaintexts. This affects anyone who has disclosed their zaddr to a third party.",
        "git_url": "https://github.com/zcash/zcash/commit/c1fbf8ab5d73cff5e1f45236995857c75ba4128d",
        "commit_title": "Ignore exceptions when deserializing note plaintexts",
        "commit_text": "",
        "func_before": "boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &ivk,\n    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingNotePlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    return ret;\n}",
        "func": "boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &ivk,\n    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    SaplingNotePlaintext ret;\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n        ss >> ret;\n        assert(ss.size() == 0);\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,13 +11,17 @@\n     }\n \n     // Deserialize from the plaintext\n-    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n-    ss << pt.get();\n-\n     SaplingNotePlaintext ret;\n-    ss >> ret;\n-\n-    assert(ss.size() == 0);\n+    try {\n+        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+        ss << pt.get();\n+        ss >> ret;\n+        assert(ss.size() == 0);\n+    } catch (const boost::thread_interrupted&) {\n+        throw;\n+    } catch (...) {\n+        return boost::none;\n+    }\n \n     uint256 pk_d;\n     if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {",
        "diff_line_info": {
            "deleted_lines": [
                "    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);",
                "    ss << pt.get();",
                "",
                "    ss >> ret;",
                "",
                "    assert(ss.size() == 0);"
            ],
            "added_lines": [
                "    try {",
                "        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);",
                "        ss << pt.get();",
                "        ss >> ret;",
                "        assert(ss.size() == 0);",
                "    } catch (const boost::thread_interrupted&) {",
                "        throw;",
                "    } catch (...) {",
                "        return boost::none;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16930",
        "func_name": "zcash/SaplingOutgoingPlaintext::decrypt",
        "description": "Zcashd in Zcash before 2.0.7-3 allows discovery of the IP address of a full node that owns a shielded address, related to mishandling of exceptions during deserialization of note plaintexts. This affects anyone who has disclosed their zaddr to a third party.",
        "git_url": "https://github.com/zcash/zcash/commit/c1fbf8ab5d73cff5e1f45236995857c75ba4128d",
        "commit_title": "Ignore exceptions when deserializing note plaintexts",
        "commit_text": "",
        "func_before": "boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingOutgoingPlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    return ret;\n}",
        "func": "boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n\n        SaplingOutgoingPlaintext ret;\n        ss >> ret;\n\n        assert(ss.size() == 0);\n\n        return ret;\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,13 +12,19 @@\n     }\n \n     // Deserialize from the plaintext\n-    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n-    ss << pt.get();\n+    try {\n+        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+        ss << pt.get();\n \n-    SaplingOutgoingPlaintext ret;\n-    ss >> ret;\n+        SaplingOutgoingPlaintext ret;\n+        ss >> ret;\n \n-    assert(ss.size() == 0);\n+        assert(ss.size() == 0);\n \n-    return ret;\n+        return ret;\n+    } catch (const boost::thread_interrupted&) {\n+        throw;\n+    } catch (...) {\n+        return boost::none;\n+    }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);",
                "    ss << pt.get();",
                "    SaplingOutgoingPlaintext ret;",
                "    ss >> ret;",
                "    assert(ss.size() == 0);",
                "    return ret;"
            ],
            "added_lines": [
                "    try {",
                "        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);",
                "        ss << pt.get();",
                "        SaplingOutgoingPlaintext ret;",
                "        ss >> ret;",
                "        assert(ss.size() == 0);",
                "        return ret;",
                "    } catch (const boost::thread_interrupted&) {",
                "        throw;",
                "    } catch (...) {",
                "        return boost::none;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16930",
        "func_name": "zcash/SaplingNotePlaintext::decrypt",
        "description": "Zcashd in Zcash before 2.0.7-3 allows discovery of the IP address of a full node that owns a shielded address, related to mishandling of exceptions during deserialization of note plaintexts. This affects anyone who has disclosed their zaddr to a third party.",
        "git_url": "https://github.com/zcash/zcash/commit/c1fbf8ab5d73cff5e1f45236995857c75ba4128d",
        "commit_title": "Ignore exceptions when deserializing note plaintexts",
        "commit_text": "",
        "func_before": "boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &epk,\n    const uint256 &esk,\n    const uint256 &pk_d,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, epk, esk, pk_d);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingNotePlaintext ret;\n    ss >> ret;\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    assert(ss.size() == 0);\n\n    return ret;\n}",
        "func": "boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(\n    const SaplingEncCiphertext &ciphertext,\n    const uint256 &epk,\n    const uint256 &esk,\n    const uint256 &pk_d,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, epk, esk, pk_d);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    SaplingNotePlaintext ret;\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n        ss >> ret;\n        assert(ss.size() == 0);\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),\n        ret.value(),\n        ret.rcm.begin(),\n        cmu_expected.begin()\n    ))\n    {\n        return boost::none;\n    }\n\n    if (cmu_expected != cmu) {\n        return boost::none;\n    }\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,11 +12,17 @@\n     }\n \n     // Deserialize from the plaintext\n-    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n-    ss << pt.get();\n-\n     SaplingNotePlaintext ret;\n-    ss >> ret;\n+    try {\n+        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+        ss << pt.get();\n+        ss >> ret;\n+        assert(ss.size() == 0);\n+    } catch (const boost::thread_interrupted&) {\n+        throw;\n+    } catch (...) {\n+        return boost::none;\n+    }\n \n     uint256 cmu_expected;\n     if (!librustzcash_sapling_compute_cm(\n@@ -34,7 +40,5 @@\n         return boost::none;\n     }\n \n-    assert(ss.size() == 0);\n-\n     return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);",
                "    ss << pt.get();",
                "",
                "    ss >> ret;",
                "    assert(ss.size() == 0);",
                ""
            ],
            "added_lines": [
                "    try {",
                "        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);",
                "        ss << pt.get();",
                "        ss >> ret;",
                "        assert(ss.size() == 0);",
                "    } catch (const boost::thread_interrupted&) {",
                "        throw;",
                "    } catch (...) {",
                "        return boost::none;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24448",
        "func_name": "torvalds/linux/nfs4_file_open",
        "description": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.",
        "git_url": "https://github.com/torvalds/linux/commit/ab0fc21bc7105b54bafd85bd8b82742f9e68898a",
        "commit_title": "Revert \"NFSv4: Handle the special Linux file open access mode\"",
        "commit_text": " This reverts commit 44942b4e457beda00981f616402a1a791e8c616e.  After secondly opening a file with O_ACCMODE|O_DIRECT flags, nfs4_valid_open_stateid() will dereference NULL nfs4_state when lseek().  Reproducer:   1. mount -t nfs -o vers=4.2 $server_ip:/ /mnt/   2. fd = open(\"/mnt/file\", O_ACCMODE|O_DIRECT|O_CREAT)   3. close(fd)   4. fd = open(\"/mnt/file\", O_ACCMODE|O_DIRECT)   5. lseek(fd) ",
        "func_before": "static int\nnfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}",
        "func": "static int\nnfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\topenflags--;\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n \t\treturn err;\n \n \tif ((openflags & O_ACCMODE) == 3)\n-\t\treturn nfs_open(inode, filp);\n+\t\topenflags--;\n \n \t/* We can't create new files here */\n \topenflags &= ~(O_CREAT|O_EXCL);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn nfs_open(inode, filp);"
            ],
            "added_lines": [
                "\t\topenflags--;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24448",
        "func_name": "torvalds/linux/nfs_atomic_open",
        "description": "An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor.",
        "git_url": "https://github.com/torvalds/linux/commit/ac795161c93699d600db16c1a8cc23a65a1eceaf",
        "commit_title": "NFSv4: Handle case where the lookup of a directory fails",
        "commit_text": " If the application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() will punt to doing a regular lookup. If the server then returns a regular file, we will happily return a file descriptor with uninitialised open state.  The fix is to return the expected ENOTDIR error in these cases. ",
        "func_before": "int nfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t    struct file *file, unsigned open_flags,\n\t\t    umode_t mode)\n{\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *res;\n\tstruct iattr attr = { .ia_valid = ATTR_OPEN };\n\tstruct inode *inode;\n\tunsigned int lookup_flags = 0;\n\tunsigned long dir_verifier;\n\tbool switched = false;\n\tint created = 0;\n\tint err;\n\n\t/* Expect a negative dentry */\n\tBUG_ON(d_inode(dentry));\n\n\tdfprintk(VFS, \"NFS: atomic_open(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\terr = nfs_check_flags(open_flags);\n\tif (err)\n\t\treturn err;\n\n\t/* NFS only supports OPEN on regular files */\n\tif ((open_flags & O_DIRECTORY)) {\n\t\tif (!d_in_lookup(dentry)) {\n\t\t\t/*\n\t\t\t * Hashed negative dentry with O_DIRECTORY: dentry was\n\t\t\t * revalidated and is fine, no need to perform lookup\n\t\t\t * again\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tlookup_flags = LOOKUP_OPEN|LOOKUP_DIRECTORY;\n\t\tgoto no_open;\n\t}\n\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\treturn -ENAMETOOLONG;\n\n\tif (open_flags & O_CREAT) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\t\tmode &= ~current_umask();\n\n\t\tattr.ia_valid |= ATTR_MODE;\n\t\tattr.ia_mode = mode;\n\t}\n\tif (open_flags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t}\n\n\tif (!(open_flags & O_CREAT) && !d_in_lookup(dentry)) {\n\t\td_drop(dentry);\n\t\tswitched = true;\n\t\tdentry = d_alloc_parallel(dentry->d_parent,\n\t\t\t\t\t  &dentry->d_name, &wq);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t\tif (unlikely(!d_in_lookup(dentry)))\n\t\t\treturn finish_no_open(file, dentry);\n\t}\n\n\tctx = create_nfs_open_context(dentry, open_flags, file);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\ttrace_nfs_atomic_open_enter(dir, ctx, open_flags);\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, open_flags, &attr, &created);\n\tif (created)\n\t\tfile->f_mode |= FMODE_CREATED;\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\t\tput_nfs_open_context(ctx);\n\t\td_drop(dentry);\n\t\tswitch (err) {\n\t\tcase -ENOENT:\n\t\t\td_splice_alias(NULL, dentry);\n\t\t\tif (nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE))\n\t\t\t\tdir_verifier = inode_peek_iversion_raw(dir);\n\t\t\telse\n\t\t\t\tdir_verifier = nfs_save_change_attribute(dir);\n\t\t\tnfs_set_verifier(dentry, dir_verifier);\n\t\t\tbreak;\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\t\tgoto no_open;\n\t\tcase -ELOOP:\n\t\t\tif (!(open_flags & O_NOFOLLOW))\n\t\t\t\tgoto no_open;\n\t\t\tbreak;\n\t\t\t/* case -EINVAL: */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\terr = nfs_finish_open(ctx, ctx->dentry, file, open_flags);\n\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\tput_nfs_open_context(ctx);\nout:\n\tif (unlikely(switched)) {\n\t\td_lookup_done(dentry);\n\t\tdput(dentry);\n\t}\n\treturn err;\n\nno_open:\n\tres = nfs_lookup(dir, dentry, lookup_flags);\n\tif (switched) {\n\t\td_lookup_done(dentry);\n\t\tif (!res)\n\t\t\tres = dentry;\n\t\telse\n\t\t\tdput(dentry);\n\t}\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\treturn finish_no_open(file, res);\n}",
        "func": "int nfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t    struct file *file, unsigned open_flags,\n\t\t    umode_t mode)\n{\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *res;\n\tstruct iattr attr = { .ia_valid = ATTR_OPEN };\n\tstruct inode *inode;\n\tunsigned int lookup_flags = 0;\n\tunsigned long dir_verifier;\n\tbool switched = false;\n\tint created = 0;\n\tint err;\n\n\t/* Expect a negative dentry */\n\tBUG_ON(d_inode(dentry));\n\n\tdfprintk(VFS, \"NFS: atomic_open(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\terr = nfs_check_flags(open_flags);\n\tif (err)\n\t\treturn err;\n\n\t/* NFS only supports OPEN on regular files */\n\tif ((open_flags & O_DIRECTORY)) {\n\t\tif (!d_in_lookup(dentry)) {\n\t\t\t/*\n\t\t\t * Hashed negative dentry with O_DIRECTORY: dentry was\n\t\t\t * revalidated and is fine, no need to perform lookup\n\t\t\t * again\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tlookup_flags = LOOKUP_OPEN|LOOKUP_DIRECTORY;\n\t\tgoto no_open;\n\t}\n\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\treturn -ENAMETOOLONG;\n\n\tif (open_flags & O_CREAT) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\t\tmode &= ~current_umask();\n\n\t\tattr.ia_valid |= ATTR_MODE;\n\t\tattr.ia_mode = mode;\n\t}\n\tif (open_flags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t}\n\n\tif (!(open_flags & O_CREAT) && !d_in_lookup(dentry)) {\n\t\td_drop(dentry);\n\t\tswitched = true;\n\t\tdentry = d_alloc_parallel(dentry->d_parent,\n\t\t\t\t\t  &dentry->d_name, &wq);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t\tif (unlikely(!d_in_lookup(dentry)))\n\t\t\treturn finish_no_open(file, dentry);\n\t}\n\n\tctx = create_nfs_open_context(dentry, open_flags, file);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\ttrace_nfs_atomic_open_enter(dir, ctx, open_flags);\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, open_flags, &attr, &created);\n\tif (created)\n\t\tfile->f_mode |= FMODE_CREATED;\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\t\tput_nfs_open_context(ctx);\n\t\td_drop(dentry);\n\t\tswitch (err) {\n\t\tcase -ENOENT:\n\t\t\td_splice_alias(NULL, dentry);\n\t\t\tif (nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE))\n\t\t\t\tdir_verifier = inode_peek_iversion_raw(dir);\n\t\t\telse\n\t\t\t\tdir_verifier = nfs_save_change_attribute(dir);\n\t\t\tnfs_set_verifier(dentry, dir_verifier);\n\t\t\tbreak;\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\t\tgoto no_open;\n\t\tcase -ELOOP:\n\t\t\tif (!(open_flags & O_NOFOLLOW))\n\t\t\t\tgoto no_open;\n\t\t\tbreak;\n\t\t\t/* case -EINVAL: */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\terr = nfs_finish_open(ctx, ctx->dentry, file, open_flags);\n\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\tput_nfs_open_context(ctx);\nout:\n\tif (unlikely(switched)) {\n\t\td_lookup_done(dentry);\n\t\tdput(dentry);\n\t}\n\treturn err;\n\nno_open:\n\tres = nfs_lookup(dir, dentry, lookup_flags);\n\tif (!res) {\n\t\tinode = d_inode(dentry);\n\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&\n\t\t    !S_ISDIR(inode->i_mode))\n\t\t\tres = ERR_PTR(-ENOTDIR);\n\t} else if (!IS_ERR(res)) {\n\t\tinode = d_inode(res);\n\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&\n\t\t    !S_ISDIR(inode->i_mode)) {\n\t\t\tdput(res);\n\t\t\tres = ERR_PTR(-ENOTDIR);\n\t\t}\n\t}\n\tif (switched) {\n\t\td_lookup_done(dentry);\n\t\tif (!res)\n\t\t\tres = dentry;\n\t\telse\n\t\t\tdput(dentry);\n\t}\n\tif (IS_ERR(res))\n\t\treturn PTR_ERR(res);\n\treturn finish_no_open(file, res);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -114,6 +114,19 @@\n \n no_open:\n \tres = nfs_lookup(dir, dentry, lookup_flags);\n+\tif (!res) {\n+\t\tinode = d_inode(dentry);\n+\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&\n+\t\t    !S_ISDIR(inode->i_mode))\n+\t\t\tres = ERR_PTR(-ENOTDIR);\n+\t} else if (!IS_ERR(res)) {\n+\t\tinode = d_inode(res);\n+\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&\n+\t\t    !S_ISDIR(inode->i_mode)) {\n+\t\t\tdput(res);\n+\t\t\tres = ERR_PTR(-ENOTDIR);\n+\t\t}\n+\t}\n \tif (switched) {\n \t\td_lookup_done(dentry);\n \t\tif (!res)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!res) {",
                "\t\tinode = d_inode(dentry);",
                "\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&",
                "\t\t    !S_ISDIR(inode->i_mode))",
                "\t\t\tres = ERR_PTR(-ENOTDIR);",
                "\t} else if (!IS_ERR(res)) {",
                "\t\tinode = d_inode(res);",
                "\t\tif ((lookup_flags & LOOKUP_DIRECTORY) && inode &&",
                "\t\t    !S_ISDIR(inode->i_mode)) {",
                "\t\t\tdput(res);",
                "\t\t\tres = ERR_PTR(-ENOTDIR);",
                "\t\t}",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-33748",
        "func_name": "xen-project/xen/acquire_grant_for_copy",
        "description": "lock order inversion in transitive grant copy handling As part of XSA-226 a missing cleanup call was inserted on an error handling path. While doing so, locking requirements were not paid attention to. As a result two cooperating guests granting each other transitive grants can cause locks to be acquired nested within one another, but in respectively opposite order. With suitable timing between the involved grant copy operations this may result in the locking up of a CPU.",
        "git_url": "https://github.com/xen-project/xen/commit/6e3aab858eef614a21a782a3b73acc88e74690ea",
        "commit_title": "gnttab: correct locking on transitive grant copy error path",
        "commit_text": " While the comment next to the lock dropping in preparation of recursively calling acquire_grant_for_copy() mistakenly talks about the rd == td case (excluded a few lines further up), the same concerns apply to the calling of release_grant_for_copy() on a subsequent error path.  This is CVE-2022-33748 / XSA-411. ",
        "func_before": "static int\nacquire_grant_for_copy(\n    struct domain *rd, grant_ref_t gref, domid_t ldom, bool readonly,\n    mfn_t *mfn, struct page_info **page, uint16_t *page_off,\n    uint16_t *length, bool allow_transitive)\n{\n    struct grant_table *rgt = rd->grant_table;\n    grant_entry_v2_t *sha2;\n    grant_entry_header_t *shah;\n    struct active_grant_entry *act;\n    grant_status_t *status;\n    uint32_t old_pin;\n    domid_t trans_domid;\n    grant_ref_t trans_gref;\n    struct domain *td;\n    mfn_t grant_mfn;\n    uint16_t trans_page_off;\n    uint16_t trans_length;\n    bool is_sub_page;\n    s16 rc = GNTST_okay;\n    unsigned int pin_incr = readonly ? GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    *page = NULL;\n\n    grant_read_lock(rgt);\n\n    if ( unlikely(gref >= nr_grant_entries(rgt)) )\n        PIN_FAIL(gt_unlock_out, GNTST_bad_gntref,\n                 \"Bad grant reference %#x\\n\", gref);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, gref);\n    act = active_entry_acquire(rgt, gref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ldom) ||\n          (act->pin & GNTPIN_incr2oflow_mask(pin_incr))) )\n        PIN_FAIL(unlock_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x\\n\",\n                 act->domid, ldom, act->pin);\n\n    if ( evaluate_nospec(rgt->gt_version == 1) )\n    {\n        sha2 = NULL;\n        status = &shah->flags;\n    }\n    else\n    {\n        sha2 = &shared_entry_v2(rgt, gref);\n        status = &status_entry(rgt, gref);\n    }\n\n    old_pin = act->pin;\n    if ( sha2 && (shah->flags & GTF_type_mask) == GTF_transitive )\n    {\n        if ( (!old_pin || (!readonly &&\n                           !(old_pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)))) &&\n             (rc = _set_status_v2(shah, status, rd, act, readonly, 0,\n                                  ldom)) != GNTST_okay )\n            goto unlock_out;\n\n        if ( !allow_transitive )\n            PIN_FAIL(unlock_out_clear, GNTST_general_error,\n                     \"transitive grant when transitivity not allowed\\n\");\n\n        trans_domid = sha2->transitive.trans_domid;\n        trans_gref = sha2->transitive.gref;\n        barrier(); /* Stop the compiler from re-loading\n                      trans_domid from shared memory */\n        if ( trans_domid == rd->domain_id )\n            PIN_FAIL(unlock_out_clear, GNTST_general_error,\n                     \"transitive grants cannot be self-referential\\n\");\n\n        /*\n         * We allow the trans_domid == ldom case, which corresponds to a\n         * grant being issued by one domain, sent to another one, and then\n         * transitively granted back to the original domain.  Allowing it\n         * is easy, and means that you don't need to go out of your way to\n         * avoid it in the guest.\n         */\n\n        /* We need to leave the rrd locked during the grant copy. */\n        td = rcu_lock_domain_by_id(trans_domid);\n        if ( td == NULL )\n            PIN_FAIL(unlock_out_clear, GNTST_general_error,\n                     \"transitive grant referenced bad domain %d\\n\",\n                     trans_domid);\n\n        /*\n         * acquire_grant_for_copy() could take the lock on the\n         * remote table (if rd == td), so we have to drop the lock\n         * here and reacquire.\n         */\n        active_entry_release(act);\n        grant_read_unlock(rgt);\n\n        rc = acquire_grant_for_copy(td, trans_gref, rd->domain_id,\n                                    readonly, &grant_mfn, page,\n                                    &trans_page_off, &trans_length,\n                                    false);\n\n        grant_read_lock(rgt);\n        act = active_entry_acquire(rgt, gref);\n\n        if ( rc != GNTST_okay )\n        {\n            rcu_unlock_domain(td);\n            reduce_status_for_pin(rd, act, status, readonly);\n            active_entry_release(act);\n            grant_read_unlock(rgt);\n            return rc;\n        }\n\n        /*\n         * We dropped the lock, so we have to check that the grant didn't\n         * change, and that nobody else tried to pin/unpin it. If anything\n         * changed, just give up and tell the caller to retry.\n         */\n        if ( rgt->gt_version != 2 ||\n             act->pin != old_pin ||\n             (old_pin && (act->domid != ldom ||\n                          !mfn_eq(act->mfn, grant_mfn) ||\n                          act->start != trans_page_off ||\n                          act->length != trans_length ||\n                          act->trans_domain != td ||\n                          act->trans_gref != trans_gref ||\n                          !act->is_sub_page)) )\n        {\n            release_grant_for_copy(td, trans_gref, readonly);\n            rcu_unlock_domain(td);\n            reduce_status_for_pin(rd, act, status, readonly);\n            active_entry_release(act);\n            grant_read_unlock(rgt);\n            put_page(*page);\n            *page = NULL;\n            return ERESTART;\n        }\n\n        if ( !old_pin )\n        {\n            act->domid = ldom;\n            act->start = trans_page_off;\n            act->length = trans_length;\n            act->trans_domain = td;\n            act->trans_gref = trans_gref;\n            act->mfn = grant_mfn;\n            act_set_gfn(act, INVALID_GFN);\n            /*\n             * The actual remote remote grant may or may not be a sub-page,\n             * but we always treat it as one because that blocks mappings of\n             * transitive grants.\n             */\n            act->is_sub_page = true;\n        }\n    }\n    else if ( !old_pin ||\n              (!readonly && !(old_pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               readonly, 0, ldom)) != GNTST_okay )\n             goto unlock_out;\n\n        td = rd;\n        trans_gref = gref;\n        if ( !sha2 )\n        {\n            unsigned long gfn = shared_entry_v1(rgt, gref).frame;\n\n            rc = get_paged_frame(gfn, &grant_mfn, page, readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            is_sub_page = false;\n            trans_page_off = 0;\n            trans_length = PAGE_SIZE;\n        }\n        else if ( !(sha2->hdr.flags & GTF_sub_page) )\n        {\n            rc = get_paged_frame(sha2->full_page.frame, &grant_mfn, page,\n                                 readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(sha2->full_page.frame));\n            is_sub_page = false;\n            trans_page_off = 0;\n            trans_length = PAGE_SIZE;\n        }\n        else\n        {\n            rc = get_paged_frame(sha2->sub_page.frame, &grant_mfn, page,\n                                 readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(sha2->sub_page.frame));\n            is_sub_page = true;\n            trans_page_off = sha2->sub_page.page_off;\n            trans_length = sha2->sub_page.length;\n        }\n\n        if ( !act->pin )\n        {\n            act->domid = ldom;\n            act->is_sub_page = is_sub_page;\n            act->start = trans_page_off;\n            act->length = trans_length;\n            act->trans_domain = td;\n            act->trans_gref = trans_gref;\n            act->mfn = grant_mfn;\n        }\n    }\n    else\n    {\n        ASSERT(mfn_valid(act->mfn));\n        *page = mfn_to_page(act->mfn);\n        td = page_get_owner_and_reference(*page);\n        /*\n         * act->pin being non-zero should guarantee the page to have a\n         * non-zero refcount and hence a valid owner (matching the one on\n         * record), with one exception: If the owning domain is dying we\n         * had better not make implications from pin count (map_grant_ref()\n         * updates pin counts before obtaining page references, for\n         * example).\n         */\n        if ( td != rd || rd->is_dying )\n        {\n            if ( td )\n                put_page(*page);\n            *page = NULL;\n            rc = GNTST_bad_domain;\n            goto unlock_out_clear;\n        }\n    }\n\n    act->pin += pin_incr;\n\n    *page_off = act->start;\n    *length = act->length;\n    *mfn = act->mfn;\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n    return rc;\n\n unlock_out_clear:\n    reduce_status_for_pin(rd, act, status, readonly);\n\n unlock_out:\n    active_entry_release(act);\n\n gt_unlock_out:\n    grant_read_unlock(rgt);\n\n    return rc;\n}",
        "func": "static int\nacquire_grant_for_copy(\n    struct domain *rd, grant_ref_t gref, domid_t ldom, bool readonly,\n    mfn_t *mfn, struct page_info **page, uint16_t *page_off,\n    uint16_t *length, bool allow_transitive)\n{\n    struct grant_table *rgt = rd->grant_table;\n    grant_entry_v2_t *sha2;\n    grant_entry_header_t *shah;\n    struct active_grant_entry *act;\n    grant_status_t *status;\n    uint32_t old_pin;\n    domid_t trans_domid;\n    grant_ref_t trans_gref;\n    struct domain *td;\n    mfn_t grant_mfn;\n    uint16_t trans_page_off;\n    uint16_t trans_length;\n    bool is_sub_page;\n    s16 rc = GNTST_okay;\n    unsigned int pin_incr = readonly ? GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    *page = NULL;\n\n    grant_read_lock(rgt);\n\n    if ( unlikely(gref >= nr_grant_entries(rgt)) )\n        PIN_FAIL(gt_unlock_out, GNTST_bad_gntref,\n                 \"Bad grant reference %#x\\n\", gref);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, gref);\n    act = active_entry_acquire(rgt, gref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ldom) ||\n          (act->pin & GNTPIN_incr2oflow_mask(pin_incr))) )\n        PIN_FAIL(unlock_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x\\n\",\n                 act->domid, ldom, act->pin);\n\n    if ( evaluate_nospec(rgt->gt_version == 1) )\n    {\n        sha2 = NULL;\n        status = &shah->flags;\n    }\n    else\n    {\n        sha2 = &shared_entry_v2(rgt, gref);\n        status = &status_entry(rgt, gref);\n    }\n\n    old_pin = act->pin;\n    if ( sha2 && (shah->flags & GTF_type_mask) == GTF_transitive )\n    {\n        if ( (!old_pin || (!readonly &&\n                           !(old_pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)))) &&\n             (rc = _set_status_v2(shah, status, rd, act, readonly, 0,\n                                  ldom)) != GNTST_okay )\n            goto unlock_out;\n\n        if ( !allow_transitive )\n            PIN_FAIL(unlock_out_clear, GNTST_general_error,\n                     \"transitive grant when transitivity not allowed\\n\");\n\n        trans_domid = sha2->transitive.trans_domid;\n        trans_gref = sha2->transitive.gref;\n        barrier(); /* Stop the compiler from re-loading\n                      trans_domid from shared memory */\n        if ( trans_domid == rd->domain_id )\n            PIN_FAIL(unlock_out_clear, GNTST_general_error,\n                     \"transitive grants cannot be self-referential\\n\");\n\n        /*\n         * We allow the trans_domid == ldom case, which corresponds to a\n         * grant being issued by one domain, sent to another one, and then\n         * transitively granted back to the original domain.  Allowing it\n         * is easy, and means that you don't need to go out of your way to\n         * avoid it in the guest.\n         */\n\n        /* We need to leave the rrd locked during the grant copy. */\n        td = rcu_lock_domain_by_id(trans_domid);\n        if ( td == NULL )\n            PIN_FAIL(unlock_out_clear, GNTST_general_error,\n                     \"transitive grant referenced bad domain %d\\n\",\n                     trans_domid);\n\n        /*\n         * acquire_grant_for_copy() will take the lock on the remote table,\n         * so we have to drop the lock here and reacquire.\n         */\n        active_entry_release(act);\n        grant_read_unlock(rgt);\n\n        rc = acquire_grant_for_copy(td, trans_gref, rd->domain_id,\n                                    readonly, &grant_mfn, page,\n                                    &trans_page_off, &trans_length,\n                                    false);\n\n        grant_read_lock(rgt);\n        act = active_entry_acquire(rgt, gref);\n\n        if ( rc != GNTST_okay )\n        {\n            rcu_unlock_domain(td);\n            reduce_status_for_pin(rd, act, status, readonly);\n            active_entry_release(act);\n            grant_read_unlock(rgt);\n            return rc;\n        }\n\n        /*\n         * We dropped the lock, so we have to check that the grant didn't\n         * change, and that nobody else tried to pin/unpin it. If anything\n         * changed, just give up and tell the caller to retry.\n         */\n        if ( rgt->gt_version != 2 ||\n             act->pin != old_pin ||\n             (old_pin && (act->domid != ldom ||\n                          !mfn_eq(act->mfn, grant_mfn) ||\n                          act->start != trans_page_off ||\n                          act->length != trans_length ||\n                          act->trans_domain != td ||\n                          act->trans_gref != trans_gref ||\n                          !act->is_sub_page)) )\n        {\n            /*\n             * Like above for acquire_grant_for_copy() we need to drop and then\n             * re-acquire the locks here to prevent lock order inversion issues.\n             * Unlike for acquire_grant_for_copy() we don't need to re-check\n             * anything, as release_grant_for_copy() doesn't depend on the grant\n             * table entry: It only updates internal state and the status flags.\n             */\n            active_entry_release(act);\n            grant_read_unlock(rgt);\n\n            release_grant_for_copy(td, trans_gref, readonly);\n            rcu_unlock_domain(td);\n\n            grant_read_lock(rgt);\n            act = active_entry_acquire(rgt, gref);\n            reduce_status_for_pin(rd, act, status, readonly);\n            active_entry_release(act);\n            grant_read_unlock(rgt);\n\n            put_page(*page);\n            *page = NULL;\n            return ERESTART;\n        }\n\n        if ( !old_pin )\n        {\n            act->domid = ldom;\n            act->start = trans_page_off;\n            act->length = trans_length;\n            act->trans_domain = td;\n            act->trans_gref = trans_gref;\n            act->mfn = grant_mfn;\n            act_set_gfn(act, INVALID_GFN);\n            /*\n             * The actual remote remote grant may or may not be a sub-page,\n             * but we always treat it as one because that blocks mappings of\n             * transitive grants.\n             */\n            act->is_sub_page = true;\n        }\n    }\n    else if ( !old_pin ||\n              (!readonly && !(old_pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               readonly, 0, ldom)) != GNTST_okay )\n             goto unlock_out;\n\n        td = rd;\n        trans_gref = gref;\n        if ( !sha2 )\n        {\n            unsigned long gfn = shared_entry_v1(rgt, gref).frame;\n\n            rc = get_paged_frame(gfn, &grant_mfn, page, readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            is_sub_page = false;\n            trans_page_off = 0;\n            trans_length = PAGE_SIZE;\n        }\n        else if ( !(sha2->hdr.flags & GTF_sub_page) )\n        {\n            rc = get_paged_frame(sha2->full_page.frame, &grant_mfn, page,\n                                 readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(sha2->full_page.frame));\n            is_sub_page = false;\n            trans_page_off = 0;\n            trans_length = PAGE_SIZE;\n        }\n        else\n        {\n            rc = get_paged_frame(sha2->sub_page.frame, &grant_mfn, page,\n                                 readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(sha2->sub_page.frame));\n            is_sub_page = true;\n            trans_page_off = sha2->sub_page.page_off;\n            trans_length = sha2->sub_page.length;\n        }\n\n        if ( !act->pin )\n        {\n            act->domid = ldom;\n            act->is_sub_page = is_sub_page;\n            act->start = trans_page_off;\n            act->length = trans_length;\n            act->trans_domain = td;\n            act->trans_gref = trans_gref;\n            act->mfn = grant_mfn;\n        }\n    }\n    else\n    {\n        ASSERT(mfn_valid(act->mfn));\n        *page = mfn_to_page(act->mfn);\n        td = page_get_owner_and_reference(*page);\n        /*\n         * act->pin being non-zero should guarantee the page to have a\n         * non-zero refcount and hence a valid owner (matching the one on\n         * record), with one exception: If the owning domain is dying we\n         * had better not make implications from pin count (map_grant_ref()\n         * updates pin counts before obtaining page references, for\n         * example).\n         */\n        if ( td != rd || rd->is_dying )\n        {\n            if ( td )\n                put_page(*page);\n            *page = NULL;\n            rc = GNTST_bad_domain;\n            goto unlock_out_clear;\n        }\n    }\n\n    act->pin += pin_incr;\n\n    *page_off = act->start;\n    *length = act->length;\n    *mfn = act->mfn;\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n    return rc;\n\n unlock_out_clear:\n    reduce_status_for_pin(rd, act, status, readonly);\n\n unlock_out:\n    active_entry_release(act);\n\n gt_unlock_out:\n    grant_read_unlock(rgt);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -88,9 +88,8 @@\n                      trans_domid);\n \n         /*\n-         * acquire_grant_for_copy() could take the lock on the\n-         * remote table (if rd == td), so we have to drop the lock\n-         * here and reacquire.\n+         * acquire_grant_for_copy() will take the lock on the remote table,\n+         * so we have to drop the lock here and reacquire.\n          */\n         active_entry_release(act);\n         grant_read_unlock(rgt);\n@@ -127,11 +126,25 @@\n                           act->trans_gref != trans_gref ||\n                           !act->is_sub_page)) )\n         {\n+            /*\n+             * Like above for acquire_grant_for_copy() we need to drop and then\n+             * re-acquire the locks here to prevent lock order inversion issues.\n+             * Unlike for acquire_grant_for_copy() we don't need to re-check\n+             * anything, as release_grant_for_copy() doesn't depend on the grant\n+             * table entry: It only updates internal state and the status flags.\n+             */\n+            active_entry_release(act);\n+            grant_read_unlock(rgt);\n+\n             release_grant_for_copy(td, trans_gref, readonly);\n             rcu_unlock_domain(td);\n+\n+            grant_read_lock(rgt);\n+            act = active_entry_acquire(rgt, gref);\n             reduce_status_for_pin(rd, act, status, readonly);\n             active_entry_release(act);\n             grant_read_unlock(rgt);\n+\n             put_page(*page);\n             *page = NULL;\n             return ERESTART;",
        "diff_line_info": {
            "deleted_lines": [
                "         * acquire_grant_for_copy() could take the lock on the",
                "         * remote table (if rd == td), so we have to drop the lock",
                "         * here and reacquire."
            ],
            "added_lines": [
                "         * acquire_grant_for_copy() will take the lock on the remote table,",
                "         * so we have to drop the lock here and reacquire.",
                "            /*",
                "             * Like above for acquire_grant_for_copy() we need to drop and then",
                "             * re-acquire the locks here to prevent lock order inversion issues.",
                "             * Unlike for acquire_grant_for_copy() we don't need to re-check",
                "             * anything, as release_grant_for_copy() doesn't depend on the grant",
                "             * table entry: It only updates internal state and the status flags.",
                "             */",
                "            active_entry_release(act);",
                "            grant_read_unlock(rgt);",
                "",
                "",
                "            grant_read_lock(rgt);",
                "            act = active_entry_acquire(rgt, gref);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39157",
        "func_name": "sonicdoe/detect-character-encoding/NAN_METHOD",
        "description": "detect-character-encoding is an open source character encoding inspection library. In detect-character-encoding v0.6.0 and earlier, data matching no charset causes the Node.js process to crash. The problem has been patched in [detect-character-encoding v0.7.0](https://github.com/sonicdoe/detect-character-encoding/releases/tag/v0.7.0). No workaround are available and all users should update to resolve this issue.",
        "git_url": "https://github.com/sonicdoe/detect-character-encoding/commit/992a11007fff6cfd40b952150ab8d30410c4a20a",
        "commit_title": "Return null if no charset matches",
        "commit_text": " Fixes a segmentation fault if no charset matches. According to http://icu-project.org/apiref/icu4c/ucsdet_8h.html#aff2633b5055d472cff4108d94f97cf7d, ucsdet_detect() may return NULL if no charset matches.  Co-authored-by: chenzhip <letme2010@gmail.com>",
        "func_before": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\n\tcharsetDetector = ucsdet_open(&errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}",
        "func": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\n\tcharsetDetector = ucsdet_open(&errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tif(charsetMatch == NULL) {\n\t\tinfo.GetReturnValue().Set(Nan::Null());\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,12 @@\n \t\treturn;\n \t}\n \n+\tif(charsetMatch == NULL) {\n+\t\tinfo.GetReturnValue().Set(Nan::Null());\n+\t\tucsdet_close(charsetDetector);\n+\t\treturn;\n+\t}\n+\n \tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n \n \tif(U_FAILURE(errorCode)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif(charsetMatch == NULL) {",
                "\t\tinfo.GetReturnValue().Set(Nan::Null());",
                "\t\tucsdet_close(charsetDetector);",
                "\t\treturn;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17044",
        "func_name": "xen-project/xen/p2m_pod_demand_populate",
        "description": "An issue was discovered in Xen through 4.9.x allowing HVM guest OS users to cause a denial of service (infinite loop and host OS hang) by leveraging the mishandling of Populate on Demand (PoD) errors.",
        "git_url": "https://github.com/xen-project/xen/commit/a1c6c6768971ea387d7eba0803908ef0928b43ac",
        "commit_title": "x86/pod: prevent infinite loop when shattering large pages",
        "commit_text": " When populating pages, the PoD may need to split large ones using p2m_set_entry and request the caller to retry (see ept_get_entry for instance).  p2m_set_entry may fail to shatter if it is not possible to allocate memory for the new page table. However, the error is not propagated resulting to the callers to retry infinitely the PoD.  Prevent the infinite loop by return false when it is not possible to shatter the large mapping.  This is XSA-246. ",
        "func_before": "bool\np2m_pod_demand_populate(struct p2m_domain *p2m, gfn_t gfn,\n                        unsigned int order)\n{\n    struct domain *d = p2m->domain;\n    struct page_info *p = NULL; /* Compiler warnings */\n    gfn_t gfn_aligned = _gfn((gfn_x(gfn) >> order) << order);\n    mfn_t mfn;\n    unsigned long i;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n    pod_lock(p2m);\n\n    /*\n     * This check is done with the pod lock held.  This will make sure that\n     * even if d->is_dying changes under our feet, p2m_pod_empty_cache()\n     * won't start until we're done.\n     */\n    if ( unlikely(d->is_dying) )\n        goto out_fail;\n\n\n    /*\n     * Because PoD does not have cache list for 1GB pages, it has to remap\n     * 1GB region to 2MB chunks for a retry.\n     */\n    if ( order == PAGE_ORDER_1G )\n    {\n        pod_unlock(p2m);\n        /*\n         * Note that we are supposed to call p2m_set_entry() 512 times to\n         * split 1GB into 512 2MB pages here. But We only do once here because\n         * p2m_set_entry() should automatically shatter the 1GB page into\n         * 512 2MB pages. The rest of 511 calls are unnecessary.\n         *\n         * NOTE: In a fine-grained p2m locking scenario this operation\n         * may need to promote its locking from gfn->1g superpage\n         */\n        p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n                      p2m_populate_on_demand, p2m->default_access);\n        return true;\n    }\n\n    /* Only reclaim if we're in actual need of more cache. */\n    if ( p2m->pod.entry_count > p2m->pod.count )\n        pod_eager_reclaim(p2m);\n\n    /*\n     * Only sweep if we're actually out of memory.  Doing anything else\n     * causes unnecessary time and fragmentation of superpages in the p2m.\n     */\n    if ( p2m->pod.count == 0 )\n        p2m_pod_emergency_sweep(p2m);\n\n    /* If the sweep failed, give up. */\n    if ( p2m->pod.count == 0 )\n        goto out_of_memory;\n\n    /* Keep track of the highest gfn demand-populated by a guest fault */\n    p2m->pod.max_guest = gfn_max(gfn, p2m->pod.max_guest);\n\n    /*\n     * Get a page f/ the cache.  A NULL return value indicates that the\n     * 2-meg range should be marked singleton PoD, and retried.\n     */\n    if ( (p = p2m_pod_cache_get(p2m, order)) == NULL )\n        goto remap_and_retry;\n\n    mfn = page_to_mfn(p);\n\n    BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n\n    p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n                  p2m->default_access);\n\n    for( i = 0; i < (1UL << order); i++ )\n    {\n        set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_x(gfn_aligned) + i);\n        paging_mark_dirty(d, mfn_add(mfn, i));\n    }\n\n    p2m->pod.entry_count -= (1UL << order);\n    BUG_ON(p2m->pod.entry_count < 0);\n\n    pod_eager_record(p2m, gfn_aligned, order);\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn, mfn;\n            int d:16,order:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.mfn = mfn_x(mfn);\n        t.d = d->domain_id;\n        t.order = order;\n\n        __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t);\n    }\n\n    pod_unlock(p2m);\n    return true;\nout_of_memory:\n    pod_unlock(p2m);\n\n    printk(\"%s: Dom%d out of PoD memory! (tot=%\"PRIu32\" ents=%ld dom%d)\\n\",\n           __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,\n           current->domain->domain_id);\n    domain_crash(d);\n    return false;\nout_fail:\n    pod_unlock(p2m);\n    return false;\nremap_and_retry:\n    BUG_ON(order != PAGE_ORDER_2M);\n    pod_unlock(p2m);\n\n    /* Remap this 2-meg region in singleton chunks */\n    /*\n     * NOTE: In a p2m fine-grained lock scenario this might\n     * need promoting the gfn lock from gfn->2M superpage.\n     */\n    for ( i = 0; i < (1UL << order); i++ )\n        p2m_set_entry(p2m, gfn_add(gfn_aligned, i), INVALID_MFN, PAGE_ORDER_4K,\n                      p2m_populate_on_demand, p2m->default_access);\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn;\n            int d:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.d = d->domain_id;\n\n        __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t);\n    }\n\n    return true;\n}",
        "func": "bool\np2m_pod_demand_populate(struct p2m_domain *p2m, gfn_t gfn,\n                        unsigned int order)\n{\n    struct domain *d = p2m->domain;\n    struct page_info *p = NULL; /* Compiler warnings */\n    gfn_t gfn_aligned = _gfn((gfn_x(gfn) >> order) << order);\n    mfn_t mfn;\n    unsigned long i;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n    pod_lock(p2m);\n\n    /*\n     * This check is done with the pod lock held.  This will make sure that\n     * even if d->is_dying changes under our feet, p2m_pod_empty_cache()\n     * won't start until we're done.\n     */\n    if ( unlikely(d->is_dying) )\n        goto out_fail;\n\n\n    /*\n     * Because PoD does not have cache list for 1GB pages, it has to remap\n     * 1GB region to 2MB chunks for a retry.\n     */\n    if ( order == PAGE_ORDER_1G )\n    {\n        pod_unlock(p2m);\n        /*\n         * Note that we are supposed to call p2m_set_entry() 512 times to\n         * split 1GB into 512 2MB pages here. But We only do once here because\n         * p2m_set_entry() should automatically shatter the 1GB page into\n         * 512 2MB pages. The rest of 511 calls are unnecessary.\n         *\n         * NOTE: In a fine-grained p2m locking scenario this operation\n         * may need to promote its locking from gfn->1g superpage\n         */\n        return !p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n                              p2m_populate_on_demand, p2m->default_access);\n    }\n\n    /* Only reclaim if we're in actual need of more cache. */\n    if ( p2m->pod.entry_count > p2m->pod.count )\n        pod_eager_reclaim(p2m);\n\n    /*\n     * Only sweep if we're actually out of memory.  Doing anything else\n     * causes unnecessary time and fragmentation of superpages in the p2m.\n     */\n    if ( p2m->pod.count == 0 )\n        p2m_pod_emergency_sweep(p2m);\n\n    /* If the sweep failed, give up. */\n    if ( p2m->pod.count == 0 )\n        goto out_of_memory;\n\n    /* Keep track of the highest gfn demand-populated by a guest fault */\n    p2m->pod.max_guest = gfn_max(gfn, p2m->pod.max_guest);\n\n    /*\n     * Get a page f/ the cache.  A NULL return value indicates that the\n     * 2-meg range should be marked singleton PoD, and retried.\n     */\n    if ( (p = p2m_pod_cache_get(p2m, order)) == NULL )\n        goto remap_and_retry;\n\n    mfn = page_to_mfn(p);\n\n    BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n\n    if ( p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n                       p2m->default_access) )\n    {\n        p2m_pod_cache_add(p2m, p, order);\n        goto out_fail;\n    }\n\n    for( i = 0; i < (1UL << order); i++ )\n    {\n        set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_x(gfn_aligned) + i);\n        paging_mark_dirty(d, mfn_add(mfn, i));\n    }\n\n    p2m->pod.entry_count -= (1UL << order);\n    BUG_ON(p2m->pod.entry_count < 0);\n\n    pod_eager_record(p2m, gfn_aligned, order);\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn, mfn;\n            int d:16,order:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.mfn = mfn_x(mfn);\n        t.d = d->domain_id;\n        t.order = order;\n\n        __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t);\n    }\n\n    pod_unlock(p2m);\n    return true;\nout_of_memory:\n    pod_unlock(p2m);\n\n    printk(\"%s: Dom%d out of PoD memory! (tot=%\"PRIu32\" ents=%ld dom%d)\\n\",\n           __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,\n           current->domain->domain_id);\n    domain_crash(d);\n    return false;\nout_fail:\n    pod_unlock(p2m);\n    return false;\nremap_and_retry:\n    BUG_ON(order != PAGE_ORDER_2M);\n    pod_unlock(p2m);\n\n    /*\n     * Remap this 2-meg region in singleton chunks. See the comment on the\n     * 1G page splitting path above for why a single call suffices.\n     *\n     * NOTE: In a p2m fine-grained lock scenario this might\n     * need promoting the gfn lock from gfn->2M superpage.\n     */\n    if ( p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_4K,\n                       p2m_populate_on_demand, p2m->default_access) )\n        return false;\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn;\n            int d:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.d = d->domain_id;\n\n        __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t);\n    }\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,9 +36,8 @@\n          * NOTE: In a fine-grained p2m locking scenario this operation\n          * may need to promote its locking from gfn->1g superpage\n          */\n-        p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n-                      p2m_populate_on_demand, p2m->default_access);\n-        return true;\n+        return !p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n+                              p2m_populate_on_demand, p2m->default_access);\n     }\n \n     /* Only reclaim if we're in actual need of more cache. */\n@@ -70,8 +69,12 @@\n \n     BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n \n-    p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n-                  p2m->default_access);\n+    if ( p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n+                       p2m->default_access) )\n+    {\n+        p2m_pod_cache_add(p2m, p, order);\n+        goto out_fail;\n+    }\n \n     for( i = 0; i < (1UL << order); i++ )\n     {\n@@ -116,14 +119,17 @@\n     BUG_ON(order != PAGE_ORDER_2M);\n     pod_unlock(p2m);\n \n-    /* Remap this 2-meg region in singleton chunks */\n     /*\n+     * Remap this 2-meg region in singleton chunks. See the comment on the\n+     * 1G page splitting path above for why a single call suffices.\n+     *\n      * NOTE: In a p2m fine-grained lock scenario this might\n      * need promoting the gfn lock from gfn->2M superpage.\n      */\n-    for ( i = 0; i < (1UL << order); i++ )\n-        p2m_set_entry(p2m, gfn_add(gfn_aligned, i), INVALID_MFN, PAGE_ORDER_4K,\n-                      p2m_populate_on_demand, p2m->default_access);\n+    if ( p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_4K,\n+                       p2m_populate_on_demand, p2m->default_access) )\n+        return false;\n+\n     if ( tb_init_done )\n     {\n         struct {",
        "diff_line_info": {
            "deleted_lines": [
                "        p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,",
                "                      p2m_populate_on_demand, p2m->default_access);",
                "        return true;",
                "    p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,",
                "                  p2m->default_access);",
                "    /* Remap this 2-meg region in singleton chunks */",
                "    for ( i = 0; i < (1UL << order); i++ )",
                "        p2m_set_entry(p2m, gfn_add(gfn_aligned, i), INVALID_MFN, PAGE_ORDER_4K,",
                "                      p2m_populate_on_demand, p2m->default_access);"
            ],
            "added_lines": [
                "        return !p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,",
                "                              p2m_populate_on_demand, p2m->default_access);",
                "    if ( p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,",
                "                       p2m->default_access) )",
                "    {",
                "        p2m_pod_cache_add(p2m, p, order);",
                "        goto out_fail;",
                "    }",
                "     * Remap this 2-meg region in singleton chunks. See the comment on the",
                "     * 1G page splitting path above for why a single call suffices.",
                "     *",
                "    if ( p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_4K,",
                "                       p2m_populate_on_demand, p2m->default_access) )",
                "        return false;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29017",
        "func_name": "axiomatic-systems/Bento4/main",
        "description": "Bento4 v1.6.0.0 was discovered to contain a segmentation fault via the component /x86_64/multiarch/strlen-avx2.S.",
        "git_url": "https://github.com/axiomatic-systems/Bento4/commit/33331ce2d35d45d855af7441db6116b4a9e2b70f",
        "commit_title": "fix #691",
        "commit_text": "",
        "func_before": "int\nmain(int argc, char** argv)\n{\n    if (argc < 2) {\n        PrintUsageAndExit();\n    }\n    \n    // default options\n    Options.input                          = NULL;\n    Options.verbose                        = false;\n    Options.hls_version                    = 0;\n    Options.pmt_pid                        = 0x100;\n    Options.audio_pid                      = 0x101;\n    Options.video_pid                      = 0x102;\n    Options.audio_track_id                 = -1;\n    Options.video_track_id                 = -1;\n    Options.audio_format                   = AUDIO_FORMAT_TS;\n    Options.output_single_file             = false;\n    Options.show_info                      = false;\n    Options.index_filename                 = \"stream.m3u8\";\n    Options.iframe_index_filename          = NULL;\n    Options.segment_filename_template      = NULL;\n    Options.segment_url_template           = NULL;\n    Options.segment_duration               = 6;\n    Options.segment_duration_threshold     = DefaultSegmentDurationThreshold;\n    Options.allow_cache                    = NULL;\n    Options.encryption_key_hex             = NULL;\n    Options.encryption_mode                = ENCRYPTION_MODE_NONE;\n    Options.encryption_iv_mode             = ENCRYPTION_IV_MODE_NONE;\n    Options.encryption_key_uri             = \"key.bin\";\n    Options.encryption_key_format          = NULL;\n    Options.encryption_key_format_versions = NULL;\n    Options.pcr_offset                     = AP4_MPEG2_TS_DEFAULT_PCR_OFFSET;\n    AP4_SetMemory(Options.encryption_key, 0, sizeof(Options.encryption_key));\n    AP4_SetMemory(Options.encryption_iv,  0, sizeof(Options.encryption_iv));\n    AP4_SetMemory(&Stats, 0, sizeof(Stats));\n\n    // parse command line\n    AP4_Result result;\n    char** args = argv+1;\n    while (const char* arg = *args++) {\n        if (!strcmp(arg, \"--verbose\")) {\n            Options.verbose = true;\n        } else if (!strcmp(arg, \"--hls-version\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --hls-version requires a number\\n\");\n                return 1;\n            }\n            Options.hls_version = (unsigned int)strtoul(*args++, NULL, 10);\n            if (Options.hls_version ==0) {\n                fprintf(stderr, \"ERROR: --hls-version requires number > 0\\n\");\n                return 1;\n            }\n        } else if (!strcmp(arg, \"--segment-duration\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --segment-duration requires a number\\n\");\n                return 1;\n            }\n            Options.segment_duration = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--segment-duration-threshold\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --segment-duration-threshold requires a number\\n\");\n                return 1;\n            }\n            Options.segment_duration_threshold = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--segment-filename-template\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --segment-filename-template requires an argument\\n\");\n                return 1;\n            }\n            Options.segment_filename_template = *args++;\n        } else if (!strcmp(arg, \"--segment-url-template\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --segment-url-template requires an argument\\n\");\n                return 1;\n            }\n            Options.segment_url_template = *args++;\n        } else if (!strcmp(arg, \"--allow-cache\")) {\n            if (*args == NULL || (strcmp(*args, \"NO\") && strcmp(*args, \"YES\"))) {\n                fprintf(stderr, \"ERROR: --allow-cache requires a YES or NO argument\\n\");\n                return 1;\n            }\n            Options.allow_cache = *args++;\n        } else if (!strcmp(arg, \"--pmt-pid\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --pmt-pid requires a number\\n\");\n                return 1;\n            }\n            Options.pmt_pid = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--audio-pid\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --audio-pid requires a number\\n\");\n                return 1;\n            }\n            Options.audio_pid = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--video-pid\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --video-pid requires a number\\n\");\n                return 1;\n            }\n            Options.video_pid = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--audio-track-id\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --audio-track-id requires a number\\n\");\n                return 1;\n            }\n            Options.audio_track_id = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--audio-format\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --audio-format requires an argument\\n\");\n                return 1;\n            }\n            const char* format = *args++;\n            if (!strcmp(format, \"ts\")) {\n                Options.audio_format = AUDIO_FORMAT_TS;\n            } else if (!strcmp(format, \"packed\")) {\n                Options.audio_format = AUDIO_FORMAT_PACKED;\n            } else {\n                fprintf(stderr, \"ERROR: unknown audio format\\n\");\n                return 1;\n            }\n        } else if (!strcmp(arg, \"--video-track-id\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --video-track-id requires a number\\n\");\n                return 1;\n            }\n            Options.video_track_id = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--pcr-offset\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --pcr-offset requires a number\\n\");\n                return 1;\n            }\n            Options.pcr_offset = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--output-single-file\")) {\n            Options.output_single_file = true;\n        } else if (!strcmp(arg, \"--index-filename\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --index-filename requires a filename\\n\");\n                return 1;\n            }\n            Options.index_filename = *args++;\n        } else if (!strcmp(arg, \"--iframe-index-filename\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --iframe-index-filename requires a filename\\n\");\n                return 1;\n            }\n            Options.iframe_index_filename = *args++;\n        } else if (!strcmp(arg, \"--show-info\")) {\n            Options.show_info = true;\n        } else if (!strcmp(arg, \"--encryption-key\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_hex = *args++;\n            result = AP4_ParseHex(Options.encryption_key_hex, Options.encryption_key, 16);\n            if (AP4_FAILED(result)) {\n                fprintf(stderr, \"ERROR: invalid hex key\\n\");\n                return 1;\n            }\n            if (Options.encryption_mode == ENCRYPTION_MODE_NONE) {\n                Options.encryption_mode = ENCRYPTION_MODE_AES_128;\n            }\n        } else if (!strcmp(arg, \"--encryption-mode\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-mode requires an argument\\n\");\n                return 1;\n            }\n            if (strncmp(*args, \"AES-128\", 7) == 0) {\n                Options.encryption_mode = ENCRYPTION_MODE_AES_128;\n            } else if (strncmp(*args, \"SAMPLE-AES\", 10) == 0) {\n                Options.encryption_mode = ENCRYPTION_MODE_SAMPLE_AES;\n            } else {\n                fprintf(stderr, \"ERROR: unknown encryption mode\\n\");\n                return 1;\n            }\n            ++args;\n        } else if (!strcmp(arg, \"--encryption-iv-mode\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-iv-mode requires an argument\\n\");\n                return 1;\n            }\n            if (strncmp(*args, \"sequence\", 8) == 0) {\n                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_SEQUENCE;\n            } else if (strncmp(*args, \"random\", 6) == 0) {\n                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_RANDOM;\n            } else if (strncmp(*args, \"fps\", 3) == 0) {\n                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_FPS;\n            } else {\n                fprintf(stderr, \"ERROR: unknown encryption IV mode\\n\");\n                return 1;\n            }\n            ++args;\n        } else if (!strcmp(arg, \"--encryption-key-uri\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key-uri requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_uri = *args++;\n        } else if (!strcmp(arg, \"--encryption-key-format\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key-format requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_format = *args++;\n        } else if (!strcmp(arg, \"--encryption-key-format-versions\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key-format-versions requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_format_versions = *args++;\n        } else if (!strcmp(arg, \"--encryption-key-line\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key-line requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_lines.Append(*args++);\n        } else if (Options.input == NULL) {\n            Options.input = arg;\n        } else {\n            fprintf(stderr, \"ERROR: unexpected argument: %s\\n\", arg);\n            return 1;\n        }\n    }\n\n    // check args\n    if (Options.input == NULL) {\n        fprintf(stderr, \"ERROR: missing input file name\\n\");\n        return 1;\n    }\n    if (Options.encryption_mode == ENCRYPTION_MODE_NONE && Options.encryption_key_lines.ItemCount() != 0) {\n        fprintf(stderr, \"ERROR: --encryption-key-line requires --encryption-key and --encryption-key-mode\\n\");\n        return 1;\n    }\n    if (Options.encryption_mode != ENCRYPTION_MODE_NONE && Options.encryption_key_hex == NULL) {\n        fprintf(stderr, \"ERROR: no encryption key specified\\n\");\n        return 1;\n    }\n    if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES && Options.hls_version > 0 && Options.hls_version < 5) {\n        Options.hls_version = 5;\n        fprintf(stderr, \"WARNING: forcing version to 5 in order to support SAMPLE-AES encryption\\n\");\n    }\n    if (Options.iframe_index_filename && Options.hls_version > 0 && Options.hls_version < 4) {\n        fprintf(stderr, \"WARNING: forcing version to 4 in order to support I-FRAME-ONLY playlists\\n\");\n        Options.hls_version = 4;\n    }\n    if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_NONE && Options.encryption_mode != ENCRYPTION_MODE_NONE) {\n        if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n            // sequence-mode IVs don't work well with i-frame only playlists, use random instead\n            Options.encryption_iv_mode = ENCRYPTION_IV_MODE_RANDOM;\n        } else {\n            Options.encryption_iv_mode = ENCRYPTION_IV_MODE_SEQUENCE;\n        }\n    }\n    if ((Options.encryption_key_format || Options.encryption_key_format_versions) && Options.hls_version > 0 && Options.hls_version < 5) {\n        Options.hls_version = 5;\n        fprintf(stderr, \"WARNING: forcing version to 5 in order to support KEYFORMAT and/or KEYFORMATVERSIONS\\n\");\n    }\n    if (Options.output_single_file && Options.hls_version > 0 && Options.hls_version < 4) {\n        Options.hls_version = 4;\n        fprintf(stderr, \"WARNING: forcing version to 4 in order to support single file output\\n\");\n    }\n    if (Options.hls_version == 0) {\n        // default version is 3 for cleartext or AES-128 encryption, and 5 for SAMPLE-AES\n        if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n            Options.hls_version = 5;\n        } else if (Options.output_single_file || Options.iframe_index_filename) {\n            Options.hls_version = 4;\n        } else {\n            Options.hls_version = 3;\n        }\n    }\n    \n    if (Options.verbose && Options.show_info) {\n        fprintf(stderr, \"WARNING: --verbose will be ignored because --show-info is selected\\n\");\n        Options.verbose = false;\n    }\n\n    // compute some derived values\n    if (Options.iframe_index_filename == NULL) {\n        if (Options.hls_version >= 4) {\n            Options.iframe_index_filename = \"iframes.m3u8\";\n        }\n    }\n    if (Options.audio_format == AUDIO_FORMAT_TS) {\n        if (Options.segment_filename_template == NULL) {\n            if (Options.output_single_file) {\n                Options.segment_filename_template = \"stream.ts\";\n            } else {\n                Options.segment_filename_template = \"segment-%d.ts\";\n            }\n        }\n        if (Options.segment_url_template == NULL) {\n            if (Options.output_single_file) {\n                Options.segment_url_template = \"stream.ts\";\n            } else {\n                Options.segment_url_template = \"segment-%d.ts\";\n            }\n        }\n    }\n    \n    if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_FPS) {\n        if (AP4_StringLength(Options.encryption_key_hex) != 64) {\n            fprintf(stderr, \"ERROR: 'fps' IV mode requires a 32 byte key value (64 characters in hex)\\n\");\n            return 1;\n        }\n        result = AP4_ParseHex(Options.encryption_key_hex+32, Options.encryption_iv, 16);\n        if (AP4_FAILED(result)) {\n            fprintf(stderr, \"ERROR: invalid hex IV\\n\");\n            return 1;\n        }\n    } else if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_RANDOM) {\n        result = AP4_System_GenerateRandomBytes(Options.encryption_iv, sizeof(Options.encryption_iv));\n        if (AP4_FAILED(result)) {\n            fprintf(stderr, \"ERROR: failed to get random IV (%d)\\n\", result);\n            return 1;\n        }\n    }\n    \n\t// create the input stream\n    AP4_ByteStream* input = NULL;\n    result = AP4_FileByteStream::Create(Options.input, AP4_FileByteStream::STREAM_MODE_READ, input);\n    if (AP4_FAILED(result)) {\n        fprintf(stderr, \"ERROR: cannot open input (%d)\\n\", result);\n        return 1;\n    }\n    \n\t// open the file\n    AP4_File* input_file = new AP4_File(*input, true);\n\n    // get the movie\n    AP4_SampleDescription* sample_description;\n    AP4_Movie* movie = input_file->GetMovie();\n    if (movie == NULL) {\n        fprintf(stderr, \"ERROR: no movie in file\\n\");\n        return 1;\n    }\n\n    // get the audio and video tracks\n    AP4_Track* audio_track = NULL;\n    if (Options.audio_track_id == -1) {\n        audio_track = movie->GetTrack(AP4_Track::TYPE_AUDIO);\n    } else if (Options.audio_track_id > 0) {\n        audio_track = movie->GetTrack((AP4_UI32)Options.audio_track_id);\n        if (audio_track == NULL) {\n            fprintf(stderr, \"ERROR: audio track ID %d not found\\n\", Options.audio_track_id);\n            return 1;\n        }\n        if (audio_track->GetType() != AP4_Track::TYPE_AUDIO) {\n            fprintf(stderr, \"ERROR: track ID %d is not an audio track\\n\", Options.audio_track_id);\n            return 1;\n        }\n    }\n    AP4_Track* video_track = NULL;\n    if (Options.video_track_id == -1) {\n        video_track = movie->GetTrack(AP4_Track::TYPE_VIDEO);\n    } else if (Options.video_track_id > 0) {\n        video_track = movie->GetTrack((AP4_UI32)Options.video_track_id);\n        if (video_track == NULL) {\n            fprintf(stderr, \"ERROR: video track ID %d not found\\n\", Options.video_track_id);\n            return 1;\n        }\n        if (video_track->GetType() != AP4_Track::TYPE_VIDEO) {\n            fprintf(stderr, \"ERROR: track ID %d is not a video track\\n\", Options.video_track_id);\n            return 1;\n        }\n    }\n    if (audio_track == NULL && video_track == NULL) {\n        fprintf(stderr, \"ERROR: no suitable tracks found\\n\");\n        delete input_file;\n        input->Release();\n        return 1;\n    }\n    if (Options.audio_format == AUDIO_FORMAT_PACKED && video_track != NULL) {\n        if (audio_track == NULL) {\n            fprintf(stderr, \"ERROR: packed audio format requires an audio track\\n\");\n            return 1;\n        }\n        fprintf(stderr, \"WARNING: ignoring video track because of the packed audio format\\n\");\n        video_track = NULL;\n    }\n    if (video_track == NULL) {\n        Options.segment_duration_threshold = 0;\n    }\n    \n    // create the appropriate readers\n    AP4_LinearReader* linear_reader = NULL;\n    SampleReader*     audio_reader  = NULL;\n    SampleReader*     video_reader  = NULL;\n    if (movie->HasFragments()) {\n        // create a linear reader to get the samples\n        linear_reader = new AP4_LinearReader(*movie, input);\n    \n        if (audio_track) {\n            linear_reader->EnableTrack(audio_track->GetId());\n            audio_reader = new FragmentedSampleReader(*linear_reader, audio_track->GetId());\n        }\n        if (video_track) {\n            linear_reader->EnableTrack(video_track->GetId());\n            video_reader = new FragmentedSampleReader(*linear_reader, video_track->GetId());\n        }\n    } else {\n        if (audio_track) {\n            audio_reader = new TrackSampleReader(*audio_track);\n        }\n        if (video_track) {\n            video_reader = new TrackSampleReader(*video_track);\n        }\n    }\n    \n    AP4_Mpeg2TsWriter*               ts_writer = NULL;\n    AP4_Mpeg2TsWriter::SampleStream* audio_stream = NULL;\n    AP4_Mpeg2TsWriter::SampleStream* video_stream = NULL;\n    AP4_UI08                         nalu_length_size = 0;\n    PackedAudioWriter*               packed_writer = NULL;\n    if (Options.audio_format == AUDIO_FORMAT_PACKED) {\n        packed_writer = new PackedAudioWriter();\n    \n        // figure out the file extensions if needed\n        sample_description = audio_track->GetSampleDescription(0);\n        if (sample_description == NULL) {\n            fprintf(stderr, \"ERROR: unable to parse audio sample description\\n\");\n            goto end;\n        }\n        if (Options.segment_filename_template == NULL || Options.segment_url_template == NULL) {\n            const char* default_stream_name    = \"stream.es\";\n            const char* default_stream_pattern = \"segment-%d.es\";\n            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {\n                AP4_MpegAudioSampleDescription* mpeg_audio_desc = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, sample_description);\n                if (mpeg_audio_desc == NULL ||\n                    !(mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG4_AUDIO          ||\n                      mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG2_AAC_AUDIO_LC   ||\n                      mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG2_AAC_AUDIO_MAIN)) {\n                    fprintf(stderr, \"ERROR: only AAC audio is supported\\n\");\n                    return 1;\n                }\n                default_stream_name    = \"stream.aac\";\n                default_stream_pattern = \"segment-%d.aac\";\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3) {\n                default_stream_name    = \"stream.ac3\";\n                default_stream_pattern = \"segment-%d.ac3\";\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n                default_stream_name    = \"stream.ec3\";\n                default_stream_pattern = \"segment-%d.ec3\";\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_4) {\n                default_stream_name    = \"stream.ac4\";\n                default_stream_pattern = \"segment-%d.ac4\";\n            }\n\n            // override the segment names\n            if (Options.segment_filename_template == NULL) {\n                if (Options.output_single_file) {\n                    Options.segment_filename_template = default_stream_name;\n                } else {\n                    Options.segment_filename_template = default_stream_pattern;\n                }\n            }\n            if (Options.segment_url_template == NULL) {\n                if (Options.output_single_file) {\n                    Options.segment_url_template = default_stream_name;\n                } else {\n                    Options.segment_url_template = default_stream_pattern;\n                }\n            }\n        }\n    } else {\n        // create an MPEG2 TS Writer\n        ts_writer = new AP4_Mpeg2TsWriter(Options.pmt_pid);\n\n        // add the audio stream\n        if (audio_track) {\n            sample_description = audio_track->GetSampleDescription(0);\n            if (sample_description == NULL) {\n                fprintf(stderr, \"ERROR: unable to parse audio sample description\\n\");\n                goto end;\n            }\n\n            unsigned int stream_type = 0;\n            unsigned int stream_id   = 0;\n            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {\n                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ISO_IEC_13818_7;\n                } else {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_ISO_IEC_13818_7;\n                }\n                stream_id   = AP4_MPEG2_TS_DEFAULT_STREAM_ID_AUDIO;\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3) {\n                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ATSC_AC3;\n                } else {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_ATSC_AC3;\n                }\n                stream_id   = AP4_MPEG2_TS_STREAM_ID_PRIVATE_STREAM_1;\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ATSC_EAC3;\n                } else {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_ATSC_EAC3;\n                }\n                stream_id   = AP4_MPEG2_TS_STREAM_ID_PRIVATE_STREAM_1;\n            } else {\n                fprintf(stderr, \"ERROR: audio codec not supported\\n\");\n                return 1;\n            }\n            if (stream_type == AP4_MPEG2_STREAM_TYPE_ATSC_EAC3) {\n                // E-AC-3 descriptor\n                unsigned int number_of_channels = 0;\n                AP4_String track_language;\n                AP4_Dec3Atom* dec3 = AP4_DYNAMIC_CAST(AP4_Dec3Atom, sample_description->GetDetails().GetChild(AP4_ATOM_TYPE_DEC3));\n                AP4_BitWriter bits(8);\n                bits.Write(0xCC, 8);\n                bits.Write(0x06, 8);    // fixed value\n                bits.Write(0xC0, 8);    // reserved, bsid_flag, mainid_flag, asvc_flag, mixinfoexists, substream1_flag, substream2_flag and substream3_flag \n                bits.Write(24, 5);      // reserved, full_service_flag and service_type\n                if (dec3->GetSubStreams()[0].acmod == 0) {\n                    number_of_channels = 1;\n                } else if (dec3->GetSubStreams()[0].acmod == 1) {\n                    number_of_channels = 0;\n                } else if (dec3->GetSubStreams()[0].acmod == 2) {\n                    number_of_channels = 2;\n                } else {\n                    number_of_channels = 4;\n                }\n                if (dec3->GetSubStreams()[0].num_dep_sub > 0) {\n                    number_of_channels = 5;\n                }\n                bits.Write(number_of_channels, 3);              // number_of_channels\n                bits.Write(4, 3);                               // language_flag, language_flag_2, reserved\n                bits.Write(dec3->GetSubStreams()[0].bsid, 5);   // bsid\n                track_language = audio_track->GetTrackLanguage();\n                if (track_language.GetLength() == 3) {\n                    bits.Write(track_language.GetChars()[0], 8);\n                    bits.Write(track_language.GetChars()[1], 8);\n                    bits.Write(track_language.GetChars()[2], 8);\n                } else {\n                    bits.Write(0x75, 8);\n                    bits.Write(0x6E, 8);\n                    bits.Write(0x64, 8);\n                }\n                 // setup the audio stream\n                result = ts_writer->SetAudioStream(audio_track->GetMediaTimeScale(),\n                                                   stream_type,\n                                                   stream_id,\n                                                   audio_stream,\n                                                   Options.audio_pid,\n                                                   bits.GetData(), 8,\n                                                   Options.pcr_offset);\n            } else {\n            // setup the audio stream\n            result = ts_writer->SetAudioStream(audio_track->GetMediaTimeScale(),\n                                               stream_type,\n                                               stream_id,\n                                               audio_stream,\n                                               Options.audio_pid,\n                                               NULL, 0,\n                                               Options.pcr_offset);\n            }\n            if (AP4_FAILED(result)) {\n                fprintf(stderr, \"could not create audio stream (%d)\\n\", result);\n                goto end;\n            }\n        }\n        \n        // add the video stream\n        if (video_track) {\n            sample_description = video_track->GetSampleDescription(0);\n            if (sample_description == NULL) {\n                fprintf(stderr, \"ERROR: unable to parse video sample description\\n\");\n                goto end;\n            }\n            \n            // decide on the stream type\n            unsigned int stream_type = 0;\n            unsigned int stream_id   = AP4_MPEG2_TS_DEFAULT_STREAM_ID_VIDEO;\n            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC1 ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC2 ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC3 ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC4 ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVAV ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVA1) {\n                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_AVC;\n                    AP4_AvcSampleDescription* avc_desc = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, sample_description);\n                    if (avc_desc == NULL) {\n                        fprintf(stderr, \"ERROR: not a proper AVC track\\n\");\n                        return 1;\n                    }\n                    nalu_length_size = avc_desc->GetNaluLengthSize();\n                } else {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_AVC;\n                }\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_HEV1 ||\n                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_HVC1 ||\n                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVHE ||\n                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVH1) {\n                stream_type = AP4_MPEG2_STREAM_TYPE_HEVC;\n            } else {\n                fprintf(stderr, \"ERROR: video codec not supported\\n\");\n                return 1;\n            }\n            if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                if (stream_type != AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_AVC) {\n                    fprintf(stderr, \"ERROR: AES-SAMPLE encryption can only be used with H.264 video\\n\");\n                    return 1;\n                }\n            }\n            \n            // setup the video stream\n            result = ts_writer->SetVideoStream(video_track->GetMediaTimeScale(),\n                                               stream_type,\n                                               stream_id,\n                                               video_stream,\n                                               Options.video_pid,\n                                               NULL, 0,\n                                               Options.pcr_offset);\n            if (AP4_FAILED(result)) {\n                fprintf(stderr, \"could not create video stream (%d)\\n\", result);\n                goto end;\n            }\n        }\n    }\n    \n    result = WriteSamples(ts_writer, packed_writer,\n                          audio_track, audio_reader, audio_stream,\n                          video_track, video_reader, video_stream,\n                          Options.segment_duration_threshold,\n                          nalu_length_size);\n    if (AP4_FAILED(result)) {\n        fprintf(stderr, \"ERROR: failed to write samples (%d)\\n\", result);\n    }\n\n    if (Options.show_info) {\n        double average_segment_bitrate = 0.0;\n        if (Stats.segments_total_duration != 0.0) {\n            average_segment_bitrate = 8.0*(double)Stats.segments_total_size/Stats.segments_total_duration;\n        }\n        double average_iframe_bitrate = 0.0;\n        if (Stats.segments_total_duration != 0.0) {\n            average_iframe_bitrate = 8.0*(double)Stats.iframes_total_size/Stats.segments_total_duration;\n        }\n\n        double frame_rate = 0.0;\n        if (video_track && (Stats.segments_total_duration != 0.0)) {\n            double sample_count = (double)video_track->GetSampleCount();\n            double media_duration = (double)video_track->GetMediaDuration();\n            double timescale = (double)video_track->GetMediaTimeScale();\n            if (media_duration > 0.0) {\n                frame_rate = sample_count/(media_duration/timescale);\n            }\n        }\n\n        printf(\n            \"{\\n\"\n        );\n        printf(\n            \"  \\\"stats\\\": {\\n\"\n            \"    \\\"duration\\\": %f,\\n\"\n            \"    \\\"avg_segment_bitrate\\\": %f,\\n\"\n            \"    \\\"max_segment_bitrate\\\": %f,\\n\"\n            \"    \\\"avg_iframe_bitrate\\\": %f,\\n\"\n            \"    \\\"max_iframe_bitrate\\\": %f,\\n\"\n            \"    \\\"frame_rate\\\": %f\\n\"\n            \"  }\",\n            (double)movie->GetDurationMs()/1000.0,\n            average_segment_bitrate,\n            Stats.max_segment_bitrate,\n            average_iframe_bitrate,\n            Stats.max_iframe_bitrate,\n            frame_rate\n        );\n        if (audio_track) {\n            AP4_String codec;\n            AP4_SampleDescription* sdesc = audio_track->GetSampleDescription(0);\n            if (sdesc) {\n                sdesc->GetCodecString(codec);\n            }\n            printf(\n                \",\\n\"\n                \"  \\\"audio\\\": {\\n\"\n                \"    \\\"codec\\\": \\\"%s\\\"\\n\"\n                \"  }\",\n                codec.GetChars()\n            );\n        }\n        if (video_track) {\n            AP4_String codec;\n            AP4_UI16 width = (AP4_UI16)(video_track->GetWidth()/65536.0);\n            AP4_UI16 height = (AP4_UI16)(video_track->GetHeight()/65536.0);\n            AP4_SampleDescription* sdesc = video_track->GetSampleDescription(0);\n            if (sdesc) {\n                sdesc->GetCodecString(codec);\n                AP4_VideoSampleDescription* video_desc = AP4_DYNAMIC_CAST(AP4_VideoSampleDescription, sdesc);\n                if (video_desc) {\n                    width = video_desc->GetWidth();\n                    height = video_desc->GetHeight();\n                }\n            }\n            printf(\n                \",\\n\"\n                \"  \\\"video\\\": {\\n\"\n                \"    \\\"codec\\\": \\\"%s\\\",\\n\"\n                \"    \\\"width\\\": %d,\\n\"\n                \"    \\\"height\\\": %d\\n\"\n                \"  }\",\n                codec.GetChars(),\n                width,\n                height\n            );\n        }\n        printf(\n            \"\\n\"\n            \"}\\n\"\n        );\n    }\n    \nend:\n    delete ts_writer;\n    delete packed_writer;\n    delete input_file;\n    input->Release();\n    delete linear_reader;\n    delete audio_reader;\n    delete video_reader;\n    \n    return result == AP4_SUCCESS?0:1;\n}",
        "func": "int\nmain(int argc, char** argv)\n{\n    if (argc < 2) {\n        PrintUsageAndExit();\n    }\n    \n    // default options\n    Options.input                          = NULL;\n    Options.verbose                        = false;\n    Options.hls_version                    = 0;\n    Options.pmt_pid                        = 0x100;\n    Options.audio_pid                      = 0x101;\n    Options.video_pid                      = 0x102;\n    Options.audio_track_id                 = -1;\n    Options.video_track_id                 = -1;\n    Options.audio_format                   = AUDIO_FORMAT_TS;\n    Options.output_single_file             = false;\n    Options.show_info                      = false;\n    Options.index_filename                 = \"stream.m3u8\";\n    Options.iframe_index_filename          = NULL;\n    Options.segment_filename_template      = NULL;\n    Options.segment_url_template           = NULL;\n    Options.segment_duration               = 6;\n    Options.segment_duration_threshold     = DefaultSegmentDurationThreshold;\n    Options.allow_cache                    = NULL;\n    Options.encryption_key_hex             = NULL;\n    Options.encryption_mode                = ENCRYPTION_MODE_NONE;\n    Options.encryption_iv_mode             = ENCRYPTION_IV_MODE_NONE;\n    Options.encryption_key_uri             = \"key.bin\";\n    Options.encryption_key_format          = NULL;\n    Options.encryption_key_format_versions = NULL;\n    Options.pcr_offset                     = AP4_MPEG2_TS_DEFAULT_PCR_OFFSET;\n    AP4_SetMemory(Options.encryption_key, 0, sizeof(Options.encryption_key));\n    AP4_SetMemory(Options.encryption_iv,  0, sizeof(Options.encryption_iv));\n    AP4_SetMemory(&Stats, 0, sizeof(Stats));\n\n    // parse command line\n    AP4_Result result;\n    char** args = argv+1;\n    while (const char* arg = *args++) {\n        if (!strcmp(arg, \"--verbose\")) {\n            Options.verbose = true;\n        } else if (!strcmp(arg, \"--hls-version\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --hls-version requires a number\\n\");\n                return 1;\n            }\n            Options.hls_version = (unsigned int)strtoul(*args++, NULL, 10);\n            if (Options.hls_version ==0) {\n                fprintf(stderr, \"ERROR: --hls-version requires number > 0\\n\");\n                return 1;\n            }\n        } else if (!strcmp(arg, \"--segment-duration\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --segment-duration requires a number\\n\");\n                return 1;\n            }\n            Options.segment_duration = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--segment-duration-threshold\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --segment-duration-threshold requires a number\\n\");\n                return 1;\n            }\n            Options.segment_duration_threshold = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--segment-filename-template\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --segment-filename-template requires an argument\\n\");\n                return 1;\n            }\n            Options.segment_filename_template = *args++;\n        } else if (!strcmp(arg, \"--segment-url-template\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --segment-url-template requires an argument\\n\");\n                return 1;\n            }\n            Options.segment_url_template = *args++;\n        } else if (!strcmp(arg, \"--allow-cache\")) {\n            if (*args == NULL || (strcmp(*args, \"NO\") && strcmp(*args, \"YES\"))) {\n                fprintf(stderr, \"ERROR: --allow-cache requires a YES or NO argument\\n\");\n                return 1;\n            }\n            Options.allow_cache = *args++;\n        } else if (!strcmp(arg, \"--pmt-pid\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --pmt-pid requires a number\\n\");\n                return 1;\n            }\n            Options.pmt_pid = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--audio-pid\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --audio-pid requires a number\\n\");\n                return 1;\n            }\n            Options.audio_pid = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--video-pid\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --video-pid requires a number\\n\");\n                return 1;\n            }\n            Options.video_pid = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--audio-track-id\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --audio-track-id requires a number\\n\");\n                return 1;\n            }\n            Options.audio_track_id = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--audio-format\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --audio-format requires an argument\\n\");\n                return 1;\n            }\n            const char* format = *args++;\n            if (!strcmp(format, \"ts\")) {\n                Options.audio_format = AUDIO_FORMAT_TS;\n            } else if (!strcmp(format, \"packed\")) {\n                Options.audio_format = AUDIO_FORMAT_PACKED;\n            } else {\n                fprintf(stderr, \"ERROR: unknown audio format\\n\");\n                return 1;\n            }\n        } else if (!strcmp(arg, \"--video-track-id\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --video-track-id requires a number\\n\");\n                return 1;\n            }\n            Options.video_track_id = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--pcr-offset\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --pcr-offset requires a number\\n\");\n                return 1;\n            }\n            Options.pcr_offset = (unsigned int)strtoul(*args++, NULL, 10);\n        } else if (!strcmp(arg, \"--output-single-file\")) {\n            Options.output_single_file = true;\n        } else if (!strcmp(arg, \"--index-filename\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --index-filename requires a filename\\n\");\n                return 1;\n            }\n            Options.index_filename = *args++;\n        } else if (!strcmp(arg, \"--iframe-index-filename\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --iframe-index-filename requires a filename\\n\");\n                return 1;\n            }\n            Options.iframe_index_filename = *args++;\n        } else if (!strcmp(arg, \"--show-info\")) {\n            Options.show_info = true;\n        } else if (!strcmp(arg, \"--encryption-key\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_hex = *args++;\n            result = AP4_ParseHex(Options.encryption_key_hex, Options.encryption_key, 16);\n            if (AP4_FAILED(result)) {\n                fprintf(stderr, \"ERROR: invalid hex key\\n\");\n                return 1;\n            }\n            if (Options.encryption_mode == ENCRYPTION_MODE_NONE) {\n                Options.encryption_mode = ENCRYPTION_MODE_AES_128;\n            }\n        } else if (!strcmp(arg, \"--encryption-mode\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-mode requires an argument\\n\");\n                return 1;\n            }\n            if (strncmp(*args, \"AES-128\", 7) == 0) {\n                Options.encryption_mode = ENCRYPTION_MODE_AES_128;\n            } else if (strncmp(*args, \"SAMPLE-AES\", 10) == 0) {\n                Options.encryption_mode = ENCRYPTION_MODE_SAMPLE_AES;\n            } else {\n                fprintf(stderr, \"ERROR: unknown encryption mode\\n\");\n                return 1;\n            }\n            ++args;\n        } else if (!strcmp(arg, \"--encryption-iv-mode\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-iv-mode requires an argument\\n\");\n                return 1;\n            }\n            if (strncmp(*args, \"sequence\", 8) == 0) {\n                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_SEQUENCE;\n            } else if (strncmp(*args, \"random\", 6) == 0) {\n                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_RANDOM;\n            } else if (strncmp(*args, \"fps\", 3) == 0) {\n                Options.encryption_iv_mode = ENCRYPTION_IV_MODE_FPS;\n            } else {\n                fprintf(stderr, \"ERROR: unknown encryption IV mode\\n\");\n                return 1;\n            }\n            ++args;\n        } else if (!strcmp(arg, \"--encryption-key-uri\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key-uri requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_uri = *args++;\n        } else if (!strcmp(arg, \"--encryption-key-format\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key-format requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_format = *args++;\n        } else if (!strcmp(arg, \"--encryption-key-format-versions\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key-format-versions requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_format_versions = *args++;\n        } else if (!strcmp(arg, \"--encryption-key-line\")) {\n            if (*args == NULL) {\n                fprintf(stderr, \"ERROR: --encryption-key-line requires an argument\\n\");\n                return 1;\n            }\n            Options.encryption_key_lines.Append(*args++);\n        } else if (Options.input == NULL) {\n            Options.input = arg;\n        } else {\n            fprintf(stderr, \"ERROR: unexpected argument: %s\\n\", arg);\n            return 1;\n        }\n    }\n\n    // check args\n    if (Options.input == NULL) {\n        fprintf(stderr, \"ERROR: missing input file name\\n\");\n        return 1;\n    }\n    if (Options.encryption_mode == ENCRYPTION_MODE_NONE && Options.encryption_key_lines.ItemCount() != 0) {\n        fprintf(stderr, \"ERROR: --encryption-key-line requires --encryption-key and --encryption-key-mode\\n\");\n        return 1;\n    }\n    if (Options.encryption_mode != ENCRYPTION_MODE_NONE && Options.encryption_key_hex == NULL) {\n        fprintf(stderr, \"ERROR: no encryption key specified\\n\");\n        return 1;\n    }\n    if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES && Options.hls_version > 0 && Options.hls_version < 5) {\n        Options.hls_version = 5;\n        fprintf(stderr, \"WARNING: forcing version to 5 in order to support SAMPLE-AES encryption\\n\");\n    }\n    if (Options.iframe_index_filename && Options.hls_version > 0 && Options.hls_version < 4) {\n        fprintf(stderr, \"WARNING: forcing version to 4 in order to support I-FRAME-ONLY playlists\\n\");\n        Options.hls_version = 4;\n    }\n    if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_NONE && Options.encryption_mode != ENCRYPTION_MODE_NONE) {\n        if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n            // sequence-mode IVs don't work well with i-frame only playlists, use random instead\n            Options.encryption_iv_mode = ENCRYPTION_IV_MODE_RANDOM;\n        } else {\n            Options.encryption_iv_mode = ENCRYPTION_IV_MODE_SEQUENCE;\n        }\n    }\n    if ((Options.encryption_key_format || Options.encryption_key_format_versions) && Options.hls_version > 0 && Options.hls_version < 5) {\n        Options.hls_version = 5;\n        fprintf(stderr, \"WARNING: forcing version to 5 in order to support KEYFORMAT and/or KEYFORMATVERSIONS\\n\");\n    }\n    if (Options.output_single_file && Options.hls_version > 0 && Options.hls_version < 4) {\n        Options.hls_version = 4;\n        fprintf(stderr, \"WARNING: forcing version to 4 in order to support single file output\\n\");\n    }\n    if (Options.hls_version == 0) {\n        // default version is 3 for cleartext or AES-128 encryption, and 5 for SAMPLE-AES\n        if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n            Options.hls_version = 5;\n        } else if (Options.output_single_file || Options.iframe_index_filename) {\n            Options.hls_version = 4;\n        } else {\n            Options.hls_version = 3;\n        }\n    }\n    \n    if (Options.verbose && Options.show_info) {\n        fprintf(stderr, \"WARNING: --verbose will be ignored because --show-info is selected\\n\");\n        Options.verbose = false;\n    }\n\n    // compute some derived values\n    if (Options.iframe_index_filename == NULL) {\n        if (Options.hls_version >= 4) {\n            Options.iframe_index_filename = \"iframes.m3u8\";\n        }\n    }\n    if (Options.audio_format == AUDIO_FORMAT_TS) {\n        if (Options.segment_filename_template == NULL) {\n            if (Options.output_single_file) {\n                Options.segment_filename_template = \"stream.ts\";\n            } else {\n                Options.segment_filename_template = \"segment-%d.ts\";\n            }\n        }\n        if (Options.segment_url_template == NULL) {\n            if (Options.output_single_file) {\n                Options.segment_url_template = \"stream.ts\";\n            } else {\n                Options.segment_url_template = \"segment-%d.ts\";\n            }\n        }\n    }\n    \n    if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_FPS) {\n        if (Options.encryption_key_hex == NULL || AP4_StringLength(Options.encryption_key_hex) != 64) {\n            fprintf(stderr, \"ERROR: 'fps' IV mode requires a 32 byte key value (64 characters in hex)\\n\");\n            return 1;\n        }\n        result = AP4_ParseHex(Options.encryption_key_hex+32, Options.encryption_iv, 16);\n        if (AP4_FAILED(result)) {\n            fprintf(stderr, \"ERROR: invalid hex IV\\n\");\n            return 1;\n        }\n    } else if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_RANDOM) {\n        result = AP4_System_GenerateRandomBytes(Options.encryption_iv, sizeof(Options.encryption_iv));\n        if (AP4_FAILED(result)) {\n            fprintf(stderr, \"ERROR: failed to get random IV (%d)\\n\", result);\n            return 1;\n        }\n    }\n    \n\t// create the input stream\n    AP4_ByteStream* input = NULL;\n    result = AP4_FileByteStream::Create(Options.input, AP4_FileByteStream::STREAM_MODE_READ, input);\n    if (AP4_FAILED(result)) {\n        fprintf(stderr, \"ERROR: cannot open input (%d)\\n\", result);\n        return 1;\n    }\n    \n\t// open the file\n    AP4_File* input_file = new AP4_File(*input, true);\n\n    // get the movie\n    AP4_SampleDescription* sample_description;\n    AP4_Movie* movie = input_file->GetMovie();\n    if (movie == NULL) {\n        fprintf(stderr, \"ERROR: no movie in file\\n\");\n        return 1;\n    }\n\n    // get the audio and video tracks\n    AP4_Track* audio_track = NULL;\n    if (Options.audio_track_id == -1) {\n        audio_track = movie->GetTrack(AP4_Track::TYPE_AUDIO);\n    } else if (Options.audio_track_id > 0) {\n        audio_track = movie->GetTrack((AP4_UI32)Options.audio_track_id);\n        if (audio_track == NULL) {\n            fprintf(stderr, \"ERROR: audio track ID %d not found\\n\", Options.audio_track_id);\n            return 1;\n        }\n        if (audio_track->GetType() != AP4_Track::TYPE_AUDIO) {\n            fprintf(stderr, \"ERROR: track ID %d is not an audio track\\n\", Options.audio_track_id);\n            return 1;\n        }\n    }\n    AP4_Track* video_track = NULL;\n    if (Options.video_track_id == -1) {\n        video_track = movie->GetTrack(AP4_Track::TYPE_VIDEO);\n    } else if (Options.video_track_id > 0) {\n        video_track = movie->GetTrack((AP4_UI32)Options.video_track_id);\n        if (video_track == NULL) {\n            fprintf(stderr, \"ERROR: video track ID %d not found\\n\", Options.video_track_id);\n            return 1;\n        }\n        if (video_track->GetType() != AP4_Track::TYPE_VIDEO) {\n            fprintf(stderr, \"ERROR: track ID %d is not a video track\\n\", Options.video_track_id);\n            return 1;\n        }\n    }\n    if (audio_track == NULL && video_track == NULL) {\n        fprintf(stderr, \"ERROR: no suitable tracks found\\n\");\n        delete input_file;\n        input->Release();\n        return 1;\n    }\n    if (Options.audio_format == AUDIO_FORMAT_PACKED && video_track != NULL) {\n        if (audio_track == NULL) {\n            fprintf(stderr, \"ERROR: packed audio format requires an audio track\\n\");\n            return 1;\n        }\n        fprintf(stderr, \"WARNING: ignoring video track because of the packed audio format\\n\");\n        video_track = NULL;\n    }\n    if (video_track == NULL) {\n        Options.segment_duration_threshold = 0;\n    }\n    \n    // create the appropriate readers\n    AP4_LinearReader* linear_reader = NULL;\n    SampleReader*     audio_reader  = NULL;\n    SampleReader*     video_reader  = NULL;\n    if (movie->HasFragments()) {\n        // create a linear reader to get the samples\n        linear_reader = new AP4_LinearReader(*movie, input);\n    \n        if (audio_track) {\n            linear_reader->EnableTrack(audio_track->GetId());\n            audio_reader = new FragmentedSampleReader(*linear_reader, audio_track->GetId());\n        }\n        if (video_track) {\n            linear_reader->EnableTrack(video_track->GetId());\n            video_reader = new FragmentedSampleReader(*linear_reader, video_track->GetId());\n        }\n    } else {\n        if (audio_track) {\n            audio_reader = new TrackSampleReader(*audio_track);\n        }\n        if (video_track) {\n            video_reader = new TrackSampleReader(*video_track);\n        }\n    }\n    \n    AP4_Mpeg2TsWriter*               ts_writer = NULL;\n    AP4_Mpeg2TsWriter::SampleStream* audio_stream = NULL;\n    AP4_Mpeg2TsWriter::SampleStream* video_stream = NULL;\n    AP4_UI08                         nalu_length_size = 0;\n    PackedAudioWriter*               packed_writer = NULL;\n    if (Options.audio_format == AUDIO_FORMAT_PACKED) {\n        packed_writer = new PackedAudioWriter();\n    \n        // figure out the file extensions if needed\n        sample_description = audio_track->GetSampleDescription(0);\n        if (sample_description == NULL) {\n            fprintf(stderr, \"ERROR: unable to parse audio sample description\\n\");\n            goto end;\n        }\n        if (Options.segment_filename_template == NULL || Options.segment_url_template == NULL) {\n            const char* default_stream_name    = \"stream.es\";\n            const char* default_stream_pattern = \"segment-%d.es\";\n            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {\n                AP4_MpegAudioSampleDescription* mpeg_audio_desc = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, sample_description);\n                if (mpeg_audio_desc == NULL ||\n                    !(mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG4_AUDIO          ||\n                      mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG2_AAC_AUDIO_LC   ||\n                      mpeg_audio_desc->GetObjectTypeId() == AP4_OTI_MPEG2_AAC_AUDIO_MAIN)) {\n                    fprintf(stderr, \"ERROR: only AAC audio is supported\\n\");\n                    return 1;\n                }\n                default_stream_name    = \"stream.aac\";\n                default_stream_pattern = \"segment-%d.aac\";\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3) {\n                default_stream_name    = \"stream.ac3\";\n                default_stream_pattern = \"segment-%d.ac3\";\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n                default_stream_name    = \"stream.ec3\";\n                default_stream_pattern = \"segment-%d.ec3\";\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_4) {\n                default_stream_name    = \"stream.ac4\";\n                default_stream_pattern = \"segment-%d.ac4\";\n            }\n\n            // override the segment names\n            if (Options.segment_filename_template == NULL) {\n                if (Options.output_single_file) {\n                    Options.segment_filename_template = default_stream_name;\n                } else {\n                    Options.segment_filename_template = default_stream_pattern;\n                }\n            }\n            if (Options.segment_url_template == NULL) {\n                if (Options.output_single_file) {\n                    Options.segment_url_template = default_stream_name;\n                } else {\n                    Options.segment_url_template = default_stream_pattern;\n                }\n            }\n        }\n    } else {\n        // create an MPEG2 TS Writer\n        ts_writer = new AP4_Mpeg2TsWriter(Options.pmt_pid);\n\n        // add the audio stream\n        if (audio_track) {\n            sample_description = audio_track->GetSampleDescription(0);\n            if (sample_description == NULL) {\n                fprintf(stderr, \"ERROR: unable to parse audio sample description\\n\");\n                goto end;\n            }\n\n            unsigned int stream_type = 0;\n            unsigned int stream_id   = 0;\n            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {\n                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ISO_IEC_13818_7;\n                } else {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_ISO_IEC_13818_7;\n                }\n                stream_id   = AP4_MPEG2_TS_DEFAULT_STREAM_ID_AUDIO;\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3) {\n                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ATSC_AC3;\n                } else {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_ATSC_AC3;\n                }\n                stream_id   = AP4_MPEG2_TS_STREAM_ID_PRIVATE_STREAM_1;\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_ATSC_EAC3;\n                } else {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_ATSC_EAC3;\n                }\n                stream_id   = AP4_MPEG2_TS_STREAM_ID_PRIVATE_STREAM_1;\n            } else {\n                fprintf(stderr, \"ERROR: audio codec not supported\\n\");\n                return 1;\n            }\n            if (stream_type == AP4_MPEG2_STREAM_TYPE_ATSC_EAC3) {\n                // E-AC-3 descriptor\n                unsigned int number_of_channels = 0;\n                AP4_String track_language;\n                AP4_Dec3Atom* dec3 = AP4_DYNAMIC_CAST(AP4_Dec3Atom, sample_description->GetDetails().GetChild(AP4_ATOM_TYPE_DEC3));\n                AP4_BitWriter bits(8);\n                bits.Write(0xCC, 8);\n                bits.Write(0x06, 8);    // fixed value\n                bits.Write(0xC0, 8);    // reserved, bsid_flag, mainid_flag, asvc_flag, mixinfoexists, substream1_flag, substream2_flag and substream3_flag \n                bits.Write(24, 5);      // reserved, full_service_flag and service_type\n                if (dec3->GetSubStreams()[0].acmod == 0) {\n                    number_of_channels = 1;\n                } else if (dec3->GetSubStreams()[0].acmod == 1) {\n                    number_of_channels = 0;\n                } else if (dec3->GetSubStreams()[0].acmod == 2) {\n                    number_of_channels = 2;\n                } else {\n                    number_of_channels = 4;\n                }\n                if (dec3->GetSubStreams()[0].num_dep_sub > 0) {\n                    number_of_channels = 5;\n                }\n                bits.Write(number_of_channels, 3);              // number_of_channels\n                bits.Write(4, 3);                               // language_flag, language_flag_2, reserved\n                bits.Write(dec3->GetSubStreams()[0].bsid, 5);   // bsid\n                track_language = audio_track->GetTrackLanguage();\n                if (track_language.GetLength() == 3) {\n                    bits.Write(track_language.GetChars()[0], 8);\n                    bits.Write(track_language.GetChars()[1], 8);\n                    bits.Write(track_language.GetChars()[2], 8);\n                } else {\n                    bits.Write(0x75, 8);\n                    bits.Write(0x6E, 8);\n                    bits.Write(0x64, 8);\n                }\n                 // setup the audio stream\n                result = ts_writer->SetAudioStream(audio_track->GetMediaTimeScale(),\n                                                   stream_type,\n                                                   stream_id,\n                                                   audio_stream,\n                                                   Options.audio_pid,\n                                                   bits.GetData(), 8,\n                                                   Options.pcr_offset);\n            } else {\n            // setup the audio stream\n            result = ts_writer->SetAudioStream(audio_track->GetMediaTimeScale(),\n                                               stream_type,\n                                               stream_id,\n                                               audio_stream,\n                                               Options.audio_pid,\n                                               NULL, 0,\n                                               Options.pcr_offset);\n            }\n            if (AP4_FAILED(result)) {\n                fprintf(stderr, \"could not create audio stream (%d)\\n\", result);\n                goto end;\n            }\n        }\n        \n        // add the video stream\n        if (video_track) {\n            sample_description = video_track->GetSampleDescription(0);\n            if (sample_description == NULL) {\n                fprintf(stderr, \"ERROR: unable to parse video sample description\\n\");\n                goto end;\n            }\n            \n            // decide on the stream type\n            unsigned int stream_type = 0;\n            unsigned int stream_id   = AP4_MPEG2_TS_DEFAULT_STREAM_ID_VIDEO;\n            if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC1 ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC2 ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC3 ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AVC4 ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVAV ||\n                sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVA1) {\n                if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_AVC;\n                    AP4_AvcSampleDescription* avc_desc = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, sample_description);\n                    if (avc_desc == NULL) {\n                        fprintf(stderr, \"ERROR: not a proper AVC track\\n\");\n                        return 1;\n                    }\n                    nalu_length_size = avc_desc->GetNaluLengthSize();\n                } else {\n                    stream_type = AP4_MPEG2_STREAM_TYPE_AVC;\n                }\n            } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_HEV1 ||\n                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_HVC1 ||\n                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVHE ||\n                       sample_description->GetFormat() == AP4_SAMPLE_FORMAT_DVH1) {\n                stream_type = AP4_MPEG2_STREAM_TYPE_HEVC;\n            } else {\n                fprintf(stderr, \"ERROR: video codec not supported\\n\");\n                return 1;\n            }\n            if (Options.encryption_mode == ENCRYPTION_MODE_SAMPLE_AES) {\n                if (stream_type != AP4_MPEG2_STREAM_TYPE_SAMPLE_AES_AVC) {\n                    fprintf(stderr, \"ERROR: AES-SAMPLE encryption can only be used with H.264 video\\n\");\n                    return 1;\n                }\n            }\n            \n            // setup the video stream\n            result = ts_writer->SetVideoStream(video_track->GetMediaTimeScale(),\n                                               stream_type,\n                                               stream_id,\n                                               video_stream,\n                                               Options.video_pid,\n                                               NULL, 0,\n                                               Options.pcr_offset);\n            if (AP4_FAILED(result)) {\n                fprintf(stderr, \"could not create video stream (%d)\\n\", result);\n                goto end;\n            }\n        }\n    }\n    \n    result = WriteSamples(ts_writer, packed_writer,\n                          audio_track, audio_reader, audio_stream,\n                          video_track, video_reader, video_stream,\n                          Options.segment_duration_threshold,\n                          nalu_length_size);\n    if (AP4_FAILED(result)) {\n        fprintf(stderr, \"ERROR: failed to write samples (%d)\\n\", result);\n    }\n\n    if (Options.show_info) {\n        double average_segment_bitrate = 0.0;\n        if (Stats.segments_total_duration != 0.0) {\n            average_segment_bitrate = 8.0*(double)Stats.segments_total_size/Stats.segments_total_duration;\n        }\n        double average_iframe_bitrate = 0.0;\n        if (Stats.segments_total_duration != 0.0) {\n            average_iframe_bitrate = 8.0*(double)Stats.iframes_total_size/Stats.segments_total_duration;\n        }\n\n        double frame_rate = 0.0;\n        if (video_track && (Stats.segments_total_duration != 0.0)) {\n            double sample_count = (double)video_track->GetSampleCount();\n            double media_duration = (double)video_track->GetMediaDuration();\n            double timescale = (double)video_track->GetMediaTimeScale();\n            if (media_duration > 0.0) {\n                frame_rate = sample_count/(media_duration/timescale);\n            }\n        }\n\n        printf(\n            \"{\\n\"\n        );\n        printf(\n            \"  \\\"stats\\\": {\\n\"\n            \"    \\\"duration\\\": %f,\\n\"\n            \"    \\\"avg_segment_bitrate\\\": %f,\\n\"\n            \"    \\\"max_segment_bitrate\\\": %f,\\n\"\n            \"    \\\"avg_iframe_bitrate\\\": %f,\\n\"\n            \"    \\\"max_iframe_bitrate\\\": %f,\\n\"\n            \"    \\\"frame_rate\\\": %f\\n\"\n            \"  }\",\n            (double)movie->GetDurationMs()/1000.0,\n            average_segment_bitrate,\n            Stats.max_segment_bitrate,\n            average_iframe_bitrate,\n            Stats.max_iframe_bitrate,\n            frame_rate\n        );\n        if (audio_track) {\n            AP4_String codec;\n            AP4_SampleDescription* sdesc = audio_track->GetSampleDescription(0);\n            if (sdesc) {\n                sdesc->GetCodecString(codec);\n            }\n            printf(\n                \",\\n\"\n                \"  \\\"audio\\\": {\\n\"\n                \"    \\\"codec\\\": \\\"%s\\\"\\n\"\n                \"  }\",\n                codec.GetChars()\n            );\n        }\n        if (video_track) {\n            AP4_String codec;\n            AP4_UI16 width = (AP4_UI16)(video_track->GetWidth()/65536.0);\n            AP4_UI16 height = (AP4_UI16)(video_track->GetHeight()/65536.0);\n            AP4_SampleDescription* sdesc = video_track->GetSampleDescription(0);\n            if (sdesc) {\n                sdesc->GetCodecString(codec);\n                AP4_VideoSampleDescription* video_desc = AP4_DYNAMIC_CAST(AP4_VideoSampleDescription, sdesc);\n                if (video_desc) {\n                    width = video_desc->GetWidth();\n                    height = video_desc->GetHeight();\n                }\n            }\n            printf(\n                \",\\n\"\n                \"  \\\"video\\\": {\\n\"\n                \"    \\\"codec\\\": \\\"%s\\\",\\n\"\n                \"    \\\"width\\\": %d,\\n\"\n                \"    \\\"height\\\": %d\\n\"\n                \"  }\",\n                codec.GetChars(),\n                width,\n                height\n            );\n        }\n        printf(\n            \"\\n\"\n            \"}\\n\"\n        );\n    }\n    \nend:\n    delete ts_writer;\n    delete packed_writer;\n    delete input_file;\n    input->Release();\n    delete linear_reader;\n    delete audio_reader;\n    delete video_reader;\n    \n    return result == AP4_SUCCESS?0:1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -300,7 +300,7 @@\n     }\n     \n     if (Options.encryption_iv_mode == ENCRYPTION_IV_MODE_FPS) {\n-        if (AP4_StringLength(Options.encryption_key_hex) != 64) {\n+        if (Options.encryption_key_hex == NULL || AP4_StringLength(Options.encryption_key_hex) != 64) {\n             fprintf(stderr, \"ERROR: 'fps' IV mode requires a 32 byte key value (64 characters in hex)\\n\");\n             return 1;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (AP4_StringLength(Options.encryption_key_hex) != 64) {"
            ],
            "added_lines": [
                "        if (Options.encryption_key_hex == NULL || AP4_StringLength(Options.encryption_key_hex) != 64) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19924",
        "func_name": "sqlite/vdbeVComment",
        "description": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
        "git_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
        "commit_title": "When an error occurs while rewriting the parser tree for window functions",
        "commit_text": "in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.  FossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
        "func_before": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}",
        "func": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed\n          || p->pParse->nErr>0 );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n   assert( p->nOp>0 || p->aOp==0 );\n-  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n+  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed\n+          || p->pParse->nErr>0 );\n   if( p->nOp ){\n     assert( p->aOp );\n     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);",
        "diff_line_info": {
            "deleted_lines": [
                "  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );"
            ],
            "added_lines": [
                "  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed",
                "          || p->pParse->nErr>0 );"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19924",
        "func_name": "sqlite/sqlite3WindowRewrite",
        "description": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
        "git_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
        "commit_title": "When an error occurs while rewriting the parser tree for window functions",
        "commit_text": "in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.  FossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
        "func_before": "int sqlite3WindowRewrite(Parse *pParse, Select *p){\n  int rc = SQLITE_OK;\n  if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    sqlite3 *db = pParse->db;\n    Select *pSub = 0;             /* The subquery */\n    SrcList *pSrc = p->pSrc;\n    Expr *pWhere = p->pWhere;\n    ExprList *pGroupBy = p->pGroupBy;\n    Expr *pHaving = p->pHaving;\n    ExprList *pSort = 0;\n\n    ExprList *pSublist = 0;       /* Expression list for sub-query */\n    Window *pMWin = p->pWin;      /* Master window object */\n    Window *pWin;                 /* Window object iterator */\n    Table *pTab;\n\n    pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ){\n      return SQLITE_NOMEM;\n    }\n\n    p->pSrc = 0;\n    p->pWhere = 0;\n    p->pGroupBy = 0;\n    p->pHaving = 0;\n    p->selFlags &= ~SF_Aggregate;\n    p->selFlags |= SF_WinRewrite;\n\n    /* Create the ORDER BY clause for the sub-select. This is the concatenation\n    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it\n    ** redundant, remove the ORDER BY from the parent SELECT.  */\n    pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);\n    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);\n    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){\n      int nSave = pSort->nExpr;\n      pSort->nExpr = p->pOrderBy->nExpr;\n      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        p->pOrderBy = 0;\n      }\n      pSort->nExpr = nSave;\n    }\n\n    /* Assign a cursor number for the ephemeral table used to buffer rows.\n    ** The OpenEphemeral instruction is coded later, after it is known how\n    ** many columns the table will have.  */\n    pMWin->iEphCsr = pParse->nTab++;\n    pParse->nTab += 3;\n\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);\n    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);\n\n    /* Append the PARTITION BY and ORDER BY expressions to the to the \n    ** sub-select expression list. They are required to figure out where \n    ** boundaries for partitions and sets of peer rows lie.  */\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);\n\n    /* Append the arguments passed to each window function to the\n    ** sub-select expression list. Also allocate two registers for each\n    ** window function - one for the accumulator, another for interim\n    ** results.  */\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      ExprList *pArgs = pWin->pOwner->x.pList;\n      if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){\n        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pWin->bExprArgs = 1;\n      }else{\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);\n      }\n      if( pWin->pFilter ){\n        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);\n        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);\n      }\n      pWin->regAccum = ++pParse->nMem;\n      pWin->regResult = ++pParse->nMem;\n      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n    }\n\n    /* If there is no ORDER BY or PARTITION BY clause, and the window\n    ** function accepts zero arguments, and there are no other columns\n    ** selected (e.g. \"SELECT row_number() OVER () FROM t1\"), it is possible\n    ** that pSublist is still NULL here. Add a constant expression here to \n    ** keep everything legal in this case. \n    */\n    if( pSublist==0 ){\n      pSublist = sqlite3ExprListAppend(pParse, 0, \n        sqlite3Expr(db, TK_INTEGER, \"0\")\n      );\n    }\n\n    pSub = sqlite3SelectNew(\n        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0\n    );\n    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n    if( p->pSrc ){\n      Table *pTab2;\n      p->pSrc->a[0].pSelect = pSub;\n      sqlite3SrcListAssignCursors(pParse, p->pSrc);\n      pSub->selFlags |= SF_Expanded;\n      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);\n      if( pTab2==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        memcpy(pTab, pTab2, sizeof(Table));\n        pTab->tabFlags |= TF_Ephemeral;\n        p->pSrc->a[0].pTab = pTab;\n        pTab = pTab2;\n      }\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);\n    }else{\n      sqlite3SelectDelete(db, pSub);\n    }\n    if( db->mallocFailed ) rc = SQLITE_NOMEM;\n    sqlite3DbFree(db, pTab);\n  }\n\n  return rc;\n}",
        "func": "int sqlite3WindowRewrite(Parse *pParse, Select *p){\n  int rc = SQLITE_OK;\n  if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    sqlite3 *db = pParse->db;\n    Select *pSub = 0;             /* The subquery */\n    SrcList *pSrc = p->pSrc;\n    Expr *pWhere = p->pWhere;\n    ExprList *pGroupBy = p->pGroupBy;\n    Expr *pHaving = p->pHaving;\n    ExprList *pSort = 0;\n\n    ExprList *pSublist = 0;       /* Expression list for sub-query */\n    Window *pMWin = p->pWin;      /* Master window object */\n    Window *pWin;                 /* Window object iterator */\n    Table *pTab;\n\n    pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ){\n      return sqlite3ErrorToParser(db, SQLITE_NOMEM);\n    }\n\n    p->pSrc = 0;\n    p->pWhere = 0;\n    p->pGroupBy = 0;\n    p->pHaving = 0;\n    p->selFlags &= ~SF_Aggregate;\n    p->selFlags |= SF_WinRewrite;\n\n    /* Create the ORDER BY clause for the sub-select. This is the concatenation\n    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it\n    ** redundant, remove the ORDER BY from the parent SELECT.  */\n    pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);\n    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);\n    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){\n      int nSave = pSort->nExpr;\n      pSort->nExpr = p->pOrderBy->nExpr;\n      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        p->pOrderBy = 0;\n      }\n      pSort->nExpr = nSave;\n    }\n\n    /* Assign a cursor number for the ephemeral table used to buffer rows.\n    ** The OpenEphemeral instruction is coded later, after it is known how\n    ** many columns the table will have.  */\n    pMWin->iEphCsr = pParse->nTab++;\n    pParse->nTab += 3;\n\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);\n    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);\n    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);\n\n    /* Append the PARTITION BY and ORDER BY expressions to the to the \n    ** sub-select expression list. They are required to figure out where \n    ** boundaries for partitions and sets of peer rows lie.  */\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);\n    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);\n\n    /* Append the arguments passed to each window function to the\n    ** sub-select expression list. Also allocate two registers for each\n    ** window function - one for the accumulator, another for interim\n    ** results.  */\n    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n      ExprList *pArgs = pWin->pOwner->x.pList;\n      if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){\n        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pWin->bExprArgs = 1;\n      }else{\n        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);\n      }\n      if( pWin->pFilter ){\n        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);\n        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);\n      }\n      pWin->regAccum = ++pParse->nMem;\n      pWin->regResult = ++pParse->nMem;\n      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n    }\n\n    /* If there is no ORDER BY or PARTITION BY clause, and the window\n    ** function accepts zero arguments, and there are no other columns\n    ** selected (e.g. \"SELECT row_number() OVER () FROM t1\"), it is possible\n    ** that pSublist is still NULL here. Add a constant expression here to \n    ** keep everything legal in this case. \n    */\n    if( pSublist==0 ){\n      pSublist = sqlite3ExprListAppend(pParse, 0, \n        sqlite3Expr(db, TK_INTEGER, \"0\")\n      );\n    }\n\n    pSub = sqlite3SelectNew(\n        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0\n    );\n    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n    if( p->pSrc ){\n      Table *pTab2;\n      p->pSrc->a[0].pSelect = pSub;\n      sqlite3SrcListAssignCursors(pParse, p->pSrc);\n      pSub->selFlags |= SF_Expanded;\n      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);\n      if( pTab2==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        memcpy(pTab, pTab2, sizeof(Table));\n        pTab->tabFlags |= TF_Ephemeral;\n        p->pSrc->a[0].pTab = pTab;\n        pTab = pTab2;\n      }\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);\n      sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);\n    }else{\n      sqlite3SelectDelete(db, pSub);\n    }\n    if( db->mallocFailed ) rc = SQLITE_NOMEM;\n    sqlite3DbFree(db, pTab);\n  }\n\n  if( rc && pParse->nErr==0 ){\n    assert( pParse->db->mallocFailed );\n    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);\n  }\n  return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \n     pTab = sqlite3DbMallocZero(db, sizeof(Table));\n     if( pTab==0 ){\n-      return SQLITE_NOMEM;\n+      return sqlite3ErrorToParser(db, SQLITE_NOMEM);\n     }\n \n     p->pSrc = 0;\n@@ -122,5 +122,9 @@\n     sqlite3DbFree(db, pTab);\n   }\n \n+  if( rc && pParse->nErr==0 ){\n+    assert( pParse->db->mallocFailed );\n+    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);\n+  }\n   return rc;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      return SQLITE_NOMEM;"
            ],
            "added_lines": [
                "      return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
                "  if( rc && pParse->nErr==0 ){",
                "    assert( pParse->db->mallocFailed );",
                "    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19924",
        "func_name": "sqlite/codeCompare",
        "description": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
        "git_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
        "commit_title": "When an error occurs while rewriting the parser tree for window functions",
        "commit_text": "in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.  FossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
        "func_before": "static int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}",
        "func": "static int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( pParse->nErr ) return 0;\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n   int addr;\n   CollSeq *p4;\n \n+  if( pParse->nErr ) return 0;\n   if( isCommuted ){\n     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n   }else{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if( pParse->nErr ) return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20218",
        "func_name": "sqlite/selectExpander",
        "description": "selectExpander in select.c in SQLite 3.30.1 proceeds with WITH stack unwinding even after a parsing error.",
        "git_url": "https://github.com/sqlite/sqlite/commit/a6c1a71cde082e09750465d5675699062922e387",
        "commit_title": "Do not attempt to unwind the WITH stack in the Parse object following an error. This fixes a separate case to [de6e6d68].",
        "commit_text": " FossilOrigin-Name: d29edef93451cc67a5d69c1cce1b1832d9ca8fff1f600afdd51338b74d077b92",
        "func_before": "static int selectExpander(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i, j, k;\n  SrcList *pTabList;\n  ExprList *pEList;\n  struct SrcList_item *pFrom;\n  sqlite3 *db = pParse->db;\n  Expr *pE, *pRight, *pExpr;\n  u16 selFlags = p->selFlags;\n  u32 elistFlags = 0;\n\n  p->selFlags |= SF_Expanded;\n  if( db->mallocFailed  ){\n    return WRC_Abort;\n  }\n  assert( p->pSrc!=0 );\n  if( (selFlags & SF_Expanded)!=0 ){\n    return WRC_Prune;\n  }\n  if( pWalker->eCode ){\n    /* Renumber selId because it has been copied from a view */\n    p->selId = ++pParse->nSelect;\n  }\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n  sqlite3WithPush(pParse, p->pWith, 0);\n\n  /* Make sure cursor numbers have been assigned to all entries in\n  ** the FROM clause of the SELECT statement.\n  */\n  sqlite3SrcListAssignCursors(pParse, pTabList);\n\n  /* Look up every table named in the FROM clause of the select.  If\n  ** an entry of the FROM clause is a subquery instead of a table or view,\n  ** then create a transient table structure to describe the subquery.\n  */\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab;\n    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n    if( pFrom->fg.isRecursive ) continue;\n    assert( pFrom->pTab==0 );\n#ifndef SQLITE_OMIT_CTE\n    if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n    if( pFrom->pTab ) {} else\n#endif\n    if( pFrom->zName==0 ){\n#ifndef SQLITE_OMIT_SUBQUERY\n      Select *pSel = pFrom->pSelect;\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pSel!=0 );\n      assert( pFrom->pTab==0 );\n      if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n      if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n#endif\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      assert( pFrom->pTab==0 );\n      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n      if( pTab==0 ) return WRC_Abort;\n      if( pTab->nTabRef>=0xffff ){\n        sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",\n           pTab->zName);\n        pFrom->pTab = 0;\n        return WRC_Abort;\n      }\n      pTab->nTabRef++;\n      if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n        return WRC_Abort;\n      }\n#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n      if( IsVirtual(pTab) || pTab->pSelect ){\n        i16 nCol;\n        u8 eCodeOrig = pWalker->eCode;\n        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n        assert( pFrom->pSelect==0 );\n        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n          sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n              pTab->zName);\n        }\n        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n        nCol = pTab->nCol;\n        pTab->nCol = -1;\n        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */\n        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n        pWalker->eCode = eCodeOrig;\n        pTab->nCol = nCol;\n      }\n#endif\n    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ASTERISK ) break;\n    assert( pE->op!=TK_DOT || pE->pRight!=0 );\n    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n    if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n    elistFlags |= pE->flags;\n  }\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    int flags = pParse->db->flags;\n    int longNames = (flags & SQLITE_FullColNames)!=0\n                      && (flags & SQLITE_ShortColNames)==0;\n\n    for(k=0; k<pEList->nExpr; k++){\n      pE = a[k].pExpr;\n      elistFlags |= pE->flags;\n      pRight = pE->pRight;\n      assert( pE->op!=TK_DOT || pRight!=0 );\n      if( pE->op!=TK_ASTERISK\n       && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n      ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n        if( pNew ){\n          pNew->a[pNew->nExpr-1].zName = a[k].zName;\n          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n          a[k].zName = 0;\n          a[k].zSpan = 0;\n        }\n        a[k].pExpr = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        char *zTName = 0;       /* text of name of TABLE */\n        if( pE->op==TK_DOT ){\n          assert( pE->pLeft!=0 );\n          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n          zTName = pE->pLeft->u.zToken;\n        }\n        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n          Table *pTab = pFrom->pTab;\n          Select *pSub = pFrom->pSelect;\n          char *zTabName = pFrom->zAlias;\n          const char *zSchemaName = 0;\n          int iDb;\n          if( zTabName==0 ){\n            zTabName = pTab->zName;\n          }\n          if( db->mallocFailed ) break;\n          if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){\n            pSub = 0;\n            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n              continue;\n            }\n            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";\n          }\n          for(j=0; j<pTab->nCol; j++){\n            char *zName = pTab->aCol[j].zName;\n            char *zColname;  /* The computed column name */\n            char *zToFree;   /* Malloced string that needs to be freed */\n            Token sColname;  /* Computed column name as a token */\n\n            assert( zName );\n            if( zTName && pSub\n             && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0\n            ){\n              continue;\n            }\n\n            /* If a column is marked as 'hidden', omit it from the expanded\n            ** result-set list unless the SELECT has the SF_IncludeHidden\n            ** bit set.\n            */\n            if( (p->selFlags & SF_IncludeHidden)==0\n             && IsHiddenColumn(&pTab->aCol[j]) \n            ){\n              continue;\n            }\n            tableSeen = 1;\n\n            if( i>0 && zTName==0 ){\n              if( (pFrom->fg.jointype & JT_NATURAL)!=0\n                && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n              ){\n                /* In a NATURAL join, omit the join columns from the \n                ** table to the right of the join */\n                continue;\n              }\n              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                /* In a join with a USING clause, omit columns in the\n                ** using clause from the table on the right. */\n                continue;\n              }\n            }\n            pRight = sqlite3Expr(db, TK_ID, zName);\n            zColname = zName;\n            zToFree = 0;\n            if( longNames || pTabList->nSrc>1 ){\n              Expr *pLeft;\n              pLeft = sqlite3Expr(db, TK_ID, zTabName);\n              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n              if( zSchemaName ){\n                pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n                pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n              }\n              if( longNames ){\n                zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                zToFree = zColname;\n              }\n            }else{\n              pExpr = pRight;\n            }\n            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n            sqlite3TokenInit(&sColname, zColname);\n            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n            if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){\n              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n              if( pSub ){\n                pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);\n                testcase( pX->zSpan==0 );\n              }else{\n                pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",\n                                           zSchemaName, zTabName, zColname);\n                testcase( pX->zSpan==0 );\n              }\n              pX->bSpanIsTab = 1;\n            }\n            sqlite3DbFree(db, zToFree);\n          }\n        }\n        if( !tableSeen ){\n          if( zTName ){\n            sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n          }else{\n            sqlite3ErrorMsg(pParse, \"no tables specified\");\n          }\n        }\n      }\n    }\n    sqlite3ExprListDelete(db, pEList);\n    p->pEList = pNew;\n  }\n  if( p->pEList ){\n    if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n      sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n      return WRC_Abort;\n    }\n    if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n      p->selFlags |= SF_ComplexResult;\n    }\n  }\n  return WRC_Continue;\n}",
        "func": "static int selectExpander(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i, j, k;\n  SrcList *pTabList;\n  ExprList *pEList;\n  struct SrcList_item *pFrom;\n  sqlite3 *db = pParse->db;\n  Expr *pE, *pRight, *pExpr;\n  u16 selFlags = p->selFlags;\n  u32 elistFlags = 0;\n\n  p->selFlags |= SF_Expanded;\n  if( db->mallocFailed  ){\n    return WRC_Abort;\n  }\n  assert( p->pSrc!=0 );\n  if( (selFlags & SF_Expanded)!=0 ){\n    return WRC_Prune;\n  }\n  if( pWalker->eCode ){\n    /* Renumber selId because it has been copied from a view */\n    p->selId = ++pParse->nSelect;\n  }\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n  sqlite3WithPush(pParse, p->pWith, 0);\n\n  /* Make sure cursor numbers have been assigned to all entries in\n  ** the FROM clause of the SELECT statement.\n  */\n  sqlite3SrcListAssignCursors(pParse, pTabList);\n\n  /* Look up every table named in the FROM clause of the select.  If\n  ** an entry of the FROM clause is a subquery instead of a table or view,\n  ** then create a transient table structure to describe the subquery.\n  */\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab;\n    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n    if( pFrom->fg.isRecursive ) continue;\n    assert( pFrom->pTab==0 );\n#ifndef SQLITE_OMIT_CTE\n    if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n    if( pFrom->pTab ) {} else\n#endif\n    if( pFrom->zName==0 ){\n#ifndef SQLITE_OMIT_SUBQUERY\n      Select *pSel = pFrom->pSelect;\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pSel!=0 );\n      assert( pFrom->pTab==0 );\n      if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n      if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n#endif\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      assert( pFrom->pTab==0 );\n      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n      if( pTab==0 ) return WRC_Abort;\n      if( pTab->nTabRef>=0xffff ){\n        sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",\n           pTab->zName);\n        pFrom->pTab = 0;\n        return WRC_Abort;\n      }\n      pTab->nTabRef++;\n      if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n        return WRC_Abort;\n      }\n#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n      if( IsVirtual(pTab) || pTab->pSelect ){\n        i16 nCol;\n        u8 eCodeOrig = pWalker->eCode;\n        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n        assert( pFrom->pSelect==0 );\n        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n          sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n              pTab->zName);\n        }\n        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n        nCol = pTab->nCol;\n        pTab->nCol = -1;\n        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */\n        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n        pWalker->eCode = eCodeOrig;\n        pTab->nCol = nCol;\n      }\n#endif\n    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ASTERISK ) break;\n    assert( pE->op!=TK_DOT || pE->pRight!=0 );\n    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n    if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n    elistFlags |= pE->flags;\n  }\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    int flags = pParse->db->flags;\n    int longNames = (flags & SQLITE_FullColNames)!=0\n                      && (flags & SQLITE_ShortColNames)==0;\n\n    for(k=0; k<pEList->nExpr; k++){\n      pE = a[k].pExpr;\n      elistFlags |= pE->flags;\n      pRight = pE->pRight;\n      assert( pE->op!=TK_DOT || pRight!=0 );\n      if( pE->op!=TK_ASTERISK\n       && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n      ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n        if( pNew ){\n          pNew->a[pNew->nExpr-1].zName = a[k].zName;\n          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n          a[k].zName = 0;\n          a[k].zSpan = 0;\n        }\n        a[k].pExpr = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        char *zTName = 0;       /* text of name of TABLE */\n        if( pE->op==TK_DOT ){\n          assert( pE->pLeft!=0 );\n          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n          zTName = pE->pLeft->u.zToken;\n        }\n        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n          Table *pTab = pFrom->pTab;\n          Select *pSub = pFrom->pSelect;\n          char *zTabName = pFrom->zAlias;\n          const char *zSchemaName = 0;\n          int iDb;\n          if( zTabName==0 ){\n            zTabName = pTab->zName;\n          }\n          if( db->mallocFailed ) break;\n          if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){\n            pSub = 0;\n            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n              continue;\n            }\n            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";\n          }\n          for(j=0; j<pTab->nCol; j++){\n            char *zName = pTab->aCol[j].zName;\n            char *zColname;  /* The computed column name */\n            char *zToFree;   /* Malloced string that needs to be freed */\n            Token sColname;  /* Computed column name as a token */\n\n            assert( zName );\n            if( zTName && pSub\n             && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0\n            ){\n              continue;\n            }\n\n            /* If a column is marked as 'hidden', omit it from the expanded\n            ** result-set list unless the SELECT has the SF_IncludeHidden\n            ** bit set.\n            */\n            if( (p->selFlags & SF_IncludeHidden)==0\n             && IsHiddenColumn(&pTab->aCol[j]) \n            ){\n              continue;\n            }\n            tableSeen = 1;\n\n            if( i>0 && zTName==0 ){\n              if( (pFrom->fg.jointype & JT_NATURAL)!=0\n                && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n              ){\n                /* In a NATURAL join, omit the join columns from the \n                ** table to the right of the join */\n                continue;\n              }\n              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                /* In a join with a USING clause, omit columns in the\n                ** using clause from the table on the right. */\n                continue;\n              }\n            }\n            pRight = sqlite3Expr(db, TK_ID, zName);\n            zColname = zName;\n            zToFree = 0;\n            if( longNames || pTabList->nSrc>1 ){\n              Expr *pLeft;\n              pLeft = sqlite3Expr(db, TK_ID, zTabName);\n              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n              if( zSchemaName ){\n                pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n                pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n              }\n              if( longNames ){\n                zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                zToFree = zColname;\n              }\n            }else{\n              pExpr = pRight;\n            }\n            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n            sqlite3TokenInit(&sColname, zColname);\n            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n            if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){\n              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n              if( pSub ){\n                pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);\n                testcase( pX->zSpan==0 );\n              }else{\n                pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",\n                                           zSchemaName, zTabName, zColname);\n                testcase( pX->zSpan==0 );\n              }\n              pX->bSpanIsTab = 1;\n            }\n            sqlite3DbFree(db, zToFree);\n          }\n        }\n        if( !tableSeen ){\n          if( zTName ){\n            sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n          }else{\n            sqlite3ErrorMsg(pParse, \"no tables specified\");\n          }\n        }\n      }\n    }\n    sqlite3ExprListDelete(db, pEList);\n    p->pEList = pNew;\n  }\n  if( p->pEList ){\n    if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n      sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n      return WRC_Abort;\n    }\n    if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n      p->selFlags |= SF_ComplexResult;\n    }\n  }\n  return WRC_Continue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,7 +96,7 @@\n \n   /* Process NATURAL keywords, and ON and USING clauses of joins.\n   */\n-  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n+  if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n     return WRC_Abort;\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){"
            ],
            "added_lines": [
                "  if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-44488",
        "func_name": "webmproject/libvpx/vp9_change_config",
        "description": "VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",
        "git_url": "https://github.com/webmproject/libvpx/commit/263682c9a29395055f3b3afe2d97be1828a6223f",
        "commit_title": "Fix bug with smaller width bigger size",
        "commit_text": " Fixed previous patch that clusterfuzz failed on.  Bug: webm:1642",
        "func_before": "void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int last_w = cpi->oxcf.width;\n  int last_h = cpi->oxcf.height;\n\n  vp9_init_quantizer(cpi);\n  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  if (cm->profile <= PROFILE_1)\n    assert(cm->bit_depth == VPX_BITS_8);\n  else\n    assert(cm->bit_depth > VPX_BITS_8);\n\n  cpi->oxcf = *oxcf;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {\n    rc->baseline_gf_interval = FIXED_GF_INTERVAL;\n  } else {\n    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;\n  }\n\n  cpi->refresh_golden_frame = 0;\n  cpi->refresh_last_frame = 1;\n  cm->refresh_frame_context = 1;\n  cm->reset_frame_context = 0;\n\n  vp9_reset_segment_features(&cm->seg);\n  vp9_set_high_precision_mv(cpi, 0);\n\n  {\n    int i;\n\n    for (i = 0; i < MAX_SEGMENTS; i++)\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n  }\n  cpi->encode_breakout = cpi->oxcf.encode_breakout;\n\n  vp9_set_rc_buffer_sizes(cpi);\n\n  // Set up frame rate and related parameters rate control values.\n  vp9_new_framerate(cpi, cpi->framerate);\n\n  // Set absolute upper and lower quality limits\n  rc->worst_quality = cpi->oxcf.worst_allowed_q;\n  rc->best_quality = cpi->oxcf.best_allowed_q;\n\n  cm->interp_filter = cpi->sf.default_interp_filter;\n\n  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {\n    cm->render_width = cpi->oxcf.render_width;\n    cm->render_height = cpi->oxcf.render_height;\n  } else {\n    cm->render_width = cpi->oxcf.width;\n    cm->render_height = cpi->oxcf.height;\n  }\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    memset(cpi->consec_zero_mv, 0,\n           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_update_layer_context_change_config(cpi,\n                                           (int)cpi->oxcf.target_bandwidth);\n  }\n\n  vp9_check_reset_rc_flag(cpi);\n\n  cpi->alt_ref_source = NULL;\n  rc->is_src_frame_alt_ref = 0;\n\n#if 0\n  // Experimental RD Code\n  cpi->frame_distortion = 0;\n  cpi->last_frame_distortion = 0;\n#endif\n\n  set_tile_limits(cpi);\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n  cpi->ext_refresh_frame_context_pending = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  vp9_set_row_mt(cpi);\n}",
        "func": "void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int last_w = cpi->oxcf.width;\n  int last_h = cpi->oxcf.height;\n\n  vp9_init_quantizer(cpi);\n  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  if (cm->profile <= PROFILE_1)\n    assert(cm->bit_depth == VPX_BITS_8);\n  else\n    assert(cm->bit_depth > VPX_BITS_8);\n\n  cpi->oxcf = *oxcf;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {\n    rc->baseline_gf_interval = FIXED_GF_INTERVAL;\n  } else {\n    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;\n  }\n\n  cpi->refresh_golden_frame = 0;\n  cpi->refresh_last_frame = 1;\n  cm->refresh_frame_context = 1;\n  cm->reset_frame_context = 0;\n\n  vp9_reset_segment_features(&cm->seg);\n  vp9_set_high_precision_mv(cpi, 0);\n\n  {\n    int i;\n\n    for (i = 0; i < MAX_SEGMENTS; i++)\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n  }\n  cpi->encode_breakout = cpi->oxcf.encode_breakout;\n\n  vp9_set_rc_buffer_sizes(cpi);\n\n  // Set up frame rate and related parameters rate control values.\n  vp9_new_framerate(cpi, cpi->framerate);\n\n  // Set absolute upper and lower quality limits\n  rc->worst_quality = cpi->oxcf.worst_allowed_q;\n  rc->best_quality = cpi->oxcf.best_allowed_q;\n\n  cm->interp_filter = cpi->sf.default_interp_filter;\n\n  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {\n    cm->render_width = cpi->oxcf.render_width;\n    cm->render_height = cpi->oxcf.render_height;\n  } else {\n    cm->render_width = cpi->oxcf.width;\n    cm->render_height = cpi->oxcf.height;\n  }\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      vp9_free_pc_tree(&cpi->td);\n      vpx_free(cpi->mbmi_ext_base);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    vpx_free(cpi->consec_zero_mv);\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->consec_zero_mv,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n\n    vpx_free(cpi->skin_map);\n    CHECK_MEM_ERROR(\n        &cm->error, cpi->skin_map,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n\n    free_copy_partition_data(cpi);\n    alloc_copy_partition_data(cpi);\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_update_layer_context_change_config(cpi,\n                                           (int)cpi->oxcf.target_bandwidth);\n  }\n\n  vp9_check_reset_rc_flag(cpi);\n\n  cpi->alt_ref_source = NULL;\n  rc->is_src_frame_alt_ref = 0;\n\n#if 0\n  // Experimental RD Code\n  cpi->frame_distortion = 0;\n  cpi->last_frame_distortion = 0;\n#endif\n\n  set_tile_limits(cpi);\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n  cpi->ext_refresh_frame_context_pending = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  vp9_set_row_mt(cpi);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,8 @@\n     new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n     if (cm->mi_alloc_size < new_mi_size) {\n       vp9_free_context_buffers(cm);\n+      vp9_free_pc_tree(&cpi->td);\n+      vpx_free(cpi->mbmi_ext_base);\n       alloc_compressor_data(cpi);\n       realloc_segmentation_maps(cpi);\n       cpi->initial_width = cpi->initial_height = 0;\n@@ -95,8 +97,18 @@\n     update_frame_size(cpi);\n \n   if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n-    memset(cpi->consec_zero_mv, 0,\n-           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n+    vpx_free(cpi->consec_zero_mv);\n+    CHECK_MEM_ERROR(\n+        &cm->error, cpi->consec_zero_mv,\n+        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n+\n+    vpx_free(cpi->skin_map);\n+    CHECK_MEM_ERROR(\n+        &cm->error, cpi->skin_map,\n+        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n+\n+    free_copy_partition_data(cpi);\n+    alloc_copy_partition_data(cpi);\n     if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n       vp9_cyclic_refresh_reset_resize(cpi);\n     rc->rc_1_frame = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    memset(cpi->consec_zero_mv, 0,",
                "           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));"
            ],
            "added_lines": [
                "      vp9_free_pc_tree(&cpi->td);",
                "      vpx_free(cpi->mbmi_ext_base);",
                "    vpx_free(cpi->consec_zero_mv);",
                "    CHECK_MEM_ERROR(",
                "        &cm->error, cpi->consec_zero_mv,",
                "        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));",
                "",
                "    vpx_free(cpi->skin_map);",
                "    CHECK_MEM_ERROR(",
                "        &cm->error, cpi->skin_map,",
                "        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));",
                "",
                "    free_copy_partition_data(cpi);",
                "    alloc_copy_partition_data(cpi);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-44488",
        "func_name": "webmproject/libvpx/vp9_alloc_context_buffers",
        "description": "VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",
        "git_url": "https://github.com/webmproject/libvpx/commit/263682c9a29395055f3b3afe2d97be1828a6223f",
        "commit_title": "Fix bug with smaller width bigger size",
        "commit_text": " Fixed previous patch that clusterfuzz failed on.  Bug: webm:1642",
        "func_before": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}",
        "func": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,13 +7,6 @@\n     cm->free_mi(cm);\n     if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n   }\n-\n-  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n-    // Create the segmentation map structure and set to 0.\n-    free_seg_map(cm);\n-    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n-  }\n-\n   if (cm->above_context_alloc_cols < cm->mi_cols) {\n     vpx_free(cm->above_context);\n     cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n@@ -28,6 +21,12 @@\n     cm->above_context_alloc_cols = cm->mi_cols;\n   }\n \n+  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n+    // Create the segmentation map structure and set to 0.\n+    free_seg_map(cm);\n+    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n+  }\n+\n   if (vp9_alloc_loop_filter(cm)) goto fail;\n \n   return 0;",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {",
                "    // Create the segmentation map structure and set to 0.",
                "    free_seg_map(cm);",
                "    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;",
                "  }",
                ""
            ],
            "added_lines": [
                "  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {",
                "    // Create the segmentation map structure and set to 0.",
                "    free_seg_map(cm);",
                "    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-44488",
        "func_name": "webmproject/libvpx/vp9_change_config",
        "description": "VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",
        "git_url": "https://github.com/webmproject/libvpx/commit/df9fd9d5b7325060b2b921558a1eb20ca7880937",
        "commit_title": "Fix bug with smaller width bigger size",
        "commit_text": " Fixed previous patch that clusterfuzz failed on.  Local fuzzing passing overnight.  Bug: webm:1642 (cherry picked from commit 263682c9a29395055f3b3afe2d97be1828a6223f)",
        "func_before": "void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int last_w = cpi->oxcf.width;\n  int last_h = cpi->oxcf.height;\n\n  vp9_init_quantizer(cpi);\n  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  if (cm->profile <= PROFILE_1)\n    assert(cm->bit_depth == VPX_BITS_8);\n  else\n    assert(cm->bit_depth > VPX_BITS_8);\n\n  cpi->oxcf = *oxcf;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {\n    rc->baseline_gf_interval = FIXED_GF_INTERVAL;\n  } else {\n    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;\n  }\n\n  cpi->refresh_golden_frame = 0;\n  cpi->refresh_last_frame = 1;\n  cm->refresh_frame_context = 1;\n  cm->reset_frame_context = 0;\n\n  vp9_reset_segment_features(&cm->seg);\n  vp9_set_high_precision_mv(cpi, 0);\n\n  {\n    int i;\n\n    for (i = 0; i < MAX_SEGMENTS; i++)\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n  }\n  cpi->encode_breakout = cpi->oxcf.encode_breakout;\n\n  vp9_set_rc_buffer_sizes(cpi);\n\n  // Set up frame rate and related parameters rate control values.\n  vp9_new_framerate(cpi, cpi->framerate);\n\n  // Set absolute upper and lower quality limits\n  rc->worst_quality = cpi->oxcf.worst_allowed_q;\n  rc->best_quality = cpi->oxcf.best_allowed_q;\n\n  cm->interp_filter = cpi->sf.default_interp_filter;\n\n  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {\n    cm->render_width = cpi->oxcf.render_width;\n    cm->render_height = cpi->oxcf.render_height;\n  } else {\n    cm->render_width = cpi->oxcf.width;\n    cm->render_height = cpi->oxcf.height;\n  }\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    memset(cpi->consec_zero_mv, 0,\n           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_update_layer_context_change_config(cpi,\n                                           (int)cpi->oxcf.target_bandwidth);\n  }\n\n  vp9_check_reset_rc_flag(cpi);\n\n  cpi->alt_ref_source = NULL;\n  rc->is_src_frame_alt_ref = 0;\n\n#if 0\n  // Experimental RD Code\n  cpi->frame_distortion = 0;\n  cpi->last_frame_distortion = 0;\n#endif\n\n  set_tile_limits(cpi);\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n  cpi->ext_refresh_frame_context_pending = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  vp9_set_row_mt(cpi);\n}",
        "func": "void vp9_change_config(struct VP9_COMP *cpi, const VP9EncoderConfig *oxcf) {\n  VP9_COMMON *const cm = &cpi->common;\n  RATE_CONTROL *const rc = &cpi->rc;\n  int last_w = cpi->oxcf.width;\n  int last_h = cpi->oxcf.height;\n\n  vp9_init_quantizer(cpi);\n  if (cm->profile != oxcf->profile) cm->profile = oxcf->profile;\n  cm->bit_depth = oxcf->bit_depth;\n  cm->color_space = oxcf->color_space;\n  cm->color_range = oxcf->color_range;\n\n  cpi->target_level = oxcf->target_level;\n  cpi->keep_level_stats = oxcf->target_level != LEVEL_MAX;\n  set_level_constraint(&cpi->level_constraint,\n                       get_level_index(cpi->target_level));\n\n  if (cm->profile <= PROFILE_1)\n    assert(cm->bit_depth == VPX_BITS_8);\n  else\n    assert(cm->bit_depth > VPX_BITS_8);\n\n  cpi->oxcf = *oxcf;\n#if CONFIG_VP9_HIGHBITDEPTH\n  cpi->td.mb.e_mbd.bd = (int)cm->bit_depth;\n#endif  // CONFIG_VP9_HIGHBITDEPTH\n\n  if ((oxcf->pass == 0) && (oxcf->rc_mode == VPX_Q)) {\n    rc->baseline_gf_interval = FIXED_GF_INTERVAL;\n  } else {\n    rc->baseline_gf_interval = (MIN_GF_INTERVAL + MAX_GF_INTERVAL) / 2;\n  }\n\n  cpi->refresh_golden_frame = 0;\n  cpi->refresh_last_frame = 1;\n  cm->refresh_frame_context = 1;\n  cm->reset_frame_context = 0;\n\n  vp9_reset_segment_features(&cm->seg);\n  vp9_set_high_precision_mv(cpi, 0);\n\n  {\n    int i;\n\n    for (i = 0; i < MAX_SEGMENTS; i++)\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n  }\n  cpi->encode_breakout = cpi->oxcf.encode_breakout;\n\n  vp9_set_rc_buffer_sizes(cpi);\n\n  // Set up frame rate and related parameters rate control values.\n  vp9_new_framerate(cpi, cpi->framerate);\n\n  // Set absolute upper and lower quality limits\n  rc->worst_quality = cpi->oxcf.worst_allowed_q;\n  rc->best_quality = cpi->oxcf.best_allowed_q;\n\n  cm->interp_filter = cpi->sf.default_interp_filter;\n\n  if (cpi->oxcf.render_width > 0 && cpi->oxcf.render_height > 0) {\n    cm->render_width = cpi->oxcf.render_width;\n    cm->render_height = cpi->oxcf.render_height;\n  } else {\n    cm->render_width = cpi->oxcf.width;\n    cm->render_height = cpi->oxcf.height;\n  }\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      vp9_free_pc_tree(&cpi->td);\n      vpx_free(cpi->mbmi_ext_base);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    vpx_free(cpi->consec_zero_mv);\n    CHECK_MEM_ERROR(\n        cm, cpi->consec_zero_mv,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n\n    vpx_free(cpi->skin_map);\n    CHECK_MEM_ERROR(\n        cm, cpi->skin_map,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n\n    free_copy_partition_data(cpi);\n    alloc_copy_partition_data(cpi);\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {\n    vp9_update_layer_context_change_config(cpi,\n                                           (int)cpi->oxcf.target_bandwidth);\n  }\n\n  vp9_check_reset_rc_flag(cpi);\n\n  cpi->alt_ref_source = NULL;\n  rc->is_src_frame_alt_ref = 0;\n\n#if 0\n  // Experimental RD Code\n  cpi->frame_distortion = 0;\n  cpi->last_frame_distortion = 0;\n#endif\n\n  set_tile_limits(cpi);\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n  cpi->ext_refresh_frame_context_pending = 0;\n\n#if CONFIG_VP9_HIGHBITDEPTH\n  highbd_set_var_fns(cpi);\n#endif\n\n  vp9_set_row_mt(cpi);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,8 @@\n     new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n     if (cm->mi_alloc_size < new_mi_size) {\n       vp9_free_context_buffers(cm);\n+      vp9_free_pc_tree(&cpi->td);\n+      vpx_free(cpi->mbmi_ext_base);\n       alloc_compressor_data(cpi);\n       realloc_segmentation_maps(cpi);\n       cpi->initial_width = cpi->initial_height = 0;\n@@ -95,8 +97,18 @@\n     update_frame_size(cpi);\n \n   if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n-    memset(cpi->consec_zero_mv, 0,\n-           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n+    vpx_free(cpi->consec_zero_mv);\n+    CHECK_MEM_ERROR(\n+        cm, cpi->consec_zero_mv,\n+        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n+\n+    vpx_free(cpi->skin_map);\n+    CHECK_MEM_ERROR(\n+        cm, cpi->skin_map,\n+        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n+\n+    free_copy_partition_data(cpi);\n+    alloc_copy_partition_data(cpi);\n     if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n       vp9_cyclic_refresh_reset_resize(cpi);\n     rc->rc_1_frame = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    memset(cpi->consec_zero_mv, 0,",
                "           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));"
            ],
            "added_lines": [
                "      vp9_free_pc_tree(&cpi->td);",
                "      vpx_free(cpi->mbmi_ext_base);",
                "    vpx_free(cpi->consec_zero_mv);",
                "    CHECK_MEM_ERROR(",
                "        cm, cpi->consec_zero_mv,",
                "        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));",
                "",
                "    vpx_free(cpi->skin_map);",
                "    CHECK_MEM_ERROR(",
                "        cm, cpi->skin_map,",
                "        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));",
                "",
                "    free_copy_partition_data(cpi);",
                "    alloc_copy_partition_data(cpi);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-44488",
        "func_name": "webmproject/libvpx/vp9_alloc_context_buffers",
        "description": "VP9 in libvpx before 1.13.1 mishandles widths, leading to a crash related to encoding.",
        "git_url": "https://github.com/webmproject/libvpx/commit/df9fd9d5b7325060b2b921558a1eb20ca7880937",
        "commit_title": "Fix bug with smaller width bigger size",
        "commit_text": " Fixed previous patch that clusterfuzz failed on.  Local fuzzing passing overnight.  Bug: webm:1642 (cherry picked from commit 263682c9a29395055f3b3afe2d97be1828a6223f)",
        "func_before": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}",
        "func": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,13 +7,6 @@\n     cm->free_mi(cm);\n     if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n   }\n-\n-  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n-    // Create the segmentation map structure and set to 0.\n-    free_seg_map(cm);\n-    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n-  }\n-\n   if (cm->above_context_alloc_cols < cm->mi_cols) {\n     vpx_free(cm->above_context);\n     cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n@@ -28,6 +21,12 @@\n     cm->above_context_alloc_cols = cm->mi_cols;\n   }\n \n+  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n+    // Create the segmentation map structure and set to 0.\n+    free_seg_map(cm);\n+    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n+  }\n+\n   if (vp9_alloc_loop_filter(cm)) goto fail;\n \n   return 0;",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {",
                "    // Create the segmentation map structure and set to 0.",
                "    free_seg_map(cm);",
                "    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;",
                "  }",
                ""
            ],
            "added_lines": [
                "  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {",
                "    // Create the segmentation map structure and set to 0.",
                "    free_seg_map(cm);",
                "    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-38406",
        "func_name": "FRRouting/frr/bgp_nlri_parse_flowspec",
        "description": "bgpd/bgp_flowspec.c in FRRouting (FRR) before 8.4.3 mishandles an nlri length of zero, aka a \"flowspec overflow.\"",
        "git_url": "https://github.com/FRRouting/frr/commit/0b999c886e241c52bd1f7ef0066700e4b618ebb3",
        "commit_title": "bgpd: Flowspec overflow issue",
        "commit_text": " According to the flowspec RFC 8955 a flowspec nlri is <length, <nlri data>> Specifying 0 as a length makes BGP get all warm on the inside.  Which in this case is not a good thing at all.  Prevent warmth, stay cold on the inside. ",
        "func_before": "int bgp_nlri_parse_flowspec(struct peer *peer, struct attr *attr,\n\t\t\t    struct bgp_nlri *packet, int withdraw)\n{\n\tuint8_t *pnt;\n\tuint8_t *lim;\n\tafi_t afi;\n\tsafi_t safi;\n\tint psize = 0;\n\tstruct prefix p;\n\tvoid *temp;\n\n\t/* Start processing the NLRI - there may be multiple in the MP_REACH */\n\tpnt = packet->nlri;\n\tlim = pnt + packet->length;\n\tafi = packet->afi;\n\tsafi = packet->safi;\n\n\tif (packet->length >= FLOWSPEC_NLRI_SIZELIMIT_EXTENDED) {\n\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n\t\t\t \"BGP flowspec nlri length maximum reached (%u)\",\n\t\t\t packet->length);\n\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_NLRI_SIZELIMIT;\n\t}\n\n\tfor (; pnt < lim; pnt += psize) {\n\t\t/* Clear prefix structure. */\n\t\tmemset(&p, 0, sizeof(p));\n\n\t\t/* All FlowSpec NLRI begin with length. */\n\t\tif (pnt + 1 > lim)\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\n\t\tpsize = *pnt++;\n\t\tif (psize >= FLOWSPEC_NLRI_SIZELIMIT) {\n\t\t\tpsize &= 0x0f;\n\t\t\tpsize = psize << 8;\n\t\t\tpsize |= *pnt++;\n\t\t}\n\t\t/* When packet overflow occur return immediately. */\n\t\tif (pnt + psize > lim) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Flowspec NLRI length inconsistent ( size %u seen)\",\n\t\t\t\tpsize);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\t\tif (bgp_fs_nlri_validate(pnt, psize, afi) < 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Bad flowspec format or NLRI options not supported\");\n\t\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_BAD_FORMAT;\n\t\t}\n\t\tp.family = AF_FLOWSPEC;\n\t\tp.prefixlen = 0;\n\t\t/* Flowspec encoding is in bytes */\n\t\tp.u.prefix_flowspec.prefixlen = psize;\n\t\tp.u.prefix_flowspec.family = afi2family(afi);\n\t\ttemp = XCALLOC(MTYPE_TMP, psize);\n\t\tmemcpy(temp, pnt, psize);\n\t\tp.u.prefix_flowspec.ptr = (uintptr_t) temp;\n\n\t\tif (BGP_DEBUG(flowspec, FLOWSPEC)) {\n\t\t\tchar return_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar local_string[BGP_FLOWSPEC_NLRI_STRING_MAX*2+16];\n\t\t\tchar ec_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar *s = NULL;\n\n\t\t\tbgp_fs_nlri_get_string((unsigned char *)\n\t\t\t\t\t       p.u.prefix_flowspec.ptr,\n\t\t\t\t\t       p.u.prefix_flowspec.prefixlen,\n\t\t\t\t\t       return_string,\n\t\t\t\t\t       NLRI_STRING_FORMAT_MIN, NULL,\n\t\t\t\t\t       afi);\n\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t \"EC{none}\");\n\t\t\tif (attr && bgp_attr_get_ecommunity(attr)) {\n\t\t\t\ts = ecommunity_ecom2str(\n\t\t\t\t\tbgp_attr_get_ecommunity(attr),\n\t\t\t\t\tECOMMUNITY_FORMAT_ROUTE_MAP, 0);\n\t\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t\t \"EC{%s}\",\n\t\t\t\t\ts == NULL ? \"none\" : s);\n\n\t\t\t\tif (s)\n\t\t\t\t\tecommunity_strfree(&s);\n\t\t\t}\n\t\t\tsnprintf(local_string, sizeof(local_string),\n\t\t\t\t \"FS Rx %s %s %s %s\", withdraw ?\n\t\t\t\t \"Withdraw\":\"Update\",\n\t\t\t\t afi2str(afi), return_string,\n\t\t\t\t attr != NULL ? ec_string : \"\");\n\t\t\tzlog_info(\"%s\", local_string);\n\t\t}\n\t\t/* Process the route. */\n\t\tif (!withdraw)\n\t\t\tbgp_update(peer, &p, 0, attr, afi, safi,\n\t\t\t\t   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,\n\t\t\t\t   NULL, 0, 0, NULL);\n\t\telse\n\t\t\tbgp_withdraw(peer, &p, 0, afi, safi, ZEBRA_ROUTE_BGP,\n\t\t\t\t     BGP_ROUTE_NORMAL, NULL, NULL, 0, NULL);\n\t}\n\treturn BGP_NLRI_PARSE_OK;\n}",
        "func": "int bgp_nlri_parse_flowspec(struct peer *peer, struct attr *attr,\n\t\t\t    struct bgp_nlri *packet, int withdraw)\n{\n\tuint8_t *pnt;\n\tuint8_t *lim;\n\tafi_t afi;\n\tsafi_t safi;\n\tint psize = 0;\n\tstruct prefix p;\n\tvoid *temp;\n\n\t/* Start processing the NLRI - there may be multiple in the MP_REACH */\n\tpnt = packet->nlri;\n\tlim = pnt + packet->length;\n\tafi = packet->afi;\n\tsafi = packet->safi;\n\n\tif (packet->length >= FLOWSPEC_NLRI_SIZELIMIT_EXTENDED) {\n\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n\t\t\t \"BGP flowspec nlri length maximum reached (%u)\",\n\t\t\t packet->length);\n\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_NLRI_SIZELIMIT;\n\t}\n\n\tfor (; pnt < lim; pnt += psize) {\n\t\t/* Clear prefix structure. */\n\t\tmemset(&p, 0, sizeof(p));\n\n\t\t/* All FlowSpec NLRI begin with length. */\n\t\tif (pnt + 1 > lim)\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\n\t\tpsize = *pnt++;\n\t\tif (psize >= FLOWSPEC_NLRI_SIZELIMIT) {\n\t\t\tpsize &= 0x0f;\n\t\t\tpsize = psize << 8;\n\t\t\tpsize |= *pnt++;\n\t\t}\n\t\t/* When packet overflow occur return immediately. */\n\t\tif (pnt + psize > lim) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Flowspec NLRI length inconsistent ( size %u seen)\",\n\t\t\t\tpsize);\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\tif (psize == 0) {\n\t\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t \"Flowspec NLRI length 0 which makes no sense\");\n\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n\t\t}\n\n\t\tif (bgp_fs_nlri_validate(pnt, psize, afi) < 0) {\n\t\t\tflog_err(\n\t\t\t\tEC_BGP_FLOWSPEC_PACKET,\n\t\t\t\t\"Bad flowspec format or NLRI options not supported\");\n\t\t\treturn BGP_NLRI_PARSE_ERROR_FLOWSPEC_BAD_FORMAT;\n\t\t}\n\t\tp.family = AF_FLOWSPEC;\n\t\tp.prefixlen = 0;\n\t\t/* Flowspec encoding is in bytes */\n\t\tp.u.prefix_flowspec.prefixlen = psize;\n\t\tp.u.prefix_flowspec.family = afi2family(afi);\n\t\ttemp = XCALLOC(MTYPE_TMP, psize);\n\t\tmemcpy(temp, pnt, psize);\n\t\tp.u.prefix_flowspec.ptr = (uintptr_t) temp;\n\n\t\tif (BGP_DEBUG(flowspec, FLOWSPEC)) {\n\t\t\tchar return_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar local_string[BGP_FLOWSPEC_NLRI_STRING_MAX*2+16];\n\t\t\tchar ec_string[BGP_FLOWSPEC_NLRI_STRING_MAX];\n\t\t\tchar *s = NULL;\n\n\t\t\tbgp_fs_nlri_get_string((unsigned char *)\n\t\t\t\t\t       p.u.prefix_flowspec.ptr,\n\t\t\t\t\t       p.u.prefix_flowspec.prefixlen,\n\t\t\t\t\t       return_string,\n\t\t\t\t\t       NLRI_STRING_FORMAT_MIN, NULL,\n\t\t\t\t\t       afi);\n\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t \"EC{none}\");\n\t\t\tif (attr && bgp_attr_get_ecommunity(attr)) {\n\t\t\t\ts = ecommunity_ecom2str(\n\t\t\t\t\tbgp_attr_get_ecommunity(attr),\n\t\t\t\t\tECOMMUNITY_FORMAT_ROUTE_MAP, 0);\n\t\t\t\tsnprintf(ec_string, sizeof(ec_string),\n\t\t\t\t\t \"EC{%s}\",\n\t\t\t\t\ts == NULL ? \"none\" : s);\n\n\t\t\t\tif (s)\n\t\t\t\t\tecommunity_strfree(&s);\n\t\t\t}\n\t\t\tsnprintf(local_string, sizeof(local_string),\n\t\t\t\t \"FS Rx %s %s %s %s\", withdraw ?\n\t\t\t\t \"Withdraw\":\"Update\",\n\t\t\t\t afi2str(afi), return_string,\n\t\t\t\t attr != NULL ? ec_string : \"\");\n\t\t\tzlog_info(\"%s\", local_string);\n\t\t}\n\t\t/* Process the route. */\n\t\tif (!withdraw)\n\t\t\tbgp_update(peer, &p, 0, attr, afi, safi,\n\t\t\t\t   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL,\n\t\t\t\t   NULL, 0, 0, NULL);\n\t\telse\n\t\t\tbgp_withdraw(peer, &p, 0, afi, safi, ZEBRA_ROUTE_BGP,\n\t\t\t\t     BGP_ROUTE_NORMAL, NULL, NULL, 0, NULL);\n\t}\n\treturn BGP_NLRI_PARSE_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,6 +44,13 @@\n \t\t\t\tpsize);\n \t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n \t\t}\n+\n+\t\tif (psize == 0) {\n+\t\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,\n+\t\t\t\t \"Flowspec NLRI length 0 which makes no sense\");\n+\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;\n+\t\t}\n+\n \t\tif (bgp_fs_nlri_validate(pnt, psize, afi) < 0) {\n \t\t\tflog_err(\n \t\t\t\tEC_BGP_FLOWSPEC_PACKET,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\tif (psize == 0) {",
                "\t\t\tflog_err(EC_BGP_FLOWSPEC_PACKET,",
                "\t\t\t\t \"Flowspec NLRI length 0 which makes no sense\");",
                "\t\t\treturn BGP_NLRI_PARSE_ERROR_PACKET_OVERFLOW;",
                "\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48232",
        "func_name": "vim/adjust_plines_for_skipcol",
        "description": "Vim is an open source command line text editor. A floating point exception may occur when calculating the line offset for overlong lines and smooth scrolling is enabled and the cpo-settings include the 'n' flag. This may happen when a window border is present and when the wrapped line continues on the next physical line directly in the window border because the 'cpo' setting includes the 'n' flag. Only users with non-default settings are affected and the exception should only result in a crash. This issue has been addressed in commit `cb0b99f0` which has been included in release version 9.0.2107. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/vim/vim/commit/cb0b99f0672d8446585d26e998343dceca17d1ce",
        "commit_title": "patch 9.0.2107: [security]: FPE in adjust_plines_for_skipcol",
        "commit_text": " Problem:  [security]: FPE in adjust_plines_for_skipcol Solution: don't divide by zero, return zero  Prevent a floating point exception when calculating w_skipcol (which can happen with a small window when the number option is set and cpo+=n).  Add a test to verify ",
        "func_before": "int\nadjust_plines_for_skipcol(win_T *wp)\n{\n    if (wp->w_skipcol == 0)\n\treturn 0;\n\n    int width = wp->w_width - win_col_off(wp);\n    if (wp->w_skipcol >= width)\n\treturn (wp->w_skipcol - width) / (width + win_col_off2(wp)) + 1;\n\n    return 0;\n}",
        "func": "int\nadjust_plines_for_skipcol(win_T *wp)\n{\n    if (wp->w_skipcol == 0)\n\treturn 0;\n\n    int width = wp->w_width - win_col_off(wp);\n    int w2 = width + win_col_off2(wp);\n    if (wp->w_skipcol >= width && w2 > 0)\n\treturn (wp->w_skipcol - width) / w2 + 1;\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,9 @@\n \treturn 0;\n \n     int width = wp->w_width - win_col_off(wp);\n-    if (wp->w_skipcol >= width)\n-\treturn (wp->w_skipcol - width) / (width + win_col_off2(wp)) + 1;\n+    int w2 = width + win_col_off2(wp);\n+    if (wp->w_skipcol >= width && w2 > 0)\n+\treturn (wp->w_skipcol - width) / w2 + 1;\n \n     return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (wp->w_skipcol >= width)",
                "\treturn (wp->w_skipcol - width) / (width + win_col_off2(wp)) + 1;"
            ],
            "added_lines": [
                "    int w2 = width + win_col_off2(wp);",
                "    if (wp->w_skipcol >= width && w2 > 0)",
                "\treturn (wp->w_skipcol - width) / w2 + 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4584",
        "func_name": "horms/perdition/main",
        "description": "Perdition before 2.2 may have weak security when handling outbound connections, caused by an error in the STARTTLS IMAP and POP server. ssl_outgoing_ciphers not being applied to STARTTLS connections",
        "git_url": "https://github.com/horms/perdition/commit/62a0ce94aeb7dd99155882956ce9e327ab914ddf",
        "commit_title": "Use specified ciphers for outgoing STARTLS connections",
        "commit_text": " Perdition(8) says:          --ssl_outgoing_ciphers STRING:                Cipher list when making outgoing SSL or TLS connections as               per ciphers(1). If empty (\"\") then openssl's default will               be used.  (default \"\")  However, this is only the case for outgoing connections that do not use STARTTLS (the perdition terminology is confusing here, since what it calls \"TLS\" actually means \"start as cleartext, negotiate to encrypted via STARTTLS\" and what it calls \"SSL\" actually means \"start SSL or TLS session, run service inside that\").   This is a security concern because it means that perdition is not obeying the specifications of the administrator, and may accept weaker ciphersuites than instructed on its backhaul connections.  Consider the case where an administrator wants to offer relatively promiscuous IMAP connections to their end users -- if the user's MUA only has some weak cipher suite or cleartext IMAP, we want to accept the weak ciphersuite as better than nothing.  However, the admin's backend IMAP servers are all under her control, and she knows that they are capable of stronger ciphersuites.  in this case, ssl_listen_ciphers will allow weak ciphers, and ssl_outgoing_ciphers will be strict and require high security, to at least protect the link between perdition and the backend IMAP server.  However, if this outgoing connection happens to use IMAP+STARTTLS instead of IMAPS, the bug described here will offer weak ciphersuites to the backend IMAP server.  This is CVE-2013-4584 This is Debian Bug #729028 ",
        "func_before": "int main (int argc, char **argv, char **envp){\n  STRUCT_AUTH(auth);\n  char *server_resp_buf = NULL;\n  char *buffer;\n  user_server_port_t *usp=NULL;\n  protocol_t *protocol=NULL;\n  token_t *our_tag=NULL;\n  token_t *client_tag=NULL;\n  size_t server_resp_buf_size=0;\n  flag_t tls_state = 0;\n  timed_log_t auth_log;\n  char from_to_host_str[((NI_MAXHOST+NI_MAXSERV)*2)+2];\n  char from_host_str[NI_MAXHOST];\n  char to_host_str[NI_MAXHOST];\n  char from_serv_str[NI_MAXSERV];\n  char to_serv_str[NI_MAXSERV];\n  char *servername=NULL;\n  char *port=NULL;\n  io_t *client_io=NULL;\n  io_t *server_io=NULL;\n  FILE *fh;\n  size_t bytes_written = 0;\n  size_t bytes_read = 0;\n  int status;\n  int round_robin_server=0;\n  int rnd;\n  int s=-1;\n  int *g = NULL;\n  int rc;\n  int flag;\n\n#ifdef WITH_SSL_SUPPORT\n  SSL_CTX *ssl_ctx=NULL;\n#endif /* WITH_SSL_SUPPORT */\n\n  /* Create Logger */\n  progname = argv[0];\n  logger_init();\n\n  /*Parse options*/\n  options(argc, argv, OPT_FIRST_CALL);\n\n  /*Read config file*/\n  if(opt.config_file!=NULL){\n    config_file_to_opt(opt.config_file);\n  }\n\n  /* Initialise setting of proctitle */\n  init_set_proc_title(argc, argv, envp);\n  progname = strdup(get_progname(argv[0]));\n  if (!progname) {\n\t  VANESSA_LOGGER_DEBUG_ERRNO(\"strdup\");\n\t  VANESSA_LOGGER_ERR(\"Error initialising process title\\n\");\n\t  perdition_exit_cleanly(-1);\n  }\n  set_proc_title(\"%s: daemon\", progname);\n\n  /* Update Logger */\n  if (!opt.debug)\n    vanessa_logger_change_max_priority(vanessa_logger_get(),\n\t\t\t\t       opt.quiet?LOG_ERR:LOG_INFO);\n\n  /*Open the dbserver_get library, if we have a library*/\n  if(getserver_openlib(opt.map_library, opt.map_library_opt,\n        &handle, &dbserver_get, &dbserver_get2)<0){\n    VANESSA_LOGGER_ERR_UNSAFE(\"dlopen of \\\"%s\\\" failed\", \n    str_null_safe(opt.map_library));\n    usage(-1);\n    perdition_exit_cleanly(-1);\n  }\n\n  /*Set signal handlers*/\n  signal(SIGHUP,    perdition_reread_handler);\n  signal(SIGINT,    perdition_exit_cleanly);\n  signal(SIGQUIT,   perdition_exit_cleanly);\n  signal(SIGILL,    perdition_exit_cleanly);\n  signal(SIGTRAP,   perdition_exit_cleanly);\n  signal(SIGIOT,    perdition_exit_cleanly);\n  signal(SIGBUS,    perdition_exit_cleanly);\n  signal(SIGFPE,    perdition_exit_cleanly);\n  signal(SIGUSR1,   vanessa_socket_handler_noop);\n  signal(SIGSEGV,   perdition_exit_cleanly);\n  signal(SIGUSR2,   vanessa_socket_handler_noop);\n  signal(SIGPIPE,   SIG_IGN);\n  signal(SIGALRM,   perdition_exit_cleanly);\n  signal(SIGTERM,   perdition_exit_cleanly);\n  signal(SIGCHLD,   vanessa_socket_handler_reaper);\n  signal(SIGURG,    perdition_exit_cleanly);\n  signal(SIGXCPU,   perdition_exit_cleanly);\n  signal(SIGXFSZ,   perdition_exit_cleanly);\n  signal(SIGVTALRM, perdition_exit_cleanly);\n  signal(SIGPROF,   perdition_exit_cleanly);\n  signal(SIGWINCH,  perdition_exit_cleanly);\n  signal(SIGIO,     perdition_exit_cleanly);\n\n  /* Set file descriptor to log to, if any */\n  fh = NULL;\n  if(opt.log_facility!=NULL) {\n    if(*(opt.log_facility) == '-') {\n      fh = stdout;\n    }\n    else if(*(opt.log_facility) == '+') {\n      fh = stderr;\n    }\n  }\n\n  /*\n   * Re-create logger now process is detached (unless in inetd mode)\n   * and configuration file has been read.\n   */\n  logger_reopen(fh);\n\n  /*Seed the uname structure*/\n  if((system_uname=(struct utsname *)malloc(sizeof(struct utsname)))==NULL){\n    VANESSA_LOGGER_DEBUG_ERRNO(\"malloc system_uname\");\n    VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n  if(uname(system_uname)<0){\n    VANESSA_LOGGER_DEBUG(\"uname\");\n    VANESSA_LOGGER_ERR(\"Fatal error finding uname for system. Exiting\");\n    perdition_exit_cleanly(-1);\n  }\n\n  /*Set up protocol structure*/\n  if((protocol=protocol_initialise(opt.protocol, protocol))==NULL){\n    VANESSA_LOGGER_DEBUG(\"protocol_initialise\");\n    VANESSA_LOGGER_ERR(\"Fatal error initialising protocol. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n\n  /*Set listen and outgoing port now the protocol structure is accessable*/\n  if((opt.listen_port=protocol->port(opt.listen_port))==NULL){\n    VANESSA_LOGGER_DEBUG(\"protocol->port 1\");\n    VANESSA_LOGGER_ERR(\"Fatal error finding port to listen on. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n  if((opt.outgoing_port=protocol->port(opt.outgoing_port))==NULL){\n    VANESSA_LOGGER_DEBUG(\"protocol->port 2\");\n    VANESSA_LOGGER_ERR(\"Fatal error finding port to connect to. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n\n  /* \n   * Set up a tag to use. \n   * Only used for IMAP based protocols, but it is harmless to have it\n   * lying about\n   */\n  if(opt.protocol == PROTOCOL_IMAP4 || opt.protocol == PROTOCOL_IMAP4S) {\n  \tour_tag = imap4_tag_create();\n  \tif(!our_tag) {\n\t  \tVANESSA_LOGGER_DEBUG(\"imap4_tag_create\");\n\t  \tVANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n\t  \tperdition_exit_cleanly(-1);\n  \t}\n  }\n  else {\n\t  our_tag = NULL;\n  }\n\n  /*\n   * Log the options we will be running with.\n   * If we are in inetd mode then only do this if debugging is turned on,\n   * else debugging is a bit too verbose.\n   */\n  if ((!opt.quiet && !opt.inetd_mode && !opt.no_daemon && !fh) || opt.debug) {\n    if (log_options()) {\n      VANESSA_LOGGER_DEBUG(\"log_options\");\n      VANESSA_LOGGER_ERR(\"Fatal error logging options. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n\n#ifdef WITH_SSL_SUPPORT\n  /*Set up the ssl mode */\n  opt.ssl_mode=protocol->encryption(opt.ssl_mode);\n\n  if(opt.ssl_mode & SSL_LISTEN_MASK) {\n    ssl_ctx = perdition_ssl_ctx(opt.ssl_ca_file, opt.ssl_ca_path,\n\t\t\t\topt.ssl_cert_file, opt.ssl_key_file,\n\t\t\t\topt.ssl_ca_chain_file, opt.ssl_listen_ciphers,\n\t\t\t\tPERDITION_SSL_SERVER);\n    if(!ssl_ctx) {\n      PERDITION_DEBUG_SSL_ERR(\"perdition_ssl_ctx\");\n      VANESSA_LOGGER_ERR(\"Fatal error establishing SSL context for listening\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n#endif /* WITH_SSL_SUPPORT */\n\n  /* Close file descriptors and detach process from shell as necessary */\n  if (opt.inetd_mode || opt.no_daemon || fh != NULL)\n    vanessa_socket_daemon_inetd_process();\n  else {\n    vanessa_socket_daemon_process();\n    if (vanessa_logger_reopen(vanessa_logger_get()) < 0) {\n      fprintf(stderr, \"Fatal error reopening logger. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n\n  /* Create PID file */\n  if (!opt.inetd_mode && opt.pid_file && *opt.pid_file) {\n  \tif(write_pid_file(opt.pid_file, opt.username, opt.group) < 0) {\n\t\tVANESSA_LOGGER_DEBUG(\"write_pid_file\");\n\t\tVANESSA_LOGGER_ERR(\"Could not write pid file\");\n\t\tperdition_exit_cleanly(1);\n\t}\n\tpid_file = opt.pid_file;\n  }\n\n  /*\n   * If we are using the server's ok line then allocate a buffer to store it\n   */ \n  if(opt.server_resp_line){\n    server_resp_buf = malloc(MAX_LINE_LENGTH);\n    if (!server_resp_buf) {\n      VANESSA_LOGGER_DEBUG_ERRNO(\"malloc server_resp_buf\");\n      VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n\n  /*\n   * Allocate the peername and sockname structures\n   */\n  sockname = malloc(sizeof(*sockname));\n  if (!sockname) {\n    VANESSA_LOGGER_DEBUG_ERRNO(\"malloc sockname\");\n    VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n  peername = malloc(sizeof(*peername));\n  if (!peername) {\n    VANESSA_LOGGER_DEBUG_ERRNO(\"malloc peername\");\n    VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n  \n\n  /* Open incoming socket as required */\n  if(!opt.inetd_mode) {\n\t  size_t nfrom;\n\t  const char **fromv;\n\t  \n  \t  if (opt.bind_address) \n\t\t  nfrom = vanessa_dynamic_array_get_count(opt.bind_address);\n\t  else \n\t\t  nfrom = 1;\n\t  \n\t  fromv = malloc(sizeof(*fromv) * ((nfrom * 2) + 1));\n\t  if (!fromv) {\n\t\t  VANESSA_LOGGER_DEBUG_ERRNO(\"malloc fromv\");\n\t\t  VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n\t\t  perdition_exit_cleanly(-1);\n\t  }\n\t  \n  \t  if (opt.bind_address) {\n\t\t  size_t i;\n\t\t  user_server_port_t *from_usp;\n\t\t  for (i = 0; i < nfrom; i++) {\n\t\t\t  from_usp = vanessa_dynamic_array_get_element(\n\t\t\t\t\t\topt.bind_address, i);\n\t\t\t  fromv[i * 2] = user_server_port_get_server(from_usp);\n\t\t\t  fromv[(i * 2) + 1] = user_server_port_get_port(\n\t\t\t  \t\t\tfrom_usp);\n\t\t\t  if (!fromv[(i * 2) + 1])\n\t\t\t\t  fromv[(i * 2) + 1] = opt.listen_port;\n\t\t  }\n\t  }\n\t  else {\n\t  \t  fromv[0] = \"0.0.0.0\";\n\t  \t  fromv[1] = opt.listen_port;\n\t  }\n\t  fromv[nfrom * 2] = NULL;\n\t  flag = 0;\n    \t  if (opt.no_lookup)\n\t    \tflag |= VANESSA_SOCKET_NO_LOOKUP;\n    \t  if (opt.tcp_keepalive)\n\t    \tflag |= VANESSA_SOCKET_TCP_KEEPALIVE;\n\t  g = vanessa_socket_server_bindv(fromv, flag);\n\t  free(fromv);\n\t  if(!g) {\n\t\t  VANESSA_LOGGER_DEBUG(\"vanessa_socket_server_bindv\");\n\t\t  VANESSA_LOGGER_ERR(\"Fatal error listening for connections.\"\n\t\t\t\t     \"Exiting.\");\n\t\t  perdition_exit_cleanly(-1);\n\t  }\n  }\n\n  /*\n   * Become someone else\n   * NB: We do this later if we are going to authenticate locally \n   */\n#ifdef WITH_PAM_SUPPORT\n  if(opt.authenticate_in) {\n    if(geteuid()){\n      VANESSA_LOGGER_INFO(\"Warning: not invoked as root, \"\n\t\t      \"local authentication may fail\");\n    }\n  }\n  else\n#endif\n    PERDITION_SET_UID_AND_GID;\n\n  /* Get an incoming connection */\n  if(opt.inetd_mode){\n    socklen_t namelen;\n\n    if((client_io=io_create_fd(0, 1, PERDITION_LOG_STR_CLIENT))==NULL){\n      VANESSA_LOGGER_DEBUG(\"io_create_fd 1\");\n      VANESSA_LOGGER_ERR(\"Fatal error setting IO. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n    io_set_timeout(client_io, opt.authenticate_timeout);\n\n    namelen = sizeof(*peername);\n    if (getpeername(0, (struct sockaddr *)peername, &namelen)) {\n      free(peername);\n      peername=NULL;\n    }\n\n    namelen = sizeof(*sockname);\n    if (getsockname(1, (struct sockaddr *)sockname, &namelen)) {\n      free(sockname);\n      sockname=NULL;\n    }\n  }\n  else{\n    flag = 0;\n    if (opt.tcp_keepalive)\n      flag |= VANESSA_SOCKET_TCP_KEEPALIVE;\n    s = vanessa_socket_server_acceptv(g, opt.connection_limit,\n\t\t\t\t      (struct sockaddr *) peername,\n\t\t\t\t      (struct sockaddr *) sockname, flag);\n    if(s < 0){\n      VANESSA_LOGGER_DEBUG(\"vanessa_socket_server_accept\");\n      VANESSA_LOGGER_ERR(\"Fatal error accepting child connection. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n\n    /* Child processes don't clean up the pid file */\n    pid_file = NULL;\n\n    /* Reopen the logger, the child gets its own FDs */\n    vanessa_logger_reopen(vanessa_logger_get());\n\n    if((client_io=io_create_fd(s, s, PERDITION_LOG_STR_CLIENT))==NULL){\n      VANESSA_LOGGER_DEBUG(\"io_create_fd 2\");\n      VANESSA_LOGGER_ERR(\"Fatal error setting IO. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n    io_set_timeout(client_io, opt.authenticate_timeout);\n  }\n\n  /* A child process, or process handling an inetd connection\n   * should exit on receipt of a SIG PIPE.\n   */\n  signal(SIGPIPE,   perdition_exit_cleanly);\n\n  /* Get the source and destination ip address as a string */\n  if (peername!=NULL) {\n    rc = getnameinfo((struct sockaddr *)peername,\n\t\t     perdition_get_salen((struct sockaddr *)peername),\n\t\t     from_host_str, NI_MAXHOST, from_serv_str, NI_MAXSERV,\n\t\t     NI_NUMERICHOST|NI_NUMERICSERV);\n    if (rc) {\n        VANESSA_LOGGER_DEBUG_UNSAFE(\"getnameinfo peername: %s\",\n\t\t\t\t    gai_strerror(rc));\n\tVANESSA_LOGGER_ERR(\"Fatal error formatting peername\");\n\tperdition_exit_cleanly(-1);\n    }\n  }\n  else {\n    *from_host_str='\\0';\n    *from_serv_str='\\0';\n  }\n  if (sockname!=NULL) {\n    rc = getnameinfo((struct sockaddr *)sockname,\n\t\t     perdition_get_salen((struct sockaddr *)sockname),\n\t\t     to_host_str, NI_MAXHOST, to_serv_str, NI_MAXSERV,\n\t\t     NI_NUMERICHOST|NI_NUMERICSERV);\n    if (rc) {\n        VANESSA_LOGGER_DEBUG_UNSAFE(\"getnameinfo sockname: %s\",\n\t\t\t\t    gai_strerror(rc));\n\tVANESSA_LOGGER_ERR(\"Fatal error formatting sockname\");\n\tperdition_exit_cleanly(-1);\n    }\n  }\n  else {\n    *to_host_str='\\0';\n    *to_serv_str='\\0';\n  }\n  *from_to_host_str='\\0';\n  if(peername!=NULL && sockname!=NULL){\n    strcat(from_to_host_str, \" \");\n    strcat(from_to_host_str, from_host_str);\n    strcat(from_to_host_str, \":\");\n    strcat(from_to_host_str, from_serv_str);\n    strcat(from_to_host_str, \"->\");\n    strcat(from_to_host_str, to_host_str);\n    strcat(from_to_host_str, \":\");\n    strcat(from_to_host_str, to_serv_str);\n  }\n\n  /*Seed rand*/\n  srand(time(NULL)*getpid());\n  rnd=rand();\n\n  /*Log the session and change the proctitle*/\n  if(opt.inetd_mode) {\n    VANESSA_LOGGER_INFO_UNSAFE(\"Connect: %s inetd_pid=%d\",\n          from_to_host_str, getppid());\n  }\n  else {\n    VANESSA_LOGGER_INFO_UNSAFE(\"Connect: %s\", from_to_host_str);\n  }\n  set_proc_title(\"%s: connect (%s)\", progname, from_to_host_str);\n\n#ifdef WITH_SSL_SUPPORT\n  if(opt.ssl_mode & SSL_MODE_SSL_LISTEN) {\n    client_io = perdition_ssl_server_connection(client_io, ssl_ctx);\n    if(!client_io) {\n      VANESSA_LOGGER_DEBUG(\"perdition_ssl_server_connection SSL\");\n      VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection to client\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n#endif /* WITH_SSL_SUPPORT */\n\n  /*Speak to our client*/\n  if(protocol->greeting(client_io, GREETING_ADD_NODENAME)){\n    VANESSA_LOGGER_DEBUG(\"greeting\");\n    VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error writing to client %s.\"\n\t\t\t      \"Exiting child.\", from_to_host_str);\n    perdition_exit_cleanly(-1);\n  }\n\n  /* Authenticate the user*/\n  for(;;){\n    /*Read the USER and PASS lines from the client */\n    status = (*(protocol->in_get_auth))(client_io, opt.ssl_mode, tls_state,\n\t\t\t\t\t&auth, &client_tag);\n    token_flush();\n    if(status<0){\n      VANESSA_LOGGER_DEBUG(\"protocol->in_get_auth\");\n      if (io_get_err(client_io) == io_err_timeout)\n\tVANESSA_LOGGER_ERR_UNSAFE(\"Fatal Error: Timeout reading \"\n\t\t\t\t  \"authentication information from \"\n\t\t\t\t  \"client%s: Exiting child\",\n\t\t\t\t  from_to_host_str);\n      else\n\tVANESSA_LOGGER_ERR_UNSAFE(\"Fatal Error reading authentication \"\n\t\t\t\t  \"information from client%s: \"\n\t\t\t\t  \"Exiting child\", from_to_host_str);\n      perdition_exit_cleanly(-1);\n    }\n    else if(status == 1){\n      perdition_log_close_early(from_to_host_str, &auth);\n      perdition_exit_cleanly(0);\n    }\n#ifdef WITH_SSL_SUPPORT\n    else if((status == 2) && (opt.ssl_mode & SSL_MODE_TLS_LISTEN)){\n      /* We have received a STLS */\n      client_io = perdition_ssl_server_connection(client_io, ssl_ctx);\n      if(!client_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_server_connection TLS\");\n\tVANESSA_LOGGER_ERR(\"Fatal error establishing TLS connection\");\n        perdition_exit_cleanly(-1);\n      }\n      tls_state |= SSL_MODE_TLS_LISTEN;\n      continue;\n    }\n    else if(opt.login_disabled ||\n\t\t    ((status == 0) && (opt.ssl_mode & SSL_MODE_TLS_LISTEN) &&\n\t\t    (opt.ssl_mode & SSL_MODE_TLS_LISTEN_FORCE) &&\n\t\t    !(tls_state & SSL_MODE_TLS_LISTEN))) {\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"Login Disabled\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n#endif /* WITH_SSL_SUPPORT */\n\n    {\n    char *id;\n    id = username_mangle(auth_get_authorisation_id(&auth), STATE_GET_SERVER);\n    if (!id) {\n      VANESSA_LOGGER_DEBUG(\"username_mangle STATE_GET_SERVER\");\n      VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error manipulating username \"\n\t\t\t\t\"for client \\\"%s\\\": Exiting child\",\n\t\t\t\tfrom_host_str);\n      perdition_exit_cleanly(-1);\n    }\n\n    /*Read the server from the map, if we have a map*/\n    if(dbserver_get || dbserver_get2 || opt.client_server_specification) {\n\tusp = getserver(id, from_host_str, to_host_str,\n\t\t\tfrom_serv_str, to_serv_str,\n\t\t\tdbserver_get, dbserver_get2);\n    }\n\n    if (id != auth_get_authorisation_id(&auth))\n      free(id);\n    }\n\n    if(usp){\n      port = usp->port;\n      servername = usp->server;\n    \n      if(opt.username_from_database && usp->user){\n      \tchar * new_id = strdup(usp->user);\n        if (!new_id) {\n\t    VANESSA_LOGGER_DEBUG_ERRNO(\"strdup\");\n            VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error manipulating username \"\n\t\t\t\t      \"for client \\\"%s\\\": Exiting child\",\n\t\t\t\t      from_host_str);\n        }\n        free(auth_get_authorisation_id(&auth));\n\tauth_set_authorisation_id(&auth, new_id);\n      }\n    }\n\n    /*Use the default server if we have one and the servername is not set*/\n    if((!servername || !*servername || round_robin_server) && \n\t\t    opt.outgoing_server!=NULL){\n      round_robin_server=1;\n      rnd=(rnd+1)%vanessa_dynamic_array_get_count(opt.outgoing_server);\n      usp=vanessa_dynamic_array_get_element(opt.outgoing_server,rnd);\n      servername=user_server_port_get_server(usp);\n      port=user_server_port_get_port(usp);\n    }\n\n    /*Use the default port if the port is not set*/\n    if(!port || !*port) {\n      port=opt.outgoing_port;\n    }\n\n    /*Try again if we didn't get anything useful*/\n    if(!servername || !*servername) {\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_ERR, \"Could not determine server\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n\n#ifdef WITH_PAM_SUPPORT\n    if(opt.authenticate_in){\n      struct auth auth2 = auth;\n      char *id;\n\n      id = username_mangle(auth_get_authorisation_id(&auth), STATE_LOCAL_AUTH);\n      if (!id) {\n        VANESSA_LOGGER_DEBUG(\"username_mangle STATE_LOCAL_AUTH\");\n        VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error manipulating username for \"\n\t\t\t\t  \"client \\\"%s\\\": Exiting child\",\n\t\t\t\t  from_host_str);\n        perdition_exit_cleanly(-1);\n      }\n      auth_set_authorisation_id(&auth2, id);\n\n      status = protocol->in_authenticate(&auth2, client_io, client_tag);\n      if (id != auth_get_authorisation_id(&auth))\n      \tfree(id);\n      if (!status) {\n        VANESSA_LOGGER_DEBUG(\"protocol->in_authenticate\");\n        VANESSA_LOGGER_INFO(\n\t  \"Local authentication failure for client: Allowing retry.\"\n        );\n  \tPERDITION_LOG_AUTH(\"failed: local authentication failure\");\n        PERDITION_CLEAN_UP_MAIN;\n        continue;\n      }\n      else if(status<0){\n        VANESSA_LOGGER_DEBUG(\"pop3_in_authenticate\");\n        VANESSA_LOGGER_ERR(\n\t  \"Fatal error authenticating to client locally. Exiting child.\"\n        );\n        perdition_exit_cleanly(-1);\n      }\n\n      /*\n       * If local authentication is used then now is the time to\n       * Become someone else\n       */\n       PERDITION_SET_UID_AND_GID;\n    }\n#endif /* WITH_PAM_SUPPORT */\n\n    /* Talk to the real pop server for the client*/\n    flag = 0;\n    if (opt.no_lookup)\n      flag |= VANESSA_SOCKET_NO_LOOKUP;\n    if (opt.tcp_keepalive)\n      flag |= VANESSA_SOCKET_TCP_KEEPALIVE;\n    s = vanessa_socket_client_src_open(NULL, NULL, servername, port, flag);\n    if(s < 0) {\n\t    VANESSA_LOGGER_DEBUG(\"vanessa_socket_client_open\");\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_ERR, \"Could not connect to server\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n\n    if((server_io=io_create_fd(s, s, PERDITION_LOG_STR_REAL))==NULL){\n      VANESSA_LOGGER_DEBUG(\"io_create_fd 3\");\n      VANESSA_LOGGER_ERR(\"Fatal error setting IO. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n    io_set_timeout(server_io, opt.authenticate_timeout);\n\n#ifdef WITH_SSL_SUPPORT\n    if(opt.ssl_mode & SSL_MODE_SSL_OUTGOING) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_outgoing_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }\n    }\n#endif /* WITH_SSL_SUPPORT */\n\n    {\n    struct auth auth2 = auth;\n    char *id;\n    int sasl_mech = 0;\n\n    /* Authenticate the user with the pop server */\n    id = username_mangle(auth_get_authorisation_id(&auth), STATE_REMOTE_LOGIN);\n    if (!id) {\n      VANESSA_LOGGER_DEBUG(\"username_mangle STATE_REMOTE_LOGIN\");\n      VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error manipulating username \"\n\t\t\t\t\"for client \\\"%s\\\": Exiting child\",\n\t\t\t\tfrom_host_str);\n      perdition_exit_cleanly(-1);\n    }\n    auth_set_authorisation_id(&auth2, id);\n\n    status = (*(protocol->out_setup))(server_io, client_io, &auth2, our_tag);\n    sasl_mech = status & PROTOCOL_S_SASL_MASK;\n    if(status==0){\n\t    quit(server_io, protocol, our_tag);\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"Connection Negotiation Failure\");\n\t    if (id != auth_get_authorisation_id(&auth))\n\t      free(id);\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n    else if(status<0){\n      VANESSA_LOGGER_DEBUG_UNSAFE(\"protocol->out_setup %d\", status);\n      VANESSA_LOGGER_ERR(\"Fatal error negotiating setup. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n\n#ifdef WITH_SSL_SUPPORT\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n          (status & PROTOCOL_S_STARTTLS)) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_listen_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }\n      tls_state |= SSL_MODE_TLS_OUTGOING;\n    }\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n\t\t    (opt.ssl_mode & SSL_MODE_TLS_OUTGOING_FORCE) &&\n\t\t    !(status & PROTOCOL_S_STARTTLS)) {\n\t    quit(server_io, protocol, our_tag);\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"TLS not present\");\n\t    if (id != auth_get_authorisation_id(&auth))\n\t        free(id);\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n#endif /* WITH_SSL_SUPPORT */\n\n    if(opt.server_resp_line){\n      server_resp_buf_size=MAX_LINE_LENGTH-1;\n    }\n    token_flush();\n    status = (*(protocol->out_authenticate))(server_io, client_io, tls_state,\n\t\t\t\t\t     &auth2, sasl_mech, our_tag,\n\t\t\t\t\t     protocol, server_resp_buf,\n\t\t\t\t\t     &server_resp_buf_size);\n    if (id != auth_get_authorisation_id(&auth))\n        free(id);\n    if(status==0) {\n\t    quit(server_io, protocol, our_tag);\n            if(opt.server_resp_line){\n              sleep(PERDITION_AUTH_FAIL_SLEEP);\n              *(server_resp_buf+server_resp_buf_size)='\\0';\n              if (protocol->write_str(client_io, WRITE_STR_NO_CLLF, client_tag,\n\t\t\t\t      NULL, server_resp_buf) < 0) {\n                VANESSA_LOGGER_DEBUG(\"protocol->write_str quit\");\n                VANESSA_LOGGER_ERR(\"Fatal error writing to client. Exiting child.\");\n                perdition_exit_cleanly(-1);\n              }\n              PERDITION_LOG_AUTH(\"failed: Re-Authentication Failure\");\n            }\n            else\n              LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"Re-Authentication Failure\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n    if(status==2){\n\t    sleep(VANESSA_LOGGER_ERR_SLEEP);\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"Login Disabled\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n    if (status==3) {\n\t    sleep(VANESSA_LOGGER_ERR_SLEEP);\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"SASL mechanism unavailable\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n    else if(status<0){\n      VANESSA_LOGGER_DEBUG_UNSAFE(\"protocol->out_authenticate %d\", status);\n      if (io_get_err(client_io) == io_err_timeout)\n\tVANESSA_LOGGER_ERR(\"Fatal error: Timeout authenticating user. \"\n\t\t\t   \"Exiting child.\");\n      else\n        VANESSA_LOGGER_ERR(\"Fatal error authenticating user. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n\n    if(opt.server_resp_line){\n      *(server_resp_buf+server_resp_buf_size)='\\0';\n      if (protocol->write_str(client_io, WRITE_STR_NO_CLLF, client_tag,\n\t\t\t      NULL, server_resp_buf) < 0) {\n        VANESSA_LOGGER_DEBUG(\"protocol->write_str logged in, server_resp\");\n        VANESSA_LOGGER_ERR(\"Fatal error writing to client. Exiting child.\");\n        perdition_exit_cleanly(-1);\n      }\n    }\n    else{\n      if (protocol->write_str(client_io, NULL_FLAG, client_tag,\n\t\t\t      protocol->type[PROTOCOL_OK], opt.ok_line) < 0) {\n        VANESSA_LOGGER_DEBUG(\"protocol->write_str logged in\");\n        VANESSA_LOGGER_ERR(\"Fatal error writing to client. Exiting child.\");\n        perdition_exit_cleanly(-1);\n      }\n    }\n    }\n\n    break;\n  }\n\n  PERDITION_LOG_AUTH(\"ok\");\n\n  if(opt.server_resp_line){\n     free(server_resp_buf);\n  }\n\n  /*We need a buffer for reads and writes to the server*/\n  buffer = malloc(BUFFER_SIZE);\n  if (!buffer) {\n    VANESSA_LOGGER_DEBUG_ERRNO(\"malloc\");\n    VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting child.\");\n    perdition_exit_cleanly(-1);\n  }\n\n  /*Let the client talk to the real server*/\n  io_set_timeout(client_io, opt.timeout);\n  io_set_timeout(server_io, opt.timeout);\n  if(io_pipe(server_io, client_io, buffer, BUFFER_SIZE,\n        &bytes_written, &bytes_read, &auth_log)<0){\n    if (io_get_err(client_io) == io_err_timeout) {\n      VANESSA_LOGGER_INFO(\"Timeout piping data.\");\n      if (protocol->bye && protocol->bye(client_io, \"Timeout\") < 0) {\n        VANESSA_LOGGER_DEBUG(\"protocol->bye timeout\");\n        VANESSA_LOGGER_ERR(\"Fatal error writing to client. Exiting child.\");\n        perdition_exit_cleanly(-1);\n      }\n    } else {\n      VANESSA_LOGGER_DEBUG(\"vanessa_socket_pipe\");\n      VANESSA_LOGGER_ERR(\"Fatal error piping data. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n\n  /*Time to leave*/\n  perdition_log_close(from_to_host_str, &auth, bytes_read, bytes_written);\n  set_proc_title(\"%s: close (%s)\", progname,\n\t\t str_null_safe(auth_get_authorisation_id(&auth)));\n\n  getserver_closelib(handle);\n  perdition_exit_cleanly(0);\n\n  /*Here so compilers won't barf*/\n  return(0);\n}",
        "func": "int main (int argc, char **argv, char **envp){\n  STRUCT_AUTH(auth);\n  char *server_resp_buf = NULL;\n  char *buffer;\n  user_server_port_t *usp=NULL;\n  protocol_t *protocol=NULL;\n  token_t *our_tag=NULL;\n  token_t *client_tag=NULL;\n  size_t server_resp_buf_size=0;\n  flag_t tls_state = 0;\n  timed_log_t auth_log;\n  char from_to_host_str[((NI_MAXHOST+NI_MAXSERV)*2)+2];\n  char from_host_str[NI_MAXHOST];\n  char to_host_str[NI_MAXHOST];\n  char from_serv_str[NI_MAXSERV];\n  char to_serv_str[NI_MAXSERV];\n  char *servername=NULL;\n  char *port=NULL;\n  io_t *client_io=NULL;\n  io_t *server_io=NULL;\n  FILE *fh;\n  size_t bytes_written = 0;\n  size_t bytes_read = 0;\n  int status;\n  int round_robin_server=0;\n  int rnd;\n  int s=-1;\n  int *g = NULL;\n  int rc;\n  int flag;\n\n#ifdef WITH_SSL_SUPPORT\n  SSL_CTX *ssl_ctx=NULL;\n#endif /* WITH_SSL_SUPPORT */\n\n  /* Create Logger */\n  progname = argv[0];\n  logger_init();\n\n  /*Parse options*/\n  options(argc, argv, OPT_FIRST_CALL);\n\n  /*Read config file*/\n  if(opt.config_file!=NULL){\n    config_file_to_opt(opt.config_file);\n  }\n\n  /* Initialise setting of proctitle */\n  init_set_proc_title(argc, argv, envp);\n  progname = strdup(get_progname(argv[0]));\n  if (!progname) {\n\t  VANESSA_LOGGER_DEBUG_ERRNO(\"strdup\");\n\t  VANESSA_LOGGER_ERR(\"Error initialising process title\\n\");\n\t  perdition_exit_cleanly(-1);\n  }\n  set_proc_title(\"%s: daemon\", progname);\n\n  /* Update Logger */\n  if (!opt.debug)\n    vanessa_logger_change_max_priority(vanessa_logger_get(),\n\t\t\t\t       opt.quiet?LOG_ERR:LOG_INFO);\n\n  /*Open the dbserver_get library, if we have a library*/\n  if(getserver_openlib(opt.map_library, opt.map_library_opt,\n        &handle, &dbserver_get, &dbserver_get2)<0){\n    VANESSA_LOGGER_ERR_UNSAFE(\"dlopen of \\\"%s\\\" failed\", \n    str_null_safe(opt.map_library));\n    usage(-1);\n    perdition_exit_cleanly(-1);\n  }\n\n  /*Set signal handlers*/\n  signal(SIGHUP,    perdition_reread_handler);\n  signal(SIGINT,    perdition_exit_cleanly);\n  signal(SIGQUIT,   perdition_exit_cleanly);\n  signal(SIGILL,    perdition_exit_cleanly);\n  signal(SIGTRAP,   perdition_exit_cleanly);\n  signal(SIGIOT,    perdition_exit_cleanly);\n  signal(SIGBUS,    perdition_exit_cleanly);\n  signal(SIGFPE,    perdition_exit_cleanly);\n  signal(SIGUSR1,   vanessa_socket_handler_noop);\n  signal(SIGSEGV,   perdition_exit_cleanly);\n  signal(SIGUSR2,   vanessa_socket_handler_noop);\n  signal(SIGPIPE,   SIG_IGN);\n  signal(SIGALRM,   perdition_exit_cleanly);\n  signal(SIGTERM,   perdition_exit_cleanly);\n  signal(SIGCHLD,   vanessa_socket_handler_reaper);\n  signal(SIGURG,    perdition_exit_cleanly);\n  signal(SIGXCPU,   perdition_exit_cleanly);\n  signal(SIGXFSZ,   perdition_exit_cleanly);\n  signal(SIGVTALRM, perdition_exit_cleanly);\n  signal(SIGPROF,   perdition_exit_cleanly);\n  signal(SIGWINCH,  perdition_exit_cleanly);\n  signal(SIGIO,     perdition_exit_cleanly);\n\n  /* Set file descriptor to log to, if any */\n  fh = NULL;\n  if(opt.log_facility!=NULL) {\n    if(*(opt.log_facility) == '-') {\n      fh = stdout;\n    }\n    else if(*(opt.log_facility) == '+') {\n      fh = stderr;\n    }\n  }\n\n  /*\n   * Re-create logger now process is detached (unless in inetd mode)\n   * and configuration file has been read.\n   */\n  logger_reopen(fh);\n\n  /*Seed the uname structure*/\n  if((system_uname=(struct utsname *)malloc(sizeof(struct utsname)))==NULL){\n    VANESSA_LOGGER_DEBUG_ERRNO(\"malloc system_uname\");\n    VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n  if(uname(system_uname)<0){\n    VANESSA_LOGGER_DEBUG(\"uname\");\n    VANESSA_LOGGER_ERR(\"Fatal error finding uname for system. Exiting\");\n    perdition_exit_cleanly(-1);\n  }\n\n  /*Set up protocol structure*/\n  if((protocol=protocol_initialise(opt.protocol, protocol))==NULL){\n    VANESSA_LOGGER_DEBUG(\"protocol_initialise\");\n    VANESSA_LOGGER_ERR(\"Fatal error initialising protocol. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n\n  /*Set listen and outgoing port now the protocol structure is accessable*/\n  if((opt.listen_port=protocol->port(opt.listen_port))==NULL){\n    VANESSA_LOGGER_DEBUG(\"protocol->port 1\");\n    VANESSA_LOGGER_ERR(\"Fatal error finding port to listen on. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n  if((opt.outgoing_port=protocol->port(opt.outgoing_port))==NULL){\n    VANESSA_LOGGER_DEBUG(\"protocol->port 2\");\n    VANESSA_LOGGER_ERR(\"Fatal error finding port to connect to. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n\n  /* \n   * Set up a tag to use. \n   * Only used for IMAP based protocols, but it is harmless to have it\n   * lying about\n   */\n  if(opt.protocol == PROTOCOL_IMAP4 || opt.protocol == PROTOCOL_IMAP4S) {\n  \tour_tag = imap4_tag_create();\n  \tif(!our_tag) {\n\t  \tVANESSA_LOGGER_DEBUG(\"imap4_tag_create\");\n\t  \tVANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n\t  \tperdition_exit_cleanly(-1);\n  \t}\n  }\n  else {\n\t  our_tag = NULL;\n  }\n\n  /*\n   * Log the options we will be running with.\n   * If we are in inetd mode then only do this if debugging is turned on,\n   * else debugging is a bit too verbose.\n   */\n  if ((!opt.quiet && !opt.inetd_mode && !opt.no_daemon && !fh) || opt.debug) {\n    if (log_options()) {\n      VANESSA_LOGGER_DEBUG(\"log_options\");\n      VANESSA_LOGGER_ERR(\"Fatal error logging options. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n\n#ifdef WITH_SSL_SUPPORT\n  /*Set up the ssl mode */\n  opt.ssl_mode=protocol->encryption(opt.ssl_mode);\n\n  if(opt.ssl_mode & SSL_LISTEN_MASK) {\n    ssl_ctx = perdition_ssl_ctx(opt.ssl_ca_file, opt.ssl_ca_path,\n\t\t\t\topt.ssl_cert_file, opt.ssl_key_file,\n\t\t\t\topt.ssl_ca_chain_file, opt.ssl_listen_ciphers,\n\t\t\t\tPERDITION_SSL_SERVER);\n    if(!ssl_ctx) {\n      PERDITION_DEBUG_SSL_ERR(\"perdition_ssl_ctx\");\n      VANESSA_LOGGER_ERR(\"Fatal error establishing SSL context for listening\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n#endif /* WITH_SSL_SUPPORT */\n\n  /* Close file descriptors and detach process from shell as necessary */\n  if (opt.inetd_mode || opt.no_daemon || fh != NULL)\n    vanessa_socket_daemon_inetd_process();\n  else {\n    vanessa_socket_daemon_process();\n    if (vanessa_logger_reopen(vanessa_logger_get()) < 0) {\n      fprintf(stderr, \"Fatal error reopening logger. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n\n  /* Create PID file */\n  if (!opt.inetd_mode && opt.pid_file && *opt.pid_file) {\n  \tif(write_pid_file(opt.pid_file, opt.username, opt.group) < 0) {\n\t\tVANESSA_LOGGER_DEBUG(\"write_pid_file\");\n\t\tVANESSA_LOGGER_ERR(\"Could not write pid file\");\n\t\tperdition_exit_cleanly(1);\n\t}\n\tpid_file = opt.pid_file;\n  }\n\n  /*\n   * If we are using the server's ok line then allocate a buffer to store it\n   */ \n  if(opt.server_resp_line){\n    server_resp_buf = malloc(MAX_LINE_LENGTH);\n    if (!server_resp_buf) {\n      VANESSA_LOGGER_DEBUG_ERRNO(\"malloc server_resp_buf\");\n      VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n\n  /*\n   * Allocate the peername and sockname structures\n   */\n  sockname = malloc(sizeof(*sockname));\n  if (!sockname) {\n    VANESSA_LOGGER_DEBUG_ERRNO(\"malloc sockname\");\n    VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n  peername = malloc(sizeof(*peername));\n  if (!peername) {\n    VANESSA_LOGGER_DEBUG_ERRNO(\"malloc peername\");\n    VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n    perdition_exit_cleanly(-1);\n  }\n  \n\n  /* Open incoming socket as required */\n  if(!opt.inetd_mode) {\n\t  size_t nfrom;\n\t  const char **fromv;\n\t  \n  \t  if (opt.bind_address) \n\t\t  nfrom = vanessa_dynamic_array_get_count(opt.bind_address);\n\t  else \n\t\t  nfrom = 1;\n\t  \n\t  fromv = malloc(sizeof(*fromv) * ((nfrom * 2) + 1));\n\t  if (!fromv) {\n\t\t  VANESSA_LOGGER_DEBUG_ERRNO(\"malloc fromv\");\n\t\t  VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting.\");\n\t\t  perdition_exit_cleanly(-1);\n\t  }\n\t  \n  \t  if (opt.bind_address) {\n\t\t  size_t i;\n\t\t  user_server_port_t *from_usp;\n\t\t  for (i = 0; i < nfrom; i++) {\n\t\t\t  from_usp = vanessa_dynamic_array_get_element(\n\t\t\t\t\t\topt.bind_address, i);\n\t\t\t  fromv[i * 2] = user_server_port_get_server(from_usp);\n\t\t\t  fromv[(i * 2) + 1] = user_server_port_get_port(\n\t\t\t  \t\t\tfrom_usp);\n\t\t\t  if (!fromv[(i * 2) + 1])\n\t\t\t\t  fromv[(i * 2) + 1] = opt.listen_port;\n\t\t  }\n\t  }\n\t  else {\n\t  \t  fromv[0] = \"0.0.0.0\";\n\t  \t  fromv[1] = opt.listen_port;\n\t  }\n\t  fromv[nfrom * 2] = NULL;\n\t  flag = 0;\n    \t  if (opt.no_lookup)\n\t    \tflag |= VANESSA_SOCKET_NO_LOOKUP;\n    \t  if (opt.tcp_keepalive)\n\t    \tflag |= VANESSA_SOCKET_TCP_KEEPALIVE;\n\t  g = vanessa_socket_server_bindv(fromv, flag);\n\t  free(fromv);\n\t  if(!g) {\n\t\t  VANESSA_LOGGER_DEBUG(\"vanessa_socket_server_bindv\");\n\t\t  VANESSA_LOGGER_ERR(\"Fatal error listening for connections.\"\n\t\t\t\t     \"Exiting.\");\n\t\t  perdition_exit_cleanly(-1);\n\t  }\n  }\n\n  /*\n   * Become someone else\n   * NB: We do this later if we are going to authenticate locally \n   */\n#ifdef WITH_PAM_SUPPORT\n  if(opt.authenticate_in) {\n    if(geteuid()){\n      VANESSA_LOGGER_INFO(\"Warning: not invoked as root, \"\n\t\t      \"local authentication may fail\");\n    }\n  }\n  else\n#endif\n    PERDITION_SET_UID_AND_GID;\n\n  /* Get an incoming connection */\n  if(opt.inetd_mode){\n    socklen_t namelen;\n\n    if((client_io=io_create_fd(0, 1, PERDITION_LOG_STR_CLIENT))==NULL){\n      VANESSA_LOGGER_DEBUG(\"io_create_fd 1\");\n      VANESSA_LOGGER_ERR(\"Fatal error setting IO. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n    io_set_timeout(client_io, opt.authenticate_timeout);\n\n    namelen = sizeof(*peername);\n    if (getpeername(0, (struct sockaddr *)peername, &namelen)) {\n      free(peername);\n      peername=NULL;\n    }\n\n    namelen = sizeof(*sockname);\n    if (getsockname(1, (struct sockaddr *)sockname, &namelen)) {\n      free(sockname);\n      sockname=NULL;\n    }\n  }\n  else{\n    flag = 0;\n    if (opt.tcp_keepalive)\n      flag |= VANESSA_SOCKET_TCP_KEEPALIVE;\n    s = vanessa_socket_server_acceptv(g, opt.connection_limit,\n\t\t\t\t      (struct sockaddr *) peername,\n\t\t\t\t      (struct sockaddr *) sockname, flag);\n    if(s < 0){\n      VANESSA_LOGGER_DEBUG(\"vanessa_socket_server_accept\");\n      VANESSA_LOGGER_ERR(\"Fatal error accepting child connection. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n\n    /* Child processes don't clean up the pid file */\n    pid_file = NULL;\n\n    /* Reopen the logger, the child gets its own FDs */\n    vanessa_logger_reopen(vanessa_logger_get());\n\n    if((client_io=io_create_fd(s, s, PERDITION_LOG_STR_CLIENT))==NULL){\n      VANESSA_LOGGER_DEBUG(\"io_create_fd 2\");\n      VANESSA_LOGGER_ERR(\"Fatal error setting IO. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n    io_set_timeout(client_io, opt.authenticate_timeout);\n  }\n\n  /* A child process, or process handling an inetd connection\n   * should exit on receipt of a SIG PIPE.\n   */\n  signal(SIGPIPE,   perdition_exit_cleanly);\n\n  /* Get the source and destination ip address as a string */\n  if (peername!=NULL) {\n    rc = getnameinfo((struct sockaddr *)peername,\n\t\t     perdition_get_salen((struct sockaddr *)peername),\n\t\t     from_host_str, NI_MAXHOST, from_serv_str, NI_MAXSERV,\n\t\t     NI_NUMERICHOST|NI_NUMERICSERV);\n    if (rc) {\n        VANESSA_LOGGER_DEBUG_UNSAFE(\"getnameinfo peername: %s\",\n\t\t\t\t    gai_strerror(rc));\n\tVANESSA_LOGGER_ERR(\"Fatal error formatting peername\");\n\tperdition_exit_cleanly(-1);\n    }\n  }\n  else {\n    *from_host_str='\\0';\n    *from_serv_str='\\0';\n  }\n  if (sockname!=NULL) {\n    rc = getnameinfo((struct sockaddr *)sockname,\n\t\t     perdition_get_salen((struct sockaddr *)sockname),\n\t\t     to_host_str, NI_MAXHOST, to_serv_str, NI_MAXSERV,\n\t\t     NI_NUMERICHOST|NI_NUMERICSERV);\n    if (rc) {\n        VANESSA_LOGGER_DEBUG_UNSAFE(\"getnameinfo sockname: %s\",\n\t\t\t\t    gai_strerror(rc));\n\tVANESSA_LOGGER_ERR(\"Fatal error formatting sockname\");\n\tperdition_exit_cleanly(-1);\n    }\n  }\n  else {\n    *to_host_str='\\0';\n    *to_serv_str='\\0';\n  }\n  *from_to_host_str='\\0';\n  if(peername!=NULL && sockname!=NULL){\n    strcat(from_to_host_str, \" \");\n    strcat(from_to_host_str, from_host_str);\n    strcat(from_to_host_str, \":\");\n    strcat(from_to_host_str, from_serv_str);\n    strcat(from_to_host_str, \"->\");\n    strcat(from_to_host_str, to_host_str);\n    strcat(from_to_host_str, \":\");\n    strcat(from_to_host_str, to_serv_str);\n  }\n\n  /*Seed rand*/\n  srand(time(NULL)*getpid());\n  rnd=rand();\n\n  /*Log the session and change the proctitle*/\n  if(opt.inetd_mode) {\n    VANESSA_LOGGER_INFO_UNSAFE(\"Connect: %s inetd_pid=%d\",\n          from_to_host_str, getppid());\n  }\n  else {\n    VANESSA_LOGGER_INFO_UNSAFE(\"Connect: %s\", from_to_host_str);\n  }\n  set_proc_title(\"%s: connect (%s)\", progname, from_to_host_str);\n\n#ifdef WITH_SSL_SUPPORT\n  if(opt.ssl_mode & SSL_MODE_SSL_LISTEN) {\n    client_io = perdition_ssl_server_connection(client_io, ssl_ctx);\n    if(!client_io) {\n      VANESSA_LOGGER_DEBUG(\"perdition_ssl_server_connection SSL\");\n      VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection to client\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n#endif /* WITH_SSL_SUPPORT */\n\n  /*Speak to our client*/\n  if(protocol->greeting(client_io, GREETING_ADD_NODENAME)){\n    VANESSA_LOGGER_DEBUG(\"greeting\");\n    VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error writing to client %s.\"\n\t\t\t      \"Exiting child.\", from_to_host_str);\n    perdition_exit_cleanly(-1);\n  }\n\n  /* Authenticate the user*/\n  for(;;){\n    /*Read the USER and PASS lines from the client */\n    status = (*(protocol->in_get_auth))(client_io, opt.ssl_mode, tls_state,\n\t\t\t\t\t&auth, &client_tag);\n    token_flush();\n    if(status<0){\n      VANESSA_LOGGER_DEBUG(\"protocol->in_get_auth\");\n      if (io_get_err(client_io) == io_err_timeout)\n\tVANESSA_LOGGER_ERR_UNSAFE(\"Fatal Error: Timeout reading \"\n\t\t\t\t  \"authentication information from \"\n\t\t\t\t  \"client%s: Exiting child\",\n\t\t\t\t  from_to_host_str);\n      else\n\tVANESSA_LOGGER_ERR_UNSAFE(\"Fatal Error reading authentication \"\n\t\t\t\t  \"information from client%s: \"\n\t\t\t\t  \"Exiting child\", from_to_host_str);\n      perdition_exit_cleanly(-1);\n    }\n    else if(status == 1){\n      perdition_log_close_early(from_to_host_str, &auth);\n      perdition_exit_cleanly(0);\n    }\n#ifdef WITH_SSL_SUPPORT\n    else if((status == 2) && (opt.ssl_mode & SSL_MODE_TLS_LISTEN)){\n      /* We have received a STLS */\n      client_io = perdition_ssl_server_connection(client_io, ssl_ctx);\n      if(!client_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_server_connection TLS\");\n\tVANESSA_LOGGER_ERR(\"Fatal error establishing TLS connection\");\n        perdition_exit_cleanly(-1);\n      }\n      tls_state |= SSL_MODE_TLS_LISTEN;\n      continue;\n    }\n    else if(opt.login_disabled ||\n\t\t    ((status == 0) && (opt.ssl_mode & SSL_MODE_TLS_LISTEN) &&\n\t\t    (opt.ssl_mode & SSL_MODE_TLS_LISTEN_FORCE) &&\n\t\t    !(tls_state & SSL_MODE_TLS_LISTEN))) {\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"Login Disabled\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n#endif /* WITH_SSL_SUPPORT */\n\n    {\n    char *id;\n    id = username_mangle(auth_get_authorisation_id(&auth), STATE_GET_SERVER);\n    if (!id) {\n      VANESSA_LOGGER_DEBUG(\"username_mangle STATE_GET_SERVER\");\n      VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error manipulating username \"\n\t\t\t\t\"for client \\\"%s\\\": Exiting child\",\n\t\t\t\tfrom_host_str);\n      perdition_exit_cleanly(-1);\n    }\n\n    /*Read the server from the map, if we have a map*/\n    if(dbserver_get || dbserver_get2 || opt.client_server_specification) {\n\tusp = getserver(id, from_host_str, to_host_str,\n\t\t\tfrom_serv_str, to_serv_str,\n\t\t\tdbserver_get, dbserver_get2);\n    }\n\n    if (id != auth_get_authorisation_id(&auth))\n      free(id);\n    }\n\n    if(usp){\n      port = usp->port;\n      servername = usp->server;\n    \n      if(opt.username_from_database && usp->user){\n      \tchar * new_id = strdup(usp->user);\n        if (!new_id) {\n\t    VANESSA_LOGGER_DEBUG_ERRNO(\"strdup\");\n            VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error manipulating username \"\n\t\t\t\t      \"for client \\\"%s\\\": Exiting child\",\n\t\t\t\t      from_host_str);\n        }\n        free(auth_get_authorisation_id(&auth));\n\tauth_set_authorisation_id(&auth, new_id);\n      }\n    }\n\n    /*Use the default server if we have one and the servername is not set*/\n    if((!servername || !*servername || round_robin_server) && \n\t\t    opt.outgoing_server!=NULL){\n      round_robin_server=1;\n      rnd=(rnd+1)%vanessa_dynamic_array_get_count(opt.outgoing_server);\n      usp=vanessa_dynamic_array_get_element(opt.outgoing_server,rnd);\n      servername=user_server_port_get_server(usp);\n      port=user_server_port_get_port(usp);\n    }\n\n    /*Use the default port if the port is not set*/\n    if(!port || !*port) {\n      port=opt.outgoing_port;\n    }\n\n    /*Try again if we didn't get anything useful*/\n    if(!servername || !*servername) {\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_ERR, \"Could not determine server\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n\n#ifdef WITH_PAM_SUPPORT\n    if(opt.authenticate_in){\n      struct auth auth2 = auth;\n      char *id;\n\n      id = username_mangle(auth_get_authorisation_id(&auth), STATE_LOCAL_AUTH);\n      if (!id) {\n        VANESSA_LOGGER_DEBUG(\"username_mangle STATE_LOCAL_AUTH\");\n        VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error manipulating username for \"\n\t\t\t\t  \"client \\\"%s\\\": Exiting child\",\n\t\t\t\t  from_host_str);\n        perdition_exit_cleanly(-1);\n      }\n      auth_set_authorisation_id(&auth2, id);\n\n      status = protocol->in_authenticate(&auth2, client_io, client_tag);\n      if (id != auth_get_authorisation_id(&auth))\n      \tfree(id);\n      if (!status) {\n        VANESSA_LOGGER_DEBUG(\"protocol->in_authenticate\");\n        VANESSA_LOGGER_INFO(\n\t  \"Local authentication failure for client: Allowing retry.\"\n        );\n  \tPERDITION_LOG_AUTH(\"failed: local authentication failure\");\n        PERDITION_CLEAN_UP_MAIN;\n        continue;\n      }\n      else if(status<0){\n        VANESSA_LOGGER_DEBUG(\"pop3_in_authenticate\");\n        VANESSA_LOGGER_ERR(\n\t  \"Fatal error authenticating to client locally. Exiting child.\"\n        );\n        perdition_exit_cleanly(-1);\n      }\n\n      /*\n       * If local authentication is used then now is the time to\n       * Become someone else\n       */\n       PERDITION_SET_UID_AND_GID;\n    }\n#endif /* WITH_PAM_SUPPORT */\n\n    /* Talk to the real pop server for the client*/\n    flag = 0;\n    if (opt.no_lookup)\n      flag |= VANESSA_SOCKET_NO_LOOKUP;\n    if (opt.tcp_keepalive)\n      flag |= VANESSA_SOCKET_TCP_KEEPALIVE;\n    s = vanessa_socket_client_src_open(NULL, NULL, servername, port, flag);\n    if(s < 0) {\n\t    VANESSA_LOGGER_DEBUG(\"vanessa_socket_client_open\");\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_ERR, \"Could not connect to server\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n\n    if((server_io=io_create_fd(s, s, PERDITION_LOG_STR_REAL))==NULL){\n      VANESSA_LOGGER_DEBUG(\"io_create_fd 3\");\n      VANESSA_LOGGER_ERR(\"Fatal error setting IO. Exiting.\");\n      perdition_exit_cleanly(-1);\n    }\n    io_set_timeout(server_io, opt.authenticate_timeout);\n\n#ifdef WITH_SSL_SUPPORT\n    if(opt.ssl_mode & SSL_MODE_SSL_OUTGOING) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_outgoing_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }\n    }\n#endif /* WITH_SSL_SUPPORT */\n\n    {\n    struct auth auth2 = auth;\n    char *id;\n    int sasl_mech = 0;\n\n    /* Authenticate the user with the pop server */\n    id = username_mangle(auth_get_authorisation_id(&auth), STATE_REMOTE_LOGIN);\n    if (!id) {\n      VANESSA_LOGGER_DEBUG(\"username_mangle STATE_REMOTE_LOGIN\");\n      VANESSA_LOGGER_ERR_UNSAFE(\"Fatal error manipulating username \"\n\t\t\t\t\"for client \\\"%s\\\": Exiting child\",\n\t\t\t\tfrom_host_str);\n      perdition_exit_cleanly(-1);\n    }\n    auth_set_authorisation_id(&auth2, id);\n\n    status = (*(protocol->out_setup))(server_io, client_io, &auth2, our_tag);\n    sasl_mech = status & PROTOCOL_S_SASL_MASK;\n    if(status==0){\n\t    quit(server_io, protocol, our_tag);\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"Connection Negotiation Failure\");\n\t    if (id != auth_get_authorisation_id(&auth))\n\t      free(id);\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n    else if(status<0){\n      VANESSA_LOGGER_DEBUG_UNSAFE(\"protocol->out_setup %d\", status);\n      VANESSA_LOGGER_ERR(\"Fatal error negotiating setup. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n\n#ifdef WITH_SSL_SUPPORT\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n          (status & PROTOCOL_S_STARTTLS)) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_outgoing_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }\n      tls_state |= SSL_MODE_TLS_OUTGOING;\n    }\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n\t\t    (opt.ssl_mode & SSL_MODE_TLS_OUTGOING_FORCE) &&\n\t\t    !(status & PROTOCOL_S_STARTTLS)) {\n\t    quit(server_io, protocol, our_tag);\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"TLS not present\");\n\t    if (id != auth_get_authorisation_id(&auth))\n\t        free(id);\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n#endif /* WITH_SSL_SUPPORT */\n\n    if(opt.server_resp_line){\n      server_resp_buf_size=MAX_LINE_LENGTH-1;\n    }\n    token_flush();\n    status = (*(protocol->out_authenticate))(server_io, client_io, tls_state,\n\t\t\t\t\t     &auth2, sasl_mech, our_tag,\n\t\t\t\t\t     protocol, server_resp_buf,\n\t\t\t\t\t     &server_resp_buf_size);\n    if (id != auth_get_authorisation_id(&auth))\n        free(id);\n    if(status==0) {\n\t    quit(server_io, protocol, our_tag);\n            if(opt.server_resp_line){\n              sleep(PERDITION_AUTH_FAIL_SLEEP);\n              *(server_resp_buf+server_resp_buf_size)='\\0';\n              if (protocol->write_str(client_io, WRITE_STR_NO_CLLF, client_tag,\n\t\t\t\t      NULL, server_resp_buf) < 0) {\n                VANESSA_LOGGER_DEBUG(\"protocol->write_str quit\");\n                VANESSA_LOGGER_ERR(\"Fatal error writing to client. Exiting child.\");\n                perdition_exit_cleanly(-1);\n              }\n              PERDITION_LOG_AUTH(\"failed: Re-Authentication Failure\");\n            }\n            else\n              LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"Re-Authentication Failure\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n    if(status==2){\n\t    sleep(VANESSA_LOGGER_ERR_SLEEP);\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"Login Disabled\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n    if (status==3) {\n\t    sleep(VANESSA_LOGGER_ERR_SLEEP);\n\t    LOGIN_FAILED_PROTOCOL(PROTOCOL_NO, \"SASL mechanism unavailable\");\n\t    PERDITION_CLEAN_UP_MAIN;\n\t    continue;\n    }\n    else if(status<0){\n      VANESSA_LOGGER_DEBUG_UNSAFE(\"protocol->out_authenticate %d\", status);\n      if (io_get_err(client_io) == io_err_timeout)\n\tVANESSA_LOGGER_ERR(\"Fatal error: Timeout authenticating user. \"\n\t\t\t   \"Exiting child.\");\n      else\n        VANESSA_LOGGER_ERR(\"Fatal error authenticating user. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n\n    if(opt.server_resp_line){\n      *(server_resp_buf+server_resp_buf_size)='\\0';\n      if (protocol->write_str(client_io, WRITE_STR_NO_CLLF, client_tag,\n\t\t\t      NULL, server_resp_buf) < 0) {\n        VANESSA_LOGGER_DEBUG(\"protocol->write_str logged in, server_resp\");\n        VANESSA_LOGGER_ERR(\"Fatal error writing to client. Exiting child.\");\n        perdition_exit_cleanly(-1);\n      }\n    }\n    else{\n      if (protocol->write_str(client_io, NULL_FLAG, client_tag,\n\t\t\t      protocol->type[PROTOCOL_OK], opt.ok_line) < 0) {\n        VANESSA_LOGGER_DEBUG(\"protocol->write_str logged in\");\n        VANESSA_LOGGER_ERR(\"Fatal error writing to client. Exiting child.\");\n        perdition_exit_cleanly(-1);\n      }\n    }\n    }\n\n    break;\n  }\n\n  PERDITION_LOG_AUTH(\"ok\");\n\n  if(opt.server_resp_line){\n     free(server_resp_buf);\n  }\n\n  /*We need a buffer for reads and writes to the server*/\n  buffer = malloc(BUFFER_SIZE);\n  if (!buffer) {\n    VANESSA_LOGGER_DEBUG_ERRNO(\"malloc\");\n    VANESSA_LOGGER_ERR(\"Fatal error allocating memory. Exiting child.\");\n    perdition_exit_cleanly(-1);\n  }\n\n  /*Let the client talk to the real server*/\n  io_set_timeout(client_io, opt.timeout);\n  io_set_timeout(server_io, opt.timeout);\n  if(io_pipe(server_io, client_io, buffer, BUFFER_SIZE,\n        &bytes_written, &bytes_read, &auth_log)<0){\n    if (io_get_err(client_io) == io_err_timeout) {\n      VANESSA_LOGGER_INFO(\"Timeout piping data.\");\n      if (protocol->bye && protocol->bye(client_io, \"Timeout\") < 0) {\n        VANESSA_LOGGER_DEBUG(\"protocol->bye timeout\");\n        VANESSA_LOGGER_ERR(\"Fatal error writing to client. Exiting child.\");\n        perdition_exit_cleanly(-1);\n      }\n    } else {\n      VANESSA_LOGGER_DEBUG(\"vanessa_socket_pipe\");\n      VANESSA_LOGGER_ERR(\"Fatal error piping data. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n  }\n\n  /*Time to leave*/\n  perdition_log_close(from_to_host_str, &auth, bytes_read, bytes_written);\n  set_proc_title(\"%s: close (%s)\", progname,\n\t\t str_null_safe(auth_get_authorisation_id(&auth)));\n\n  getserver_closelib(handle);\n  perdition_exit_cleanly(0);\n\n  /*Here so compilers won't barf*/\n  return(0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -654,7 +654,7 @@\n     else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n           (status & PROTOCOL_S_STARTTLS)) {\n       server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n-\t\t      opt.ssl_ca_path, opt.ssl_listen_ciphers, servername);\n+\t\t      opt.ssl_ca_path, opt.ssl_outgoing_ciphers, servername);\n       if(!server_io) {\n         VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n         VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t      opt.ssl_ca_path, opt.ssl_listen_ciphers, servername);"
            ],
            "added_lines": [
                "\t\t      opt.ssl_ca_path, opt.ssl_outgoing_ciphers, servername);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11472",
        "func_name": "torvalds/linux/acpi_ns_terminate",
        "description": "The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
        "git_url": "https://github.com/torvalds/linux/commit/3b2d69114fefa474fca542e51119036dceb4aa6f",
        "commit_title": "ACPICA: Namespace: fix operand cache leak",
        "commit_text": " ACPICA commit a23325b2e583556eae88ed3f764e457786bf4df6  I found some ACPI operand cache leaks in ACPI early abort cases.  Boot log of ACPI operand cache leak is as follows: >[    0.174332] ACPI: Added _OSI(Module Device) >[    0.175504] ACPI: Added _OSI(Processor Device) >[    0.176010] ACPI: Added _OSI(3.0 _SCP Extensions) >[    0.177032] ACPI: Added _OSI(Processor Aggregator Device) >[    0.178284] ACPI: SCI (IRQ16705) allocation failed >[    0.179352] ACPI Exception: AE_NOT_ACQUIRED, Unable to install System Control Interrupt handler (20160930/evevent-131) >[    0.180008] ACPI: Unable to start the ACPI Interpreter >[    0.181125] ACPI Error: Could not remove SCI handler (20160930/evmisc-281) >[    0.184068] kmem_cache_destroy Acpi-Operand: Slab cache still has objects >[    0.185358] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.10.0-rc3 #2 >[    0.186820] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS virtual_box 12/01/2006 >[    0.188000] Call Trace: >[    0.188000]  ? dump_stack+0x5c/0x7d >[    0.188000]  ? kmem_cache_destroy+0x224/0x230 >[    0.188000]  ? acpi_sleep_proc_init+0x22/0x22 >[    0.188000]  ? acpi_os_delete_cache+0xa/0xd >[    0.188000]  ? acpi_ut_delete_caches+0x3f/0x7b >[    0.188000]  ? acpi_terminate+0x5/0xf >[    0.188000]  ? acpi_init+0x288/0x32e >[    0.188000]  ? __class_create+0x4c/0x80 >[    0.188000]  ? video_setup+0x7a/0x7a >[    0.188000]  ? do_one_initcall+0x4e/0x1b0 >[    0.188000]  ? kernel_init_freeable+0x194/0x21a >[    0.188000]  ? rest_init+0x80/0x80 >[    0.188000]  ? kernel_init+0xa/0x100 >[    0.188000]  ? ret_from_fork+0x25/0x30  When early abort is occurred due to invalid ACPI information, Linux kernel terminates ACPI by calling acpi_terminate() function. The function calls acpi_ns_terminate() function to delete namespace data and ACPI operand cache (acpi_gbl_module_code_list).  But the deletion code in acpi_ns_terminate() function is wrapped in ACPI_EXEC_APP definition, therefore the code is only executed when the definition exists. If the define doesn't exist, ACPI operand cache (acpi_gbl_module_code_list) is leaked, and stack dump is shown in kernel log.  This causes a security threat because the old kernel (<= 4.9) shows memory locations of kernel functions in stack dump, therefore kernel ASLR can be neutralized.  To fix ACPI operand leak for enhancing security, I made a patch which removes the ACPI_EXEC_APP define in acpi_ns_terminate() function for executing the deletion code unconditionally.  Link: https://github.com/acpica/acpica/commit/a23325b2",
        "func_before": "void acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n\n\t\t/* Delete any module-level code blocks */\n\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * Free the entire namespace -- all nodes and all objects\n\t * attached to the nodes\n\t */\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\n\t/* Delete any objects attached to the root node */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}",
        "func": "void acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *prev;\n\tunion acpi_operand_object *next;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n\t/* Delete any module-level code blocks */\n\n\tnext = acpi_gbl_module_code_list;\n\twhile (next) {\n\t\tprev = next;\n\t\tnext = next->method.mutex;\n\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */\n\t\tacpi_ut_remove_reference(prev);\n\t}\n\n\t/*\n\t * Free the entire namespace -- all nodes and all objects\n\t * attached to the nodes\n\t */\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\n\t/* Delete any objects attached to the root node */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,25 +1,20 @@\n void acpi_ns_terminate(void)\n {\n \tacpi_status status;\n+\tunion acpi_operand_object *prev;\n+\tunion acpi_operand_object *next;\n \n \tACPI_FUNCTION_TRACE(ns_terminate);\n \n-#ifdef ACPI_EXEC_APP\n-\t{\n-\t\tunion acpi_operand_object *prev;\n-\t\tunion acpi_operand_object *next;\n+\t/* Delete any module-level code blocks */\n \n-\t\t/* Delete any module-level code blocks */\n-\n-\t\tnext = acpi_gbl_module_code_list;\n-\t\twhile (next) {\n-\t\t\tprev = next;\n-\t\t\tnext = next->method.mutex;\n-\t\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */\n-\t\t\tacpi_ut_remove_reference(prev);\n-\t\t}\n+\tnext = acpi_gbl_module_code_list;\n+\twhile (next) {\n+\t\tprev = next;\n+\t\tnext = next->method.mutex;\n+\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */\n+\t\tacpi_ut_remove_reference(prev);\n \t}\n-#endif\n \n \t/*\n \t * Free the entire namespace -- all nodes and all objects",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef ACPI_EXEC_APP",
                "\t{",
                "\t\tunion acpi_operand_object *prev;",
                "\t\tunion acpi_operand_object *next;",
                "\t\t/* Delete any module-level code blocks */",
                "",
                "\t\tnext = acpi_gbl_module_code_list;",
                "\t\twhile (next) {",
                "\t\t\tprev = next;",
                "\t\t\tnext = next->method.mutex;",
                "\t\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */",
                "\t\t\tacpi_ut_remove_reference(prev);",
                "\t\t}",
                "#endif"
            ],
            "added_lines": [
                "\tunion acpi_operand_object *prev;",
                "\tunion acpi_operand_object *next;",
                "\t/* Delete any module-level code blocks */",
                "\tnext = acpi_gbl_module_code_list;",
                "\twhile (next) {",
                "\t\tprev = next;",
                "\t\tnext = next->method.mutex;",
                "\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */",
                "\t\tacpi_ut_remove_reference(prev);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11472",
        "func_name": "acpica/AcpiNsTerminate",
        "description": "The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",
        "git_url": "https://github.com/acpica/acpica/commit/a23325b2e583556eae88ed3f764e457786bf4df6",
        "commit_title": "Namespace: fix operand cache leak",
        "commit_text": " I found some ACPI operand cache leaks in ACPI early abort cases.  Boot log of ACPI operand cache leak is as follows: >[    0.174332] ACPI: Added _OSI(Module Device) >[    0.175504] ACPI: Added _OSI(Processor Device) >[    0.176010] ACPI: Added _OSI(3.0 _SCP Extensions) >[    0.177032] ACPI: Added _OSI(Processor Aggregator Device) >[    0.178284] ACPI: SCI (IRQ16705) allocation failed >[    0.179352] ACPI Exception: AE_NOT_ACQUIRED, Unable to install System Control Interrupt handler (20160930/evevent-131) >[    0.180008] ACPI: Unable to start the ACPI Interpreter >[    0.181125] ACPI Error: Could not remove SCI handler (20160930/evmisc-281) >[    0.184068] kmem_cache_destroy Acpi-Operand: Slab cache still has objects >[    0.185358] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.10.0-rc3 #2 >[    0.186820] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006 >[    0.188000] Call Trace: >[    0.188000]  ? dump_stack+0x5c/0x7d >[    0.188000]  ? kmem_cache_destroy+0x224/0x230 >[    0.188000]  ? acpi_sleep_proc_init+0x22/0x22 >[    0.188000]  ? acpi_os_delete_cache+0xa/0xd >[    0.188000]  ? acpi_ut_delete_caches+0x3f/0x7b >[    0.188000]  ? acpi_terminate+0x5/0xf >[    0.188000]  ? acpi_init+0x288/0x32e >[    0.188000]  ? __class_create+0x4c/0x80 >[    0.188000]  ? video_setup+0x7a/0x7a >[    0.188000]  ? do_one_initcall+0x4e/0x1b0 >[    0.188000]  ? kernel_init_freeable+0x194/0x21a >[    0.188000]  ? rest_init+0x80/0x80 >[    0.188000]  ? kernel_init+0xa/0x100 >[    0.188000]  ? ret_from_fork+0x25/0x30  When early abort is occurred due to invalid ACPI information, Linux kernel terminates ACPI by calling AcpiTerminate() function. The function calls AcpiNsTerminate() function to delete namespace data and ACPI operand cache (AcpiGbl_ModuleCodeList).  But the deletion code in AcpiNsTerminate() function is wrapped in ACPI_EXEC_APP definition, therefore the code is only executed when the definition exists. If the define doesn't exist, ACPI operand cache (AcpiGbl_ModuleCodeList) is leaked, and stack dump is shown in kernel log.  This causes a security threat because the old kernel (<= 4.9) shows memory locations of kernel functions in stack dump, therefore kernel ASLR can be neutralized.  To fix ACPI operand leak for enhancing security, I made a patch which removes the ACPI_EXEC_APP define in AcpiNsTerminate() function for executing the deletion code unconditionally. ",
        "func_before": "void\nAcpiNsTerminate (\n    void)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsTerminate);\n\n\n#ifdef ACPI_EXEC_APP\n    {\n        ACPI_OPERAND_OBJECT     *Prev;\n        ACPI_OPERAND_OBJECT     *Next;\n\n        /* Delete any module-level code blocks */\n\n        Next = AcpiGbl_ModuleCodeList;\n        while (Next)\n        {\n            Prev = Next;\n            Next = Next->Method.Mutex;\n            Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */\n            AcpiUtRemoveReference (Prev);\n        }\n    }\n#endif\n\n    /*\n     * Free the entire namespace -- all nodes and all objects\n     * attached to the nodes\n     */\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n\n    /* Delete any objects attached to the root node */\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}",
        "func": "void\nAcpiNsTerminate (\n    void)\n{\n    ACPI_STATUS             Status;\n    ACPI_OPERAND_OBJECT     *Prev;\n    ACPI_OPERAND_OBJECT     *Next;\n\n\n    ACPI_FUNCTION_TRACE (NsTerminate);\n\n\n    /* Delete any module-level code blocks */\n\n    Next = AcpiGbl_ModuleCodeList;\n    while (Next)\n    {\n        Prev = Next;\n        Next = Next->Method.Mutex;\n        Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */\n        AcpiUtRemoveReference (Prev);\n    }\n\n    /*\n     * Free the entire namespace -- all nodes and all objects\n     * attached to the nodes\n     */\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n\n    /* Delete any objects attached to the root node */\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,28 +3,23 @@\n     void)\n {\n     ACPI_STATUS             Status;\n+    ACPI_OPERAND_OBJECT     *Prev;\n+    ACPI_OPERAND_OBJECT     *Next;\n \n \n     ACPI_FUNCTION_TRACE (NsTerminate);\n \n \n-#ifdef ACPI_EXEC_APP\n+    /* Delete any module-level code blocks */\n+\n+    Next = AcpiGbl_ModuleCodeList;\n+    while (Next)\n     {\n-        ACPI_OPERAND_OBJECT     *Prev;\n-        ACPI_OPERAND_OBJECT     *Next;\n-\n-        /* Delete any module-level code blocks */\n-\n-        Next = AcpiGbl_ModuleCodeList;\n-        while (Next)\n-        {\n-            Prev = Next;\n-            Next = Next->Method.Mutex;\n-            Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */\n-            AcpiUtRemoveReference (Prev);\n-        }\n+        Prev = Next;\n+        Next = Next->Method.Mutex;\n+        Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */\n+        AcpiUtRemoveReference (Prev);\n     }\n-#endif\n \n     /*\n      * Free the entire namespace -- all nodes and all objects",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef ACPI_EXEC_APP",
                "        ACPI_OPERAND_OBJECT     *Prev;",
                "        ACPI_OPERAND_OBJECT     *Next;",
                "",
                "        /* Delete any module-level code blocks */",
                "",
                "        Next = AcpiGbl_ModuleCodeList;",
                "        while (Next)",
                "        {",
                "            Prev = Next;",
                "            Next = Next->Method.Mutex;",
                "            Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */",
                "            AcpiUtRemoveReference (Prev);",
                "        }",
                "#endif"
            ],
            "added_lines": [
                "    ACPI_OPERAND_OBJECT     *Prev;",
                "    ACPI_OPERAND_OBJECT     *Next;",
                "    /* Delete any module-level code blocks */",
                "",
                "    Next = AcpiGbl_ModuleCodeList;",
                "    while (Next)",
                "        Prev = Next;",
                "        Next = Next->Method.Mutex;",
                "        Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */",
                "        AcpiUtRemoveReference (Prev);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-50019",
        "func_name": "open5gs/gmm_state_authentication",
        "description": "An issue was discovered in open5gs v2.6.6. InitialUEMessage, Registration request sent at a specific time can crash AMF due to incorrect error handling of Nudm_UECM_Registration response.",
        "git_url": "https://github.com/open5gs/open5gs/commit/7278714133422cee46c32c7523f81ec2cecad9e2",
        "commit_title": "[AMF] Fixed Nudm_UECM_Registration crash (#2733)",
        "commit_text": " 1. UE sends RegistrationRequest to AMF. 2. AMF sends Nudm_UECM_Registration to UDM. 3. UE sends RegistrationRequest to AMF. 4. GMM state is gmm_state_authentication 5. UDM sends Nudm_UECM_Registration response to AMF. 6. AMF crashs since no Handler in gmm_state_authentication state",
        "func_before": "void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)\n{\n    int r, rv;\n    ogs_nas_5gmm_cause_t gmm_cause;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_nas_5gs_message_t *nas_message = NULL;\n    ogs_nas_security_header_type_t h;\n\n    ogs_nas_5gs_authentication_failure_t *authentication_failure = NULL;\n    ogs_nas_authentication_failure_parameter_t\n        *authentication_failure_parameter = NULL;\n\n    ogs_sbi_message_t *sbi_message = NULL;\n\n    ogs_assert(s);\n    ogs_assert(e);\n\n    amf_sm_debug(e);\n\n    if (e->sess) {\n        sess = e->sess;\n        amf_ue = sess->amf_ue;\n        ogs_assert(amf_ue);\n    } else {\n        amf_ue = e->amf_ue;\n        ogs_assert(amf_ue);\n    }\n\n    switch (e->h.id) {\n    case OGS_FSM_ENTRY_SIG:\n        break;\n    case OGS_FSM_EXIT_SIG:\n        break;\n    case AMF_EVENT_5GMM_MESSAGE:\n        nas_message = e->nas.message;\n        ogs_assert(nas_message);\n\n        h.type = e->nas.type;\n\n        switch (nas_message->gmm.h.message_type) {\n        case OGS_NAS_5GS_AUTHENTICATION_RESPONSE:\n            rv = gmm_handle_authentication_response(\n                    amf_ue, &nas_message->gmm.authentication_response);\n\n            if (rv != OGS_OK) {\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            }\n            break;\n\n        case OGS_NAS_5GS_AUTHENTICATION_FAILURE:\n            authentication_failure = &nas_message->gmm.authentication_failure;\n            ogs_assert(authentication_failure);\n            authentication_failure_parameter = &authentication_failure->\n                authentication_failure_parameter;\n            ogs_assert(authentication_failure_parameter);\n\n            ogs_debug(\"[%s] Authentication failure [%d]\", amf_ue->suci,\n                    authentication_failure->gmm_cause);\n\n            amf_metrics_inst_by_cause_add(authentication_failure->gmm_cause,\n                    AMF_METR_CTR_AMF_AUTH_FAIL, 1);\n\n            CLEAR_AMF_UE_TIMER(amf_ue->t3560);\n\n            switch (authentication_failure->gmm_cause) {\n            case OGS_5GMM_CAUSE_MAC_FAILURE:\n                ogs_warn(\"Authentication failure(MAC failure)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NON_5G_AUTHENTICATION_UNACCEPTABLE:\n                ogs_error(\"Authentication failure\"\n                        \"(Non-5GS authentication unacceptable)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NGKSI_ALREADY_IN_USE:\n                ogs_warn(\"Authentication failure(ngKSI already in use)\");\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, NULL);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            case OGS_5GMM_CAUSE_SYNCH_FAILURE:\n                ogs_warn(\"Authentication failure(Synch failure)\");\n                if (authentication_failure_parameter->length != OGS_AUTS_LEN) {\n                    ogs_error(\"Invalid AUTS Length [%d]\",\n                            authentication_failure_parameter->length);\n                    break;\n                }\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, authentication_failure_parameter->auts);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            default:\n                ogs_error(\"Unknown GMM_CAUSE{%d] in Authentication\"\n                        \" failure\",\n                        authentication_failure->gmm_cause);\n                break;\n            }\n\n            r = nas_5gs_send_authentication_reject(amf_ue);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n\n            break;\n        case OGS_NAS_5GS_REGISTRATION_REQUEST:\n            ogs_warn(\"Registration request\");\n            gmm_cause = gmm_handle_registration_request(\n                    amf_ue, h, e->ngap.code,\n                    &nas_message->gmm.registration_request);\n            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                ogs_error(\"[%s] gmm_handle_registration_request() failed [%d]\",\n                            amf_ue->suci, gmm_cause);\n                r = nas_5gs_send_registration_reject(amf_ue, gmm_cause);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(s, gmm_state_exception);\n                break;\n            }\n\n            r = amf_ue_sbi_discover_and_send(\n                    OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                    amf_nausf_auth_build_authenticate, amf_ue, 0, NULL);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            break;\n\n        case OGS_NAS_5GS_5GMM_STATUS:\n            ogs_warn(\"[%s] 5GMM STATUS : Cause[%d]\",\n                    amf_ue->suci, nas_message->gmm.gmm_status.gmm_cause);\n            OGS_FSM_TRAN(s, &gmm_state_exception);\n            break;\n\n        case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:\n            ogs_warn(\"[%s] Deregistration request\", amf_ue->supi);\n\n            gmm_handle_deregistration_request(\n                    amf_ue, &nas_message->gmm.deregistration_request_from_ue);\n            OGS_FSM_TRAN(s, &gmm_state_de_registered);\n            break;\n\n        default:\n            ogs_error(\"Unknown message[%d]\", nas_message->gmm.h.message_type);\n            break;\n        }\n        break;\n    case AMF_EVENT_5GMM_TIMER:\n        switch (e->h.timer_id) {\n        case AMF_TIMER_T3560:\n            if (amf_ue->t3560.retry_count >=\n                    amf_timer_cfg(AMF_TIMER_T3560)->max_count) {\n                ogs_warn(\"[%s] Retransmission failed. Stop retransmission\",\n                        amf_ue->suci);\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            } else {\n                amf_ue->t3560.retry_count++;\n                r = nas_5gs_send_authentication_request(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n            }\n            break;\n        default:\n            ogs_error(\"[%s] Unknown timer[%s:%d]\", amf_ue->suci,\n                    amf_timer_get_name(e->h.timer_id), e->h.timer_id);\n            break;\n        }\n        break;\n    case OGS_EVENT_SBI_CLIENT:\n        sbi_message = e->h.sbi.message;\n        ogs_assert(sbi_message);\n\n        SWITCH(sbi_message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n\n                if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                    if (sbi_message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NOT_FOUND) {\n                        ogs_warn(\"[%s] Cannot find SUCI [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    } else {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    }\n                    r = nas_5gs_send_gmm_reject_from_sbi(\n                            amf_ue, sbi_message->res_status);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                    OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    break;\n                }\n\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    rv = amf_nausf_auth_handle_authenticate(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    rv = amf_nausf_auth_handle_authenticate_confirmation(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    } else {\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);\n                    }\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        DEFAULT\n            ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n            ogs_assert_if_reached();\n        END\n        break;\n\n    default:\n        ogs_error(\"Unknown event[%s]\", amf_event_get_name(e));\n        break;\n    }\n}",
        "func": "void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)\n{\n    int r, rv;\n    ogs_nas_5gmm_cause_t gmm_cause;\n\n    amf_ue_t *amf_ue = NULL;\n    amf_sess_t *sess = NULL;\n\n    ogs_nas_5gs_message_t *nas_message = NULL;\n    ogs_nas_security_header_type_t h;\n\n    ogs_nas_5gs_authentication_failure_t *authentication_failure = NULL;\n    ogs_nas_authentication_failure_parameter_t\n        *authentication_failure_parameter = NULL;\n\n    ogs_sbi_message_t *sbi_message = NULL;\n\n    ogs_assert(s);\n    ogs_assert(e);\n\n    amf_sm_debug(e);\n\n    if (e->sess) {\n        sess = e->sess;\n        amf_ue = sess->amf_ue;\n        ogs_assert(amf_ue);\n    } else {\n        amf_ue = e->amf_ue;\n        ogs_assert(amf_ue);\n    }\n\n    switch (e->h.id) {\n    case OGS_FSM_ENTRY_SIG:\n        break;\n    case OGS_FSM_EXIT_SIG:\n        break;\n    case AMF_EVENT_5GMM_MESSAGE:\n        nas_message = e->nas.message;\n        ogs_assert(nas_message);\n\n        h.type = e->nas.type;\n\n        switch (nas_message->gmm.h.message_type) {\n        case OGS_NAS_5GS_AUTHENTICATION_RESPONSE:\n            rv = gmm_handle_authentication_response(\n                    amf_ue, &nas_message->gmm.authentication_response);\n\n            if (rv != OGS_OK) {\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            }\n            break;\n\n        case OGS_NAS_5GS_AUTHENTICATION_FAILURE:\n            authentication_failure = &nas_message->gmm.authentication_failure;\n            ogs_assert(authentication_failure);\n            authentication_failure_parameter = &authentication_failure->\n                authentication_failure_parameter;\n            ogs_assert(authentication_failure_parameter);\n\n            ogs_debug(\"[%s] Authentication failure [%d]\", amf_ue->suci,\n                    authentication_failure->gmm_cause);\n\n            amf_metrics_inst_by_cause_add(authentication_failure->gmm_cause,\n                    AMF_METR_CTR_AMF_AUTH_FAIL, 1);\n\n            CLEAR_AMF_UE_TIMER(amf_ue->t3560);\n\n            switch (authentication_failure->gmm_cause) {\n            case OGS_5GMM_CAUSE_MAC_FAILURE:\n                ogs_warn(\"Authentication failure(MAC failure)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NON_5G_AUTHENTICATION_UNACCEPTABLE:\n                ogs_error(\"Authentication failure\"\n                        \"(Non-5GS authentication unacceptable)\");\n                break;\n\n            case OGS_5GMM_CAUSE_NGKSI_ALREADY_IN_USE:\n                ogs_warn(\"Authentication failure(ngKSI already in use)\");\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, NULL);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            case OGS_5GMM_CAUSE_SYNCH_FAILURE:\n                ogs_warn(\"Authentication failure(Synch failure)\");\n                if (authentication_failure_parameter->length != OGS_AUTS_LEN) {\n                    ogs_error(\"Invalid AUTS Length [%d]\",\n                            authentication_failure_parameter->length);\n                    break;\n                }\n                r = amf_ue_sbi_discover_and_send(\n                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                        amf_nausf_auth_build_authenticate,\n                        amf_ue, 0, authentication_failure_parameter->auts);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                return;\n\n            default:\n                ogs_error(\"Unknown GMM_CAUSE{%d] in Authentication\"\n                        \" failure\",\n                        authentication_failure->gmm_cause);\n                break;\n            }\n\n            r = nas_5gs_send_authentication_reject(amf_ue);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n\n            break;\n        case OGS_NAS_5GS_REGISTRATION_REQUEST:\n            ogs_warn(\"Registration request\");\n            gmm_cause = gmm_handle_registration_request(\n                    amf_ue, h, e->ngap.code,\n                    &nas_message->gmm.registration_request);\n            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {\n                ogs_error(\"[%s] gmm_handle_registration_request() failed [%d]\",\n                            amf_ue->suci, gmm_cause);\n                r = nas_5gs_send_registration_reject(amf_ue, gmm_cause);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(s, gmm_state_exception);\n                break;\n            }\n\n            r = amf_ue_sbi_discover_and_send(\n                    OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,\n                    amf_nausf_auth_build_authenticate, amf_ue, 0, NULL);\n            ogs_expect(r == OGS_OK);\n            ogs_assert(r != OGS_ERROR);\n            break;\n\n        case OGS_NAS_5GS_5GMM_STATUS:\n            ogs_warn(\"[%s] 5GMM STATUS : Cause[%d]\",\n                    amf_ue->suci, nas_message->gmm.gmm_status.gmm_cause);\n            OGS_FSM_TRAN(s, &gmm_state_exception);\n            break;\n\n        case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:\n            ogs_warn(\"[%s] Deregistration request\", amf_ue->supi);\n\n            gmm_handle_deregistration_request(\n                    amf_ue, &nas_message->gmm.deregistration_request_from_ue);\n            OGS_FSM_TRAN(s, &gmm_state_de_registered);\n            break;\n\n        default:\n            ogs_error(\"Unknown message[%d]\", nas_message->gmm.h.message_type);\n            break;\n        }\n        break;\n    case AMF_EVENT_5GMM_TIMER:\n        switch (e->h.timer_id) {\n        case AMF_TIMER_T3560:\n            if (amf_ue->t3560.retry_count >=\n                    amf_timer_cfg(AMF_TIMER_T3560)->max_count) {\n                ogs_warn(\"[%s] Retransmission failed. Stop retransmission\",\n                        amf_ue->suci);\n                r = nas_5gs_send_authentication_reject(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n            } else {\n                amf_ue->t3560.retry_count++;\n                r = nas_5gs_send_authentication_request(amf_ue);\n                ogs_expect(r == OGS_OK);\n                ogs_assert(r != OGS_ERROR);\n            }\n            break;\n        default:\n            ogs_error(\"[%s] Unknown timer[%s:%d]\", amf_ue->suci,\n                    amf_timer_get_name(e->h.timer_id), e->h.timer_id);\n            break;\n        }\n        break;\n    case OGS_EVENT_SBI_CLIENT:\n        sbi_message = e->h.sbi.message;\n        ogs_assert(sbi_message);\n\n        SWITCH(sbi_message->h.service.name)\n        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)\n            SWITCH(sbi_message->h.resource.component[0])\n            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)\n\n                if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                    if (sbi_message->res_status ==\n                            OGS_SBI_HTTP_STATUS_NOT_FOUND) {\n                        ogs_warn(\"[%s] Cannot find SUCI [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    } else {\n                        ogs_error(\"[%s] HTTP response error [%d]\",\n                            amf_ue->suci, sbi_message->res_status);\n                    }\n                    r = nas_5gs_send_gmm_reject_from_sbi(\n                            amf_ue, sbi_message->res_status);\n                    ogs_expect(r == OGS_OK);\n                    ogs_assert(r != OGS_ERROR);\n                    OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    break;\n                }\n\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_POST)\n                    rv = amf_nausf_auth_handle_authenticate(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    }\n                    break;\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    rv = amf_nausf_auth_handle_authenticate_confirmation(\n                            amf_ue, sbi_message);\n                    if (rv != OGS_OK) {\n                        ogs_error(\"[%s] Cannot handle SBI message\",\n                                amf_ue->suci);\n                        r = nas_5gs_send_authentication_reject(amf_ue);\n                        ogs_expect(r == OGS_OK);\n                        ogs_assert(r != OGS_ERROR);\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);\n                    } else {\n                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);\n                    }\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[0]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&\n                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n                ogs_error(\"[%s] HTTP response error [%d]\",\n                        amf_ue->supi, sbi_message->res_status);\n            }\n\n            SWITCH(sbi_message->h.resource.component[1])\n            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n                SWITCH(sbi_message->h.method)\n                CASE(OGS_SBI_HTTP_METHOD_PUT)\n                    /*\n                     * Issue #2733\n                     *\n                     * We need to ignore this message in this state.\n                     */\n                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n                    break;\n                DEFAULT\n                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n                            amf_ue->suci, sbi_message->h.method);\n                    ogs_assert_if_reached();\n                END\n                break;\n\n            DEFAULT\n                ogs_error(\"Invalid resource name [%s]\",\n                        sbi_message->h.resource.component[1]);\n                ogs_assert_if_reached();\n            END\n            break;\n\n        DEFAULT\n            ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n            ogs_assert_if_reached();\n        END\n        break;\n\n    default:\n        ogs_error(\"Unknown event[%s]\", amf_event_get_name(e));\n        break;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -249,6 +249,39 @@\n             END\n             break;\n \n+        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)\n+            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&\n+                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&\n+                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {\n+                ogs_error(\"[%s] HTTP response error [%d]\",\n+                        amf_ue->supi, sbi_message->res_status);\n+            }\n+\n+            SWITCH(sbi_message->h.resource.component[1])\n+            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)\n+                SWITCH(sbi_message->h.method)\n+                CASE(OGS_SBI_HTTP_METHOD_PUT)\n+                    /*\n+                     * Issue #2733\n+                     *\n+                     * We need to ignore this message in this state.\n+                     */\n+                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);\n+                    break;\n+                DEFAULT\n+                    ogs_error(\"[%s] Invalid HTTP method [%s]\",\n+                            amf_ue->suci, sbi_message->h.method);\n+                    ogs_assert_if_reached();\n+                END\n+                break;\n+\n+            DEFAULT\n+                ogs_error(\"Invalid resource name [%s]\",\n+                        sbi_message->h.resource.component[1]);\n+                ogs_assert_if_reached();\n+            END\n+            break;\n+\n         DEFAULT\n             ogs_error(\"Invalid service name [%s]\", sbi_message->h.service.name);\n             ogs_assert_if_reached();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)",
                "            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&",
                "                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&",
                "                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {",
                "                ogs_error(\"[%s] HTTP response error [%d]\",",
                "                        amf_ue->supi, sbi_message->res_status);",
                "            }",
                "",
                "            SWITCH(sbi_message->h.resource.component[1])",
                "            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)",
                "                SWITCH(sbi_message->h.method)",
                "                CASE(OGS_SBI_HTTP_METHOD_PUT)",
                "                    /*",
                "                     * Issue #2733",
                "                     *",
                "                     * We need to ignore this message in this state.",
                "                     */",
                "                    ogs_error(\"[%s] Ignore SBI message\", amf_ue->supi);",
                "                    break;",
                "                DEFAULT",
                "                    ogs_error(\"[%s] Invalid HTTP method [%s]\",",
                "                            amf_ue->suci, sbi_message->h.method);",
                "                    ogs_assert_if_reached();",
                "                END",
                "                break;",
                "",
                "            DEFAULT",
                "                ogs_error(\"Invalid resource name [%s]\",",
                "                        sbi_message->h.resource.component[1]);",
                "                ogs_assert_if_reached();",
                "            END",
                "            break;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2024-23325",
        "func_name": "envoyproxy/envoy/Filter::parseV2Header",
        "description": "Envoy is a high-performance edge/middle/service proxy. Envoy crashes in Proxy protocol when using an address type that isnt supported by the OS. Envoy is susceptible to crashing on a host with IPv6 disabled and a listener config with proxy protocol enabled when it receives a request where the client presents its IPv6 address.  It is valid for a client to present its IPv6 address to a target server even though the whole chain is connected via IPv4. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bacd3107455b8d387889467725eb72aa0d5b5237",
        "commit_title": "Fix crash when proxy protocol receives an address type that isn't",
        "commit_text": "supported by the operating system  Fix [CVE-2024-23325](https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26) ",
        "func_before": "bool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n        proxy_protocol_header_.emplace(\n            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        proxy_protocol_header_.emplace(WireHeader{\n            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n            std::make_shared<Network::Address::Ipv6Instance>(ra6),\n            std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}",
        "func": "bool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n              std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n              std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n              std::make_shared<Network::Address::Ipv6Instance>(ra6),\n              std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n        return true;\n      }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,11 +37,21 @@\n         la4.sin_family = AF_INET;\n         la4.sin_port = v4->dst_port;\n         la4.sin_addr.s_addr = v4->dst_addr;\n-        proxy_protocol_header_.emplace(\n-            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n-                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n-                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n-                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n+\n+        TRY_NEEDS_AUDIT_ADDRESS {\n+          // TODO(ggreenway): make this work without requiring operating system support for an\n+          // address family.\n+          proxy_protocol_header_.emplace(WireHeader{\n+              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n+              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n+              std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n+              std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n+        }\n+        END_TRY CATCH(const EnvoyException& e, {\n+          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n+          return false;\n+        });\n+\n         return true;\n       } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n         PACKED_STRUCT(struct pp_ipv6_addr {\n@@ -63,15 +73,18 @@\n         la6.sin6_port = v6->dst_port;\n         safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n \n-        proxy_protocol_header_.emplace(WireHeader{\n-            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n-            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n-            std::make_shared<Network::Address::Ipv6Instance>(ra6),\n-            std::make_shared<Network::Address::Ipv6Instance>(la6)});\n+        TRY_NEEDS_AUDIT_ADDRESS {\n+          proxy_protocol_header_.emplace(WireHeader{\n+              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n+              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n+              std::make_shared<Network::Address::Ipv6Instance>(ra6),\n+              std::make_shared<Network::Address::Ipv6Instance>(la6)});\n+        }\n+        END_TRY CATCH(const EnvoyException& e, {\n+          // TODO(ggreenway): make this work without requiring operating system support for an\n+          // address family.\n+          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n+          return false;\n+        });\n         return true;\n       }\n-    }\n-  }\n-  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n-  return false;\n-}",
        "diff_line_info": {
            "deleted_lines": [
                "        proxy_protocol_header_.emplace(",
                "            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,",
                "                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,",
                "                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),",
                "                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});",
                "        proxy_protocol_header_.emplace(WireHeader{",
                "            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,",
                "            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,",
                "            std::make_shared<Network::Address::Ipv6Instance>(ra6),",
                "            std::make_shared<Network::Address::Ipv6Instance>(la6)});",
                "    }",
                "  }",
                "  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");",
                "  return false;",
                "}"
            ],
            "added_lines": [
                "",
                "        TRY_NEEDS_AUDIT_ADDRESS {",
                "          // TODO(ggreenway): make this work without requiring operating system support for an",
                "          // address family.",
                "          proxy_protocol_header_.emplace(WireHeader{",
                "              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,",
                "              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,",
                "              std::make_shared<Network::Address::Ipv4Instance>(&ra4),",
                "              std::make_shared<Network::Address::Ipv4Instance>(&la4)});",
                "        }",
                "        END_TRY CATCH(const EnvoyException& e, {",
                "          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());",
                "          return false;",
                "        });",
                "",
                "        TRY_NEEDS_AUDIT_ADDRESS {",
                "          proxy_protocol_header_.emplace(WireHeader{",
                "              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,",
                "              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,",
                "              std::make_shared<Network::Address::Ipv6Instance>(ra6),",
                "              std::make_shared<Network::Address::Ipv6Instance>(la6)});",
                "        }",
                "        END_TRY CATCH(const EnvoyException& e, {",
                "          // TODO(ggreenway): make this work without requiring operating system support for an",
                "          // address family.",
                "          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());",
                "          return false;",
                "        });"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-23325",
        "func_name": "envoyproxy/envoy/Ipv4Instance::validateProtocolSupported",
        "description": "Envoy is a high-performance edge/middle/service proxy. Envoy crashes in Proxy protocol when using an address type that isnt supported by the OS. Envoy is susceptible to crashing on a host with IPv6 disabled and a listener config with proxy protocol enabled when it receives a request where the client presents its IPv6 address.  It is valid for a client to present its IPv6 address to a target server even though the whole chain is connected via IPv4. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bacd3107455b8d387889467725eb72aa0d5b5237",
        "commit_title": "Fix crash when proxy protocol receives an address type that isn't",
        "commit_text": "supported by the operating system  Fix [CVE-2024-23325](https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26) ",
        "func_before": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}",
        "func": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported && !force_ipv4_unsupported_for_test) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n absl::Status Ipv4Instance::validateProtocolSupported() {\n   static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n-  if (supported) {\n+  if (supported && !force_ipv4_unsupported_for_test) {\n     return absl::OkStatus();\n   }\n   return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");",
        "diff_line_info": {
            "deleted_lines": [
                "  if (supported) {"
            ],
            "added_lines": [
                "  if (supported && !force_ipv4_unsupported_for_test) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-23325",
        "func_name": "envoyproxy/envoy/Ipv6Instance::validateProtocolSupported",
        "description": "Envoy is a high-performance edge/middle/service proxy. Envoy crashes in Proxy protocol when using an address type that isnt supported by the OS. Envoy is susceptible to crashing on a host with IPv6 disabled and a listener config with proxy protocol enabled when it receives a request where the client presents its IPv6 address.  It is valid for a client to present its IPv6 address to a target server even though the whole chain is connected via IPv4. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bacd3107455b8d387889467725eb72aa0d5b5237",
        "commit_title": "Fix crash when proxy protocol receives an address type that isn't",
        "commit_text": "supported by the operating system  Fix [CVE-2024-23325](https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26) ",
        "func_before": "absl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}",
        "func": "absl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported && !force_ipv6_unsupported_for_test) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n absl::Status Ipv6Instance::validateProtocolSupported() {\n   static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n-  if (supported) {\n+  if (supported && !force_ipv6_unsupported_for_test) {\n     return absl::OkStatus();\n   }\n   return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");",
        "diff_line_info": {
            "deleted_lines": [
                "  if (supported) {"
            ],
            "added_lines": [
                "  if (supported && !force_ipv6_unsupported_for_test) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-23325",
        "func_name": "envoyproxy/envoy/Utility::getSubjectAltNames",
        "description": "Envoy is a high-performance edge/middle/service proxy. Envoy crashes in Proxy protocol when using an address type that isnt supported by the OS. Envoy is susceptible to crashing on a host with IPv6 disabled and a listener config with proxy protocol enabled when it receives a request where the client presents its IPv6 address.  It is valid for a client to present its IPv6 address to a target server even though the whole chain is connected via IPv4. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bacd3107455b8d387889467725eb72aa0d5b5237",
        "commit_title": "Fix crash when proxy protocol receives an address type that isn't",
        "commit_text": "supported by the operating system  Fix [CVE-2024-23325](https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26) ",
        "func_before": "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      subject_alt_names.push_back(generalNameAsString(san));\n    }\n  }\n  return subject_alt_names;\n}",
        "func": "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type, bool skip_unsupported) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      if (skip_unsupported) {\n        // An IP SAN for an unsupported IP version will throw an exception.\n        // TODO(ggreenway): remove this when IP address construction no longer throws.\n        TRY_NEEDS_AUDIT_ADDRESS { subject_alt_names.push_back(generalNameAsString(san)); }\n        END_TRY CATCH(const EnvoyException& e,\n                      { ENVOY_LOG_MISC(debug, \"Error reading SAN, value skipped: {}\", e.what()); });\n      } else {\n        subject_alt_names.push_back(generalNameAsString(san));\n      }\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {\n+std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type, bool skip_unsupported) {\n   std::vector<std::string> subject_alt_names;\n   bssl::UniquePtr<GENERAL_NAMES> san_names(\n       static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n@@ -7,8 +7,14 @@\n   }\n   for (const GENERAL_NAME* san : san_names.get()) {\n     if (san->type == type) {\n-      subject_alt_names.push_back(generalNameAsString(san));\n+      if (skip_unsupported) {\n+        // An IP SAN for an unsupported IP version will throw an exception.\n+        // TODO(ggreenway): remove this when IP address construction no longer throws.\n+        TRY_NEEDS_AUDIT_ADDRESS { subject_alt_names.push_back(generalNameAsString(san)); }\n+        END_TRY CATCH(const EnvoyException& e,\n+                      { ENVOY_LOG_MISC(debug, \"Error reading SAN, value skipped: {}\", e.what()); });\n+      } else {\n+        subject_alt_names.push_back(generalNameAsString(san));\n+      }\n     }\n   }\n-  return subject_alt_names;\n-}",
        "diff_line_info": {
            "deleted_lines": [
                "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {",
                "      subject_alt_names.push_back(generalNameAsString(san));",
                "  return subject_alt_names;",
                "}"
            ],
            "added_lines": [
                "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type, bool skip_unsupported) {",
                "      if (skip_unsupported) {",
                "        // An IP SAN for an unsupported IP version will throw an exception.",
                "        // TODO(ggreenway): remove this when IP address construction no longer throws.",
                "        TRY_NEEDS_AUDIT_ADDRESS { subject_alt_names.push_back(generalNameAsString(san)); }",
                "        END_TRY CATCH(const EnvoyException& e,",
                "                      { ENVOY_LOG_MISC(debug, \"Error reading SAN, value skipped: {}\", e.what()); });",
                "      } else {",
                "        subject_alt_names.push_back(generalNameAsString(san));",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-23325",
        "func_name": "envoyproxy/envoy/ConnectionInfoImplBase::ipSansPeerCertificate",
        "description": "Envoy is a high-performance edge/middle/service proxy. Envoy crashes in Proxy protocol when using an address type that isnt supported by the OS. Envoy is susceptible to crashing on a host with IPv6 disabled and a listener config with proxy protocol enabled when it receives a request where the client presents its IPv6 address.  It is valid for a client to present its IPv6 address to a target server even though the whole chain is connected via IPv4. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bacd3107455b8d387889467725eb72aa0d5b5237",
        "commit_title": "Fix crash when proxy protocol receives an address type that isn't",
        "commit_text": "supported by the operating system  Fix [CVE-2024-23325](https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26) ",
        "func_before": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_peer_certificate_;\n}",
        "func": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD, true);\n  return cached_ip_san_peer_certificate_;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,6 @@\n     ASSERT(cached_ip_san_peer_certificate_.empty());\n     return cached_ip_san_peer_certificate_;\n   }\n-  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n+  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD, true);\n   return cached_ip_san_peer_certificate_;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);"
            ],
            "added_lines": [
                "  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD, true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46928",
        "func_name": "torvalds/linux/handle_interruption",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Clear stale IIR value on instruction access rights trap\n\nWhen a trap 7 (Instruction access rights) occurs, this means the CPU\ncouldn't execute an instruction due to missing execute permissions on\nthe memory region.  In this case it seems the CPU didn't even fetched\nthe instruction from memory and thus did not store it in the cr19 (IIR)\nregister before calling the trap handler. So, the trap handler will find\nsome random old stale value in cr19.\n\nThis patch simply overwrites the stale IIR value with a constant magic\n\"bad food\" value (0xbaadf00d), in the hope people don't start to try to\nunderstand the various random IIR values in trap 7 dumps.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=e96373f0a5f484bc1e193f9951dcb3adf24bf3f7",
        "commit_title": "[ Upstream commit 484730e5862f6b872dca13840bed40fd7c60fa26 ]",
        "commit_text": " When a trap 7 (Instruction access rights) occurs, this means the CPU couldn't execute an instruction due to missing execute permissions on the memory region.  In this case it seems the CPU didn't even fetched the instruction from memory and thus did not store it in the cr19 (IIR) register before calling the trap handler. So, the trap handler will find some random old stale value in cr19.  This patch simply overwrites the stale IIR value with a constant magic \"bad food\" value (0xbaadf00d), in the hope people don't start to try to understand the various random IIR values in trap 7 dumps.  Noticed-by: John David Anglin <dave.anglin@bell.net> ",
        "func_before": "void notrace handle_interruption(int code, struct pt_regs *regs)\n{\n\tunsigned long fault_address = 0;\n\tunsigned long fault_space = 0;\n\tint si_code;\n\n\tif (code == 1)\n\t    pdc_console_restart();  /* switch back to pdc if HPMC */\n\telse\n\t    local_irq_enable();\n\n\t/* Security check:\n\t * If the priority level is still user, and the\n\t * faulting space is not equal to the active space\n\t * then the user is attempting something in a space\n\t * that does not belong to them. Kill the process.\n\t *\n\t * This is normally the situation when the user\n\t * attempts to jump into the kernel space at the\n\t * wrong offset, be it at the gateway page or a\n\t * random location.\n\t *\n\t * We cannot normally signal the process because it\n\t * could *be* on the gateway page, and processes\n\t * executing on the gateway page can't have signals\n\t * delivered.\n\t * \n\t * We merely readjust the address into the users\n\t * space, at a destination address of zero, and\n\t * allow processing to continue.\n\t */\n\tif (((unsigned long)regs->iaoq[0] & 3) &&\n\t    ((unsigned long)regs->iasq[0] != (unsigned long)regs->sr[7])) { \n\t\t/* Kill the user process later */\n\t\tregs->iaoq[0] = 0 | 3;\n\t\tregs->iaoq[1] = regs->iaoq[0] + 4;\n\t\tregs->iasq[0] = regs->iasq[1] = regs->sr[7];\n\t\tregs->gr[0] &= ~PSW_B;\n\t\treturn;\n\t}\n\t\n#if 0\n\tprintk(KERN_CRIT \"Interruption # %d\\n\", code);\n#endif\n\n\tswitch(code) {\n\n\tcase  1:\n\t\t/* High-priority machine check (HPMC) */\n\t\t\n\t\t/* set up a new led state on systems shipped with a LED State panel */\n\t\tpdc_chassis_send_status(PDC_CHASSIS_DIRECT_HPMC);\n\n\t\tparisc_terminate(\"High Priority Machine Check (HPMC)\",\n\t\t\t\tregs, code, 0);\n\t\t/* NOT REACHED */\n\t\t\n\tcase  2:\n\t\t/* Power failure interrupt */\n\t\tprintk(KERN_CRIT \"Power failure interrupt !\\n\");\n\t\treturn;\n\n\tcase  3:\n\t\t/* Recovery counter trap */\n\t\tregs->gr[0] &= ~PSW_R;\n\n#ifdef CONFIG_KPROBES\n\t\tif (parisc_kprobe_ss_handler(regs))\n\t\t\treturn;\n#endif\n\n#ifdef CONFIG_KGDB\n\t\tif (kgdb_single_step) {\n\t\t\tkgdb_handle_exception(0, SIGTRAP, 0, regs);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif (user_space(regs))\n\t\t\thandle_gdb_break(regs, TRAP_TRACE);\n\t\t/* else this must be the start of a syscall - just let it run */\n\t\treturn;\n\n\tcase  5:\n\t\t/* Low-priority machine check */\n\t\tpdc_chassis_send_status(PDC_CHASSIS_DIRECT_LPMC);\n\t\t\n\t\tflush_cache_all();\n\t\tflush_tlb_all();\n\t\tcpu_lpmc(5, regs);\n\t\treturn;\n\n\tcase  PARISC_ITLB_TRAP:\n\t\t/* Instruction TLB miss fault/Instruction page fault */\n\t\tfault_address = regs->iaoq[0];\n\t\tfault_space   = regs->iasq[0];\n\t\tbreak;\n\n\tcase  8:\n\t\t/* Illegal instruction trap */\n\t\tdie_if_kernel(\"Illegal instruction\", regs, code);\n\t\tsi_code = ILL_ILLOPC;\n\t\tgoto give_sigill;\n\n\tcase  9:\n\t\t/* Break instruction trap */\n\t\thandle_break(regs);\n\t\treturn;\n\n\tcase 10:\n\t\t/* Privileged operation trap */\n\t\tdie_if_kernel(\"Privileged operation\", regs, code);\n\t\tsi_code = ILL_PRVOPC;\n\t\tgoto give_sigill;\n\n\tcase 11:\n\t\t/* Privileged register trap */\n\t\tif ((regs->iir & 0xffdfffe0) == 0x034008a0) {\n\n\t\t\t/* This is a MFCTL cr26/cr27 to gr instruction.\n\t\t\t * PCXS traps on this, so we need to emulate it.\n\t\t\t */\n\n\t\t\tif (regs->iir & 0x00200000)\n\t\t\t\tregs->gr[regs->iir & 0x1f] = mfctl(27);\n\t\t\telse\n\t\t\t\tregs->gr[regs->iir & 0x1f] = mfctl(26);\n\n\t\t\tregs->iaoq[0] = regs->iaoq[1];\n\t\t\tregs->iaoq[1] += 4;\n\t\t\tregs->iasq[0] = regs->iasq[1];\n\t\t\treturn;\n\t\t}\n\n\t\tdie_if_kernel(\"Privileged register usage\", regs, code);\n\t\tsi_code = ILL_PRVREG;\n\tgive_sigill:\n\t\tforce_sig_fault(SIGILL, si_code,\n\t\t\t\t(void __user *) regs->iaoq[0]);\n\t\treturn;\n\n\tcase 12:\n\t\t/* Overflow Trap, let the userland signal handler do the cleanup */\n\t\tforce_sig_fault(SIGFPE, FPE_INTOVF,\n\t\t\t\t(void __user *) regs->iaoq[0]);\n\t\treturn;\n\t\t\n\tcase 13:\n\t\t/* Conditional Trap\n\t\t   The condition succeeds in an instruction which traps\n\t\t   on condition  */\n\t\tif(user_mode(regs)){\n\t\t\t/* Let userspace app figure it out from the insn pointed\n\t\t\t * to by si_addr.\n\t\t\t */\n\t\t\tforce_sig_fault(SIGFPE, FPE_CONDTRAP,\n\t\t\t\t\t(void __user *) regs->iaoq[0]);\n\t\t\treturn;\n\t\t} \n\t\t/* The kernel doesn't want to handle condition codes */\n\t\tbreak;\n\t\t\n\tcase 14:\n\t\t/* Assist Exception Trap, i.e. floating point exception. */\n\t\tdie_if_kernel(\"Floating point exception\", regs, 0); /* quiet */\n\t\t__inc_irq_stat(irq_fpassist_count);\n\t\thandle_fpe(regs);\n\t\treturn;\n\n\tcase 15:\n\t\t/* Data TLB miss fault/Data page fault */\n\t\tfallthrough;\n\tcase 16:\n\t\t/* Non-access instruction TLB miss fault */\n\t\t/* The instruction TLB entry needed for the target address of the FIC\n\t\t   is absent, and hardware can't find it, so we get to cleanup */\n\t\tfallthrough;\n\tcase 17:\n\t\t/* Non-access data TLB miss fault/Non-access data page fault */\n\t\t/* FIXME: \n\t\t\t Still need to add slow path emulation code here!\n\t\t\t If the insn used a non-shadow register, then the tlb\n\t\t\t handlers could not have their side-effect (e.g. probe\n\t\t\t writing to a target register) emulated since rfir would\n\t\t\t erase the changes to said register. Instead we have to\n\t\t\t setup everything, call this function we are in, and emulate\n\t\t\t by hand. Technically we need to emulate:\n\t\t\t fdc,fdce,pdc,\"fic,4f\",prober,probeir,probew, probeiw\n\t\t*/\n\t\tfault_address = regs->ior;\n\t\tfault_space = regs->isr;\n\t\tbreak;\n\n\tcase 18:\n\t\t/* PCXS only -- later cpu's split this into types 26,27 & 28 */\n\t\t/* Check for unaligned access */\n\t\tif (check_unaligned(regs)) {\n\t\t\thandle_unaligned(regs);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase 26: \n\t\t/* PCXL: Data memory access rights trap */\n\t\tfault_address = regs->ior;\n\t\tfault_space   = regs->isr;\n\t\tbreak;\n\n\tcase 19:\n\t\t/* Data memory break trap */\n\t\tregs->gr[0] |= PSW_X; /* So we can single-step over the trap */\n\t\tfallthrough;\n\tcase 21:\n\t\t/* Page reference trap */\n\t\thandle_gdb_break(regs, TRAP_HWBKPT);\n\t\treturn;\n\n\tcase 25:\n\t\t/* Taken branch trap */\n\t\tregs->gr[0] &= ~PSW_T;\n\t\tif (user_space(regs))\n\t\t\thandle_gdb_break(regs, TRAP_BRANCH);\n\t\t/* else this must be the start of a syscall - just let it\n\t\t * run.\n\t\t */\n\t\treturn;\n\n\tcase  7:  \n\t\t/* Instruction access rights */\n\t\t/* PCXL: Instruction memory protection trap */\n\n\t\t/*\n\t\t * This could be caused by either: 1) a process attempting\n\t\t * to execute within a vma that does not have execute\n\t\t * permission, or 2) an access rights violation caused by a\n\t\t * flush only translation set up by ptep_get_and_clear().\n\t\t * So we check the vma permissions to differentiate the two.\n\t\t * If the vma indicates we have execute permission, then\n\t\t * the cause is the latter one. In this case, we need to\n\t\t * call do_page_fault() to fix the problem.\n\t\t */\n\n\t\tif (user_mode(regs)) {\n\t\t\tstruct vm_area_struct *vma;\n\n\t\t\tmmap_read_lock(current->mm);\n\t\t\tvma = find_vma(current->mm,regs->iaoq[0]);\n\t\t\tif (vma && (regs->iaoq[0] >= vma->vm_start)\n\t\t\t\t&& (vma->vm_flags & VM_EXEC)) {\n\n\t\t\t\tfault_address = regs->iaoq[0];\n\t\t\t\tfault_space = regs->iasq[0];\n\n\t\t\t\tmmap_read_unlock(current->mm);\n\t\t\t\tbreak; /* call do_page_fault() */\n\t\t\t}\n\t\t\tmmap_read_unlock(current->mm);\n\t\t}\n\t\tfallthrough;\n\tcase 27: \n\t\t/* Data memory protection ID trap */\n\t\tif (code == 27 && !user_mode(regs) &&\n\t\t\tfixup_exception(regs))\n\t\t\treturn;\n\n\t\tdie_if_kernel(\"Protection id trap\", regs, code);\n\t\tforce_sig_fault(SIGSEGV, SEGV_MAPERR,\n\t\t\t\t(code == 7)?\n\t\t\t\t((void __user *) regs->iaoq[0]) :\n\t\t\t\t((void __user *) regs->ior));\n\t\treturn;\n\n\tcase 28: \n\t\t/* Unaligned data reference trap */\n\t\thandle_unaligned(regs);\n\t\treturn;\n\n\tdefault:\n\t\tif (user_mode(regs)) {\n\t\t\tparisc_printk_ratelimited(0, regs, KERN_DEBUG\n\t\t\t\t\"handle_interruption() pid=%d command='%s'\\n\",\n\t\t\t\ttask_pid_nr(current), current->comm);\n\t\t\t/* SIGBUS, for lack of a better one. */\n\t\t\tforce_sig_fault(SIGBUS, BUS_OBJERR,\n\t\t\t\t\t(void __user *)regs->ior);\n\t\t\treturn;\n\t\t}\n\t\tpdc_chassis_send_status(PDC_CHASSIS_DIRECT_PANIC);\n\t\t\n\t\tparisc_terminate(\"Unexpected interruption\", regs, code, 0);\n\t\t/* NOT REACHED */\n\t}\n\n\tif (user_mode(regs)) {\n\t    if ((fault_space >> SPACEID_SHIFT) != (regs->sr[7] >> SPACEID_SHIFT)) {\n\t\tparisc_printk_ratelimited(0, regs, KERN_DEBUG\n\t\t\t\t\"User fault %d on space 0x%08lx, pid=%d command='%s'\\n\",\n\t\t\t\tcode, fault_space,\n\t\t\t\ttask_pid_nr(current), current->comm);\n\t\tforce_sig_fault(SIGSEGV, SEGV_MAPERR,\n\t\t\t\t(void __user *)regs->ior);\n\t\treturn;\n\t    }\n\t}\n\telse {\n\n\t    /*\n\t     * The kernel should never fault on its own address space,\n\t     * unless pagefault_disable() was called before.\n\t     */\n\n\t    if (fault_space == 0 && !faulthandler_disabled())\n\t    {\n\t\t/* Clean up and return if in exception table. */\n\t\tif (fixup_exception(regs))\n\t\t\treturn;\n\t\tpdc_chassis_send_status(PDC_CHASSIS_DIRECT_PANIC);\n\t\tparisc_terminate(\"Kernel Fault\", regs, code, fault_address);\n\t    }\n\t}\n\n\tdo_page_fault(regs, code, fault_address);\n}",
        "func": "void notrace handle_interruption(int code, struct pt_regs *regs)\n{\n\tunsigned long fault_address = 0;\n\tunsigned long fault_space = 0;\n\tint si_code;\n\n\tif (code == 1)\n\t    pdc_console_restart();  /* switch back to pdc if HPMC */\n\telse\n\t    local_irq_enable();\n\n\t/* Security check:\n\t * If the priority level is still user, and the\n\t * faulting space is not equal to the active space\n\t * then the user is attempting something in a space\n\t * that does not belong to them. Kill the process.\n\t *\n\t * This is normally the situation when the user\n\t * attempts to jump into the kernel space at the\n\t * wrong offset, be it at the gateway page or a\n\t * random location.\n\t *\n\t * We cannot normally signal the process because it\n\t * could *be* on the gateway page, and processes\n\t * executing on the gateway page can't have signals\n\t * delivered.\n\t * \n\t * We merely readjust the address into the users\n\t * space, at a destination address of zero, and\n\t * allow processing to continue.\n\t */\n\tif (((unsigned long)regs->iaoq[0] & 3) &&\n\t    ((unsigned long)regs->iasq[0] != (unsigned long)regs->sr[7])) { \n\t\t/* Kill the user process later */\n\t\tregs->iaoq[0] = 0 | 3;\n\t\tregs->iaoq[1] = regs->iaoq[0] + 4;\n\t\tregs->iasq[0] = regs->iasq[1] = regs->sr[7];\n\t\tregs->gr[0] &= ~PSW_B;\n\t\treturn;\n\t}\n\t\n#if 0\n\tprintk(KERN_CRIT \"Interruption # %d\\n\", code);\n#endif\n\n\tswitch(code) {\n\n\tcase  1:\n\t\t/* High-priority machine check (HPMC) */\n\t\t\n\t\t/* set up a new led state on systems shipped with a LED State panel */\n\t\tpdc_chassis_send_status(PDC_CHASSIS_DIRECT_HPMC);\n\n\t\tparisc_terminate(\"High Priority Machine Check (HPMC)\",\n\t\t\t\tregs, code, 0);\n\t\t/* NOT REACHED */\n\t\t\n\tcase  2:\n\t\t/* Power failure interrupt */\n\t\tprintk(KERN_CRIT \"Power failure interrupt !\\n\");\n\t\treturn;\n\n\tcase  3:\n\t\t/* Recovery counter trap */\n\t\tregs->gr[0] &= ~PSW_R;\n\n#ifdef CONFIG_KPROBES\n\t\tif (parisc_kprobe_ss_handler(regs))\n\t\t\treturn;\n#endif\n\n#ifdef CONFIG_KGDB\n\t\tif (kgdb_single_step) {\n\t\t\tkgdb_handle_exception(0, SIGTRAP, 0, regs);\n\t\t\treturn;\n\t\t}\n#endif\n\n\t\tif (user_space(regs))\n\t\t\thandle_gdb_break(regs, TRAP_TRACE);\n\t\t/* else this must be the start of a syscall - just let it run */\n\t\treturn;\n\n\tcase  5:\n\t\t/* Low-priority machine check */\n\t\tpdc_chassis_send_status(PDC_CHASSIS_DIRECT_LPMC);\n\t\t\n\t\tflush_cache_all();\n\t\tflush_tlb_all();\n\t\tcpu_lpmc(5, regs);\n\t\treturn;\n\n\tcase  PARISC_ITLB_TRAP:\n\t\t/* Instruction TLB miss fault/Instruction page fault */\n\t\tfault_address = regs->iaoq[0];\n\t\tfault_space   = regs->iasq[0];\n\t\tbreak;\n\n\tcase  8:\n\t\t/* Illegal instruction trap */\n\t\tdie_if_kernel(\"Illegal instruction\", regs, code);\n\t\tsi_code = ILL_ILLOPC;\n\t\tgoto give_sigill;\n\n\tcase  9:\n\t\t/* Break instruction trap */\n\t\thandle_break(regs);\n\t\treturn;\n\n\tcase 10:\n\t\t/* Privileged operation trap */\n\t\tdie_if_kernel(\"Privileged operation\", regs, code);\n\t\tsi_code = ILL_PRVOPC;\n\t\tgoto give_sigill;\n\n\tcase 11:\n\t\t/* Privileged register trap */\n\t\tif ((regs->iir & 0xffdfffe0) == 0x034008a0) {\n\n\t\t\t/* This is a MFCTL cr26/cr27 to gr instruction.\n\t\t\t * PCXS traps on this, so we need to emulate it.\n\t\t\t */\n\n\t\t\tif (regs->iir & 0x00200000)\n\t\t\t\tregs->gr[regs->iir & 0x1f] = mfctl(27);\n\t\t\telse\n\t\t\t\tregs->gr[regs->iir & 0x1f] = mfctl(26);\n\n\t\t\tregs->iaoq[0] = regs->iaoq[1];\n\t\t\tregs->iaoq[1] += 4;\n\t\t\tregs->iasq[0] = regs->iasq[1];\n\t\t\treturn;\n\t\t}\n\n\t\tdie_if_kernel(\"Privileged register usage\", regs, code);\n\t\tsi_code = ILL_PRVREG;\n\tgive_sigill:\n\t\tforce_sig_fault(SIGILL, si_code,\n\t\t\t\t(void __user *) regs->iaoq[0]);\n\t\treturn;\n\n\tcase 12:\n\t\t/* Overflow Trap, let the userland signal handler do the cleanup */\n\t\tforce_sig_fault(SIGFPE, FPE_INTOVF,\n\t\t\t\t(void __user *) regs->iaoq[0]);\n\t\treturn;\n\t\t\n\tcase 13:\n\t\t/* Conditional Trap\n\t\t   The condition succeeds in an instruction which traps\n\t\t   on condition  */\n\t\tif(user_mode(regs)){\n\t\t\t/* Let userspace app figure it out from the insn pointed\n\t\t\t * to by si_addr.\n\t\t\t */\n\t\t\tforce_sig_fault(SIGFPE, FPE_CONDTRAP,\n\t\t\t\t\t(void __user *) regs->iaoq[0]);\n\t\t\treturn;\n\t\t} \n\t\t/* The kernel doesn't want to handle condition codes */\n\t\tbreak;\n\t\t\n\tcase 14:\n\t\t/* Assist Exception Trap, i.e. floating point exception. */\n\t\tdie_if_kernel(\"Floating point exception\", regs, 0); /* quiet */\n\t\t__inc_irq_stat(irq_fpassist_count);\n\t\thandle_fpe(regs);\n\t\treturn;\n\n\tcase 15:\n\t\t/* Data TLB miss fault/Data page fault */\n\t\tfallthrough;\n\tcase 16:\n\t\t/* Non-access instruction TLB miss fault */\n\t\t/* The instruction TLB entry needed for the target address of the FIC\n\t\t   is absent, and hardware can't find it, so we get to cleanup */\n\t\tfallthrough;\n\tcase 17:\n\t\t/* Non-access data TLB miss fault/Non-access data page fault */\n\t\t/* FIXME: \n\t\t\t Still need to add slow path emulation code here!\n\t\t\t If the insn used a non-shadow register, then the tlb\n\t\t\t handlers could not have their side-effect (e.g. probe\n\t\t\t writing to a target register) emulated since rfir would\n\t\t\t erase the changes to said register. Instead we have to\n\t\t\t setup everything, call this function we are in, and emulate\n\t\t\t by hand. Technically we need to emulate:\n\t\t\t fdc,fdce,pdc,\"fic,4f\",prober,probeir,probew, probeiw\n\t\t*/\n\t\tfault_address = regs->ior;\n\t\tfault_space = regs->isr;\n\t\tbreak;\n\n\tcase 18:\n\t\t/* PCXS only -- later cpu's split this into types 26,27 & 28 */\n\t\t/* Check for unaligned access */\n\t\tif (check_unaligned(regs)) {\n\t\t\thandle_unaligned(regs);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase 26: \n\t\t/* PCXL: Data memory access rights trap */\n\t\tfault_address = regs->ior;\n\t\tfault_space   = regs->isr;\n\t\tbreak;\n\n\tcase 19:\n\t\t/* Data memory break trap */\n\t\tregs->gr[0] |= PSW_X; /* So we can single-step over the trap */\n\t\tfallthrough;\n\tcase 21:\n\t\t/* Page reference trap */\n\t\thandle_gdb_break(regs, TRAP_HWBKPT);\n\t\treturn;\n\n\tcase 25:\n\t\t/* Taken branch trap */\n\t\tregs->gr[0] &= ~PSW_T;\n\t\tif (user_space(regs))\n\t\t\thandle_gdb_break(regs, TRAP_BRANCH);\n\t\t/* else this must be the start of a syscall - just let it\n\t\t * run.\n\t\t */\n\t\treturn;\n\n\tcase  7:  \n\t\t/* Instruction access rights */\n\t\t/* PCXL: Instruction memory protection trap */\n\n\t\t/*\n\t\t * This could be caused by either: 1) a process attempting\n\t\t * to execute within a vma that does not have execute\n\t\t * permission, or 2) an access rights violation caused by a\n\t\t * flush only translation set up by ptep_get_and_clear().\n\t\t * So we check the vma permissions to differentiate the two.\n\t\t * If the vma indicates we have execute permission, then\n\t\t * the cause is the latter one. In this case, we need to\n\t\t * call do_page_fault() to fix the problem.\n\t\t */\n\n\t\tif (user_mode(regs)) {\n\t\t\tstruct vm_area_struct *vma;\n\n\t\t\tmmap_read_lock(current->mm);\n\t\t\tvma = find_vma(current->mm,regs->iaoq[0]);\n\t\t\tif (vma && (regs->iaoq[0] >= vma->vm_start)\n\t\t\t\t&& (vma->vm_flags & VM_EXEC)) {\n\n\t\t\t\tfault_address = regs->iaoq[0];\n\t\t\t\tfault_space = regs->iasq[0];\n\n\t\t\t\tmmap_read_unlock(current->mm);\n\t\t\t\tbreak; /* call do_page_fault() */\n\t\t\t}\n\t\t\tmmap_read_unlock(current->mm);\n\t\t}\n\t\t/* CPU could not fetch instruction, so clear stale IIR value. */\n\t\tregs->iir = 0xbaadf00d;\n\t\tfallthrough;\n\tcase 27: \n\t\t/* Data memory protection ID trap */\n\t\tif (code == 27 && !user_mode(regs) &&\n\t\t\tfixup_exception(regs))\n\t\t\treturn;\n\n\t\tdie_if_kernel(\"Protection id trap\", regs, code);\n\t\tforce_sig_fault(SIGSEGV, SEGV_MAPERR,\n\t\t\t\t(code == 7)?\n\t\t\t\t((void __user *) regs->iaoq[0]) :\n\t\t\t\t((void __user *) regs->ior));\n\t\treturn;\n\n\tcase 28: \n\t\t/* Unaligned data reference trap */\n\t\thandle_unaligned(regs);\n\t\treturn;\n\n\tdefault:\n\t\tif (user_mode(regs)) {\n\t\t\tparisc_printk_ratelimited(0, regs, KERN_DEBUG\n\t\t\t\t\"handle_interruption() pid=%d command='%s'\\n\",\n\t\t\t\ttask_pid_nr(current), current->comm);\n\t\t\t/* SIGBUS, for lack of a better one. */\n\t\t\tforce_sig_fault(SIGBUS, BUS_OBJERR,\n\t\t\t\t\t(void __user *)regs->ior);\n\t\t\treturn;\n\t\t}\n\t\tpdc_chassis_send_status(PDC_CHASSIS_DIRECT_PANIC);\n\t\t\n\t\tparisc_terminate(\"Unexpected interruption\", regs, code, 0);\n\t\t/* NOT REACHED */\n\t}\n\n\tif (user_mode(regs)) {\n\t    if ((fault_space >> SPACEID_SHIFT) != (regs->sr[7] >> SPACEID_SHIFT)) {\n\t\tparisc_printk_ratelimited(0, regs, KERN_DEBUG\n\t\t\t\t\"User fault %d on space 0x%08lx, pid=%d command='%s'\\n\",\n\t\t\t\tcode, fault_space,\n\t\t\t\ttask_pid_nr(current), current->comm);\n\t\tforce_sig_fault(SIGSEGV, SEGV_MAPERR,\n\t\t\t\t(void __user *)regs->ior);\n\t\treturn;\n\t    }\n\t}\n\telse {\n\n\t    /*\n\t     * The kernel should never fault on its own address space,\n\t     * unless pagefault_disable() was called before.\n\t     */\n\n\t    if (fault_space == 0 && !faulthandler_disabled())\n\t    {\n\t\t/* Clean up and return if in exception table. */\n\t\tif (fixup_exception(regs))\n\t\t\treturn;\n\t\tpdc_chassis_send_status(PDC_CHASSIS_DIRECT_PANIC);\n\t\tparisc_terminate(\"Kernel Fault\", regs, code, fault_address);\n\t    }\n\t}\n\n\tdo_page_fault(regs, code, fault_address);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -255,6 +255,8 @@\n \t\t\t}\n \t\t\tmmap_read_unlock(current->mm);\n \t\t}\n+\t\t/* CPU could not fetch instruction, so clear stale IIR value. */\n+\t\tregs->iir = 0xbaadf00d;\n \t\tfallthrough;\n \tcase 27: \n \t\t/* Data memory protection ID trap */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/* CPU could not fetch instruction, so clear stale IIR value. */",
                "\t\tregs->iir = 0xbaadf00d;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7247",
        "func_name": "openbsd/src/smtp_mailaddr",
        "description": "smtp_mailaddr in smtp_session.c in OpenSMTPD 6.6, as used in OpenBSD 6.6 and other products, allows remote attackers to execute arbitrary commands as root via a crafted SMTP session, as demonstrated by shell metacharacters in a MAIL FROM field. This affects the \"uncommented\" default configuration. The issue exists because of an incorrect return value upon failure of input validation.",
        "git_url": "https://github.com/openbsd/src/commit/9dcfda045474d8903224d175907bfc29761dcb45",
        "commit_title": "Fix a security vulnerability discovered by Qualys which can lead to a",
        "commit_text": "privileges escalation on mbox deliveries and unprivileged code execution on lmtp deliveries, due to a logic issue causing a sanity check to be missed.  ok eric@, millert@",
        "func_before": "static int\nsmtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\t/* accept empty return-path in MAIL FROM, required for bounces */\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\n\t\t/* no user-part, reject */\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\n\t\t/* no domain, local user */\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
        "func": "static int\nsmtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\t/* accept empty return-path in MAIL FROM, required for bounces */\n\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\treturn (1);\n\n\t/* no or invalid user-part, reject */\n\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n\t\treturn (0);\n\n\t/* no domain part, local user */\n\tif (maddr->domain[0] == '\\0') {\n\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\tsizeof(maddr->domain));\n\t}\n\n\tif (!valid_domainpart(maddr->domain))\n\t\treturn (0);\n\n\treturn (1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,24 +27,22 @@\n \t\tmemmove(maddr->user, p, strlen(p) + 1);\n \t}\n \n-\tif (!valid_localpart(maddr->user) ||\n-\t    !valid_domainpart(maddr->domain)) {\n-\t\t/* accept empty return-path in MAIL FROM, required for bounces */\n-\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n-\t\t\treturn (1);\n+\t/* accept empty return-path in MAIL FROM, required for bounces */\n+\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n+\t\treturn (1);\n \n-\t\t/* no user-part, reject */\n-\t\tif (maddr->user[0] == '\\0')\n-\t\t\treturn (0);\n+\t/* no or invalid user-part, reject */\n+\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n+\t\treturn (0);\n \n-\t\t/* no domain, local user */\n-\t\tif (maddr->domain[0] == '\\0') {\n-\t\t\t(void)strlcpy(maddr->domain, domain,\n-\t\t\t    sizeof(maddr->domain));\n-\t\t\treturn (1);\n-\t\t}\n+\t/* no domain part, local user */\n+\tif (maddr->domain[0] == '\\0') {\n+\t\t(void)strlcpy(maddr->domain, domain,\n+\t\t\tsizeof(maddr->domain));\n+\t}\n+\n+\tif (!valid_domainpart(maddr->domain))\n \t\treturn (0);\n-\t}\n \n \treturn (1);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!valid_localpart(maddr->user) ||",
                "\t    !valid_domainpart(maddr->domain)) {",
                "\t\t/* accept empty return-path in MAIL FROM, required for bounces */",
                "\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')",
                "\t\t\treturn (1);",
                "\t\t/* no user-part, reject */",
                "\t\tif (maddr->user[0] == '\\0')",
                "\t\t\treturn (0);",
                "\t\t/* no domain, local user */",
                "\t\tif (maddr->domain[0] == '\\0') {",
                "\t\t\t(void)strlcpy(maddr->domain, domain,",
                "\t\t\t    sizeof(maddr->domain));",
                "\t\t\treturn (1);",
                "\t\t}",
                "\t}"
            ],
            "added_lines": [
                "\t/* accept empty return-path in MAIL FROM, required for bounces */",
                "\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')",
                "\t\treturn (1);",
                "\t/* no or invalid user-part, reject */",
                "\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))",
                "\t\treturn (0);",
                "\t/* no domain part, local user */",
                "\tif (maddr->domain[0] == '\\0') {",
                "\t\t(void)strlcpy(maddr->domain, domain,",
                "\t\t\tsizeof(maddr->domain));",
                "\t}",
                "",
                "\tif (!valid_domainpart(maddr->domain))"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24753",
        "func_name": "objsys/oocborrt/cbor2json",
        "description": "A memory corruption vulnerability in Objective Open CBOR Run-time (oocborrt) in versions before 2020-08-12 could allow an attacker to execute code via crafted Concise Binary Object Representation (CBOR) input to the cbor2json decoder. An uncaught error while decoding CBOR Major Type 3 text strings leads to the use of an attacker-controllable uninitialized stack value. This can be used to modify memory, causing a crash or potentially exploitable heap corruption.",
        "git_url": "https://github.com/objsys/oocborrt/commit/539851c66778f68a244633985f6f8d0df94ea3b3",
        "commit_title": "fixed missing return status test error",
        "commit_text": "",
        "func_before": "static int cbor2json (OSCTXT* pCborCtxt, OSCTXT* pJsonCtxt)\n{\n   int ret = 0;\n   OSOCTET tag, ub;\n\n   /* Read byte from stream */\n   ret = rtxReadBytes (pCborCtxt, &ub, 1);\n   if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n   tag = ub >> 5;\n\n   /* Switch on tag value */\n   switch (tag) {\n   case OSRTCBOR_UINT: {\n      OSUINTTYPE value;\n      ret = rtCborDecUInt (pCborCtxt, ub, &value);\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n      /* Encode JSON */\n#ifndef _NO_INT64_SUPPORT\n      ret = rtJsonEncUInt64Value (pJsonCtxt, value);\n#else\n      ret = rtJsonEncUIntValue (pJsonCtxt, value);\n#endif\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n      break;\n   }\n   case OSRTCBOR_NEGINT: {\n      OSINTTYPE value;\n      ret = rtCborDecInt (pCborCtxt, ub, &value);\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n      /* Encode JSON */\n#ifndef _NO_INT64_SUPPORT\n      ret = rtJsonEncInt64Value (pJsonCtxt, value);\n#else\n      ret = rtJsonEncIntValue (pJsonCtxt, value);\n#endif\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n      break;\n   }\n   case OSRTCBOR_BYTESTR: {\n      OSDynOctStr64 byteStr;\n      ret = rtCborDecDynByteStr (pCborCtxt, ub, &byteStr);\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n      /* Encode JSON */\n      ret = rtJsonEncHexStr (pJsonCtxt, byteStr.numocts, byteStr.data);\n      rtxMemFreePtr (pCborCtxt, byteStr.data);\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n\n      break;\n   }\n   case OSRTCBOR_UTF8STR: {\n      OSUTF8CHAR* utf8str;\n      ret = rtCborDecDynUTF8Str (pCborCtxt, ub, (char**)&utf8str);\n\n      ret = rtJsonEncStringValue (pJsonCtxt, utf8str);\n      rtxMemFreePtr (pCborCtxt, utf8str);\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n\n      break;\n   }\n   case OSRTCBOR_ARRAY: \n   case OSRTCBOR_MAP: {\n      OSOCTET len = ub & 0x1F;\n      char startChar = (tag == OSRTCBOR_ARRAY) ? '[' : '{';\n      char endChar = (tag == OSRTCBOR_ARRAY) ? ']' : '}';\n\n      OSRTSAFEPUTCHAR (pJsonCtxt, startChar);\n\n      if (len == OSRTCBOR_INDEF) {\n         OSBOOL first = TRUE;\n         for (;;) {\n            if (OSRTCBOR_MATCHEOC (pCborCtxt)) {\n               pCborCtxt->buffer.byteIndex++;\n               break;\n            }\n\n            if (!first) \n               OSRTSAFEPUTCHAR (pJsonCtxt, ',');\n            else\n               first = FALSE;\n\n            /* If map, decode object name */\n            if (tag == OSRTCBOR_MAP) {\n               ret = cborElemNameToJson (pCborCtxt, pJsonCtxt);\n            }\n\n            /* Make recursive call */\n            if (0 == ret)\n               ret = cbor2json (pCborCtxt, pJsonCtxt);\n            if (0 != ret) {\n               OSCTXT* pctxt = \n                  (rtxErrGetErrorCnt(pJsonCtxt) > 0) ? pJsonCtxt : pCborCtxt;\n               return LOG_RTERR (pctxt, ret);\n            }\n         }\n      }\n      else { /* definite length */\n         OSSIZE nitems;\n\n         /* Decode tag and number of items */\n         ret = rtCborDecSize (pCborCtxt, len, &nitems);\n         if (0 == ret) {\n            OSSIZE i;\n\n            /* Loop to decode array items */\n            for (i = 0; i < nitems; i++) {\n               if (0 != i) OSRTSAFEPUTCHAR (pJsonCtxt, ',');\n\n               /* If map, decode object name */\n               if (tag == OSRTCBOR_MAP) {\n                  ret = cborElemNameToJson (pCborCtxt, pJsonCtxt);\n               }\n\n               /* Make recursive call */\n               if (0 == ret)\n                  ret = cbor2json (pCborCtxt, pJsonCtxt);\n               if (0 != ret) {\n                  OSCTXT* pctxt = \n                  (rtxErrGetErrorCnt(pJsonCtxt) > 0) ? pJsonCtxt : pCborCtxt;\n                  return LOG_RTERR (pctxt, ret);\n               }\n            }\n         }\n      }\n      OSRTSAFEPUTCHAR (pJsonCtxt, endChar);\n      break;\n   }\n\n   case OSRTCBOR_FLOAT:\n      if (tag == OSRTCBOR_FALSEENC || tag == OSRTCBOR_TRUEENC) {\n         OSBOOL boolval = (ub == OSRTCBOR_TRUEENC) ? TRUE : FALSE;\n         ret = rtJsonEncBoolValue (pJsonCtxt, boolval);\n         if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n      }\n      else if (tag == OSRTCBOR_FLT16ENC ||\n               tag == OSRTCBOR_FLT32ENC ||\n               tag == OSRTCBOR_FLT64ENC) {\n         OSDOUBLE fltval;\n         ret = rtCborDecFloat (pCborCtxt, ub, &fltval);\n         if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n         /* Encode JSON */\n         ret = rtJsonEncDoubleValue (pJsonCtxt, fltval, 0);\n         if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n      }\n      else {\n         ret = cborTagNotSupp (pCborCtxt, tag);\n      }\n      break;\n\n   default:\n      ret = cborTagNotSupp (pCborCtxt, tag);\n   }\n\n   return ret;\n}",
        "func": "static int cbor2json (OSCTXT* pCborCtxt, OSCTXT* pJsonCtxt)\n{\n   int ret = 0;\n   OSOCTET tag, ub;\n\n   /* Read byte from stream */\n   ret = rtxReadBytes (pCborCtxt, &ub, 1);\n   if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n   tag = ub >> 5;\n\n   /* Switch on tag value */\n   switch (tag) {\n   case OSRTCBOR_UINT: {\n      OSUINTTYPE value;\n      ret = rtCborDecUInt (pCborCtxt, ub, &value);\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n      /* Encode JSON */\n#ifndef _NO_INT64_SUPPORT\n      ret = rtJsonEncUInt64Value (pJsonCtxt, value);\n#else\n      ret = rtJsonEncUIntValue (pJsonCtxt, value);\n#endif\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n      break;\n   }\n   case OSRTCBOR_NEGINT: {\n      OSINTTYPE value;\n      ret = rtCborDecInt (pCborCtxt, ub, &value);\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n      /* Encode JSON */\n#ifndef _NO_INT64_SUPPORT\n      ret = rtJsonEncInt64Value (pJsonCtxt, value);\n#else\n      ret = rtJsonEncIntValue (pJsonCtxt, value);\n#endif\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n      break;\n   }\n   case OSRTCBOR_BYTESTR: {\n      OSDynOctStr64 byteStr;\n      ret = rtCborDecDynByteStr (pCborCtxt, ub, &byteStr);\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n      /* Encode JSON */\n      ret = rtJsonEncHexStr (pJsonCtxt, byteStr.numocts, byteStr.data);\n      rtxMemFreePtr (pCborCtxt, byteStr.data);\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n\n      break;\n   }\n   case OSRTCBOR_UTF8STR: {\n      OSUTF8CHAR* utf8str;\n      ret = rtCborDecDynUTF8Str (pCborCtxt, ub, (char**)&utf8str);\n      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n      ret = rtJsonEncStringValue (pJsonCtxt, utf8str);\n      rtxMemFreePtr (pCborCtxt, utf8str);\n      if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n\n      break;\n   }\n   case OSRTCBOR_ARRAY: \n   case OSRTCBOR_MAP: {\n      OSOCTET len = ub & 0x1F;\n      char startChar = (tag == OSRTCBOR_ARRAY) ? '[' : '{';\n      char endChar = (tag == OSRTCBOR_ARRAY) ? ']' : '}';\n\n      OSRTSAFEPUTCHAR (pJsonCtxt, startChar);\n\n      if (len == OSRTCBOR_INDEF) {\n         OSBOOL first = TRUE;\n         for (;;) {\n            if (OSRTCBOR_MATCHEOC (pCborCtxt)) {\n               pCborCtxt->buffer.byteIndex++;\n               break;\n            }\n\n            if (!first) \n               OSRTSAFEPUTCHAR (pJsonCtxt, ',');\n            else\n               first = FALSE;\n\n            /* If map, decode object name */\n            if (tag == OSRTCBOR_MAP) {\n               ret = cborElemNameToJson (pCborCtxt, pJsonCtxt);\n            }\n\n            /* Make recursive call */\n            if (0 == ret)\n               ret = cbor2json (pCborCtxt, pJsonCtxt);\n            if (0 != ret) {\n               OSCTXT* pctxt = \n                  (rtxErrGetErrorCnt(pJsonCtxt) > 0) ? pJsonCtxt : pCborCtxt;\n               return LOG_RTERR (pctxt, ret);\n            }\n         }\n      }\n      else { /* definite length */\n         OSSIZE nitems;\n\n         /* Decode tag and number of items */\n         ret = rtCborDecSize (pCborCtxt, len, &nitems);\n         if (0 == ret) {\n            OSSIZE i;\n\n            /* Loop to decode array items */\n            for (i = 0; i < nitems; i++) {\n               if (0 != i) OSRTSAFEPUTCHAR (pJsonCtxt, ',');\n\n               /* If map, decode object name */\n               if (tag == OSRTCBOR_MAP) {\n                  ret = cborElemNameToJson (pCborCtxt, pJsonCtxt);\n               }\n\n               /* Make recursive call */\n               if (0 == ret)\n                  ret = cbor2json (pCborCtxt, pJsonCtxt);\n               if (0 != ret) {\n                  OSCTXT* pctxt = \n                  (rtxErrGetErrorCnt(pJsonCtxt) > 0) ? pJsonCtxt : pCborCtxt;\n                  return LOG_RTERR (pctxt, ret);\n               }\n            }\n         }\n      }\n      OSRTSAFEPUTCHAR (pJsonCtxt, endChar);\n      break;\n   }\n\n   case OSRTCBOR_FLOAT:\n      if (tag == OSRTCBOR_FALSEENC || tag == OSRTCBOR_TRUEENC) {\n         OSBOOL boolval = (ub == OSRTCBOR_TRUEENC) ? TRUE : FALSE;\n         ret = rtJsonEncBoolValue (pJsonCtxt, boolval);\n         if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n      }\n      else if (tag == OSRTCBOR_FLT16ENC ||\n               tag == OSRTCBOR_FLT32ENC ||\n               tag == OSRTCBOR_FLT64ENC) {\n         OSDOUBLE fltval;\n         ret = rtCborDecFloat (pCborCtxt, ub, &fltval);\n         if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n\n         /* Encode JSON */\n         ret = rtJsonEncDoubleValue (pJsonCtxt, fltval, 0);\n         if (0 != ret) return LOG_RTERR (pJsonCtxt, ret);\n      }\n      else {\n         ret = cborTagNotSupp (pCborCtxt, tag);\n      }\n      break;\n\n   default:\n      ret = cborTagNotSupp (pCborCtxt, tag);\n   }\n\n   return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,6 +53,7 @@\n    case OSRTCBOR_UTF8STR: {\n       OSUTF8CHAR* utf8str;\n       ret = rtCborDecDynUTF8Str (pCborCtxt, ub, (char**)&utf8str);\n+      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);\n \n       ret = rtJsonEncStringValue (pJsonCtxt, utf8str);\n       rtxMemFreePtr (pCborCtxt, utf8str);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (0 != ret) return LOG_RTERR (pCborCtxt, ret);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-25597",
        "func_name": "xen-project/xen/port_is_valid",
        "description": "An issue was discovered in Xen through 4.14.x. There is mishandling of the constraint that once-valid event channels may not turn invalid. Logic in the handling of event channel operations in Xen assumes that an event channel, once valid, will not become invalid over the life time of a guest. However, operations like the resetting of all event channels may involve decreasing one of the bounds checked when determining validity. This may lead to bug checks triggering, crashing the host. An unprivileged guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. All Xen versions from 4.4 onwards are vulnerable. Xen versions 4.3 and earlier are not vulnerable. Only systems with untrusted guests permitted to create more than the default number of event channels are vulnerable. This number depends on the architecture and type of guest. For 32-bit x86 PV guests, this is 1023; for 64-bit x86 PV guests, and for all ARM guests, this number is 4095. Systems where untrusted guests are limited to fewer than this number are not vulnerable. Note that xl and libxl limit max_event_channels to 1023 by default, so systems using exclusively xl, libvirt+libxl, or their own toolstack based on libxl, and not explicitly setting max_event_channels, are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/e59ce972d1280c6c55065da822e0860845582053",
        "commit_title": "evtchn: relax port_is_valid()",
        "commit_text": " To avoid ports potentially becoming invalid behind the back of certain other functions (due to ->max_evtchn shrinking) because of - a guest invoking evtchn_reset() and from a 2nd vCPU opening new   channels in parallel (see also XSA-343), - alloc_unbound_xen_event_channel() produced channels living above the   2-level range (see also XSA-342), drop the max_evtchns check from port_is_valid(). For a port for which the function once returned \"true\", the returned value may not turn into \"false\" later on. The function's result may only depend on bounds which can only ever grow (which is the case for d->valid_evtchns).  This also eliminates a false sense of safety, utilized by some of the users (see again XSA-343): Without a suitable lock held, d->max_evtchns may change at any time, and hence deducing that certain other operations are safe when port_is_valid() returned true is not legitimate. The opportunities to abuse this may get widened by the change here (depending on guest and host configuration), but will be taken care of by the other XSA.  This is XSA-338. ",
        "func_before": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    if ( p >= d->max_evtchns )\n        return 0;\n    return p < read_atomic(&d->valid_evtchns);\n}",
        "func": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    return p < read_atomic(&d->valid_evtchns);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,4 @@\n static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n {\n-    if ( p >= d->max_evtchns )\n-        return 0;\n     return p < read_atomic(&d->valid_evtchns);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( p >= d->max_evtchns )",
                "        return 0;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-25602",
        "func_name": "xen-project/xen/write_msr",
        "description": "An issue was discovered in Xen through 4.14.x. An x86 PV guest can trigger a host OS crash when handling guest access to MSR_MISC_ENABLE. When a guest accesses certain Model Specific Registers, Xen first reads the value from hardware to use as the basis for auditing the guest access. For the MISC_ENABLE MSR, which is an Intel specific MSR, this MSR read is performed without error handling for a #GP fault, which is the consequence of trying to read this MSR on non-Intel hardware. A buggy or malicious PV guest administrator can crash Xen, resulting in a host Denial of Service. Only x86 systems are vulnerable. ARM systems are not vulnerable. Only Xen versions 4.11 and onwards are vulnerable. 4.10 and earlier are not vulnerable. Only x86 systems that do not implement the MISC_ENABLE MSR (0x1a0) are vulnerable. AMD and Hygon systems do not implement this MSR and are vulnerable. Intel systems do implement this MSR and are not vulnerable. Other manufacturers have not been checked. Only x86 PV guests can exploit the vulnerability. x86 HVM/PVH guests cannot exploit the vulnerability.",
        "git_url": "https://github.com/xen-project/xen/commit/e71301ecd50f2d3bd1b960bbf7dcf850d02e7e8a",
        "commit_title": "x86/pv: Handle the Intel-specific MSR_MISC_ENABLE correctly",
        "commit_text": " This MSR doesn't exist on AMD hardware, and switching away from the safe functions in the common MSR path was an erroneous change.  Partially revert the change.  This is XSA-333. ",
        "func_before": "static int write_msr(unsigned int reg, uint64_t val,\n                     struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_wrmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n        uint64_t temp;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrfsbase(val);\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsbase(val);\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsshadow(val);\n        curr->arch.pv.gs_base_user = val;\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        /*\n         * Reject writes which change the value, but Linux depends on being\n         * able to write back the current value.\n         */\n        if ( val != guest_efer(currd) )\n            break;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n    case MSR_K8_HWCR:\n        if ( !(boot_cpu_data.x86_vendor &\n               (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_NB_CFG:\n        if ( !is_hwdom_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) ||\n             ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 )\n            break;\n        if ( !is_hwdom_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 )\n            break;\n        if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ?\n             temp != val :\n             ((temp ^ val) &\n              ~(FAM10H_MMIO_CONF_ENABLE |\n                (FAM10H_MMIO_CONF_BUSRANGE_MASK <<\n                 FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\n                ((u64)FAM10H_MMIO_CONF_BASE_MASK <<\n                 FAM10H_MMIO_CONF_BASE_SHIFT))) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_MISC_ENABLE:\n        rdmsrl(reg, temp);\n        if ( val != guest_misc_enable(temp) )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MPERF:\n    case MSR_IA32_APERF:\n        if ( !(boot_cpu_data.x86_vendor &\n               (X86_VENDOR_INTEL | X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_PERF_CTL:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_THERM_CONTROL:\n    case MSR_IA32_ENERGY_PERF_BIAS:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hwdom_pinned_vcpu(curr) || wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor &\n                              (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            {\n                if ( (vpmu_mode & XENPMU_MODE_ALL) &&\n                     !is_hardware_domain(currd) )\n                    return X86EMUL_OKAY;\n\n                if ( vpmu_do_wrmsr(reg, val, 0) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        gdprintk(XENLOG_WARNING,\n                 \"WRMSR 0x%08x val 0x%016\"PRIx64\" unimplemented\\n\",\n                 reg, val);\n        break;\n\n    invalid:\n        gdprintk(XENLOG_WARNING,\n                 \"Domain attempted WRMSR 0x%08x from 0x%016\"PRIx64\" to 0x%016\"PRIx64\"\\n\",\n                 reg, temp, val);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}",
        "func": "static int write_msr(unsigned int reg, uint64_t val,\n                     struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_wrmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n        uint64_t temp;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrfsbase(val);\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsbase(val);\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) )\n            break;\n        wrgsshadow(val);\n        curr->arch.pv.gs_base_user = val;\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        /*\n         * Reject writes which change the value, but Linux depends on being\n         * able to write back the current value.\n         */\n        if ( val != guest_efer(currd) )\n            break;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n    case MSR_K8_HWCR:\n        if ( !(boot_cpu_data.x86_vendor &\n               (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_AMD64_NB_CFG:\n        if ( !is_hwdom_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) ||\n             ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 )\n            break;\n        if ( !is_hwdom_pinned_vcpu(curr) )\n            return X86EMUL_OKAY;\n        if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 )\n            break;\n        if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ?\n             temp != val :\n             ((temp ^ val) &\n              ~(FAM10H_MMIO_CONF_ENABLE |\n                (FAM10H_MMIO_CONF_BUSRANGE_MASK <<\n                 FAM10H_MMIO_CONF_BUSRANGE_SHIFT) |\n                ((u64)FAM10H_MMIO_CONF_BASE_MASK <<\n                 FAM10H_MMIO_CONF_BASE_SHIFT))) )\n            goto invalid;\n        if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_MISC_ENABLE:\n        if ( rdmsr_safe(reg, temp) )\n            break;\n        if ( val != guest_misc_enable(temp) )\n            goto invalid;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MPERF:\n    case MSR_IA32_APERF:\n        if ( !(boot_cpu_data.x86_vendor &\n               (X86_VENDOR_INTEL | X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_PERF_CTL:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( likely(!is_cpufreq_controller(currd)) ||\n             wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_IA32_THERM_CONTROL:\n    case MSR_IA32_ENERGY_PERF_BIAS:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL )\n            break;\n        if ( !is_hwdom_pinned_vcpu(curr) || wrmsr_safe(reg, val) == 0 )\n            return X86EMUL_OKAY;\n        break;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor &\n                              (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            {\n                if ( (vpmu_mode & XENPMU_MODE_ALL) &&\n                     !is_hardware_domain(currd) )\n                    return X86EMUL_OKAY;\n\n                if ( vpmu_do_wrmsr(reg, val, 0) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        gdprintk(XENLOG_WARNING,\n                 \"WRMSR 0x%08x val 0x%016\"PRIx64\" unimplemented\\n\",\n                 reg, val);\n        break;\n\n    invalid:\n        gdprintk(XENLOG_WARNING,\n                 \"Domain attempted WRMSR 0x%08x from 0x%016\"PRIx64\" to 0x%016\"PRIx64\"\\n\",\n                 reg, temp, val);\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -100,7 +100,8 @@\n         break;\n \n     case MSR_IA32_MISC_ENABLE:\n-        rdmsrl(reg, temp);\n+        if ( rdmsr_safe(reg, temp) )\n+            break;\n         if ( val != guest_misc_enable(temp) )\n             goto invalid;\n         return X86EMUL_OKAY;",
        "diff_line_info": {
            "deleted_lines": [
                "        rdmsrl(reg, temp);"
            ],
            "added_lines": [
                "        if ( rdmsr_safe(reg, temp) )",
                "            break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-25602",
        "func_name": "xen-project/xen/read_msr",
        "description": "An issue was discovered in Xen through 4.14.x. An x86 PV guest can trigger a host OS crash when handling guest access to MSR_MISC_ENABLE. When a guest accesses certain Model Specific Registers, Xen first reads the value from hardware to use as the basis for auditing the guest access. For the MISC_ENABLE MSR, which is an Intel specific MSR, this MSR read is performed without error handling for a #GP fault, which is the consequence of trying to read this MSR on non-Intel hardware. A buggy or malicious PV guest administrator can crash Xen, resulting in a host Denial of Service. Only x86 systems are vulnerable. ARM systems are not vulnerable. Only Xen versions 4.11 and onwards are vulnerable. 4.10 and earlier are not vulnerable. Only x86 systems that do not implement the MISC_ENABLE MSR (0x1a0) are vulnerable. AMD and Hygon systems do not implement this MSR and are vulnerable. Intel systems do implement this MSR and are not vulnerable. Other manufacturers have not been checked. Only x86 PV guests can exploit the vulnerability. x86 HVM/PVH guests cannot exploit the vulnerability.",
        "git_url": "https://github.com/xen-project/xen/commit/e71301ecd50f2d3bd1b960bbf7dcf850d02e7e8a",
        "commit_title": "x86/pv: Handle the Intel-specific MSR_MISC_ENABLE correctly",
        "commit_text": " This MSR doesn't exist on AMD hardware, and switching away from the safe functions in the common MSR path was an erroneous change.  Partially revert the change.  This is XSA-333. ",
        "func_before": "static int read_msr(unsigned int reg, uint64_t *val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_rdmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n    case MSR_APIC_BASE:\n        /* Linux PV guests will attempt to read APIC_BASE. */\n        *val = APIC_BASE_ENABLE | APIC_DEFAULT_PHYS_BASE;\n        if ( !curr->vcpu_id )\n            *val |= APIC_BASE_BSP;\n        return X86EMUL_OKAY;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = rdfsbase();\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = rdgsbase();\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = curr->arch.pv.gs_base_user;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_TSC:\n        *val = currd->arch.vtsc ? pv_soft_rdtsc(curr, ctxt->regs) : rdtsc();\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        *val = guest_efer(currd);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_CR_PAT:\n        *val = XEN_MSR_PAT;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( unlikely(is_cpufreq_controller(currd)) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 )\n            break;\n        /* fall through */\n    case MSR_AMD64_NB_CFG:\n        if ( is_hwdom_pinned_vcpu(curr) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MISC_ENABLE:\n        rdmsrl(reg, *val);\n        *val = guest_misc_enable(*val);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_PERF_CAPABILITIES:\n        /* No extra capabilities are supported. */\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n            /* fall through */\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor &\n                              (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            {\n                if ( vpmu_do_rdmsr(reg, val) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        gdprintk(XENLOG_WARNING, \"RDMSR 0x%08x unimplemented\\n\", reg);\n        break;\n\n    normal:\n        if ( rdmsr_safe(reg, *val) )\n            break;\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}",
        "func": "static int read_msr(unsigned int reg, uint64_t *val,\n                    struct x86_emulate_ctxt *ctxt)\n{\n    struct vcpu *curr = current;\n    const struct domain *currd = curr->domain;\n    bool vpmu_msr = false;\n    int ret;\n\n    if ( (ret = guest_rdmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE )\n    {\n        if ( ret == X86EMUL_EXCEPTION )\n            x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt);\n\n        return ret;\n    }\n\n    switch ( reg )\n    {\n    case MSR_APIC_BASE:\n        /* Linux PV guests will attempt to read APIC_BASE. */\n        *val = APIC_BASE_ENABLE | APIC_DEFAULT_PHYS_BASE;\n        if ( !curr->vcpu_id )\n            *val |= APIC_BASE_BSP;\n        return X86EMUL_OKAY;\n\n    case MSR_FS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = rdfsbase();\n        return X86EMUL_OKAY;\n\n    case MSR_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = rdgsbase();\n        return X86EMUL_OKAY;\n\n    case MSR_SHADOW_GS_BASE:\n        if ( is_pv_32bit_domain(currd) )\n            break;\n        *val = curr->arch.pv.gs_base_user;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_TSC:\n        *val = currd->arch.vtsc ? pv_soft_rdtsc(curr, ctxt->regs) : rdtsc();\n        return X86EMUL_OKAY;\n\n    case MSR_EFER:\n        *val = guest_efer(currd);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_CR_PAT:\n        *val = XEN_MSR_PAT;\n        return X86EMUL_OKAY;\n\n    case MSR_K7_FID_VID_CTL:\n    case MSR_K7_FID_VID_STATUS:\n    case MSR_K8_PSTATE_LIMIT:\n    case MSR_K8_PSTATE_CTRL:\n    case MSR_K8_PSTATE_STATUS:\n    case MSR_K8_PSTATE0:\n    case MSR_K8_PSTATE1:\n    case MSR_K8_PSTATE2:\n    case MSR_K8_PSTATE3:\n    case MSR_K8_PSTATE4:\n    case MSR_K8_PSTATE5:\n    case MSR_K8_PSTATE6:\n    case MSR_K8_PSTATE7:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD )\n            break;\n        if ( unlikely(is_cpufreq_controller(currd)) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_FAM10H_MMIO_CONF_BASE:\n        if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ||\n             boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 )\n            break;\n        /* fall through */\n    case MSR_AMD64_NB_CFG:\n        if ( is_hwdom_pinned_vcpu(curr) )\n            goto normal;\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_MISC_ENABLE:\n        if ( rdmsr_safe(reg, *val) )\n            break;\n        *val = guest_misc_enable(*val);\n        return X86EMUL_OKAY;\n\n    case MSR_IA32_PERF_CAPABILITIES:\n        /* No extra capabilities are supported. */\n        *val = 0;\n        return X86EMUL_OKAY;\n\n    case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7):\n    case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3):\n    case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2:\n    case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n        if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL )\n        {\n            vpmu_msr = true;\n            /* fall through */\n    case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5:\n    case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3:\n            if ( vpmu_msr || (boot_cpu_data.x86_vendor &\n                              (X86_VENDOR_AMD | X86_VENDOR_HYGON)) )\n            {\n                if ( vpmu_do_rdmsr(reg, val) )\n                    break;\n                return X86EMUL_OKAY;\n            }\n        }\n        /* fall through */\n    default:\n        gdprintk(XENLOG_WARNING, \"RDMSR 0x%08x unimplemented\\n\", reg);\n        break;\n\n    normal:\n        if ( rdmsr_safe(reg, *val) )\n            break;\n        return X86EMUL_OKAY;\n    }\n\n    return X86EMUL_UNHANDLEABLE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,7 +85,8 @@\n         return X86EMUL_OKAY;\n \n     case MSR_IA32_MISC_ENABLE:\n-        rdmsrl(reg, *val);\n+        if ( rdmsr_safe(reg, *val) )\n+            break;\n         *val = guest_misc_enable(*val);\n         return X86EMUL_OKAY;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        rdmsrl(reg, *val);"
            ],
            "added_lines": [
                "        if ( rdmsr_safe(reg, *val) )",
                "            break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28896",
        "func_name": "neomutt/imap_open_connection",
        "description": "Mutt before 2.0.2 and NeoMutt before 2020-11-20 did not ensure that $ssl_force_tls was processed if an IMAP server's initial server response was invalid. The connection was not properly closed, and the code could continue attempting to authenticate. This could result in authentication credentials being exposed on an unencrypted connection, or to a machine-in-the-middle.",
        "git_url": "https://github.com/neomutt/neomutt/commit/9c36717a3e2af1f2c1b7242035455ec8112b4b06",
        "commit_title": "imap: close connection on all failures",
        "commit_text": " Thanks to Gabriel Salles-Loustau for spotting the problem.  Co-authored-by: Kevin McCarthy <kevin@8t8.us>",
        "func_before": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_istr_startswith(adata->buf, \"* OK\"))\n  {\n    if (!mutt_istr_startswith(adata->buf, \"* OK [CAPABILITY\") && check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && (adata->conn->ssf == 0))\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_istr_startswith(adata->buf, \"* PREAUTH\"))\n  {\n#ifdef USE_SSL\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response may be a\n     * MITM attack.  The only way to stop \"STARTTLS\" MITM attacks is via\n     * $ssl_force_tls: an attacker can easily spoof \"* OK\" and strip the\n     * STARTTLS capability.  So consult $ssl_force_tls, not $ssl_starttls, to\n     * decide whether to abort. Note that if using $tunnel and\n     * $tunnel_is_secure, adata->conn->ssf will be set to 1. */\n    if ((adata->conn->ssf == 0) && C_SslForceTls)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}",
        "func": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_istr_startswith(adata->buf, \"* OK\"))\n  {\n    if (!mutt_istr_startswith(adata->buf, \"* OK [CAPABILITY\") && check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto bail;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto bail;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && (adata->conn->ssf == 0))\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto bail;\n    }\n#endif\n  }\n  else if (mutt_istr_startswith(adata->buf, \"* PREAUTH\"))\n  {\n#ifdef USE_SSL\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response may be a\n     * MITM attack.  The only way to stop \"STARTTLS\" MITM attacks is via\n     * $ssl_force_tls: an attacker can easily spoof \"* OK\" and strip the\n     * STARTTLS capability.  So consult $ssl_force_tls, not $ssl_starttls, to\n     * decide whether to abort. Note that if using $tunnel and\n     * $tunnel_is_secure, adata->conn->ssf will be set to 1. */\n    if ((adata->conn->ssf == 0) && C_SslForceTls)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto bail;\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\nbail:\n  imap_close_connection(adata);\n  FREE(&adata->capstr);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n       else if ((ans = query_quadoption(C_SslStarttls,\n                                        _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n       {\n-        goto err_close_conn;\n+        goto bail;\n       }\n       if (ans == MUTT_YES)\n       {\n@@ -43,7 +43,7 @@\n           if (mutt_ssl_starttls(adata->conn))\n           {\n             mutt_error(_(\"Could not negotiate TLS connection\"));\n-            goto err_close_conn;\n+            goto bail;\n           }\n           else\n           {\n@@ -58,7 +58,7 @@\n     if (C_SslForceTls && (adata->conn->ssf == 0))\n     {\n       mutt_error(_(\"Encrypted connection unavailable\"));\n-      goto err_close_conn;\n+      goto bail;\n     }\n #endif\n   }\n@@ -74,7 +74,7 @@\n     if ((adata->conn->ssf == 0) && C_SslForceTls)\n     {\n       mutt_error(_(\"Encrypted connection unavailable\"));\n-      goto err_close_conn;\n+      goto bail;\n     }\n #endif\n \n@@ -91,11 +91,8 @@\n \n   return 0;\n \n-#ifdef USE_SSL\n-err_close_conn:\n+bail:\n   imap_close_connection(adata);\n-#endif\n-bail:\n   FREE(&adata->capstr);\n   return -1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        goto err_close_conn;",
                "            goto err_close_conn;",
                "      goto err_close_conn;",
                "      goto err_close_conn;",
                "#ifdef USE_SSL",
                "err_close_conn:",
                "#endif",
                "bail:"
            ],
            "added_lines": [
                "        goto bail;",
                "            goto bail;",
                "      goto bail;",
                "      goto bail;",
                "bail:"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28896",
        "func_name": "muttmua/mutt/imap_open_connection",
        "description": "Mutt before 2.0.2 and NeoMutt before 2020-11-20 did not ensure that $ssl_force_tls was processed if an IMAP server's initial server response was invalid. The connection was not properly closed, and the code could continue attempting to authenticate. This could result in authentication credentials being exposed on an unencrypted connection, or to a machine-in-the-middle.",
        "git_url": "https://gitlab.com/muttmua/mutt/-/commit/04b06aaa3e0cc0022b9b01dbca2863756ebbf59a",
        "commit_title": "Ensure IMAP connection is closed after a connection error.",
        "commit_text": " During connection, if the server provided an illegal initial response, Mutt \"bailed\", but did not actually close the connection.  The calling code unfortunately relied on the connection status to decide to continue with authentication, instead of checking the \"bail\" return value.  This could result in authentication credentials being sent over an unencrypted connection, without $ssl_force_tls being consulted.  Fix this by strictly closing the connection on any invalid response during connection.  The fix is intentionally small, to ease backporting.  A better fix would include removing the 'err_close_conn' label, and perhaps adding return value checking in the caller (though this change obviates the need for that).  This addresses CVE-2020-28896.  Thanks to Gabriel Salles-Loustau for reporting the problem, and providing test cases to reproduce. ",
        "func_before": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response\n     * may be a MITM attack.  The only way to stop \"STARTTLS\" MITM\n     * attacks is via $ssl_force_tls: an attacker can easily spoof\n     * \"* OK\" and strip the STARTTLS capability.  So consult\n     * $ssl_force_tls, not $ssl_starttls, to decide whether to\n     * abort. Note that if using $tunnel and $tunnel_is_secure,\n     * conn->ssf will be set to 1. */\n    if (!idata->conn->ssf && option(OPTSSLFORCETLS))\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}",
        "func": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response\n     * may be a MITM attack.  The only way to stop \"STARTTLS\" MITM\n     * attacks is via $ssl_force_tls: an attacker can easily spoof\n     * \"* OK\" and strip the STARTTLS capability.  So consult\n     * $ssl_force_tls, not $ssl_starttls, to decide whether to\n     * abort. Note that if using $tunnel and $tunnel_is_secure,\n     * conn->ssf will be set to 1. */\n    if (!idata->conn->ssf && option(OPTSSLFORCETLS))\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n#endif\nbail:\n  imap_close_connection (idata);\n  FREE (&idata->capstr);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -91,9 +91,9 @@\n \n #if defined(USE_SSL)\n err_close_conn:\n-  imap_close_connection (idata);\n #endif\n bail:\n+  imap_close_connection (idata);\n   FREE (&idata->capstr);\n   return -1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  imap_close_connection (idata);"
            ],
            "added_lines": [
                "  imap_close_connection (idata);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28971",
        "func_name": "torvalds/linux/intel_pmu_drain_pebs_nhm",
        "description": "In intel_pmu_drain_pebs_nhm in arch/x86/events/intel/ds.c in the Linux kernel through 5.11.8 on some Haswell CPUs, userspace applications (such as perf-fuzzer) can cause a system crash because the PEBS status in a PEBS record is mishandled, aka CID-d88d05a9e0b6.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=d88d05a9e0b6d9356e97129d4ff9942d765f46ea",
        "commit_title": "A repeatable crash can be triggered by the perf_fuzzer on some Haswell",
        "commit_text": "system. https://lore.kernel.org/lkml/7170d3b-c17f-1ded-52aa-cc6d9ae999f4@maine.edu/  For some old CPUs (HSW and earlier), the PEBS status in a PEBS record may be mistakenly set to 0. To minimize the impact of the defect, the commit was introduced to try to avoid dropping the PEBS record for some cases. It adds a check in the intel_pmu_drain_pebs_nhm(), and updates the local pebs_status accordingly. However, it doesn't correct the PEBS status in the PEBS record, which may trigger the crash, especially for the large PEBS.  It's possible that all the PEBS records in a large PEBS have the PEBS status 0. If so, the first get_next_pebs_record_by_bit() in the __intel_pmu_pebs_event() returns NULL. The at = NULL. Since it's a large PEBS, the 'count' parameter must > 1. The second get_next_pebs_record_by_bit() will crash.  Besides the local pebs_status, correct the PEBS status in the PEBS record as well.  Suggested-by: Peter Zijlstra (Intel) <peterz@infradead.org> Cc: stable@vger.kernel.org Link: https://lkml.kernel.org/r/1615555298-140216-1-git-send-email-kan.liang@linux.intel.com ",
        "func_before": "static void intel_pmu_drain_pebs_nhm(struct pt_regs *iregs, struct perf_sample_data *data)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tstruct debug_store *ds = cpuc->ds;\n\tstruct perf_event *event;\n\tvoid *base, *at, *top;\n\tshort counts[INTEL_PMC_IDX_FIXED + MAX_FIXED_PEBS_EVENTS] = {};\n\tshort error[INTEL_PMC_IDX_FIXED + MAX_FIXED_PEBS_EVENTS] = {};\n\tint bit, i, size;\n\tu64 mask;\n\n\tif (!x86_pmu.pebs_active)\n\t\treturn;\n\n\tbase = (struct pebs_record_nhm *)(unsigned long)ds->pebs_buffer_base;\n\ttop = (struct pebs_record_nhm *)(unsigned long)ds->pebs_index;\n\n\tds->pebs_index = ds->pebs_buffer_base;\n\n\tmask = (1ULL << x86_pmu.max_pebs_events) - 1;\n\tsize = x86_pmu.max_pebs_events;\n\tif (x86_pmu.flags & PMU_FL_PEBS_ALL) {\n\t\tmask |= ((1ULL << x86_pmu.num_counters_fixed) - 1) << INTEL_PMC_IDX_FIXED;\n\t\tsize = INTEL_PMC_IDX_FIXED + x86_pmu.num_counters_fixed;\n\t}\n\n\tif (unlikely(base >= top)) {\n\t\tintel_pmu_pebs_event_update_no_drain(cpuc, size);\n\t\treturn;\n\t}\n\n\tfor (at = base; at < top; at += x86_pmu.pebs_record_size) {\n\t\tstruct pebs_record_nhm *p = at;\n\t\tu64 pebs_status;\n\n\t\tpebs_status = p->status & cpuc->pebs_enabled;\n\t\tpebs_status &= mask;\n\n\t\t/* PEBS v3 has more accurate status bits */\n\t\tif (x86_pmu.intel_cap.pebs_format >= 3) {\n\t\t\tfor_each_set_bit(bit, (unsigned long *)&pebs_status, size)\n\t\t\t\tcounts[bit]++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * On some CPUs the PEBS status can be zero when PEBS is\n\t\t * racing with clearing of GLOBAL_STATUS.\n\t\t *\n\t\t * Normally we would drop that record, but in the\n\t\t * case when there is only a single active PEBS event\n\t\t * we can assume it's for that event.\n\t\t */\n\t\tif (!pebs_status && cpuc->pebs_enabled &&\n\t\t\t!(cpuc->pebs_enabled & (cpuc->pebs_enabled-1)))\n\t\t\tpebs_status = cpuc->pebs_enabled;\n\n\t\tbit = find_first_bit((unsigned long *)&pebs_status,\n\t\t\t\t\tx86_pmu.max_pebs_events);\n\t\tif (bit >= x86_pmu.max_pebs_events)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The PEBS hardware does not deal well with the situation\n\t\t * when events happen near to each other and multiple bits\n\t\t * are set. But it should happen rarely.\n\t\t *\n\t\t * If these events include one PEBS and multiple non-PEBS\n\t\t * events, it doesn't impact PEBS record. The record will\n\t\t * be handled normally. (slow path)\n\t\t *\n\t\t * If these events include two or more PEBS events, the\n\t\t * records for the events can be collapsed into a single\n\t\t * one, and it's not possible to reconstruct all events\n\t\t * that caused the PEBS record. It's called collision.\n\t\t * If collision happened, the record will be dropped.\n\t\t */\n\t\tif (pebs_status != (1ULL << bit)) {\n\t\t\tfor_each_set_bit(i, (unsigned long *)&pebs_status, size)\n\t\t\t\terror[i]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounts[bit]++;\n\t}\n\n\tfor_each_set_bit(bit, (unsigned long *)&mask, size) {\n\t\tif ((counts[bit] == 0) && (error[bit] == 0))\n\t\t\tcontinue;\n\n\t\tevent = cpuc->events[bit];\n\t\tif (WARN_ON_ONCE(!event))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON_ONCE(!event->attr.precise_ip))\n\t\t\tcontinue;\n\n\t\t/* log dropped samples number */\n\t\tif (error[bit]) {\n\t\t\tperf_log_lost_samples(event, error[bit]);\n\n\t\t\tif (iregs && perf_event_account_interrupt(event))\n\t\t\t\tx86_pmu_stop(event, 0);\n\t\t}\n\n\t\tif (counts[bit]) {\n\t\t\t__intel_pmu_pebs_event(event, iregs, data, base,\n\t\t\t\t\t       top, bit, counts[bit],\n\t\t\t\t\t       setup_pebs_fixed_sample_data);\n\t\t}\n\t}\n}",
        "func": "static void intel_pmu_drain_pebs_nhm(struct pt_regs *iregs, struct perf_sample_data *data)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tstruct debug_store *ds = cpuc->ds;\n\tstruct perf_event *event;\n\tvoid *base, *at, *top;\n\tshort counts[INTEL_PMC_IDX_FIXED + MAX_FIXED_PEBS_EVENTS] = {};\n\tshort error[INTEL_PMC_IDX_FIXED + MAX_FIXED_PEBS_EVENTS] = {};\n\tint bit, i, size;\n\tu64 mask;\n\n\tif (!x86_pmu.pebs_active)\n\t\treturn;\n\n\tbase = (struct pebs_record_nhm *)(unsigned long)ds->pebs_buffer_base;\n\ttop = (struct pebs_record_nhm *)(unsigned long)ds->pebs_index;\n\n\tds->pebs_index = ds->pebs_buffer_base;\n\n\tmask = (1ULL << x86_pmu.max_pebs_events) - 1;\n\tsize = x86_pmu.max_pebs_events;\n\tif (x86_pmu.flags & PMU_FL_PEBS_ALL) {\n\t\tmask |= ((1ULL << x86_pmu.num_counters_fixed) - 1) << INTEL_PMC_IDX_FIXED;\n\t\tsize = INTEL_PMC_IDX_FIXED + x86_pmu.num_counters_fixed;\n\t}\n\n\tif (unlikely(base >= top)) {\n\t\tintel_pmu_pebs_event_update_no_drain(cpuc, size);\n\t\treturn;\n\t}\n\n\tfor (at = base; at < top; at += x86_pmu.pebs_record_size) {\n\t\tstruct pebs_record_nhm *p = at;\n\t\tu64 pebs_status;\n\n\t\tpebs_status = p->status & cpuc->pebs_enabled;\n\t\tpebs_status &= mask;\n\n\t\t/* PEBS v3 has more accurate status bits */\n\t\tif (x86_pmu.intel_cap.pebs_format >= 3) {\n\t\t\tfor_each_set_bit(bit, (unsigned long *)&pebs_status, size)\n\t\t\t\tcounts[bit]++;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * On some CPUs the PEBS status can be zero when PEBS is\n\t\t * racing with clearing of GLOBAL_STATUS.\n\t\t *\n\t\t * Normally we would drop that record, but in the\n\t\t * case when there is only a single active PEBS event\n\t\t * we can assume it's for that event.\n\t\t */\n\t\tif (!pebs_status && cpuc->pebs_enabled &&\n\t\t\t!(cpuc->pebs_enabled & (cpuc->pebs_enabled-1)))\n\t\t\tpebs_status = p->status = cpuc->pebs_enabled;\n\n\t\tbit = find_first_bit((unsigned long *)&pebs_status,\n\t\t\t\t\tx86_pmu.max_pebs_events);\n\t\tif (bit >= x86_pmu.max_pebs_events)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The PEBS hardware does not deal well with the situation\n\t\t * when events happen near to each other and multiple bits\n\t\t * are set. But it should happen rarely.\n\t\t *\n\t\t * If these events include one PEBS and multiple non-PEBS\n\t\t * events, it doesn't impact PEBS record. The record will\n\t\t * be handled normally. (slow path)\n\t\t *\n\t\t * If these events include two or more PEBS events, the\n\t\t * records for the events can be collapsed into a single\n\t\t * one, and it's not possible to reconstruct all events\n\t\t * that caused the PEBS record. It's called collision.\n\t\t * If collision happened, the record will be dropped.\n\t\t */\n\t\tif (pebs_status != (1ULL << bit)) {\n\t\t\tfor_each_set_bit(i, (unsigned long *)&pebs_status, size)\n\t\t\t\terror[i]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounts[bit]++;\n\t}\n\n\tfor_each_set_bit(bit, (unsigned long *)&mask, size) {\n\t\tif ((counts[bit] == 0) && (error[bit] == 0))\n\t\t\tcontinue;\n\n\t\tevent = cpuc->events[bit];\n\t\tif (WARN_ON_ONCE(!event))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON_ONCE(!event->attr.precise_ip))\n\t\t\tcontinue;\n\n\t\t/* log dropped samples number */\n\t\tif (error[bit]) {\n\t\t\tperf_log_lost_samples(event, error[bit]);\n\n\t\t\tif (iregs && perf_event_account_interrupt(event))\n\t\t\t\tx86_pmu_stop(event, 0);\n\t\t}\n\n\t\tif (counts[bit]) {\n\t\t\t__intel_pmu_pebs_event(event, iregs, data, base,\n\t\t\t\t\t       top, bit, counts[bit],\n\t\t\t\t\t       setup_pebs_fixed_sample_data);\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,7 +54,7 @@\n \t\t */\n \t\tif (!pebs_status && cpuc->pebs_enabled &&\n \t\t\t!(cpuc->pebs_enabled & (cpuc->pebs_enabled-1)))\n-\t\t\tpebs_status = cpuc->pebs_enabled;\n+\t\t\tpebs_status = p->status = cpuc->pebs_enabled;\n \n \t\tbit = find_first_bit((unsigned long *)&pebs_status,\n \t\t\t\t\tx86_pmu.max_pebs_events);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tpebs_status = cpuc->pebs_enabled;"
            ],
            "added_lines": [
                "\t\t\tpebs_status = p->status = cpuc->pebs_enabled;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11743",
        "func_name": "xen-project/xen/map_grant_ref",
        "description": "An issue was discovered in Xen through 4.13.x, allowing guest OS users to cause a denial of service because of a bad error path in GNTTABOP_map_grant. Grant table operations are expected to return 0 for success, and a negative number for errors. Some misplaced brackets cause one error path to return 1 instead of a negative value. The grant table code in Linux treats this condition as success, and proceeds with incorrectly initialised state. A buggy or malicious guest can construct its grant table in such a way that, when a backend domain tries to map a grant, it hits the incorrect error path. This will crash a Linux based dom0 or backend domain.",
        "git_url": "https://github.com/xen-project/xen/commit/da0c66c8f48042a0186799014af69db0303b1da5",
        "commit_title": "xen/gnttab: Fix error path in map_grant_ref()",
        "commit_text": " Part of XSA-295 (c/s 863e74eb2cffb) inadvertently re-positioned the brackets, changing the logic.  If the _set_status() call fails, the grant_map hypercall would fail with a status of 1 (rc != GNTST_okay) instead of the expected negative GNTST_* error.  This error path can be taken due to bad guest state, and causes net/blk-back in Linux to crash.  This is XSA-316. ",
        "func_before": "static void\nmap_grant_ref(\n    struct gnttab_map_grant_ref *op)\n{\n    struct domain *ld, *rd, *owner = NULL;\n    struct grant_table *lgt, *rgt;\n    grant_ref_t ref;\n    grant_handle_t handle;\n    mfn_t mfn;\n    struct page_info *pg = NULL;\n    int            rc = GNTST_okay;\n    unsigned int   cache_flags, clear_flags = 0, refcnt = 0, typecnt = 0;\n    bool           host_map_created = false;\n    struct active_grant_entry *act = NULL;\n    struct grant_mapping *mt;\n    grant_entry_header_t *shah;\n    uint16_t *status;\n    bool_t need_iommu;\n\n    ld = current->domain;\n\n    if ( unlikely((op->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad flags in grant map op: %x\\n\", op->flags);\n        op->status = GNTST_bad_gntref;\n        return;\n    }\n\n    if ( unlikely(paging_mode_external(ld) &&\n                  (op->flags & (GNTMAP_device_map|GNTMAP_application_map|\n                            GNTMAP_contains_pte))) )\n    {\n        gdprintk(XENLOG_INFO, \"No device mapping in HVM domain\\n\");\n        op->status = GNTST_general_error;\n        return;\n    }\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(op->dom)) == NULL) )\n    {\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", op->dom);\n        op->status = GNTST_bad_domain;\n        return;\n    }\n\n    rc = xsm_grant_mapref(XSM_HOOK, ld, rd, op->flags);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    lgt = ld->grant_table;\n    handle = get_maptrack_handle(lgt);\n    if ( unlikely(handle == INVALID_MAPTRACK_HANDLE) )\n    {\n        rcu_unlock_domain(rd);\n        gdprintk(XENLOG_INFO, \"Failed to obtain maptrack handle\\n\");\n        op->status = GNTST_no_device_space;\n        return;\n    }\n\n    rgt = rd->grant_table;\n    grant_read_lock(rgt);\n\n    /* Bounds check on the grant ref */\n    ref = op->ref;\n    if ( unlikely(ref >= nr_grant_entries(rgt)))\n        PIN_FAIL(unlock_out, GNTST_bad_gntref, \"Bad ref %#x for d%d\\n\",\n                 ref, rgt->domain->domain_id);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, ref);\n    act = active_entry_acquire(rgt, ref);\n\n    /* Make sure we do not access memory speculatively */\n    status = evaluate_nospec(rgt->gt_version == 1) ? &shah->flags\n                                                 : &status_entry(rgt, ref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ld->domain_id) ||\n          (act->pin & 0x80808080U) != 0 ||\n          (act->is_sub_page)) )\n        PIN_FAIL(act_release_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x, or subpage %d\\n\",\n                 act->domid, ld->domain_id, act->pin, act->is_sub_page);\n\n    if ( !act->pin ||\n         (!(op->flags & GNTMAP_readonly) &&\n          !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               op->flags & GNTMAP_readonly, 1,\n                               ld->domain_id) != GNTST_okay) )\n            goto act_release_out;\n\n        if ( !act->pin )\n        {\n            unsigned long gfn = evaluate_nospec(rgt->gt_version == 1) ?\n                                shared_entry_v1(rgt, ref).frame :\n                                shared_entry_v2(rgt, ref).full_page.frame;\n\n            rc = get_paged_frame(gfn, &mfn, &pg,\n                                 op->flags & GNTMAP_readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            act->domid = ld->domain_id;\n            act->mfn = mfn;\n            act->start = 0;\n            act->length = PAGE_SIZE;\n            act->is_sub_page = false;\n            act->trans_domain = rd;\n            act->trans_gref = ref;\n        }\n    }\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    mfn = act->mfn;\n\n    cache_flags = (shah->flags & (GTF_PAT | GTF_PWT | GTF_PCD) );\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n\n    /* pg may be set, with a refcount included, from get_paged_frame(). */\n    if ( !pg )\n    {\n        pg = mfn_valid(mfn) ? mfn_to_page(mfn) : NULL;\n        if ( pg )\n            owner = page_get_owner_and_reference(pg);\n    }\n    else\n        owner = page_get_owner(pg);\n\n    if ( owner )\n        refcnt++;\n\n    if ( !pg || (owner == dom_io) )\n    {\n        /* Only needed the reference to confirm dom_io ownership. */\n        if ( pg )\n        {\n            put_page(pg);\n            refcnt--;\n        }\n\n        if ( paging_mode_external(ld) )\n        {\n            gdprintk(XENLOG_WARNING, \"HVM guests can't grant map iomem\\n\");\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( !iomem_access_permitted(rd, mfn_x(mfn), mfn_x(mfn)) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Iomem mapping not permitted %#\"PRI_mfn\" (domain %d)\\n\",\n                     mfn_x(mfn), rd->domain_id);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags,\n                                           cache_flags);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else if ( owner == rd || (dom_cow && owner == dom_cow) )\n    {\n        if ( (op->flags & GNTMAP_device_map) && !(op->flags & GNTMAP_readonly) )\n        {\n            if ( (owner == dom_cow) ||\n                 !get_page_type(pg, PGT_writable_page) )\n                goto could_not_pin;\n            typecnt++;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            /*\n             * Only need to grab another reference if device_map claimed\n             * the other one.\n             */\n            if ( op->flags & GNTMAP_device_map )\n            {\n                if ( !get_page(pg, rd) )\n                    goto could_not_pin;\n                refcnt++;\n            }\n\n            if ( gnttab_host_mapping_get_page_type(op->flags & GNTMAP_readonly,\n                                                   ld, rd) )\n            {\n                if ( (owner == dom_cow) ||\n                     !get_page_type(pg, PGT_writable_page) )\n                    goto could_not_pin;\n                typecnt++;\n            }\n\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags, 0);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else\n    {\n    could_not_pin:\n        if ( !rd->is_dying )\n            gdprintk(XENLOG_WARNING, \"Could not pin grant frame %#\"PRI_mfn\"\\n\",\n                     mfn_x(mfn));\n        rc = GNTST_general_error;\n        goto undo_out;\n    }\n\n    need_iommu = gnttab_need_iommu_mapping(ld);\n    if ( need_iommu )\n    {\n        unsigned int kind;\n\n        double_gt_lock(lgt, rgt);\n\n        /*\n         * We're not translated, so we know that dfns and mfns are\n         * the same things, so the IOMMU entry is always 1-to-1.\n         */\n        kind = mapkind(lgt, rd, mfn);\n        if ( !(op->flags & GNTMAP_readonly) &&\n             !(kind & MAPKIND_WRITE) )\n            kind = IOMMUF_readable | IOMMUF_writable;\n        else if ( !kind )\n            kind = IOMMUF_readable;\n        else\n            kind = 0;\n        if ( kind && iommu_legacy_map(ld, _dfn(mfn_x(mfn)), mfn, 0, kind) )\n        {\n            double_gt_unlock(lgt, rgt);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_MAP, op->dom);\n\n    /*\n     * All maptrack entry users check mt->flags first before using the\n     * other fields so just ensure the flags field is stored last.\n     *\n     * However, if gnttab_need_iommu_mapping() then this would race\n     * with a concurrent mapkind() call (on an unmap, for example)\n     * and a lock is required.\n     */\n    mt = &maptrack_entry(lgt, handle);\n    mt->domid = op->dom;\n    mt->ref   = op->ref;\n    smp_wmb();\n    write_atomic(&mt->flags, op->flags);\n\n    if ( need_iommu )\n        double_gt_unlock(lgt, rgt);\n\n    op->dev_bus_addr = mfn_to_maddr(mfn);\n    op->handle       = handle;\n    op->status       = GNTST_okay;\n\n    rcu_unlock_domain(rd);\n    return;\n\n undo_out:\n    if ( host_map_created )\n    {\n        replace_grant_host_mapping(op->host_addr, mfn, 0, op->flags);\n        gnttab_flush_tlb(ld);\n    }\n\n    while ( typecnt-- )\n        put_page_type(pg);\n\n    while ( refcnt-- )\n        put_page(pg);\n\n    grant_read_lock(rgt);\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n unlock_out_clear:\n    if ( !(op->flags & GNTMAP_readonly) &&\n         !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask)) )\n        clear_flags |= GTF_writing;\n\n    if ( !act->pin )\n        clear_flags |= GTF_reading;\n\n    if ( clear_flags )\n        gnttab_clear_flags(rd, clear_flags, status);\n\n act_release_out:\n    active_entry_release(act);\n\n unlock_out:\n    grant_read_unlock(rgt);\n    op->status = rc;\n    put_maptrack_handle(lgt, handle);\n    rcu_unlock_domain(rd);\n}",
        "func": "static void\nmap_grant_ref(\n    struct gnttab_map_grant_ref *op)\n{\n    struct domain *ld, *rd, *owner = NULL;\n    struct grant_table *lgt, *rgt;\n    grant_ref_t ref;\n    grant_handle_t handle;\n    mfn_t mfn;\n    struct page_info *pg = NULL;\n    int            rc = GNTST_okay;\n    unsigned int   cache_flags, clear_flags = 0, refcnt = 0, typecnt = 0;\n    bool           host_map_created = false;\n    struct active_grant_entry *act = NULL;\n    struct grant_mapping *mt;\n    grant_entry_header_t *shah;\n    uint16_t *status;\n    bool_t need_iommu;\n\n    ld = current->domain;\n\n    if ( unlikely((op->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad flags in grant map op: %x\\n\", op->flags);\n        op->status = GNTST_bad_gntref;\n        return;\n    }\n\n    if ( unlikely(paging_mode_external(ld) &&\n                  (op->flags & (GNTMAP_device_map|GNTMAP_application_map|\n                            GNTMAP_contains_pte))) )\n    {\n        gdprintk(XENLOG_INFO, \"No device mapping in HVM domain\\n\");\n        op->status = GNTST_general_error;\n        return;\n    }\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(op->dom)) == NULL) )\n    {\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", op->dom);\n        op->status = GNTST_bad_domain;\n        return;\n    }\n\n    rc = xsm_grant_mapref(XSM_HOOK, ld, rd, op->flags);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    lgt = ld->grant_table;\n    handle = get_maptrack_handle(lgt);\n    if ( unlikely(handle == INVALID_MAPTRACK_HANDLE) )\n    {\n        rcu_unlock_domain(rd);\n        gdprintk(XENLOG_INFO, \"Failed to obtain maptrack handle\\n\");\n        op->status = GNTST_no_device_space;\n        return;\n    }\n\n    rgt = rd->grant_table;\n    grant_read_lock(rgt);\n\n    /* Bounds check on the grant ref */\n    ref = op->ref;\n    if ( unlikely(ref >= nr_grant_entries(rgt)))\n        PIN_FAIL(unlock_out, GNTST_bad_gntref, \"Bad ref %#x for d%d\\n\",\n                 ref, rgt->domain->domain_id);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, ref);\n    act = active_entry_acquire(rgt, ref);\n\n    /* Make sure we do not access memory speculatively */\n    status = evaluate_nospec(rgt->gt_version == 1) ? &shah->flags\n                                                 : &status_entry(rgt, ref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ld->domain_id) ||\n          (act->pin & 0x80808080U) != 0 ||\n          (act->is_sub_page)) )\n        PIN_FAIL(act_release_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x, or subpage %d\\n\",\n                 act->domid, ld->domain_id, act->pin, act->is_sub_page);\n\n    if ( !act->pin ||\n         (!(op->flags & GNTMAP_readonly) &&\n          !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               op->flags & GNTMAP_readonly, 1,\n                               ld->domain_id)) != GNTST_okay )\n            goto act_release_out;\n\n        if ( !act->pin )\n        {\n            unsigned long gfn = evaluate_nospec(rgt->gt_version == 1) ?\n                                shared_entry_v1(rgt, ref).frame :\n                                shared_entry_v2(rgt, ref).full_page.frame;\n\n            rc = get_paged_frame(gfn, &mfn, &pg,\n                                 op->flags & GNTMAP_readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            act->domid = ld->domain_id;\n            act->mfn = mfn;\n            act->start = 0;\n            act->length = PAGE_SIZE;\n            act->is_sub_page = false;\n            act->trans_domain = rd;\n            act->trans_gref = ref;\n        }\n    }\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    mfn = act->mfn;\n\n    cache_flags = (shah->flags & (GTF_PAT | GTF_PWT | GTF_PCD) );\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n\n    /* pg may be set, with a refcount included, from get_paged_frame(). */\n    if ( !pg )\n    {\n        pg = mfn_valid(mfn) ? mfn_to_page(mfn) : NULL;\n        if ( pg )\n            owner = page_get_owner_and_reference(pg);\n    }\n    else\n        owner = page_get_owner(pg);\n\n    if ( owner )\n        refcnt++;\n\n    if ( !pg || (owner == dom_io) )\n    {\n        /* Only needed the reference to confirm dom_io ownership. */\n        if ( pg )\n        {\n            put_page(pg);\n            refcnt--;\n        }\n\n        if ( paging_mode_external(ld) )\n        {\n            gdprintk(XENLOG_WARNING, \"HVM guests can't grant map iomem\\n\");\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( !iomem_access_permitted(rd, mfn_x(mfn), mfn_x(mfn)) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Iomem mapping not permitted %#\"PRI_mfn\" (domain %d)\\n\",\n                     mfn_x(mfn), rd->domain_id);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags,\n                                           cache_flags);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else if ( owner == rd || (dom_cow && owner == dom_cow) )\n    {\n        if ( (op->flags & GNTMAP_device_map) && !(op->flags & GNTMAP_readonly) )\n        {\n            if ( (owner == dom_cow) ||\n                 !get_page_type(pg, PGT_writable_page) )\n                goto could_not_pin;\n            typecnt++;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            /*\n             * Only need to grab another reference if device_map claimed\n             * the other one.\n             */\n            if ( op->flags & GNTMAP_device_map )\n            {\n                if ( !get_page(pg, rd) )\n                    goto could_not_pin;\n                refcnt++;\n            }\n\n            if ( gnttab_host_mapping_get_page_type(op->flags & GNTMAP_readonly,\n                                                   ld, rd) )\n            {\n                if ( (owner == dom_cow) ||\n                     !get_page_type(pg, PGT_writable_page) )\n                    goto could_not_pin;\n                typecnt++;\n            }\n\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags, 0);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else\n    {\n    could_not_pin:\n        if ( !rd->is_dying )\n            gdprintk(XENLOG_WARNING, \"Could not pin grant frame %#\"PRI_mfn\"\\n\",\n                     mfn_x(mfn));\n        rc = GNTST_general_error;\n        goto undo_out;\n    }\n\n    need_iommu = gnttab_need_iommu_mapping(ld);\n    if ( need_iommu )\n    {\n        unsigned int kind;\n\n        double_gt_lock(lgt, rgt);\n\n        /*\n         * We're not translated, so we know that dfns and mfns are\n         * the same things, so the IOMMU entry is always 1-to-1.\n         */\n        kind = mapkind(lgt, rd, mfn);\n        if ( !(op->flags & GNTMAP_readonly) &&\n             !(kind & MAPKIND_WRITE) )\n            kind = IOMMUF_readable | IOMMUF_writable;\n        else if ( !kind )\n            kind = IOMMUF_readable;\n        else\n            kind = 0;\n        if ( kind && iommu_legacy_map(ld, _dfn(mfn_x(mfn)), mfn, 0, kind) )\n        {\n            double_gt_unlock(lgt, rgt);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_MAP, op->dom);\n\n    /*\n     * All maptrack entry users check mt->flags first before using the\n     * other fields so just ensure the flags field is stored last.\n     *\n     * However, if gnttab_need_iommu_mapping() then this would race\n     * with a concurrent mapkind() call (on an unmap, for example)\n     * and a lock is required.\n     */\n    mt = &maptrack_entry(lgt, handle);\n    mt->domid = op->dom;\n    mt->ref   = op->ref;\n    smp_wmb();\n    write_atomic(&mt->flags, op->flags);\n\n    if ( need_iommu )\n        double_gt_unlock(lgt, rgt);\n\n    op->dev_bus_addr = mfn_to_maddr(mfn);\n    op->handle       = handle;\n    op->status       = GNTST_okay;\n\n    rcu_unlock_domain(rd);\n    return;\n\n undo_out:\n    if ( host_map_created )\n    {\n        replace_grant_host_mapping(op->host_addr, mfn, 0, op->flags);\n        gnttab_flush_tlb(ld);\n    }\n\n    while ( typecnt-- )\n        put_page_type(pg);\n\n    while ( refcnt-- )\n        put_page(pg);\n\n    grant_read_lock(rgt);\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n unlock_out_clear:\n    if ( !(op->flags & GNTMAP_readonly) &&\n         !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask)) )\n        clear_flags |= GTF_writing;\n\n    if ( !act->pin )\n        clear_flags |= GTF_reading;\n\n    if ( clear_flags )\n        gnttab_clear_flags(rd, clear_flags, status);\n\n act_release_out:\n    active_entry_release(act);\n\n unlock_out:\n    grant_read_unlock(rgt);\n    op->status = rc;\n    put_maptrack_handle(lgt, handle);\n    rcu_unlock_domain(rd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -92,7 +92,7 @@\n     {\n         if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                                op->flags & GNTMAP_readonly, 1,\n-                               ld->domain_id) != GNTST_okay) )\n+                               ld->domain_id)) != GNTST_okay )\n             goto act_release_out;\n \n         if ( !act->pin )",
        "diff_line_info": {
            "deleted_lines": [
                "                               ld->domain_id) != GNTST_okay) )"
            ],
            "added_lines": [
                "                               ld->domain_id)) != GNTST_okay )"
            ]
        }
    }
]