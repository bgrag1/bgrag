[
    {
        "cve_id": "CVE-2018-19134",
        "func_name": "ArtifexSoftware/ghostpdl/zsetcolor",
        "description": "In Artifex Ghostscript through 9.25, the setpattern operator did not properly validate certain types. A specially crafted PostScript document could exploit this to crash Ghostscript or, possibly, execute arbitrary code in the context of the Ghostscript process. This is a type confusion issue because of failure to check whether the Implementation of a pattern dictionary was a structure type.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/693baf02152119af6e6afd30bb8ec76d14f84bbf",
        "commit_title": "PS interpreter - check the Implementation of a Pattern before use",
        "commit_text": " Bug #700141 \"Type confusion in setpattern\"  As the bug thread says, we were not checking that the Implementation of a pattern dictionary was a structure type, leading to a crash when we tried to treat it as one.  Here we make the st_pattern1_instance and st_pattern2_instance structures public definitions and in zsetcolor we check the object stored under the Implementation key in the supplied dictionary to see if its a t_struct or t_astruct type, and if it is that its a st_pattern1_instance or st_pattern2_instance structure.  If either check fails we throw a typecheck error.  We need to make the st_pattern1_instance and st_pattern2_instance definitions public as they are defined in the graphics library and we need to check in the interpreter.",
        "func_before": "static int\nzsetcolor(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    es_ptr ep;\n    const gs_color_space *  pcs = gs_currentcolorspace(igs);\n    gs_client_color         cc;\n    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;\n    PS_colour_space_t *space;\n\n    /* initialize the client color pattern pointer for GC */\n    cc.pattern = 0;\n\n    /* check for a pattern color space */\n    if ((n_comps = cs_num_components(pcs)) < 0) {\n        n_comps = -n_comps;\n        if (r_has_type(op, t_dictionary)) {\n            ref     *pImpl, pPatInst;\n\n            if ((code = dict_find_string(op, \"Implementation\", &pImpl)) < 0)\n                return code;\n            if (code > 0) {\n                code = array_get(imemory, pImpl, 0, &pPatInst);\n                if (code < 0)\n                    return code;\n                cc.pattern = r_ptr(&pPatInst, gs_pattern_instance_t);\n                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)\n                      ? n_comps - 1\n                      : 0 );\n            } else\n                n_numeric_comps = 0;\n        } else\n            n_numeric_comps = 0;\n        num_offset = 1;\n    } else\n        n_numeric_comps = n_comps;\n\n    /* gather the numeric operands */\n    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);\n    if (code < 0)\n        return code;\n    /* The values are copied to graphic state and compared with */\n    /* other colors by memcmp() in gx_hld_saved_color_equal()   */\n    /* This is the easiest way to avoid indeterminism */\n    memset(cc.paint.values + n_numeric_comps, 0,\n            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);\n\n    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);\n    if (code < 0)\n        return code;\n    if (space->validatecomponents) {\n        code = space->validatecomponents(i_ctx_p,\n                                         &istate->colorspace[0].array,\n                                         cc.paint.values, n_numeric_comps);\n        if (code < 0)\n            return code;\n    }\n\n    /* pass the color to the graphic library */\n    if ((code = gs_setcolor(igs, &cc)) >= 0) {\n\n        if (n_comps > n_numeric_comps) {\n            istate->pattern[0] = *op;      /* save pattern dict or null */\n        }\n    }\n\n    /* Check the color spaces, to see if we need to run any tint transform\n     * procedures. Some Adobe applications *eg Photoshop) expect that the\n     * tint transform will be run and use this to set up duotone DeviceN\n     * spaces.\n     */\n    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);\n    if (code < 0)\n        return code;\n    /* Set up for the continuation procedure which will do the work */\n    /* Make sure the exec stack has enough space */\n    check_estack(5);\n    /* A place holder for data potentially used by transform functions */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store the 'depth' of the space returned during checking above */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store the 'stage' of processing (initially 0) */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store a pointer to the color space stored on the operand stack\n     * as the stack may grow unpredictably making further access\n     * to the space difficult\n     */\n    ep = esp += 1;\n    *ep = istate->colorspace[0].array;\n    /* Finally, the actual continuation routine */\n    push_op_estack(setcolor_cont);\n    return o_push_estack;\n}",
        "func": "static int\nzsetcolor(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    es_ptr ep;\n    const gs_color_space *  pcs = gs_currentcolorspace(igs);\n    gs_client_color         cc;\n    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;\n    PS_colour_space_t *space;\n\n    /* initialize the client color pattern pointer for GC */\n    cc.pattern = 0;\n\n    /* check for a pattern color space */\n    if ((n_comps = cs_num_components(pcs)) < 0) {\n        n_comps = -n_comps;\n        if (r_has_type(op, t_dictionary)) {\n            ref     *pImpl, pPatInst;\n\n            if ((code = dict_find_string(op, \"Implementation\", &pImpl)) < 0)\n                return code;\n            if (code > 0) {\n                code = array_get(imemory, pImpl, 0, &pPatInst);\n                if (code < 0)\n                    return code;\n                if (!r_is_struct(&pPatInst) || (!r_has_stype(&pPatInst, imemory, st_pattern1_instance) && !r_has_stype(&pPatInst, imemory, st_pattern2_instance)))\n                    return_error(gs_error_typecheck);\n\n                cc.pattern = r_ptr(&pPatInst, gs_pattern_instance_t);\n                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)\n                      ? n_comps - 1\n                      : 0 );\n            } else\n                n_numeric_comps = 0;\n        } else\n            n_numeric_comps = 0;\n        num_offset = 1;\n    } else\n        n_numeric_comps = n_comps;\n\n    /* gather the numeric operands */\n    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);\n    if (code < 0)\n        return code;\n    /* The values are copied to graphic state and compared with */\n    /* other colors by memcmp() in gx_hld_saved_color_equal()   */\n    /* This is the easiest way to avoid indeterminism */\n    memset(cc.paint.values + n_numeric_comps, 0,\n            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);\n\n    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);\n    if (code < 0)\n        return code;\n    if (space->validatecomponents) {\n        code = space->validatecomponents(i_ctx_p,\n                                         &istate->colorspace[0].array,\n                                         cc.paint.values, n_numeric_comps);\n        if (code < 0)\n            return code;\n    }\n\n    /* pass the color to the graphic library */\n    if ((code = gs_setcolor(igs, &cc)) >= 0) {\n\n        if (n_comps > n_numeric_comps) {\n            istate->pattern[0] = *op;      /* save pattern dict or null */\n        }\n    }\n\n    /* Check the color spaces, to see if we need to run any tint transform\n     * procedures. Some Adobe applications *eg Photoshop) expect that the\n     * tint transform will be run and use this to set up duotone DeviceN\n     * spaces.\n     */\n    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);\n    if (code < 0)\n        return code;\n    /* Set up for the continuation procedure which will do the work */\n    /* Make sure the exec stack has enough space */\n    check_estack(5);\n    /* A place holder for data potentially used by transform functions */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store the 'depth' of the space returned during checking above */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store the 'stage' of processing (initially 0) */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store a pointer to the color space stored on the operand stack\n     * as the stack may grow unpredictably making further access\n     * to the space difficult\n     */\n    ep = esp += 1;\n    *ep = istate->colorspace[0].array;\n    /* Finally, the actual continuation routine */\n    push_op_estack(setcolor_cont);\n    return o_push_estack;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,9 @@\n                 code = array_get(imemory, pImpl, 0, &pPatInst);\n                 if (code < 0)\n                     return code;\n+                if (!r_is_struct(&pPatInst) || (!r_has_stype(&pPatInst, imemory, st_pattern1_instance) && !r_has_stype(&pPatInst, imemory, st_pattern2_instance)))\n+                    return_error(gs_error_typecheck);\n+\n                 cc.pattern = r_ptr(&pPatInst, gs_pattern_instance_t);\n                 n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)\n                       ? n_comps - 1",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if (!r_is_struct(&pPatInst) || (!r_has_stype(&pPatInst, imemory, st_pattern1_instance) && !r_has_stype(&pPatInst, imemory, st_pattern2_instance)))",
                "                    return_error(gs_error_typecheck);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19134",
        "func_name": "ArtifexSoftware/ghostpdl/iccompareproc",
        "description": "In Artifex Ghostscript through 9.25, the setpattern operator did not properly validate certain types. A specially crafted PostScript document could exploit this to crash Ghostscript or, possibly, execute arbitrary code in the context of the Ghostscript process. This is a type confusion issue because of failure to check whether the Implementation of a pattern dictionary was a structure type.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/693baf02152119af6e6afd30bb8ec76d14f84bbf",
        "commit_title": "PS interpreter - check the Implementation of a Pattern before use",
        "commit_text": " Bug #700141 \"Type confusion in setpattern\"  As the bug thread says, we were not checking that the Implementation of a pattern dictionary was a structure type, leading to a crash when we tried to treat it as one.  Here we make the st_pattern1_instance and st_pattern2_instance structures public definitions and in zsetcolor we check the object stored under the Implementation key in the supplied dictionary to see if its a t_struct or t_astruct type, and if it is that its a st_pattern1_instance or st_pattern2_instance structure.  If either check fails we throw a typecheck error.  We need to make the st_pattern1_instance and st_pattern2_instance definitions public as they are defined in the graphics library and we need to check in the interpreter.",
        "func_before": "static int iccompareproc(i_ctx_t *i_ctx_p, ref *space, ref *testspace)\n{\n    int code1, code2;\n    ref ICCdict1, ICCdict2, *tempref1, *tempref2;\n    int buff_size;\n\n    code1 = array_get(imemory, space, 1, &ICCdict1);\n    if (code1 < 0)\n        return 0;\n    code2 = array_get(imemory, testspace, 1, &ICCdict2);\n    if (code2 < 0)\n        return 0;\n\n    /* As a quick check see if current is same as new */\n    if (ICCdict1.value.bytes == ICCdict2.value.bytes) \n         return 1;\n\n    /* Need to check all the various parts */\n    code1 = dict_find_string(&ICCdict1, \"N\", &tempref1);\n    code2 = dict_find_string(&ICCdict2, \"N\", &tempref2);\n    if (code1 != code2)\n        return 0;\n    if (tempref1->value.intval != tempref2->value.intval)\n        return 0;\n\n    if (!comparedictkey(i_ctx_p, &ICCdict1, &ICCdict2, (char *)\"Range\"))\n        return 0;\n\n    code1 = dict_find_string(&ICCdict1, \"DataSource\", &tempref1);\n    if (code1 <= 0)\n        return 0;\n    code2 = dict_find_string(&ICCdict2, \"DataSource\", &tempref2);\n    if (code2 <= 0)\n        return 0;\n    if (r_size(tempref1) != r_size(tempref2)) \n        return 0;\n\n    buff_size = r_size(tempref1);\n    if (memcmp(tempref1->value.const_bytes, tempref2->value.const_bytes, buff_size) == 0)\n        return 1;\n    else\n        return 0;\n}",
        "func": "static int iccompareproc(i_ctx_t *i_ctx_p, ref *space, ref *testspace)\n{\n    int code1, code2;\n    ref ICCdict1, ICCdict2, *tempref1, *tempref2;\n    int buff_size;\n\n    code1 = array_get(imemory, space, 1, &ICCdict1);\n    if (code1 < 0)\n        return 0;\n    code2 = array_get(imemory, testspace, 1, &ICCdict2);\n    if (code2 < 0)\n        return 0;\n\n    /* As a quick check see if current is same as new */\n    if (ICCdict1.value.bytes == ICCdict2.value.bytes)\n         return 1;\n\n    /* Need to check all the various parts */\n    code1 = dict_find_string(&ICCdict1, \"N\", &tempref1);\n    code2 = dict_find_string(&ICCdict2, \"N\", &tempref2);\n    if (code1 != code2)\n        return 0;\n    if (tempref1->value.intval != tempref2->value.intval)\n        return 0;\n\n    if (!comparedictkey(i_ctx_p, &ICCdict1, &ICCdict2, (char *)\"Range\"))\n        return 0;\n\n    code1 = dict_find_string(&ICCdict1, \"DataSource\", &tempref1);\n    if (code1 <= 0)\n        return 0;\n    code2 = dict_find_string(&ICCdict2, \"DataSource\", &tempref2);\n    if (code2 <= 0)\n        return 0;\n    if (r_size(tempref1) != r_size(tempref2))\n        return 0;\n\n    buff_size = r_size(tempref1);\n    if (memcmp(tempref1->value.const_bytes, tempref2->value.const_bytes, buff_size) == 0)\n        return 1;\n    else\n        return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n         return 0;\n \n     /* As a quick check see if current is same as new */\n-    if (ICCdict1.value.bytes == ICCdict2.value.bytes) \n+    if (ICCdict1.value.bytes == ICCdict2.value.bytes)\n          return 1;\n \n     /* Need to check all the various parts */\n@@ -32,7 +32,7 @@\n     code2 = dict_find_string(&ICCdict2, \"DataSource\", &tempref2);\n     if (code2 <= 0)\n         return 0;\n-    if (r_size(tempref1) != r_size(tempref2)) \n+    if (r_size(tempref1) != r_size(tempref2))\n         return 0;\n \n     buff_size = r_size(tempref1);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ICCdict1.value.bytes == ICCdict2.value.bytes) ",
                "    if (r_size(tempref1) != r_size(tempref2)) "
            ],
            "added_lines": [
                "    if (ICCdict1.value.bytes == ICCdict2.value.bytes)",
                "    if (r_size(tempref1) != r_size(tempref2))"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19134",
        "func_name": "ArtifexSoftware/ghostpdl/setindexedspace",
        "description": "In Artifex Ghostscript through 9.25, the setpattern operator did not properly validate certain types. A specially crafted PostScript document could exploit this to crash Ghostscript or, possibly, execute arbitrary code in the context of the Ghostscript process. This is a type confusion issue because of failure to check whether the Implementation of a pattern dictionary was a structure type.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/693baf02152119af6e6afd30bb8ec76d14f84bbf",
        "commit_title": "PS interpreter - check the Implementation of a Pattern before use",
        "commit_text": " Bug #700141 \"Type confusion in setpattern\"  As the bug thread says, we were not checking that the Implementation of a pattern dictionary was a structure type, leading to a crash when we tried to treat it as one.  Here we make the st_pattern1_instance and st_pattern2_instance structures public definitions and in zsetcolor we check the object stored under the Implementation key in the supplied dictionary to see if its a t_struct or t_astruct type, and if it is that its a st_pattern1_instance or st_pattern2_instance structure.  If either check fails we throw a typecheck error.  We need to make the st_pattern1_instance and st_pattern2_instance definitions public as they are defined in the graphics library and we need to check in the interpreter.",
        "func_before": "static int setindexedspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CIESubst)\n{\n    ref *pproc = &istate->colorspace[0].procs.special.index_proc;\n    int code = 0;\n    uint edepth = ref_stack_count(&e_stack);\n    ref_colorspace cspace_old;\n    ref hival, lookup;\n    gs_color_space *pcs;\n    gs_color_space *pcs_base;\n    gs_color_space_index base_type;\n\n    if (i_ctx_p->language_level < 2)\n        return_error(gs_error_undefined);\n\n    *cont = 0;\n    if (*stage == 1) {\n        *stage = 0;\n        return 0;\n    }\n\n    cspace_old = istate->colorspace[0];\n\n    pcs_base = gs_currentcolorspace(igs);\n    base_type = gs_color_space_get_index(pcs_base);\n\n    code = array_get(imemory, r, 3, &lookup);\n    if (code < 0)\n        return code;\n    code = array_get(imemory, r, 2, &hival);\n    if (code < 0)\n        return code;\n    if (r_has_type(&lookup, t_string)) {\n        int num_values = (hival.value.intval + 1) * cs_num_components(pcs_base);\n        byte *data_tmp;\n\n        check_read(lookup);\n        /*\n         * The PDF and PS specifications state that the lookup table must have\n         * the exact number of of data bytes needed.  However we have found\n         * PDF files from Amyuni with extra data bytes.  Acrobat 6.0 accepts\n         * these files without complaint, so we ignore the extra data.\n         */\n        if (r_size(&lookup) < num_values)\n            return_error(gs_error_rangecheck);\n        /* If we have a named color profile and the base space is DeviceN or\n           Separation use a different set of procedures to ensure the named\n           color remapping code is used */\n        if (igs->icc_manager->device_named != NULL && \n            (base_type == gs_color_space_index_Separation ||\n             base_type == gs_color_space_index_DeviceN))\n            pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed_Named);\n        else\n            pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed);\n        if (!pcs) {\n            return_error(gs_error_VMerror);\n        }\n        pcs->base_space = pcs_base;\n        rc_increment_cs(pcs_base);\n\n        data_tmp = (byte *) (pcs->params.indexed.lookup.table.data = ialloc_string (lookup.tas.rsize, \"setindexedspace\"));\n        if (!data_tmp) {\n            rc_decrement(pcs, \"setindexedspace\");\n            return_error(gs_error_VMerror);\n        }\n\n        memcpy(data_tmp, lookup.value.const_bytes, lookup.tas.rsize);\n\n        pcs->params.indexed.lookup.table.size = num_values;\n        pcs->params.indexed.use_proc = 0;\n        make_null(pproc);\n    } else {\n        gs_indexed_map *map;\n\n        /*\n         * We have to call zcs_begin_map before moving the parameters,\n         * since if the color space is a DeviceN or Separation space,\n         * the memmove will overwrite its parameters.\n         */\n        code = zcs_begin_map(i_ctx_p, &map, &lookup, (hival.value.intval + 1),\n                             pcs_base, indexed_cont);\n        if (code < 0)\n            return code;\n        if (igs->icc_manager->device_named != NULL &&\n            (base_type == gs_color_space_index_Separation ||\n             base_type == gs_color_space_index_DeviceN))\n            pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed_Named);\n        else\n            pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed);\n        pcs->base_space = pcs_base;\n        rc_increment_cs(pcs_base);\n        pcs->params.indexed.use_proc = 1;\n        *pproc = lookup;\n        map->proc.lookup_index = lookup_indexed_map;\n        pcs->params.indexed.lookup.map = map;\n    }\n    pcs->params.indexed.hival = hival.value.intval;\n    pcs->params.indexed.n_comps = cs_num_components(pcs_base);\n    code = gs_setcolorspace(igs, pcs);\n    /* release reference from construction */\n    rc_decrement_only_cs(pcs, \"setindexedspace\");\n    if (code < 0) {\n        istate->colorspace[0] = cspace_old;\n        ref_stack_pop_to(&e_stack, edepth);\n        return code;\n    }\n    *stage = 0;\n    if (ref_stack_count(&e_stack) == edepth) {\n        return 0;\n    } else {\n        *cont = 1;\n        *stage = 1;\n        return o_push_estack; /* installation will load the caches */\n    }\n}",
        "func": "static int setindexedspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CIESubst)\n{\n    ref *pproc = &istate->colorspace[0].procs.special.index_proc;\n    int code = 0;\n    uint edepth = ref_stack_count(&e_stack);\n    ref_colorspace cspace_old;\n    ref hival, lookup;\n    gs_color_space *pcs;\n    gs_color_space *pcs_base;\n    gs_color_space_index base_type;\n\n    if (i_ctx_p->language_level < 2)\n        return_error(gs_error_undefined);\n\n    *cont = 0;\n    if (*stage == 1) {\n        *stage = 0;\n        return 0;\n    }\n\n    cspace_old = istate->colorspace[0];\n\n    pcs_base = gs_currentcolorspace(igs);\n    base_type = gs_color_space_get_index(pcs_base);\n\n    code = array_get(imemory, r, 3, &lookup);\n    if (code < 0)\n        return code;\n    code = array_get(imemory, r, 2, &hival);\n    if (code < 0)\n        return code;\n    if (r_has_type(&lookup, t_string)) {\n        int num_values = (hival.value.intval + 1) * cs_num_components(pcs_base);\n        byte *data_tmp;\n\n        check_read(lookup);\n        /*\n         * The PDF and PS specifications state that the lookup table must have\n         * the exact number of of data bytes needed.  However we have found\n         * PDF files from Amyuni with extra data bytes.  Acrobat 6.0 accepts\n         * these files without complaint, so we ignore the extra data.\n         */\n        if (r_size(&lookup) < num_values)\n            return_error(gs_error_rangecheck);\n        /* If we have a named color profile and the base space is DeviceN or\n           Separation use a different set of procedures to ensure the named\n           color remapping code is used */\n        if (igs->icc_manager->device_named != NULL &&\n            (base_type == gs_color_space_index_Separation ||\n             base_type == gs_color_space_index_DeviceN))\n            pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed_Named);\n        else\n            pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed);\n        if (!pcs) {\n            return_error(gs_error_VMerror);\n        }\n        pcs->base_space = pcs_base;\n        rc_increment_cs(pcs_base);\n\n        data_tmp = (byte *) (pcs->params.indexed.lookup.table.data = ialloc_string (lookup.tas.rsize, \"setindexedspace\"));\n        if (!data_tmp) {\n            rc_decrement(pcs, \"setindexedspace\");\n            return_error(gs_error_VMerror);\n        }\n\n        memcpy(data_tmp, lookup.value.const_bytes, lookup.tas.rsize);\n\n        pcs->params.indexed.lookup.table.size = num_values;\n        pcs->params.indexed.use_proc = 0;\n        make_null(pproc);\n    } else {\n        gs_indexed_map *map;\n\n        /*\n         * We have to call zcs_begin_map before moving the parameters,\n         * since if the color space is a DeviceN or Separation space,\n         * the memmove will overwrite its parameters.\n         */\n        code = zcs_begin_map(i_ctx_p, &map, &lookup, (hival.value.intval + 1),\n                             pcs_base, indexed_cont);\n        if (code < 0)\n            return code;\n        if (igs->icc_manager->device_named != NULL &&\n            (base_type == gs_color_space_index_Separation ||\n             base_type == gs_color_space_index_DeviceN))\n            pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed_Named);\n        else\n            pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed);\n        pcs->base_space = pcs_base;\n        rc_increment_cs(pcs_base);\n        pcs->params.indexed.use_proc = 1;\n        *pproc = lookup;\n        map->proc.lookup_index = lookup_indexed_map;\n        pcs->params.indexed.lookup.map = map;\n    }\n    pcs->params.indexed.hival = hival.value.intval;\n    pcs->params.indexed.n_comps = cs_num_components(pcs_base);\n    code = gs_setcolorspace(igs, pcs);\n    /* release reference from construction */\n    rc_decrement_only_cs(pcs, \"setindexedspace\");\n    if (code < 0) {\n        istate->colorspace[0] = cspace_old;\n        ref_stack_pop_to(&e_stack, edepth);\n        return code;\n    }\n    *stage = 0;\n    if (ref_stack_count(&e_stack) == edepth) {\n        return 0;\n    } else {\n        *cont = 1;\n        *stage = 1;\n        return o_push_estack; /* installation will load the caches */\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n         /* If we have a named color profile and the base space is DeviceN or\n            Separation use a different set of procedures to ensure the named\n            color remapping code is used */\n-        if (igs->icc_manager->device_named != NULL && \n+        if (igs->icc_manager->device_named != NULL &&\n             (base_type == gs_color_space_index_Separation ||\n              base_type == gs_color_space_index_DeviceN))\n             pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Indexed_Named);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (igs->icc_manager->device_named != NULL && "
            ],
            "added_lines": [
                "        if (igs->icc_manager->device_named != NULL &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19134",
        "func_name": "ArtifexSoftware/ghostpdl/gs_pattern2_set_color",
        "description": "In Artifex Ghostscript through 9.25, the setpattern operator did not properly validate certain types. A specially crafted PostScript document could exploit this to crash Ghostscript or, possibly, execute arbitrary code in the context of the Ghostscript process. This is a type confusion issue because of failure to check whether the Implementation of a pattern dictionary was a structure type.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/693baf02152119af6e6afd30bb8ec76d14f84bbf",
        "commit_title": "PS interpreter - check the Implementation of a Pattern before use",
        "commit_text": " Bug #700141 \"Type confusion in setpattern\"  As the bug thread says, we were not checking that the Implementation of a pattern dictionary was a structure type, leading to a crash when we tried to treat it as one.  Here we make the st_pattern1_instance and st_pattern2_instance structures public definitions and in zsetcolor we check the object stored under the Implementation key in the supplied dictionary to see if its a t_struct or t_astruct type, and if it is that its a st_pattern1_instance or st_pattern2_instance structure.  If either check fails we throw a typecheck error.  We need to make the st_pattern1_instance and st_pattern2_instance definitions public as they are defined in the graphics library and we need to check in the interpreter.",
        "func_before": "static int\ngs_pattern2_set_color(const gs_client_color * pcc, gs_gstate * pgs)\n{\n    gs_pattern2_instance_t * pinst = (gs_pattern2_instance_t *)pcc->pattern;\n    gs_color_space * pcs = pinst->templat.Shading->params.ColorSpace;\n    int code;\n    uchar k, num_comps;\n\n    pinst->saved->overprint_mode = pgs->overprint_mode;\n    pinst->saved->overprint = pgs->overprint;\n    \n    num_comps = pgs->device->color_info.num_components;\n    for (k = 0; k < num_comps; k++) {\n        pgs->color_component_map.color_map[k] = \n            pinst->saved->color_component_map.color_map[k];\n    }\n    code = pcs->type->set_overprint(pcs, pgs);\n    return code;\n}",
        "func": "static int\ngs_pattern2_set_color(const gs_client_color * pcc, gs_gstate * pgs)\n{\n    gs_pattern2_instance_t * pinst = (gs_pattern2_instance_t *)pcc->pattern;\n    gs_color_space * pcs = pinst->templat.Shading->params.ColorSpace;\n    int code;\n    uchar k, num_comps;\n\n    pinst->saved->overprint_mode = pgs->overprint_mode;\n    pinst->saved->overprint = pgs->overprint;\n\n    num_comps = pgs->device->color_info.num_components;\n    for (k = 0; k < num_comps; k++) {\n        pgs->color_component_map.color_map[k] =\n            pinst->saved->color_component_map.color_map[k];\n    }\n    code = pcs->type->set_overprint(pcs, pgs);\n    return code;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,10 +8,10 @@\n \n     pinst->saved->overprint_mode = pgs->overprint_mode;\n     pinst->saved->overprint = pgs->overprint;\n-    \n+\n     num_comps = pgs->device->color_info.num_components;\n     for (k = 0; k < num_comps; k++) {\n-        pgs->color_component_map.color_map[k] = \n+        pgs->color_component_map.color_map[k] =\n             pinst->saved->color_component_map.color_map[k];\n     }\n     code = pcs->type->set_overprint(pcs, pgs);",
        "diff_line_info": {
            "deleted_lines": [
                "    ",
                "        pgs->color_component_map.color_map[k] = "
            ],
            "added_lines": [
                "",
                "        pgs->color_component_map.color_map[k] ="
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7398",
        "func_name": "m6w6/ext-http/merge_param",
        "description": "A type confusion vulnerability in the merge_param() function of php_http_params.c in PHP's pecl-http extension 3.1.0beta2 (PHP 7) and earlier as well as 2.6.0beta2 (PHP 5) and earlier allows attackers to crash PHP and possibly execute arbitrary code via crafted HTTP requests.",
        "git_url": "https://github.com/m6w6/ext-http/commit/17137d4ab1ce81a2cee0fae842340a344ef3da83",
        "commit_title": "fix bug #73055",
        "commit_text": "",
        "func_before": "static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)\n{\n\tzval **ptr, **zdata_ptr;\n\tphp_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);\n\n#if 0\n\t{\n\t\tzval tmp;\n\t\tINIT_PZVAL_ARRAY(&tmp, params);\n\t\tfprintf(stderr, \"params = \");\n\t\tzend_print_zval_r(&tmp, 1 TSRMLS_CC);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n\n\thkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);\n\n\tif ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))\n\t||\t(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))\n\t) {\n\t\tzval *tmp, *arg, **args;\n\n\t\t/* create the entry if it doesn't exist */\n\t\tzend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);\n\t\tZ_ADDREF_PP(ptr);\n\t\tMAKE_STD_ZVAL(tmp);\n\t\tarray_init(tmp);\n\t\tadd_assoc_zval_ex(tmp, ZEND_STRS(\"value\"), *ptr);\n\n\t\tMAKE_STD_ZVAL(arg);\n\t\tarray_init(arg);\n\t\tzend_hash_update(Z_ARRVAL_P(tmp), \"arguments\", sizeof(\"arguments\"), (void *) &arg, sizeof(zval *), (void *) &args);\n\t\t*current_args = args;\n\n\t\tif (hkey.type == HASH_KEY_IS_STRING) {\n\t\t\tzend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);\n\t\t} else {\n\t\t\tzend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);\n\t\t}\n\t} else {\n\t\t/* merge */\n\t\tif (hkey.type == HASH_KEY_IS_STRING) {\n\t\t\tzend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);\n\t\t} else {\n\t\t\tzend_hash_index_find(params, hkey.num, (void *) &ptr);\n\t\t}\n\n\t\tzdata_ptr = &zdata;\n\n\t\tif (Z_TYPE_PP(ptr) == IS_ARRAY\n\t\t&&\tSUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), \"value\", sizeof(\"value\"), (void *) &ptr)\n\t\t&&\tSUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)\n\t\t) {\n\t\t\t/*\n\t\t\t * params = [arr => [value => [0 => 1]]]\n\t\t\t *                            ^- ptr\n\t\t\t * zdata  = [arr => [0 => NULL]]\n\t\t\t *                  ^- zdata_ptr\n\t\t\t */\n\t\t\tzval **test_ptr;\n\n\t\t\twhile (Z_TYPE_PP(zdata_ptr) == IS_ARRAY\n\t\t\t&&\tSUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)\n\t\t\t) {\n\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY) {\n\n\t\t\t\t\t/* now find key in ptr */\n\t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {\n\t\t\t\t\t\tif (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {\n\t\t\t\t\t\t\tzdata_ptr = test_ptr;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tZ_ADDREF_PP(test_ptr);\n\t\t\t\t\t\t\tzend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {\n\t\t\t\t\t\t\tzdata_ptr = test_ptr;\n\t\t\t\t\t\t} else if (hkey.num) {\n\t\t\t\t\t\t\tZ_ADDREF_PP(test_ptr);\n\t\t\t\t\t\t\tzend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tZ_ADDREF_PP(test_ptr);\n\t\t\t\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* this is the leaf */\n\t\t\t\t\tZ_ADDREF_PP(test_ptr);\n\t\t\t\t\tif (Z_TYPE_PP(ptr) != IS_ARRAY) {\n\t\t\t\t\t\tzval_dtor(*ptr);\n\t\t\t\t\t\tarray_init(*ptr);\n\t\t\t\t\t}\n\t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {\n\t\t\t\t\t\tzend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t} else if (hkey.num) {\n\t\t\t\t\t\tzend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/* bubble up */\n\twhile (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));\n\t*current_param = ptr;\n}",
        "func": "static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)\n{\n\tzval **ptr, **zdata_ptr;\n\tphp_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);\n\n#if 0\n\t{\n\t\tzval tmp;\n\t\tINIT_PZVAL_ARRAY(&tmp, params);\n\t\tfprintf(stderr, \"params = \");\n\t\tzend_print_zval_r(&tmp, 1 TSRMLS_CC);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n\n\thkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);\n\n\tif ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))\n\t||\t(hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))\n\t) {\n\t\tzval *tmp, *arg, **args;\n\n\t\t/* create the entry if it doesn't exist */\n\t\tzend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);\n\t\tZ_ADDREF_PP(ptr);\n\t\tMAKE_STD_ZVAL(tmp);\n\t\tarray_init(tmp);\n\t\tadd_assoc_zval_ex(tmp, ZEND_STRS(\"value\"), *ptr);\n\n\t\tMAKE_STD_ZVAL(arg);\n\t\tarray_init(arg);\n\t\tzend_hash_update(Z_ARRVAL_P(tmp), \"arguments\", sizeof(\"arguments\"), (void *) &arg, sizeof(zval *), (void *) &args);\n\t\t*current_args = args;\n\n\t\tif (hkey.type == HASH_KEY_IS_STRING) {\n\t\t\tzend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);\n\t\t} else {\n\t\t\tzend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);\n\t\t}\n\t} else {\n\t\t/* merge */\n\t\tif (hkey.type == HASH_KEY_IS_STRING) {\n\t\t\tzend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);\n\t\t} else {\n\t\t\tzend_hash_index_find(params, hkey.num, (void *) &ptr);\n\t\t}\n\n\t\tzdata_ptr = &zdata;\n\n\t\tif (Z_TYPE_PP(ptr) == IS_ARRAY\n\t\t&&\tSUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), \"value\", sizeof(\"value\"), (void *) &ptr)\n\t\t&&\tSUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)\n\t\t) {\n\t\t\t/*\n\t\t\t * params = [arr => [value => [0 => 1]]]\n\t\t\t *                            ^- ptr\n\t\t\t * zdata  = [arr => [0 => NULL]]\n\t\t\t *                  ^- zdata_ptr\n\t\t\t */\n\t\t\tzval **test_ptr;\n\n\t\t\twhile (Z_TYPE_PP(zdata_ptr) == IS_ARRAY\n\t\t\t&&\tSUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)\n\t\t\t) {\n\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {\n\n\t\t\t\t\t/* now find key in ptr */\n\t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {\n\t\t\t\t\t\tif (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {\n\t\t\t\t\t\t\tzdata_ptr = test_ptr;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tZ_ADDREF_PP(test_ptr);\n\t\t\t\t\t\t\tzend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {\n\t\t\t\t\t\t\tzdata_ptr = test_ptr;\n\t\t\t\t\t\t} else if (hkey.num) {\n\t\t\t\t\t\t\tZ_ADDREF_PP(test_ptr);\n\t\t\t\t\t\t\tzend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tZ_ADDREF_PP(test_ptr);\n\t\t\t\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* this is the leaf */\n\t\t\t\t\tZ_ADDREF_PP(test_ptr);\n\t\t\t\t\tif (Z_TYPE_PP(ptr) != IS_ARRAY) {\n\t\t\t\t\t\tzval_dtor(*ptr);\n\t\t\t\t\t\tarray_init(*ptr);\n\t\t\t\t\t}\n\t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {\n\t\t\t\t\t\tzend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t} else if (hkey.num) {\n\t\t\t\t\t\tzend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/* bubble up */\n\twhile (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));\n\t*current_param = ptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,7 +62,7 @@\n \t\t\twhile (Z_TYPE_PP(zdata_ptr) == IS_ARRAY\n \t\t\t&&\tSUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)\n \t\t\t) {\n-\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY) {\n+\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {\n \n \t\t\t\t\t/* now find key in ptr */\n \t\t\t\t\tif (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY) {"
            ],
            "added_lines": [
                "\t\t\t\tif (Z_TYPE_PP(test_ptr) == IS_ARRAY && Z_TYPE_PP(ptr) == IS_ARRAY) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0322",
        "func_name": "torvalds/linux/sctp_make_strreset_req",
        "description": "A flaw was found in the sctp_make_strreset_req function in net/sctp/sm_make_chunk.c in the SCTP network protocol in the Linux kernel with a local user privilege access. In this flaw, an attempt to use more buffer than is allocated triggers a BUG_ON issue, leading to a denial of service (DOS).",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a2d859e3fc97e79d907761550dbc03ff1b36479c",
        "commit_title": "sctp_make_strreset_req() makes repeated calls to sctp_addto_chunk()",
        "commit_text": "which will automatically account for padding on each call. inreq and outreq are already 4 bytes aligned, but the payload is not and doing SCTP_PAD4(a + b) (which _sctp_make_chunk() did implicitly here) is different from SCTP_PAD4(a) + SCTP_PAD4(b) and not enough. It led to possible attempt to use more buffer than it was allocated and triggered a BUG_ON.  Cc: Vlad Yasevich <vyasevich@gmail.com> Cc: Neil Horman <nhorman@tuxdriver.com> Cc: Greg KH <gregkh@linuxfoundation.org> Link: https://lore.kernel.org/r/b97c1f8b0c7ff79ac4ed206fc2c49d3612e0850c.1634156849.git.mleitner@redhat.com ",
        "func_before": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}",
        "func": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \toutlen = (sizeof(outreq) + stream_len) * out;\n \tinlen = (sizeof(inreq) + stream_len) * in;\n \n-\tretval = sctp_make_reconf(asoc, outlen + inlen);\n+\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));\n \tif (!retval)\n \t\treturn NULL;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tretval = sctp_make_reconf(asoc, outlen + inlen);"
            ],
            "added_lines": [
                "\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5161",
        "func_name": "chromium/EditingStyle::mergeStyle",
        "description": "The EditingStyle::mergeStyle function in WebKit/Source/core/editing/EditingStyle.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, mishandles custom properties, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted web site that leverages \"type confusion\" in the StylePropertySerializer class.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/aadb63893e4c1358d1e5139aa29552eb190682c8",
        "commit_title": "Fix EditingStyle::mergeStyle()'s handling of custom properties",
        "commit_text": " This patch fixes the logic of EditingStyle::mergeStyle() to correctly handle custom properties. Currently it serializes the CSSValue and then reparses it, which, aside from being inefficient, doesn't work for custom properties as the custom property name is lost (since we only have the enum value CSSPropertyVariable).   Review-Url: https://codereview.chromium.org/2103043004 ",
        "func_before": "void EditingStyle::mergeStyle(const StylePropertySet* style, CSSPropertyOverrideMode mode)\n{\n    if (!style)\n        return;\n\n    if (!m_mutableStyle) {\n        m_mutableStyle = style->mutableCopy();\n        return;\n    }\n\n    unsigned propertyCount = style->propertyCount();\n    for (unsigned i = 0; i < propertyCount; ++i) {\n        StylePropertySet::PropertyReference property = style->propertyAt(i);\n        const CSSValue* value = m_mutableStyle->getPropertyCSSValue(property.id());\n\n        // text decorations never override values\n        if ((property.id() == textDecorationPropertyForEditing() || property.id() == CSSPropertyWebkitTextDecorationsInEffect) && property.value().isValueList() && value) {\n            if (value->isValueList()) {\n                CSSValueList* result = mergeTextDecorationValues(*toCSSValueList(value), toCSSValueList(property.value()));\n                m_mutableStyle->setProperty(property.id(), result, property.isImportant());\n                continue;\n            }\n            value = nullptr; // text-decoration: none is equivalent to not having the property\n        }\n\n        if (mode == OverrideValues || (mode == DoNotOverrideValues && !value))\n            m_mutableStyle->setProperty(property.id(), property.value().cssText(), property.isImportant());\n    }\n}",
        "func": "void EditingStyle::mergeStyle(const StylePropertySet* style, CSSPropertyOverrideMode mode)\n{\n    if (!style)\n        return;\n\n    if (!m_mutableStyle) {\n        m_mutableStyle = style->mutableCopy();\n        return;\n    }\n\n    unsigned propertyCount = style->propertyCount();\n    for (unsigned i = 0; i < propertyCount; ++i) {\n        StylePropertySet::PropertyReference property = style->propertyAt(i);\n        const CSSValue* value = m_mutableStyle->getPropertyCSSValue(property.id());\n\n        // text decorations never override values\n        if ((property.id() == textDecorationPropertyForEditing() || property.id() == CSSPropertyWebkitTextDecorationsInEffect) && property.value().isValueList() && value) {\n            if (value->isValueList()) {\n                CSSValueList* result = mergeTextDecorationValues(*toCSSValueList(value), toCSSValueList(property.value()));\n                m_mutableStyle->setProperty(property.id(), result, property.isImportant());\n                continue;\n            }\n            value = nullptr; // text-decoration: none is equivalent to not having the property\n        }\n\n        if (mode == OverrideValues || (mode == DoNotOverrideValues && !value))\n            m_mutableStyle->setProperty(property.toCSSProperty());\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,6 @@\n         }\n \n         if (mode == OverrideValues || (mode == DoNotOverrideValues && !value))\n-            m_mutableStyle->setProperty(property.id(), property.value().cssText(), property.isImportant());\n+            m_mutableStyle->setProperty(property.toCSSProperty());\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            m_mutableStyle->setProperty(property.id(), property.value().cssText(), property.isImportant());"
            ],
            "added_lines": [
                "            m_mutableStyle->setProperty(property.toCSSProperty());"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5161",
        "func_name": "chromium/MutableStylePropertySet::setProperty",
        "description": "The EditingStyle::mergeStyle function in WebKit/Source/core/editing/EditingStyle.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, mishandles custom properties, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted web site that leverages \"type confusion\" in the StylePropertySerializer class.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/aadb63893e4c1358d1e5139aa29552eb190682c8",
        "commit_title": "Fix EditingStyle::mergeStyle()'s handling of custom properties",
        "commit_text": " This patch fixes the logic of EditingStyle::mergeStyle() to correctly handle custom properties. Currently it serializes the CSSValue and then reparses it, which, aside from being inefficient, doesn't work for custom properties as the custom property name is lost (since we only have the enum value CSSPropertyVariable).   Review-Url: https://codereview.chromium.org/2103043004 ",
        "func_before": "bool MutableStylePropertySet::setProperty(CSSPropertyID unresolvedProperty, const String& value, bool important, StyleSheetContents* contextStyleSheet)\n{\n    // Setting the value to an empty string just removes the property in both IE and Gecko.\n    // Setting it to null seems to produce less consistent results, but we treat it just the same.\n    if (value.isEmpty())\n        return removeProperty(resolveCSSPropertyID(unresolvedProperty));\n\n    // When replacing an existing property value, this moves the property to the end of the list.\n    // Firefox preserves the position, and MSIE moves the property to the beginning.\n    return CSSParser::parseValue(this, unresolvedProperty, value, important, contextStyleSheet);\n}",
        "func": "bool MutableStylePropertySet::setProperty(CSSPropertyID unresolvedProperty, const String& value, bool important, StyleSheetContents* contextStyleSheet)\n{\n    DCHECK_GE(unresolvedProperty, firstCSSProperty);\n\n    // Setting the value to an empty string just removes the property in both IE and Gecko.\n    // Setting it to null seems to produce less consistent results, but we treat it just the same.\n    if (value.isEmpty())\n        return removeProperty(resolveCSSPropertyID(unresolvedProperty));\n\n    // When replacing an existing property value, this moves the property to the end of the list.\n    // Firefox preserves the position, and MSIE moves the property to the beginning.\n    return CSSParser::parseValue(this, unresolvedProperty, value, important, contextStyleSheet);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n bool MutableStylePropertySet::setProperty(CSSPropertyID unresolvedProperty, const String& value, bool important, StyleSheetContents* contextStyleSheet)\n {\n+    DCHECK_GE(unresolvedProperty, firstCSSProperty);\n+\n     // Setting the value to an empty string just removes the property in both IE and Gecko.\n     // Setting it to null seems to produce less consistent results, but we treat it just the same.\n     if (value.isEmpty())",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    DCHECK_GE(unresolvedProperty, firstCSSProperty);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7156",
        "func_name": "qemu/pvscsi_convert_sglist",
        "description": "The pvscsi_convert_sglist function in hw/scsi/vmw_pvscsi.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging an incorrect cast.",
        "git_url": "https://github.com/qemu/qemu/commit/49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8",
        "commit_title": "scsi: pvscsi: limit loop to fetch SG list",
        "commit_text": " In PVSCSI paravirtual SCSI bus, pvscsi_convert_sglist can take a very long time or go into an infinite loop due to two different bugs:  1) the request descriptor data length is defined to be 64 bit. While building SG list from a request descriptor, it gets truncated to 32bit in routine 'pvscsi_convert_sglist'. This could lead to an infinite loop situation large 'dataLen' values when data_length is cast to uint32_t and chunk_size becomes always zero.  Fix this by removing the incorrect cast.  2) pvscsi_get_next_sg_elem can be called arbitrarily many times if the element has a zero length.  Get out of the loop early when this happens, by introducing an upper limit on the number of SG list elements.  Message-Id: <1473108643-12983-1-git-send-email-ppandit@redhat.com>",
        "func_before": "static void\npvscsi_convert_sglist(PVSCSIRequest *r)\n{\n    int chunk_size;\n    uint64_t data_length = r->req.dataLen;\n    PVSCSISGState sg = r->sg;\n    while (data_length) {\n        while (!sg.resid) {\n            pvscsi_get_next_sg_elem(&sg);\n            trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                        r->sg.resid);\n        }\n        assert(data_length > 0);\n        chunk_size = MIN((unsigned) data_length, sg.resid);\n        if (chunk_size) {\n            qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n        }\n\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}",
        "func": "static void\npvscsi_convert_sglist(PVSCSIRequest *r)\n{\n    uint32_t chunk_size, elmcnt = 0;\n    uint64_t data_length = r->req.dataLen;\n    PVSCSISGState sg = r->sg;\n    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {\n        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {\n            pvscsi_get_next_sg_elem(&sg);\n            trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                        r->sg.resid);\n        }\n        chunk_size = MIN(data_length, sg.resid);\n        if (chunk_size) {\n            qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n        }\n\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,17 +1,16 @@\n static void\n pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n-    int chunk_size;\n+    uint32_t chunk_size, elmcnt = 0;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n-    while (data_length) {\n-        while (!sg.resid) {\n+    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {\n+        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n-        assert(data_length > 0);\n-        chunk_size = MIN((unsigned) data_length, sg.resid);\n+        chunk_size = MIN(data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "    int chunk_size;",
                "    while (data_length) {",
                "        while (!sg.resid) {",
                "        assert(data_length > 0);",
                "        chunk_size = MIN((unsigned) data_length, sg.resid);"
            ],
            "added_lines": [
                "    uint32_t chunk_size, elmcnt = 0;",
                "    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {",
                "        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {",
                "        chunk_size = MIN(data_length, sg.resid);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8602",
        "func_name": "ArtifexSoftware/ghostpdl/zsethalftone5",
        "description": "The .sethalftone5 function in psi/zht2.c in Ghostscript before 9.21 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted Postscript document that calls .sethalftone5 with an empty operand stack.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/f5c7555c30393e64ec1f5ab0dfae5b55b3b3fc78",
        "commit_title": "Bug 697203: check for sufficient params in .sethalftone5",
        "commit_text": " and param types",
        "func_before": "static int\nzsethalftone5(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint count;\n    gs_halftone_component *phtc = 0;\n    gs_halftone_component *pc;\n    int code = 0;\n    int j;\n    bool have_default;\n    gs_halftone *pht = 0;\n    gx_device_halftone *pdht = 0;\n    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    gs_memory_t *mem;\n    uint edepth = ref_stack_count(&e_stack);\n    int npop = 2;\n    int dict_enum = dict_first(op);\n    ref rvalue[2];\n    int cname, colorant_number;\n    byte * pname;\n    uint name_size;\n    int halftonetype, type = 0;\n    gs_gstate *pgs = igs;\n    int space_index = r_space_index(op - 1);\n\n    mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    check_type(op[-1], t_dictionary);\n    check_dict_read(op[-1]);\n\n    /*\n     * We think that Type 2 and Type 4 halftones, like\n     * screens set by setcolorscreen, adapt automatically to\n     * the device color space, so we need to mark them\n     * with a different internal halftone type.\n     */\n    code = dict_int_param(op - 1, \"HalftoneType\", 1, 100, 0, &type);\n    if (code < 0)\n          return code;\n    halftonetype = (type == 2 || type == 4)\n                        ? ht_type_multiple_colorscreen\n                        : ht_type_multiple;\n\n    /* Count how many components that we will actually use. */\n\n    have_default = false;\n    for (count = 0; ;) {\n\n        /* Move to next element in the dictionary */\n        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n            break;\n        /*\n         * Verify that we have a valid component.  We may have a\n         * /HalfToneType entry.\n         */\n        if (!r_has_type(&rvalue[0], t_name))\n            continue;\n        if (!r_has_type(&rvalue[1], t_dictionary))\n            continue;\n\n        /* Get the name of the component  verify that we will use it. */\n        cname = name_index(mem, &rvalue[0]);\n        code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n        if (code < 0)\n            break;\n        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n        if (colorant_number < 0)\n            continue;\n        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {\n            /* If here then we have the \"Default\" component */\n            if (have_default)\n                return_error(gs_error_rangecheck);\n            have_default = true;\n        }\n\n        count++;\n        /*\n         * Check to see if we have already reached the legal number of\n         * components.\n         */\n        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {\n            code = gs_note_error(gs_error_rangecheck);\n            break;\n        }\n    }\n    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))\n        code = gs_note_error(gs_error_rangecheck);\n\n    if (code >= 0) {\n        check_estack(5);\t\t/* for sampling Type 1 screens */\n        refset_null(sprocs, count);\n        refset_null(tprocs, count);\n        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,\n                          imemory, pht = 0, \".sethalftone5\");\n        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,\n                                     &st_ht_component_element,\n                                     \".sethalftone5\");\n        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,\n                          imemory, pdht = 0, \".sethalftone5\");\n        if (pht == 0 || phtc == 0 || pdht == 0) {\n            j = 0; /* Quiet the compiler:\n                      gs_note_error isn't necessarily identity,\n                      so j could be left ununitialized. */\n            code = gs_note_error(gs_error_VMerror);\n        }\n    }\n    if (code >= 0) {\n        dict_enum = dict_first(op);\n        for (j = 0, pc = phtc; ;) {\n            int type;\n\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n            /*\n             * Verify that we have a valid component.  We may have a\n             * /HalfToneType entry.\n             */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\t\t/* Do not use this component */\n            pc->cname = cname;\n            pc->comp_number = colorant_number;\n\n            /* Now process the component dictionary */\n            check_dict_read(rvalue[1]);\n            if (dict_int_param(&rvalue[1], \"HalftoneType\", 1, 7, 0, &type) < 0) {\n                code = gs_note_error(gs_error_typecheck);\n                break;\n            }\n            switch (type) {\n                default:\n                    code = gs_note_error(gs_error_rangecheck);\n                    break;\n                case 1:\n                    code = dict_spot_params(&rvalue[1], &pc->params.spot,\n                                                sprocs + j, tprocs + j, mem);\n                    pc->params.spot.screen.spot_function = spot1_dummy;\n                    pc->type = ht_type_spot;\n                    break;\n                case 3:\n                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,\n                                                        tprocs + j);\n                    pc->type = ht_type_threshold;\n                    break;\n                case 7:\n                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,\n                                                        tprocs + j, imemory);\n                    pc->type = ht_type_threshold2;\n                    break;\n            }\n            if (code < 0)\n                break;\n            pc++;\n            j++;\n        }\n    }\n    if (code >= 0) {\n        pht->type = halftonetype;\n        pht->params.multiple.components = phtc;\n        pht->params.multiple.num_comp = j;\n        pht->params.multiple.get_colorname_string = gs_get_colorname_string;\n        code = gs_sethalftone_prepare(igs, pht, pdht);\n    }\n    if (code >= 0) {\n        /*\n         * Put the actual frequency and angle in the spot function component dictionaries.\n         */\n        dict_enum = dict_first(op);\n        for (pc = phtc; ; ) {\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n\n            /* Verify that we have a valid component */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component and verify that we will use it. */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\n\n            if (pc->type == ht_type_spot) {\n                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);\n                if (code < 0)\n                    break;\n            }\n            pc++;\n        }\n    }\n    if (code >= 0) {\n        /*\n         * Schedule the sampling of any Type 1 screens,\n         * and any (Type 1 or Type 3) TransferFunctions.\n         * Save the stack depths in case we have to back out.\n         */\n        uint odepth = ref_stack_count(&o_stack);\n        ref odict, odict5;\n\n        odict = op[-1];\n        odict5 = *op;\n        pop(2);\n        op = osp;\n        esp += 5;\n        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);\n        esp[-3] = odict;\n        make_istruct(esp - 2, 0, pht);\n        make_istruct(esp - 1, 0, pdht);\n        make_op_estack(esp, sethalftone_finish);\n        for (j = 0; j < count; j++) {\n            gx_ht_order *porder = NULL;\n\n            if (pdht->components == 0)\n                porder = &pdht->order;\n            else {\n                /* Find the component in pdht that matches component j in\n                   the pht; gs_sethalftone_prepare() may permute these. */\n                int k;\n                int comp_number = phtc[j].comp_number;\n                for (k = 0; k < count; k++) {\n                    if (pdht->components[k].comp_number == comp_number) {\n                        porder = &pdht->components[k].corder;\n                        break;\n                    }\n                }\n            }\n            switch (phtc[j].type) {\n            case ht_type_spot:\n                code = zscreen_enum_init(i_ctx_p, porder,\n                                         &phtc[j].params.spot.screen,\n                                         &sprocs[j], 0, 0, space_index);\n                if (code < 0)\n                    break;\n                /* falls through */\n            case ht_type_threshold:\n                if (!r_has_type(tprocs + j, t__invalid)) {\n                    /* Schedule TransferFunction sampling. */\n                    /****** check_xstack IS WRONG ******/\n                    check_ostack(zcolor_remap_one_ostack);\n                    check_estack(zcolor_remap_one_estack);\n                    code = zcolor_remap_one(i_ctx_p, tprocs + j,\n                                            porder->transfer, igs,\n                                            zcolor_remap_one_finish);\n                    op = osp;\n                }\n                break;\n            default:\t/* not possible here, but to keep */\n                                /* the compilers happy.... */\n                ;\n            }\n            if (code < 0) {\t/* Restore the stack. */\n                ref_stack_pop_to(&o_stack, odepth);\n                ref_stack_pop_to(&e_stack, edepth);\n                op = osp;\n                op[-1] = odict;\n                *op = odict5;\n                break;\n            }\n            npop = 0;\n        }\n    }\n    if (code < 0) {\n        gs_free_object(mem, pdht, \".sethalftone5\");\n        gs_free_object(mem, phtc, \".sethalftone5\");\n        gs_free_object(mem, pht, \".sethalftone5\");\n        return code;\n    }\n    pop(npop);\n    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);\n}",
        "func": "static int\nzsethalftone5(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint count;\n    gs_halftone_component *phtc = 0;\n    gs_halftone_component *pc;\n    int code = 0;\n    int j;\n    bool have_default;\n    gs_halftone *pht = 0;\n    gx_device_halftone *pdht = 0;\n    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    gs_memory_t *mem;\n    uint edepth = ref_stack_count(&e_stack);\n    int npop = 2;\n    int dict_enum;\n    ref rvalue[2];\n    int cname, colorant_number;\n    byte * pname;\n    uint name_size;\n    int halftonetype, type = 0;\n    gs_gstate *pgs = igs;\n    int space_index;\n\n    if (ref_stack_count(&o_stack) < 2)\n        return_error(gs_error_stackunderflow);\n    check_type(*op, t_dictionary);\n    check_type(*(op - 1), t_dictionary);\n\n    dict_enum = dict_first(op);\n    space_index = r_space_index(op - 1);\n\n    mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    check_type(op[-1], t_dictionary);\n    check_dict_read(op[-1]);\n\n    /*\n     * We think that Type 2 and Type 4 halftones, like\n     * screens set by setcolorscreen, adapt automatically to\n     * the device color space, so we need to mark them\n     * with a different internal halftone type.\n     */\n    code = dict_int_param(op - 1, \"HalftoneType\", 1, 100, 0, &type);\n    if (code < 0)\n          return code;\n    halftonetype = (type == 2 || type == 4)\n                        ? ht_type_multiple_colorscreen\n                        : ht_type_multiple;\n\n    /* Count how many components that we will actually use. */\n\n    have_default = false;\n    for (count = 0; ;) {\n\n        /* Move to next element in the dictionary */\n        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n            break;\n        /*\n         * Verify that we have a valid component.  We may have a\n         * /HalfToneType entry.\n         */\n        if (!r_has_type(&rvalue[0], t_name))\n            continue;\n        if (!r_has_type(&rvalue[1], t_dictionary))\n            continue;\n\n        /* Get the name of the component  verify that we will use it. */\n        cname = name_index(mem, &rvalue[0]);\n        code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n        if (code < 0)\n            break;\n        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n        if (colorant_number < 0)\n            continue;\n        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {\n            /* If here then we have the \"Default\" component */\n            if (have_default)\n                return_error(gs_error_rangecheck);\n            have_default = true;\n        }\n\n        count++;\n        /*\n         * Check to see if we have already reached the legal number of\n         * components.\n         */\n        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {\n            code = gs_note_error(gs_error_rangecheck);\n            break;\n        }\n    }\n    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))\n        code = gs_note_error(gs_error_rangecheck);\n\n    if (code >= 0) {\n        check_estack(5);\t\t/* for sampling Type 1 screens */\n        refset_null(sprocs, count);\n        refset_null(tprocs, count);\n        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,\n                          imemory, pht = 0, \".sethalftone5\");\n        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,\n                                     &st_ht_component_element,\n                                     \".sethalftone5\");\n        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,\n                          imemory, pdht = 0, \".sethalftone5\");\n        if (pht == 0 || phtc == 0 || pdht == 0) {\n            j = 0; /* Quiet the compiler:\n                      gs_note_error isn't necessarily identity,\n                      so j could be left ununitialized. */\n            code = gs_note_error(gs_error_VMerror);\n        }\n    }\n    if (code >= 0) {\n        dict_enum = dict_first(op);\n        for (j = 0, pc = phtc; ;) {\n            int type;\n\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n            /*\n             * Verify that we have a valid component.  We may have a\n             * /HalfToneType entry.\n             */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\t\t/* Do not use this component */\n            pc->cname = cname;\n            pc->comp_number = colorant_number;\n\n            /* Now process the component dictionary */\n            check_dict_read(rvalue[1]);\n            if (dict_int_param(&rvalue[1], \"HalftoneType\", 1, 7, 0, &type) < 0) {\n                code = gs_note_error(gs_error_typecheck);\n                break;\n            }\n            switch (type) {\n                default:\n                    code = gs_note_error(gs_error_rangecheck);\n                    break;\n                case 1:\n                    code = dict_spot_params(&rvalue[1], &pc->params.spot,\n                                                sprocs + j, tprocs + j, mem);\n                    pc->params.spot.screen.spot_function = spot1_dummy;\n                    pc->type = ht_type_spot;\n                    break;\n                case 3:\n                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,\n                                                        tprocs + j);\n                    pc->type = ht_type_threshold;\n                    break;\n                case 7:\n                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,\n                                                        tprocs + j, imemory);\n                    pc->type = ht_type_threshold2;\n                    break;\n            }\n            if (code < 0)\n                break;\n            pc++;\n            j++;\n        }\n    }\n    if (code >= 0) {\n        pht->type = halftonetype;\n        pht->params.multiple.components = phtc;\n        pht->params.multiple.num_comp = j;\n        pht->params.multiple.get_colorname_string = gs_get_colorname_string;\n        code = gs_sethalftone_prepare(igs, pht, pdht);\n    }\n    if (code >= 0) {\n        /*\n         * Put the actual frequency and angle in the spot function component dictionaries.\n         */\n        dict_enum = dict_first(op);\n        for (pc = phtc; ; ) {\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n\n            /* Verify that we have a valid component */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component and verify that we will use it. */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\n\n            if (pc->type == ht_type_spot) {\n                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);\n                if (code < 0)\n                    break;\n            }\n            pc++;\n        }\n    }\n    if (code >= 0) {\n        /*\n         * Schedule the sampling of any Type 1 screens,\n         * and any (Type 1 or Type 3) TransferFunctions.\n         * Save the stack depths in case we have to back out.\n         */\n        uint odepth = ref_stack_count(&o_stack);\n        ref odict, odict5;\n\n        odict = op[-1];\n        odict5 = *op;\n        pop(2);\n        op = osp;\n        esp += 5;\n        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);\n        esp[-3] = odict;\n        make_istruct(esp - 2, 0, pht);\n        make_istruct(esp - 1, 0, pdht);\n        make_op_estack(esp, sethalftone_finish);\n        for (j = 0; j < count; j++) {\n            gx_ht_order *porder = NULL;\n\n            if (pdht->components == 0)\n                porder = &pdht->order;\n            else {\n                /* Find the component in pdht that matches component j in\n                   the pht; gs_sethalftone_prepare() may permute these. */\n                int k;\n                int comp_number = phtc[j].comp_number;\n                for (k = 0; k < count; k++) {\n                    if (pdht->components[k].comp_number == comp_number) {\n                        porder = &pdht->components[k].corder;\n                        break;\n                    }\n                }\n            }\n            switch (phtc[j].type) {\n            case ht_type_spot:\n                code = zscreen_enum_init(i_ctx_p, porder,\n                                         &phtc[j].params.spot.screen,\n                                         &sprocs[j], 0, 0, space_index);\n                if (code < 0)\n                    break;\n                /* falls through */\n            case ht_type_threshold:\n                if (!r_has_type(tprocs + j, t__invalid)) {\n                    /* Schedule TransferFunction sampling. */\n                    /****** check_xstack IS WRONG ******/\n                    check_ostack(zcolor_remap_one_ostack);\n                    check_estack(zcolor_remap_one_estack);\n                    code = zcolor_remap_one(i_ctx_p, tprocs + j,\n                                            porder->transfer, igs,\n                                            zcolor_remap_one_finish);\n                    op = osp;\n                }\n                break;\n            default:\t/* not possible here, but to keep */\n                                /* the compilers happy.... */\n                ;\n            }\n            if (code < 0) {\t/* Restore the stack. */\n                ref_stack_pop_to(&o_stack, odepth);\n                ref_stack_pop_to(&e_stack, edepth);\n                op = osp;\n                op[-1] = odict;\n                *op = odict5;\n                break;\n            }\n            npop = 0;\n        }\n    }\n    if (code < 0) {\n        gs_free_object(mem, pdht, \".sethalftone5\");\n        gs_free_object(mem, phtc, \".sethalftone5\");\n        gs_free_object(mem, pht, \".sethalftone5\");\n        return code;\n    }\n    pop(npop);\n    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,14 +15,22 @@\n     gs_memory_t *mem;\n     uint edepth = ref_stack_count(&e_stack);\n     int npop = 2;\n-    int dict_enum = dict_first(op);\n+    int dict_enum;\n     ref rvalue[2];\n     int cname, colorant_number;\n     byte * pname;\n     uint name_size;\n     int halftonetype, type = 0;\n     gs_gstate *pgs = igs;\n-    int space_index = r_space_index(op - 1);\n+    int space_index;\n+\n+    if (ref_stack_count(&o_stack) < 2)\n+        return_error(gs_error_stackunderflow);\n+    check_type(*op, t_dictionary);\n+    check_type(*(op - 1), t_dictionary);\n+\n+    dict_enum = dict_first(op);\n+    space_index = r_space_index(op - 1);\n \n     mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    int dict_enum = dict_first(op);",
                "    int space_index = r_space_index(op - 1);"
            ],
            "added_lines": [
                "    int dict_enum;",
                "    int space_index;",
                "",
                "    if (ref_stack_count(&o_stack) < 2)",
                "        return_error(gs_error_stackunderflow);",
                "    check_type(*op, t_dictionary);",
                "    check_type(*(op - 1), t_dictionary);",
                "",
                "    dict_enum = dict_first(op);",
                "    space_index = r_space_index(op - 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8291",
        "func_name": "ArtifexSoftware/ghostpdl/zrsdparams",
        "description": "Artifex Ghostscript through 2017-04-26 allows -dSAFER bypass and remote command execution via .rsdparams type confusion with a \"/OutputFile (%pipe%\" substring in a crafted .eps document that is an input to the gs program, as exploited in the wild in April 2017.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/04b37bbce174eed24edec7ad5b920eb93db4d47d",
        "commit_title": "Bug 697799: have .rsdparams check its parameters",
        "commit_text": " The Ghostscript internal operator .rsdparams wasn't checking the number or type of the operands it was being passed. Do so.",
        "func_before": "static int\nzrsdparams(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *pFilter;\n    ref *pDecodeParms;\n    int Intent = 0;\n    bool AsyncRead;\n    ref empty_array, filter1_array, parms1_array;\n    uint i;\n    int code;\n\n    make_empty_array(&empty_array, a_readonly);\n    if (dict_find_string(op, \"Filter\", &pFilter) > 0) {\n        if (!r_is_array(pFilter)) {\n            if (!r_has_type(pFilter, t_name))\n                return_error(gs_error_typecheck);\n            make_array(&filter1_array, a_readonly, 1, pFilter);\n            pFilter = &filter1_array;\n        }\n    } else\n        pFilter = &empty_array;\n    /* If Filter is undefined, ignore DecodeParms. */\n    if (pFilter != &empty_array &&\n        dict_find_string(op, \"DecodeParms\", &pDecodeParms) > 0\n        ) {\n        if (pFilter == &filter1_array) {\n            make_array(&parms1_array, a_readonly, 1, pDecodeParms);\n            pDecodeParms = &parms1_array;\n        } else if (!r_is_array(pDecodeParms))\n            return_error(gs_error_typecheck);\n        else if (r_size(pFilter) != r_size(pDecodeParms))\n            return_error(gs_error_rangecheck);\n    } else\n        pDecodeParms = 0;\n    for (i = 0; i < r_size(pFilter); ++i) {\n        ref f, fname, dp;\n\n        array_get(imemory, pFilter, (long)i, &f);\n        if (!r_has_type(&f, t_name))\n            return_error(gs_error_typecheck);\n        name_string_ref(imemory, &f, &fname);\n        if (r_size(&fname) < 6 ||\n            memcmp(fname.value.bytes + r_size(&fname) - 6, \"Decode\", 6)\n            )\n            return_error(gs_error_rangecheck);\n        if (pDecodeParms) {\n            array_get(imemory, pDecodeParms, (long)i, &dp);\n            if (!(r_has_type(&dp, t_dictionary) || r_has_type(&dp, t_null)))\n                return_error(gs_error_typecheck);\n        }\n    }\n    code = dict_int_param(op, \"Intent\", 0, 3, 0, &Intent);\n    if (code < 0 && code != gs_error_rangecheck) /* out-of-range int is ok, use 0 */\n        return code;\n    if ((code = dict_bool_param(op, \"AsyncRead\", false, &AsyncRead)) < 0\n        )\n        return code;\n    push(1);\n    op[-1] = *pFilter;\n    if (pDecodeParms)\n        *op = *pDecodeParms;\n    else\n        make_null(op);\n    return 0;\n}",
        "func": "static int\nzrsdparams(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *pFilter;\n    ref *pDecodeParms;\n    int Intent = 0;\n    bool AsyncRead = false;\n    ref empty_array, filter1_array, parms1_array;\n    uint i;\n    int code = 0;\n\n    if (ref_stack_count(&o_stack) < 1)\n        return_error(gs_error_stackunderflow);\n    if (!r_has_type(op, t_dictionary) && !r_has_type(op, t_null)) {\n        return_error(gs_error_typecheck);\n    }\n\n    make_empty_array(&empty_array, a_readonly);\n    if (r_has_type(op, t_dictionary)\n        && dict_find_string(op, \"Filter\", &pFilter) > 0) {\n        if (!r_is_array(pFilter)) {\n            if (!r_has_type(pFilter, t_name))\n                return_error(gs_error_typecheck);\n            make_array(&filter1_array, a_readonly, 1, pFilter);\n            pFilter = &filter1_array;\n        }\n    } else\n        pFilter = &empty_array;\n    /* If Filter is undefined, ignore DecodeParms. */\n    if (pFilter != &empty_array &&\n        dict_find_string(op, \"DecodeParms\", &pDecodeParms) > 0\n        ) {\n        if (pFilter == &filter1_array) {\n            make_array(&parms1_array, a_readonly, 1, pDecodeParms);\n            pDecodeParms = &parms1_array;\n        } else if (!r_is_array(pDecodeParms))\n            return_error(gs_error_typecheck);\n        else if (r_size(pFilter) != r_size(pDecodeParms))\n            return_error(gs_error_rangecheck);\n    } else\n        pDecodeParms = 0;\n    for (i = 0; i < r_size(pFilter); ++i) {\n        ref f, fname, dp;\n\n        array_get(imemory, pFilter, (long)i, &f);\n        if (!r_has_type(&f, t_name))\n            return_error(gs_error_typecheck);\n        name_string_ref(imemory, &f, &fname);\n        if (r_size(&fname) < 6 ||\n            memcmp(fname.value.bytes + r_size(&fname) - 6, \"Decode\", 6)\n            )\n            return_error(gs_error_rangecheck);\n        if (pDecodeParms) {\n            array_get(imemory, pDecodeParms, (long)i, &dp);\n            if (!(r_has_type(&dp, t_dictionary) || r_has_type(&dp, t_null)))\n                return_error(gs_error_typecheck);\n        }\n    }\n    if (r_has_type(op, t_dictionary))\n        code = dict_int_param(op, \"Intent\", 0, 3, 0, &Intent);\n    if (code < 0 && code != gs_error_rangecheck) /* out-of-range int is ok, use 0 */\n        return code;\n    if (r_has_type(op, t_dictionary))\n        if ((code = dict_bool_param(op, \"AsyncRead\", false, &AsyncRead)) < 0)\n            return code;\n    push(1);\n    op[-1] = *pFilter;\n    if (pDecodeParms)\n        *op = *pDecodeParms;\n    else\n        make_null(op);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,13 +5,20 @@\n     ref *pFilter;\n     ref *pDecodeParms;\n     int Intent = 0;\n-    bool AsyncRead;\n+    bool AsyncRead = false;\n     ref empty_array, filter1_array, parms1_array;\n     uint i;\n-    int code;\n+    int code = 0;\n+\n+    if (ref_stack_count(&o_stack) < 1)\n+        return_error(gs_error_stackunderflow);\n+    if (!r_has_type(op, t_dictionary) && !r_has_type(op, t_null)) {\n+        return_error(gs_error_typecheck);\n+    }\n \n     make_empty_array(&empty_array, a_readonly);\n-    if (dict_find_string(op, \"Filter\", &pFilter) > 0) {\n+    if (r_has_type(op, t_dictionary)\n+        && dict_find_string(op, \"Filter\", &pFilter) > 0) {\n         if (!r_is_array(pFilter)) {\n             if (!r_has_type(pFilter, t_name))\n                 return_error(gs_error_typecheck);\n@@ -50,12 +57,13 @@\n                 return_error(gs_error_typecheck);\n         }\n     }\n-    code = dict_int_param(op, \"Intent\", 0, 3, 0, &Intent);\n+    if (r_has_type(op, t_dictionary))\n+        code = dict_int_param(op, \"Intent\", 0, 3, 0, &Intent);\n     if (code < 0 && code != gs_error_rangecheck) /* out-of-range int is ok, use 0 */\n         return code;\n-    if ((code = dict_bool_param(op, \"AsyncRead\", false, &AsyncRead)) < 0\n-        )\n-        return code;\n+    if (r_has_type(op, t_dictionary))\n+        if ((code = dict_bool_param(op, \"AsyncRead\", false, &AsyncRead)) < 0)\n+            return code;\n     push(1);\n     op[-1] = *pFilter;\n     if (pDecodeParms)",
        "diff_line_info": {
            "deleted_lines": [
                "    bool AsyncRead;",
                "    int code;",
                "    if (dict_find_string(op, \"Filter\", &pFilter) > 0) {",
                "    code = dict_int_param(op, \"Intent\", 0, 3, 0, &Intent);",
                "    if ((code = dict_bool_param(op, \"AsyncRead\", false, &AsyncRead)) < 0",
                "        )",
                "        return code;"
            ],
            "added_lines": [
                "    bool AsyncRead = false;",
                "    int code = 0;",
                "",
                "    if (ref_stack_count(&o_stack) < 1)",
                "        return_error(gs_error_stackunderflow);",
                "    if (!r_has_type(op, t_dictionary) && !r_has_type(op, t_null)) {",
                "        return_error(gs_error_typecheck);",
                "    }",
                "    if (r_has_type(op, t_dictionary)",
                "        && dict_find_string(op, \"Filter\", &pFilter) > 0) {",
                "    if (r_has_type(op, t_dictionary))",
                "        code = dict_int_param(op, \"Intent\", 0, 3, 0, &Intent);",
                "    if (r_has_type(op, t_dictionary))",
                "        if ((code = dict_bool_param(op, \"AsyncRead\", false, &AsyncRead)) < 0)",
                "            return code;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9040",
        "func_name": "binutils-gdb/process_mips_specific",
        "description": "GNU Binutils 2017-04-03 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash), related to the process_mips_specific function in readelf.c, via a crafted ELF file that triggers a large memory-allocation attempt.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=7296a62a2a237f6b1ad8db8c38b090e9f592c8cf",
        "commit_title": "",
        "commit_text": "readelf: fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.  \tPR binutils/21379 \t* readelf.c (process_dynamic_section): Detect over large section \toffsets in the DT_SYMTAB entry.  \tPR binutils/21345 \t* readelf.c (process_mips_specific): Catch an unfeasible memory \tallocation before it happens and print a suitable error message. ",
        "func_before": "static bfd_boolean\nprocess_mips_specific (FILE * file)\n{\n  Elf_Internal_Dyn * entry;\n  Elf_Internal_Shdr *sect = NULL;\n  size_t liblist_offset = 0;\n  size_t liblistno = 0;\n  size_t conflictsno = 0;\n  size_t options_offset = 0;\n  size_t conflicts_offset = 0;\n  size_t pltrelsz = 0;\n  size_t pltrel = 0;\n  bfd_vma pltgot = 0;\n  bfd_vma mips_pltgot = 0;\n  bfd_vma jmprel = 0;\n  bfd_vma local_gotno = 0;\n  bfd_vma gotsym = 0;\n  bfd_vma symtabno = 0;\n  bfd_boolean res = TRUE;\n\n  if (! process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t    display_mips_gnu_attribute))\n    res = FALSE;\n\n  sect = find_section (\".MIPS.abiflags\");\n\n  if (sect != NULL)\n    {\n      Elf_External_ABIFlags_v0 *abiflags_ext;\n      Elf_Internal_ABIFlags_v0 abiflags_in;\n\n      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)\n\t{\n\t  error (_(\"Corrupt MIPS ABI Flags section.\\n\"));\n\t  res = FALSE;\n\t}\n      else\n\t{\n\t  abiflags_ext = get_data (NULL, file, sect->sh_offset, 1,\n\t\t\t\t   sect->sh_size, _(\"MIPS ABI Flags section\"));\n\t  if (abiflags_ext)\n\t    {\n\t      abiflags_in.version = BYTE_GET (abiflags_ext->version);\n\t      abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level);\n\t      abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev);\n\t      abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size);\n\t      abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size);\n\t      abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size);\n\t      abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi);\n\t      abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext);\n\t      abiflags_in.ases = BYTE_GET (abiflags_ext->ases);\n\t      abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1);\n\t      abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2);\n\n\t      printf (\"\\nMIPS ABI Flags Version: %d\\n\", abiflags_in.version);\n\t      printf (\"\\nISA: MIPS%d\", abiflags_in.isa_level);\n\t      if (abiflags_in.isa_rev > 1)\n\t\tprintf (\"r%d\", abiflags_in.isa_rev);\n\t      printf (\"\\nGPR size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.gpr_size));\n\t      printf (\"\\nCPR1 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr1_size));\n\t      printf (\"\\nCPR2 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr2_size));\n\t      fputs (\"\\nFP ABI: \", stdout);\n\t      print_mips_fp_abi_value (abiflags_in.fp_abi);\n\t      fputs (\"ISA Extension: \", stdout);\n\t      print_mips_isa_ext (abiflags_in.isa_ext);\n\t      fputs (\"\\nASEs:\", stdout);\n\t      print_mips_ases (abiflags_in.ases);\n\t      printf (\"\\nFLAGS 1: %8.8lx\", abiflags_in.flags1);\n\t      printf (\"\\nFLAGS 2: %8.8lx\", abiflags_in.flags2);\n\t      fputc ('\\n', stdout);\n\t      free (abiflags_ext);\n\t    }\n\t}\n    }\n\n  /* We have a lot of special sections.  Thanks SGI!  */\n  if (dynamic_section == NULL)\n    /* No information available.  */\n    return res;\n\n  for (entry = dynamic_section;\n       /* PR 17531 file: 012-50589-0.004.  */\n       entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL;\n       ++entry)\n    switch (entry->d_tag)\n      {\n      case DT_MIPS_LIBLIST:\n\tliblist_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     liblistno * sizeof (Elf32_External_Lib));\n\tbreak;\n      case DT_MIPS_LIBLISTNO:\n\tliblistno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_OPTIONS:\n\toptions_offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\tbreak;\n      case DT_MIPS_CONFLICT:\n\tconflicts_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     conflictsno * sizeof (Elf32_External_Conflict));\n\tbreak;\n      case DT_MIPS_CONFLICTNO:\n\tconflictsno = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTGOT:\n\tpltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_MIPS_LOCAL_GOTNO:\n\tlocal_gotno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_GOTSYM:\n\tgotsym = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_SYMTABNO:\n\tsymtabno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_PLTGOT:\n\tmips_pltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_PLTREL:\n\tpltrel = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTRELSZ:\n\tpltrelsz = entry->d_un.d_val;\n\tbreak;\n      case DT_JMPREL:\n\tjmprel = entry->d_un.d_ptr;\n\tbreak;\n      default:\n\tbreak;\n      }\n\n  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)\n    {\n      Elf32_External_Lib * elib;\n      size_t cnt;\n\n      elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset,\n                                              liblistno,\n                                              sizeof (Elf32_External_Lib),\n                                              _(\"liblist section data\"));\n      if (elib)\n\t{\n\t  printf (_(\"\\nSection '.liblist' contains %lu entries:\\n\"),\n\t\t  (unsigned long) liblistno);\n\t  fputs (_(\"     Library              Time Stamp          Checksum   Version Flags\\n\"),\n\t\t stdout);\n\n\t  for (cnt = 0; cnt < liblistno; ++cnt)\n\t    {\n\t      Elf32_Lib liblist;\n\t      time_t atime;\n\t      char timebuf[128];\n\t      struct tm * tmp;\n\n\t      liblist.l_name = BYTE_GET (elib[cnt].l_name);\n\t      atime = BYTE_GET (elib[cnt].l_time_stamp);\n\t      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);\n\t      liblist.l_version = BYTE_GET (elib[cnt].l_version);\n\t      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);\n\n\t      tmp = gmtime (&atime);\n\t      snprintf (timebuf, sizeof (timebuf),\n\t\t\t\"%04u-%02u-%02uT%02u:%02u:%02u\",\n\t\t\ttmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,\n\t\t\ttmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n\t      printf (\"%3lu: \", (unsigned long) cnt);\n\t      if (VALID_DYNAMIC_NAME (liblist.l_name))\n\t\tprint_symbol (20, GET_DYNAMIC_NAME (liblist.l_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %9ld>\"), liblist.l_name);\n\t      printf (\" %s %#10lx %-7ld\", timebuf, liblist.l_checksum,\n\t\t      liblist.l_version);\n\n\t      if (liblist.l_flags == 0)\n\t\tputs (_(\" NONE\"));\n\t      else\n\t\t{\n\t\t  static const struct\n\t\t  {\n\t\t    const char * name;\n\t\t    int bit;\n\t\t  }\n\t\t  l_flags_vals[] =\n\t\t  {\n\t\t    { \" EXACT_MATCH\", LL_EXACT_MATCH },\n\t\t    { \" IGNORE_INT_VER\", LL_IGNORE_INT_VER },\n\t\t    { \" REQUIRE_MINOR\", LL_REQUIRE_MINOR },\n\t\t    { \" EXPORTS\", LL_EXPORTS },\n\t\t    { \" DELAY_LOAD\", LL_DELAY_LOAD },\n\t\t    { \" DELTA\", LL_DELTA }\n\t\t  };\n\t\t  int flags = liblist.l_flags;\n\t\t  size_t fcnt;\n\n\t\t  for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt)\n\t\t    if ((flags & l_flags_vals[fcnt].bit) != 0)\n\t\t      {\n\t\t\tfputs (l_flags_vals[fcnt].name, stdout);\n\t\t\tflags ^= l_flags_vals[fcnt].bit;\n\t\t      }\n\t\t  if (flags != 0)\n\t\t    printf (\" %#x\", (unsigned int) flags);\n\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\n\t  free (elib);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (options_offset != 0)\n    {\n      Elf_External_Options * eopt;\n      Elf_Internal_Options * iopt;\n      Elf_Internal_Options * option;\n      size_t offset;\n      int cnt;\n      sect = section_headers;\n\n      /* Find the section header so that we get the size.  */\n      sect = find_section_by_type (SHT_MIPS_OPTIONS);\n      /* PR 17533 file: 012-277276-0.004.  */\n      if (sect == NULL)\n\t{\n\t  error (_(\"No MIPS_OPTIONS header found\\n\"));\n\t  return FALSE;\n\t}\n\n      eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1,\n                                                sect->sh_size, _(\"options\"));\n      if (eopt)\n\t{\n\t  iopt = (Elf_Internal_Options *)\n              cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));\n\t  if (iopt == NULL)\n\t    {\n\t      error (_(\"Out of memory allocating space for MIPS options\\n\"));\n\t      return FALSE;\n\t    }\n\n\t  offset = cnt = 0;\n\t  option = iopt;\n\n\t  while (offset <= sect->sh_size - sizeof (* eopt))\n\t    {\n\t      Elf_External_Options * eoption;\n\n\t      eoption = (Elf_External_Options *) ((char *) eopt + offset);\n\n\t      option->kind = BYTE_GET (eoption->kind);\n\t      option->size = BYTE_GET (eoption->size);\n\t      option->section = BYTE_GET (eoption->section);\n\t      option->info = BYTE_GET (eoption->info);\n\n\t      /* PR 17531: file: ffa0fa3b.  */\n\t      if (option->size < sizeof (* eopt)\n\t\t  || offset + option->size > sect->sh_size)\n\t\t{\n\t\t  error (_(\"Invalid size (%u) for MIPS option\\n\"), option->size);\n\t\t  return FALSE;\n\t\t}\n\t      offset += option->size;\n\n\t      ++option;\n\t      ++cnt;\n\t    }\n\n\t  printf (_(\"\\nSection '%s' contains %d entries:\\n\"),\n\t\t  printable_section_name (sect), cnt);\n\n\t  option = iopt;\n\t  offset = 0;\n\n\t  while (cnt-- > 0)\n\t    {\n\t      size_t len;\n\n\t      switch (option->kind)\n\t\t{\n\t\tcase ODK_NULL:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" NULL       %d %lx\", option->section, option->info);\n\t\t  break;\n\t\tcase ODK_REGINFO:\n\t\t  printf (\" REGINFO    \");\n\t\t  if (elf_header.e_machine == EM_MIPS)\n\t\t    {\n\t\t      /* 32bit form.  */\n\t\t      Elf32_External_RegInfo * ereg;\n\t\t      Elf32_RegInfo reginfo;\n\n\t\t      ereg = (Elf32_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x%lx\\n\",\n\t\t\t      reginfo.ri_gprmask,\n\t\t\t      (unsigned long) reginfo.ri_gp_value);\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* 64 bit form.  */\n\t\t      Elf64_External_RegInfo * ereg;\n\t\t      Elf64_Internal_RegInfo reginfo;\n\n\t\t      ereg = (Elf64_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x\",\n\t\t\t      reginfo.ri_gprmask);\n\t\t      printf_vma (reginfo.ri_gp_value);\n\t\t      printf (\"\\n\");\n\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  ++option;\n\t\t  continue;\n\t\tcase ODK_EXCEPTIONS:\n\t\t  fputs (\" EXCEPTIONS fpe_min(\", stdout);\n\t\t  process_mips_fpe_exception (option->info & OEX_FPU_MIN);\n\t\t  fputs (\") fpe_max(\", stdout);\n\t\t  process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8);\n\t\t  fputs (\")\", stdout);\n\n\t\t  if (option->info & OEX_PAGE0)\n\t\t    fputs (\" PAGE0\", stdout);\n\t\t  if (option->info & OEX_SMM)\n\t\t    fputs (\" SMM\", stdout);\n\t\t  if (option->info & OEX_FPDBUG)\n\t\t    fputs (\" FPDBUG\", stdout);\n\t\t  if (option->info & OEX_DISMISS)\n\t\t    fputs (\" DISMISS\", stdout);\n\t\t  break;\n\t\tcase ODK_PAD:\n\t\t  fputs (\" PAD       \", stdout);\n\t\t  if (option->info & OPAD_PREFIX)\n\t\t    fputs (\" PREFIX\", stdout);\n\t\t  if (option->info & OPAD_POSTFIX)\n\t\t    fputs (\" POSTFIX\", stdout);\n\t\t  if (option->info & OPAD_SYMBOL)\n\t\t    fputs (\" SYMBOL\", stdout);\n\t\t  break;\n\t\tcase ODK_HWPATCH:\n\t\t  fputs (\" HWPATCH   \", stdout);\n\t\t  if (option->info & OHW_R4KEOP)\n\t\t    fputs (\" R4KEOP\", stdout);\n\t\t  if (option->info & OHW_R8KPFETCH)\n\t\t    fputs (\" R8KPFETCH\", stdout);\n\t\t  if (option->info & OHW_R5KEOP)\n\t\t    fputs (\" R5KEOP\", stdout);\n\t\t  if (option->info & OHW_R5KCVTL)\n\t\t    fputs (\" R5KCVTL\", stdout);\n\t\t  break;\n\t\tcase ODK_FILL:\n\t\t  fputs (\" FILL       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_TAGS:\n\t\t  fputs (\" TAGS       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_HWAND:\n\t\t  fputs (\" HWAND     \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_HWOR:\n\t\t  fputs (\" HWOR      \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_GP_GROUP:\n\t\t  printf (\" GP_GROUP  %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tcase ODK_IDENT:\n\t\t  printf (\" IDENT     %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tdefault:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" %3d ???     %d %lx\",\n\t\t\t  option->kind, option->section, option->info);\n\t\t  break;\n\t\t}\n\n\t      len = sizeof (* eopt);\n\t      while (len < option->size)\n\t\t{\n\t\t  unsigned char datum = * ((unsigned char *) eopt + offset + len);\n\n\t\t  if (ISPRINT (datum))\n\t\t    printf (\"%c\", datum);\n\t\t  else\n\t\t    printf (\"\\\\%03o\", datum);\n\t\t  len ++;\n\t\t}\n\t      fputs (\"\\n\", stdout);\n\n\t      offset += option->size;\n\t      ++option;\n\t    }\n\n\t  free (eopt);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (conflicts_offset != 0 && conflictsno != 0)\n    {\n      Elf32_Conflict * iconf;\n      size_t cnt;\n\n      if (dynamic_symbols == NULL)\n\t{\n\t  error (_(\"conflict list found without a dynamic symbol table\\n\"));\n\t  return FALSE;\n\t}\n\n      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));\n      if (iconf == NULL)\n\t{\n\t  error (_(\"Out of memory allocating space for dynamic conflicts\\n\"));\n\t  return FALSE;\n\t}\n\n      if (is_32bit_elf)\n\t{\n\t  Elf32_External_Conflict * econf32;\n\n\t  econf32 = (Elf32_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf32), _(\"conflict\"));\n\t  if (!econf32)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf32[cnt]);\n\n\t  free (econf32);\n\t}\n      else\n\t{\n\t  Elf64_External_Conflict * econf64;\n\n\t  econf64 = (Elf64_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf64), _(\"conflict\"));\n\t  if (!econf64)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf64[cnt]);\n\n\t  free (econf64);\n\t}\n\n      printf (_(\"\\nSection '.conflict' contains %lu entries:\\n\"),\n\t      (unsigned long) conflictsno);\n      puts (_(\"  Num:    Index       Value  Name\"));\n\n      for (cnt = 0; cnt < conflictsno; ++cnt)\n\t{\n\t  printf (\"%5lu: %8lu  \", (unsigned long) cnt, iconf[cnt]);\n\n\t  if (iconf[cnt] >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index>\"));\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym;\n\n\t      psym = & dynamic_symbols[iconf[cnt]];\n\t      print_vma (psym->st_value, FULL_HEX);\n\t      putchar (' ');\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (25, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  putchar ('\\n');\n\t}\n\n      free (iconf);\n    }\n\n  if (pltgot != 0 && local_gotno != 0)\n    {\n      bfd_vma ent, local_end, global_end;\n      size_t i, offset;\n      unsigned char * data;\n      unsigned char * data_end;\n      int addr_size;\n\n      ent = pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      local_end = pltgot + local_gotno * addr_size;\n\n      /* PR binutils/17533 file: 012-111227-0.004  */\n      if (symtabno < gotsym)\n\t{\n\t  error (_(\"The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\\n\"),\n\t\t (unsigned long) gotsym, (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      global_end = local_end + (symtabno - gotsym) * addr_size;\n      /* PR 17531: file: 54c91a34.  */\n      if (global_end < local_end)\n\t{\n\t  error (_(\"Too many GOT symbols: %lu\\n\"), (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      offset = offset_from_vma (file, pltgot, global_end - pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset,\n                                         global_end - pltgot, 1,\n\t\t\t\t\t _(\"Global Offset Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n      data_end = data + (global_end - pltgot);\n\n      printf (_(\"\\nPrimary GOT:\\n\"));\n      printf (_(\" Canonical gp value: \"));\n      print_vma (pltgot + 0x7ff0, LONG_HEX);\n      printf (\"\\n\\n\");\n\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %10s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t      addr_size * 2, _(\"Initial\"));\n      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n      printf (_(\" Lazy resolver\\n\"));\n      if (ent == (bfd_vma) -1)\n\tgoto got_print_fail;\n\n      if (data)\n\t{\n\t  /* PR 21344 */\n\t  if (data + ent - pltgot > data_end - addr_size)\n\t    {\n\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"),\n\t\t     (long) ent);\n\t      goto got_print_fail;\n\t    }\n\t  \n\t  if (byte_get (data + ent - pltgot, addr_size)\n\t      >> (addr_size * 8 - 1) != 0)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (_(\" Module pointer (GNU extension)\\n\"));\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t}\n      printf (\"\\n\");\n\n      if (ent < local_end)\n\t{\n\t  printf (_(\" Local entries:\\n\"));\n\t  printf (\"  %*s %10s %*s\\n\",\n\t\t  addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"));\n\t  while (ent < local_end)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n      if (gotsym < symtabno)\n\t{\n\t  int sym_width;\n\n\t  printf (_(\" Global entries:\\n\"));\n\t  printf (\"  %*s %10s %*s %*s %-7s %3s %s\\n\",\n\t\t  addr_size * 2, _(\"Address\"),\n\t\t  _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"),\n\t\t  addr_size * 2, _(\"Sym.Val.\"),\n\t\t  _(\"Type\"),\n\t\t  /* Note for translators: \"Ndx\" = abbreviated form of \"Index\".  */\n\t\t  _(\"Ndx\"), _(\"Name\"));\n\n\t  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;\n\n\t  for (i = gotsym; i < symtabno; i++)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\" \");\n\n\t      if (dynamic_symbols == NULL)\n\t\tprintf (_(\"<no dynamic symbols>\"));\n\t      else if (i < num_dynamic_syms)\n\t\t{\n\t\t  Elf_Internal_Sym * psym = dynamic_symbols + i;\n\n\t\t  print_vma (psym->st_value, LONG_HEX);\n\t\t  printf (\" %-7s %3s \",\n\t\t\t  get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t\t  get_symbol_index_type (psym->st_shndx));\n\n\t\t  if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\t    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t\t  else\n\t\t    printf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t\t}\n\t      else\n\t\tprintf (_(\"<symbol index %lu exceeds number of dynamic symbols>\"),\n\t\t\t(unsigned long) i);\n\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tbreak;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n    got_print_fail:\n      if (data)\n\tfree (data);\n    }\n\n  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)\n    {\n      bfd_vma ent, end;\n      size_t offset, rel_offset;\n      unsigned long count, i;\n      unsigned char * data;\n      int addr_size, sym_width;\n      Elf_Internal_Rela * rels;\n\n      rel_offset = offset_from_vma (file, jmprel, pltrelsz);\n      if (pltrel == DT_RELA)\n\t{\n\t  if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n      else\n\t{\n\t  if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n\n      ent = mips_pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      end = mips_pltgot + (2 + count) * addr_size;\n\n      offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot,\n                                         1, _(\"Procedure Linkage Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n\n      printf (\"\\nPLT GOT:\\n\\n\");\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), addr_size * 2, _(\"Initial\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" PLT lazy resolver\\n\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" Module pointer\\n\"));\n      printf (\"\\n\");\n\n      printf (_(\" Entries:\\n\"));\n      printf (\"  %*s %*s %*s %-7s %3s %s\\n\",\n\t      addr_size * 2, _(\"Address\"),\n\t      addr_size * 2, _(\"Initial\"),\n\t      addr_size * 2, _(\"Sym.Val.\"), _(\"Type\"), _(\"Ndx\"), _(\"Name\"));\n      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;\n      for (i = 0; i < count; i++)\n\t{\n\t  unsigned long idx = get_reloc_symindex (rels[i].r_info);\n\n\t  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n\t  printf (\" \");\n\n\t  if (idx >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index: %lu>\"), idx);\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym = dynamic_symbols + idx;\n\n\t      print_vma (psym->st_value, LONG_HEX);\n\t      printf (\" %-7s %3s \",\n\t\t      get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t      get_symbol_index_type (psym->st_shndx));\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  printf (\"\\n\");\n\t}\n      printf (\"\\n\");\n\n      if (data)\n\tfree (data);\n      free (rels);\n    }\n\n  return res;\n}",
        "func": "static bfd_boolean\nprocess_mips_specific (FILE * file)\n{\n  Elf_Internal_Dyn * entry;\n  Elf_Internal_Shdr *sect = NULL;\n  size_t liblist_offset = 0;\n  size_t liblistno = 0;\n  size_t conflictsno = 0;\n  size_t options_offset = 0;\n  size_t conflicts_offset = 0;\n  size_t pltrelsz = 0;\n  size_t pltrel = 0;\n  bfd_vma pltgot = 0;\n  bfd_vma mips_pltgot = 0;\n  bfd_vma jmprel = 0;\n  bfd_vma local_gotno = 0;\n  bfd_vma gotsym = 0;\n  bfd_vma symtabno = 0;\n  bfd_boolean res = TRUE;\n\n  if (! process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t    display_mips_gnu_attribute))\n    res = FALSE;\n\n  sect = find_section (\".MIPS.abiflags\");\n\n  if (sect != NULL)\n    {\n      Elf_External_ABIFlags_v0 *abiflags_ext;\n      Elf_Internal_ABIFlags_v0 abiflags_in;\n\n      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)\n\t{\n\t  error (_(\"Corrupt MIPS ABI Flags section.\\n\"));\n\t  res = FALSE;\n\t}\n      else\n\t{\n\t  abiflags_ext = get_data (NULL, file, sect->sh_offset, 1,\n\t\t\t\t   sect->sh_size, _(\"MIPS ABI Flags section\"));\n\t  if (abiflags_ext)\n\t    {\n\t      abiflags_in.version = BYTE_GET (abiflags_ext->version);\n\t      abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level);\n\t      abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev);\n\t      abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size);\n\t      abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size);\n\t      abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size);\n\t      abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi);\n\t      abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext);\n\t      abiflags_in.ases = BYTE_GET (abiflags_ext->ases);\n\t      abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1);\n\t      abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2);\n\n\t      printf (\"\\nMIPS ABI Flags Version: %d\\n\", abiflags_in.version);\n\t      printf (\"\\nISA: MIPS%d\", abiflags_in.isa_level);\n\t      if (abiflags_in.isa_rev > 1)\n\t\tprintf (\"r%d\", abiflags_in.isa_rev);\n\t      printf (\"\\nGPR size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.gpr_size));\n\t      printf (\"\\nCPR1 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr1_size));\n\t      printf (\"\\nCPR2 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr2_size));\n\t      fputs (\"\\nFP ABI: \", stdout);\n\t      print_mips_fp_abi_value (abiflags_in.fp_abi);\n\t      fputs (\"ISA Extension: \", stdout);\n\t      print_mips_isa_ext (abiflags_in.isa_ext);\n\t      fputs (\"\\nASEs:\", stdout);\n\t      print_mips_ases (abiflags_in.ases);\n\t      printf (\"\\nFLAGS 1: %8.8lx\", abiflags_in.flags1);\n\t      printf (\"\\nFLAGS 2: %8.8lx\", abiflags_in.flags2);\n\t      fputc ('\\n', stdout);\n\t      free (abiflags_ext);\n\t    }\n\t}\n    }\n\n  /* We have a lot of special sections.  Thanks SGI!  */\n  if (dynamic_section == NULL)\n    /* No information available.  */\n    return res;\n\n  for (entry = dynamic_section;\n       /* PR 17531 file: 012-50589-0.004.  */\n       entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL;\n       ++entry)\n    switch (entry->d_tag)\n      {\n      case DT_MIPS_LIBLIST:\n\tliblist_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     liblistno * sizeof (Elf32_External_Lib));\n\tbreak;\n      case DT_MIPS_LIBLISTNO:\n\tliblistno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_OPTIONS:\n\toptions_offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\tbreak;\n      case DT_MIPS_CONFLICT:\n\tconflicts_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     conflictsno * sizeof (Elf32_External_Conflict));\n\tbreak;\n      case DT_MIPS_CONFLICTNO:\n\tconflictsno = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTGOT:\n\tpltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_MIPS_LOCAL_GOTNO:\n\tlocal_gotno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_GOTSYM:\n\tgotsym = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_SYMTABNO:\n\tsymtabno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_PLTGOT:\n\tmips_pltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_PLTREL:\n\tpltrel = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTRELSZ:\n\tpltrelsz = entry->d_un.d_val;\n\tbreak;\n      case DT_JMPREL:\n\tjmprel = entry->d_un.d_ptr;\n\tbreak;\n      default:\n\tbreak;\n      }\n\n  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)\n    {\n      Elf32_External_Lib * elib;\n      size_t cnt;\n\n      elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset,\n                                              liblistno,\n                                              sizeof (Elf32_External_Lib),\n                                              _(\"liblist section data\"));\n      if (elib)\n\t{\n\t  printf (_(\"\\nSection '.liblist' contains %lu entries:\\n\"),\n\t\t  (unsigned long) liblistno);\n\t  fputs (_(\"     Library              Time Stamp          Checksum   Version Flags\\n\"),\n\t\t stdout);\n\n\t  for (cnt = 0; cnt < liblistno; ++cnt)\n\t    {\n\t      Elf32_Lib liblist;\n\t      time_t atime;\n\t      char timebuf[128];\n\t      struct tm * tmp;\n\n\t      liblist.l_name = BYTE_GET (elib[cnt].l_name);\n\t      atime = BYTE_GET (elib[cnt].l_time_stamp);\n\t      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);\n\t      liblist.l_version = BYTE_GET (elib[cnt].l_version);\n\t      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);\n\n\t      tmp = gmtime (&atime);\n\t      snprintf (timebuf, sizeof (timebuf),\n\t\t\t\"%04u-%02u-%02uT%02u:%02u:%02u\",\n\t\t\ttmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,\n\t\t\ttmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n\t      printf (\"%3lu: \", (unsigned long) cnt);\n\t      if (VALID_DYNAMIC_NAME (liblist.l_name))\n\t\tprint_symbol (20, GET_DYNAMIC_NAME (liblist.l_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %9ld>\"), liblist.l_name);\n\t      printf (\" %s %#10lx %-7ld\", timebuf, liblist.l_checksum,\n\t\t      liblist.l_version);\n\n\t      if (liblist.l_flags == 0)\n\t\tputs (_(\" NONE\"));\n\t      else\n\t\t{\n\t\t  static const struct\n\t\t  {\n\t\t    const char * name;\n\t\t    int bit;\n\t\t  }\n\t\t  l_flags_vals[] =\n\t\t  {\n\t\t    { \" EXACT_MATCH\", LL_EXACT_MATCH },\n\t\t    { \" IGNORE_INT_VER\", LL_IGNORE_INT_VER },\n\t\t    { \" REQUIRE_MINOR\", LL_REQUIRE_MINOR },\n\t\t    { \" EXPORTS\", LL_EXPORTS },\n\t\t    { \" DELAY_LOAD\", LL_DELAY_LOAD },\n\t\t    { \" DELTA\", LL_DELTA }\n\t\t  };\n\t\t  int flags = liblist.l_flags;\n\t\t  size_t fcnt;\n\n\t\t  for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt)\n\t\t    if ((flags & l_flags_vals[fcnt].bit) != 0)\n\t\t      {\n\t\t\tfputs (l_flags_vals[fcnt].name, stdout);\n\t\t\tflags ^= l_flags_vals[fcnt].bit;\n\t\t      }\n\t\t  if (flags != 0)\n\t\t    printf (\" %#x\", (unsigned int) flags);\n\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\n\t  free (elib);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (options_offset != 0)\n    {\n      Elf_External_Options * eopt;\n      Elf_Internal_Options * iopt;\n      Elf_Internal_Options * option;\n      size_t offset;\n      int cnt;\n      sect = section_headers;\n\n      /* Find the section header so that we get the size.  */\n      sect = find_section_by_type (SHT_MIPS_OPTIONS);\n      /* PR 17533 file: 012-277276-0.004.  */\n      if (sect == NULL)\n\t{\n\t  error (_(\"No MIPS_OPTIONS header found\\n\"));\n\t  return FALSE;\n\t}\n\n      eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1,\n                                                sect->sh_size, _(\"options\"));\n      if (eopt)\n\t{\n\t  iopt = (Elf_Internal_Options *)\n              cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));\n\t  if (iopt == NULL)\n\t    {\n\t      error (_(\"Out of memory allocating space for MIPS options\\n\"));\n\t      return FALSE;\n\t    }\n\n\t  offset = cnt = 0;\n\t  option = iopt;\n\n\t  while (offset <= sect->sh_size - sizeof (* eopt))\n\t    {\n\t      Elf_External_Options * eoption;\n\n\t      eoption = (Elf_External_Options *) ((char *) eopt + offset);\n\n\t      option->kind = BYTE_GET (eoption->kind);\n\t      option->size = BYTE_GET (eoption->size);\n\t      option->section = BYTE_GET (eoption->section);\n\t      option->info = BYTE_GET (eoption->info);\n\n\t      /* PR 17531: file: ffa0fa3b.  */\n\t      if (option->size < sizeof (* eopt)\n\t\t  || offset + option->size > sect->sh_size)\n\t\t{\n\t\t  error (_(\"Invalid size (%u) for MIPS option\\n\"), option->size);\n\t\t  return FALSE;\n\t\t}\n\t      offset += option->size;\n\n\t      ++option;\n\t      ++cnt;\n\t    }\n\n\t  printf (_(\"\\nSection '%s' contains %d entries:\\n\"),\n\t\t  printable_section_name (sect), cnt);\n\n\t  option = iopt;\n\t  offset = 0;\n\n\t  while (cnt-- > 0)\n\t    {\n\t      size_t len;\n\n\t      switch (option->kind)\n\t\t{\n\t\tcase ODK_NULL:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" NULL       %d %lx\", option->section, option->info);\n\t\t  break;\n\t\tcase ODK_REGINFO:\n\t\t  printf (\" REGINFO    \");\n\t\t  if (elf_header.e_machine == EM_MIPS)\n\t\t    {\n\t\t      /* 32bit form.  */\n\t\t      Elf32_External_RegInfo * ereg;\n\t\t      Elf32_RegInfo reginfo;\n\n\t\t      ereg = (Elf32_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x%lx\\n\",\n\t\t\t      reginfo.ri_gprmask,\n\t\t\t      (unsigned long) reginfo.ri_gp_value);\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* 64 bit form.  */\n\t\t      Elf64_External_RegInfo * ereg;\n\t\t      Elf64_Internal_RegInfo reginfo;\n\n\t\t      ereg = (Elf64_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x\",\n\t\t\t      reginfo.ri_gprmask);\n\t\t      printf_vma (reginfo.ri_gp_value);\n\t\t      printf (\"\\n\");\n\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  ++option;\n\t\t  continue;\n\t\tcase ODK_EXCEPTIONS:\n\t\t  fputs (\" EXCEPTIONS fpe_min(\", stdout);\n\t\t  process_mips_fpe_exception (option->info & OEX_FPU_MIN);\n\t\t  fputs (\") fpe_max(\", stdout);\n\t\t  process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8);\n\t\t  fputs (\")\", stdout);\n\n\t\t  if (option->info & OEX_PAGE0)\n\t\t    fputs (\" PAGE0\", stdout);\n\t\t  if (option->info & OEX_SMM)\n\t\t    fputs (\" SMM\", stdout);\n\t\t  if (option->info & OEX_FPDBUG)\n\t\t    fputs (\" FPDBUG\", stdout);\n\t\t  if (option->info & OEX_DISMISS)\n\t\t    fputs (\" DISMISS\", stdout);\n\t\t  break;\n\t\tcase ODK_PAD:\n\t\t  fputs (\" PAD       \", stdout);\n\t\t  if (option->info & OPAD_PREFIX)\n\t\t    fputs (\" PREFIX\", stdout);\n\t\t  if (option->info & OPAD_POSTFIX)\n\t\t    fputs (\" POSTFIX\", stdout);\n\t\t  if (option->info & OPAD_SYMBOL)\n\t\t    fputs (\" SYMBOL\", stdout);\n\t\t  break;\n\t\tcase ODK_HWPATCH:\n\t\t  fputs (\" HWPATCH   \", stdout);\n\t\t  if (option->info & OHW_R4KEOP)\n\t\t    fputs (\" R4KEOP\", stdout);\n\t\t  if (option->info & OHW_R8KPFETCH)\n\t\t    fputs (\" R8KPFETCH\", stdout);\n\t\t  if (option->info & OHW_R5KEOP)\n\t\t    fputs (\" R5KEOP\", stdout);\n\t\t  if (option->info & OHW_R5KCVTL)\n\t\t    fputs (\" R5KCVTL\", stdout);\n\t\t  break;\n\t\tcase ODK_FILL:\n\t\t  fputs (\" FILL       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_TAGS:\n\t\t  fputs (\" TAGS       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_HWAND:\n\t\t  fputs (\" HWAND     \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_HWOR:\n\t\t  fputs (\" HWOR      \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_GP_GROUP:\n\t\t  printf (\" GP_GROUP  %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tcase ODK_IDENT:\n\t\t  printf (\" IDENT     %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tdefault:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" %3d ???     %d %lx\",\n\t\t\t  option->kind, option->section, option->info);\n\t\t  break;\n\t\t}\n\n\t      len = sizeof (* eopt);\n\t      while (len < option->size)\n\t\t{\n\t\t  unsigned char datum = * ((unsigned char *) eopt + offset + len);\n\n\t\t  if (ISPRINT (datum))\n\t\t    printf (\"%c\", datum);\n\t\t  else\n\t\t    printf (\"\\\\%03o\", datum);\n\t\t  len ++;\n\t\t}\n\t      fputs (\"\\n\", stdout);\n\n\t      offset += option->size;\n\t      ++option;\n\t    }\n\n\t  free (eopt);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (conflicts_offset != 0 && conflictsno != 0)\n    {\n      Elf32_Conflict * iconf;\n      size_t cnt;\n\n      if (dynamic_symbols == NULL)\n\t{\n\t  error (_(\"conflict list found without a dynamic symbol table\\n\"));\n\t  return FALSE;\n\t}\n\n      /* PR 21345 - print a slightly more helpful error message\n\t if we are sure that the cmalloc will fail.  */\n      if (conflictsno * sizeof (* iconf) > current_file_size)\n\t{\n\t  error (_(\"Overlarge number of conflicts detected: %lx\\n\"),\n\t\t (long) conflictsno);\n\t  return FALSE;\n\t}\n\n      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));\n      if (iconf == NULL)\n\t{\n\t  error (_(\"Out of memory allocating space for dynamic conflicts\\n\"));\n\t  return FALSE;\n\t}\n\n      if (is_32bit_elf)\n\t{\n\t  Elf32_External_Conflict * econf32;\n\n\t  econf32 = (Elf32_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf32), _(\"conflict\"));\n\t  if (!econf32)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf32[cnt]);\n\n\t  free (econf32);\n\t}\n      else\n\t{\n\t  Elf64_External_Conflict * econf64;\n\n\t  econf64 = (Elf64_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf64), _(\"conflict\"));\n\t  if (!econf64)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf64[cnt]);\n\n\t  free (econf64);\n\t}\n\n      printf (_(\"\\nSection '.conflict' contains %lu entries:\\n\"),\n\t      (unsigned long) conflictsno);\n      puts (_(\"  Num:    Index       Value  Name\"));\n\n      for (cnt = 0; cnt < conflictsno; ++cnt)\n\t{\n\t  printf (\"%5lu: %8lu  \", (unsigned long) cnt, iconf[cnt]);\n\n\t  if (iconf[cnt] >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index>\"));\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym;\n\n\t      psym = & dynamic_symbols[iconf[cnt]];\n\t      print_vma (psym->st_value, FULL_HEX);\n\t      putchar (' ');\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (25, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  putchar ('\\n');\n\t}\n\n      free (iconf);\n    }\n\n  if (pltgot != 0 && local_gotno != 0)\n    {\n      bfd_vma ent, local_end, global_end;\n      size_t i, offset;\n      unsigned char * data;\n      unsigned char * data_end;\n      int addr_size;\n\n      ent = pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      local_end = pltgot + local_gotno * addr_size;\n\n      /* PR binutils/17533 file: 012-111227-0.004  */\n      if (symtabno < gotsym)\n\t{\n\t  error (_(\"The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\\n\"),\n\t\t (unsigned long) gotsym, (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      global_end = local_end + (symtabno - gotsym) * addr_size;\n      /* PR 17531: file: 54c91a34.  */\n      if (global_end < local_end)\n\t{\n\t  error (_(\"Too many GOT symbols: %lu\\n\"), (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      offset = offset_from_vma (file, pltgot, global_end - pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset,\n                                         global_end - pltgot, 1,\n\t\t\t\t\t _(\"Global Offset Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n      data_end = data + (global_end - pltgot);\n\n      printf (_(\"\\nPrimary GOT:\\n\"));\n      printf (_(\" Canonical gp value: \"));\n      print_vma (pltgot + 0x7ff0, LONG_HEX);\n      printf (\"\\n\\n\");\n\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %10s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t      addr_size * 2, _(\"Initial\"));\n      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n      printf (_(\" Lazy resolver\\n\"));\n      if (ent == (bfd_vma) -1)\n\tgoto got_print_fail;\n\n      if (data)\n\t{\n\t  /* PR 21344 */\n\t  if (data + ent - pltgot > data_end - addr_size)\n\t    {\n\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"),\n\t\t     (long) ent);\n\t      goto got_print_fail;\n\t    }\n\t  \n\t  if (byte_get (data + ent - pltgot, addr_size)\n\t      >> (addr_size * 8 - 1) != 0)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (_(\" Module pointer (GNU extension)\\n\"));\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t}\n      printf (\"\\n\");\n\n      if (ent < local_end)\n\t{\n\t  printf (_(\" Local entries:\\n\"));\n\t  printf (\"  %*s %10s %*s\\n\",\n\t\t  addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"));\n\t  while (ent < local_end)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n      if (gotsym < symtabno)\n\t{\n\t  int sym_width;\n\n\t  printf (_(\" Global entries:\\n\"));\n\t  printf (\"  %*s %10s %*s %*s %-7s %3s %s\\n\",\n\t\t  addr_size * 2, _(\"Address\"),\n\t\t  _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"),\n\t\t  addr_size * 2, _(\"Sym.Val.\"),\n\t\t  _(\"Type\"),\n\t\t  /* Note for translators: \"Ndx\" = abbreviated form of \"Index\".  */\n\t\t  _(\"Ndx\"), _(\"Name\"));\n\n\t  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;\n\n\t  for (i = gotsym; i < symtabno; i++)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\" \");\n\n\t      if (dynamic_symbols == NULL)\n\t\tprintf (_(\"<no dynamic symbols>\"));\n\t      else if (i < num_dynamic_syms)\n\t\t{\n\t\t  Elf_Internal_Sym * psym = dynamic_symbols + i;\n\n\t\t  print_vma (psym->st_value, LONG_HEX);\n\t\t  printf (\" %-7s %3s \",\n\t\t\t  get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t\t  get_symbol_index_type (psym->st_shndx));\n\n\t\t  if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\t    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t\t  else\n\t\t    printf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t\t}\n\t      else\n\t\tprintf (_(\"<symbol index %lu exceeds number of dynamic symbols>\"),\n\t\t\t(unsigned long) i);\n\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tbreak;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n    got_print_fail:\n      if (data)\n\tfree (data);\n    }\n\n  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)\n    {\n      bfd_vma ent, end;\n      size_t offset, rel_offset;\n      unsigned long count, i;\n      unsigned char * data;\n      int addr_size, sym_width;\n      Elf_Internal_Rela * rels;\n\n      rel_offset = offset_from_vma (file, jmprel, pltrelsz);\n      if (pltrel == DT_RELA)\n\t{\n\t  if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n      else\n\t{\n\t  if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n\n      ent = mips_pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      end = mips_pltgot + (2 + count) * addr_size;\n\n      offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot,\n                                         1, _(\"Procedure Linkage Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n\n      printf (\"\\nPLT GOT:\\n\\n\");\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), addr_size * 2, _(\"Initial\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" PLT lazy resolver\\n\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" Module pointer\\n\"));\n      printf (\"\\n\");\n\n      printf (_(\" Entries:\\n\"));\n      printf (\"  %*s %*s %*s %-7s %3s %s\\n\",\n\t      addr_size * 2, _(\"Address\"),\n\t      addr_size * 2, _(\"Initial\"),\n\t      addr_size * 2, _(\"Sym.Val.\"), _(\"Type\"), _(\"Ndx\"), _(\"Name\"));\n      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;\n      for (i = 0; i < count; i++)\n\t{\n\t  unsigned long idx = get_reloc_symindex (rels[i].r_info);\n\n\t  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n\t  printf (\" \");\n\n\t  if (idx >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index: %lu>\"), idx);\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym = dynamic_symbols + idx;\n\n\t      print_vma (psym->st_value, LONG_HEX);\n\t      printf (\" %-7s %3s \",\n\t\t      get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t      get_symbol_index_type (psym->st_shndx));\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  printf (\"\\n\");\n\t}\n      printf (\"\\n\");\n\n      if (data)\n\tfree (data);\n      free (rels);\n    }\n\n  return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -447,6 +447,15 @@\n \t  return FALSE;\n \t}\n \n+      /* PR 21345 - print a slightly more helpful error message\n+\t if we are sure that the cmalloc will fail.  */\n+      if (conflictsno * sizeof (* iconf) > current_file_size)\n+\t{\n+\t  error (_(\"Overlarge number of conflicts detected: %lx\\n\"),\n+\t\t (long) conflictsno);\n+\t  return FALSE;\n+\t}\n+\n       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));\n       if (iconf == NULL)\n \t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      /* PR 21345 - print a slightly more helpful error message",
                "\t if we are sure that the cmalloc will fail.  */",
                "      if (conflictsno * sizeof (* iconf) > current_file_size)",
                "\t{",
                "\t  error (_(\"Overlarge number of conflicts detected: %lx\\n\"),",
                "\t\t (long) conflictsno);",
                "\t  return FALSE;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9040",
        "func_name": "binutils-gdb/process_dynamic_section",
        "description": "GNU Binutils 2017-04-03 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash), related to the process_mips_specific function in readelf.c, via a crafted ELF file that triggers a large memory-allocation attempt.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=7296a62a2a237f6b1ad8db8c38b090e9f592c8cf",
        "commit_title": "",
        "commit_text": "readelf: fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.  \tPR binutils/21379 \t* readelf.c (process_dynamic_section): Detect over large section \toffsets in the DT_SYMTAB entry.  \tPR binutils/21345 \t* readelf.c (process_mips_specific): Catch an unfeasible memory \tallocation before it happens and print a suitable error message. ",
        "func_before": "static bfd_boolean\nprocess_dynamic_section (FILE * file)\n{\n  Elf_Internal_Dyn * entry;\n\n  if (dynamic_size == 0)\n    {\n      if (do_dynamic)\n\tprintf (_(\"\\nThere is no dynamic section in this file.\\n\"));\n\n      return TRUE;\n    }\n\n  if (is_32bit_elf)\n    {\n      if (! get_32bit_dynamic_section (file))\n\treturn FALSE;\n    }\n  else\n    {\n      if (! get_64bit_dynamic_section (file))\n\treturn FALSE;\n    }\n\n  /* Find the appropriate symbol table.  */\n  if (dynamic_symbols == NULL)\n    {\n      for (entry = dynamic_section;\n\t   entry < dynamic_section + dynamic_nent;\n\t   ++entry)\n\t{\n\t  Elf_Internal_Shdr section;\n\n\t  if (entry->d_tag != DT_SYMTAB)\n\t    continue;\n\n\t  dynamic_info[DT_SYMTAB] = entry->d_un.d_val;\n\n\t  /* Since we do not know how big the symbol table is,\n\t     we default to reading in the entire file (!) and\n\t     processing that.  This is overkill, I know, but it\n\t     should work.  */\n\t  section.sh_offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\n\t  if (archive_file_offset != 0)\n\t    section.sh_size = archive_file_size - section.sh_offset;\n\t  else\n\t    {\n\t      if (fseek (file, 0, SEEK_END))\n\t\terror (_(\"Unable to seek to end of file!\\n\"));\n\n\t      section.sh_size = ftell (file) - section.sh_offset;\n\t    }\n\n\t  if (is_32bit_elf)\n\t    section.sh_entsize = sizeof (Elf32_External_Sym);\n\t  else\n\t    section.sh_entsize = sizeof (Elf64_External_Sym);\n\t  section.sh_name = string_table_length;\n\n\t  dynamic_symbols = GET_ELF_SYMBOLS (file, &section, & num_dynamic_syms);\n\t  if (num_dynamic_syms < 1)\n\t    {\n\t      error (_(\"Unable to determine the number of symbols to load\\n\"));\n\t      continue;\n\t    }\n\t}\n    }\n\n  /* Similarly find a string table.  */\n  if (dynamic_strings == NULL)\n    {\n      for (entry = dynamic_section;\n\t   entry < dynamic_section + dynamic_nent;\n\t   ++entry)\n\t{\n\t  unsigned long offset;\n\t  long str_tab_len;\n\n\t  if (entry->d_tag != DT_STRTAB)\n\t    continue;\n\n\t  dynamic_info[DT_STRTAB] = entry->d_un.d_val;\n\n\t  /* Since we do not know how big the string table is,\n\t     we default to reading in the entire file (!) and\n\t     processing that.  This is overkill, I know, but it\n\t     should work.  */\n\n\t  offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\n\t  if (archive_file_offset != 0)\n\t    str_tab_len = archive_file_size - offset;\n\t  else\n\t    {\n\t      if (fseek (file, 0, SEEK_END))\n\t\terror (_(\"Unable to seek to end of file\\n\"));\n\t      str_tab_len = ftell (file) - offset;\n\t    }\n\n\t  if (str_tab_len < 1)\n\t    {\n\t      error\n\t\t(_(\"Unable to determine the length of the dynamic string table\\n\"));\n\t      continue;\n\t    }\n\n\t  dynamic_strings = (char *) get_data (NULL, file, offset, 1,\n                                               str_tab_len,\n                                               _(\"dynamic string table\"));\n\t  dynamic_strings_length = dynamic_strings == NULL ? 0 : str_tab_len;\n\t  break;\n\t}\n    }\n\n  /* And find the syminfo section if available.  */\n  if (dynamic_syminfo == NULL)\n    {\n      unsigned long syminsz = 0;\n\n      for (entry = dynamic_section;\n\t   entry < dynamic_section + dynamic_nent;\n\t   ++entry)\n\t{\n\t  if (entry->d_tag == DT_SYMINENT)\n\t    {\n\t      /* Note: these braces are necessary to avoid a syntax\n\t\t error from the SunOS4 C compiler.  */\n\t      /* PR binutils/17531: A corrupt file can trigger this test.\n\t\t So do not use an assert, instead generate an error message.  */\n\t      if (sizeof (Elf_External_Syminfo) != entry->d_un.d_val)\n\t\terror (_(\"Bad value (%d) for SYMINENT entry\\n\"),\n\t\t       (int) entry->d_un.d_val);\n\t    }\n\t  else if (entry->d_tag == DT_SYMINSZ)\n\t    syminsz = entry->d_un.d_val;\n\t  else if (entry->d_tag == DT_SYMINFO)\n\t    dynamic_syminfo_offset = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t\t\t\t      syminsz);\n\t}\n\n      if (dynamic_syminfo_offset != 0 && syminsz != 0)\n\t{\n\t  Elf_External_Syminfo * extsyminfo;\n\t  Elf_External_Syminfo * extsym;\n\t  Elf_Internal_Syminfo * syminfo;\n\n\t  /* There is a syminfo section.  Read the data.  */\n\t  extsyminfo = (Elf_External_Syminfo *)\n              get_data (NULL, file, dynamic_syminfo_offset, 1, syminsz,\n                        _(\"symbol information\"));\n\t  if (!extsyminfo)\n\t    return FALSE;\n\n\t  dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);\n\t  if (dynamic_syminfo == NULL)\n\t    {\n\t      error (_(\"Out of memory allocating %lu byte for dynamic symbol info\\n\"),\n\t\t     (unsigned long) syminsz);\n\t      return FALSE;\n\t    }\n\n\t  dynamic_syminfo_nent = syminsz / sizeof (Elf_External_Syminfo);\n\t  for (syminfo = dynamic_syminfo, extsym = extsyminfo;\n\t       syminfo < dynamic_syminfo + dynamic_syminfo_nent;\n\t       ++syminfo, ++extsym)\n\t    {\n\t      syminfo->si_boundto = BYTE_GET (extsym->si_boundto);\n\t      syminfo->si_flags = BYTE_GET (extsym->si_flags);\n\t    }\n\n\t  free (extsyminfo);\n\t}\n    }\n\n  if (do_dynamic && dynamic_addr)\n    printf (_(\"\\nDynamic section at offset 0x%lx contains %lu entries:\\n\"),\n\t    dynamic_addr, (unsigned long) dynamic_nent);\n  if (do_dynamic)\n    printf (_(\"  Tag        Type                         Name/Value\\n\"));\n\n  for (entry = dynamic_section;\n       entry < dynamic_section + dynamic_nent;\n       entry++)\n    {\n      if (do_dynamic)\n\t{\n\t  const char * dtype;\n\n\t  putchar (' ');\n\t  print_vma (entry->d_tag, FULL_HEX);\n\t  dtype = get_dynamic_type (entry->d_tag);\n\t  printf (\" (%s)%*s\", dtype,\n\t\t  ((is_32bit_elf ? 27 : 19) - (int) strlen (dtype)), \" \");\n\t}\n\n      switch (entry->d_tag)\n\t{\n\tcase DT_FLAGS:\n\t  if (do_dynamic)\n\t    print_dynamic_flags (entry->d_un.d_val);\n\t  break;\n\n\tcase DT_AUXILIARY:\n\tcase DT_FILTER:\n\tcase DT_CONFIG:\n\tcase DT_DEPAUDIT:\n\tcase DT_AUDIT:\n\t  if (do_dynamic)\n\t    {\n\t      switch (entry->d_tag)\n\t\t{\n\t\tcase DT_AUXILIARY:\n\t\t  printf (_(\"Auxiliary library\"));\n\t\t  break;\n\n\t\tcase DT_FILTER:\n\t\t  printf (_(\"Filter library\"));\n\t\t  break;\n\n\t\tcase DT_CONFIG:\n\t\t  printf (_(\"Configuration file\"));\n\t\t  break;\n\n\t\tcase DT_DEPAUDIT:\n\t\t  printf (_(\"Dependency audit library\"));\n\t\t  break;\n\n\t\tcase DT_AUDIT:\n\t\t  printf (_(\"Audit library\"));\n\t\t  break;\n\t\t}\n\n\t      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))\n\t\tprintf (\": [%s]\\n\", GET_DYNAMIC_NAME (entry->d_un.d_val));\n\t      else\n\t\t{\n\t\t  printf (\": \");\n\t\t  print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t\t  putchar ('\\n');\n\t\t}\n\t    }\n\t  break;\n\n\tcase DT_FEATURE:\n\t  if (do_dynamic)\n\t    {\n\t      printf (_(\"Flags:\"));\n\n\t      if (entry->d_un.d_val == 0)\n\t\tprintf (_(\" None\\n\"));\n\t      else\n\t\t{\n\t\t  unsigned long int val = entry->d_un.d_val;\n\n\t\t  if (val & DTF_1_PARINIT)\n\t\t    {\n\t\t      printf (\" PARINIT\");\n\t\t      val ^= DTF_1_PARINIT;\n\t\t    }\n\t\t  if (val & DTF_1_CONFEXP)\n\t\t    {\n\t\t      printf (\" CONFEXP\");\n\t\t      val ^= DTF_1_CONFEXP;\n\t\t    }\n\t\t  if (val != 0)\n\t\t    printf (\" %lx\", val);\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\t  break;\n\n\tcase DT_POSFLAG_1:\n\t  if (do_dynamic)\n\t    {\n\t      printf (_(\"Flags:\"));\n\n\t      if (entry->d_un.d_val == 0)\n\t\tprintf (_(\" None\\n\"));\n\t      else\n\t\t{\n\t\t  unsigned long int val = entry->d_un.d_val;\n\n\t\t  if (val & DF_P1_LAZYLOAD)\n\t\t    {\n\t\t      printf (\" LAZYLOAD\");\n\t\t      val ^= DF_P1_LAZYLOAD;\n\t\t    }\n\t\t  if (val & DF_P1_GROUPPERM)\n\t\t    {\n\t\t      printf (\" GROUPPERM\");\n\t\t      val ^= DF_P1_GROUPPERM;\n\t\t    }\n\t\t  if (val != 0)\n\t\t    printf (\" %lx\", val);\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\t  break;\n\n\tcase DT_FLAGS_1:\n\t  if (do_dynamic)\n\t    {\n\t      printf (_(\"Flags:\"));\n\t      if (entry->d_un.d_val == 0)\n\t\tprintf (_(\" None\\n\"));\n\t      else\n\t\t{\n\t\t  unsigned long int val = entry->d_un.d_val;\n\n\t\t  if (val & DF_1_NOW)\n\t\t    {\n\t\t      printf (\" NOW\");\n\t\t      val ^= DF_1_NOW;\n\t\t    }\n\t\t  if (val & DF_1_GLOBAL)\n\t\t    {\n\t\t      printf (\" GLOBAL\");\n\t\t      val ^= DF_1_GLOBAL;\n\t\t    }\n\t\t  if (val & DF_1_GROUP)\n\t\t    {\n\t\t      printf (\" GROUP\");\n\t\t      val ^= DF_1_GROUP;\n\t\t    }\n\t\t  if (val & DF_1_NODELETE)\n\t\t    {\n\t\t      printf (\" NODELETE\");\n\t\t      val ^= DF_1_NODELETE;\n\t\t    }\n\t\t  if (val & DF_1_LOADFLTR)\n\t\t    {\n\t\t      printf (\" LOADFLTR\");\n\t\t      val ^= DF_1_LOADFLTR;\n\t\t    }\n\t\t  if (val & DF_1_INITFIRST)\n\t\t    {\n\t\t      printf (\" INITFIRST\");\n\t\t      val ^= DF_1_INITFIRST;\n\t\t    }\n\t\t  if (val & DF_1_NOOPEN)\n\t\t    {\n\t\t      printf (\" NOOPEN\");\n\t\t      val ^= DF_1_NOOPEN;\n\t\t    }\n\t\t  if (val & DF_1_ORIGIN)\n\t\t    {\n\t\t      printf (\" ORIGIN\");\n\t\t      val ^= DF_1_ORIGIN;\n\t\t    }\n\t\t  if (val & DF_1_DIRECT)\n\t\t    {\n\t\t      printf (\" DIRECT\");\n\t\t      val ^= DF_1_DIRECT;\n\t\t    }\n\t\t  if (val & DF_1_TRANS)\n\t\t    {\n\t\t      printf (\" TRANS\");\n\t\t      val ^= DF_1_TRANS;\n\t\t    }\n\t\t  if (val & DF_1_INTERPOSE)\n\t\t    {\n\t\t      printf (\" INTERPOSE\");\n\t\t      val ^= DF_1_INTERPOSE;\n\t\t    }\n\t\t  if (val & DF_1_NODEFLIB)\n\t\t    {\n\t\t      printf (\" NODEFLIB\");\n\t\t      val ^= DF_1_NODEFLIB;\n\t\t    }\n\t\t  if (val & DF_1_NODUMP)\n\t\t    {\n\t\t      printf (\" NODUMP\");\n\t\t      val ^= DF_1_NODUMP;\n\t\t    }\n\t\t  if (val & DF_1_CONFALT)\n\t\t    {\n\t\t      printf (\" CONFALT\");\n\t\t      val ^= DF_1_CONFALT;\n\t\t    }\n\t\t  if (val & DF_1_ENDFILTEE)\n\t\t    {\n\t\t      printf (\" ENDFILTEE\");\n\t\t      val ^= DF_1_ENDFILTEE;\n\t\t    }\n\t\t  if (val & DF_1_DISPRELDNE)\n\t\t    {\n\t\t      printf (\" DISPRELDNE\");\n\t\t      val ^= DF_1_DISPRELDNE;\n\t\t    }\n\t\t  if (val & DF_1_DISPRELPND)\n\t\t    {\n\t\t      printf (\" DISPRELPND\");\n\t\t      val ^= DF_1_DISPRELPND;\n\t\t    }\n\t\t  if (val & DF_1_NODIRECT)\n\t\t    {\n\t\t      printf (\" NODIRECT\");\n\t\t      val ^= DF_1_NODIRECT;\n\t\t    }\n\t\t  if (val & DF_1_IGNMULDEF)\n\t\t    {\n\t\t      printf (\" IGNMULDEF\");\n\t\t      val ^= DF_1_IGNMULDEF;\n\t\t    }\n\t\t  if (val & DF_1_NOKSYMS)\n\t\t    {\n\t\t      printf (\" NOKSYMS\");\n\t\t      val ^= DF_1_NOKSYMS;\n\t\t    }\n\t\t  if (val & DF_1_NOHDR)\n\t\t    {\n\t\t      printf (\" NOHDR\");\n\t\t      val ^= DF_1_NOHDR;\n\t\t    }\n\t\t  if (val & DF_1_EDITED)\n\t\t    {\n\t\t      printf (\" EDITED\");\n\t\t      val ^= DF_1_EDITED;\n\t\t    }\n\t\t  if (val & DF_1_NORELOC)\n\t\t    {\n\t\t      printf (\" NORELOC\");\n\t\t      val ^= DF_1_NORELOC;\n\t\t    }\n\t\t  if (val & DF_1_SYMINTPOSE)\n\t\t    {\n\t\t      printf (\" SYMINTPOSE\");\n\t\t      val ^= DF_1_SYMINTPOSE;\n\t\t    }\n\t\t  if (val & DF_1_GLOBAUDIT)\n\t\t    {\n\t\t      printf (\" GLOBAUDIT\");\n\t\t      val ^= DF_1_GLOBAUDIT;\n\t\t    }\n\t\t  if (val & DF_1_SINGLETON)\n\t\t    {\n\t\t      printf (\" SINGLETON\");\n\t\t      val ^= DF_1_SINGLETON;\n\t\t    }\n\t\t  if (val & DF_1_STUB)\n\t\t    {\n\t\t      printf (\" STUB\");\n\t\t      val ^= DF_1_STUB;\n\t\t    }\n\t\t  if (val & DF_1_PIE)\n\t\t    {\n\t\t      printf (\" PIE\");\n\t\t      val ^= DF_1_PIE;\n\t\t    }\n\t\t  if (val != 0)\n\t\t    printf (\" %lx\", val);\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\t  break;\n\n\tcase DT_PLTREL:\n\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n\t  if (do_dynamic)\n\t    puts (get_dynamic_type (entry->d_un.d_val));\n\t  break;\n\n\tcase DT_NULL\t:\n\tcase DT_NEEDED\t:\n\tcase DT_PLTGOT\t:\n\tcase DT_HASH\t:\n\tcase DT_STRTAB\t:\n\tcase DT_SYMTAB\t:\n\tcase DT_RELA\t:\n\tcase DT_INIT\t:\n\tcase DT_FINI\t:\n\tcase DT_SONAME\t:\n\tcase DT_RPATH\t:\n\tcase DT_SYMBOLIC:\n\tcase DT_REL\t:\n\tcase DT_DEBUG\t:\n\tcase DT_TEXTREL\t:\n\tcase DT_JMPREL\t:\n\tcase DT_RUNPATH\t:\n\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n\n\t  if (do_dynamic)\n\t    {\n\t      char * name;\n\n\t      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))\n\t\tname = GET_DYNAMIC_NAME (entry->d_un.d_val);\n\t      else\n\t\tname = NULL;\n\n\t      if (name)\n\t\t{\n\t\t  switch (entry->d_tag)\n\t\t    {\n\t\t    case DT_NEEDED:\n\t\t      printf (_(\"Shared library: [%s]\"), name);\n\n\t\t      if (streq (name, program_interpreter))\n\t\t\tprintf (_(\" program interpreter\"));\n\t\t      break;\n\n\t\t    case DT_SONAME:\n\t\t      printf (_(\"Library soname: [%s]\"), name);\n\t\t      break;\n\n\t\t    case DT_RPATH:\n\t\t      printf (_(\"Library rpath: [%s]\"), name);\n\t\t      break;\n\n\t\t    case DT_RUNPATH:\n\t\t      printf (_(\"Library runpath: [%s]\"), name);\n\t\t      break;\n\n\t\t    default:\n\t\t      print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t\t      break;\n\t\t    }\n\t\t}\n\t      else\n\t\tprint_vma (entry->d_un.d_val, PREFIX_HEX);\n\n\t      putchar ('\\n');\n\t    }\n\t  break;\n\n\tcase DT_PLTRELSZ:\n\tcase DT_RELASZ\t:\n\tcase DT_STRSZ\t:\n\tcase DT_RELSZ\t:\n\tcase DT_RELAENT\t:\n\tcase DT_SYMENT\t:\n\tcase DT_RELENT\t:\n\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n\t  /* Fall through.  */\n\tcase DT_PLTPADSZ:\n\tcase DT_MOVEENT\t:\n\tcase DT_MOVESZ\t:\n\tcase DT_INIT_ARRAYSZ:\n\tcase DT_FINI_ARRAYSZ:\n\tcase DT_GNU_CONFLICTSZ:\n\tcase DT_GNU_LIBLISTSZ:\n\t  if (do_dynamic)\n\t    {\n\t      print_vma (entry->d_un.d_val, UNSIGNED);\n\t      printf (_(\" (bytes)\\n\"));\n\t    }\n\t  break;\n\n\tcase DT_VERDEFNUM:\n\tcase DT_VERNEEDNUM:\n\tcase DT_RELACOUNT:\n\tcase DT_RELCOUNT:\n\t  if (do_dynamic)\n\t    {\n\t      print_vma (entry->d_un.d_val, UNSIGNED);\n\t      putchar ('\\n');\n\t    }\n\t  break;\n\n\tcase DT_SYMINSZ:\n\tcase DT_SYMINENT:\n\tcase DT_SYMINFO:\n\tcase DT_USED:\n\tcase DT_INIT_ARRAY:\n\tcase DT_FINI_ARRAY:\n\t  if (do_dynamic)\n\t    {\n\t      if (entry->d_tag == DT_USED\n\t\t  && VALID_DYNAMIC_NAME (entry->d_un.d_val))\n\t\t{\n\t\t  char * name = GET_DYNAMIC_NAME (entry->d_un.d_val);\n\n\t\t  if (*name)\n\t\t    {\n\t\t      printf (_(\"Not needed object: [%s]\\n\"), name);\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t      print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t      putchar ('\\n');\n\t    }\n\t  break;\n\n\tcase DT_BIND_NOW:\n\t  /* The value of this entry is ignored.  */\n\t  if (do_dynamic)\n\t    putchar ('\\n');\n\t  break;\n\n\tcase DT_GNU_PRELINKED:\n\t  if (do_dynamic)\n\t    {\n\t      struct tm * tmp;\n\t      time_t atime = entry->d_un.d_val;\n\n\t      tmp = gmtime (&atime);\n\t      /* PR 17533 file: 041-1244816-0.004.  */\n\t      if (tmp == NULL)\n\t\tprintf (_(\"<corrupt time val: %lx\"),\n\t\t\t(unsigned long) atime);\n\t      else\n\t\tprintf (\"%04u-%02u-%02uT%02u:%02u:%02u\\n\",\n\t\t\ttmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,\n\t\t\ttmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n\t    }\n\t  break;\n\n\tcase DT_GNU_HASH:\n\t  dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n\t  if (do_dynamic)\n\t    {\n\t      print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t      putchar ('\\n');\n\t    }\n\t  break;\n\n\tdefault:\n\t  if ((entry->d_tag >= DT_VERSYM) && (entry->d_tag <= DT_VERNEEDNUM))\n\t    version_info[DT_VERSIONTAGIDX (entry->d_tag)] =\n\t      entry->d_un.d_val;\n\n\t  if (do_dynamic)\n\t    {\n\t      switch (elf_header.e_machine)\n\t\t{\n\t\tcase EM_MIPS:\n\t\tcase EM_MIPS_RS3_LE:\n\t\t  dynamic_section_mips_val (entry);\n\t\t  break;\n\t\tcase EM_PARISC:\n\t\t  dynamic_section_parisc_val (entry);\n\t\t  break;\n\t\tcase EM_IA_64:\n\t\t  dynamic_section_ia64_val (entry);\n\t\t  break;\n\t\tdefault:\n\t\t  print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t\t  putchar ('\\n');\n\t\t}\n\t    }\n\t  break;\n\t}\n    }\n\n  return TRUE;\n}",
        "func": "static bfd_boolean\nprocess_dynamic_section (FILE * file)\n{\n  Elf_Internal_Dyn * entry;\n\n  if (dynamic_size == 0)\n    {\n      if (do_dynamic)\n\tprintf (_(\"\\nThere is no dynamic section in this file.\\n\"));\n\n      return TRUE;\n    }\n\n  if (is_32bit_elf)\n    {\n      if (! get_32bit_dynamic_section (file))\n\treturn FALSE;\n    }\n  else\n    {\n      if (! get_64bit_dynamic_section (file))\n\treturn FALSE;\n    }\n\n  /* Find the appropriate symbol table.  */\n  if (dynamic_symbols == NULL)\n    {\n      for (entry = dynamic_section;\n\t   entry < dynamic_section + dynamic_nent;\n\t   ++entry)\n\t{\n\t  Elf_Internal_Shdr section;\n\n\t  if (entry->d_tag != DT_SYMTAB)\n\t    continue;\n\n\t  dynamic_info[DT_SYMTAB] = entry->d_un.d_val;\n\n\t  /* Since we do not know how big the symbol table is,\n\t     we default to reading in the entire file (!) and\n\t     processing that.  This is overkill, I know, but it\n\t     should work.  */\n\t  section.sh_offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\t  if ((bfd_size_type) section.sh_offset > current_file_size)\n\t    {\n\t      /* See PR 21379 for a reproducer.  */\n\t      error (_(\"Invalid DT_SYMTAB entry: %lx\"), (long) section.sh_offset);\n\t      return FALSE;\n\t    }\n\n\t  if (archive_file_offset != 0)\n\t    section.sh_size = archive_file_size - section.sh_offset;\n\t  else\n\t    {\n\t      if (fseek (file, 0, SEEK_END))\n\t\terror (_(\"Unable to seek to end of file!\\n\"));\n\n\t      section.sh_size = ftell (file) - section.sh_offset;\n\t    }\n\n\t  if (is_32bit_elf)\n\t    section.sh_entsize = sizeof (Elf32_External_Sym);\n\t  else\n\t    section.sh_entsize = sizeof (Elf64_External_Sym);\n\t  section.sh_name = string_table_length;\n\n\t  dynamic_symbols = GET_ELF_SYMBOLS (file, &section, & num_dynamic_syms);\n\t  if (num_dynamic_syms < 1)\n\t    {\n\t      error (_(\"Unable to determine the number of symbols to load\\n\"));\n\t      continue;\n\t    }\n\t}\n    }\n\n  /* Similarly find a string table.  */\n  if (dynamic_strings == NULL)\n    {\n      for (entry = dynamic_section;\n\t   entry < dynamic_section + dynamic_nent;\n\t   ++entry)\n\t{\n\t  unsigned long offset;\n\t  long str_tab_len;\n\n\t  if (entry->d_tag != DT_STRTAB)\n\t    continue;\n\n\t  dynamic_info[DT_STRTAB] = entry->d_un.d_val;\n\n\t  /* Since we do not know how big the string table is,\n\t     we default to reading in the entire file (!) and\n\t     processing that.  This is overkill, I know, but it\n\t     should work.  */\n\n\t  offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\n\t  if (archive_file_offset != 0)\n\t    str_tab_len = archive_file_size - offset;\n\t  else\n\t    {\n\t      if (fseek (file, 0, SEEK_END))\n\t\terror (_(\"Unable to seek to end of file\\n\"));\n\t      str_tab_len = ftell (file) - offset;\n\t    }\n\n\t  if (str_tab_len < 1)\n\t    {\n\t      error\n\t\t(_(\"Unable to determine the length of the dynamic string table\\n\"));\n\t      continue;\n\t    }\n\n\t  dynamic_strings = (char *) get_data (NULL, file, offset, 1,\n                                               str_tab_len,\n                                               _(\"dynamic string table\"));\n\t  dynamic_strings_length = dynamic_strings == NULL ? 0 : str_tab_len;\n\t  break;\n\t}\n    }\n\n  /* And find the syminfo section if available.  */\n  if (dynamic_syminfo == NULL)\n    {\n      unsigned long syminsz = 0;\n\n      for (entry = dynamic_section;\n\t   entry < dynamic_section + dynamic_nent;\n\t   ++entry)\n\t{\n\t  if (entry->d_tag == DT_SYMINENT)\n\t    {\n\t      /* Note: these braces are necessary to avoid a syntax\n\t\t error from the SunOS4 C compiler.  */\n\t      /* PR binutils/17531: A corrupt file can trigger this test.\n\t\t So do not use an assert, instead generate an error message.  */\n\t      if (sizeof (Elf_External_Syminfo) != entry->d_un.d_val)\n\t\terror (_(\"Bad value (%d) for SYMINENT entry\\n\"),\n\t\t       (int) entry->d_un.d_val);\n\t    }\n\t  else if (entry->d_tag == DT_SYMINSZ)\n\t    syminsz = entry->d_un.d_val;\n\t  else if (entry->d_tag == DT_SYMINFO)\n\t    dynamic_syminfo_offset = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t\t\t\t      syminsz);\n\t}\n\n      if (dynamic_syminfo_offset != 0 && syminsz != 0)\n\t{\n\t  Elf_External_Syminfo * extsyminfo;\n\t  Elf_External_Syminfo * extsym;\n\t  Elf_Internal_Syminfo * syminfo;\n\n\t  /* There is a syminfo section.  Read the data.  */\n\t  extsyminfo = (Elf_External_Syminfo *)\n              get_data (NULL, file, dynamic_syminfo_offset, 1, syminsz,\n                        _(\"symbol information\"));\n\t  if (!extsyminfo)\n\t    return FALSE;\n\n\t  dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);\n\t  if (dynamic_syminfo == NULL)\n\t    {\n\t      error (_(\"Out of memory allocating %lu byte for dynamic symbol info\\n\"),\n\t\t     (unsigned long) syminsz);\n\t      return FALSE;\n\t    }\n\n\t  dynamic_syminfo_nent = syminsz / sizeof (Elf_External_Syminfo);\n\t  for (syminfo = dynamic_syminfo, extsym = extsyminfo;\n\t       syminfo < dynamic_syminfo + dynamic_syminfo_nent;\n\t       ++syminfo, ++extsym)\n\t    {\n\t      syminfo->si_boundto = BYTE_GET (extsym->si_boundto);\n\t      syminfo->si_flags = BYTE_GET (extsym->si_flags);\n\t    }\n\n\t  free (extsyminfo);\n\t}\n    }\n\n  if (do_dynamic && dynamic_addr)\n    printf (_(\"\\nDynamic section at offset 0x%lx contains %lu entries:\\n\"),\n\t    dynamic_addr, (unsigned long) dynamic_nent);\n  if (do_dynamic)\n    printf (_(\"  Tag        Type                         Name/Value\\n\"));\n\n  for (entry = dynamic_section;\n       entry < dynamic_section + dynamic_nent;\n       entry++)\n    {\n      if (do_dynamic)\n\t{\n\t  const char * dtype;\n\n\t  putchar (' ');\n\t  print_vma (entry->d_tag, FULL_HEX);\n\t  dtype = get_dynamic_type (entry->d_tag);\n\t  printf (\" (%s)%*s\", dtype,\n\t\t  ((is_32bit_elf ? 27 : 19) - (int) strlen (dtype)), \" \");\n\t}\n\n      switch (entry->d_tag)\n\t{\n\tcase DT_FLAGS:\n\t  if (do_dynamic)\n\t    print_dynamic_flags (entry->d_un.d_val);\n\t  break;\n\n\tcase DT_AUXILIARY:\n\tcase DT_FILTER:\n\tcase DT_CONFIG:\n\tcase DT_DEPAUDIT:\n\tcase DT_AUDIT:\n\t  if (do_dynamic)\n\t    {\n\t      switch (entry->d_tag)\n\t\t{\n\t\tcase DT_AUXILIARY:\n\t\t  printf (_(\"Auxiliary library\"));\n\t\t  break;\n\n\t\tcase DT_FILTER:\n\t\t  printf (_(\"Filter library\"));\n\t\t  break;\n\n\t\tcase DT_CONFIG:\n\t\t  printf (_(\"Configuration file\"));\n\t\t  break;\n\n\t\tcase DT_DEPAUDIT:\n\t\t  printf (_(\"Dependency audit library\"));\n\t\t  break;\n\n\t\tcase DT_AUDIT:\n\t\t  printf (_(\"Audit library\"));\n\t\t  break;\n\t\t}\n\n\t      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))\n\t\tprintf (\": [%s]\\n\", GET_DYNAMIC_NAME (entry->d_un.d_val));\n\t      else\n\t\t{\n\t\t  printf (\": \");\n\t\t  print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t\t  putchar ('\\n');\n\t\t}\n\t    }\n\t  break;\n\n\tcase DT_FEATURE:\n\t  if (do_dynamic)\n\t    {\n\t      printf (_(\"Flags:\"));\n\n\t      if (entry->d_un.d_val == 0)\n\t\tprintf (_(\" None\\n\"));\n\t      else\n\t\t{\n\t\t  unsigned long int val = entry->d_un.d_val;\n\n\t\t  if (val & DTF_1_PARINIT)\n\t\t    {\n\t\t      printf (\" PARINIT\");\n\t\t      val ^= DTF_1_PARINIT;\n\t\t    }\n\t\t  if (val & DTF_1_CONFEXP)\n\t\t    {\n\t\t      printf (\" CONFEXP\");\n\t\t      val ^= DTF_1_CONFEXP;\n\t\t    }\n\t\t  if (val != 0)\n\t\t    printf (\" %lx\", val);\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\t  break;\n\n\tcase DT_POSFLAG_1:\n\t  if (do_dynamic)\n\t    {\n\t      printf (_(\"Flags:\"));\n\n\t      if (entry->d_un.d_val == 0)\n\t\tprintf (_(\" None\\n\"));\n\t      else\n\t\t{\n\t\t  unsigned long int val = entry->d_un.d_val;\n\n\t\t  if (val & DF_P1_LAZYLOAD)\n\t\t    {\n\t\t      printf (\" LAZYLOAD\");\n\t\t      val ^= DF_P1_LAZYLOAD;\n\t\t    }\n\t\t  if (val & DF_P1_GROUPPERM)\n\t\t    {\n\t\t      printf (\" GROUPPERM\");\n\t\t      val ^= DF_P1_GROUPPERM;\n\t\t    }\n\t\t  if (val != 0)\n\t\t    printf (\" %lx\", val);\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\t  break;\n\n\tcase DT_FLAGS_1:\n\t  if (do_dynamic)\n\t    {\n\t      printf (_(\"Flags:\"));\n\t      if (entry->d_un.d_val == 0)\n\t\tprintf (_(\" None\\n\"));\n\t      else\n\t\t{\n\t\t  unsigned long int val = entry->d_un.d_val;\n\n\t\t  if (val & DF_1_NOW)\n\t\t    {\n\t\t      printf (\" NOW\");\n\t\t      val ^= DF_1_NOW;\n\t\t    }\n\t\t  if (val & DF_1_GLOBAL)\n\t\t    {\n\t\t      printf (\" GLOBAL\");\n\t\t      val ^= DF_1_GLOBAL;\n\t\t    }\n\t\t  if (val & DF_1_GROUP)\n\t\t    {\n\t\t      printf (\" GROUP\");\n\t\t      val ^= DF_1_GROUP;\n\t\t    }\n\t\t  if (val & DF_1_NODELETE)\n\t\t    {\n\t\t      printf (\" NODELETE\");\n\t\t      val ^= DF_1_NODELETE;\n\t\t    }\n\t\t  if (val & DF_1_LOADFLTR)\n\t\t    {\n\t\t      printf (\" LOADFLTR\");\n\t\t      val ^= DF_1_LOADFLTR;\n\t\t    }\n\t\t  if (val & DF_1_INITFIRST)\n\t\t    {\n\t\t      printf (\" INITFIRST\");\n\t\t      val ^= DF_1_INITFIRST;\n\t\t    }\n\t\t  if (val & DF_1_NOOPEN)\n\t\t    {\n\t\t      printf (\" NOOPEN\");\n\t\t      val ^= DF_1_NOOPEN;\n\t\t    }\n\t\t  if (val & DF_1_ORIGIN)\n\t\t    {\n\t\t      printf (\" ORIGIN\");\n\t\t      val ^= DF_1_ORIGIN;\n\t\t    }\n\t\t  if (val & DF_1_DIRECT)\n\t\t    {\n\t\t      printf (\" DIRECT\");\n\t\t      val ^= DF_1_DIRECT;\n\t\t    }\n\t\t  if (val & DF_1_TRANS)\n\t\t    {\n\t\t      printf (\" TRANS\");\n\t\t      val ^= DF_1_TRANS;\n\t\t    }\n\t\t  if (val & DF_1_INTERPOSE)\n\t\t    {\n\t\t      printf (\" INTERPOSE\");\n\t\t      val ^= DF_1_INTERPOSE;\n\t\t    }\n\t\t  if (val & DF_1_NODEFLIB)\n\t\t    {\n\t\t      printf (\" NODEFLIB\");\n\t\t      val ^= DF_1_NODEFLIB;\n\t\t    }\n\t\t  if (val & DF_1_NODUMP)\n\t\t    {\n\t\t      printf (\" NODUMP\");\n\t\t      val ^= DF_1_NODUMP;\n\t\t    }\n\t\t  if (val & DF_1_CONFALT)\n\t\t    {\n\t\t      printf (\" CONFALT\");\n\t\t      val ^= DF_1_CONFALT;\n\t\t    }\n\t\t  if (val & DF_1_ENDFILTEE)\n\t\t    {\n\t\t      printf (\" ENDFILTEE\");\n\t\t      val ^= DF_1_ENDFILTEE;\n\t\t    }\n\t\t  if (val & DF_1_DISPRELDNE)\n\t\t    {\n\t\t      printf (\" DISPRELDNE\");\n\t\t      val ^= DF_1_DISPRELDNE;\n\t\t    }\n\t\t  if (val & DF_1_DISPRELPND)\n\t\t    {\n\t\t      printf (\" DISPRELPND\");\n\t\t      val ^= DF_1_DISPRELPND;\n\t\t    }\n\t\t  if (val & DF_1_NODIRECT)\n\t\t    {\n\t\t      printf (\" NODIRECT\");\n\t\t      val ^= DF_1_NODIRECT;\n\t\t    }\n\t\t  if (val & DF_1_IGNMULDEF)\n\t\t    {\n\t\t      printf (\" IGNMULDEF\");\n\t\t      val ^= DF_1_IGNMULDEF;\n\t\t    }\n\t\t  if (val & DF_1_NOKSYMS)\n\t\t    {\n\t\t      printf (\" NOKSYMS\");\n\t\t      val ^= DF_1_NOKSYMS;\n\t\t    }\n\t\t  if (val & DF_1_NOHDR)\n\t\t    {\n\t\t      printf (\" NOHDR\");\n\t\t      val ^= DF_1_NOHDR;\n\t\t    }\n\t\t  if (val & DF_1_EDITED)\n\t\t    {\n\t\t      printf (\" EDITED\");\n\t\t      val ^= DF_1_EDITED;\n\t\t    }\n\t\t  if (val & DF_1_NORELOC)\n\t\t    {\n\t\t      printf (\" NORELOC\");\n\t\t      val ^= DF_1_NORELOC;\n\t\t    }\n\t\t  if (val & DF_1_SYMINTPOSE)\n\t\t    {\n\t\t      printf (\" SYMINTPOSE\");\n\t\t      val ^= DF_1_SYMINTPOSE;\n\t\t    }\n\t\t  if (val & DF_1_GLOBAUDIT)\n\t\t    {\n\t\t      printf (\" GLOBAUDIT\");\n\t\t      val ^= DF_1_GLOBAUDIT;\n\t\t    }\n\t\t  if (val & DF_1_SINGLETON)\n\t\t    {\n\t\t      printf (\" SINGLETON\");\n\t\t      val ^= DF_1_SINGLETON;\n\t\t    }\n\t\t  if (val & DF_1_STUB)\n\t\t    {\n\t\t      printf (\" STUB\");\n\t\t      val ^= DF_1_STUB;\n\t\t    }\n\t\t  if (val & DF_1_PIE)\n\t\t    {\n\t\t      printf (\" PIE\");\n\t\t      val ^= DF_1_PIE;\n\t\t    }\n\t\t  if (val != 0)\n\t\t    printf (\" %lx\", val);\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\t  break;\n\n\tcase DT_PLTREL:\n\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n\t  if (do_dynamic)\n\t    puts (get_dynamic_type (entry->d_un.d_val));\n\t  break;\n\n\tcase DT_NULL\t:\n\tcase DT_NEEDED\t:\n\tcase DT_PLTGOT\t:\n\tcase DT_HASH\t:\n\tcase DT_STRTAB\t:\n\tcase DT_SYMTAB\t:\n\tcase DT_RELA\t:\n\tcase DT_INIT\t:\n\tcase DT_FINI\t:\n\tcase DT_SONAME\t:\n\tcase DT_RPATH\t:\n\tcase DT_SYMBOLIC:\n\tcase DT_REL\t:\n\tcase DT_DEBUG\t:\n\tcase DT_TEXTREL\t:\n\tcase DT_JMPREL\t:\n\tcase DT_RUNPATH\t:\n\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n\n\t  if (do_dynamic)\n\t    {\n\t      char * name;\n\n\t      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))\n\t\tname = GET_DYNAMIC_NAME (entry->d_un.d_val);\n\t      else\n\t\tname = NULL;\n\n\t      if (name)\n\t\t{\n\t\t  switch (entry->d_tag)\n\t\t    {\n\t\t    case DT_NEEDED:\n\t\t      printf (_(\"Shared library: [%s]\"), name);\n\n\t\t      if (streq (name, program_interpreter))\n\t\t\tprintf (_(\" program interpreter\"));\n\t\t      break;\n\n\t\t    case DT_SONAME:\n\t\t      printf (_(\"Library soname: [%s]\"), name);\n\t\t      break;\n\n\t\t    case DT_RPATH:\n\t\t      printf (_(\"Library rpath: [%s]\"), name);\n\t\t      break;\n\n\t\t    case DT_RUNPATH:\n\t\t      printf (_(\"Library runpath: [%s]\"), name);\n\t\t      break;\n\n\t\t    default:\n\t\t      print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t\t      break;\n\t\t    }\n\t\t}\n\t      else\n\t\tprint_vma (entry->d_un.d_val, PREFIX_HEX);\n\n\t      putchar ('\\n');\n\t    }\n\t  break;\n\n\tcase DT_PLTRELSZ:\n\tcase DT_RELASZ\t:\n\tcase DT_STRSZ\t:\n\tcase DT_RELSZ\t:\n\tcase DT_RELAENT\t:\n\tcase DT_SYMENT\t:\n\tcase DT_RELENT\t:\n\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n\t  /* Fall through.  */\n\tcase DT_PLTPADSZ:\n\tcase DT_MOVEENT\t:\n\tcase DT_MOVESZ\t:\n\tcase DT_INIT_ARRAYSZ:\n\tcase DT_FINI_ARRAYSZ:\n\tcase DT_GNU_CONFLICTSZ:\n\tcase DT_GNU_LIBLISTSZ:\n\t  if (do_dynamic)\n\t    {\n\t      print_vma (entry->d_un.d_val, UNSIGNED);\n\t      printf (_(\" (bytes)\\n\"));\n\t    }\n\t  break;\n\n\tcase DT_VERDEFNUM:\n\tcase DT_VERNEEDNUM:\n\tcase DT_RELACOUNT:\n\tcase DT_RELCOUNT:\n\t  if (do_dynamic)\n\t    {\n\t      print_vma (entry->d_un.d_val, UNSIGNED);\n\t      putchar ('\\n');\n\t    }\n\t  break;\n\n\tcase DT_SYMINSZ:\n\tcase DT_SYMINENT:\n\tcase DT_SYMINFO:\n\tcase DT_USED:\n\tcase DT_INIT_ARRAY:\n\tcase DT_FINI_ARRAY:\n\t  if (do_dynamic)\n\t    {\n\t      if (entry->d_tag == DT_USED\n\t\t  && VALID_DYNAMIC_NAME (entry->d_un.d_val))\n\t\t{\n\t\t  char * name = GET_DYNAMIC_NAME (entry->d_un.d_val);\n\n\t\t  if (*name)\n\t\t    {\n\t\t      printf (_(\"Not needed object: [%s]\\n\"), name);\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t      print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t      putchar ('\\n');\n\t    }\n\t  break;\n\n\tcase DT_BIND_NOW:\n\t  /* The value of this entry is ignored.  */\n\t  if (do_dynamic)\n\t    putchar ('\\n');\n\t  break;\n\n\tcase DT_GNU_PRELINKED:\n\t  if (do_dynamic)\n\t    {\n\t      struct tm * tmp;\n\t      time_t atime = entry->d_un.d_val;\n\n\t      tmp = gmtime (&atime);\n\t      /* PR 17533 file: 041-1244816-0.004.  */\n\t      if (tmp == NULL)\n\t\tprintf (_(\"<corrupt time val: %lx\"),\n\t\t\t(unsigned long) atime);\n\t      else\n\t\tprintf (\"%04u-%02u-%02uT%02u:%02u:%02u\\n\",\n\t\t\ttmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,\n\t\t\ttmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n\t    }\n\t  break;\n\n\tcase DT_GNU_HASH:\n\t  dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n\t  if (do_dynamic)\n\t    {\n\t      print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t      putchar ('\\n');\n\t    }\n\t  break;\n\n\tdefault:\n\t  if ((entry->d_tag >= DT_VERSYM) && (entry->d_tag <= DT_VERNEEDNUM))\n\t    version_info[DT_VERSIONTAGIDX (entry->d_tag)] =\n\t      entry->d_un.d_val;\n\n\t  if (do_dynamic)\n\t    {\n\t      switch (elf_header.e_machine)\n\t\t{\n\t\tcase EM_MIPS:\n\t\tcase EM_MIPS_RS3_LE:\n\t\t  dynamic_section_mips_val (entry);\n\t\t  break;\n\t\tcase EM_PARISC:\n\t\t  dynamic_section_parisc_val (entry);\n\t\t  break;\n\t\tcase EM_IA_64:\n\t\t  dynamic_section_ia64_val (entry);\n\t\t  break;\n\t\tdefault:\n\t\t  print_vma (entry->d_un.d_val, PREFIX_HEX);\n\t\t  putchar ('\\n');\n\t\t}\n\t    }\n\t  break;\n\t}\n    }\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,6 +41,12 @@\n \t     processing that.  This is overkill, I know, but it\n \t     should work.  */\n \t  section.sh_offset = offset_from_vma (file, entry->d_un.d_val, 0);\n+\t  if ((bfd_size_type) section.sh_offset > current_file_size)\n+\t    {\n+\t      /* See PR 21379 for a reproducer.  */\n+\t      error (_(\"Invalid DT_SYMTAB entry: %lx\"), (long) section.sh_offset);\n+\t      return FALSE;\n+\t    }\n \n \t  if (archive_file_offset != 0)\n \t    section.sh_size = archive_file_size - section.sh_offset;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t  if ((bfd_size_type) section.sh_offset > current_file_size)",
                "\t    {",
                "\t      /* See PR 21379 for a reproducer.  */",
                "\t      error (_(\"Invalid DT_SYMTAB entry: %lx\"), (long) section.sh_offset);",
                "\t      return FALSE;",
                "\t    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9040",
        "func_name": "binutils-gdb/print_gnu_build_attribute_name",
        "description": "GNU Binutils 2017-04-03 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash), related to the process_mips_specific function in readelf.c, via a crafted ELF file that triggers a large memory-allocation attempt.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=7296a62a2a237f6b1ad8db8c38b090e9f592c8cf",
        "commit_title": "",
        "commit_text": "readelf: fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.  \tPR binutils/21379 \t* readelf.c (process_dynamic_section): Detect over large section \toffsets in the DT_SYMTAB entry.  \tPR binutils/21345 \t* readelf.c (process_mips_specific): Catch an unfeasible memory \tallocation before it happens and print a suitable error message. ",
        "func_before": "static bfd_boolean\nprint_gnu_build_attribute_name (Elf_Internal_Note * pnote)\n{\n  static const char string_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_STRING, 0 };\n  static const char number_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC, 0 };\n  static const char bool_expected [3] = { GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE, GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE, 0 };\n  char         name_type;\n  char         name_attribute;\n  const char * expected_types;\n  const char * name = pnote->namedata;\n  const char * text;\n  int          left;\n\n  if (name == NULL || pnote->namesz < 2)\n    {\n      error (_(\"corrupt name field in GNU build attribute note: size = %ld\\n\"), pnote->namesz);\n      print_symbol (-20, _(\"  <corrupt name field>\"));\n      return FALSE;\n    }\n\n  switch ((name_type = * name))\n    {\n    case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC:\n    case GNU_BUILD_ATTRIBUTE_TYPE_STRING:\n    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE:\n    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE:\n      printf (\"%c\", * name);\n      break;\n    default:\n      error (_(\"unrecognised attribute type in name field: %d\\n\"), name_type);\n      print_symbol (-20, _(\"<unknown name type>\"));\n      return FALSE;\n    }\n\n  left = 19;\n  ++ name;\n  text = NULL;\n\n  switch ((name_attribute = * name))\n    {\n    case GNU_BUILD_ATTRIBUTE_VERSION:\n      text = _(\"<version>\");\n      expected_types = string_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_STACK_PROT:\n      text = _(\"<stack prot>\");\n      expected_types = \"!+*\";\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_RELRO:\n      text = _(\"<relro>\");\n      expected_types = bool_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_STACK_SIZE:\n      text = _(\"<stack size>\");\n      expected_types = number_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_TOOL:\n      text = _(\"<tool>\");\n      expected_types = string_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_ABI:\n      text = _(\"<ABI>\");\n      expected_types = \"$*\";\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_PIC:\n      text = _(\"<PIC>\");\n      expected_types = number_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_SHORT_ENUM:\n      text = _(\"<short enum>\");\n      expected_types = bool_expected;\n      ++ name;\n      break;\n\n    default:\n      if (ISPRINT (* name))\n\t{\n\t  int len = strnlen (name, pnote->namesz - (name - pnote->namedata)) + 1;\n\n\t  if (len > left && ! do_wide)\n\t    len = left;\n\t  printf (\"%.*s:\", len, name);\n\t  left -= len;\n\t  name += len;\n\t}\n      else\n\t{\n\t  error (_(\"unexpected character in name field\\n\"));\n\t  print_symbol (- left, _(\"<unknown attribute>\"));\n\t  return 0;\n\t}\n      expected_types = \"*$!+\";\n      break;\n    }\n\n  if (text)\n    {\n      printf (\"%s\", text);\n      left -= strlen (text);\n    }\n\n  if (strchr (expected_types, name_type) == NULL)\n    warn (_(\"attribute does not have an expected type (%c)\\n\"), name_type);\n\n  if ((unsigned long)(name - pnote->namedata) > pnote->namesz)\n    {\n      error (_(\"corrupt name field: namesz: %lu but parsing gets to %ld\\n\"),\n\t     (unsigned long) pnote->namesz,\n\t     (long) (name - pnote->namedata));\n      return FALSE;\n    }\n\n  if (left < 1 && ! do_wide)\n    return TRUE;\n\n  switch (name_type)\n    {\n    case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC:\n      {\n\tunsigned int   bytes = pnote->namesz - (name - pnote->namedata);\n\tunsigned long  val = 0;\n\tunsigned int   shift = 0;\n\tchar *         decoded = NULL;\n\n\twhile (bytes --)\n\t  {\n\t    unsigned long byte = (* name ++) & 0xff;\n\n\t    val |= byte << shift;\n\t    shift += 8;\n\t  }\n\n\tswitch (name_attribute)\n\t  {\n\t  case GNU_BUILD_ATTRIBUTE_PIC:\n\t    switch (val)\n\t      {\n\t      case 0: decoded = \"static\"; break;\n\t      case 1: decoded = \"pic\"; break;\n\t      case 2: decoded = \"PIC\"; break;\n\t      case 3: decoded = \"pie\"; break;\n\t      case 4: decoded = \"PIE\"; break;\n\t      default: break;\n\t      }\n\t    break;\n\t  case GNU_BUILD_ATTRIBUTE_STACK_PROT:\n\t    switch (val)\n\t      {\n\t\t/* Based upon the SPCT_FLAG_xxx enum values in gcc/cfgexpand.c.  */\n\t      case 0: decoded = \"off\"; break;\n\t      case 1: decoded = \"on\"; break;\n\t      case 2: decoded = \"all\"; break;\n\t      case 3: decoded = \"strong\"; break;\n\t      case 4: decoded = \"explicit\"; break;\n\t      default: break;\n\t      }\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\n\tif (decoded != NULL)\n\t  print_symbol (-left, decoded);\n\telse\n\t  {\n\t    if (do_wide)\n\t      left -= printf (\"0x%lx\", val);\n\t    else\n\t      left -= printf (\"0x%-.*lx\", left, val);\n\t  }\n      }\n      break;\n    case GNU_BUILD_ATTRIBUTE_TYPE_STRING:\n      left -= print_symbol (- left, name);\n      break;\n    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE:\n      left -= print_symbol (- left, \"true\");\n      break;\n    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE:\n      left -= print_symbol (- left, \"false\");\n      break;\n    }\n\n  if (do_wide && left > 0)\n    printf (\"%-*s\", left, \" \");\n    \n  return TRUE;\n}",
        "func": "static bfd_boolean\nprint_gnu_build_attribute_name (Elf_Internal_Note * pnote)\n{\n  static const char string_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_STRING, 0 };\n  static const char number_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC, 0 };\n  static const char bool_expected [3] = { GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE, GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE, 0 };\n  char         name_type;\n  char         name_attribute;\n  const char * expected_types;\n  const char * name = pnote->namedata;\n  const char * text;\n  int          left;\n\n  if (name == NULL || pnote->namesz < 2)\n    {\n      error (_(\"corrupt name field in GNU build attribute note: size = %ld\\n\"), pnote->namesz);\n      print_symbol (-20, _(\"  <corrupt name>\"));\n      return FALSE;\n    }\n\n  switch ((name_type = * name))\n    {\n    case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC:\n    case GNU_BUILD_ATTRIBUTE_TYPE_STRING:\n    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE:\n    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE:\n      printf (\"%c\", * name);\n      break;\n    default:\n      error (_(\"unrecognised attribute type in name field: %d\\n\"), name_type);\n      print_symbol (-20, _(\"<unknown name type>\"));\n      return FALSE;\n    }\n\n  left = 19;\n  ++ name;\n  text = NULL;\n\n  switch ((name_attribute = * name))\n    {\n    case GNU_BUILD_ATTRIBUTE_VERSION:\n      text = _(\"<version>\");\n      expected_types = string_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_STACK_PROT:\n      text = _(\"<stack prot>\");\n      expected_types = \"!+*\";\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_RELRO:\n      text = _(\"<relro>\");\n      expected_types = bool_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_STACK_SIZE:\n      text = _(\"<stack size>\");\n      expected_types = number_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_TOOL:\n      text = _(\"<tool>\");\n      expected_types = string_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_ABI:\n      text = _(\"<ABI>\");\n      expected_types = \"$*\";\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_PIC:\n      text = _(\"<PIC>\");\n      expected_types = number_expected;\n      ++ name;\n      break;\n    case GNU_BUILD_ATTRIBUTE_SHORT_ENUM:\n      text = _(\"<short enum>\");\n      expected_types = bool_expected;\n      ++ name;\n      break;\n\n    default:\n      if (ISPRINT (* name))\n\t{\n\t  int len = strnlen (name, pnote->namesz - (name - pnote->namedata)) + 1;\n\n\t  if (len > left && ! do_wide)\n\t    len = left;\n\t  printf (\"%.*s:\", len, name);\n\t  left -= len;\n\t  name += len;\n\t}\n      else\n\t{\n\t  error (_(\"unexpected character in name field\\n\"));\n\t  print_symbol (- left, _(\"<unknown attribute>\"));\n\t  return 0;\n\t}\n      expected_types = \"*$!+\";\n      break;\n    }\n\n  if (text)\n    {\n      printf (\"%s\", text);\n      left -= strlen (text);\n    }\n\n  if (strchr (expected_types, name_type) == NULL)\n    warn (_(\"attribute does not have an expected type (%c)\\n\"), name_type);\n\n  if ((unsigned long)(name - pnote->namedata) > pnote->namesz)\n    {\n      error (_(\"corrupt name field: namesz: %lu but parsing gets to %ld\\n\"),\n\t     (unsigned long) pnote->namesz,\n\t     (long) (name - pnote->namedata));\n      return FALSE;\n    }\n\n  if (left < 1 && ! do_wide)\n    return TRUE;\n\n  switch (name_type)\n    {\n    case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC:\n      {\n\tunsigned int   bytes = pnote->namesz - (name - pnote->namedata);\n\tunsigned long  val = 0;\n\tunsigned int   shift = 0;\n\tchar *         decoded = NULL;\n\n\twhile (bytes --)\n\t  {\n\t    unsigned long byte = (* name ++) & 0xff;\n\n\t    val |= byte << shift;\n\t    shift += 8;\n\t  }\n\n\tswitch (name_attribute)\n\t  {\n\t  case GNU_BUILD_ATTRIBUTE_PIC:\n\t    switch (val)\n\t      {\n\t      case 0: decoded = \"static\"; break;\n\t      case 1: decoded = \"pic\"; break;\n\t      case 2: decoded = \"PIC\"; break;\n\t      case 3: decoded = \"pie\"; break;\n\t      case 4: decoded = \"PIE\"; break;\n\t      default: break;\n\t      }\n\t    break;\n\t  case GNU_BUILD_ATTRIBUTE_STACK_PROT:\n\t    switch (val)\n\t      {\n\t\t/* Based upon the SPCT_FLAG_xxx enum values in gcc/cfgexpand.c.  */\n\t      case 0: decoded = \"off\"; break;\n\t      case 1: decoded = \"on\"; break;\n\t      case 2: decoded = \"all\"; break;\n\t      case 3: decoded = \"strong\"; break;\n\t      case 4: decoded = \"explicit\"; break;\n\t      default: break;\n\t      }\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\n\tif (decoded != NULL)\n\t  print_symbol (-left, decoded);\n\telse\n\t  {\n\t    if (do_wide)\n\t      left -= printf (\"0x%lx\", val);\n\t    else\n\t      left -= printf (\"0x%-.*lx\", left, val);\n\t  }\n      }\n      break;\n    case GNU_BUILD_ATTRIBUTE_TYPE_STRING:\n      left -= print_symbol (- left, name);\n      break;\n    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE:\n      left -= print_symbol (- left, \"true\");\n      break;\n    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE:\n      left -= print_symbol (- left, \"false\");\n      break;\n    }\n\n  if (do_wide && left > 0)\n    printf (\"%-*s\", left, \" \");\n    \n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n   if (name == NULL || pnote->namesz < 2)\n     {\n       error (_(\"corrupt name field in GNU build attribute note: size = %ld\\n\"), pnote->namesz);\n-      print_symbol (-20, _(\"  <corrupt name field>\"));\n+      print_symbol (-20, _(\"  <corrupt name>\"));\n       return FALSE;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      print_symbol (-20, _(\"  <corrupt name field>\"));"
            ],
            "added_lines": [
                "      print_symbol (-20, _(\"  <corrupt name>\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9040",
        "func_name": "binutils-gdb/print_symbol_for_build_attribute",
        "description": "GNU Binutils 2017-04-03 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash), related to the process_mips_specific function in readelf.c, via a crafted ELF file that triggers a large memory-allocation attempt.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=7296a62a2a237f6b1ad8db8c38b090e9f592c8cf",
        "commit_title": "",
        "commit_text": "readelf: fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.  \tPR binutils/21379 \t* readelf.c (process_dynamic_section): Detect over large section \toffsets in the DT_SYMTAB entry.  \tPR binutils/21345 \t* readelf.c (process_mips_specific): Catch an unfeasible memory \tallocation before it happens and print a suitable error message. ",
        "func_before": "static bfd_boolean\nprint_symbol_for_build_attribute (FILE *         file,\n\t\t\t\t  unsigned long  offset,\n\t\t\t\t  bfd_boolean    is_open_attr)\n{\n  static FILE *             saved_file = NULL;\n  static char *             strtab;\n  static unsigned long      strtablen;\n  static Elf_Internal_Sym * symtab;\n  static unsigned long      nsyms;\n  Elf_Internal_Sym *  saved_sym = NULL;\n  Elf_Internal_Sym *  sym;\n\n  if (saved_file == NULL || file != saved_file)\n    {\n      Elf_Internal_Shdr * symsec;\n\n      /* Load the symbol and string sections.  */\n      for (symsec = section_headers;\n\t   symsec < section_headers + elf_header.e_shnum;\n\t   symsec ++)\n\t{\n\t  if (symsec->sh_type == SHT_SYMTAB)\n\t    {\n\t      symtab = GET_ELF_SYMBOLS (file, symsec, & nsyms);\n\n\t      if (symsec->sh_link < elf_header.e_shnum)\n\t\t{\n\t\t  Elf_Internal_Shdr * strtab_sec = section_headers + symsec->sh_link;\n\n\t\t  strtab = (char *) get_data (NULL, file, strtab_sec->sh_offset,\n\t\t\t\t\t      1, strtab_sec->sh_size,\n\t\t\t\t\t      _(\"string table\"));\n\t\t  strtablen = strtab != NULL ? strtab_sec->sh_size : 0;\n\t\t}\n\t    }\n\t}\n      saved_file = file;\n    }\n\n  if (symtab == NULL || strtab == NULL)\n    {\n      printf (\"\\n\");\n      return FALSE;\n    }\n\n  /* Find a symbol whose value matches offset.  */\n  for (sym = symtab; sym < symtab + nsyms; sym ++)\n    if (sym->st_value == offset)\n      {\n\tif (sym->st_name >= strtablen)\n\t  /* Huh ?  This should not happen.  */\n\t  continue;\n\n\tif (strtab[sym->st_name] == 0)\n\t  continue;\n\n\tif (is_open_attr)\n\t  {\n\t    /* For OPEN attributes we prefer GLOBAL over LOCAL symbols\n\t       and FILE or OBJECT symbols over NOTYPE symbols.  We skip\n\t       FUNC symbols entirely.  */\n\t    switch (ELF_ST_TYPE (sym->st_info))\n\t      {\n\t      case STT_FILE:\n\t\tsaved_sym = sym;\n\t\t/* We can stop searching now.  */\n\t\tsym = symtab + nsyms;\n\t\tcontinue;\n\n\t      case STT_OBJECT:\n\t\tsaved_sym = sym;\n\t\tcontinue;\n\n\t      case STT_FUNC:\n\t\t/* Ignore function symbols.  */\n\t\tcontinue;\n\n\t      default:\n\t\tbreak;\n\t      }\n\n\t    switch (ELF_ST_BIND (sym->st_info))\n\t      {\n\t      case STB_GLOBAL:\n\t\tif (saved_sym == NULL\n\t\t    || ELF_ST_TYPE (saved_sym->st_info) != STT_OBJECT)\n\t\t  saved_sym = sym;\n\t\tbreak;\n\n\t      case STB_LOCAL:\n\t\tif (saved_sym == NULL)\n\t\t  saved_sym = sym;\n\t\tbreak;\n\n\t      default:\n\t\tbreak;\n\t      }\n\t  }\n\telse\n\t  {\n\t    if (ELF_ST_TYPE (sym->st_info) != STT_FUNC)\n\t      continue;\n\n\t    saved_sym = sym;\n\t    break;\n\t  }\n      }\n\n  printf (\" (%s: %s)\\n\",\n\t  is_open_attr ? _(\"file\") : _(\"func\"),\n\t  saved_sym ? strtab + saved_sym->st_name : _(\"<no symbol found>)\"));\n  return TRUE;\n}",
        "func": "static bfd_boolean\nprint_symbol_for_build_attribute (FILE *         file,\n\t\t\t\t  unsigned long  offset,\n\t\t\t\t  bfd_boolean    is_open_attr)\n{\n  static FILE *             saved_file = NULL;\n  static char *             strtab;\n  static unsigned long      strtablen;\n  static Elf_Internal_Sym * symtab;\n  static unsigned long      nsyms;\n  Elf_Internal_Sym *        saved_sym = NULL;\n  Elf_Internal_Sym *        sym;\n\n  if (section_headers != NULL\n      && (saved_file == NULL || file != saved_file))\n    {\n      Elf_Internal_Shdr * symsec;\n\n      /* Load the symbol and string sections.  */\n      for (symsec = section_headers;\n\t   symsec < section_headers + elf_header.e_shnum;\n\t   symsec ++)\n\t{\n\t  if (symsec->sh_type == SHT_SYMTAB)\n\t    {\n\t      symtab = GET_ELF_SYMBOLS (file, symsec, & nsyms);\n\n\t      if (symsec->sh_link < elf_header.e_shnum)\n\t\t{\n\t\t  Elf_Internal_Shdr * strtab_sec = section_headers + symsec->sh_link;\n\n\t\t  strtab = (char *) get_data (NULL, file, strtab_sec->sh_offset,\n\t\t\t\t\t      1, strtab_sec->sh_size,\n\t\t\t\t\t      _(\"string table\"));\n\t\t  strtablen = strtab != NULL ? strtab_sec->sh_size : 0;\n\t\t}\n\t    }\n\t}\n      saved_file = file;\n    }\n\n  if (symtab == NULL || strtab == NULL)\n    {\n      printf (\"\\n\");\n      return FALSE;\n    }\n\n  /* Find a symbol whose value matches offset.  */\n  for (sym = symtab; sym < symtab + nsyms; sym ++)\n    if (sym->st_value == offset)\n      {\n\tif (sym->st_name >= strtablen)\n\t  /* Huh ?  This should not happen.  */\n\t  continue;\n\n\tif (strtab[sym->st_name] == 0)\n\t  continue;\n\n\tif (is_open_attr)\n\t  {\n\t    /* For OPEN attributes we prefer GLOBAL over LOCAL symbols\n\t       and FILE or OBJECT symbols over NOTYPE symbols.  We skip\n\t       FUNC symbols entirely.  */\n\t    switch (ELF_ST_TYPE (sym->st_info))\n\t      {\n\t      case STT_FILE:\n\t\tsaved_sym = sym;\n\t\t/* We can stop searching now.  */\n\t\tsym = symtab + nsyms;\n\t\tcontinue;\n\n\t      case STT_OBJECT:\n\t\tsaved_sym = sym;\n\t\tcontinue;\n\n\t      case STT_FUNC:\n\t\t/* Ignore function symbols.  */\n\t\tcontinue;\n\n\t      default:\n\t\tbreak;\n\t      }\n\n\t    switch (ELF_ST_BIND (sym->st_info))\n\t      {\n\t      case STB_GLOBAL:\n\t\tif (saved_sym == NULL\n\t\t    || ELF_ST_TYPE (saved_sym->st_info) != STT_OBJECT)\n\t\t  saved_sym = sym;\n\t\tbreak;\n\n\t      case STB_LOCAL:\n\t\tif (saved_sym == NULL)\n\t\t  saved_sym = sym;\n\t\tbreak;\n\n\t      default:\n\t\tbreak;\n\t      }\n\t  }\n\telse\n\t  {\n\t    if (ELF_ST_TYPE (sym->st_info) != STT_FUNC)\n\t      continue;\n\n\t    saved_sym = sym;\n\t    break;\n\t  }\n      }\n\n  printf (\" (%s: %s)\\n\",\n\t  is_open_attr ? _(\"file\") : _(\"func\"),\n\t  saved_sym ? strtab + saved_sym->st_name : _(\"<no symbol found>)\"));\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,10 +8,11 @@\n   static unsigned long      strtablen;\n   static Elf_Internal_Sym * symtab;\n   static unsigned long      nsyms;\n-  Elf_Internal_Sym *  saved_sym = NULL;\n-  Elf_Internal_Sym *  sym;\n+  Elf_Internal_Sym *        saved_sym = NULL;\n+  Elf_Internal_Sym *        sym;\n \n-  if (saved_file == NULL || file != saved_file)\n+  if (section_headers != NULL\n+      && (saved_file == NULL || file != saved_file))\n     {\n       Elf_Internal_Shdr * symsec;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  Elf_Internal_Sym *  saved_sym = NULL;",
                "  Elf_Internal_Sym *  sym;",
                "  if (saved_file == NULL || file != saved_file)"
            ],
            "added_lines": [
                "  Elf_Internal_Sym *        saved_sym = NULL;",
                "  Elf_Internal_Sym *        sym;",
                "  if (section_headers != NULL",
                "      && (saved_file == NULL || file != saved_file))"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9040",
        "func_name": "binutils-gdb/process_arch_specific",
        "description": "GNU Binutils 2017-04-03 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash), related to the process_mips_specific function in readelf.c, via a crafted ELF file that triggers a large memory-allocation attempt.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=7296a62a2a237f6b1ad8db8c38b090e9f592c8cf",
        "commit_title": "",
        "commit_text": "readelf: fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.  \tPR binutils/21379 \t* readelf.c (process_dynamic_section): Detect over large section \toffsets in the DT_SYMTAB entry.  \tPR binutils/21345 \t* readelf.c (process_mips_specific): Catch an unfeasible memory \tallocation before it happens and print a suitable error message. ",
        "func_before": "static bfd_boolean\nprocess_arch_specific (FILE * file)\n{\n  if (! do_arch)\n    return TRUE;\n\n  switch (elf_header.e_machine)\n    {\n    case EM_ARM:\n      return process_attributes (file, \"aeabi\", SHT_ARM_ATTRIBUTES,\n\t\t\t\t display_arm_attribute,\n\t\t\t\t display_generic_attribute);\n\n    case EM_MIPS:\n    case EM_MIPS_RS3_LE:\n      return process_mips_specific (file);\n\n    case EM_MSP430:\n      return process_attributes (file, \"mspabi\", SHT_MSP430_ATTRIBUTES,\n\t\t\t\t display_msp430x_attribute,\n\t\t\t\t display_generic_attribute);\n\n    case EM_NDS32:\n      return process_nds32_specific (file);\n\n    case EM_PPC:\n    case EM_PPC64:\n      return process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t\t display_power_gnu_attribute);\n\n    case EM_S390:\n    case EM_S390_OLD:\n      return process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t\t display_s390_gnu_attribute);\n\n    case EM_SPARC:\n    case EM_SPARC32PLUS:\n    case EM_SPARCV9:\n      return process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t\t display_sparc_gnu_attribute);\n\n    case EM_TI_C6000:\n      return process_attributes (file, \"c6xabi\", SHT_C6000_ATTRIBUTES,\n\t\t\t\t display_tic6x_attribute,\n\t\t\t\t display_generic_attribute);\n\n    default:\n      return process_attributes (file, \"gnu\", SHT_GNU_ATTRIBUTES,\n\t\t\t\t display_public_gnu_attributes,\n\t\t\t\t display_generic_attribute);\n    }\n}",
        "func": "static bfd_boolean\nprocess_arch_specific (FILE * file)\n{\n  if (! do_arch)\n    return TRUE;\n\n  switch (elf_header.e_machine)\n    {\n    case EM_ARM:\n      return process_attributes (file, \"aeabi\", SHT_ARM_ATTRIBUTES,\n\t\t\t\t display_arm_attribute,\n\t\t\t\t display_generic_attribute);\n\n    case EM_MIPS:\n    case EM_MIPS_RS3_LE:\n      return process_mips_specific (file);\n\n    case EM_MSP430:\n     return process_attributes (file, \"mspabi\", SHT_MSP430_ATTRIBUTES,\n\t\t\t\t display_msp430x_attribute,\n\t\t\t\t display_generic_attribute);\n\n    case EM_NDS32:\n      return process_nds32_specific (file);\n\n    case EM_PPC:\n    case EM_PPC64:\n      return process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t\t display_power_gnu_attribute);\n\n    case EM_S390:\n    case EM_S390_OLD:\n      return process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t\t display_s390_gnu_attribute);\n\n    case EM_SPARC:\n    case EM_SPARC32PLUS:\n    case EM_SPARCV9:\n      return process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t\t display_sparc_gnu_attribute);\n\n    case EM_TI_C6000:\n      return process_attributes (file, \"c6xabi\", SHT_C6000_ATTRIBUTES,\n\t\t\t\t display_tic6x_attribute,\n\t\t\t\t display_generic_attribute);\n\n    default:\n      return process_attributes (file, \"gnu\", SHT_GNU_ATTRIBUTES,\n\t\t\t\t display_public_gnu_attributes,\n\t\t\t\t display_generic_attribute);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n       return process_mips_specific (file);\n \n     case EM_MSP430:\n-      return process_attributes (file, \"mspabi\", SHT_MSP430_ATTRIBUTES,\n+     return process_attributes (file, \"mspabi\", SHT_MSP430_ATTRIBUTES,\n \t\t\t\t display_msp430x_attribute,\n \t\t\t\t display_generic_attribute);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      return process_attributes (file, \"mspabi\", SHT_MSP430_ATTRIBUTES,"
            ],
            "added_lines": [
                "     return process_attributes (file, \"mspabi\", SHT_MSP430_ATTRIBUTES,"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7979",
        "func_name": "ArtifexSoftware/ghostpdl/zinitialize_dsc_parser",
        "description": "Ghostscript before 9.21 might allow remote attackers to bypass the SAFER mode protection mechanism and consequently execute arbitrary code by leveraging type confusion in .initialize_dsc_parser.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/875a0095f37626a721c7ff57d606a0f95af03913",
        "commit_title": "DSC parser - validate parameters",
        "commit_text": " Bug #697190 \".initialize_dsc_parser doesn't validate the parameter is a dict type before using it.\"  Regardless of any security implications, its simply wrong for a PostScript operator not to validate its parameter(s).  No differences expected.",
        "func_before": "static int\nzinitialize_dsc_parser(i_ctx_t *i_ctx_p)\n{\n    ref local_ref;\n    int code;\n    os_ptr const op = osp;\n    dict * const pdict = op->value.pdict;\n    gs_memory_t * const mem = (gs_memory_t *)dict_memory(pdict);\n    dsc_data_t * const data =\n        gs_alloc_struct(mem, dsc_data_t, &st_dsc_data_t, \"DSC parser init\");\n\n    if (!data)\n        return_error(gs_error_VMerror);\n    data->document_level = 0;\n\n    data->dsc_data_ptr = dsc_init_with_alloc((void *) \"Ghostscript DSC parsing\",\n                           zDSC_memalloc, zDSC_memfree, (void *)mem->non_gc_memory);\n    if (!data->dsc_data_ptr)\n        return_error(gs_error_VMerror);\n    dsc_set_error_function(data->dsc_data_ptr, dsc_error_handler);\n    make_astruct(&local_ref, a_readonly | r_space(op), (byte *) data);\n    code = idict_put_string(op, dsc_dict_name, &local_ref);\n    if (code >= 0)\n        pop(1);\n    return code;\n}",
        "func": "static int\nzinitialize_dsc_parser(i_ctx_t *i_ctx_p)\n{\n    ref local_ref;\n    int code;\n    os_ptr const op = osp;\n    dict *pdict;\n    gs_memory_t *mem;\n    dsc_data_t *data;\n\n    check_read_type(*op, t_dictionary);\n\n    pdict = op->value.pdict;\n    mem = (gs_memory_t *)dict_memory(pdict);\n\n    data = gs_alloc_struct(mem, dsc_data_t, &st_dsc_data_t, \"DSC parser init\");\n    if (!data)\n        return_error(gs_error_VMerror);\n    data->document_level = 0;\n\n    data->dsc_data_ptr = dsc_init_with_alloc((void *) \"Ghostscript DSC parsing\",\n                           zDSC_memalloc, zDSC_memfree, (void *)mem->non_gc_memory);\n    if (!data->dsc_data_ptr)\n        return_error(gs_error_VMerror);\n    dsc_set_error_function(data->dsc_data_ptr, dsc_error_handler);\n    make_astruct(&local_ref, a_readonly | r_space(op), (byte *) data);\n    code = idict_put_string(op, dsc_dict_name, &local_ref);\n    if (code >= 0)\n        pop(1);\n    return code;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,11 +4,16 @@\n     ref local_ref;\n     int code;\n     os_ptr const op = osp;\n-    dict * const pdict = op->value.pdict;\n-    gs_memory_t * const mem = (gs_memory_t *)dict_memory(pdict);\n-    dsc_data_t * const data =\n-        gs_alloc_struct(mem, dsc_data_t, &st_dsc_data_t, \"DSC parser init\");\n+    dict *pdict;\n+    gs_memory_t *mem;\n+    dsc_data_t *data;\n \n+    check_read_type(*op, t_dictionary);\n+\n+    pdict = op->value.pdict;\n+    mem = (gs_memory_t *)dict_memory(pdict);\n+\n+    data = gs_alloc_struct(mem, dsc_data_t, &st_dsc_data_t, \"DSC parser init\");\n     if (!data)\n         return_error(gs_error_VMerror);\n     data->document_level = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    dict * const pdict = op->value.pdict;",
                "    gs_memory_t * const mem = (gs_memory_t *)dict_memory(pdict);",
                "    dsc_data_t * const data =",
                "        gs_alloc_struct(mem, dsc_data_t, &st_dsc_data_t, \"DSC parser init\");"
            ],
            "added_lines": [
                "    dict *pdict;",
                "    gs_memory_t *mem;",
                "    dsc_data_t *data;",
                "    check_read_type(*op, t_dictionary);",
                "",
                "    pdict = op->value.pdict;",
                "    mem = (gs_memory_t *)dict_memory(pdict);",
                "",
                "    data = gs_alloc_struct(mem, dsc_data_t, &st_dsc_data_t, \"DSC parser init\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-15910",
        "func_name": "ArtifexSoftware/ghostpdl/gdev_pdf_put_params_impl",
        "description": "In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the LockDistillerParams parameter to crash the interpreter or execute code.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/c3476dde7743761a4e1d39a631716199b696b880",
        "commit_title": "Bug 699656: Handle LockDistillerParams not being a boolean",
        "commit_text": " This caused a function call commented as \"Can't fail\" to fail, and resulted in memory correuption and a segfault.",
        "func_before": "static int\ngdev_pdf_put_params_impl(gx_device * dev, const gx_device_pdf * save_dev, gs_param_list * plist)\n{\n    int ecode, code;\n    gx_device_pdf *pdev = (gx_device_pdf *) dev;\n    float cl = (float)pdev->CompatibilityLevel;\n    bool locked = pdev->params.LockDistillerParams, ForOPDFRead;\n    gs_param_name param_name;\n\n    pdev->pdf_memory = gs_memory_stable(pdev->memory);\n    /*\n     * If this is a pseudo-parameter (pdfmark or DSC),\n     * don't bother checking for any real ones.\n     */\n\n    {\n        gs_param_string_array ppa;\n        gs_param_string pps;\n\n        code = param_read_string_array(plist, (param_name = \"pdfmark\"), &ppa);\n        switch (code) {\n            case 0:\n                code = pdfwrite_pdf_open_document(pdev);\n                if (code < 0)\n                    return code;\n                code = pdfmark_process(pdev, &ppa);\n                if (code >= 0)\n                    return code;\n                /* falls through for errors */\n            default:\n                param_signal_error(plist, param_name, code);\n                return code;\n            case 1:\n                break;\n        }\n\n        code = param_read_string_array(plist, (param_name = \"DSC\"), &ppa);\n        switch (code) {\n            case 0:\n                code = pdfwrite_pdf_open_document(pdev);\n                if (code < 0)\n                    return code;\n                code = pdf_dsc_process(pdev, &ppa);\n                if (code >= 0)\n                    return code;\n                /* falls through for errors */\n            default:\n                param_signal_error(plist, param_name, code);\n                return code;\n            case 1:\n                break;\n        }\n\n        code = param_read_string(plist, (param_name = \"pdfpagelabels\"), &pps);\n        switch (code) {\n            case 0:\n                {\n                    if (!pdev->ForOPDFRead) {\n                        cos_dict_t *const pcd = pdev->Catalog;\n                        code = pdfwrite_pdf_open_document(pdev);\n                        if (code < 0)\n                            return code;\n                        code = cos_dict_put_string(pcd, (const byte *)\"/PageLabels\", 11,\n                                   pps.data, pps.size);\n                        if (code >= 0)\n                            return code;\n                    } else\n                        return 0;\n                 }\n                /* falls through for errors */\n            default:\n                param_signal_error(plist, param_name, code);\n                return code;\n            case 1:\n                break;\n        }\n    }\n\n    /*\n     * Check for LockDistillerParams before doing anything else.\n     * If LockDistillerParams is true and is not being set to false,\n     * ignore all resettings of PDF-specific parameters.  Note that\n     * LockDistillerParams is read again, and reset if necessary, in\n     * psdf_put_params.\n     */\n    ecode = param_read_bool(plist, \"LockDistillerParams\", &locked);\n    if (ecode < 0)\n        param_signal_error(plist, param_name, ecode);\n\n    /* General parameters. */\n\n    {\n        int efo = 1;\n\n        ecode = param_put_int(plist, (param_name = \".EmbedFontObjects\"), &efo, ecode);\n        if (ecode < 0)\n            param_signal_error(plist, param_name, ecode);\n        if (efo != 1)\n            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);\n    }\n    {\n        int cdv = CoreDistVersion;\n\n        ecode = param_put_int(plist, (param_name = \"CoreDistVersion\"), &cdv, ecode);\n        if (ecode < 0)\n            return gs_note_error(ecode);\n        if (cdv != CoreDistVersion)\n            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);\n    }\n\n    switch (code = param_read_float(plist, (param_name = \"CompatibilityLevel\"), &cl)) {\n        default:\n            ecode = code;\n            param_signal_error(plist, param_name, ecode);\n            break;\n        case 0:\n            if (!(locked && pdev->params.LockDistillerParams)) {\n                /*\n                 * Must be 1.2, 1.3, 1.4, or 1.5.  Per Adobe documentation, substitute\n                 * the nearest achievable value.\n                 */\n                if (cl < (float)1.15)\n                    cl = (float)1.1;\n                else if (cl < (float)1.25)\n                    cl = (float)1.2;\n                else if (cl < (float)1.35)\n                    cl = (float)1.3;\n                else if (cl < (float)1.45)\n                    cl = (float)1.4;\n                else if (cl < (float)1.55)\n                    cl = (float)1.5;\n                else if (cl < (float)1.65)\n                    cl = (float)1.6;\n                else if (cl < (float)1.75)\n                    cl = (float)1.7;\n                else {\n                    cl = (float)2.0;\n                    if (pdev->params.TransferFunctionInfo == tfi_Preserve)\n                        pdev->params.TransferFunctionInfo = tfi_Apply;\n                }\n            }\n        case 1:\n            break;\n    }\n    {   /* HACK : gs_param_list_s::memory is documented in gsparam.h as\n           \"for allocating coerced arrays\". Not sure why zputdeviceparams\n           sets it to the current memory space, while the device\n           assumes to store them in the device's memory space.\n           As a hackish workaround we temporary replace it here.\n           Doing so because we don't want to change the global code now\n           because we're unable to test it with all devices.\n           Bug 688531 \"Segmentation fault running pdfwrite from 219-01.ps\".\n\n           This solution to be reconsidered after fixing\n           the bug 688533 \"zputdeviceparams specifies a wrong memory space.\".\n        */\n        gs_memory_t *mem = plist->memory;\n\n        plist->memory = pdev->pdf_memory;\n        code = gs_param_read_items(plist, pdev, pdf_param_items);\n        if (code < 0 || (code = param_read_bool(plist, \"ForOPDFRead\", &ForOPDFRead)) < 0)\n        {\n        }\n        if (code == 0 && !pdev->is_ps2write && !(locked && pdev->params.LockDistillerParams))\n            pdev->ForOPDFRead = ForOPDFRead;\n        plist->memory = mem;\n    }\n    if (code < 0)\n        ecode = code;\n    {\n        /*\n         * Setting FirstObjectNumber is only legal if the file\n         * has just been opened and nothing has been written,\n         * or if we are setting it to the same value.\n         */\n        long fon = pdev->FirstObjectNumber;\n\n        if (fon != save_dev->FirstObjectNumber) {\n            if (fon <= 0 || fon > 0x7fff0000 ||\n                (pdev->next_id != 0 &&\n                 pdev->next_id !=\n                 save_dev->FirstObjectNumber + pdf_num_initial_ids)\n                ) {\n                ecode = gs_error_rangecheck;\n                param_signal_error(plist, \"FirstObjectNumber\", ecode);\n            }\n        }\n    }\n    {\n        /*\n         * Set ProcessColorModel now, because gx_default_put_params checks\n         * it.\n         */\n        static const char *const pcm_names[] = {\n            \"DeviceGray\", \"DeviceRGB\", \"DeviceCMYK\", \"DeviceN\", 0\n        };\n        int pcm = -1;\n\n        ecode = param_put_enum(plist, \"ProcessColorModel\", &pcm,\n                               pcm_names, ecode);\n        if (pcm >= 0) {\n            pdf_set_process_color_model(pdev, pcm);\n            rc_decrement(pdev->icc_struct, \"gdev_pdf_put_params_impl, ProcessColorModel changed\");\n            pdev->icc_struct = 0;\n        }\n    }\n    if (ecode < 0)\n        goto fail;\n\n    if (pdev->is_ps2write && (code = param_read_bool(plist, \"ProduceDSC\", &pdev->ProduceDSC)) < 0) {\n        param_signal_error(plist, param_name, code);\n    }\n\n    /* PDFA and PDFX are stored in the page device dictionary and therefore\n     * set on every setpagedevice. However, if we have encountered a file which\n     * can't be made this way, and the PDFACompatibilityPolicy is 1, we want to\n     * continue producing the file, but not as a PDF/A or PDF/X file. Its more\n     * or less impossible to alter the setting in the (potentially saved) page\n     * device dictionary, so we use this rather clunky method.\n     */\n    if (pdev->PDFA < 0 || pdev->PDFA > 3){\n        ecode = gs_note_error(gs_error_rangecheck);\n        param_signal_error(plist, \"PDFA\", ecode);\n        goto fail;\n    }\n    if(pdev->PDFA != 0 && pdev->AbortPDFAX)\n        pdev->PDFA = 0;\n    if(pdev->PDFX && pdev->AbortPDFAX)\n        pdev->PDFX = 0;\n    if (pdev->PDFX && pdev->PDFA != 0) {\n        ecode = gs_note_error(gs_error_rangecheck);\n        param_signal_error(plist, \"PDFA\", ecode);\n        goto fail;\n    }\n    if (pdev->PDFX && pdev->ForOPDFRead) {\n        ecode = gs_note_error(gs_error_rangecheck);\n        param_signal_error(plist, \"PDFX\", ecode);\n        goto fail;\n    }\n    if (pdev->PDFA != 0 && pdev->ForOPDFRead) {\n        ecode = gs_note_error(gs_error_rangecheck);\n        param_signal_error(plist, \"PDFA\", ecode);\n        goto fail;\n    }\n    if (pdev->PDFA == 1 || pdev->PDFX || pdev->CompatibilityLevel < 1.4) {\n         pdev->HaveTransparency = false;\n         pdev->PreserveSMask = false;\n    }\n\n    /*\n     * We have to set version to the new value, because the set of\n     * legal parameter values for psdf_put_params varies according to\n     * the version.\n     */\n    if (pdev->PDFX)\n        cl = (float)1.3; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */\n    if (pdev->PDFA != 0 && cl < 1.4)\n        cl = (float)1.4;\n    pdev->version = (cl < 1.2 ? psdf_version_level2 : psdf_version_ll3);\n    if (pdev->ForOPDFRead) {\n        pdev->ResourcesBeforeUsage = true;\n        pdev->HaveCFF = false;\n        pdev->HavePDFWidths = false;\n        pdev->HaveStrokeColor = false;\n        cl = (float)1.2; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */\n        pdev->MaxInlineImageSize = max_long; /* Save printer's RAM from saving temporary image data.\n                                                Immediate images doen't need buffering. */\n        pdev->version = psdf_version_level2;\n    } else {\n        pdev->ResourcesBeforeUsage = false;\n        pdev->HaveCFF = true;\n        pdev->HavePDFWidths = true;\n        pdev->HaveStrokeColor = true;\n    }\n    pdev->ParamCompatibilityLevel = cl;\n    if (cl < 1.2) {\n        pdev->HaveCFF = false;\n    }\n    ecode = gdev_psdf_put_params(dev, plist);\n    if (ecode < 0)\n        goto fail;\n\n    if (pdev->CompatibilityLevel > 1.7 && pdev->params.TransferFunctionInfo == tfi_Preserve) {\n        pdev->params.TransferFunctionInfo = tfi_Apply;\n        emprintf(pdev->memory, \"\\nIt is not possible to preserve transfer functions in PDF 2.0\\ntransfer functions will be applied instead\\n\");\n    }\n\n    if (pdev->params.ConvertCMYKImagesToRGB) {\n        if (pdev->params.ColorConversionStrategy == ccs_CMYK) {\n            emprintf(pdev->memory, \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\\n\");\n        } else {\n            if (pdev->params.ColorConversionStrategy == ccs_Gray) {\n                emprintf(pdev->memory, \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\\n\");\n            } else {\n                if (pdev->icc_struct)\n                    rc_decrement(pdev->icc_struct,\n                                 \"reset default profile\\n\");\n                pdf_set_process_color_model(pdev,1);\n                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);\n                if (ecode < 0)\n                    goto fail;\n            }\n        }\n    }\n    switch (pdev->params.ColorConversionStrategy) {\n        case ccs_ByObjectType:\n        case ccs_LeaveColorUnchanged:\n            break;\n        case ccs_UseDeviceDependentColor:\n        case ccs_UseDeviceIndependentColor:\n        case ccs_UseDeviceIndependentColorForImages:\n            pdev->params.TransferFunctionInfo = tfi_Apply;\n            break;\n        case ccs_CMYK:\n            pdev->params.TransferFunctionInfo = tfi_Apply;\n            if (pdev->icc_struct)\n                rc_decrement(pdev->icc_struct,\n                             \"reset default profile\\n\");\n            pdf_set_process_color_model(pdev, 2);\n            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);\n            if (ecode < 0)\n                goto fail;\n            break;\n        case ccs_Gray:\n            pdev->params.TransferFunctionInfo = tfi_Apply;\n            if (pdev->icc_struct)\n                rc_decrement(pdev->icc_struct,\n                             \"reset default profile\\n\");\n            pdf_set_process_color_model(pdev,0);\n            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);\n            if (ecode < 0)\n                goto fail;\n            break;\n        case ccs_sRGB:\n        case ccs_RGB:\n            pdev->params.TransferFunctionInfo = tfi_Apply;\n            /* Only bother to do this if we didn't handle it above */\n            if (!pdev->params.ConvertCMYKImagesToRGB) {\n                if (pdev->icc_struct)\n                    rc_decrement(pdev->icc_struct,\n                                 \"reset default profile\\n\");\n                pdf_set_process_color_model(pdev,1);\n                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);\n                if (ecode < 0)\n                    goto fail;\n            }\n            break;\n        default:\n            break;\n    }\n    if (cl < 1.5f && pdev->params.ColorImage.Filter != NULL &&\n            !strcmp(pdev->params.ColorImage.Filter, \"JPXEncode\")) {\n        emprintf(pdev->memory,\n                 \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\");\n        ecode = gs_note_error(gs_error_rangecheck);\n    }\n    if (cl < 1.5f && pdev->params.GrayImage.Filter != NULL &&\n            !strcmp(pdev->params.GrayImage.Filter, \"JPXEncode\")) {\n        emprintf(pdev->memory,\n                 \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\");\n        ecode = gs_note_error(gs_error_rangecheck);\n    }\n    if (cl < 1.4f && pdev->params.MonoImage.Filter != NULL &&\n            !strcmp(pdev->params.MonoImage.Filter, \"JBIG2Encode\")) {\n        emprintf(pdev->memory,\n                 \"JBIG2Encode requires CompatibilityLevel >= 1.4 .\\n\");\n        ecode = gs_note_error(gs_error_rangecheck);\n    }\n    if (pdev->HaveTrueTypes && pdev->version == psdf_version_level2) {\n        pdev->version = psdf_version_level2_with_TT ;\n    }\n    if (ecode < 0)\n        goto fail;\n\n    if (pdev->FirstObjectNumber != save_dev->FirstObjectNumber) {\n        if (pdev->xref.file != 0) {\n            if (gp_fseek_64(pdev->xref.file, 0L, SEEK_SET) != 0) {\n                ecode = gs_error_ioerror;\n                goto fail;\n            }\n            pdf_initialize_ids(pdev);\n        }\n    }\n    /* Handle the float/double mismatch. */\n    pdev->CompatibilityLevel = (int)(cl * 10 + 0.5) / 10.0;\n    if(pdev->OwnerPassword.size != save_dev->OwnerPassword.size ||\n        (pdev->OwnerPassword.size != 0 &&\n         memcmp(pdev->OwnerPassword.data, save_dev->OwnerPassword.data,\n         pdev->OwnerPassword.size) != 0)) {\n        if (pdev->is_open) {\n            if (pdev->PageCount == 0) {\n                gs_closedevice((gx_device *)save_dev);\n                return 0;\n            }\n            else\n                emprintf(pdev->memory, \"Owner Password changed mid-job, ignoring.\\n\");\n        }\n    }\n\n    if (pdev->Linearise && pdev->is_ps2write) {\n        emprintf(pdev->memory, \"Can't linearise PostScript output, ignoring\\n\");\n        pdev->Linearise = false;\n    }\n\n    if (pdev->Linearise && pdev->OwnerPassword.size != 0) {\n        emprintf(pdev->memory, \"Can't linearise encrypted PDF, ignoring\\n\");\n        pdev->Linearise = false;\n    }\n\n    if (pdev->FlattenFonts)\n        pdev->PreserveTrMode = false;\n    return 0;\n fail:\n    /* Restore all the parameters to their original state. */\n    pdev->version = save_dev->version;\n    pdf_set_process_color_model(pdev, save_dev->pcm_color_info_index);\n    pdev->saved_fill_color = save_dev->saved_fill_color;\n    pdev->saved_stroke_color = save_dev->saved_fill_color;\n    {\n        const gs_param_item_t *ppi = pdf_param_items;\n\n        for (; ppi->key; ++ppi)\n            memcpy((char *)pdev + ppi->offset,\n                   (char *)save_dev + ppi->offset,\n                   gs_param_type_sizes[ppi->type]);\n        pdev->ForOPDFRead = save_dev->ForOPDFRead;\n    }\n    return ecode;\n}",
        "func": "static int\ngdev_pdf_put_params_impl(gx_device * dev, const gx_device_pdf * save_dev, gs_param_list * plist)\n{\n    int ecode, code;\n    gx_device_pdf *pdev = (gx_device_pdf *) dev;\n    float cl = (float)pdev->CompatibilityLevel;\n    bool locked = pdev->params.LockDistillerParams, ForOPDFRead;\n    gs_param_name param_name;\n\n    pdev->pdf_memory = gs_memory_stable(pdev->memory);\n    /*\n     * If this is a pseudo-parameter (pdfmark or DSC),\n     * don't bother checking for any real ones.\n     */\n\n    {\n        gs_param_string_array ppa;\n        gs_param_string pps;\n\n        code = param_read_string_array(plist, (param_name = \"pdfmark\"), &ppa);\n        switch (code) {\n            case 0:\n                code = pdfwrite_pdf_open_document(pdev);\n                if (code < 0)\n                    return code;\n                code = pdfmark_process(pdev, &ppa);\n                if (code >= 0)\n                    return code;\n                /* falls through for errors */\n            default:\n                param_signal_error(plist, param_name, code);\n                return code;\n            case 1:\n                break;\n        }\n\n        code = param_read_string_array(plist, (param_name = \"DSC\"), &ppa);\n        switch (code) {\n            case 0:\n                code = pdfwrite_pdf_open_document(pdev);\n                if (code < 0)\n                    return code;\n                code = pdf_dsc_process(pdev, &ppa);\n                if (code >= 0)\n                    return code;\n                /* falls through for errors */\n            default:\n                param_signal_error(plist, param_name, code);\n                return code;\n            case 1:\n                break;\n        }\n\n        code = param_read_string(plist, (param_name = \"pdfpagelabels\"), &pps);\n        switch (code) {\n            case 0:\n                {\n                    if (!pdev->ForOPDFRead) {\n                        cos_dict_t *const pcd = pdev->Catalog;\n                        code = pdfwrite_pdf_open_document(pdev);\n                        if (code < 0)\n                            return code;\n                        code = cos_dict_put_string(pcd, (const byte *)\"/PageLabels\", 11,\n                                   pps.data, pps.size);\n                        if (code >= 0)\n                            return code;\n                    } else\n                        return 0;\n                 }\n                /* falls through for errors */\n            default:\n                param_signal_error(plist, param_name, code);\n                return code;\n            case 1:\n                break;\n        }\n    }\n\n    /*\n     * Check for LockDistillerParams before doing anything else.\n     * If LockDistillerParams is true and is not being set to false,\n     * ignore all resettings of PDF-specific parameters.  Note that\n     * LockDistillerParams is read again, and reset if necessary, in\n     * psdf_put_params.\n     */\n    ecode = param_read_bool(plist, (param_name = \"LockDistillerParams\"), &locked);\n    if (ecode < 0)\n        param_signal_error(plist, param_name, ecode);\n\n    /* General parameters. */\n\n    {\n        int efo = 1;\n\n        ecode = param_put_int(plist, (param_name = \".EmbedFontObjects\"), &efo, ecode);\n        if (ecode < 0)\n            param_signal_error(plist, param_name, ecode);\n        if (efo != 1)\n            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);\n    }\n    {\n        int cdv = CoreDistVersion;\n\n        ecode = param_put_int(plist, (param_name = \"CoreDistVersion\"), &cdv, ecode);\n        if (ecode < 0)\n            return gs_note_error(ecode);\n        if (cdv != CoreDistVersion)\n            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);\n    }\n\n    switch (code = param_read_float(plist, (param_name = \"CompatibilityLevel\"), &cl)) {\n        default:\n            ecode = code;\n            param_signal_error(plist, param_name, ecode);\n            break;\n        case 0:\n            if (!(locked && pdev->params.LockDistillerParams)) {\n                /*\n                 * Must be 1.2, 1.3, 1.4, or 1.5.  Per Adobe documentation, substitute\n                 * the nearest achievable value.\n                 */\n                if (cl < (float)1.15)\n                    cl = (float)1.1;\n                else if (cl < (float)1.25)\n                    cl = (float)1.2;\n                else if (cl < (float)1.35)\n                    cl = (float)1.3;\n                else if (cl < (float)1.45)\n                    cl = (float)1.4;\n                else if (cl < (float)1.55)\n                    cl = (float)1.5;\n                else if (cl < (float)1.65)\n                    cl = (float)1.6;\n                else if (cl < (float)1.75)\n                    cl = (float)1.7;\n                else {\n                    cl = (float)2.0;\n                    if (pdev->params.TransferFunctionInfo == tfi_Preserve)\n                        pdev->params.TransferFunctionInfo = tfi_Apply;\n                }\n            }\n        case 1:\n            break;\n    }\n    {   /* HACK : gs_param_list_s::memory is documented in gsparam.h as\n           \"for allocating coerced arrays\". Not sure why zputdeviceparams\n           sets it to the current memory space, while the device\n           assumes to store them in the device's memory space.\n           As a hackish workaround we temporary replace it here.\n           Doing so because we don't want to change the global code now\n           because we're unable to test it with all devices.\n           Bug 688531 \"Segmentation fault running pdfwrite from 219-01.ps\".\n\n           This solution to be reconsidered after fixing\n           the bug 688533 \"zputdeviceparams specifies a wrong memory space.\".\n        */\n        gs_memory_t *mem = plist->memory;\n\n        plist->memory = pdev->pdf_memory;\n        code = gs_param_read_items(plist, pdev, pdf_param_items);\n        if (code < 0 || (code = param_read_bool(plist, \"ForOPDFRead\", &ForOPDFRead)) < 0)\n        {\n        }\n        if (code == 0 && !pdev->is_ps2write && !(locked && pdev->params.LockDistillerParams))\n            pdev->ForOPDFRead = ForOPDFRead;\n        plist->memory = mem;\n    }\n    if (code < 0)\n        ecode = code;\n    {\n        /*\n         * Setting FirstObjectNumber is only legal if the file\n         * has just been opened and nothing has been written,\n         * or if we are setting it to the same value.\n         */\n        long fon = pdev->FirstObjectNumber;\n\n        if (fon != save_dev->FirstObjectNumber) {\n            if (fon <= 0 || fon > 0x7fff0000 ||\n                (pdev->next_id != 0 &&\n                 pdev->next_id !=\n                 save_dev->FirstObjectNumber + pdf_num_initial_ids)\n                ) {\n                ecode = gs_error_rangecheck;\n                param_signal_error(plist, \"FirstObjectNumber\", ecode);\n            }\n        }\n    }\n    {\n        /*\n         * Set ProcessColorModel now, because gx_default_put_params checks\n         * it.\n         */\n        static const char *const pcm_names[] = {\n            \"DeviceGray\", \"DeviceRGB\", \"DeviceCMYK\", \"DeviceN\", 0\n        };\n        int pcm = -1;\n\n        ecode = param_put_enum(plist, \"ProcessColorModel\", &pcm,\n                               pcm_names, ecode);\n        if (pcm >= 0) {\n            pdf_set_process_color_model(pdev, pcm);\n            rc_decrement(pdev->icc_struct, \"gdev_pdf_put_params_impl, ProcessColorModel changed\");\n            pdev->icc_struct = 0;\n        }\n    }\n    if (ecode < 0)\n        goto fail;\n\n    if (pdev->is_ps2write && (code = param_read_bool(plist, \"ProduceDSC\", &pdev->ProduceDSC)) < 0) {\n        param_signal_error(plist, param_name, code);\n    }\n\n    /* PDFA and PDFX are stored in the page device dictionary and therefore\n     * set on every setpagedevice. However, if we have encountered a file which\n     * can't be made this way, and the PDFACompatibilityPolicy is 1, we want to\n     * continue producing the file, but not as a PDF/A or PDF/X file. Its more\n     * or less impossible to alter the setting in the (potentially saved) page\n     * device dictionary, so we use this rather clunky method.\n     */\n    if (pdev->PDFA < 0 || pdev->PDFA > 3){\n        ecode = gs_note_error(gs_error_rangecheck);\n        param_signal_error(plist, \"PDFA\", ecode);\n        goto fail;\n    }\n    if(pdev->PDFA != 0 && pdev->AbortPDFAX)\n        pdev->PDFA = 0;\n    if(pdev->PDFX && pdev->AbortPDFAX)\n        pdev->PDFX = 0;\n    if (pdev->PDFX && pdev->PDFA != 0) {\n        ecode = gs_note_error(gs_error_rangecheck);\n        param_signal_error(plist, \"PDFA\", ecode);\n        goto fail;\n    }\n    if (pdev->PDFX && pdev->ForOPDFRead) {\n        ecode = gs_note_error(gs_error_rangecheck);\n        param_signal_error(plist, \"PDFX\", ecode);\n        goto fail;\n    }\n    if (pdev->PDFA != 0 && pdev->ForOPDFRead) {\n        ecode = gs_note_error(gs_error_rangecheck);\n        param_signal_error(plist, \"PDFA\", ecode);\n        goto fail;\n    }\n    if (pdev->PDFA == 1 || pdev->PDFX || pdev->CompatibilityLevel < 1.4) {\n         pdev->HaveTransparency = false;\n         pdev->PreserveSMask = false;\n    }\n\n    /*\n     * We have to set version to the new value, because the set of\n     * legal parameter values for psdf_put_params varies according to\n     * the version.\n     */\n    if (pdev->PDFX)\n        cl = (float)1.3; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */\n    if (pdev->PDFA != 0 && cl < 1.4)\n        cl = (float)1.4;\n    pdev->version = (cl < 1.2 ? psdf_version_level2 : psdf_version_ll3);\n    if (pdev->ForOPDFRead) {\n        pdev->ResourcesBeforeUsage = true;\n        pdev->HaveCFF = false;\n        pdev->HavePDFWidths = false;\n        pdev->HaveStrokeColor = false;\n        cl = (float)1.2; /* Instead pdev->CompatibilityLevel = 1.2; - see below. */\n        pdev->MaxInlineImageSize = max_long; /* Save printer's RAM from saving temporary image data.\n                                                Immediate images doen't need buffering. */\n        pdev->version = psdf_version_level2;\n    } else {\n        pdev->ResourcesBeforeUsage = false;\n        pdev->HaveCFF = true;\n        pdev->HavePDFWidths = true;\n        pdev->HaveStrokeColor = true;\n    }\n    pdev->ParamCompatibilityLevel = cl;\n    if (cl < 1.2) {\n        pdev->HaveCFF = false;\n    }\n    ecode = gdev_psdf_put_params(dev, plist);\n    if (ecode < 0)\n        goto fail;\n\n    if (pdev->CompatibilityLevel > 1.7 && pdev->params.TransferFunctionInfo == tfi_Preserve) {\n        pdev->params.TransferFunctionInfo = tfi_Apply;\n        emprintf(pdev->memory, \"\\nIt is not possible to preserve transfer functions in PDF 2.0\\ntransfer functions will be applied instead\\n\");\n    }\n\n    if (pdev->params.ConvertCMYKImagesToRGB) {\n        if (pdev->params.ColorConversionStrategy == ccs_CMYK) {\n            emprintf(pdev->memory, \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\\n\");\n        } else {\n            if (pdev->params.ColorConversionStrategy == ccs_Gray) {\n                emprintf(pdev->memory, \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\\n\");\n            } else {\n                if (pdev->icc_struct)\n                    rc_decrement(pdev->icc_struct,\n                                 \"reset default profile\\n\");\n                pdf_set_process_color_model(pdev,1);\n                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);\n                if (ecode < 0)\n                    goto fail;\n            }\n        }\n    }\n    switch (pdev->params.ColorConversionStrategy) {\n        case ccs_ByObjectType:\n        case ccs_LeaveColorUnchanged:\n            break;\n        case ccs_UseDeviceDependentColor:\n        case ccs_UseDeviceIndependentColor:\n        case ccs_UseDeviceIndependentColorForImages:\n            pdev->params.TransferFunctionInfo = tfi_Apply;\n            break;\n        case ccs_CMYK:\n            pdev->params.TransferFunctionInfo = tfi_Apply;\n            if (pdev->icc_struct)\n                rc_decrement(pdev->icc_struct,\n                             \"reset default profile\\n\");\n            pdf_set_process_color_model(pdev, 2);\n            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);\n            if (ecode < 0)\n                goto fail;\n            break;\n        case ccs_Gray:\n            pdev->params.TransferFunctionInfo = tfi_Apply;\n            if (pdev->icc_struct)\n                rc_decrement(pdev->icc_struct,\n                             \"reset default profile\\n\");\n            pdf_set_process_color_model(pdev,0);\n            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);\n            if (ecode < 0)\n                goto fail;\n            break;\n        case ccs_sRGB:\n        case ccs_RGB:\n            pdev->params.TransferFunctionInfo = tfi_Apply;\n            /* Only bother to do this if we didn't handle it above */\n            if (!pdev->params.ConvertCMYKImagesToRGB) {\n                if (pdev->icc_struct)\n                    rc_decrement(pdev->icc_struct,\n                                 \"reset default profile\\n\");\n                pdf_set_process_color_model(pdev,1);\n                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);\n                if (ecode < 0)\n                    goto fail;\n            }\n            break;\n        default:\n            break;\n    }\n    if (cl < 1.5f && pdev->params.ColorImage.Filter != NULL &&\n            !strcmp(pdev->params.ColorImage.Filter, \"JPXEncode\")) {\n        emprintf(pdev->memory,\n                 \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\");\n        ecode = gs_note_error(gs_error_rangecheck);\n    }\n    if (cl < 1.5f && pdev->params.GrayImage.Filter != NULL &&\n            !strcmp(pdev->params.GrayImage.Filter, \"JPXEncode\")) {\n        emprintf(pdev->memory,\n                 \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\");\n        ecode = gs_note_error(gs_error_rangecheck);\n    }\n    if (cl < 1.4f && pdev->params.MonoImage.Filter != NULL &&\n            !strcmp(pdev->params.MonoImage.Filter, \"JBIG2Encode\")) {\n        emprintf(pdev->memory,\n                 \"JBIG2Encode requires CompatibilityLevel >= 1.4 .\\n\");\n        ecode = gs_note_error(gs_error_rangecheck);\n    }\n    if (pdev->HaveTrueTypes && pdev->version == psdf_version_level2) {\n        pdev->version = psdf_version_level2_with_TT ;\n    }\n    if (ecode < 0)\n        goto fail;\n\n    if (pdev->FirstObjectNumber != save_dev->FirstObjectNumber) {\n        if (pdev->xref.file != 0) {\n            if (gp_fseek_64(pdev->xref.file, 0L, SEEK_SET) != 0) {\n                ecode = gs_error_ioerror;\n                goto fail;\n            }\n            pdf_initialize_ids(pdev);\n        }\n    }\n    /* Handle the float/double mismatch. */\n    pdev->CompatibilityLevel = (int)(cl * 10 + 0.5) / 10.0;\n    if(pdev->OwnerPassword.size != save_dev->OwnerPassword.size ||\n        (pdev->OwnerPassword.size != 0 &&\n         memcmp(pdev->OwnerPassword.data, save_dev->OwnerPassword.data,\n         pdev->OwnerPassword.size) != 0)) {\n        if (pdev->is_open) {\n            if (pdev->PageCount == 0) {\n                gs_closedevice((gx_device *)save_dev);\n                return 0;\n            }\n            else\n                emprintf(pdev->memory, \"Owner Password changed mid-job, ignoring.\\n\");\n        }\n    }\n\n    if (pdev->Linearise && pdev->is_ps2write) {\n        emprintf(pdev->memory, \"Can't linearise PostScript output, ignoring\\n\");\n        pdev->Linearise = false;\n    }\n\n    if (pdev->Linearise && pdev->OwnerPassword.size != 0) {\n        emprintf(pdev->memory, \"Can't linearise encrypted PDF, ignoring\\n\");\n        pdev->Linearise = false;\n    }\n\n    if (pdev->FlattenFonts)\n        pdev->PreserveTrMode = false;\n    return 0;\n fail:\n    /* Restore all the parameters to their original state. */\n    pdev->version = save_dev->version;\n    pdf_set_process_color_model(pdev, save_dev->pcm_color_info_index);\n    pdev->saved_fill_color = save_dev->saved_fill_color;\n    pdev->saved_stroke_color = save_dev->saved_fill_color;\n    {\n        const gs_param_item_t *ppi = pdf_param_items;\n\n        for (; ppi->key; ++ppi)\n            memcpy((char *)pdev + ppi->offset,\n                   (char *)save_dev + ppi->offset,\n                   gs_param_type_sizes[ppi->type]);\n        pdev->ForOPDFRead = save_dev->ForOPDFRead;\n    }\n    return ecode;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -83,7 +83,7 @@\n      * LockDistillerParams is read again, and reset if necessary, in\n      * psdf_put_params.\n      */\n-    ecode = param_read_bool(plist, \"LockDistillerParams\", &locked);\n+    ecode = param_read_bool(plist, (param_name = \"LockDistillerParams\"), &locked);\n     if (ecode < 0)\n         param_signal_error(plist, param_name, ecode);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    ecode = param_read_bool(plist, \"LockDistillerParams\", &locked);"
            ],
            "added_lines": [
                "    ecode = param_read_bool(plist, (param_name = \"LockDistillerParams\"), &locked);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-15910",
        "func_name": "ArtifexSoftware/ghostpdl/ref_param_read_signal_error",
        "description": "In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the LockDistillerParams parameter to crash the interpreter or execute code.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/c3476dde7743761a4e1d39a631716199b696b880",
        "commit_title": "Bug 699656: Handle LockDistillerParams not being a boolean",
        "commit_text": " This caused a function call commented as \"Can't fail\" to fail, and resulted in memory correuption and a segfault.",
        "func_before": "static int\nref_param_read_signal_error(gs_param_list * plist, gs_param_name pkey, int code)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc;\n\n    ref_param_read(iplist, pkey, &loc, -1);\t/* can't fail */\n    *loc.presult = code;\n    switch (ref_param_read_get_policy(plist, pkey)) {\n        case gs_param_policy_ignore:\n            return 0;\n        case gs_param_policy_consult_user:\n            return_error(gs_error_configurationerror);\n        default:\n            return code;\n    }\n}",
        "func": "static int\nref_param_read_signal_error(gs_param_list * plist, gs_param_name pkey, int code)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc = {0};\n\n    ref_param_read(iplist, pkey, &loc, -1);\n    if (loc.presult)\n        *loc.presult = code;\n    switch (ref_param_read_get_policy(plist, pkey)) {\n        case gs_param_policy_ignore:\n            return 0;\n        case gs_param_policy_consult_user:\n            return_error(gs_error_configurationerror);\n        default:\n            return code;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,10 +2,11 @@\n ref_param_read_signal_error(gs_param_list * plist, gs_param_name pkey, int code)\n {\n     iparam_list *const iplist = (iparam_list *) plist;\n-    iparam_loc loc;\n+    iparam_loc loc = {0};\n \n-    ref_param_read(iplist, pkey, &loc, -1);\t/* can't fail */\n-    *loc.presult = code;\n+    ref_param_read(iplist, pkey, &loc, -1);\n+    if (loc.presult)\n+        *loc.presult = code;\n     switch (ref_param_read_get_policy(plist, pkey)) {\n         case gs_param_policy_ignore:\n             return 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    iparam_loc loc;",
                "    ref_param_read(iplist, pkey, &loc, -1);\t/* can't fail */",
                "    *loc.presult = code;"
            ],
            "added_lines": [
                "    iparam_loc loc = {0};",
                "    ref_param_read(iplist, pkey, &loc, -1);",
                "    if (loc.presult)",
                "        *loc.presult = code;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16511",
        "func_name": "ArtifexSoftware/ghostpdl/ztype",
        "description": "An issue was discovered in Artifex Ghostscript before 9.24. A type confusion in \"ztype\" could be used by remote attackers able to supply crafted PostScript to crash the interpreter or possibly have unspecified other impact.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/0edd3d6c634a577db261615a9dc2719bca7f6e01",
        "commit_title": "Bug 699659: Don't just assume an object is a t_(a)struct",
        "commit_text": "",
        "func_before": "static int\nztype(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    ref tnref;\n    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);\n\n    if (code < 0)\n        return code;\n    if (!r_has_type(&tnref, t_name)) {\n        /* Must be either a stack underflow or a t_[a]struct. */\n        check_op(2);\n        {                       /* Get the type name from the structure. */\n            if (op[-1].value.pstruct != 0x00) {\n            const char *sname =\n                gs_struct_type_name_string(gs_object_type(imemory,\n                                                          op[-1].value.pstruct));\n            int code = name_ref(imemory, (const byte *)sname, strlen(sname),\n                                (ref *) (op - 1), 0);\n\n            if (code < 0)\n                return code;\n            } else\n                return_error(gs_error_stackunderflow);\n        }\n        r_set_attrs(op - 1, a_executable);\n    } else {\n        ref_assign(op - 1, &tnref);\n    }\n    pop(1);\n    return 0;\n}",
        "func": "static int\nztype(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    ref tnref;\n    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);\n\n    if (code < 0)\n        return code;\n    if (!r_has_type(&tnref, t_name)) {\n        /* Must be either a stack underflow or a t_[a]struct. */\n        check_op(2);\n        {                       /* Get the type name from the structure. */\n            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {\n            const char *sname =\n                gs_struct_type_name_string(gs_object_type(imemory,\n                                                          op[-1].value.pstruct));\n            int code = name_ref(imemory, (const byte *)sname, strlen(sname),\n                                (ref *) (op - 1), 0);\n\n            if (code < 0)\n                return code;\n            } else\n                return_error(gs_error_stackunderflow);\n        }\n        r_set_attrs(op - 1, a_executable);\n    } else {\n        ref_assign(op - 1, &tnref);\n    }\n    pop(1);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n         /* Must be either a stack underflow or a t_[a]struct. */\n         check_op(2);\n         {                       /* Get the type name from the structure. */\n-            if (op[-1].value.pstruct != 0x00) {\n+            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {\n             const char *sname =\n                 gs_struct_type_name_string(gs_object_type(imemory,\n                                                           op[-1].value.pstruct));",
        "diff_line_info": {
            "deleted_lines": [
                "            if (op[-1].value.pstruct != 0x00) {"
            ],
            "added_lines": [
                "            if ((r_has_type(&op[-1], t_struct) || r_has_type(&op[-1], t_astruct)) && op[-1].value.pstruct != 0x00) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16513",
        "func_name": "ArtifexSoftware/ghostpdl/zsetcolor",
        "description": "In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the setcolor function to crash the interpreter or possibly have unspecified other impact.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/b326a71659b7837d3acde954b18bda1a6f5e9498",
        "commit_title": "Bug 699655: Properly check the return value....",
        "commit_text": " ...when getting a value from a dictionary",
        "func_before": "static int\nzsetcolor(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    es_ptr ep;\n    const gs_color_space *  pcs = gs_currentcolorspace(igs);\n    gs_client_color         cc;\n    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;\n    PS_colour_space_t *space;\n\n    /* initialize the client color pattern pointer for GC */\n    cc.pattern = 0;\n\n    /* check for a pattern color space */\n    if ((n_comps = cs_num_components(pcs)) < 0) {\n        n_comps = -n_comps;\n        if (r_has_type(op, t_dictionary)) {\n            ref     *pImpl, pPatInst;\n\n            code = dict_find_string(op, \"Implementation\", &pImpl);\n            if (code != 0) {\n                code = array_get(imemory, pImpl, 0, &pPatInst);\n                if (code < 0)\n                    return code;\n                cc.pattern = r_ptr(&pPatInst, gs_pattern_instance_t);\n                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)\n                      ? n_comps - 1\n                      : 0 );\n            } else\n                n_numeric_comps = 0;\n        } else\n            n_numeric_comps = 0;\n        num_offset = 1;\n    } else\n        n_numeric_comps = n_comps;\n\n    /* gather the numeric operands */\n    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);\n    if (code < 0)\n        return code;\n    /* The values are copied to graphic state and compared with */\n    /* other colors by memcmp() in gx_hld_saved_color_equal()   */\n    /* This is the easiest way to avoid indeterminism */\n    memset(cc.paint.values + n_numeric_comps, 0,\n            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);\n\n    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);\n    if (code < 0)\n        return code;\n    if (space->validatecomponents) {\n        code = space->validatecomponents(i_ctx_p,\n                                         &istate->colorspace[0].array,\n                                         cc.paint.values, n_numeric_comps);\n        if (code < 0)\n            return code;\n    }\n\n    /* pass the color to the graphic library */\n    if ((code = gs_setcolor(igs, &cc)) >= 0) {\n\n        if (n_comps > n_numeric_comps) {\n            istate->pattern[0] = *op;      /* save pattern dict or null */\n        }\n    }\n\n    /* Check the color spaces, to see if we need to run any tint transform\n     * procedures. Some Adobe applications *eg Photoshop) expect that the\n     * tint transform will be run and use this to set up duotone DeviceN\n     * spaces.\n     */\n    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);\n    if (code < 0)\n        return code;\n    /* Set up for the continuation procedure which will do the work */\n    /* Make sure the exec stack has enough space */\n    check_estack(5);\n    /* A place holder for data potentially used by transform functions */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store the 'depth' of the space returned during checking above */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store the 'stage' of processing (initially 0) */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store a pointer to the color space stored on the operand stack\n     * as the stack may grow unpredictably making further access\n     * to the space difficult\n     */\n    ep = esp += 1;\n    *ep = istate->colorspace[0].array;\n    /* Finally, the actual continuation routine */\n    push_op_estack(setcolor_cont);\n    return o_push_estack;\n}",
        "func": "static int\nzsetcolor(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    es_ptr ep;\n    const gs_color_space *  pcs = gs_currentcolorspace(igs);\n    gs_client_color         cc;\n    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;\n    PS_colour_space_t *space;\n\n    /* initialize the client color pattern pointer for GC */\n    cc.pattern = 0;\n\n    /* check for a pattern color space */\n    if ((n_comps = cs_num_components(pcs)) < 0) {\n        n_comps = -n_comps;\n        if (r_has_type(op, t_dictionary)) {\n            ref     *pImpl, pPatInst;\n\n            if ((code = dict_find_string(op, \"Implementation\", &pImpl)) < 0)\n                return code;\n            if (code > 0) {\n                code = array_get(imemory, pImpl, 0, &pPatInst);\n                if (code < 0)\n                    return code;\n                cc.pattern = r_ptr(&pPatInst, gs_pattern_instance_t);\n                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)\n                      ? n_comps - 1\n                      : 0 );\n            } else\n                n_numeric_comps = 0;\n        } else\n            n_numeric_comps = 0;\n        num_offset = 1;\n    } else\n        n_numeric_comps = n_comps;\n\n    /* gather the numeric operands */\n    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);\n    if (code < 0)\n        return code;\n    /* The values are copied to graphic state and compared with */\n    /* other colors by memcmp() in gx_hld_saved_color_equal()   */\n    /* This is the easiest way to avoid indeterminism */\n    memset(cc.paint.values + n_numeric_comps, 0,\n            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);\n\n    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);\n    if (code < 0)\n        return code;\n    if (space->validatecomponents) {\n        code = space->validatecomponents(i_ctx_p,\n                                         &istate->colorspace[0].array,\n                                         cc.paint.values, n_numeric_comps);\n        if (code < 0)\n            return code;\n    }\n\n    /* pass the color to the graphic library */\n    if ((code = gs_setcolor(igs, &cc)) >= 0) {\n\n        if (n_comps > n_numeric_comps) {\n            istate->pattern[0] = *op;      /* save pattern dict or null */\n        }\n    }\n\n    /* Check the color spaces, to see if we need to run any tint transform\n     * procedures. Some Adobe applications *eg Photoshop) expect that the\n     * tint transform will be run and use this to set up duotone DeviceN\n     * spaces.\n     */\n    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);\n    if (code < 0)\n        return code;\n    /* Set up for the continuation procedure which will do the work */\n    /* Make sure the exec stack has enough space */\n    check_estack(5);\n    /* A place holder for data potentially used by transform functions */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store the 'depth' of the space returned during checking above */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store the 'stage' of processing (initially 0) */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store a pointer to the color space stored on the operand stack\n     * as the stack may grow unpredictably making further access\n     * to the space difficult\n     */\n    ep = esp += 1;\n    *ep = istate->colorspace[0].array;\n    /* Finally, the actual continuation routine */\n    push_op_estack(setcolor_cont);\n    return o_push_estack;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,9 @@\n         if (r_has_type(op, t_dictionary)) {\n             ref     *pImpl, pPatInst;\n \n-            code = dict_find_string(op, \"Implementation\", &pImpl);\n-            if (code != 0) {\n+            if ((code = dict_find_string(op, \"Implementation\", &pImpl)) < 0)\n+                return code;\n+            if (code > 0) {\n                 code = array_get(imemory, pImpl, 0, &pPatInst);\n                 if (code < 0)\n                     return code;",
        "diff_line_info": {
            "deleted_lines": [
                "            code = dict_find_string(op, \"Implementation\", &pImpl);",
                "            if (code != 0) {"
            ],
            "added_lines": [
                "            if ((code = dict_find_string(op, \"Implementation\", &pImpl)) < 0)",
                "                return code;",
                "            if (code > 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9490",
        "func_name": "android/IndexOfValueImpl",
        "description": "In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",
        "git_url": "https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb",
        "commit_title": "Backport: Fix Object.entries/values with changing elements",
        "commit_text": " Bug: 111274046 Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \\ /data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest (cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99) ",
        "func_before": "static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,\n                                         Handle<JSObject> object,\n                                         Handle<Object> value,\n                                         uint32_t start_from, uint32_t length) {\n    DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n    Handle<Map> original_map = handle(object->map(), isolate);\n    Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                     isolate);\n\n    for (uint32_t k = start_from; k < length; ++k) {\n      uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                            ALL_PROPERTIES);\n      if (entry == kMaxUInt32) {\n        continue;\n      }\n\n      Handle<Object> element_k =\n          Subclass::GetImpl(isolate, *parameter_map, entry);\n\n      if (element_k->IsAccessorPair()) {\n        LookupIterator it(isolate, object, k, LookupIterator::OWN);\n        DCHECK(it.IsFound());\n        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,\n                                         Object::GetPropertyWithAccessor(&it),\n                                         Nothing<int64_t>());\n\n        if (value->StrictEquals(*element_k)) {\n          return Just<int64_t>(k);\n        }\n\n        if (object->map() != *original_map) {\n          // Some mutation occurred in accessor. Abort \"fast\" path.\n          return IndexOfValueSlowPath(isolate, object, value, k + 1, length);\n        }\n      } else if (value->StrictEquals(*element_k)) {\n        return Just<int64_t>(k);\n      }\n    }\n    return Just<int64_t>(-1);\n  }",
        "func": "static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,\n                                         Handle<JSObject> object,\n                                         Handle<Object> value,\n                                         uint32_t start_from, uint32_t length) {\n    DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n    Handle<Map> original_map(object->map(), isolate);\n    Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                     isolate);\n\n    for (uint32_t k = start_from; k < length; ++k) {\n      DCHECK_EQ(object->map(), *original_map);\n      uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                            ALL_PROPERTIES);\n      if (entry == kMaxUInt32) {\n        continue;\n      }\n\n      Handle<Object> element_k =\n          Subclass::GetImpl(isolate, *parameter_map, entry);\n\n      if (element_k->IsAccessorPair()) {\n        LookupIterator it(isolate, object, k, LookupIterator::OWN);\n        DCHECK(it.IsFound());\n        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,\n                                         Object::GetPropertyWithAccessor(&it),\n                                         Nothing<int64_t>());\n\n        if (value->StrictEquals(*element_k)) {\n          return Just<int64_t>(k);\n        }\n\n        if (object->map() != *original_map) {\n          // Some mutation occurred in accessor. Abort \"fast\" path.\n          return IndexOfValueSlowPath(isolate, object, value, k + 1, length);\n        }\n      } else if (value->StrictEquals(*element_k)) {\n        return Just<int64_t>(k);\n      }\n    }\n    return Just<int64_t>(-1);\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,11 +3,12 @@\n                                          Handle<Object> value,\n                                          uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {",
        "diff_line_info": {
            "deleted_lines": [
                "    Handle<Map> original_map = handle(object->map(), isolate);"
            ],
            "added_lines": [
                "    Handle<Map> original_map(object->map(), isolate);",
                "      DCHECK_EQ(object->map(), *original_map);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9490",
        "func_name": "android/IncludesValueImpl",
        "description": "In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",
        "git_url": "https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb",
        "commit_title": "Backport: Fix Object.entries/values with changing elements",
        "commit_text": " Bug: 111274046 Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \\ /data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest (cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99) ",
        "func_before": "static Maybe<bool> IncludesValueImpl(Isolate* isolate,\n                                       Handle<JSObject> object,\n                                       Handle<Object> value,\n                                       uint32_t start_from, uint32_t length) {\n    DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n    Handle<Map> original_map = handle(object->map(), isolate);\n    Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                     isolate);\n    bool search_for_hole = value->IsUndefined(isolate);\n\n    for (uint32_t k = start_from; k < length; ++k) {\n      uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                            ALL_PROPERTIES);\n      if (entry == kMaxUInt32) {\n        if (search_for_hole) return Just(true);\n        continue;\n      }\n\n      Handle<Object> element_k =\n          Subclass::GetImpl(isolate, *parameter_map, entry);\n\n      if (element_k->IsAccessorPair()) {\n        LookupIterator it(isolate, object, k, LookupIterator::OWN);\n        DCHECK(it.IsFound());\n        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,\n                                         Object::GetPropertyWithAccessor(&it),\n                                         Nothing<bool>());\n\n        if (value->SameValueZero(*element_k)) return Just(true);\n\n        if (object->map() != *original_map) {\n          // Some mutation occurred in accessor. Abort \"fast\" path\n          return IncludesValueSlowPath(isolate, object, value, k + 1, length);\n        }\n      } else if (value->SameValueZero(*element_k)) {\n        return Just(true);\n      }\n    }\n    return Just(false);\n  }",
        "func": "static Maybe<bool> IncludesValueImpl(Isolate* isolate,\n                                       Handle<JSObject> object,\n                                       Handle<Object> value,\n                                       uint32_t start_from, uint32_t length) {\n    DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n    Handle<Map> original_map(object->map(), isolate);\n    Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                     isolate);\n    bool search_for_hole = value->IsUndefined(isolate);\n\n    for (uint32_t k = start_from; k < length; ++k) {\n      DCHECK_EQ(object->map(), *original_map);\n      uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                            ALL_PROPERTIES);\n      if (entry == kMaxUInt32) {\n        if (search_for_hole) return Just(true);\n        continue;\n      }\n\n      Handle<Object> element_k =\n          Subclass::GetImpl(isolate, *parameter_map, entry);\n\n      if (element_k->IsAccessorPair()) {\n        LookupIterator it(isolate, object, k, LookupIterator::OWN);\n        DCHECK(it.IsFound());\n        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,\n                                         Object::GetPropertyWithAccessor(&it),\n                                         Nothing<bool>());\n\n        if (value->SameValueZero(*element_k)) return Just(true);\n\n        if (object->map() != *original_map) {\n          // Some mutation occurred in accessor. Abort \"fast\" path\n          return IncludesValueSlowPath(isolate, object, value, k + 1, length);\n        }\n      } else if (value->SameValueZero(*element_k)) {\n        return Just(true);\n      }\n    }\n    return Just(false);\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,12 +3,13 @@\n                                        Handle<Object> value,\n                                        uint32_t start_from, uint32_t length) {\n     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));\n-    Handle<Map> original_map = handle(object->map(), isolate);\n+    Handle<Map> original_map(object->map(), isolate);\n     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),\n                                      isolate);\n     bool search_for_hole = value->IsUndefined(isolate);\n \n     for (uint32_t k = start_from; k < length; ++k) {\n+      DCHECK_EQ(object->map(), *original_map);\n       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,\n                                             ALL_PROPERTIES);\n       if (entry == kMaxUInt32) {",
        "diff_line_info": {
            "deleted_lines": [
                "    Handle<Map> original_map = handle(object->map(), isolate);"
            ],
            "added_lines": [
                "    Handle<Map> original_map(object->map(), isolate);",
                "      DCHECK_EQ(object->map(), *original_map);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9490",
        "func_name": "android/ElementsAccessorBase",
        "description": "In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046",
        "git_url": "https://android.googlesource.com/platform/external/v8/+/a24543157ae2cdd25da43e20f4e48a07481e6ceb",
        "commit_title": "Backport: Fix Object.entries/values with changing elements",
        "commit_text": " Bug: 111274046 Test: m -j proxy_resolver_v8_unittest && adb sync && adb shell \\ /data/nativetest64/proxy_resolver_v8_unittest/proxy_resolver_v8_unittest (cherry picked from commit d8be9a10287afed07705ac8af027d6a46d4def99) ",
        "func_before": "explicit ElementsAccessorBase(const char* name)\n      : ElementsAccessor(name) { }",
        "func": "explicit ElementsAccessorBase(const char* name)\n      : InternalElementsAccessor(name) {}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,2 +1,2 @@\n explicit ElementsAccessorBase(const char* name)\n-      : ElementsAccessor(name) { }\n+      : InternalElementsAccessor(name) {}",
        "diff_line_info": {
            "deleted_lines": [
                "      : ElementsAccessor(name) { }"
            ],
            "added_lines": [
                "      : InternalElementsAccessor(name) {}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18386",
        "func_name": "torvalds/linux/n_tty_set_termios",
        "description": "drivers/tty/n_tty.c in the Linux kernel before 4.14.11 allows local attackers (who are able to access pseudo terminals) to hang/block further usage of any pseudo terminal devices due to an EXTPROC versus ICANON confusion in TIOCINQ.",
        "git_url": "https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348",
        "commit_title": "n_tty: fix EXTPROC vs ICANON interaction with TIOCINQ (aka FIONREAD)",
        "commit_text": " We added support for EXTPROC back in 2010 in commit 26df6d13406d (\"tty: Add EXTPROC support for LINEMODE\") and the intent was to allow it to override some (all?) ICANON behavior.  Quoting from that original commit message:           There is a new bit in the termios local flag word, EXTPROC.          When this bit is set, several aspects of the terminal driver          are disabled.  Input line editing, character echo, and mapping          of signals are all disabled.  This allows the telnetd to turn          off these functions when in linemode, but still keep track of          what state the user wants the terminal to be in.  but the problem turns out that \"several aspects of the terminal driver are disabled\" is a bit ambiguous, and you can really confuse the n_tty layer by setting EXTPROC and then causing some of the ICANON invariants to no longer be maintained.  This fixes at least one such case (TIOCINQ) becoming unhappy because of the confusion over whether ICANON really means ICANON when EXTPROC is set.  This basically makes TIOCINQ match the case of read: if EXTPROC is set, we ignore ICANON.  Also, make sure to reset the ICANON state ie EXTPROC changes, not just if ICANON changes.  Cc: Jiri Slaby <jslaby@suse.com>",
        "func_before": "static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\n\t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\t\tldata->line_start = ldata->read_tail;\n\t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n\t\t\tldata->canon_head = ldata->read_tail;\n\t\t\tldata->push = 0;\n\t\t} else {\n\t\t\tset_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),\n\t\t\t\tldata->read_flags);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tldata->push = 1;\n\t\t}\n\t\tldata->commit_head = ldata->read_head;\n\t\tldata->erasing = 0;\n\t\tldata->lnext = 0;\n\t}\n\n\tldata->icanon = (L_ICANON(tty) != 0);\n\n\tif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\n\t    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\n\t    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\n\t    I_PARMRK(tty)) {\n\t\tbitmap_zero(ldata->char_map, 256);\n\n\t\tif (I_IGNCR(tty) || I_ICRNL(tty))\n\t\t\tset_bit('\\r', ldata->char_map);\n\t\tif (I_INLCR(tty))\n\t\t\tset_bit('\\n', ldata->char_map);\n\n\t\tif (L_ICANON(tty)) {\n\t\t\tset_bit(ERASE_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(KILL_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(EOF_CHAR(tty), ldata->char_map);\n\t\t\tset_bit('\\n', ldata->char_map);\n\t\t\tset_bit(EOL_CHAR(tty), ldata->char_map);\n\t\t\tif (L_IEXTEN(tty)) {\n\t\t\t\tset_bit(WERASE_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(LNEXT_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(EOL2_CHAR(tty), ldata->char_map);\n\t\t\t\tif (L_ECHO(tty))\n\t\t\t\t\tset_bit(REPRINT_CHAR(tty),\n\t\t\t\t\t\tldata->char_map);\n\t\t\t}\n\t\t}\n\t\tif (I_IXON(tty)) {\n\t\t\tset_bit(START_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(STOP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tset_bit(INTR_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(QUIT_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(SUSP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tclear_bit(__DISABLED_CHAR, ldata->char_map);\n\t\tldata->raw = 0;\n\t\tldata->real_raw = 0;\n\t} else {\n\t\tldata->raw = 1;\n\t\tif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\n\t\t    (I_IGNPAR(tty) || !I_INPCK(tty)) &&\n\t\t    (tty->driver->flags & TTY_DRIVER_REAL_RAW))\n\t\t\tldata->real_raw = 1;\n\t\telse\n\t\t\tldata->real_raw = 0;\n\t}\n\t/*\n\t * Fix tty hang when I_IXON(tty) is cleared, but the tty\n\t * been stopped by STOP_CHAR(tty) before it.\n\t */\n\tif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\t/* The termios change make the tty ready for I/O */\n\twake_up_interruptible(&tty->write_wait);\n\twake_up_interruptible(&tty->read_wait);\n}",
        "func": "static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {\n\t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\t\tldata->line_start = ldata->read_tail;\n\t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n\t\t\tldata->canon_head = ldata->read_tail;\n\t\t\tldata->push = 0;\n\t\t} else {\n\t\t\tset_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),\n\t\t\t\tldata->read_flags);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tldata->push = 1;\n\t\t}\n\t\tldata->commit_head = ldata->read_head;\n\t\tldata->erasing = 0;\n\t\tldata->lnext = 0;\n\t}\n\n\tldata->icanon = (L_ICANON(tty) != 0);\n\n\tif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\n\t    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\n\t    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\n\t    I_PARMRK(tty)) {\n\t\tbitmap_zero(ldata->char_map, 256);\n\n\t\tif (I_IGNCR(tty) || I_ICRNL(tty))\n\t\t\tset_bit('\\r', ldata->char_map);\n\t\tif (I_INLCR(tty))\n\t\t\tset_bit('\\n', ldata->char_map);\n\n\t\tif (L_ICANON(tty)) {\n\t\t\tset_bit(ERASE_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(KILL_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(EOF_CHAR(tty), ldata->char_map);\n\t\t\tset_bit('\\n', ldata->char_map);\n\t\t\tset_bit(EOL_CHAR(tty), ldata->char_map);\n\t\t\tif (L_IEXTEN(tty)) {\n\t\t\t\tset_bit(WERASE_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(LNEXT_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(EOL2_CHAR(tty), ldata->char_map);\n\t\t\t\tif (L_ECHO(tty))\n\t\t\t\t\tset_bit(REPRINT_CHAR(tty),\n\t\t\t\t\t\tldata->char_map);\n\t\t\t}\n\t\t}\n\t\tif (I_IXON(tty)) {\n\t\t\tset_bit(START_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(STOP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tset_bit(INTR_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(QUIT_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(SUSP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tclear_bit(__DISABLED_CHAR, ldata->char_map);\n\t\tldata->raw = 0;\n\t\tldata->real_raw = 0;\n\t} else {\n\t\tldata->raw = 1;\n\t\tif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\n\t\t    (I_IGNPAR(tty) || !I_INPCK(tty)) &&\n\t\t    (tty->driver->flags & TTY_DRIVER_REAL_RAW))\n\t\t\tldata->real_raw = 1;\n\t\telse\n\t\t\tldata->real_raw = 0;\n\t}\n\t/*\n\t * Fix tty hang when I_IXON(tty) is cleared, but the tty\n\t * been stopped by STOP_CHAR(tty) before it.\n\t */\n\tif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\t/* The termios change make the tty ready for I/O */\n\twake_up_interruptible(&tty->write_wait);\n\twake_up_interruptible(&tty->read_wait);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tstruct n_tty_data *ldata = tty->disc_data;\n \n-\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\n+\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {\n \t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n \t\tldata->line_start = ldata->read_tail;\n \t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {"
            ],
            "added_lines": [
                "\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18386",
        "func_name": "torvalds/linux/n_tty_ioctl",
        "description": "drivers/tty/n_tty.c in the Linux kernel before 4.14.11 allows local attackers (who are able to access pseudo terminals) to hang/block further usage of any pseudo terminal devices due to an EXTPROC versus ICANON confusion in TIOCINQ.",
        "git_url": "https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348",
        "commit_title": "n_tty: fix EXTPROC vs ICANON interaction with TIOCINQ (aka FIONREAD)",
        "commit_text": " We added support for EXTPROC back in 2010 in commit 26df6d13406d (\"tty: Add EXTPROC support for LINEMODE\") and the intent was to allow it to override some (all?) ICANON behavior.  Quoting from that original commit message:           There is a new bit in the termios local flag word, EXTPROC.          When this bit is set, several aspects of the terminal driver          are disabled.  Input line editing, character echo, and mapping          of signals are all disabled.  This allows the telnetd to turn          off these functions when in linemode, but still keep track of          what state the user wants the terminal to be in.  but the problem turns out that \"several aspects of the terminal driver are disabled\" is a bit ambiguous, and you can really confuse the n_tty layer by setting EXTPROC and then causing some of the ICANON invariants to no longer be maintained.  This fixes at least one such case (TIOCINQ) becoming unhappy because of the confusion over whether ICANON really means ICANON when EXTPROC is set.  This basically makes TIOCINQ match the case of read: if EXTPROC is set, we ignore ICANON.  Also, make sure to reset the ICANON state ie EXTPROC changes, not just if ICANON changes.  Cc: Jiri Slaby <jslaby@suse.com>",
        "func_before": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}",
        "func": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n \tcase TIOCINQ:\n \t\tdown_write(&tty->termios_rwsem);\n-\t\tif (L_ICANON(tty))\n+\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))\n \t\t\tretval = inq_canon(ldata);\n \t\telse\n \t\t\tretval = read_cnt(ldata);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (L_ICANON(tty))"
            ],
            "added_lines": [
                "\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19476",
        "func_name": "ArtifexSoftware/ghostpdl/seticc",
        "description": "psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/67d760ab775dae4efe803b5944b0439aa3c0b04a",
        "commit_title": "Bug #700169 - unchecked type",
        "commit_text": " Bug #700169 \"Type confusion in setcolorspace\"  In seticc() we extract \"Name\" from a dictionary, if it succeeds we then use it as a string, without checking the type to see if it is in fact a string.  Add a check on the type, and add a couple to check that 'N' is an integer in a few places too.",
        "func_before": "int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)\n{\n    int                     code, k;\n    gs_color_space *        pcs;\n    ref *                   pstrmval;\n    stream *                s = 0L;\n    cmm_profile_t           *picc_profile = NULL;\n    int                     i, expected = 0;\n    ref *                   pnameval;\n    static const char *const icc_std_profile_names[] = {\n            GSICC_STANDARD_PROFILES\n        };\n    static const char *const icc_std_profile_keys[] = {\n            GSICC_STANDARD_PROFILES_KEYS\n        };\n\n    /* verify the DataSource entry */\n    if (dict_find_string(ICCdict, \"DataSource\", &pstrmval) <= 0)\n        return_error(gs_error_undefined);\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    /* build the color space object */\n    code = gs_cspace_build_ICC(&pcs, NULL, gs_gstate_memory(igs));\n    if (code < 0)\n        return gs_rethrow(code, \"building color space object\");\n    /*  For now, dump the profile into a buffer\n        and obtain handle from the buffer when we need it.\n        We may want to change this later.\n        This depends to some degree on what the CMS is capable of doing.\n        I don't want to get bogged down on stream I/O at this point.\n        Note also, if we are going to be putting these into the clist we will\n        want to have this buffer. */\n    /* Check if we have the /Name entry.  This is used to associate with\n       specs that have enumerated types to indicate sRGB sGray etc */\n    if (dict_find_string(ICCdict, \"Name\", &pnameval) > 0){\n        uint size = r_size(pnameval);\n        char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, \"seticc\");\n        memcpy(str, (const char *)pnameval->value.bytes, size);\n        str[size] = 0;\n\n        /* Compare this to the standard profile names */\n        for (k = 0; k < GSICC_NUMBER_STANDARD_PROFILES; k++) {\n            if ( strcmp( str, icc_std_profile_keys[k] ) == 0 ) {\n                picc_profile = gsicc_get_profile_handle_file(icc_std_profile_names[k],\n                    strlen(icc_std_profile_names[k]), gs_gstate_memory(igs));\n                break;\n            }\n        }\n        gs_free_object(gs_gstate_memory(igs), str, \"seticc\");\n    } else {\n        picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n        if (picc_profile == NULL)\n            return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n        /* We have to get the profile handle due to the fact that we need to know\n           if it has a data space that is CIELAB */\n        picc_profile->profile_handle =\n            gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                            picc_profile->buffer_size,\n                                            gs_gstate_memory(igs));\n    }\n    if (picc_profile == NULL || picc_profile->profile_handle == NULL) {\n        /* Free up everything, the profile is not valid. We will end up going\n           ahead and using a default based upon the number of components */\n        rc_decrement(picc_profile,\"seticc\");\n        rc_decrement(pcs,\"seticc\");\n        return -1;\n    }\n    code = gsicc_set_gscs_profile(pcs, picc_profile, gs_gstate_memory(igs));\n    if (code < 0) {\n        rc_decrement(picc_profile,\"seticc\");\n        rc_decrement(pcs,\"seticc\");\n        return code;\n    }\n    picc_profile->num_comps = ncomps;\n\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            break;\n        case gsGRAY:\n            expected = 1;\n            break;\n        case gsCMYK:\n            expected = 4;\n            break;\n        case gsNCHANNEL:\n        case gsNAMED:            /* Silence warnings */\n        case gsUNDEFINED:        /* Silence warnings */\n            break;\n    }\n    if (!expected || ncomps != expected) {\n        rc_decrement(picc_profile,\"seticc\");\n        rc_decrement(pcs,\"seticc\");\n        return_error(gs_error_rangecheck);\n    }\n\n    /* Lets go ahead and get the hash code and check if we match one of the default spaces */\n    /* Later we may want to delay this, but for now lets go ahead and do it */\n    gsicc_init_hash_cs(picc_profile, igs);\n\n    /* Set the range according to the data type that is associated with the\n       ICC input color type.  Occasionally, we will run into CIELAB to CIELAB\n       profiles for spot colors in PDF documents. These spot colors are typically described\n       as separation colors with tint transforms that go from a tint value\n       to a linear mapping between the CIELAB white point and the CIELAB tint\n       color.  This results in a CIELAB value that we need to use to fill.  We\n       need to detect this to make sure we do the proper scaling of the data.  For\n       CIELAB images in PDF, the source is always normal 8 or 16 bit encoded data\n       in the range from 0 to 255 or 0 to 65535.  In that case, there should not\n       be any encoding and decoding to CIELAB.  The PDF content will not include\n       an ICC profile but will set the color space to \\Lab.  In this case, we use\n       our seticc_lab operation to install the LAB to LAB profile, but we detect\n       that we did that through the use of the is_lab flag in the profile descriptor.\n       When then avoid the CIELAB encode and decode */\n    if (picc_profile->data_cs == gsCIELAB) {\n    /* If the input space to this profile is CIELAB, then we need to adjust the limits */\n        /* See ICC spec ICC.1:2004-10 Section 6.3.4.2 and 6.4.  I don't believe we need to\n           worry about CIEXYZ profiles or any of the other odds ones.  Need to check that though\n           at some point. */\n        picc_profile->Range.ranges[0].rmin = 0.0;\n        picc_profile->Range.ranges[0].rmax = 100.0;\n        picc_profile->Range.ranges[1].rmin = -128.0;\n        picc_profile->Range.ranges[1].rmax = 127.0;\n        picc_profile->Range.ranges[2].rmin = -128.0;\n        picc_profile->Range.ranges[2].rmax = 127.0;\n        picc_profile->islab = true;\n    } else {\n        for (i = 0; i < ncomps; i++) {\n            picc_profile->Range.ranges[i].rmin = range_buff[2 * i];\n            picc_profile->Range.ranges[i].rmax = range_buff[2 * i + 1];\n        }\n    }\n    /* Now see if we are in an overide situation.  We have to wait until now\n       in case this is an LAB profile which we will not overide */\n    if (gs_currentoverrideicc(igs) && picc_profile->data_cs != gsCIELAB) {\n        /* Free up the profile structure */\n        switch( picc_profile->data_cs ) {\n            case gsRGB:\n                pcs->cmm_icc_profile_data = igs->icc_manager->default_rgb;\n                break;\n            case gsGRAY:\n                pcs->cmm_icc_profile_data = igs->icc_manager->default_gray;\n                break;\n            case gsCMYK:\n                pcs->cmm_icc_profile_data = igs->icc_manager->default_cmyk;\n                break;\n            default:\n                break;\n        }\n        /* Have one increment from the color space.  Having these tied\n           together is not really correct.  Need to fix that.  ToDo.  MJV */\n        rc_adjust(picc_profile, -2, \"seticc\");\n        rc_increment(pcs->cmm_icc_profile_data);\n    }\n    /* Set the color space.  We are done.  No joint cache here... */\n    code = gs_setcolorspace(igs, pcs);\n    /* The context has taken a reference to the colorspace. We no longer need\n     * ours, so drop it. */\n    rc_decrement_only(pcs, \"seticc\");\n    /* In this case, we already have a ref count of 2 on the icc profile\n       one for when it was created and one for when it was set.  We really\n       only want one here so adjust */\n    rc_decrement(picc_profile,\"seticc\");\n    /* Remove the ICC dict from the stack */\n    pop(1);\n    return code;\n}",
        "func": "int seticc(i_ctx_t * i_ctx_p, int ncomps, ref *ICCdict, float *range_buff)\n{\n    int                     code, k;\n    gs_color_space *        pcs;\n    ref *                   pstrmval;\n    stream *                s = 0L;\n    cmm_profile_t           *picc_profile = NULL;\n    int                     i, expected = 0;\n    ref *                   pnameval;\n    static const char *const icc_std_profile_names[] = {\n            GSICC_STANDARD_PROFILES\n        };\n    static const char *const icc_std_profile_keys[] = {\n            GSICC_STANDARD_PROFILES_KEYS\n        };\n\n    /* verify the DataSource entry */\n    if (dict_find_string(ICCdict, \"DataSource\", &pstrmval) <= 0)\n        return_error(gs_error_undefined);\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    /* build the color space object */\n    code = gs_cspace_build_ICC(&pcs, NULL, gs_gstate_memory(igs));\n    if (code < 0)\n        return gs_rethrow(code, \"building color space object\");\n    /*  For now, dump the profile into a buffer\n        and obtain handle from the buffer when we need it.\n        We may want to change this later.\n        This depends to some degree on what the CMS is capable of doing.\n        I don't want to get bogged down on stream I/O at this point.\n        Note also, if we are going to be putting these into the clist we will\n        want to have this buffer. */\n    /* Check if we have the /Name entry.  This is used to associate with\n       specs that have enumerated types to indicate sRGB sGray etc */\n    if (dict_find_string(ICCdict, \"Name\", &pnameval) > 0 && r_has_type(pnameval, t_string)){\n        uint size = r_size(pnameval);\n        char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, \"seticc\");\n        memcpy(str, (const char *)pnameval->value.bytes, size);\n        str[size] = 0;\n\n        /* Compare this to the standard profile names */\n        for (k = 0; k < GSICC_NUMBER_STANDARD_PROFILES; k++) {\n            if ( strcmp( str, icc_std_profile_keys[k] ) == 0 ) {\n                picc_profile = gsicc_get_profile_handle_file(icc_std_profile_names[k],\n                    strlen(icc_std_profile_names[k]), gs_gstate_memory(igs));\n                break;\n            }\n        }\n        gs_free_object(gs_gstate_memory(igs), str, \"seticc\");\n    } else {\n        picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n        if (picc_profile == NULL)\n            return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n        /* We have to get the profile handle due to the fact that we need to know\n           if it has a data space that is CIELAB */\n        picc_profile->profile_handle =\n            gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                            picc_profile->buffer_size,\n                                            gs_gstate_memory(igs));\n    }\n    if (picc_profile == NULL || picc_profile->profile_handle == NULL) {\n        /* Free up everything, the profile is not valid. We will end up going\n           ahead and using a default based upon the number of components */\n        rc_decrement(picc_profile,\"seticc\");\n        rc_decrement(pcs,\"seticc\");\n        return -1;\n    }\n    code = gsicc_set_gscs_profile(pcs, picc_profile, gs_gstate_memory(igs));\n    if (code < 0) {\n        rc_decrement(picc_profile,\"seticc\");\n        rc_decrement(pcs,\"seticc\");\n        return code;\n    }\n    picc_profile->num_comps = ncomps;\n\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            break;\n        case gsGRAY:\n            expected = 1;\n            break;\n        case gsCMYK:\n            expected = 4;\n            break;\n        case gsNCHANNEL:\n        case gsNAMED:            /* Silence warnings */\n        case gsUNDEFINED:        /* Silence warnings */\n            break;\n    }\n    if (!expected || ncomps != expected) {\n        rc_decrement(picc_profile,\"seticc\");\n        rc_decrement(pcs,\"seticc\");\n        return_error(gs_error_rangecheck);\n    }\n\n    /* Lets go ahead and get the hash code and check if we match one of the default spaces */\n    /* Later we may want to delay this, but for now lets go ahead and do it */\n    gsicc_init_hash_cs(picc_profile, igs);\n\n    /* Set the range according to the data type that is associated with the\n       ICC input color type.  Occasionally, we will run into CIELAB to CIELAB\n       profiles for spot colors in PDF documents. These spot colors are typically described\n       as separation colors with tint transforms that go from a tint value\n       to a linear mapping between the CIELAB white point and the CIELAB tint\n       color.  This results in a CIELAB value that we need to use to fill.  We\n       need to detect this to make sure we do the proper scaling of the data.  For\n       CIELAB images in PDF, the source is always normal 8 or 16 bit encoded data\n       in the range from 0 to 255 or 0 to 65535.  In that case, there should not\n       be any encoding and decoding to CIELAB.  The PDF content will not include\n       an ICC profile but will set the color space to \\Lab.  In this case, we use\n       our seticc_lab operation to install the LAB to LAB profile, but we detect\n       that we did that through the use of the is_lab flag in the profile descriptor.\n       When then avoid the CIELAB encode and decode */\n    if (picc_profile->data_cs == gsCIELAB) {\n    /* If the input space to this profile is CIELAB, then we need to adjust the limits */\n        /* See ICC spec ICC.1:2004-10 Section 6.3.4.2 and 6.4.  I don't believe we need to\n           worry about CIEXYZ profiles or any of the other odds ones.  Need to check that though\n           at some point. */\n        picc_profile->Range.ranges[0].rmin = 0.0;\n        picc_profile->Range.ranges[0].rmax = 100.0;\n        picc_profile->Range.ranges[1].rmin = -128.0;\n        picc_profile->Range.ranges[1].rmax = 127.0;\n        picc_profile->Range.ranges[2].rmin = -128.0;\n        picc_profile->Range.ranges[2].rmax = 127.0;\n        picc_profile->islab = true;\n    } else {\n        for (i = 0; i < ncomps; i++) {\n            picc_profile->Range.ranges[i].rmin = range_buff[2 * i];\n            picc_profile->Range.ranges[i].rmax = range_buff[2 * i + 1];\n        }\n    }\n    /* Now see if we are in an overide situation.  We have to wait until now\n       in case this is an LAB profile which we will not overide */\n    if (gs_currentoverrideicc(igs) && picc_profile->data_cs != gsCIELAB) {\n        /* Free up the profile structure */\n        switch( picc_profile->data_cs ) {\n            case gsRGB:\n                pcs->cmm_icc_profile_data = igs->icc_manager->default_rgb;\n                break;\n            case gsGRAY:\n                pcs->cmm_icc_profile_data = igs->icc_manager->default_gray;\n                break;\n            case gsCMYK:\n                pcs->cmm_icc_profile_data = igs->icc_manager->default_cmyk;\n                break;\n            default:\n                break;\n        }\n        /* Have one increment from the color space.  Having these tied\n           together is not really correct.  Need to fix that.  ToDo.  MJV */\n        rc_adjust(picc_profile, -2, \"seticc\");\n        rc_increment(pcs->cmm_icc_profile_data);\n    }\n    /* Set the color space.  We are done.  No joint cache here... */\n    code = gs_setcolorspace(igs, pcs);\n    /* The context has taken a reference to the colorspace. We no longer need\n     * ours, so drop it. */\n    rc_decrement_only(pcs, \"seticc\");\n    /* In this case, we already have a ref count of 2 on the icc profile\n       one for when it was created and one for when it was set.  We really\n       only want one here so adjust */\n    rc_decrement(picc_profile,\"seticc\");\n    /* Remove the ICC dict from the stack */\n    pop(1);\n    return code;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n         want to have this buffer. */\n     /* Check if we have the /Name entry.  This is used to associate with\n        specs that have enumerated types to indicate sRGB sGray etc */\n-    if (dict_find_string(ICCdict, \"Name\", &pnameval) > 0){\n+    if (dict_find_string(ICCdict, \"Name\", &pnameval) > 0 && r_has_type(pnameval, t_string)){\n         uint size = r_size(pnameval);\n         char *str = (char *)gs_alloc_bytes(gs_gstate_memory(igs), size+1, \"seticc\");\n         memcpy(str, (const char *)pnameval->value.bytes, size);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (dict_find_string(ICCdict, \"Name\", &pnameval) > 0){"
            ],
            "added_lines": [
                "    if (dict_find_string(ICCdict, \"Name\", &pnameval) > 0 && r_has_type(pnameval, t_string)){"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19476",
        "func_name": "ArtifexSoftware/ghostpdl/zset_outputintent",
        "description": "psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/67d760ab775dae4efe803b5944b0439aa3c0b04a",
        "commit_title": "Bug #700169 - unchecked type",
        "commit_text": " Bug #700169 \"Type confusion in setcolorspace\"  In seticc() we extract \"Name\" from a dictionary, if it succeeds we then use it as a string, without checking the type to see if it is in fact a string.  Add a check on the type, and add a couple to check that 'N' is an integer in a few places too.",
        "func_before": "static int\nzset_outputintent(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    int                     code = 0;\n    gx_device *dev = gs_currentdevice(igs);\n    cmm_dev_profile_t       *dev_profile;\n    stream *                s = 0L;\n    ref *                   pnval;\n    ref *                   pstrmval;\n    int                     ncomps, dev_comps;\n    cmm_profile_t           *picc_profile;\n    int                     expected = 0;\n    gs_color_space_index    index;\n    gsicc_manager_t         *icc_manager = igs->icc_manager;\n    cmm_profile_t           *source_profile = NULL;\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    if_debug0m(gs_debug_flag_icc, imemory, \"[icc] Using OutputIntent\\n\");\n\n    /* Get the device structure */\n    code = dev_proc(dev, get_profile)(dev,  &dev_profile);\n    if (code < 0)\n        return code;\n\n    if (dev_profile == NULL) {\n        code = gsicc_init_device_profile_struct(dev, NULL, 0);\n        if (code < 0)\n            return code;\n        code = dev_proc(dev, get_profile)(dev,  &dev_profile);\n        if (code < 0)\n            return code;\n    }\n    if (dev_profile->oi_profile != NULL) {\n        return 0;  /* Allow only one setting of this object */\n    }\n    code = dict_find_string(op, \"N\", &pnval);\n    if (code < 0)\n        return code;\n    if (code == 0)\n        return_error(gs_error_undefined);\n    ncomps = pnval->value.intval;\n\n    /* verify the DataSource entry. Creat profile from stream */\n    if (dict_find_string(op, \"DataSource\", &pstrmval) <= 0)\n        return_error(gs_error_undefined);\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n    if (picc_profile == NULL)\n        return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n    picc_profile->num_comps = ncomps;\n    picc_profile->profile_handle =\n        gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                        picc_profile->buffer_size,\n                                        gs_gstate_memory(igs));\n    if (picc_profile->profile_handle == NULL) {\n        rc_decrement(picc_profile,\"zset_outputintent\");\n        return -1;\n    }\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            source_profile = icc_manager->default_rgb;\n            break;\n        case gsGRAY:\n            expected = 1;\n            source_profile = icc_manager->default_gray;\n            break;\n        case gsCMYK:\n            expected = 4;\n            source_profile = icc_manager->default_cmyk;\n            break;\n        case gsNCHANNEL:\n            expected = 0;\n            break;\n        case gsNAMED:\n        case gsUNDEFINED:\n            break;\n    }\n    if (expected && ncomps != expected) {\n        rc_decrement(picc_profile,\"zset_outputintent\");\n        return_error(gs_error_rangecheck);\n    }\n    gsicc_init_hash_cs(picc_profile, igs);\n\n    /* All is well with the profile.  Lets set the stuff that needs to be set */\n    dev_profile->oi_profile = picc_profile;\n    picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,\n                                                 MAX_DEFAULT_ICC_LENGTH,\n                                                 \"zset_outputintent\");\n    strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));\n    picc_profile->name[strlen(OI_PROFILE)] = 0;\n    picc_profile->name_length = strlen(OI_PROFILE);\n    /* Set the range of the profile */\n    gsicc_set_icc_range(&picc_profile);\n\n    /* If the output device has a different number of componenets, then we are\n       going to set the output intent as the proofing profile, unless the\n       proofing profile has already been set.\n\n       If the device has the same number of components (and color model) then as\n       the profile we will use this as the output profile, unless someone has\n       explicitly set the output profile.\n\n       Finally, we will use the output intent profile for the default profile\n       of the proper Device profile in the icc manager, again, unless someone\n       has explicitly set this default profile. */\n\n    dev_comps = dev_profile->device_profile[0]->num_comps;\n    index = gsicc_get_default_type(dev_profile->device_profile[0]);\n    if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {\n        /* The OI profile is the same type as the profile for the device and a\n           \"default\" profile for the device was not externally set. So we go\n           ahead and use the OI profile as the device profile.  Care needs to be\n           taken here to keep from screwing up any device parameters.   We will\n           use a keyword of OIProfile for the user/device parameter to indicate\n           its usage.  Also, note conflicts if one is setting object dependent\n           color management */\n        rc_assign(dev_profile->device_profile[0], picc_profile,\n                  \"zset_outputintent\");\n        if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used for device profile\\n\");\n    } else {\n        if (dev_profile->proof_profile == NULL) {\n            /* This means that we should use the OI profile as the proofing\n               profile.  Note that if someone already has specified a\n               proofing profile it is unclear what they are trying to do\n               with the output intent.  In this case, we will use it\n               just for the source data below */\n            dev_profile->proof_profile = picc_profile;\n            rc_increment(picc_profile);\n            if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used for proof profile\\n\");\n        }\n    }\n    /* Now the source colors.  See which source color space needs to use the\n       output intent ICC profile */\n    index = gsicc_get_default_type(source_profile);\n    if (index < gs_color_space_index_DevicePixel) {\n        /* source_profile is currently the default.  Set it to the OI profile */\n        switch (picc_profile->data_cs) {\n            case gsGRAY:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source Gray\\n\");\n                rc_assign(icc_manager->default_gray, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            case gsRGB:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source RGB\\n\");\n                rc_assign(icc_manager->default_rgb, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            case gsCMYK:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source CMYK\\n\");\n                rc_assign(icc_manager->default_cmyk, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            default:\n                break;\n        }\n    }\n    /* Remove the output intent dict from the stack */\n    pop(1);\n    return code;\n}",
        "func": "static int\nzset_outputintent(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    int                     code = 0;\n    gx_device *dev = gs_currentdevice(igs);\n    cmm_dev_profile_t       *dev_profile;\n    stream *                s = 0L;\n    ref *                   pnval;\n    ref *                   pstrmval;\n    int                     ncomps, dev_comps;\n    cmm_profile_t           *picc_profile;\n    int                     expected = 0;\n    gs_color_space_index    index;\n    gsicc_manager_t         *icc_manager = igs->icc_manager;\n    cmm_profile_t           *source_profile = NULL;\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    if_debug0m(gs_debug_flag_icc, imemory, \"[icc] Using OutputIntent\\n\");\n\n    /* Get the device structure */\n    code = dev_proc(dev, get_profile)(dev,  &dev_profile);\n    if (code < 0)\n        return code;\n\n    if (dev_profile == NULL) {\n        code = gsicc_init_device_profile_struct(dev, NULL, 0);\n        if (code < 0)\n            return code;\n        code = dev_proc(dev, get_profile)(dev,  &dev_profile);\n        if (code < 0)\n            return code;\n    }\n    if (dev_profile->oi_profile != NULL) {\n        return 0;  /* Allow only one setting of this object */\n    }\n    code = dict_find_string(op, \"N\", &pnval);\n    if (code < 0)\n        return code;\n    if (code == 0)\n        return_error(gs_error_undefined);\n    if (r_type(pnval) != t_integer)\n        return gs_note_error(gs_error_typecheck);\n    ncomps = pnval->value.intval;\n\n    /* verify the DataSource entry. Creat profile from stream */\n    if (dict_find_string(op, \"DataSource\", &pstrmval) <= 0)\n        return_error(gs_error_undefined);\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n    if (picc_profile == NULL)\n        return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n    picc_profile->num_comps = ncomps;\n    picc_profile->profile_handle =\n        gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                        picc_profile->buffer_size,\n                                        gs_gstate_memory(igs));\n    if (picc_profile->profile_handle == NULL) {\n        rc_decrement(picc_profile,\"zset_outputintent\");\n        return -1;\n    }\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            source_profile = icc_manager->default_rgb;\n            break;\n        case gsGRAY:\n            expected = 1;\n            source_profile = icc_manager->default_gray;\n            break;\n        case gsCMYK:\n            expected = 4;\n            source_profile = icc_manager->default_cmyk;\n            break;\n        case gsNCHANNEL:\n            expected = 0;\n            break;\n        case gsNAMED:\n        case gsUNDEFINED:\n            break;\n    }\n    if (expected && ncomps != expected) {\n        rc_decrement(picc_profile,\"zset_outputintent\");\n        return_error(gs_error_rangecheck);\n    }\n    gsicc_init_hash_cs(picc_profile, igs);\n\n    /* All is well with the profile.  Lets set the stuff that needs to be set */\n    dev_profile->oi_profile = picc_profile;\n    picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,\n                                                 MAX_DEFAULT_ICC_LENGTH,\n                                                 \"zset_outputintent\");\n    strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));\n    picc_profile->name[strlen(OI_PROFILE)] = 0;\n    picc_profile->name_length = strlen(OI_PROFILE);\n    /* Set the range of the profile */\n    gsicc_set_icc_range(&picc_profile);\n\n    /* If the output device has a different number of componenets, then we are\n       going to set the output intent as the proofing profile, unless the\n       proofing profile has already been set.\n\n       If the device has the same number of components (and color model) then as\n       the profile we will use this as the output profile, unless someone has\n       explicitly set the output profile.\n\n       Finally, we will use the output intent profile for the default profile\n       of the proper Device profile in the icc manager, again, unless someone\n       has explicitly set this default profile. */\n\n    dev_comps = dev_profile->device_profile[0]->num_comps;\n    index = gsicc_get_default_type(dev_profile->device_profile[0]);\n    if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {\n        /* The OI profile is the same type as the profile for the device and a\n           \"default\" profile for the device was not externally set. So we go\n           ahead and use the OI profile as the device profile.  Care needs to be\n           taken here to keep from screwing up any device parameters.   We will\n           use a keyword of OIProfile for the user/device parameter to indicate\n           its usage.  Also, note conflicts if one is setting object dependent\n           color management */\n        rc_assign(dev_profile->device_profile[0], picc_profile,\n                  \"zset_outputintent\");\n        if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used for device profile\\n\");\n    } else {\n        if (dev_profile->proof_profile == NULL) {\n            /* This means that we should use the OI profile as the proofing\n               profile.  Note that if someone already has specified a\n               proofing profile it is unclear what they are trying to do\n               with the output intent.  In this case, we will use it\n               just for the source data below */\n            dev_profile->proof_profile = picc_profile;\n            rc_increment(picc_profile);\n            if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used for proof profile\\n\");\n        }\n    }\n    /* Now the source colors.  See which source color space needs to use the\n       output intent ICC profile */\n    index = gsicc_get_default_type(source_profile);\n    if (index < gs_color_space_index_DevicePixel) {\n        /* source_profile is currently the default.  Set it to the OI profile */\n        switch (picc_profile->data_cs) {\n            case gsGRAY:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source Gray\\n\");\n                rc_assign(icc_manager->default_gray, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            case gsRGB:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source RGB\\n\");\n                rc_assign(icc_manager->default_rgb, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            case gsCMYK:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source CMYK\\n\");\n                rc_assign(icc_manager->default_cmyk, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            default:\n                break;\n        }\n    }\n    /* Remove the output intent dict from the stack */\n    pop(1);\n    return code;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,8 @@\n         return code;\n     if (code == 0)\n         return_error(gs_error_undefined);\n+    if (r_type(pnval) != t_integer)\n+        return gs_note_error(gs_error_typecheck);\n     ncomps = pnval->value.intval;\n \n     /* verify the DataSource entry. Creat profile from stream */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (r_type(pnval) != t_integer)",
                "        return gs_note_error(gs_error_typecheck);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19476",
        "func_name": "ArtifexSoftware/ghostpdl/znumicc_components",
        "description": "psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/67d760ab775dae4efe803b5944b0439aa3c0b04a",
        "commit_title": "Bug #700169 - unchecked type",
        "commit_text": " Bug #700169 \"Type confusion in setcolorspace\"  In seticc() we extract \"Name\" from a dictionary, if it succeeds we then use it as a string, without checking the type to see if it is in fact a string.  Add a check on the type, and add a couple to check that 'N' is an integer in a few places too.",
        "func_before": "static int\nznumicc_components(i_ctx_t * i_ctx_p)\n{\n    ref *                   pnval;\n    ref *                   pstrmval;\n    stream *                s;\n    int                     ncomps, expected = 0, code;\n    cmm_profile_t           *picc_profile;\n    os_ptr                  op = osp;\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n\n    code = dict_find_string(op, \"N\", &pnval);\n    if (code < 0)\n        return code;\n    if (code == 0)\n        return_error(gs_error_undefined);\n    ncomps = pnval->value.intval;\n    /* verify the DataSource entry. Create profile from stream */\n    if (dict_find_string(op, \"DataSource\", &pstrmval) <= 0)\n        return_error(gs_error_undefined);\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n    if (picc_profile == NULL)\n        return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n\n    picc_profile->num_comps = ncomps;\n    picc_profile->profile_handle =\n        gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                        picc_profile->buffer_size,\n                                        gs_gstate_memory(igs));\n    if (picc_profile->profile_handle == NULL) {\n        rc_decrement(picc_profile,\"znumicc_components\");\n        make_int(op, expected);\n        return 0;\n    }\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            break;\n        case gsGRAY:\n            expected = 1;\n            break;\n        case gsCMYK:\n            expected = 4;\n            break;\n        case gsNCHANNEL:\n            expected = 0;\n            break;\n        case gsNAMED:\n        case gsUNDEFINED:\n            expected = -1;\n            break;\n    }\n\n    make_int(op, expected);\n\n    rc_decrement(picc_profile,\"zset_outputintent\");\n    return 0;\n}",
        "func": "static int\nznumicc_components(i_ctx_t * i_ctx_p)\n{\n    ref *                   pnval;\n    ref *                   pstrmval;\n    stream *                s;\n    int                     ncomps, expected = 0, code;\n    cmm_profile_t           *picc_profile;\n    os_ptr                  op = osp;\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n\n    code = dict_find_string(op, \"N\", &pnval);\n    if (code < 0)\n        return code;\n    if (code == 0)\n        return_error(gs_error_undefined);\n    if (r_type(pnval) != t_integer)\n        return gs_note_error(gs_error_typecheck);\n    ncomps = pnval->value.intval;\n    /* verify the DataSource entry. Create profile from stream */\n    if (dict_find_string(op, \"DataSource\", &pstrmval) <= 0)\n        return_error(gs_error_undefined);\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n    if (picc_profile == NULL)\n        return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n\n    picc_profile->num_comps = ncomps;\n    picc_profile->profile_handle =\n        gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                        picc_profile->buffer_size,\n                                        gs_gstate_memory(igs));\n    if (picc_profile->profile_handle == NULL) {\n        rc_decrement(picc_profile,\"znumicc_components\");\n        make_int(op, expected);\n        return 0;\n    }\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            break;\n        case gsGRAY:\n            expected = 1;\n            break;\n        case gsCMYK:\n            expected = 4;\n            break;\n        case gsNCHANNEL:\n            expected = 0;\n            break;\n        case gsNAMED:\n        case gsUNDEFINED:\n            expected = -1;\n            break;\n    }\n\n    make_int(op, expected);\n\n    rc_decrement(picc_profile,\"zset_outputintent\");\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,8 @@\n         return code;\n     if (code == 0)\n         return_error(gs_error_undefined);\n+    if (r_type(pnval) != t_integer)\n+        return gs_note_error(gs_error_typecheck);\n     ncomps = pnval->value.intval;\n     /* verify the DataSource entry. Create profile from stream */\n     if (dict_find_string(op, \"DataSource\", &pstrmval) <= 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (r_type(pnval) != t_integer)",
                "        return gs_note_error(gs_error_typecheck);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19477",
        "func_name": "ArtifexSoftware/ghostpdl/z_jbig2decode",
        "description": "psi/zfjbig2.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a JBIG2Decode type confusion.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/606a22e77e7f081781e99e44644cd0119f559e03",
        "commit_title": "Bug #700168 - add a type check",
        "commit_text": " Bug #700168 \"Type confusion in JBIG2Decode\"  The code was assuming that .jbig2globalctx was a structure allocated by the graphics library, without checking.  Add a check to see that it is a structure and that its the correct type of structure.",
        "func_before": "static int\nz_jbig2decode(i_ctx_t * i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *sop = NULL;\n    s_jbig2_global_data_t *gref;\n    stream_jbig2decode_state state;\n\n    /* Extract the global context reference, if any, from the parameter\n       dictionary and embed it in our stream state. The original object\n       ref is under the JBIG2Globals key.\n       We expect the postscript code to resolve this and call\n       z_jbig2makeglobalctx() below to create an astruct wrapping the\n       global decoder data and store it under the .jbig2globalctx key\n     */\n    s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n        if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n            gref = r_ptr(sop, s_jbig2_global_data_t);\n            s_jbig2decode_set_global_data((stream_state*)&state, gref);\n        }\n    }\n\n    /* we pass npop=0, since we've no arguments left to consume */\n    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                       (stream_state *) & state, (sop ? r_space(sop) : 0));\n}",
        "func": "static int\nz_jbig2decode(i_ctx_t * i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *sop = NULL;\n    s_jbig2_global_data_t *gref;\n    stream_jbig2decode_state state;\n\n    /* Extract the global context reference, if any, from the parameter\n       dictionary and embed it in our stream state. The original object\n       ref is under the JBIG2Globals key.\n       We expect the postscript code to resolve this and call\n       z_jbig2makeglobalctx() below to create an astruct wrapping the\n       global decoder data and store it under the .jbig2globalctx key\n     */\n    s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n        if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n            if (!r_is_struct(sop) || !r_has_stype(sop, imemory, st_jbig2_global_data_t))\n                return_error(gs_error_typecheck);\n            gref = r_ptr(sop, s_jbig2_global_data_t);\n            s_jbig2decode_set_global_data((stream_state*)&state, gref);\n        }\n    }\n\n    /* we pass npop=0, since we've no arguments left to consume */\n    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                       (stream_state *) & state, (sop ? r_space(sop) : 0));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n     if (r_has_type(op, t_dictionary)) {\n         check_dict_read(*op);\n         if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n+            if (!r_is_struct(sop) || !r_has_stype(sop, imemory, st_jbig2_global_data_t))\n+                return_error(gs_error_typecheck);\n             gref = r_ptr(sop, s_jbig2_global_data_t);\n             s_jbig2decode_set_global_data((stream_state*)&state, gref);\n         }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            if (!r_is_struct(sop) || !r_has_stype(sop, imemory, st_jbig2_global_data_t))",
                "                return_error(gs_error_typecheck);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5804",
        "func_name": "LibRaw/quicktake_100_load_raw",
        "description": "A type confusion error within the \"identify()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.8 can be exploited to trigger a division by zero.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/9f26ce37f5be86ea11bfc6831366558650b1f6ff",
        "commit_title": "SA81000: LibRaw 0.18.8",
        "commit_text": "",
        "func_before": "void CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n    }\n  for (row=2; row < height+2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  }\n  maximum = 0x3ff;\n}",
        "func": "void CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(width>640 || height > 480)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  \n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n    }\n  for (row=2; row < height+2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  }\n  maximum = 0x3ff;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,11 @@\n     654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n     855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n   int rb, row, col, sharp, val=0;\n-\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(width>640 || height > 480)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+  \n   getbits(-1);\n   memset (pixel, 0x80, sizeof pixel);\n   for (row=2; row < height+2; row++) {",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(width>640 || height > 480)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif",
                "  "
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5804",
        "func_name": "LibRaw/leaf_hdr_load_raw",
        "description": "A type confusion error within the \"identify()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.8 can be exploited to trigger a division by zero.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/9f26ce37f5be86ea11bfc6831366558650b1f6ff",
        "commit_title": "SA81000: LibRaw 0.18.8",
        "commit_text": "",
        "func_before": "void CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    if(!filters) free(pixel);\n    throw;\n  }\n#endif\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}",
        "func": "void CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!image)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    if(!filters) free(pixel);\n    throw;\n  }\n#endif\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n   unsigned tile=0, r, c, row, col;\n \n   if (!filters) {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+    if(!image)\n+      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n     pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n     merror (pixel, \"leaf_hdr_load_raw()\");\n   }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "    if(!image)",
                "      throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5804",
        "func_name": "LibRaw/quicktake_100_load_raw",
        "description": "A type confusion error within the \"identify()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.8 can be exploited to trigger a division by zero.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/9f26ce37f5be86ea11bfc6831366558650b1f6ff",
        "commit_title": "SA81000: LibRaw 0.18.8",
        "commit_text": "",
        "func_before": "void CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n\n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n    }\n  for (row=2; row < height+2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  }\n  maximum = 0x3ff;\n}",
        "func": "void CLASS quicktake_100_load_raw()\n{\n  uchar pixel[484][644];\n  static const short gstep[16] =\n  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };\n  static const short rstep[6][4] =\n  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },\n    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };\n  static const short t_curve[256] =\n  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,\n    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,\n    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,\n    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,\n    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,\n    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,\n    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,\n    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,\n    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,\n    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,\n    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n  int rb, row, col, sharp, val=0;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(width>640 || height > 480)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  \n  getbits(-1);\n  memset (pixel, 0x80, sizeof pixel);\n  for (row=2; row < height+2; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=2+(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +\n\t\tpixel[row][col-2]) >> 2) + gstep[getbits(4)];\n      pixel[row][col] = val = LIM(val,0,255);\n      if (col < 4)\n\tpixel[row][col-2] = pixel[row+1][~row & 1] = val;\n      if (row == 2)\n\tpixel[row-1][col+1] = pixel[row-1][col+3] = val;\n    }\n    pixel[row][col] = val;\n  }\n  for (rb=0; rb < 2; rb++)\n    for (row=2+rb; row < height+2; row+=2)\n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=3-(row & 1); col < width+2; col+=2) {\n\tif (row < 4 || col < 4) sharp = 2;\n\telse {\n\t  val = ABS(pixel[row-2][col] - pixel[row][col-2])\n\t      + ABS(pixel[row-2][col] - pixel[row-2][col-2])\n\t      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);\n\t  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :\n\t\t  val < 32 ? 3 : val < 48 ? 4 : 5;\n\t}\n\tval = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)\n\t      + rstep[sharp][getbits(2)];\n\tpixel[row][col] = val = LIM(val,0,255);\n\tif (row < 4) pixel[row-2][col+2] = val;\n\tif (col < 4) pixel[row+2][col-2] = val;\n      }\n    }\n  for (row=2; row < height+2; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=3-(row & 1); col < width+2; col+=2) {\n      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +\n\t      pixel[row][col+1]) >> 1) - 0x100;\n      pixel[row][col] = LIM(val,0,255);\n    }\n  }\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col++)\n      RAW(row,col) = t_curve[pixel[row+2][col+2]];\n  }\n  maximum = 0x3ff;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,11 @@\n     654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,\n     855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };\n   int rb, row, col, sharp, val=0;\n-\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(width>640 || height > 480)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+  \n   getbits(-1);\n   memset (pixel, 0x80, sizeof pixel);\n   for (row=2; row < height+2; row++) {",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(width>640 || height > 480)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif",
                "  "
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5804",
        "func_name": "LibRaw/leaf_hdr_load_raw",
        "description": "A type confusion error within the \"identify()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.8 can be exploited to trigger a division by zero.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/9f26ce37f5be86ea11bfc6831366558650b1f6ff",
        "commit_title": "SA81000: LibRaw 0.18.8",
        "commit_text": "",
        "func_before": "void CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    if(!filters) free(pixel);\n    throw;\n  }\n#endif\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}",
        "func": "void CLASS leaf_hdr_load_raw()\n{\n  ushort *pixel=0;\n  unsigned tile=0, r, c, row, col;\n\n  if (!filters) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!image)\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n    merror (pixel, \"leaf_hdr_load_raw()\");\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  FORC(tiff_samples)\n    for (r=0; r < raw_height; r++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      if (r % tile_length == 0) {\n\tfseek (ifp, data_offset + 4*tile++, SEEK_SET);\n\tfseek (ifp, get4(), SEEK_SET);\n      }\n      if (filters && c != shot_select) continue;\n      if (filters) pixel = raw_image + r*raw_width;\n      read_shorts (pixel, raw_width);\n      if (!filters && (row = r - top_margin) < height)\n\tfor (col=0; col < width; col++)\n\t  image[row*width+col][c] = pixel[col+left_margin];\n    }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    if(!filters) free(pixel);\n    throw;\n  }\n#endif\n  if (!filters) {\n    maximum = 0xffff;\n    raw_color = 1;\n    free (pixel);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n   unsigned tile=0, r, c, row, col;\n \n   if (!filters) {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+    if(!image)\n+      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n     pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n     merror (pixel, \"leaf_hdr_load_raw()\");\n   }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "    if(!image)",
                "      throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41890",
        "func_name": "tensorflow/BCastList<N>::BCastList",
        "description": "TensorFlow is an open source platform for machine learning. If `BCast::ToShape` is given input larger than an `int32`, it will crash, despite being supposed to handle up to an `int64`. An example can be seen in `tf.experimental.numpy.outer` by passing in large input to the input `b`. We have patched the issue in GitHub commit 8310bf8dd188ff780e7fc53245058215a05bdbe5. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/8310bf8dd188ff780e7fc53245058215a05bdbe5",
        "commit_title": "Fix crash caused by large broadcasting error.  There was an int32 overflow.",
        "commit_text": " PiperOrigin-RevId: 475677838",
        "func_before": "BCastList<N>::BCastList(const BCastList::Vec (&x)[N],\n                        const bool fewer_dims_optimization,\n                        const bool return_flattened_batch_indices) {\n  typedef BCastList::Vec Vec;\n\n  // Safely multiplies dimensions taking into account symbolic shapes.\n  auto mul_dims = [](int64_t dim1, int64_t dim2) -> int64 {\n    return dim1 != 0 && dim2 != 0 && (dim1 < 0 || dim2 < 0) ? -1 : dim1 * dim2;\n  };\n\n  bool all_equal = true;\n  size_t largest_rank = 0;\n  output_batch_size_ = 1;\n  for (int i = 0; i < N; ++i) {\n    if (x[i] != x[0]) {\n      all_equal = false;\n    }\n    if (x[i].size() > largest_rank) {\n      largest_rank = x[i].size();\n    }\n  }\n  if (all_equal) {\n    broadcasting_required_ = false;\n  }\n  if (all_equal && TF_PREDICT_TRUE(fewer_dims_optimization)) {\n    // Fast path for common case of identical shapes.\n    int64_t elements = 1;\n    const int rank = x[0].size();\n    output_.resize(rank);\n    for (int i = 0; i < rank; i++) {\n      const int64_t dim = x[0][i];\n      elements = mul_dims(elements, dim);\n      output_[i] = dim;\n    }\n    result_.push_back(elements);\n    output_batch_size_ = elements;\n    for (int i = 0; i < N; ++i) {\n      reshape_[i].push_back(elements);\n      bcast_[i].push_back(1);\n    }\n    // grad_reduce_ is left as empty\n    return;\n  }\n\n  // Reverse all the shapes for convenience\n  // After the reverse, 0-th is the inner-most dimension.\n  Vec copy[N];\n  for (int i = 0; i < N; ++i) {\n    copy[i] = x[i];\n    Reverse(&copy[i]);\n  }\n\n  // 1-extend and align all vectors.\n  for (int i = 0; i < N; ++i) {\n    if (copy[i].size() < largest_rank) {\n      copy[i].resize(largest_rank, 1);\n    }\n  }\n  // Going through each dimension starting from the inner-most\n  // dimension, compares dimension of x and y. They are compatible if\n  // they are equal or either is 1.\n\n  // indices of j-th component of each input.\n  bool prev_is_one[N];\n  bool current_is_one[N];\n  for (int i = 0; i < N; ++i) {\n    prev_is_one[i] = false;\n    current_is_one[i] = false;\n  }\n  Vec output;\n  bool output_dim_set = false;\n  int output_dim = -1;\n  bool none_is_one = true;\n  bool set_one = false;\n  for (int j = 0; j < largest_rank; ++j) {\n    output_dim = -1;\n    output_dim_set = false;\n    none_is_one = true;\n    // Find which indices are 1.\n    for (int i = 0; i < N; ++i) {\n      // Keep track of which indices are 1.\n      if (copy[i][j] == 1) {\n        current_is_one[i] = true;\n        none_is_one = false;\n      } else {\n        current_is_one[i] = false;\n        if (!output_dim_set || copy[i][j] == output_dim) {\n          output_dim = copy[i][j];\n          output_dim_set = true;\n        } else {\n          valid_ = false;\n          return;\n        }\n      }\n    }\n    output_.push_back(output_dim_set ? output_dim : 1);\n    output_batch_size_ = mul_dims(output_batch_size_, output_.back());\n    // All dimensions are 1.\n    if (!output_dim_set) {\n      if (!TF_PREDICT_TRUE(fewer_dims_optimization)) {\n        for (int i = 0; i < N; ++i) {\n          bcast_[i].push_back(1);\n          reshape_[i].push_back(1);\n        }\n        result_.push_back(1);\n      }\n      for (int i = 0; i < N; ++i) {\n        grad_reduce_idx_[i].push_back(largest_rank - 1 - j);\n      }\n      // This will skip updating the previous state to the current one. We'll\n      // explain why this is safe below.\n      // Consider the previous state P, current state C and the next state N.\n      // In the case where N also is all ones (N == C), we'll do the same\n      // optimization here (push back one dimensions if we need to), which is\n      // safe and is expected.\n      //\n      // When N != C, we'll continue as usual. However, we might trigger the\n      // next block if N == P (because we didn't update the previous state).\n      // We trigger the next block if `fewer_dims_optimization` is true.\n      // This means that we did not modify and broadcast / reshapes in this\n      // block (we skipped updating, since the one dimensions can be ignored).\n      // In essence, we only need to check whether the previous non-one state is\n      // equal to the current non-one state.\n\n      continue;\n    } else if (TF_PREDICT_TRUE(fewer_dims_optimization) &&\n               std::equal(current_is_one, current_is_one + N, prev_is_one) &&\n               set_one) {\n      // It is a run of the same broadcasting case as last time.\n      // We can reshape the input so that fewer dimensions\n      // are involved in the intermediate computation.\n      result_.back() = mul_dims(result_.back(), output_dim);\n      for (int i = 0; i < N; ++i) {\n        reshape_[i].back() = mul_dims(reshape_[i].back(), copy[i][j]);\n        bcast_[i].back() =\n            mul_dims(bcast_[i].back(), current_is_one[i] ? output_dim : 1);\n        if (current_is_one[i] && !none_is_one) {\n          grad_reduce_idx_[i].push_back(largest_rank - 1 - j);\n        }\n      }\n    } else {\n      result_.push_back(output_dim);\n      for (int i = 0; i < N; ++i) {\n        reshape_[i].push_back(copy[i][j]);\n        bcast_[i].push_back(current_is_one[i] ? output_dim : 1);\n        if (current_is_one[i] && !none_is_one) {\n          grad_reduce_idx_[i].push_back(largest_rank - 1 - j);\n        }\n      }\n    }\n    set_one = true;\n    for (int i = 0; i < N; ++i) {\n      prev_is_one[i] = current_is_one[i];\n    }\n  }\n  if (result_.empty()) {\n    result_.push_back(1);\n    for (int i = 0; i < N; ++i) {\n      reshape_[i].push_back(1);\n      bcast_[i].push_back(1);\n    }\n  }\n  // Do something about batches.\n  for (int i = 0; i < N; ++i) {\n    Reverse(&reshape_[i]);\n    Reverse(&bcast_[i]);\n    Reverse(&grad_reduce_idx_[i]);\n  }\n  Reverse(&result_);\n  Reverse(&output_);\n  // Only compute batch indices when we need broadcasting, and we aren't doing\n  // needless work (when the output size is 0 or the\n  // return_flattened_batch_indices isn't enabled).\n  if (return_flattened_batch_indices && broadcasting_required_ &&\n      output_batch_size_ > 0) {\n    for (int i = 0; i < N; ++i) {\n      ComputeBatchIndices(output_batch_size_, reshape_[i], bcast_[i],\n                          &batch_indices_[i]);\n    }\n  }\n}",
        "func": "BCastList<N>::BCastList(const BCastList::Vec (&x)[N],\n                        const bool fewer_dims_optimization,\n                        const bool return_flattened_batch_indices) {\n  typedef BCastList::Vec Vec;\n\n  // Safely multiplies dimensions taking into account symbolic shapes.\n  auto mul_dims = [](int64_t dim1, int64_t dim2) -> int64_t {\n    return dim1 != 0 && dim2 != 0 && (dim1 < 0 || dim2 < 0) ? -1 : dim1 * dim2;\n  };\n\n  bool all_equal = true;\n  size_t largest_rank = 0;\n  output_batch_size_ = 1;\n  for (int i = 0; i < N; ++i) {\n    if (x[i] != x[0]) {\n      all_equal = false;\n    }\n    if (x[i].size() > largest_rank) {\n      largest_rank = x[i].size();\n    }\n  }\n  if (all_equal) {\n    broadcasting_required_ = false;\n  }\n  if (all_equal && TF_PREDICT_TRUE(fewer_dims_optimization)) {\n    // Fast path for common case of identical shapes.\n    int64_t elements = 1;\n    const int rank = x[0].size();\n    output_.resize(rank);\n    for (int i = 0; i < rank; i++) {\n      const int64_t dim = x[0][i];\n      elements = mul_dims(elements, dim);\n      output_[i] = dim;\n    }\n    result_.push_back(elements);\n    output_batch_size_ = elements;\n    for (int i = 0; i < N; ++i) {\n      reshape_[i].push_back(elements);\n      bcast_[i].push_back(1);\n    }\n    // grad_reduce_ is left as empty\n    return;\n  }\n\n  // Reverse all the shapes for convenience\n  // After the reverse, 0-th is the inner-most dimension.\n  Vec copy[N];\n  for (int i = 0; i < N; ++i) {\n    copy[i] = x[i];\n    Reverse(&copy[i]);\n  }\n\n  // 1-extend and align all vectors.\n  for (int i = 0; i < N; ++i) {\n    if (copy[i].size() < largest_rank) {\n      copy[i].resize(largest_rank, 1);\n    }\n  }\n  // Going through each dimension starting from the inner-most\n  // dimension, compares dimension of x and y. They are compatible if\n  // they are equal or either is 1.\n\n  // indices of j-th component of each input.\n  bool prev_is_one[N];\n  bool current_is_one[N];\n  for (int i = 0; i < N; ++i) {\n    prev_is_one[i] = false;\n    current_is_one[i] = false;\n  }\n  Vec output;\n  bool output_dim_set = false;\n  int64_t output_dim = -1;\n  bool none_is_one = true;\n  bool set_one = false;\n  for (int j = 0; j < largest_rank; ++j) {\n    output_dim = -1;\n    output_dim_set = false;\n    none_is_one = true;\n    // Find which indices are 1.\n    for (int i = 0; i < N; ++i) {\n      // Keep track of which indices are 1.\n      if (copy[i][j] == 1) {\n        current_is_one[i] = true;\n        none_is_one = false;\n      } else {\n        current_is_one[i] = false;\n        if (!output_dim_set || copy[i][j] == output_dim) {\n          output_dim = copy[i][j];\n          output_dim_set = true;\n        } else {\n          valid_ = false;\n          return;\n        }\n      }\n    }\n    output_.push_back(output_dim_set ? output_dim : 1);\n    output_batch_size_ = mul_dims(output_batch_size_, output_.back());\n    // All dimensions are 1.\n    if (!output_dim_set) {\n      if (!TF_PREDICT_TRUE(fewer_dims_optimization)) {\n        for (int i = 0; i < N; ++i) {\n          bcast_[i].push_back(1);\n          reshape_[i].push_back(1);\n        }\n        result_.push_back(1);\n      }\n      for (int i = 0; i < N; ++i) {\n        grad_reduce_idx_[i].push_back(largest_rank - 1 - j);\n      }\n      // This will skip updating the previous state to the current one. We'll\n      // explain why this is safe below.\n      // Consider the previous state P, current state C and the next state N.\n      // In the case where N also is all ones (N == C), we'll do the same\n      // optimization here (push back one dimensions if we need to), which is\n      // safe and is expected.\n      //\n      // When N != C, we'll continue as usual. However, we might trigger the\n      // next block if N == P (because we didn't update the previous state).\n      // We trigger the next block if `fewer_dims_optimization` is true.\n      // This means that we did not modify and broadcast / reshapes in this\n      // block (we skipped updating, since the one dimensions can be ignored).\n      // In essence, we only need to check whether the previous non-one state is\n      // equal to the current non-one state.\n\n      continue;\n    } else if (TF_PREDICT_TRUE(fewer_dims_optimization) &&\n               std::equal(current_is_one, current_is_one + N, prev_is_one) &&\n               set_one) {\n      // It is a run of the same broadcasting case as last time.\n      // We can reshape the input so that fewer dimensions\n      // are involved in the intermediate computation.\n      result_.back() = mul_dims(result_.back(), output_dim);\n      for (int i = 0; i < N; ++i) {\n        reshape_[i].back() = mul_dims(reshape_[i].back(), copy[i][j]);\n        bcast_[i].back() =\n            mul_dims(bcast_[i].back(), current_is_one[i] ? output_dim : 1);\n        if (current_is_one[i] && !none_is_one) {\n          grad_reduce_idx_[i].push_back(largest_rank - 1 - j);\n        }\n      }\n    } else {\n      result_.push_back(output_dim);\n      for (int i = 0; i < N; ++i) {\n        reshape_[i].push_back(copy[i][j]);\n        bcast_[i].push_back(current_is_one[i] ? output_dim : 1);\n        if (current_is_one[i] && !none_is_one) {\n          grad_reduce_idx_[i].push_back(largest_rank - 1 - j);\n        }\n      }\n    }\n    set_one = true;\n    for (int i = 0; i < N; ++i) {\n      prev_is_one[i] = current_is_one[i];\n    }\n  }\n  if (result_.empty()) {\n    result_.push_back(1);\n    for (int i = 0; i < N; ++i) {\n      reshape_[i].push_back(1);\n      bcast_[i].push_back(1);\n    }\n  }\n  // Do something about batches.\n  for (int i = 0; i < N; ++i) {\n    Reverse(&reshape_[i]);\n    Reverse(&bcast_[i]);\n    Reverse(&grad_reduce_idx_[i]);\n  }\n  Reverse(&result_);\n  Reverse(&output_);\n  // Only compute batch indices when we need broadcasting, and we aren't doing\n  // needless work (when the output size is 0 or the\n  // return_flattened_batch_indices isn't enabled).\n  if (return_flattened_batch_indices && broadcasting_required_ &&\n      output_batch_size_ > 0) {\n    for (int i = 0; i < N; ++i) {\n      ComputeBatchIndices(output_batch_size_, reshape_[i], bcast_[i],\n                          &batch_indices_[i]);\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n   typedef BCastList::Vec Vec;\n \n   // Safely multiplies dimensions taking into account symbolic shapes.\n-  auto mul_dims = [](int64_t dim1, int64_t dim2) -> int64 {\n+  auto mul_dims = [](int64_t dim1, int64_t dim2) -> int64_t {\n     return dim1 != 0 && dim2 != 0 && (dim1 < 0 || dim2 < 0) ? -1 : dim1 * dim2;\n   };\n \n@@ -69,7 +69,7 @@\n   }\n   Vec output;\n   bool output_dim_set = false;\n-  int output_dim = -1;\n+  int64_t output_dim = -1;\n   bool none_is_one = true;\n   bool set_one = false;\n   for (int j = 0; j < largest_rank; ++j) {",
        "diff_line_info": {
            "deleted_lines": [
                "  auto mul_dims = [](int64_t dim1, int64_t dim2) -> int64 {",
                "  int output_dim = -1;"
            ],
            "added_lines": [
                "  auto mul_dims = [](int64_t dim1, int64_t dim2) -> int64_t {",
                "  int64_t output_dim = -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9626",
        "func_name": "videolan/vlc/MP4_ReadBox_String",
        "description": "Integer underflow in the MP4_ReadBox_String function in modules/demux/mp4/libmp4.c in VideoLAN VLC media player before 2.1.6 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a box size less than 7.",
        "git_url": "https://github.com/videolan/vlc/commit/2e7c7091a61aa5d07e7997b393d821e91f593c39",
        "commit_title": "demux: mp4: fix buffer overflow in parsing of string boxes.",
        "commit_text": " We ensure that pbox->i_size is never smaller than 8 to avoid an integer underflow in the third argument of the subsequent call to memcpy. We also make sure no truncation occurs when passing values derived from the 64 bit integer p_box->i_size to arguments of malloc and memcpy that may be 32 bit integers on 32 bit platforms. ",
        "func_before": "static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}",
        "func": "static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )\n        MP4_READBOX_EXIT( 0 );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n {\n     MP4_READBOX_ENTER( MP4_Box_data_string_t );\n+\n+    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )\n+        MP4_READBOX_EXIT( 0 );\n \n     p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n     if( p_box->data.p_string->psz_text == NULL )",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )",
                "        MP4_READBOX_EXIT( 0 );"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-12453",
        "func_name": "redis/xgroupCommand",
        "description": "Type confusion in the xgroupCommand function in t_stream.c in redis-server in Redis before 5.0 allows remote attackers to cause denial-of-service via an XGROUP command in which the key is not a stream.",
        "git_url": "https://github.com/redis/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6",
        "commit_title": "Abort in XGROUP if the key is not a stream",
        "commit_text": "",
        "func_before": "void xgroupCommand(client *c) {\n    const char *help[] = {\n\"CREATE      <key> <groupname> <id or $>  -- Create a new consumer group.\",\n\"SETID       <key> <groupname> <id or $>  -- Set the current group ID.\",\n\"DELGROUP    <key> <groupname>            -- Remove the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer.\",\n\"HELP                                     -- Prints this help.\",\nNULL\n    };\n    stream *s = NULL;\n    sds grpname = NULL;\n    streamCG *cg = NULL;\n    char *opt = c->argv[1]->ptr; /* Subcommand name. */\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    if (c->argc >= 4) {\n        robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n        if (o == NULL) return;\n        s = o->ptr;\n        grpname = c->argv[3]->ptr;\n\n        /* Certain subcommands require the group to exist. */\n        if ((cg = streamLookupCG(s,grpname)) == NULL &&\n            (!strcasecmp(opt,\"SETID\") ||\n             !strcasecmp(opt,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)grpname, (char*)c->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CREATE\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);\n        if (cg) {\n            addReply(c,shared.ok);\n            server.dirty++;\n        } else {\n            addReplySds(c,\n                sdsnew(\"-BUSYGROUP Consumer Group name already exists\\r\\n\"));\n        }\n    } else if (!strcasecmp(opt,\"SETID\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        cg->last_id = id;\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(opt,\"DESTROY\") && c->argc == 4) {\n        if (cg) {\n            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);\n            streamFreeCG(cg);\n            addReply(c,shared.cone);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(opt,\"DELCONSUMER\") && c->argc == 5) {\n        /* Delete the consumer and returns the number of pending messages\n         * that were yet associated with such a consumer. */\n        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);\n        addReplyLongLong(c,pending);\n        server.dirty++;\n    } else if (!strcasecmp(opt,\"HELP\")) {\n        addReplyHelp(c, help);\n    } else {\n        addReply(c,shared.syntaxerr);\n    }\n}",
        "func": "void xgroupCommand(client *c) {\n    const char *help[] = {\n\"CREATE      <key> <groupname> <id or $>  -- Create a new consumer group.\",\n\"SETID       <key> <groupname> <id or $>  -- Set the current group ID.\",\n\"DELGROUP    <key> <groupname>            -- Remove the specified group.\",\n\"DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer.\",\n\"HELP                                     -- Prints this help.\",\nNULL\n    };\n    stream *s = NULL;\n    sds grpname = NULL;\n    streamCG *cg = NULL;\n    char *opt = c->argv[1]->ptr; /* Subcommand name. */\n\n    /* Lookup the key now, this is common for all the subcommands but HELP. */\n    if (c->argc >= 4) {\n        robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n        s = o->ptr;\n        grpname = c->argv[3]->ptr;\n\n        /* Certain subcommands require the group to exist. */\n        if ((cg = streamLookupCG(s,grpname)) == NULL &&\n            (!strcasecmp(opt,\"SETID\") ||\n             !strcasecmp(opt,\"DELCONSUMER\")))\n        {\n            addReplyErrorFormat(c, \"-NOGROUP No such consumer group '%s' \"\n                                   \"for key name '%s'\",\n                                   (char*)grpname, (char*)c->argv[2]->ptr);\n            return;\n        }\n    }\n\n    /* Dispatch the different subcommands. */\n    if (!strcasecmp(opt,\"CREATE\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);\n        if (cg) {\n            addReply(c,shared.ok);\n            server.dirty++;\n        } else {\n            addReplySds(c,\n                sdsnew(\"-BUSYGROUP Consumer Group name already exists\\r\\n\"));\n        }\n    } else if (!strcasecmp(opt,\"SETID\") && c->argc == 5) {\n        streamID id;\n        if (!strcmp(c->argv[4]->ptr,\"$\")) {\n            id = s->last_id;\n        } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {\n            return;\n        }\n        cg->last_id = id;\n        addReply(c,shared.ok);\n    } else if (!strcasecmp(opt,\"DESTROY\") && c->argc == 4) {\n        if (cg) {\n            raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);\n            streamFreeCG(cg);\n            addReply(c,shared.cone);\n        } else {\n            addReply(c,shared.czero);\n        }\n    } else if (!strcasecmp(opt,\"DELCONSUMER\") && c->argc == 5) {\n        /* Delete the consumer and returns the number of pending messages\n         * that were yet associated with such a consumer. */\n        long long pending = streamDelConsumer(cg,c->argv[4]->ptr);\n        addReplyLongLong(c,pending);\n        server.dirty++;\n    } else if (!strcasecmp(opt,\"HELP\")) {\n        addReplyHelp(c, help);\n    } else {\n        addReply(c,shared.syntaxerr);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     /* Lookup the key now, this is common for all the subcommands but HELP. */\n     if (c->argc >= 4) {\n         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);\n-        if (o == NULL) return;\n+        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;\n         s = o->ptr;\n         grpname = c->argv[3]->ptr;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        if (o == NULL) return;"
            ],
            "added_lines": [
                "        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;"
            ]
        }
    }
]