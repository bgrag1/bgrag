[
    {
        "cve_id": "CVE-2022-31135",
        "func_name": "AttorneyOnline/akashi/AOClient::pktRemoveEvidence",
        "description": "Akashi is an open source server implementation of the Attorney Online video game based on the Ace Attorney universe. Affected versions of Akashi are subject to a denial of service attack. An attacker can use a specially crafted evidence packet to make an illegal modification, causing a server crash. This can be used to mount a denial-of-service exploit. Users are advised to upgrade. There is no known workaround for this issue.",
        "git_url": "https://github.com/AttorneyOnline/akashi/commit/5566cdfedddef1f219aee33477d9c9690bf2f78b",
        "commit_title": "Fix out of bounds crash on evidence",
        "commit_text": "",
        "func_before": "void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}",
        "func": "void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n         return;\n     bool is_int = false;\n     int idx = argv[0].toInt(&is_int);\n-    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n+    if (is_int && idx < area->evidence().size() && idx >= 0) {\n         area->deleteEvidence(idx);\n     }\n     sendEvidenceList(area);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (is_int && idx <= area->evidence().size() && idx >= 0) {"
            ],
            "added_lines": [
                "    if (is_int && idx < area->evidence().size() && idx >= 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-31135",
        "func_name": "AttorneyOnline/akashi/AOClient::pktEditEvidence",
        "description": "Akashi is an open source server implementation of the Attorney Online video game based on the Ace Attorney universe. Affected versions of Akashi are subject to a denial of service attack. An attacker can use a specially crafted evidence packet to make an illegal modification, causing a server crash. This can be used to mount a denial-of-service exploit. Users are advised to upgrade. There is no known workaround for this issue.",
        "git_url": "https://github.com/AttorneyOnline/akashi/commit/5566cdfedddef1f219aee33477d9c9690bf2f78b",
        "commit_title": "Fix out of bounds crash on evidence",
        "commit_text": "",
        "func_before": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}",
        "func": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     bool is_int = false;\n     int idx = argv[0].toInt(&is_int);\n     AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n-    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n+    if (is_int && idx < area->evidence().size() && idx >= 0) {\n         area->replaceEvidence(idx, evi);\n     }\n     sendEvidenceList(area);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (is_int && idx <= area->evidence().size() && idx >= 0) {"
            ],
            "added_lines": [
                "    if (is_int && idx < area->evidence().size() && idx >= 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::insert_",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/47e589072c44350b0305c05066c224d1cbda992d",
        "commit_title": "[core] Fixed sender list to reallocate on insert",
        "commit_text": "if required",
        "func_before": "void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n   CSNode* n = u->m_pSNode;\n\n   // do not insert repeated node\n   if (n->m_iHeapLoc >= 0)\n      return;\n\n   m_iLastEntry ++;\n   m_pHeap[m_iLastEntry] = n;\n   n->m_llTimeStamp_tk = ts;\n\n   int q = m_iLastEntry;\n   int p = q;\n   while (p != 0)\n   {\n      p = (q - 1) >> 1;\n      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)\n      {\n         CSNode* t = m_pHeap[p];\n         m_pHeap[p] = m_pHeap[q];\n         m_pHeap[q] = t;\n         t->m_iHeapLoc = q;\n         q = p;\n      }\n      else\n         break;\n   }\n\n   n->m_iHeapLoc = q;\n\n   // an earlier event has been inserted, wake up sending worker\n   if (n->m_iHeapLoc == 0)\n      m_pTimer->interrupt();\n\n   // first entry, activate the sending queue\n   if (0 == m_iLastEntry)\n   {\n       pthread_mutex_lock(m_pWindowLock);\n       pthread_cond_signal(m_pWindowCond);\n       pthread_mutex_unlock(m_pWindowLock);\n   }\n}",
        "func": "void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n    // increase the heap array size if necessary\n    if (m_iLastEntry == m_iArrayLength - 1)\n        realloc_();\n\n    insert_norealloc(ts, u);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,43 +1,8 @@\n void CSndUList::insert_(int64_t ts, const CUDT* u)\n {\n-   CSNode* n = u->m_pSNode;\n+    // increase the heap array size if necessary\n+    if (m_iLastEntry == m_iArrayLength - 1)\n+        realloc_();\n \n-   // do not insert repeated node\n-   if (n->m_iHeapLoc >= 0)\n-      return;\n-\n-   m_iLastEntry ++;\n-   m_pHeap[m_iLastEntry] = n;\n-   n->m_llTimeStamp_tk = ts;\n-\n-   int q = m_iLastEntry;\n-   int p = q;\n-   while (p != 0)\n-   {\n-      p = (q - 1) >> 1;\n-      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)\n-      {\n-         CSNode* t = m_pHeap[p];\n-         m_pHeap[p] = m_pHeap[q];\n-         m_pHeap[q] = t;\n-         t->m_iHeapLoc = q;\n-         q = p;\n-      }\n-      else\n-         break;\n-   }\n-\n-   n->m_iHeapLoc = q;\n-\n-   // an earlier event has been inserted, wake up sending worker\n-   if (n->m_iHeapLoc == 0)\n-      m_pTimer->interrupt();\n-\n-   // first entry, activate the sending queue\n-   if (0 == m_iLastEntry)\n-   {\n-       pthread_mutex_lock(m_pWindowLock);\n-       pthread_cond_signal(m_pWindowCond);\n-       pthread_mutex_unlock(m_pWindowLock);\n-   }\n+    insert_norealloc(ts, u);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "   CSNode* n = u->m_pSNode;",
                "   // do not insert repeated node",
                "   if (n->m_iHeapLoc >= 0)",
                "      return;",
                "",
                "   m_iLastEntry ++;",
                "   m_pHeap[m_iLastEntry] = n;",
                "   n->m_llTimeStamp_tk = ts;",
                "",
                "   int q = m_iLastEntry;",
                "   int p = q;",
                "   while (p != 0)",
                "   {",
                "      p = (q - 1) >> 1;",
                "      if (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[q]->m_llTimeStamp_tk)",
                "      {",
                "         CSNode* t = m_pHeap[p];",
                "         m_pHeap[p] = m_pHeap[q];",
                "         m_pHeap[q] = t;",
                "         t->m_iHeapLoc = q;",
                "         q = p;",
                "      }",
                "      else",
                "         break;",
                "   }",
                "",
                "   n->m_iHeapLoc = q;",
                "",
                "   // an earlier event has been inserted, wake up sending worker",
                "   if (n->m_iHeapLoc == 0)",
                "      m_pTimer->interrupt();",
                "",
                "   // first entry, activate the sending queue",
                "   if (0 == m_iLastEntry)",
                "   {",
                "       pthread_mutex_lock(m_pWindowLock);",
                "       pthread_cond_signal(m_pWindowCond);",
                "       pthread_mutex_unlock(m_pWindowLock);",
                "   }"
            ],
            "added_lines": [
                "    // increase the heap array size if necessary",
                "    if (m_iLastEntry == m_iArrayLength - 1)",
                "        realloc_();",
                "    insert_norealloc(ts, u);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::update",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/47e589072c44350b0305c05066c224d1cbda992d",
        "commit_title": "[core] Fixed sender list to reallocate on insert",
        "commit_text": "if required",
        "func_before": "void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n   }\n\n   insert_(1, u);\n}",
        "func": "void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n      insert_norealloc(1, u);\n      return;\n   }\n\n   insert_(1, u);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n       }\n \n       remove_(u);\n+      insert_norealloc(1, u);\n+      return;\n    }\n \n    insert_(1, u);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      insert_norealloc(1, u);",
                "      return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::pop",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/47e589072c44350b0305c05066c224d1cbda992d",
        "commit_title": "[core] Fixed sender list to reallocate on insert",
        "commit_text": "if required",
        "func_before": "int CSndUList::pop(sockaddr*& addr, CPacket& pkt)\n{\n   CGuard listguard(m_ListLock);\n\n   if (-1 == m_iLastEntry)\n      return -1;\n\n   // no pop until the next schedulled time\n   uint64_t ts;\n   CTimer::rdtsc(ts);\n   if (ts < m_pHeap[0]->m_llTimeStamp_tk)\n      return -1;\n\n   CUDT* u = m_pHeap[0]->m_pUDT;\n   remove_(u);\n\n#define UST(field) ( (u->m_b##field) ? \"+\" : \"-\" ) << #field << \" \"\n\n   HLOGC(mglog.Debug, log << \"SND:pop: requesting packet from @\" << u->socketID()\n           << \" STATUS: \"\n           << UST(Listening)\n           << UST(Connecting)\n           << UST(Connected)\n           << UST(Closing)\n           << UST(Shutdown)\n           << UST(Broken)\n           << UST(PeerHealth)\n           << UST(Opened)\n        );\n#undef UST\n\n   if (!u->m_bConnected || u->m_bBroken)\n      return -1;\n\n   // pack a packet from the socket\n   if (u->packData(pkt, ts) <= 0)\n      return -1;\n\n   addr = u->m_pPeerAddr;\n\n   // insert a new entry, ts is the next processing time\n   if (ts > 0)\n      insert_(ts, u);\n\n   return 1;\n}",
        "func": "int CSndUList::pop(sockaddr*& addr, CPacket& pkt)\n{\n   CGuard listguard(m_ListLock);\n\n   if (-1 == m_iLastEntry)\n      return -1;\n\n   // no pop until the next schedulled time\n   uint64_t ts;\n   CTimer::rdtsc(ts);\n   if (ts < m_pHeap[0]->m_llTimeStamp_tk)\n      return -1;\n\n   CUDT* u = m_pHeap[0]->m_pUDT;\n   remove_(u);\n\n#define UST(field) ( (u->m_b##field) ? \"+\" : \"-\" ) << #field << \" \"\n\n   HLOGC(mglog.Debug, log << \"SND:pop: requesting packet from @\" << u->socketID()\n           << \" STATUS: \"\n           << UST(Listening)\n           << UST(Connecting)\n           << UST(Connected)\n           << UST(Closing)\n           << UST(Shutdown)\n           << UST(Broken)\n           << UST(PeerHealth)\n           << UST(Opened)\n        );\n#undef UST\n\n   if (!u->m_bConnected || u->m_bBroken)\n      return -1;\n\n   // pack a packet from the socket\n   if (u->packData(pkt, ts) <= 0)\n      return -1;\n\n   addr = u->m_pPeerAddr;\n\n   // insert a new entry, ts is the next processing time\n   if (ts > 0)\n      insert_norealloc(ts, u);\n\n   return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,7 @@\n \n    // insert a new entry, ts is the next processing time\n    if (ts > 0)\n-      insert_(ts, u);\n+      insert_norealloc(ts, u);\n \n    return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      insert_(ts, u);"
            ],
            "added_lines": [
                "      insert_norealloc(ts, u);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::CSndUList",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de",
        "commit_title": "[core] CSndUList initial size is reduced to 512 elements",
        "commit_text": "",
        "func_before": "CSndUList::CSndUList():\n    m_pHeap(NULL),\n    m_iArrayLength(4096),\n    m_iLastEntry(-1),\n    m_ListLock(),\n    m_pWindowLock(NULL),\n    m_pWindowCond(NULL),\n    m_pTimer(NULL)\n{\n    m_pHeap = new CSNode*[m_iArrayLength];\n    pthread_mutex_init(&m_ListLock, NULL);\n}",
        "func": "CSndUList::CSndUList():\n    m_pHeap(NULL),\n    m_iArrayLength(512),\n    m_iLastEntry(-1),\n    m_ListLock(),\n    m_pWindowLock(NULL),\n    m_pWindowCond(NULL),\n    m_pTimer(NULL)\n{\n    m_pHeap = new CSNode*[m_iArrayLength];\n    pthread_mutex_init(&m_ListLock, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n CSndUList::CSndUList():\n     m_pHeap(NULL),\n-    m_iArrayLength(4096),\n+    m_iArrayLength(512),\n     m_iLastEntry(-1),\n     m_ListLock(),\n     m_pWindowLock(NULL),",
        "diff_line_info": {
            "deleted_lines": [
                "    m_iArrayLength(4096),"
            ],
            "added_lines": [
                "    m_iArrayLength(512),"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::realloc_",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de",
        "commit_title": "[core] CSndUList initial size is reduced to 512 elements",
        "commit_text": "",
        "func_before": "void CSndUList::realloc_()\n{\n   CSNode** temp = NULL;\n\n   try\n   {\n       temp = new CSNode * [m_iArrayLength * 2];\n   }\n   catch (...)\n   {\n       return;\n   }\n\n   memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);\n   m_iArrayLength *= 2;\n   delete[] m_pHeap;\n   m_pHeap = temp;\n}",
        "func": "void CSndUList::realloc_()\n{\n   CSNode** temp = NULL;\n\n   try\n   {\n       temp = new CSNode *[2 * m_iArrayLength];\n   }\n   catch (...)\n   {\n       throw CUDTException(MJ_SYSTEMRES, MN_MEMORY, 0);\n   }\n\n   memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);\n   m_iArrayLength *= 2;\n   delete[] m_pHeap;\n   m_pHeap = temp;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,11 +4,11 @@\n \n    try\n    {\n-       temp = new CSNode * [m_iArrayLength * 2];\n+       temp = new CSNode *[2 * m_iArrayLength];\n    }\n    catch (...)\n    {\n-       return;\n+       throw CUDTException(MJ_SYSTEMRES, MN_MEMORY, 0);\n    }\n \n    memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);",
        "diff_line_info": {
            "deleted_lines": [
                "       temp = new CSNode * [m_iArrayLength * 2];",
                "       return;"
            ],
            "added_lines": [
                "       temp = new CSNode *[2 * m_iArrayLength];",
                "       throw CUDTException(MJ_SYSTEMRES, MN_MEMORY, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::insert_",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de",
        "commit_title": "[core] CSndUList initial size is reduced to 512 elements",
        "commit_text": "",
        "func_before": "void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n    // increase the heap array size if necessary\n    if (m_iLastEntry == m_iArrayLength - 1)\n        realloc_();\n\n    insert_norealloc(ts, u);\n}",
        "func": "void CSndUList::insert_(int64_t ts, const CUDT* u)\n{\n    // increase the heap array size if necessary\n    if (m_iLastEntry == m_iArrayLength - 1)\n        realloc_();\n\n    insert_norealloc_(ts, u);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,5 @@\n     if (m_iLastEntry == m_iArrayLength - 1)\n         realloc_();\n \n-    insert_norealloc(ts, u);\n+    insert_norealloc_(ts, u);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    insert_norealloc(ts, u);"
            ],
            "added_lines": [
                "    insert_norealloc_(ts, u);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::remove_",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de",
        "commit_title": "[core] CSndUList initial size is reduced to 512 elements",
        "commit_text": "",
        "func_before": "void CSndUList::remove_(const CUDT* u)\n{\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      // remove the node from heap\n      m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];\n      m_iLastEntry --;\n      m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;\n\n      int q = n->m_iHeapLoc;\n      int p = q * 2 + 1;\n      while (p <= m_iLastEntry)\n      {\n         if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[p + 1]->m_llTimeStamp_tk))\n            p ++;\n\n         if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)\n         {\n            CSNode* t = m_pHeap[p];\n            m_pHeap[p] = m_pHeap[q];\n            m_pHeap[p]->m_iHeapLoc = p;\n            m_pHeap[q] = t;\n            m_pHeap[q]->m_iHeapLoc = q;\n\n            q = p;\n            p = q * 2 + 1;\n         }\n         else\n            break;\n      }\n\n      n->m_iHeapLoc = -1;\n   }\n\n   // the only event has been deleted, wake up immediately\n   if (0 == m_iLastEntry)\n      m_pTimer->interrupt();\n}",
        "func": "void CSndUList::remove_(const CUDT* u)\n{\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      // remove the node from heap\n      m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];\n      m_iLastEntry --;\n      m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;\n\n      int q = n->m_iHeapLoc;\n      int p = q * 2 + 1;\n      while (p <= m_iLastEntry)\n      {\n         if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp_tk > m_pHeap[p + 1]->m_llTimeStamp_tk))\n            p ++;\n\n         if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)\n         {\n            swap(m_pHeap[p], m_pHeap[q]);\n            m_pHeap[p]->m_iHeapLoc = p;\n            m_pHeap[q]->m_iHeapLoc = q;\n\n            q = p;\n            p = q * 2 + 1;\n         }\n         else\n            break;\n      }\n\n      n->m_iHeapLoc = -1;\n   }\n\n   // the only event has been deleted, wake up immediately\n   if (0 == m_iLastEntry)\n      m_pTimer->interrupt();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,10 +18,8 @@\n \n          if (m_pHeap[q]->m_llTimeStamp_tk > m_pHeap[p]->m_llTimeStamp_tk)\n          {\n-            CSNode* t = m_pHeap[p];\n-            m_pHeap[p] = m_pHeap[q];\n+            swap(m_pHeap[p], m_pHeap[q]);\n             m_pHeap[p]->m_iHeapLoc = p;\n-            m_pHeap[q] = t;\n             m_pHeap[q]->m_iHeapLoc = q;\n \n             q = p;",
        "diff_line_info": {
            "deleted_lines": [
                "            CSNode* t = m_pHeap[p];",
                "            m_pHeap[p] = m_pHeap[q];",
                "            m_pHeap[q] = t;"
            ],
            "added_lines": [
                "            swap(m_pHeap[p], m_pHeap[q]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::update",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de",
        "commit_title": "[core] CSndUList initial size is reduced to 512 elements",
        "commit_text": "",
        "func_before": "void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n      insert_norealloc(1, u);\n      return;\n   }\n\n   insert_(1, u);\n}",
        "func": "void CSndUList::update(const CUDT* u, EReschedule reschedule)\n{\n   CGuard listguard(m_ListLock);\n\n   CSNode* n = u->m_pSNode;\n\n   if (n->m_iHeapLoc >= 0)\n   {\n      if (!reschedule) // EReschedule to bool conversion, predicted.\n         return;\n\n      if (n->m_iHeapLoc == 0)\n      {\n         n->m_llTimeStamp_tk = 1;\n         m_pTimer->interrupt();\n         return;\n      }\n\n      remove_(u);\n      insert_norealloc_(1, u);\n      return;\n   }\n\n   insert_(1, u);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n       }\n \n       remove_(u);\n-      insert_norealloc(1, u);\n+      insert_norealloc_(1, u);\n       return;\n    }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      insert_norealloc(1, u);"
            ],
            "added_lines": [
                "      insert_norealloc_(1, u);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15784",
        "func_name": "Haivision/srt/CSndUList::pop",
        "description": "Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.",
        "git_url": "https://github.com/Haivision/srt/commit/64875fa98ff6afd2f21a9727970fb4333efe95de",
        "commit_title": "[core] CSndUList initial size is reduced to 512 elements",
        "commit_text": "",
        "func_before": "int CSndUList::pop(sockaddr*& addr, CPacket& pkt)\n{\n   CGuard listguard(m_ListLock);\n\n   if (-1 == m_iLastEntry)\n      return -1;\n\n   // no pop until the next schedulled time\n   uint64_t ts;\n   CTimer::rdtsc(ts);\n   if (ts < m_pHeap[0]->m_llTimeStamp_tk)\n      return -1;\n\n   CUDT* u = m_pHeap[0]->m_pUDT;\n   remove_(u);\n\n#define UST(field) ( (u->m_b##field) ? \"+\" : \"-\" ) << #field << \" \"\n\n   HLOGC(mglog.Debug, log << \"SND:pop: requesting packet from @\" << u->socketID()\n           << \" STATUS: \"\n           << UST(Listening)\n           << UST(Connecting)\n           << UST(Connected)\n           << UST(Closing)\n           << UST(Shutdown)\n           << UST(Broken)\n           << UST(PeerHealth)\n           << UST(Opened)\n        );\n#undef UST\n\n   if (!u->m_bConnected || u->m_bBroken)\n      return -1;\n\n   // pack a packet from the socket\n   if (u->packData(pkt, ts) <= 0)\n      return -1;\n\n   addr = u->m_pPeerAddr;\n\n   // insert a new entry, ts is the next processing time\n   if (ts > 0)\n      insert_norealloc(ts, u);\n\n   return 1;\n}",
        "func": "int CSndUList::pop(sockaddr*& addr, CPacket& pkt)\n{\n   CGuard listguard(m_ListLock);\n\n   if (-1 == m_iLastEntry)\n      return -1;\n\n   // no pop until the next schedulled time\n   uint64_t ts;\n   CTimer::rdtsc(ts);\n   if (ts < m_pHeap[0]->m_llTimeStamp_tk)\n      return -1;\n\n   CUDT* u = m_pHeap[0]->m_pUDT;\n   remove_(u);\n\n#define UST(field) ( (u->m_b##field) ? \"+\" : \"-\" ) << #field << \" \"\n\n   HLOGC(mglog.Debug, log << \"SND:pop: requesting packet from @\" << u->socketID()\n           << \" STATUS: \"\n           << UST(Listening)\n           << UST(Connecting)\n           << UST(Connected)\n           << UST(Closing)\n           << UST(Shutdown)\n           << UST(Broken)\n           << UST(PeerHealth)\n           << UST(Opened)\n        );\n#undef UST\n\n   if (!u->m_bConnected || u->m_bBroken)\n      return -1;\n\n   // pack a packet from the socket\n   if (u->packData(pkt, ts) <= 0)\n      return -1;\n\n   addr = u->m_pPeerAddr;\n\n   // insert a new entry, ts is the next processing time\n   if (ts > 0)\n      insert_norealloc_(ts, u);\n\n   return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,7 @@\n \n    // insert a new entry, ts is the next processing time\n    if (ts > 0)\n-      insert_norealloc(ts, u);\n+      insert_norealloc_(ts, u);\n \n    return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      insert_norealloc(ts, u);"
            ],
            "added_lines": [
                "      insert_norealloc_(ts, u);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1000016",
        "func_name": "ffmpeg/cbs_av1_read_uvlc",
        "description": "FFMPEG version 4.1 contains a CWE-129: Improper Validation of Array Index vulnerability in libavcodec/cbs_av1.c that can result in Denial of service. This attack appears to be exploitable via specially crafted AV1 file has to be provided as input. This vulnerability appears to have been fixed in after commit b97a4b658814b2de8b9f2a3bce491c002d34de31.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/b97a4b658814b2de8b9f2a3bce491c002d34de31",
        "commit_title": "cbs_av1: Fix reading of overlong uvlc codes",
        "commit_text": " The specification allows 2^32-1 to be encoded as any number of zeroes greater than 31, followed by a one.  This previously failed because the trace code would overflow the array containing the string representation of the bits if there were more than 63 zeroes.  Fix that by splitting the trace output into batches, and at the same time move it out of the default path.  (While this seems likely to be a specification error, libaom does support it so we probably should as well.)  From a test case by keval shah <skeval65@gmail.com>. ",
        "func_before": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n\n        value += (1 << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;\n    return 0;\n}",
        "func": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t zeroes, bits_value, value;\n    int position;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = 0;\n    while (1) {\n        if (get_bits_left(gbc) < 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc))\n            break;\n        ++zeroes;\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        if (get_bits_left(gbc) < zeroes) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        bits_value = get_bits_long(gbc, zeroes);\n        value = bits_value + (UINT32_C(1) << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[65];\n        int i, j, k;\n\n        if (zeroes >= 32) {\n            while (zeroes > 32) {\n                k = FFMIN(zeroes - 32, 32);\n                for (i = 0; i < k; i++)\n                    bits[i] = '0';\n                bits[i] = 0;\n                ff_cbs_trace_syntax_element(ctx, position, name,\n                                            NULL, bits, 0);\n                zeroes -= k;\n                position += k;\n            }\n        }\n\n        for (i = 0; i < zeroes; i++)\n            bits[i] = '0';\n        bits[i++] = '1';\n\n        if (zeroes < 32) {\n            for (j = 0; j < zeroes; j++)\n                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        }\n\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name,\n                                    NULL, bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,45 +2,67 @@\n                              const char *name, uint32_t *write_to,\n                              uint32_t range_min, uint32_t range_max)\n {\n-    uint32_t value;\n-    int position, zeroes, i, j;\n-    char bits[65];\n+    uint32_t zeroes, bits_value, value;\n+    int position;\n \n     if (ctx->trace_enable)\n         position = get_bits_count(gbc);\n \n-    zeroes = i = 0;\n+    zeroes = 0;\n     while (1) {\n-        if (get_bits_left(gbc) < zeroes + 1) {\n+        if (get_bits_left(gbc) < 1) {\n             av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                    \"%s: bitstream ended.\\n\", name);\n             return AVERROR_INVALIDDATA;\n         }\n \n-        if (get_bits1(gbc)) {\n-            bits[i++] = '1';\n+        if (get_bits1(gbc))\n             break;\n-        } else {\n-            bits[i++] = '0';\n-            ++zeroes;\n-        }\n+        ++zeroes;\n     }\n \n     if (zeroes >= 32) {\n         value = MAX_UINT_BITS(32);\n     } else {\n-        value = get_bits_long(gbc, zeroes);\n+        if (get_bits_left(gbc) < zeroes) {\n+            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n+                   \"%s: bitstream ended.\\n\", name);\n+            return AVERROR_INVALIDDATA;\n+        }\n \n-        for (j = 0; j < zeroes; j++)\n-            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n-\n-        value += (1 << zeroes) - 1;\n+        bits_value = get_bits_long(gbc, zeroes);\n+        value = bits_value + (UINT32_C(1) << zeroes) - 1;\n     }\n \n     if (ctx->trace_enable) {\n+        char bits[65];\n+        int i, j, k;\n+\n+        if (zeroes >= 32) {\n+            while (zeroes > 32) {\n+                k = FFMIN(zeroes - 32, 32);\n+                for (i = 0; i < k; i++)\n+                    bits[i] = '0';\n+                bits[i] = 0;\n+                ff_cbs_trace_syntax_element(ctx, position, name,\n+                                            NULL, bits, 0);\n+                zeroes -= k;\n+                position += k;\n+            }\n+        }\n+\n+        for (i = 0; i < zeroes; i++)\n+            bits[i] = '0';\n+        bits[i++] = '1';\n+\n+        if (zeroes < 32) {\n+            for (j = 0; j < zeroes; j++)\n+                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';\n+        }\n+\n         bits[i] = 0;\n-        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n-                                    bits, value);\n+        ff_cbs_trace_syntax_element(ctx, position, name,\n+                                    NULL, bits, value);\n     }\n \n     if (value < range_min || value > range_max) {",
        "diff_line_info": {
            "deleted_lines": [
                "    uint32_t value;",
                "    int position, zeroes, i, j;",
                "    char bits[65];",
                "    zeroes = i = 0;",
                "        if (get_bits_left(gbc) < zeroes + 1) {",
                "        if (get_bits1(gbc)) {",
                "            bits[i++] = '1';",
                "        } else {",
                "            bits[i++] = '0';",
                "            ++zeroes;",
                "        }",
                "        value = get_bits_long(gbc, zeroes);",
                "        for (j = 0; j < zeroes; j++)",
                "            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';",
                "",
                "        value += (1 << zeroes) - 1;",
                "        ff_cbs_trace_syntax_element(ctx, position, name, NULL,",
                "                                    bits, value);"
            ],
            "added_lines": [
                "    uint32_t zeroes, bits_value, value;",
                "    int position;",
                "    zeroes = 0;",
                "        if (get_bits_left(gbc) < 1) {",
                "        if (get_bits1(gbc))",
                "        ++zeroes;",
                "        if (get_bits_left(gbc) < zeroes) {",
                "            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"",
                "                   \"%s: bitstream ended.\\n\", name);",
                "            return AVERROR_INVALIDDATA;",
                "        }",
                "        bits_value = get_bits_long(gbc, zeroes);",
                "        value = bits_value + (UINT32_C(1) << zeroes) - 1;",
                "        char bits[65];",
                "        int i, j, k;",
                "",
                "        if (zeroes >= 32) {",
                "            while (zeroes > 32) {",
                "                k = FFMIN(zeroes - 32, 32);",
                "                for (i = 0; i < k; i++)",
                "                    bits[i] = '0';",
                "                bits[i] = 0;",
                "                ff_cbs_trace_syntax_element(ctx, position, name,",
                "                                            NULL, bits, 0);",
                "                zeroes -= k;",
                "                position += k;",
                "            }",
                "        }",
                "",
                "        for (i = 0; i < zeroes; i++)",
                "            bits[i] = '0';",
                "        bits[i++] = '1';",
                "",
                "        if (zeroes < 32) {",
                "            for (j = 0; j < zeroes; j++)",
                "                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';",
                "        }",
                "",
                "        ff_cbs_trace_syntax_element(ctx, position, name,",
                "                                    NULL, bits, value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-27223",
        "func_name": "torvalds/linux/xudc_getstatus",
        "description": "In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access.",
        "git_url": "https://github.com/torvalds/linux/commit/7f14c7227f342d9932f9b918893c8814f86d2a0d",
        "commit_title": "USB: gadget: validate endpoint index for xilinx udc",
        "commit_text": " Assure that host may not manipulate the index to point past endpoint array.  Cc: stable <stable@kernel.org>",
        "func_before": "static void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\t/* Get device status */\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}",
        "func": "static void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\t/* Get device status */\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,8 @@\n \t\tbreak;\n \tcase USB_RECIP_ENDPOINT:\n \t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n+\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n+\t\t\tgoto stall;\n \t\ttarget_ep = &udc->ep[epnum];\n \t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n \t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (epnum >= XUSB_MAX_ENDPOINTS)",
                "\t\t\tgoto stall;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-27223",
        "func_name": "torvalds/linux/xudc_set_clear_feature",
        "description": "In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access.",
        "git_url": "https://github.com/torvalds/linux/commit/7f14c7227f342d9932f9b918893c8814f86d2a0d",
        "commit_title": "USB: gadget: validate endpoint index for xilinx udc",
        "commit_text": " Assure that host may not manipulate the index to point past endpoint array.  Cc: stable <stable@kernel.org>",
        "func_before": "static void xudc_set_clear_feature(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu8 endpoint;\n\tu8 outinbit;\n\tu32 epcfgreg;\n\tint flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0);\n\tint ret;\n\n\tswitch (udc->setup.bRequestType) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (udc->setup.wValue) {\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t/*\n\t\t\t * The Test Mode will be executed\n\t\t\t * after the status phase.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tif (flag)\n\t\t\t\tudc->remote_wkp = 1;\n\t\t\telse\n\t\t\t\tudc->remote_wkp = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txudc_ep0_stall(udc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (!udc->setup.wValue) {\n\t\t\tendpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\ttarget_ep = &udc->ep[endpoint];\n\t\t\toutinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK;\n\t\t\toutinbit = outinbit >> 7;\n\n\t\t\t/* Make sure direction matches.*/\n\t\t\tif (outinbit != target_ep->is_in) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\t\tif (!endpoint) {\n\t\t\t\t/* Clear the stall.*/\n\t\t\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t      target_ep->offset, epcfgreg);\n\t\t\t} else {\n\t\t\t\tif (flag) {\n\t\t\t\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t} else {\n\t\t\t\t\t/* Unstall the endpoint.*/\n\t\t\t\t\tepcfgreg &= ~(XUSB_EP_CFG_STALL_MASK |\n\t\t\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK);\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\txudc_ep0_stall(udc);\n\t\treturn;\n\t}\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"Can't respond to SET/CLEAR FEATURE\\n\");\n\txudc_ep0_stall(udc);\n}",
        "func": "static void xudc_set_clear_feature(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu8 endpoint;\n\tu8 outinbit;\n\tu32 epcfgreg;\n\tint flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0);\n\tint ret;\n\n\tswitch (udc->setup.bRequestType) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (udc->setup.wValue) {\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t/*\n\t\t\t * The Test Mode will be executed\n\t\t\t * after the status phase.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tif (flag)\n\t\t\t\tudc->remote_wkp = 1;\n\t\t\telse\n\t\t\t\tudc->remote_wkp = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txudc_ep0_stall(udc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (!udc->setup.wValue) {\n\t\t\tendpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\tif (endpoint >= XUSB_MAX_ENDPOINTS) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget_ep = &udc->ep[endpoint];\n\t\t\toutinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK;\n\t\t\toutinbit = outinbit >> 7;\n\n\t\t\t/* Make sure direction matches.*/\n\t\t\tif (outinbit != target_ep->is_in) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\t\tif (!endpoint) {\n\t\t\t\t/* Clear the stall.*/\n\t\t\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t      target_ep->offset, epcfgreg);\n\t\t\t} else {\n\t\t\t\tif (flag) {\n\t\t\t\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t} else {\n\t\t\t\t\t/* Unstall the endpoint.*/\n\t\t\t\t\tepcfgreg &= ~(XUSB_EP_CFG_STALL_MASK |\n\t\t\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK);\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\txudc_ep0_stall(udc);\n\t\treturn;\n\t}\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"Can't respond to SET/CLEAR FEATURE\\n\");\n\txudc_ep0_stall(udc);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,6 +32,10 @@\n \tcase USB_RECIP_ENDPOINT:\n \t\tif (!udc->setup.wValue) {\n \t\t\tendpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n+\t\t\tif (endpoint >= XUSB_MAX_ENDPOINTS) {\n+\t\t\t\txudc_ep0_stall(udc);\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t\ttarget_ep = &udc->ep[endpoint];\n \t\t\toutinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK;\n \t\t\toutinbit = outinbit >> 7;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif (endpoint >= XUSB_MAX_ENDPOINTS) {",
                "\t\t\t\txudc_ep0_stall(udc);",
                "\t\t\t\treturn;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1237",
        "func_name": "radareorg/radare2/r_bin_ne_get_relocs",
        "description": "Improper Validation of Array Index in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).",
        "git_url": "https://github.com/radareorg/radare2/commit/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6",
        "commit_title": "Fix oobread segfaults in the NE bin parser ##crash",
        "commit_text": " * Reported by @han0nly via huntr.dev * Reproducers: seed1 seed2 * BountyID: ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40",
        "func_before": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off, start = off = seg->paddr + seg->size;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tNE_image_reloc_item rel;\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\t\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}",
        "func": "RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {\n\tRList *segments = bin->segments;\n\tif (!segments) {\n\t\treturn NULL;\n\t}\n\tRList *entries = bin->entries;\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRList *symbols = bin->symbols;\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\n\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n\tif (!modref) {\n\t\treturn NULL;\n\t}\n\tr_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));\n\n\tRList *relocs = r_list_newf (free);\n\tif (!relocs) {\n\t\tfree (modref);\n\t\treturn NULL;\n\t}\n\n\tRListIter *it;\n\tRBinSection *seg;\n\tint index = -1;\n\tr_list_foreach (segments, it, seg) {\n\t\tindex++;\n\t\tif (!(bin->segment_entries[index].flags & RELOCINFO)) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 off, start = off = seg->paddr + seg->size;\n\t\tut16 length = r_buf_read_le16_at (bin->buf, off);\n\t\tif (!length) {\n\t\t\tcontinue;\n\t\t}\n\t\toff += 2;\n\t\tsize_t buf_size = r_buf_size (bin->buf);\n\t\twhile (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {\n\t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tNE_image_reloc_item rel;\n\t\t\tr_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));\n\t\t\treloc->paddr = seg->paddr + rel.offset;\n\t\t\tswitch (rel.type) {\n\t\t\tcase LOBYTE:\n\t\t\t\treloc->type = R_BIN_RELOC_8;\n\t\t\t\tbreak;\n\t\t\tcase SEL_16:\n\t\t\tcase OFF_16:\n\t\t\t\treloc->type = R_BIN_RELOC_16;\n\t\t\t\tbreak;\n\t\t\tcase POI_32:\n\t\t\tcase OFF_32:\n\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\tbreak;\n\t\t\tcase POI_48:\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tut32 offset;\n\t\t\tif (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\tif (!imp) {\n\t\t\t\t\tfree (reloc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar *name;\n\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {\n\t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n\t\t\t\t} else {\n\t\t\t\t\tint index = rel.index;\n\t\t\t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n\t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t}\n\t\t\t\tif (rel.flags & IMPORTED_ORD) {\n\t\t\t\t\timp->ordinal = rel.func_ord;\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));\n\t\t\t\t} else {\n\t\t\t\t\toffset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;\n\t\t\t\t\tchar *func = __read_nonnull_str_at (bin->buf, offset);\n\t\t\t\t\timp->name = r_str_newf (\"%s.%s\", name, func);\n\t\t\t\t\tfree (func);\n\t\t\t\t}\n\t\t\t\tfree (name);\n\t\t\t\treloc->import = imp;\n\t\t\t} else if (rel.flags & OSFIXUP) {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\tif (strstr (seg->name, \"FIXED\")) {\n\t\t\t\t\tRBinSection *s = r_list_get_n (segments, rel.segnum - 1);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\toffset = s->paddr + rel.segoff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\toffset = entry->paddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treloc->addend = offset;\n\t\t\t\tRBinSymbol *sym = NULL;\n\t\t\t\tRListIter *sit;\n\t\t\t\tr_list_foreach (symbols, sit, sym) {\n\t\t\t\t\tif (sym->paddr == reloc->addend) {\n\t\t\t\t\t\treloc->symbol = sym;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rel.flags & ADDITIVE) {\n\t\t\t\treloc->additive = 1;\n\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tr_list_append (relocs, reloc);\n\t\t\t\t\t\n\t\t\t\t\toffset = r_buf_read_le16_at (bin->buf, reloc->paddr);\n\t\t\t\t\tRBinReloc *tmp = reloc;\n\t\t\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*reloc = *tmp;\n\t\t\t\t\treloc->paddr = seg->paddr + offset;\n\t\t\t\t} while (offset != 0xFFFF);\n\t\t\t\tfree (reloc);\n\t\t\t}\n\n\t\t\toff += sizeof (NE_image_reloc_item);\n\t\t}\n\t}\n\tfree (modref);\n\treturn relocs;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \t\treturn NULL;\n \t}\n \n-\tut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));\n+\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));\n \tif (!modref) {\n \t\treturn NULL;\n \t}\n@@ -38,7 +38,8 @@\n \t\t\tcontinue;\n \t\t}\n \t\toff += 2;\n-\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {\n+\t\tsize_t buf_size = r_buf_size (bin->buf);\n+\t\twhile (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {\n \t\t\tRBinReloc *reloc = R_NEW0 (RBinReloc);\n \t\t\tif (!reloc) {\n \t\t\t\treturn NULL;\n@@ -71,10 +72,11 @@\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tchar *name;\n-\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {\n+\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {\n \t\t\t\t\tname = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????\n \t\t\t\t} else {\n-\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n+\t\t\t\t\tint index = rel.index;\n+\t\t\t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;\n \t\t\t\t\tname = __read_nonnull_str_at (bin->buf, offset);\n \t\t\t\t}\n \t\t\t\tif (rel.flags & IMPORTED_ORD) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));",
                "\t\twhile (off < start + length * sizeof (NE_image_reloc_item)) {",
                "\t\t\t\tif (rel.index > bin->ne_header->ModRefs) {",
                "\t\t\t\t\toffset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;"
            ],
            "added_lines": [
                "\tut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));",
                "\t\tsize_t buf_size = r_buf_size (bin->buf);",
                "\t\twhile (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {",
                "\t\t\t\tif (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {",
                "\t\t\t\t\tint index = rel.index;",
                "\t\t\t\t\toffset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1237",
        "func_name": "radareorg/radare2/r_bin_ne_get_segments",
        "description": "Improper Validation of Array Index in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).",
        "git_url": "https://github.com/radareorg/radare2/commit/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6",
        "commit_title": "Fix oobread segfaults in the NE bin parser ##crash",
        "commit_text": " * Reported by @han0nly via huntr.dev * Reproducers: seed1 seed2 * BountyID: ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40",
        "func_before": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}",
        "func": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,10 +6,10 @@\n \tRList *segments = r_list_newf (free);\n \tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n \t\tRBinSection *bs = R_NEW0 (RBinSection);\n-\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n \t\tif (!bs) {\n \t\t\treturn segments;\n \t\t}\n+\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n \t\tbs->size = se->length;\n \t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n \t\tbs->bits = R_SYS_BITS_16;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tNE_image_segment_entry *se = &bin->segment_entries[i];"
            ],
            "added_lines": [
                "\t\tNE_image_segment_entry *se = &bin->segment_entries[i];"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7170",
        "func_name": "qemu/vmsvga_fifo_run",
        "description": "The vmsvga_fifo_run function in hw/display/vmware_vga.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) via vectors related to cursor.mask[] and cursor.image[] array sizes when processing a DEFINE_CURSOR svga command.",
        "git_url": "https://github.com/qemu/qemu/commit/167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "commit_title": "vmsvga: correct bitmap and pixmap size checks",
        "commit_text": " When processing svga command DEFINE_CURSOR in vmsvga_fifo_run, the computed BITMAP and PIXMAP size are checked against the 'cursor.mask[]' and 'cursor.image[]' array sizes in bytes. Correct these checks to avoid OOB memory access. ",
        "func_before": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\n    uint32_t cmd, colour;\n    int args, len, maxloop = 1024;\n    int x, y, dx, dy, width, height;\n    struct vmsvga_cursor_definition_s cursor;\n    uint32_t cmd_start;\n\n    len = vmsvga_fifo_length(s);\n    while (len > 0 && --maxloop > 0) {\n        /* May need to go back to the start of the command if incomplete */\n        cmd_start = s->fifo_stop;\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n        case SVGA_CMD_UPDATE:\n        case SVGA_CMD_UPDATE_VERBOSE:\n            len -= 5;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n            break;\n\n        case SVGA_CMD_RECT_FILL:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            colour = vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_RECT_COPY:\n            len -= 7;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            dx = vmsvga_fifo_read(s);\n            dy = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_DEFINE_CURSOR:\n            len -= 8;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            cursor.id = vmsvga_fifo_read(s);\n            cursor.hot_x = vmsvga_fifo_read(s);\n            cursor.hot_y = vmsvga_fifo_read(s);\n            cursor.width = x = vmsvga_fifo_read(s);\n            cursor.height = y = vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            cursor.bpp = vmsvga_fifo_read(s);\n\n            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n            if (cursor.width > 256 ||\n                cursor.height > 256 ||\n                cursor.bpp > 32 ||\n                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n                    goto badcmd;\n            }\n\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n            }\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n            }\n#ifdef HW_MOUSE_ACCEL\n            vmsvga_cursor_define(s, &cursor);\n            break;\n#else\n            args = 0;\n            goto badcmd;\n#endif\n\n        /*\n         * Other commands that we at least know the number of arguments\n         * for so we can avoid FIFO desync if driver uses them illegally.\n         */\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            args = x * y;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_FILL:\n            args = 6;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_COPY:\n            args = 7;\n            goto badcmd;\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n            len -= 4;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n            goto badcmd;\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n            args = 12;\n            goto badcmd;\n\n        /*\n         * Other commands that are not listed as depending on any\n         * CAPABILITIES bits, but are not described in the README either.\n         */\n        case SVGA_CMD_SURFACE_FILL:\n        case SVGA_CMD_SURFACE_COPY:\n        case SVGA_CMD_FRONT_ROP_FILL:\n        case SVGA_CMD_FENCE:\n        case SVGA_CMD_INVALID_CMD:\n            break; /* Nop */\n\n        default:\n            args = 0;\n        badcmd:\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n            while (args--) {\n                vmsvga_fifo_read(s);\n            }\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n                   __func__, cmd);\n            break;\n\n        rewind:\n            s->fifo_stop = cmd_start;\n            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\n            break;\n        }\n    }\n\n    s->syncing = 0;\n}",
        "func": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\n    uint32_t cmd, colour;\n    int args, len, maxloop = 1024;\n    int x, y, dx, dy, width, height;\n    struct vmsvga_cursor_definition_s cursor;\n    uint32_t cmd_start;\n\n    len = vmsvga_fifo_length(s);\n    while (len > 0 && --maxloop > 0) {\n        /* May need to go back to the start of the command if incomplete */\n        cmd_start = s->fifo_stop;\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n        case SVGA_CMD_UPDATE:\n        case SVGA_CMD_UPDATE_VERBOSE:\n            len -= 5;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n            break;\n\n        case SVGA_CMD_RECT_FILL:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            colour = vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_RECT_COPY:\n            len -= 7;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            dx = vmsvga_fifo_read(s);\n            dy = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_DEFINE_CURSOR:\n            len -= 8;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            cursor.id = vmsvga_fifo_read(s);\n            cursor.hot_x = vmsvga_fifo_read(s);\n            cursor.hot_y = vmsvga_fifo_read(s);\n            cursor.width = x = vmsvga_fifo_read(s);\n            cursor.height = y = vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            cursor.bpp = vmsvga_fifo_read(s);\n\n            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n            if (cursor.width > 256\n                || cursor.height > 256\n                || cursor.bpp > 32\n                || SVGA_BITMAP_SIZE(x, y)\n                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])\n                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)\n                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {\n                    goto badcmd;\n            }\n\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n            }\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n            }\n#ifdef HW_MOUSE_ACCEL\n            vmsvga_cursor_define(s, &cursor);\n            break;\n#else\n            args = 0;\n            goto badcmd;\n#endif\n\n        /*\n         * Other commands that we at least know the number of arguments\n         * for so we can avoid FIFO desync if driver uses them illegally.\n         */\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            args = x * y;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_FILL:\n            args = 6;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_COPY:\n            args = 7;\n            goto badcmd;\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n            len -= 4;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n            goto badcmd;\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n            args = 12;\n            goto badcmd;\n\n        /*\n         * Other commands that are not listed as depending on any\n         * CAPABILITIES bits, but are not described in the README either.\n         */\n        case SVGA_CMD_SURFACE_FILL:\n        case SVGA_CMD_SURFACE_COPY:\n        case SVGA_CMD_FRONT_ROP_FILL:\n        case SVGA_CMD_FENCE:\n        case SVGA_CMD_INVALID_CMD:\n            break; /* Nop */\n\n        default:\n            args = 0;\n        badcmd:\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n            while (args--) {\n                vmsvga_fifo_read(s);\n            }\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n                   __func__, cmd);\n            break;\n\n        rewind:\n            s->fifo_stop = cmd_start;\n            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\n            break;\n        }\n    }\n\n    s->syncing = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,11 +80,13 @@\n             cursor.bpp = vmsvga_fifo_read(s);\n \n             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n-            if (cursor.width > 256 ||\n-                cursor.height > 256 ||\n-                cursor.bpp > 32 ||\n-                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n-                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n+            if (cursor.width > 256\n+                || cursor.height > 256\n+                || cursor.bpp > 32\n+                || SVGA_BITMAP_SIZE(x, y)\n+                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])\n+                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)\n+                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {\n                     goto badcmd;\n             }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "            if (cursor.width > 256 ||",
                "                cursor.height > 256 ||",
                "                cursor.bpp > 32 ||",
                "                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||",
                "                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {"
            ],
            "added_lines": [
                "            if (cursor.width > 256",
                "                || cursor.height > 256",
                "                || cursor.bpp > 32",
                "                || SVGA_BITMAP_SIZE(x, y)",
                "                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])",
                "                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)",
                "                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2806",
        "func_name": "freetype/freetype2/t42_parse_sfnts",
        "description": "Array index error in the t42_parse_sfnts function in type42/t42parse.c in FreeType before 2.4.2 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via negative size values for certain strings in FontType42 font files, leading to a heap-based buffer overflow.",
        "git_url": "http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=c06da1ad34663da7b6fc39b030dc3ae185b96557",
        "commit_title": "* src/type42/t42parse.c (t42_parse_sfnts): Protect against negative",
        "commit_text": "string_size. Fix comparison. ",
        "func_before": "static void\n  t42_parse_sfnts( T42_Face    face,\n                   T42_Loader  loader )\n  {\n    T42_Parser  parser = &loader->parser;\n    FT_Memory   memory = parser->root.memory;\n    FT_Byte*    cur;\n    FT_Byte*    limit  = parser->root.limit;\n    FT_Error    error;\n    FT_Int      num_tables = 0;\n    FT_ULong    count, ttf_size = 0;\n\n    FT_Long     n, string_size, old_string_size, real_size;\n    FT_Byte*    string_buf = NULL;\n    FT_Bool     allocated  = 0;\n\n    T42_Load_Status  status;\n\n\n    /* The format is                                */\n    /*                                              */\n    /*   /sfnts [ <hexstring> <hexstring> ... ] def */\n    /*                                              */\n    /* or                                           */\n    /*                                              */\n    /*   /sfnts [                                   */\n    /*      <num_bin_bytes> RD <binary data>        */\n    /*      <num_bin_bytes> RD <binary data>        */\n    /*      ...                                     */\n    /*   ] def                                      */\n    /*                                              */\n    /* with exactly one space after the `RD' token. */\n\n    T1_Skip_Spaces( parser );\n\n    if ( parser->root.cursor >= limit || *parser->root.cursor++ != '[' )\n    {\n      FT_ERROR(( \"t42_parse_sfnts: can't find begin of sfnts vector\\n\" ));\n      error = T42_Err_Invalid_File_Format;\n      goto Fail;\n    }\n\n    T1_Skip_Spaces( parser );\n    status          = BEFORE_START;\n    string_size     = 0;\n    old_string_size = 0;\n    count           = 0;\n\n    while ( parser->root.cursor < limit )\n    {\n      cur = parser->root.cursor;\n\n      if ( *cur == ']' )\n      {\n        parser->root.cursor++;\n        goto Exit;\n      }\n\n      else if ( *cur == '<' )\n      {\n        T1_Skip_PS_Token( parser );\n        if ( parser->root.error )\n          goto Exit;\n\n        /* don't include delimiters */\n        string_size = (FT_Long)( ( parser->root.cursor - cur - 2 + 1 ) / 2 );\n        if ( FT_REALLOC( string_buf, old_string_size, string_size ) )\n          goto Fail;\n\n        allocated = 1;\n\n        parser->root.cursor = cur;\n        (void)T1_ToBytes( parser, string_buf, string_size, &real_size, 1 );\n        old_string_size = string_size;\n        string_size = real_size;\n      }\n\n      else if ( ft_isdigit( *cur ) )\n      {\n        if ( allocated )\n        {\n          FT_ERROR(( \"t42_parse_sfnts: \"\n                     \"can't handle mixed binary and hex strings\\n\" ));\n          error = T42_Err_Invalid_File_Format;\n          goto Fail;\n        }\n\n        string_size = T1_ToInt( parser );\n\n        T1_Skip_PS_Token( parser );             /* `RD' */\n        if ( parser->root.error )\n          return;\n\n        string_buf = parser->root.cursor + 1;   /* one space after `RD' */\n\n        parser->root.cursor += string_size + 1;\n        if ( parser->root.cursor >= limit )\n        {\n          FT_ERROR(( \"t42_parse_sfnts: too many binary data\\n\" ));\n          error = T42_Err_Invalid_File_Format;\n          goto Fail;\n        }\n      }\n\n      if ( !string_buf )\n      {\n        FT_ERROR(( \"t42_parse_sfnts: invalid data in sfnts array\\n\" ));\n        error = T42_Err_Invalid_File_Format;\n        goto Fail;\n      }\n\n      /* A string can have a trailing zero byte for padding.  Ignore it. */\n      if ( string_buf[string_size - 1] == 0 && ( string_size % 2 == 1 ) )\n        string_size--;\n\n      if ( !string_size )\n      {\n        FT_ERROR(( \"t42_parse_sfnts: invalid string\\n\" ));\n        error = T42_Err_Invalid_File_Format;\n        goto Fail;\n      }\n\n      for ( n = 0; n < string_size; n++ )\n      {\n        switch ( status )\n        {\n        case BEFORE_START:\n          /* load offset table, 12 bytes */\n          if ( count < 12 )\n          {\n            face->ttf_data[count++] = string_buf[n];\n            continue;\n          }\n          else\n          {\n            num_tables = 16 * face->ttf_data[4] + face->ttf_data[5];\n            status     = BEFORE_TABLE_DIR;\n            ttf_size   = 12 + 16 * num_tables;\n\n            if ( FT_REALLOC( face->ttf_data, 12, ttf_size ) )\n              goto Fail;\n          }\n          /* fall through */\n\n        case BEFORE_TABLE_DIR:\n          /* the offset table is read; read the table directory */\n          if ( count < ttf_size )\n          {\n            face->ttf_data[count++] = string_buf[n];\n            continue;\n          }\n          else\n          {\n            int       i;\n            FT_ULong  len;\n\n\n            for ( i = 0; i < num_tables; i++ )\n            {\n              FT_Byte*  p = face->ttf_data + 12 + 16 * i + 12;\n\n\n              len = FT_PEEK_ULONG( p );\n\n              /* Pad to a 4-byte boundary length */\n              ttf_size += ( len + 3 ) & ~3;\n            }\n\n            status         = OTHER_TABLES;\n            face->ttf_size = ttf_size;\n\n            /* there are no more than 256 tables, so no size check here */\n            if ( FT_REALLOC( face->ttf_data, 12 + 16 * num_tables,\n                             ttf_size + 1 ) )\n              goto Fail;\n          }\n          /* fall through */\n\n        case OTHER_TABLES:\n          /* all other tables are just copied */\n          if ( count >= ttf_size )\n          {\n            FT_ERROR(( \"t42_parse_sfnts: too many binary data\\n\" ));\n            error = T42_Err_Invalid_File_Format;\n            goto Fail;\n          }\n          face->ttf_data[count++] = string_buf[n];\n        }\n      }\n\n      T1_Skip_Spaces( parser );\n    }\n\n    /* if control reaches this point, the format was not valid */\n    error = T42_Err_Invalid_File_Format;\n\n  Fail:\n    parser->root.error = error;\n\n  Exit:\n    if ( allocated )\n      FT_FREE( string_buf );\n  }",
        "func": "static void\n  t42_parse_sfnts( T42_Face    face,\n                   T42_Loader  loader )\n  {\n    T42_Parser  parser = &loader->parser;\n    FT_Memory   memory = parser->root.memory;\n    FT_Byte*    cur;\n    FT_Byte*    limit  = parser->root.limit;\n    FT_Error    error;\n    FT_Int      num_tables = 0;\n    FT_ULong    count, ttf_size = 0;\n\n    FT_Long     n, string_size, old_string_size, real_size;\n    FT_Byte*    string_buf = NULL;\n    FT_Bool     allocated  = 0;\n\n    T42_Load_Status  status;\n\n\n    /* The format is                                */\n    /*                                              */\n    /*   /sfnts [ <hexstring> <hexstring> ... ] def */\n    /*                                              */\n    /* or                                           */\n    /*                                              */\n    /*   /sfnts [                                   */\n    /*      <num_bin_bytes> RD <binary data>        */\n    /*      <num_bin_bytes> RD <binary data>        */\n    /*      ...                                     */\n    /*   ] def                                      */\n    /*                                              */\n    /* with exactly one space after the `RD' token. */\n\n    T1_Skip_Spaces( parser );\n\n    if ( parser->root.cursor >= limit || *parser->root.cursor++ != '[' )\n    {\n      FT_ERROR(( \"t42_parse_sfnts: can't find begin of sfnts vector\\n\" ));\n      error = T42_Err_Invalid_File_Format;\n      goto Fail;\n    }\n\n    T1_Skip_Spaces( parser );\n    status          = BEFORE_START;\n    string_size     = 0;\n    old_string_size = 0;\n    count           = 0;\n\n    while ( parser->root.cursor < limit )\n    {\n      cur = parser->root.cursor;\n\n      if ( *cur == ']' )\n      {\n        parser->root.cursor++;\n        goto Exit;\n      }\n\n      else if ( *cur == '<' )\n      {\n        T1_Skip_PS_Token( parser );\n        if ( parser->root.error )\n          goto Exit;\n\n        /* don't include delimiters */\n        string_size = (FT_Long)( ( parser->root.cursor - cur - 2 + 1 ) / 2 );\n        if ( FT_REALLOC( string_buf, old_string_size, string_size ) )\n          goto Fail;\n\n        allocated = 1;\n\n        parser->root.cursor = cur;\n        (void)T1_ToBytes( parser, string_buf, string_size, &real_size, 1 );\n        old_string_size = string_size;\n        string_size = real_size;\n      }\n\n      else if ( ft_isdigit( *cur ) )\n      {\n        if ( allocated )\n        {\n          FT_ERROR(( \"t42_parse_sfnts: \"\n                     \"can't handle mixed binary and hex strings\\n\" ));\n          error = T42_Err_Invalid_File_Format;\n          goto Fail;\n        }\n\n        string_size = T1_ToInt( parser );\n        if ( string_size < 0 )\n        {\n          FT_ERROR(( \"t42_parse_sfnts: invalid string size\\n\" ));\n          error = T42_Err_Invalid_File_Format;\n          goto Fail;\n        }\n\n        T1_Skip_PS_Token( parser );             /* `RD' */\n        if ( parser->root.error )\n          return;\n\n        string_buf = parser->root.cursor + 1;   /* one space after `RD' */\n\n        if ( limit - parser->root.cursor < string_size )\n        {\n          FT_ERROR(( \"t42_parse_sfnts: too many binary data\\n\" ));\n          error = T42_Err_Invalid_File_Format;\n          goto Fail;\n        }\n        else\n          parser->root.cursor += string_size + 1;\n      }\n\n      if ( !string_buf )\n      {\n        FT_ERROR(( \"t42_parse_sfnts: invalid data in sfnts array\\n\" ));\n        error = T42_Err_Invalid_File_Format;\n        goto Fail;\n      }\n\n      /* A string can have a trailing zero byte for padding.  Ignore it. */\n      if ( string_buf[string_size - 1] == 0 && ( string_size % 2 == 1 ) )\n        string_size--;\n\n      if ( !string_size )\n      {\n        FT_ERROR(( \"t42_parse_sfnts: invalid string\\n\" ));\n        error = T42_Err_Invalid_File_Format;\n        goto Fail;\n      }\n\n      for ( n = 0; n < string_size; n++ )\n      {\n        switch ( status )\n        {\n        case BEFORE_START:\n          /* load offset table, 12 bytes */\n          if ( count < 12 )\n          {\n            face->ttf_data[count++] = string_buf[n];\n            continue;\n          }\n          else\n          {\n            num_tables = 16 * face->ttf_data[4] + face->ttf_data[5];\n            status     = BEFORE_TABLE_DIR;\n            ttf_size   = 12 + 16 * num_tables;\n\n            if ( FT_REALLOC( face->ttf_data, 12, ttf_size ) )\n              goto Fail;\n          }\n          /* fall through */\n\n        case BEFORE_TABLE_DIR:\n          /* the offset table is read; read the table directory */\n          if ( count < ttf_size )\n          {\n            face->ttf_data[count++] = string_buf[n];\n            continue;\n          }\n          else\n          {\n            int       i;\n            FT_ULong  len;\n\n\n            for ( i = 0; i < num_tables; i++ )\n            {\n              FT_Byte*  p = face->ttf_data + 12 + 16 * i + 12;\n\n\n              len = FT_PEEK_ULONG( p );\n\n              /* Pad to a 4-byte boundary length */\n              ttf_size += ( len + 3 ) & ~3;\n            }\n\n            status         = OTHER_TABLES;\n            face->ttf_size = ttf_size;\n\n            /* there are no more than 256 tables, so no size check here */\n            if ( FT_REALLOC( face->ttf_data, 12 + 16 * num_tables,\n                             ttf_size + 1 ) )\n              goto Fail;\n          }\n          /* fall through */\n\n        case OTHER_TABLES:\n          /* all other tables are just copied */\n          if ( count >= ttf_size )\n          {\n            FT_ERROR(( \"t42_parse_sfnts: too many binary data\\n\" ));\n            error = T42_Err_Invalid_File_Format;\n            goto Fail;\n          }\n          face->ttf_data[count++] = string_buf[n];\n        }\n      }\n\n      T1_Skip_Spaces( parser );\n    }\n\n    /* if control reaches this point, the format was not valid */\n    error = T42_Err_Invalid_File_Format;\n\n  Fail:\n    parser->root.error = error;\n\n  Exit:\n    if ( allocated )\n      FT_FREE( string_buf );\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -86,6 +86,12 @@\n         }\n \n         string_size = T1_ToInt( parser );\n+        if ( string_size < 0 )\n+        {\n+          FT_ERROR(( \"t42_parse_sfnts: invalid string size\\n\" ));\n+          error = T42_Err_Invalid_File_Format;\n+          goto Fail;\n+        }\n \n         T1_Skip_PS_Token( parser );             /* `RD' */\n         if ( parser->root.error )\n@@ -93,13 +99,14 @@\n \n         string_buf = parser->root.cursor + 1;   /* one space after `RD' */\n \n-        parser->root.cursor += string_size + 1;\n-        if ( parser->root.cursor >= limit )\n+        if ( limit - parser->root.cursor < string_size )\n         {\n           FT_ERROR(( \"t42_parse_sfnts: too many binary data\\n\" ));\n           error = T42_Err_Invalid_File_Format;\n           goto Fail;\n         }\n+        else\n+          parser->root.cursor += string_size + 1;\n       }\n \n       if ( !string_buf )",
        "diff_line_info": {
            "deleted_lines": [
                "        parser->root.cursor += string_size + 1;",
                "        if ( parser->root.cursor >= limit )"
            ],
            "added_lines": [
                "        if ( string_size < 0 )",
                "        {",
                "          FT_ERROR(( \"t42_parse_sfnts: invalid string size\\n\" ));",
                "          error = T42_Err_Invalid_File_Format;",
                "          goto Fail;",
                "        }",
                "        if ( limit - parser->root.cursor < string_size )",
                "        else",
                "          parser->root.cursor += string_size + 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1169",
        "func_name": "kernel/git/tiwai/sound/asihpi_hpi_ioctl",
        "description": "Array index error in the asihpi_hpi_ioctl function in sound/pci/asihpi/hpioctl.c in the AudioScience HPI driver in the Linux kernel before 2.6.38.1 might allow local users to cause a denial of service (memory corruption) or possibly gain privileges via a crafted adapter index value that triggers access to an invalid kernel pointer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/tiwai/sound.git;a=commit;h=4a122c10fbfe9020df469f0f669da129c5757671",
        "commit_title": "The user-supplied index into the adapters array needs to be checked, or",
        "commit_text": "an out-of-bounds kernel pointer could be accessed and used, leading to potentially exploitable memory corruption.  Cc: <stable@kernel.org> ",
        "func_before": "long asihpi_hpi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hpi_ioctl_linux __user *phpi_ioctl_data;\n\tvoid __user *puhm;\n\tvoid __user *puhr;\n\tunion hpi_message_buffer_v1 *hm;\n\tunion hpi_response_buffer_v1 *hr;\n\tu16 res_max_size;\n\tu32 uncopied_bytes;\n\tstruct hpi_adapter *pa = NULL;\n\tint err = 0;\n\n\tif (cmd != HPI_IOCTL_LINUX)\n\t\treturn -EINVAL;\n\n\thm = kmalloc(sizeof(*hm), GFP_KERNEL);\n\thr = kmalloc(sizeof(*hr), GFP_KERNEL);\n\tif (!hm || !hr) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tphpi_ioctl_data = (struct hpi_ioctl_linux __user *)arg;\n\n\t/* Read the message and response pointers from user space.  */\n\tif (get_user(puhm, &phpi_ioctl_data->phm)\n\t\t|| get_user(puhr, &phpi_ioctl_data->phr)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Now read the message size and data from user space.  */\n\tif (get_user(hm->h.size, (u16 __user *)puhm)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hm->h.size > sizeof(*hm))\n\t\thm->h.size = sizeof(*hm);\n\n\t/* printk(KERN_INFO \"message size %d\\n\", hm->h.wSize); */\n\n\tuncopied_bytes = copy_from_user(hm, puhm, hm->h.size);\n\tif (uncopied_bytes) {\n\t\tHPI_DEBUG_LOG(ERROR, \"uncopied bytes %d\\n\", uncopied_bytes);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (get_user(res_max_size, (u16 __user *)puhr)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\t/* printk(KERN_INFO \"user response size %d\\n\", res_max_size); */\n\tif (res_max_size < sizeof(struct hpi_response_header)) {\n\t\tHPI_DEBUG_LOG(WARNING, \"small res size %d\\n\", res_max_size);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpa = &adapters[hm->h.adapter_index];\n\thr->h.size = res_max_size;\n\tif (hm->h.object == HPI_OBJ_SUBSYSTEM) {\n\t\tswitch (hm->h.function) {\n\t\tcase HPI_SUBSYS_CREATE_ADAPTER:\n\t\tcase HPI_SUBSYS_DELETE_ADAPTER:\n\t\t\t/* Application must not use these functions! */\n\t\t\thr->h.size = sizeof(hr->h);\n\t\t\thr->h.error = HPI_ERROR_INVALID_OPERATION;\n\t\t\thr->h.function = hm->h.function;\n\t\t\tuncopied_bytes = copy_to_user(puhr, hr, hr->h.size);\n\t\t\tif (uncopied_bytes)\n\t\t\t\terr = -EFAULT;\n\t\t\telse\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\n\t\tdefault:\n\t\t\thpi_send_recv_f(&hm->m0, &hr->r0, file);\n\t\t}\n\t} else {\n\t\tu16 __user *ptr = NULL;\n\t\tu32 size = 0;\n\n\t\t/* -1=no data 0=read from user mem, 1=write to user mem */\n\t\tint wrflag = -1;\n\t\tu32 adapter = hm->h.adapter_index;\n\n\t\tif ((hm->h.adapter_index > HPI_MAX_ADAPTERS) || (!pa->type)) {\n\t\t\thpi_init_response(&hr->r0, HPI_OBJ_ADAPTER,\n\t\t\t\tHPI_ADAPTER_OPEN,\n\t\t\t\tHPI_ERROR_BAD_ADAPTER_NUMBER);\n\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_to_user(puhr, hr, sizeof(hr->h));\n\t\t\tif (uncopied_bytes)\n\t\t\t\terr = -EFAULT;\n\t\t\telse\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mutex_lock_interruptible(&adapters[adapter].mutex)) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Dig out any pointers embedded in the message.  */\n\t\tswitch (hm->h.function) {\n\t\tcase HPI_OSTREAM_WRITE:\n\t\tcase HPI_ISTREAM_READ:{\n\t\t\t\t/* Yes, sparse, this is correct. */\n\t\t\t\tptr = (u16 __user *)hm->m0.u.d.u.data.pb_data;\n\t\t\t\tsize = hm->m0.u.d.u.data.data_size;\n\n\t\t\t\t/* Allocate buffer according to application request.\n\t\t\t\t   ?Is it better to alloc/free for the duration\n\t\t\t\t   of the transaction?\n\t\t\t\t */\n\t\t\t\tif (pa->buffer_size < size) {\n\t\t\t\t\tHPI_DEBUG_LOG(DEBUG,\n\t\t\t\t\t\t\"Realloc adapter %d stream \"\n\t\t\t\t\t\t\"buffer from %zd to %d\\n\",\n\t\t\t\t\t\thm->h.adapter_index,\n\t\t\t\t\t\tpa->buffer_size, size);\n\t\t\t\t\tif (pa->p_buffer) {\n\t\t\t\t\t\tpa->buffer_size = 0;\n\t\t\t\t\t\tvfree(pa->p_buffer);\n\t\t\t\t\t}\n\t\t\t\t\tpa->p_buffer = vmalloc(size);\n\t\t\t\t\tif (pa->p_buffer)\n\t\t\t\t\t\tpa->buffer_size = size;\n\t\t\t\t\telse {\n\t\t\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\t\t\"HPI could not allocate \"\n\t\t\t\t\t\t\t\"stream buffer size %d\\n\",\n\t\t\t\t\t\t\tsize);\n\n\t\t\t\t\t\tmutex_unlock(&adapters\n\t\t\t\t\t\t\t[adapter].mutex);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thm->m0.u.d.u.data.pb_data = pa->p_buffer;\n\t\t\t\tif (hm->h.function == HPI_ISTREAM_READ)\n\t\t\t\t\t/* from card, WRITE to user mem */\n\t\t\t\t\twrflag = 1;\n\t\t\t\telse\n\t\t\t\t\twrflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size && (wrflag == 0)) {\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_from_user(pa->p_buffer, ptr, size);\n\t\t\tif (uncopied_bytes)\n\t\t\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\t\t\"Missed %d of %d \"\n\t\t\t\t\t\"bytes from user\\n\", uncopied_bytes,\n\t\t\t\t\tsize);\n\t\t}\n\n\t\thpi_send_recv_f(&hm->m0, &hr->r0, file);\n\n\t\tif (size && (wrflag == 1)) {\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_to_user(ptr, pa->p_buffer, size);\n\t\t\tif (uncopied_bytes)\n\t\t\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\t\t\"Missed %d of %d \" \"bytes to user\\n\",\n\t\t\t\t\tuncopied_bytes, size);\n\t\t}\n\n\t\tmutex_unlock(&adapters[adapter].mutex);\n\t}\n\n\t/* on return response size must be set */\n\t/*printk(KERN_INFO \"response size %d\\n\", hr->h.wSize); */\n\n\tif (!hr->h.size) {\n\t\tHPI_DEBUG_LOG(ERROR, \"response zero size\\n\");\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hr->h.size > res_max_size) {\n\t\tHPI_DEBUG_LOG(ERROR, \"response too big %d %d\\n\", hr->h.size,\n\t\t\tres_max_size);\n\t\thr->h.error = HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\n\t\thr->h.specific_error = hr->h.size;\n\t\thr->h.size = sizeof(hr->h);\n\t}\n\n\tuncopied_bytes = copy_to_user(puhr, hr, hr->h.size);\n\tif (uncopied_bytes) {\n\t\tHPI_DEBUG_LOG(ERROR, \"uncopied bytes %d\\n\", uncopied_bytes);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(hm);\n\tkfree(hr);\n\treturn err;\n}",
        "func": "long asihpi_hpi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hpi_ioctl_linux __user *phpi_ioctl_data;\n\tvoid __user *puhm;\n\tvoid __user *puhr;\n\tunion hpi_message_buffer_v1 *hm;\n\tunion hpi_response_buffer_v1 *hr;\n\tu16 res_max_size;\n\tu32 uncopied_bytes;\n\tstruct hpi_adapter *pa = NULL;\n\tint err = 0;\n\n\tif (cmd != HPI_IOCTL_LINUX)\n\t\treturn -EINVAL;\n\n\thm = kmalloc(sizeof(*hm), GFP_KERNEL);\n\thr = kmalloc(sizeof(*hr), GFP_KERNEL);\n\tif (!hm || !hr) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tphpi_ioctl_data = (struct hpi_ioctl_linux __user *)arg;\n\n\t/* Read the message and response pointers from user space.  */\n\tif (get_user(puhm, &phpi_ioctl_data->phm)\n\t\t|| get_user(puhr, &phpi_ioctl_data->phr)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Now read the message size and data from user space.  */\n\tif (get_user(hm->h.size, (u16 __user *)puhm)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hm->h.size > sizeof(*hm))\n\t\thm->h.size = sizeof(*hm);\n\n\t/* printk(KERN_INFO \"message size %d\\n\", hm->h.wSize); */\n\n\tuncopied_bytes = copy_from_user(hm, puhm, hm->h.size);\n\tif (uncopied_bytes) {\n\t\tHPI_DEBUG_LOG(ERROR, \"uncopied bytes %d\\n\", uncopied_bytes);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (get_user(res_max_size, (u16 __user *)puhr)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\t/* printk(KERN_INFO \"user response size %d\\n\", res_max_size); */\n\tif (res_max_size < sizeof(struct hpi_response_header)) {\n\t\tHPI_DEBUG_LOG(WARNING, \"small res size %d\\n\", res_max_size);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hm->h.adapter_index >= HPI_MAX_ADAPTERS) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpa = &adapters[hm->h.adapter_index];\n\thr->h.size = res_max_size;\n\tif (hm->h.object == HPI_OBJ_SUBSYSTEM) {\n\t\tswitch (hm->h.function) {\n\t\tcase HPI_SUBSYS_CREATE_ADAPTER:\n\t\tcase HPI_SUBSYS_DELETE_ADAPTER:\n\t\t\t/* Application must not use these functions! */\n\t\t\thr->h.size = sizeof(hr->h);\n\t\t\thr->h.error = HPI_ERROR_INVALID_OPERATION;\n\t\t\thr->h.function = hm->h.function;\n\t\t\tuncopied_bytes = copy_to_user(puhr, hr, hr->h.size);\n\t\t\tif (uncopied_bytes)\n\t\t\t\terr = -EFAULT;\n\t\t\telse\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\n\t\tdefault:\n\t\t\thpi_send_recv_f(&hm->m0, &hr->r0, file);\n\t\t}\n\t} else {\n\t\tu16 __user *ptr = NULL;\n\t\tu32 size = 0;\n\n\t\t/* -1=no data 0=read from user mem, 1=write to user mem */\n\t\tint wrflag = -1;\n\t\tu32 adapter = hm->h.adapter_index;\n\n\t\tif ((hm->h.adapter_index > HPI_MAX_ADAPTERS) || (!pa->type)) {\n\t\t\thpi_init_response(&hr->r0, HPI_OBJ_ADAPTER,\n\t\t\t\tHPI_ADAPTER_OPEN,\n\t\t\t\tHPI_ERROR_BAD_ADAPTER_NUMBER);\n\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_to_user(puhr, hr, sizeof(hr->h));\n\t\t\tif (uncopied_bytes)\n\t\t\t\terr = -EFAULT;\n\t\t\telse\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mutex_lock_interruptible(&adapters[adapter].mutex)) {\n\t\t\terr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Dig out any pointers embedded in the message.  */\n\t\tswitch (hm->h.function) {\n\t\tcase HPI_OSTREAM_WRITE:\n\t\tcase HPI_ISTREAM_READ:{\n\t\t\t\t/* Yes, sparse, this is correct. */\n\t\t\t\tptr = (u16 __user *)hm->m0.u.d.u.data.pb_data;\n\t\t\t\tsize = hm->m0.u.d.u.data.data_size;\n\n\t\t\t\t/* Allocate buffer according to application request.\n\t\t\t\t   ?Is it better to alloc/free for the duration\n\t\t\t\t   of the transaction?\n\t\t\t\t */\n\t\t\t\tif (pa->buffer_size < size) {\n\t\t\t\t\tHPI_DEBUG_LOG(DEBUG,\n\t\t\t\t\t\t\"Realloc adapter %d stream \"\n\t\t\t\t\t\t\"buffer from %zd to %d\\n\",\n\t\t\t\t\t\thm->h.adapter_index,\n\t\t\t\t\t\tpa->buffer_size, size);\n\t\t\t\t\tif (pa->p_buffer) {\n\t\t\t\t\t\tpa->buffer_size = 0;\n\t\t\t\t\t\tvfree(pa->p_buffer);\n\t\t\t\t\t}\n\t\t\t\t\tpa->p_buffer = vmalloc(size);\n\t\t\t\t\tif (pa->p_buffer)\n\t\t\t\t\t\tpa->buffer_size = size;\n\t\t\t\t\telse {\n\t\t\t\t\t\tHPI_DEBUG_LOG(ERROR,\n\t\t\t\t\t\t\t\"HPI could not allocate \"\n\t\t\t\t\t\t\t\"stream buffer size %d\\n\",\n\t\t\t\t\t\t\tsize);\n\n\t\t\t\t\t\tmutex_unlock(&adapters\n\t\t\t\t\t\t\t[adapter].mutex);\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thm->m0.u.d.u.data.pb_data = pa->p_buffer;\n\t\t\t\tif (hm->h.function == HPI_ISTREAM_READ)\n\t\t\t\t\t/* from card, WRITE to user mem */\n\t\t\t\t\twrflag = 1;\n\t\t\t\telse\n\t\t\t\t\twrflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size && (wrflag == 0)) {\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_from_user(pa->p_buffer, ptr, size);\n\t\t\tif (uncopied_bytes)\n\t\t\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\t\t\"Missed %d of %d \"\n\t\t\t\t\t\"bytes from user\\n\", uncopied_bytes,\n\t\t\t\t\tsize);\n\t\t}\n\n\t\thpi_send_recv_f(&hm->m0, &hr->r0, file);\n\n\t\tif (size && (wrflag == 1)) {\n\t\t\tuncopied_bytes =\n\t\t\t\tcopy_to_user(ptr, pa->p_buffer, size);\n\t\t\tif (uncopied_bytes)\n\t\t\t\tHPI_DEBUG_LOG(WARNING,\n\t\t\t\t\t\"Missed %d of %d \" \"bytes to user\\n\",\n\t\t\t\t\tuncopied_bytes, size);\n\t\t}\n\n\t\tmutex_unlock(&adapters[adapter].mutex);\n\t}\n\n\t/* on return response size must be set */\n\t/*printk(KERN_INFO \"response size %d\\n\", hr->h.wSize); */\n\n\tif (!hr->h.size) {\n\t\tHPI_DEBUG_LOG(ERROR, \"response zero size\\n\");\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (hr->h.size > res_max_size) {\n\t\tHPI_DEBUG_LOG(ERROR, \"response too big %d %d\\n\", hr->h.size,\n\t\t\tres_max_size);\n\t\thr->h.error = HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\n\t\thr->h.specific_error = hr->h.size;\n\t\thr->h.size = sizeof(hr->h);\n\t}\n\n\tuncopied_bytes = copy_to_user(puhr, hr, hr->h.size);\n\tif (uncopied_bytes) {\n\t\tHPI_DEBUG_LOG(ERROR, \"uncopied bytes %d\\n\", uncopied_bytes);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(hm);\n\tkfree(hr);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,6 +54,11 @@\n \tif (res_max_size < sizeof(struct hpi_response_header)) {\n \t\tHPI_DEBUG_LOG(WARNING, \"small res size %d\\n\", res_max_size);\n \t\terr = -EFAULT;\n+\t\tgoto out;\n+\t}\n+\n+\tif (hm->h.adapter_index >= HPI_MAX_ADAPTERS) {\n+\t\terr = -EINVAL;\n \t\tgoto out;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tgoto out;",
                "\t}",
                "",
                "\tif (hm->h.adapter_index >= HPI_MAX_ADAPTERS) {",
                "\t\terr = -EINVAL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7228",
        "func_name": "xen-project/xen/memory_exchange",
        "description": "An issue (known as XSA-212) was discovered in Xen, with fixes available for 4.8.x, 4.7.x, 4.6.x, 4.5.x, and 4.4.x. The earlier XSA-29 fix introduced an insufficient check on XENMEM_exchange input, allowing the caller to drive hypervisor memory accesses outside of the guest provided input/output arrays.",
        "git_url": "https://github.com/xen-project/xen/commit/938fd2586eb081bcbd694f4c1f09ae6a263b0d90",
        "commit_title": "memory: properly check guest memory ranges in XENMEM_exchange handling",
        "commit_text": " The use of guest_handle_okay() here (as introduced by the XSA-29 fix) is insufficient here, guest_handle_subrange_okay() needs to be used instead.  Note that the uses are okay in - XENMEM_add_to_physmap_batch handling due to the size field being only   16 bits wide, - livepatch_list() due to the limit of 1024 enforced on the   number-of-entries input (leaving aside the fact that this can be   called by a privileged domain only anyway), - compat mode handling due to counts there being limited to 32 bits, - everywhere else due to guest arrays being accessed sequentially from   index zero.  This is CVE-2017-7228 / XSA-212. ",
        "func_before": "static long memory_exchange(XEN_GUEST_HANDLE_PARAM(xen_memory_exchange_t) arg)\n{\n    struct xen_memory_exchange exch;\n    PAGE_LIST_HEAD(in_chunk_list);\n    PAGE_LIST_HEAD(out_chunk_list);\n    unsigned long in_chunk_order, out_chunk_order;\n    xen_pfn_t     gpfn, gmfn, mfn;\n    unsigned long i, j, k;\n    unsigned int  memflags = 0;\n    long          rc = 0;\n    struct domain *d;\n    struct page_info *page;\n\n    if ( copy_from_guest(&exch, arg, 1) )\n        return -EFAULT;\n\n    if ( max(exch.in.extent_order, exch.out.extent_order) >\n         max_order(current->domain) )\n    {\n        rc = -EPERM;\n        goto fail_early;\n    }\n\n    /* Various sanity checks. */\n    if ( (exch.nr_exchanged > exch.in.nr_extents) ||\n         /* Input and output domain identifiers match? */\n         (exch.in.domid != exch.out.domid) ||\n         /* Sizes of input and output lists do not overflow a long? */\n         ((~0UL >> exch.in.extent_order) < exch.in.nr_extents) ||\n         ((~0UL >> exch.out.extent_order) < exch.out.nr_extents) ||\n         /* Sizes of input and output lists match? */\n         ((exch.in.nr_extents << exch.in.extent_order) !=\n          (exch.out.nr_extents << exch.out.extent_order)) )\n    {\n        rc = -EINVAL;\n        goto fail_early;\n    }\n\n    if ( !guest_handle_okay(exch.in.extent_start, exch.in.nr_extents) ||\n         !guest_handle_okay(exch.out.extent_start, exch.out.nr_extents) )\n    {\n        rc = -EFAULT;\n        goto fail_early;\n    }\n\n    if ( exch.in.extent_order <= exch.out.extent_order )\n    {\n        in_chunk_order  = exch.out.extent_order - exch.in.extent_order;\n        out_chunk_order = 0;\n    }\n    else\n    {\n        in_chunk_order  = 0;\n        out_chunk_order = exch.in.extent_order - exch.out.extent_order;\n    }\n\n    d = rcu_lock_domain_by_any_id(exch.in.domid);\n    if ( d == NULL )\n    {\n        rc = -ESRCH;\n        goto fail_early;\n    }\n\n    rc = xsm_memory_exchange(XSM_TARGET, d);\n    if ( rc )\n    {\n        rcu_unlock_domain(d);\n        goto fail_early;\n    }\n\n    memflags |= MEMF_bits(domain_clamp_alloc_bitsize(\n        d,\n        XENMEMF_get_address_bits(exch.out.mem_flags) ? :\n        (BITS_PER_LONG+PAGE_SHIFT)));\n    memflags |= MEMF_node(XENMEMF_get_node(exch.out.mem_flags));\n\n    for ( i = (exch.nr_exchanged >> in_chunk_order);\n          i < (exch.in.nr_extents >> in_chunk_order);\n          i++ )\n    {\n        if ( i != (exch.nr_exchanged >> in_chunk_order) &&\n             hypercall_preempt_check() )\n        {\n            exch.nr_exchanged = i << in_chunk_order;\n            rcu_unlock_domain(d);\n            if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n                return -EFAULT;\n            return hypercall_create_continuation(\n                __HYPERVISOR_memory_op, \"lh\", XENMEM_exchange, arg);\n        }\n\n        /* Steal a chunk's worth of input pages from the domain. */\n        for ( j = 0; j < (1UL << in_chunk_order); j++ )\n        {\n            if ( unlikely(__copy_from_guest_offset(\n                &gmfn, exch.in.extent_start, (i<<in_chunk_order)+j, 1)) )\n            {\n                rc = -EFAULT;\n                goto fail;\n            }\n\n            for ( k = 0; k < (1UL << exch.in.extent_order); k++ )\n            {\n#ifdef CONFIG_X86\n                p2m_type_t p2mt;\n\n                /* Shared pages cannot be exchanged */\n                mfn = mfn_x(get_gfn_unshare(d, gmfn + k, &p2mt));\n                if ( p2m_is_shared(p2mt) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -ENOMEM;\n                    goto fail; \n                }\n#else /* !CONFIG_X86 */\n                mfn = mfn_x(gfn_to_mfn(d, _gfn(gmfn + k)));\n#endif\n                if ( unlikely(!mfn_valid(_mfn(mfn))) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -EINVAL;\n                    goto fail;\n                }\n\n                page = mfn_to_page(mfn);\n\n                if ( unlikely(steal_page(d, page, MEMF_no_refcount)) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -EINVAL;\n                    goto fail;\n                }\n\n                page_list_add(page, &in_chunk_list);\n                put_gfn(d, gmfn + k);\n            }\n        }\n\n        /* Allocate a chunk's worth of anonymous output pages. */\n        for ( j = 0; j < (1UL << out_chunk_order); j++ )\n        {\n            page = alloc_domheap_pages(d, exch.out.extent_order,\n                                       MEMF_no_owner | memflags);\n            if ( unlikely(page == NULL) )\n            {\n                rc = -ENOMEM;\n                goto fail;\n            }\n\n            page_list_add(page, &out_chunk_list);\n        }\n\n        /*\n         * Success! Beyond this point we cannot fail for this chunk.\n         */\n\n        /* Destroy final reference to each input page. */\n        while ( (page = page_list_remove_head(&in_chunk_list)) )\n        {\n            unsigned long gfn;\n\n            if ( !test_and_clear_bit(_PGC_allocated, &page->count_info) )\n                BUG();\n            mfn = page_to_mfn(page);\n            gfn = mfn_to_gmfn(d, mfn);\n            /* Pages were unshared above */\n            BUG_ON(SHARED_M2P(gfn));\n            guest_physmap_remove_page(d, _gfn(gfn), _mfn(mfn), 0);\n            put_page(page);\n        }\n\n        /* Assign each output page to the domain. */\n        for ( j = 0; (page = page_list_remove_head(&out_chunk_list)); ++j )\n        {\n            if ( assign_pages(d, page, exch.out.extent_order,\n                              MEMF_no_refcount) )\n            {\n                unsigned long dec_count;\n                bool_t drop_dom_ref;\n\n                /*\n                 * Pages in in_chunk_list is stolen without\n                 * decreasing the tot_pages. If the domain is dying when\n                 * assign pages, we need decrease the count. For those pages\n                 * that has been assigned, it should be covered by\n                 * domain_relinquish_resources().\n                 */\n                dec_count = (((1UL << exch.in.extent_order) *\n                              (1UL << in_chunk_order)) -\n                             (j * (1UL << exch.out.extent_order)));\n\n                spin_lock(&d->page_alloc_lock);\n                drop_dom_ref = (dec_count &&\n                                !domain_adjust_tot_pages(d, -dec_count));\n                spin_unlock(&d->page_alloc_lock);\n\n                if ( drop_dom_ref )\n                    put_domain(d);\n\n                free_domheap_pages(page, exch.out.extent_order);\n                goto dying;\n            }\n\n            if ( __copy_from_guest_offset(&gpfn, exch.out.extent_start,\n                                          (i << out_chunk_order) + j, 1) )\n            {\n                rc = -EFAULT;\n                continue;\n            }\n\n            mfn = page_to_mfn(page);\n            guest_physmap_add_page(d, _gfn(gpfn), _mfn(mfn),\n                                   exch.out.extent_order);\n\n            if ( !paging_mode_translate(d) )\n            {\n                for ( k = 0; k < (1UL << exch.out.extent_order); k++ )\n                    set_gpfn_from_mfn(mfn + k, gpfn + k);\n                if ( __copy_to_guest_offset(exch.out.extent_start,\n                                            (i << out_chunk_order) + j,\n                                            &mfn, 1) )\n                    rc = -EFAULT;\n            }\n        }\n        BUG_ON( !(d->is_dying) && (j != (1UL << out_chunk_order)) );\n    }\n\n    exch.nr_exchanged = exch.in.nr_extents;\n    if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n        rc = -EFAULT;\n    rcu_unlock_domain(d);\n    return rc;\n\n    /*\n     * Failed a chunk! Free any partial chunk work. Tell caller how many\n     * chunks succeeded.\n     */\n fail:\n    /* Reassign any input pages we managed to steal. */\n    while ( (page = page_list_remove_head(&in_chunk_list)) )\n        if ( assign_pages(d, page, 0, MEMF_no_refcount) )\n        {\n            BUG_ON(!d->is_dying);\n            if ( test_and_clear_bit(_PGC_allocated, &page->count_info) )\n                put_page(page);\n        }\n\n dying:\n    rcu_unlock_domain(d);\n    /* Free any output pages we managed to allocate. */\n    while ( (page = page_list_remove_head(&out_chunk_list)) )\n        free_domheap_pages(page, exch.out.extent_order);\n\n    exch.nr_exchanged = i << in_chunk_order;\n\n fail_early:\n    if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n        rc = -EFAULT;\n    return rc;\n}",
        "func": "static long memory_exchange(XEN_GUEST_HANDLE_PARAM(xen_memory_exchange_t) arg)\n{\n    struct xen_memory_exchange exch;\n    PAGE_LIST_HEAD(in_chunk_list);\n    PAGE_LIST_HEAD(out_chunk_list);\n    unsigned long in_chunk_order, out_chunk_order;\n    xen_pfn_t     gpfn, gmfn, mfn;\n    unsigned long i, j, k;\n    unsigned int  memflags = 0;\n    long          rc = 0;\n    struct domain *d;\n    struct page_info *page;\n\n    if ( copy_from_guest(&exch, arg, 1) )\n        return -EFAULT;\n\n    if ( max(exch.in.extent_order, exch.out.extent_order) >\n         max_order(current->domain) )\n    {\n        rc = -EPERM;\n        goto fail_early;\n    }\n\n    /* Various sanity checks. */\n    if ( (exch.nr_exchanged > exch.in.nr_extents) ||\n         /* Input and output domain identifiers match? */\n         (exch.in.domid != exch.out.domid) ||\n         /* Sizes of input and output lists do not overflow a long? */\n         ((~0UL >> exch.in.extent_order) < exch.in.nr_extents) ||\n         ((~0UL >> exch.out.extent_order) < exch.out.nr_extents) ||\n         /* Sizes of input and output lists match? */\n         ((exch.in.nr_extents << exch.in.extent_order) !=\n          (exch.out.nr_extents << exch.out.extent_order)) )\n    {\n        rc = -EINVAL;\n        goto fail_early;\n    }\n\n    if ( !guest_handle_subrange_okay(exch.in.extent_start, exch.nr_exchanged,\n                                     exch.in.nr_extents - 1) )\n    {\n        rc = -EFAULT;\n        goto fail_early;\n    }\n\n    if ( exch.in.extent_order <= exch.out.extent_order )\n    {\n        in_chunk_order  = exch.out.extent_order - exch.in.extent_order;\n        out_chunk_order = 0;\n\n        if ( !guest_handle_subrange_okay(exch.out.extent_start,\n                                         exch.nr_exchanged >> in_chunk_order,\n                                         exch.out.nr_extents - 1) )\n        {\n            rc = -EFAULT;\n            goto fail_early;\n        }\n    }\n    else\n    {\n        in_chunk_order  = 0;\n        out_chunk_order = exch.in.extent_order - exch.out.extent_order;\n\n        if ( !guest_handle_subrange_okay(exch.out.extent_start,\n                                         exch.nr_exchanged << out_chunk_order,\n                                         exch.out.nr_extents - 1) )\n        {\n            rc = -EFAULT;\n            goto fail_early;\n        }\n    }\n\n    d = rcu_lock_domain_by_any_id(exch.in.domid);\n    if ( d == NULL )\n    {\n        rc = -ESRCH;\n        goto fail_early;\n    }\n\n    rc = xsm_memory_exchange(XSM_TARGET, d);\n    if ( rc )\n    {\n        rcu_unlock_domain(d);\n        goto fail_early;\n    }\n\n    memflags |= MEMF_bits(domain_clamp_alloc_bitsize(\n        d,\n        XENMEMF_get_address_bits(exch.out.mem_flags) ? :\n        (BITS_PER_LONG+PAGE_SHIFT)));\n    memflags |= MEMF_node(XENMEMF_get_node(exch.out.mem_flags));\n\n    for ( i = (exch.nr_exchanged >> in_chunk_order);\n          i < (exch.in.nr_extents >> in_chunk_order);\n          i++ )\n    {\n        if ( i != (exch.nr_exchanged >> in_chunk_order) &&\n             hypercall_preempt_check() )\n        {\n            exch.nr_exchanged = i << in_chunk_order;\n            rcu_unlock_domain(d);\n            if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n                return -EFAULT;\n            return hypercall_create_continuation(\n                __HYPERVISOR_memory_op, \"lh\", XENMEM_exchange, arg);\n        }\n\n        /* Steal a chunk's worth of input pages from the domain. */\n        for ( j = 0; j < (1UL << in_chunk_order); j++ )\n        {\n            if ( unlikely(__copy_from_guest_offset(\n                &gmfn, exch.in.extent_start, (i<<in_chunk_order)+j, 1)) )\n            {\n                rc = -EFAULT;\n                goto fail;\n            }\n\n            for ( k = 0; k < (1UL << exch.in.extent_order); k++ )\n            {\n#ifdef CONFIG_X86\n                p2m_type_t p2mt;\n\n                /* Shared pages cannot be exchanged */\n                mfn = mfn_x(get_gfn_unshare(d, gmfn + k, &p2mt));\n                if ( p2m_is_shared(p2mt) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -ENOMEM;\n                    goto fail; \n                }\n#else /* !CONFIG_X86 */\n                mfn = mfn_x(gfn_to_mfn(d, _gfn(gmfn + k)));\n#endif\n                if ( unlikely(!mfn_valid(_mfn(mfn))) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -EINVAL;\n                    goto fail;\n                }\n\n                page = mfn_to_page(mfn);\n\n                if ( unlikely(steal_page(d, page, MEMF_no_refcount)) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -EINVAL;\n                    goto fail;\n                }\n\n                page_list_add(page, &in_chunk_list);\n                put_gfn(d, gmfn + k);\n            }\n        }\n\n        /* Allocate a chunk's worth of anonymous output pages. */\n        for ( j = 0; j < (1UL << out_chunk_order); j++ )\n        {\n            page = alloc_domheap_pages(d, exch.out.extent_order,\n                                       MEMF_no_owner | memflags);\n            if ( unlikely(page == NULL) )\n            {\n                rc = -ENOMEM;\n                goto fail;\n            }\n\n            page_list_add(page, &out_chunk_list);\n        }\n\n        /*\n         * Success! Beyond this point we cannot fail for this chunk.\n         */\n\n        /* Destroy final reference to each input page. */\n        while ( (page = page_list_remove_head(&in_chunk_list)) )\n        {\n            unsigned long gfn;\n\n            if ( !test_and_clear_bit(_PGC_allocated, &page->count_info) )\n                BUG();\n            mfn = page_to_mfn(page);\n            gfn = mfn_to_gmfn(d, mfn);\n            /* Pages were unshared above */\n            BUG_ON(SHARED_M2P(gfn));\n            guest_physmap_remove_page(d, _gfn(gfn), _mfn(mfn), 0);\n            put_page(page);\n        }\n\n        /* Assign each output page to the domain. */\n        for ( j = 0; (page = page_list_remove_head(&out_chunk_list)); ++j )\n        {\n            if ( assign_pages(d, page, exch.out.extent_order,\n                              MEMF_no_refcount) )\n            {\n                unsigned long dec_count;\n                bool_t drop_dom_ref;\n\n                /*\n                 * Pages in in_chunk_list is stolen without\n                 * decreasing the tot_pages. If the domain is dying when\n                 * assign pages, we need decrease the count. For those pages\n                 * that has been assigned, it should be covered by\n                 * domain_relinquish_resources().\n                 */\n                dec_count = (((1UL << exch.in.extent_order) *\n                              (1UL << in_chunk_order)) -\n                             (j * (1UL << exch.out.extent_order)));\n\n                spin_lock(&d->page_alloc_lock);\n                drop_dom_ref = (dec_count &&\n                                !domain_adjust_tot_pages(d, -dec_count));\n                spin_unlock(&d->page_alloc_lock);\n\n                if ( drop_dom_ref )\n                    put_domain(d);\n\n                free_domheap_pages(page, exch.out.extent_order);\n                goto dying;\n            }\n\n            if ( __copy_from_guest_offset(&gpfn, exch.out.extent_start,\n                                          (i << out_chunk_order) + j, 1) )\n            {\n                rc = -EFAULT;\n                continue;\n            }\n\n            mfn = page_to_mfn(page);\n            guest_physmap_add_page(d, _gfn(gpfn), _mfn(mfn),\n                                   exch.out.extent_order);\n\n            if ( !paging_mode_translate(d) )\n            {\n                for ( k = 0; k < (1UL << exch.out.extent_order); k++ )\n                    set_gpfn_from_mfn(mfn + k, gpfn + k);\n                if ( __copy_to_guest_offset(exch.out.extent_start,\n                                            (i << out_chunk_order) + j,\n                                            &mfn, 1) )\n                    rc = -EFAULT;\n            }\n        }\n        BUG_ON( !(d->is_dying) && (j != (1UL << out_chunk_order)) );\n    }\n\n    exch.nr_exchanged = exch.in.nr_extents;\n    if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n        rc = -EFAULT;\n    rcu_unlock_domain(d);\n    return rc;\n\n    /*\n     * Failed a chunk! Free any partial chunk work. Tell caller how many\n     * chunks succeeded.\n     */\n fail:\n    /* Reassign any input pages we managed to steal. */\n    while ( (page = page_list_remove_head(&in_chunk_list)) )\n        if ( assign_pages(d, page, 0, MEMF_no_refcount) )\n        {\n            BUG_ON(!d->is_dying);\n            if ( test_and_clear_bit(_PGC_allocated, &page->count_info) )\n                put_page(page);\n        }\n\n dying:\n    rcu_unlock_domain(d);\n    /* Free any output pages we managed to allocate. */\n    while ( (page = page_list_remove_head(&out_chunk_list)) )\n        free_domheap_pages(page, exch.out.extent_order);\n\n    exch.nr_exchanged = i << in_chunk_order;\n\n fail_early:\n    if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n        rc = -EFAULT;\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,8 +36,8 @@\n         goto fail_early;\n     }\n \n-    if ( !guest_handle_okay(exch.in.extent_start, exch.in.nr_extents) ||\n-         !guest_handle_okay(exch.out.extent_start, exch.out.nr_extents) )\n+    if ( !guest_handle_subrange_okay(exch.in.extent_start, exch.nr_exchanged,\n+                                     exch.in.nr_extents - 1) )\n     {\n         rc = -EFAULT;\n         goto fail_early;\n@@ -47,11 +47,27 @@\n     {\n         in_chunk_order  = exch.out.extent_order - exch.in.extent_order;\n         out_chunk_order = 0;\n+\n+        if ( !guest_handle_subrange_okay(exch.out.extent_start,\n+                                         exch.nr_exchanged >> in_chunk_order,\n+                                         exch.out.nr_extents - 1) )\n+        {\n+            rc = -EFAULT;\n+            goto fail_early;\n+        }\n     }\n     else\n     {\n         in_chunk_order  = 0;\n         out_chunk_order = exch.in.extent_order - exch.out.extent_order;\n+\n+        if ( !guest_handle_subrange_okay(exch.out.extent_start,\n+                                         exch.nr_exchanged << out_chunk_order,\n+                                         exch.out.nr_extents - 1) )\n+        {\n+            rc = -EFAULT;\n+            goto fail_early;\n+        }\n     }\n \n     d = rcu_lock_domain_by_any_id(exch.in.domid);",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( !guest_handle_okay(exch.in.extent_start, exch.in.nr_extents) ||",
                "         !guest_handle_okay(exch.out.extent_start, exch.out.nr_extents) )"
            ],
            "added_lines": [
                "    if ( !guest_handle_subrange_okay(exch.in.extent_start, exch.nr_exchanged,",
                "                                     exch.in.nr_extents - 1) )",
                "",
                "        if ( !guest_handle_subrange_okay(exch.out.extent_start,",
                "                                         exch.nr_exchanged >> in_chunk_order,",
                "                                         exch.out.nr_extents - 1) )",
                "        {",
                "            rc = -EFAULT;",
                "            goto fail_early;",
                "        }",
                "",
                "        if ( !guest_handle_subrange_okay(exch.out.extent_start,",
                "                                         exch.nr_exchanged << out_chunk_order,",
                "                                         exch.out.nr_extents - 1) )",
                "        {",
                "            rc = -EFAULT;",
                "            goto fail_early;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8797",
        "func_name": "torvalds/linux/nfsd4_layout_verify",
        "description": "The NFSv4 server in the Linux kernel before 4.11.3 does not properly validate the layout type when processing the NFSv4 pNFS GETDEVICEINFO or LAYOUTGET operand in a UDP packet from a remote attacker. This type value is uninitialized upon encountering certain error conditions. This value is used as an array index for dereferencing, which leads to an OOPS and eventually a DoS of knfsd and a soft-lockup of the whole system.",
        "git_url": "https://github.com/torvalds/linux/commit/b550a32e60a4941994b437a8d662432a486235a5",
        "commit_title": "nfsd: fix undefined behavior in nfsd4_layout_verify",
        "commit_text": "   UBSAN: Undefined behaviour in fs/nfsd/nfs4proc.c:1262:34   shift exponent 128 is too large for 32-bit type 'int'  Depending on compiler+architecture, this may cause the check for layout_type to succeed for overly large values (which seems to be the case with amd64). The large value will be later used in de-referencing nfsd4_layout_ops for function pointers.  [colin.king@canonical.com: use LAYOUT_TYPE_MAX instead of 32] Cc: stable@vger.kernel.org",
        "func_before": "static const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
        "func": "static const struct nfsd4_layout_ops *\nnfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (layout_type >= LAYOUT_TYPE_MAX ||\n\t    !(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,8 @@\n \t\treturn NULL;\n \t}\n \n-\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n+\tif (layout_type >= LAYOUT_TYPE_MAX ||\n+\t    !(exp->ex_layout_types & (1 << layout_type))) {\n \t\tdprintk(\"%s: layout type %d not supported\\n\",\n \t\t\t__func__, layout_type);\n \t\treturn NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!(exp->ex_layout_types & (1 << layout_type))) {"
            ],
            "added_lines": [
                "\tif (layout_type >= LAYOUT_TYPE_MAX ||",
                "\t    !(exp->ex_layout_types & (1 << layout_type))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8797",
        "func_name": "torvalds/linux/nfsd4_encode_getdeviceinfo",
        "description": "The NFSv4 server in the Linux kernel before 4.11.3 does not properly validate the layout type when processing the NFSv4 pNFS GETDEVICEINFO or LAYOUTGET operand in a UDP packet from a remote attacker. This type value is uninitialized upon encountering certain error conditions. This value is used as an array index for dereferencing, which leads to an OOPS and eventually a DoS of knfsd and a soft-lockup of the whole system.",
        "git_url": "https://github.com/torvalds/linux/commit/f961e3f2acae94b727380c0b74e2d3954d0edf79",
        "commit_title": "nfsd: encoders mustn't use unitialized values in error cases",
        "commit_text": " In error cases, lgp->lg_layout_type may be out of bounds; so we shouldn't be using it until after the check of nfserr.  This was seen to crash nfsd threads when the server receives a LAYOUTGET request with a large layout type.  GETDEVICEINFO has the same problem.  Cc: stable@vger.kernel.org",
        "func_before": "static __be32\nnfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, be32_to_cpu(nfserr));\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\n\t/* If maxcount is 0 then just update notifications */\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\t/*\n\t\t\t * We don't bother to burden the layout drivers with\n\t\t\t * enforcing gd_maxcount, just tell the client to\n\t\t\t * come back with a bigger buffer if it's not enough.\n\t\t\t */\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t/* bitmap length */\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\n\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 /* notifications */;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}",
        "func": "static __be32\nnfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops;\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, be32_to_cpu(nfserr));\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\n\t/* If maxcount is 0 then just update notifications */\n\tif (gdev->gd_maxcount != 0) {\n\t\tops = nfsd4_layout_ops[gdev->gd_layout_type];\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\t/*\n\t\t\t * We don't bother to burden the layout drivers with\n\t\t\t * enforcing gd_maxcount, just tell the client to\n\t\t\t * come back with a bigger buffer if it's not enough.\n\t\t\t */\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t/* bitmap length */\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\n\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 /* notifications */;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,7 @@\n \t\tstruct nfsd4_getdeviceinfo *gdev)\n {\n \tstruct xdr_stream *xdr = &resp->xdr;\n-\tconst struct nfsd4_layout_ops *ops =\n-\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n+\tconst struct nfsd4_layout_ops *ops;\n \tu32 starting_len = xdr->buf->len, needed_len;\n \t__be32 *p;\n \n@@ -21,6 +20,7 @@\n \n \t/* If maxcount is 0 then just update notifications */\n \tif (gdev->gd_maxcount != 0) {\n+\t\tops = nfsd4_layout_ops[gdev->gd_layout_type];\n \t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n \t\tif (nfserr) {\n \t\t\t/*",
        "diff_line_info": {
            "deleted_lines": [
                "\tconst struct nfsd4_layout_ops *ops =",
                "\t\tnfsd4_layout_ops[gdev->gd_layout_type];"
            ],
            "added_lines": [
                "\tconst struct nfsd4_layout_ops *ops;",
                "\t\tops = nfsd4_layout_ops[gdev->gd_layout_type];"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8797",
        "func_name": "torvalds/linux/nfsd4_encode_layoutget",
        "description": "The NFSv4 server in the Linux kernel before 4.11.3 does not properly validate the layout type when processing the NFSv4 pNFS GETDEVICEINFO or LAYOUTGET operand in a UDP packet from a remote attacker. This type value is uninitialized upon encountering certain error conditions. This value is used as an array index for dereferencing, which leads to an OOPS and eventually a DoS of knfsd and a soft-lockup of the whole system.",
        "git_url": "https://github.com/torvalds/linux/commit/f961e3f2acae94b727380c0b74e2d3954d0edf79",
        "commit_title": "nfsd: encoders mustn't use unitialized values in error cases",
        "commit_text": " In error cases, lgp->lg_layout_type may be out of bounds; so we shouldn't be using it until after the check of nfserr.  This was seen to crash nfsd threads when the server receives a LAYOUTGET request with a large layout type.  GETDEVICEINFO has the same problem.  Cc: stable@vger.kernel.org",
        "func_before": "static __be32\nnfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}",
        "func": "static __be32\nnfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops;\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\n\tops = nfsd4_layout_ops[lgp->lg_layout_type];\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,7 @@\n \t\tstruct nfsd4_layoutget *lgp)\n {\n \tstruct xdr_stream *xdr = &resp->xdr;\n-\tconst struct nfsd4_layout_ops *ops =\n-\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n+\tconst struct nfsd4_layout_ops *ops;\n \t__be32 *p;\n \n \tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n@@ -27,6 +26,7 @@\n \t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n \t*p++ = cpu_to_be32(lgp->lg_layout_type);\n \n+\tops = nfsd4_layout_ops[lgp->lg_layout_type];\n \tnfserr = ops->encode_layoutget(xdr, lgp);\n out:\n \tkfree(lgp->lg_content);",
        "diff_line_info": {
            "deleted_lines": [
                "\tconst struct nfsd4_layout_ops *ops =",
                "\t\tnfsd4_layout_ops[lgp->lg_layout_type];"
            ],
            "added_lines": [
                "\tconst struct nfsd4_layout_ops *ops;",
                "\tops = nfsd4_layout_ops[lgp->lg_layout_type];"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-13302",
        "func_name": "ffmpeg/handle_eac3",
        "description": "In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/ed22dc22216f74c75ee7901f82649e1ff725ba50",
        "commit_title": "avformat/movenc: Check that frame_types other than EAC3_FRAME_TYPE_INDEPENDENT have a supported substream id",
        "commit_text": " ",
        "func_before": "static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(track->par, \"Multiple independent substreams\");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        }\n\n        /* fill the info needed for the \"dec3\" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);\n                if (ret < 0)\n                    goto end;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info->substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n                cumul_size += hdr->frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6) {\n        ret = pkt->size;\n        goto end;\n    }\n    else if (info->num_blocks + num_blocks > 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info->num_blocks) {\n        ret = av_packet_ref(&info->pkt, pkt);\n        if (!ret)\n            info->num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            goto end;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            goto end;\n        if (info->num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &info->pkt);\n        info->num_blocks = 0;\n    }\n    ret = pkt->size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}",
        "func": "static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    AC3HeaderInfo *hdr = NULL;\n    struct eac3_info *info;\n    int num_blocks, ret;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");\n            ret = 0;\n        } else\n            ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {\n            ret = AVERROR(EINVAL);\n            goto end;\n        }\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1) {\n                ret = AVERROR(EINVAL);\n                goto end;\n            }\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(track->par, \"Multiple independent substreams\");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        } else {\n            if (hdr->substreamid != 0) {\n                avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");\n                ret = AVERROR_PATCHWELCOME;\n                goto end;\n            }\n        }\n\n        /* fill the info needed for the \"dec3\" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                GetBitContext gbc;\n                int i;\n                ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);\n                if (ret < 0)\n                    goto end;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {\n                    ret = AVERROR(EINVAL);\n                    goto end;\n                }\n                info->substream[parent].num_dep_sub++;\n                ret /= 8;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n                cumul_size += hdr->frame_size;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6) {\n        ret = pkt->size;\n        goto end;\n    }\n    else if (info->num_blocks + num_blocks > 6) {\n        ret = AVERROR_INVALIDDATA;\n        goto end;\n    }\n\n    if (!info->num_blocks) {\n        ret = av_packet_ref(&info->pkt, pkt);\n        if (!ret)\n            info->num_blocks = num_blocks;\n        goto end;\n    } else {\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            goto end;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            goto end;\n        if (info->num_blocks != 6)\n            goto end;\n        av_packet_unref(pkt);\n        av_packet_move_ref(pkt, &info->pkt);\n        info->num_blocks = 0;\n    }\n    ret = pkt->size;\n\nend:\n    av_free(hdr);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,6 +46,12 @@\n                        hdr->substreamid == 0 && info->substream[0].bsid) {\n                 info->ec3_done = 1;\n                 goto concatenate;\n+            }\n+        } else {\n+            if (hdr->substreamid != 0) {\n+                avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");\n+                ret = AVERROR_PATCHWELCOME;\n+                goto end;\n             }\n         }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            }",
                "        } else {",
                "            if (hdr->substreamid != 0) {",
                "                avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");",
                "                ret = AVERROR_PATCHWELCOME;",
                "                goto end;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16648",
        "func_name": "ArtifexSoftware/mupdf/pdf_dev_clip_text",
        "description": "In Artifex MuPDF 1.13.0, the fz_append_byte function in fitz/buffer.c allows remote attackers to cause a denial of service (segmentation fault) via a crafted pdf file. This is caused by a pdf/pdf-device.c pdf_dev_alpha array-index underflow.",
        "git_url": "https://github.com/ArtifexSoftware/mupdf/commit/38f883fe129a5e89306252a4676eaaf4bc968824",
        "commit_title": "Fix text used as clip mask in pdfwrite device.",
        "commit_text": " Push the clip state, and pass the correct text rendering mode state.",
        "func_before": "static void\npdf_dev_clip_text(fz_context *ctx, fz_device *dev, const fz_text *text, fz_matrix ctm, fz_rect scissor)\n{\n\tpdf_device *pdev = (pdf_device*)dev;\n\tfz_text_span *span;\n\tfor (span = text->head; span; span = span->next)\n\t{\n\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 0);\n\t\tpdf_dev_ctm(ctx, pdev, ctm);\n\t\tpdf_dev_font(ctx, pdev, span->font);\n\t\tpdf_dev_text_span(ctx, pdev, span);\n\t}\n}",
        "func": "static void\npdf_dev_clip_text(fz_context *ctx, fz_device *dev, const fz_text *text, fz_matrix ctm, fz_rect scissor)\n{\n\tpdf_device *pdev = (pdf_device*)dev;\n\tfz_text_span *span;\n\n\tpdf_dev_end_text(ctx, pdev);\n\tpdf_dev_push(ctx, pdev);\n\n\tfor (span = text->head; span; span = span->next)\n\t{\n\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 7);\n\t\tpdf_dev_ctm(ctx, pdev, ctm);\n\t\tpdf_dev_font(ctx, pdev, span->font);\n\t\tpdf_dev_text_span(ctx, pdev, span);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,13 @@\n {\n \tpdf_device *pdev = (pdf_device*)dev;\n \tfz_text_span *span;\n+\n+\tpdf_dev_end_text(ctx, pdev);\n+\tpdf_dev_push(ctx, pdev);\n+\n \tfor (span = text->head; span; span = span->next)\n \t{\n-\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 0);\n+\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 7);\n \t\tpdf_dev_ctm(ctx, pdev, ctm);\n \t\tpdf_dev_font(ctx, pdev, span->font);\n \t\tpdf_dev_text_span(ctx, pdev, span);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 0);"
            ],
            "added_lines": [
                "",
                "\tpdf_dev_end_text(ctx, pdev);",
                "\tpdf_dev_push(ctx, pdev);",
                "",
                "\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 7);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16648",
        "func_name": "ArtifexSoftware/mupdf/pdf_dev_clip_stroke_text",
        "description": "In Artifex MuPDF 1.13.0, the fz_append_byte function in fitz/buffer.c allows remote attackers to cause a denial of service (segmentation fault) via a crafted pdf file. This is caused by a pdf/pdf-device.c pdf_dev_alpha array-index underflow.",
        "git_url": "https://github.com/ArtifexSoftware/mupdf/commit/38f883fe129a5e89306252a4676eaaf4bc968824",
        "commit_title": "Fix text used as clip mask in pdfwrite device.",
        "commit_text": " Push the clip state, and pass the correct text rendering mode state.",
        "func_before": "static void\npdf_dev_clip_stroke_text(fz_context *ctx, fz_device *dev, const fz_text *text, const fz_stroke_state *stroke, fz_matrix ctm, fz_rect scissor)\n{\n\tpdf_device *pdev = (pdf_device*)dev;\n\tfz_text_span *span;\n\tfor (span = text->head; span; span = span->next)\n\t{\n\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 0);\n\t\tpdf_dev_font(ctx, pdev, span->font);\n\t\tpdf_dev_ctm(ctx, pdev, ctm);\n\t\tpdf_dev_text_span(ctx, pdev, span);\n\t}\n}",
        "func": "static void\npdf_dev_clip_stroke_text(fz_context *ctx, fz_device *dev, const fz_text *text, const fz_stroke_state *stroke, fz_matrix ctm, fz_rect scissor)\n{\n\tpdf_device *pdev = (pdf_device*)dev;\n\tfz_text_span *span;\n\n\tpdf_dev_end_text(ctx, pdev);\n\tpdf_dev_push(ctx, pdev);\n\n\tfor (span = text->head; span; span = span->next)\n\t{\n\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 7);\n\t\tpdf_dev_font(ctx, pdev, span->font);\n\t\tpdf_dev_ctm(ctx, pdev, ctm);\n\t\tpdf_dev_text_span(ctx, pdev, span);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,13 @@\n {\n \tpdf_device *pdev = (pdf_device*)dev;\n \tfz_text_span *span;\n+\n+\tpdf_dev_end_text(ctx, pdev);\n+\tpdf_dev_push(ctx, pdev);\n+\n \tfor (span = text->head; span; span = span->next)\n \t{\n-\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 0);\n+\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 7);\n \t\tpdf_dev_font(ctx, pdev, span->font);\n \t\tpdf_dev_ctm(ctx, pdev, ctm);\n \t\tpdf_dev_text_span(ctx, pdev, span);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 0);"
            ],
            "added_lines": [
                "",
                "\tpdf_dev_end_text(ctx, pdev);",
                "\tpdf_dev_push(ctx, pdev);",
                "",
                "\t\tpdf_dev_begin_text(ctx, pdev, span->trm, 7);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33815",
        "func_name": "ffmpeg/dwa_uncompress",
        "description": "dwa_uncompress in libavcodec/exr.c in FFmpeg 4.4 allows an out-of-bounds array access because dc_count is not strictly checked.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777",
        "commit_title": "avcodec/exr: More strictly check dc_count",
        "commit_text": " ",
        "func_before": "static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    int64_t version, lo_usize, lo_size;\n    int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;\n    int64_t ac_count, dc_count, ac_compression;\n    const int dc_w = td->xsize >> 3;\n    const int dc_h = td->ysize >> 3;\n    GetByteContext gb, agb;\n    int skip, ret;\n\n    if (compressed_size <= 88)\n        return AVERROR_INVALIDDATA;\n\n    version = AV_RL64(src + 0);\n    if (version != 2)\n        return AVERROR_INVALIDDATA;\n\n    lo_usize = AV_RL64(src + 8);\n    lo_size = AV_RL64(src + 16);\n    ac_size = AV_RL64(src + 24);\n    dc_size = AV_RL64(src + 32);\n    rle_csize = AV_RL64(src + 40);\n    rle_usize = AV_RL64(src + 48);\n    rle_raw_size = AV_RL64(src + 56);\n    ac_count = AV_RL64(src + 64);\n    dc_count = AV_RL64(src + 72);\n    ac_compression = AV_RL64(src + 80);\n\n    if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&gb, src + 88, compressed_size - 88);\n    skip = bytestream2_get_le16(&gb);\n    if (skip < 2)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(&gb, skip - 2);\n\n    if (lo_size > 0) {\n        if (lo_usize > uncompressed_size)\n            return AVERROR_INVALIDDATA;\n        bytestream2_skip(&gb, lo_size);\n    }\n\n    if (ac_size > 0) {\n        unsigned long dest_len = ac_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);\n        if (!td->ac_data)\n            return AVERROR(ENOMEM);\n\n        switch (ac_compression) {\n        case 0:\n            ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);\n            if (ret < 0)\n                return ret;\n            break;\n        case 1:\n            if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||\n                dest_len != ac_count * 2LL)\n                return AVERROR_INVALIDDATA;\n            break;\n        default:\n            return AVERROR_INVALIDDATA;\n        }\n\n        bytestream2_skip(&gb, ac_size);\n    }\n\n    if (dc_size > 0) {\n        unsigned long dest_len = dc_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);\n        if (!td->dc_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||\n            (dest_len != dc_count * 2LL))\n            return AVERROR_INVALIDDATA;\n\n        s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);\n        s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);\n\n        bytestream2_skip(&gb, dc_size);\n    }\n\n    if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {\n        unsigned long dest_len = rle_usize;\n\n        av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);\n        if (!td->rle_data)\n            return AVERROR(ENOMEM);\n\n        av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);\n        if (!td->rle_raw_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||\n            (dest_len != rle_usize))\n            return AVERROR_INVALIDDATA;\n\n        ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);\n        if (ret < 0)\n            return ret;\n        bytestream2_skip(&gb, rle_csize);\n    }\n\n    bytestream2_init(&agb, td->ac_data, ac_count * 2);\n\n    for (int y = 0; y < td->ysize; y += 8) {\n        for (int x = 0; x < td->xsize; x += 8) {\n            memset(td->block, 0, sizeof(td->block));\n\n            for (int j = 0; j < 3; j++) {\n                float *block = td->block[j];\n                const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;\n                uint16_t *dc = (uint16_t *)td->dc_data;\n                union av_intfloat32 dc_val;\n\n                dc_val.i = half2float(dc[idx], s->mantissatable,\n                                      s->exponenttable, s->offsettable);\n\n                block[0] = dc_val.f;\n                ac_uncompress(s, &agb, block);\n                dct_inverse(block);\n            }\n\n            {\n                const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;\n                const int o = s->nb_channels == 4;\n                float *bo = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;\n                float *go = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;\n                float *ro = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;\n                float *yb = td->block[0];\n                float *ub = td->block[1];\n                float *vb = td->block[2];\n\n                for (int yy = 0; yy < 8; yy++) {\n                    for (int xx = 0; xx < 8; xx++) {\n                        const int idx = xx + yy * 8;\n\n                        convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);\n\n                        bo[xx] = to_linear(bo[xx], scale);\n                        go[xx] = to_linear(go[xx], scale);\n                        ro[xx] = to_linear(ro[xx], scale);\n                    }\n\n                    bo += td->xsize * s->nb_channels;\n                    go += td->xsize * s->nb_channels;\n                    ro += td->xsize * s->nb_channels;\n                }\n            }\n        }\n    }\n\n    if (s->nb_channels < 4)\n        return 0;\n\n    for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {\n        uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;\n        uint8_t *ai0 = td->rle_raw_data + y * td->xsize;\n        uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;\n\n        for (int x = 0; x < td->xsize; x++) {\n            uint16_t ha = ai0[x] | (ai1[x] << 8);\n\n            ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);\n        }\n    }\n\n    return 0;\n}",
        "func": "static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                          int uncompressed_size, EXRThreadData *td)\n{\n    int64_t version, lo_usize, lo_size;\n    int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;\n    int64_t ac_count, dc_count, ac_compression;\n    const int dc_w = td->xsize >> 3;\n    const int dc_h = td->ysize >> 3;\n    GetByteContext gb, agb;\n    int skip, ret;\n\n    if (compressed_size <= 88)\n        return AVERROR_INVALIDDATA;\n\n    version = AV_RL64(src + 0);\n    if (version != 2)\n        return AVERROR_INVALIDDATA;\n\n    lo_usize = AV_RL64(src + 8);\n    lo_size = AV_RL64(src + 16);\n    ac_size = AV_RL64(src + 24);\n    dc_size = AV_RL64(src + 32);\n    rle_csize = AV_RL64(src + 40);\n    rle_usize = AV_RL64(src + 48);\n    rle_raw_size = AV_RL64(src + 56);\n    ac_count = AV_RL64(src + 64);\n    dc_count = AV_RL64(src + 72);\n    ac_compression = AV_RL64(src + 80);\n\n    if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_init(&gb, src + 88, compressed_size - 88);\n    skip = bytestream2_get_le16(&gb);\n    if (skip < 2)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(&gb, skip - 2);\n\n    if (lo_size > 0) {\n        if (lo_usize > uncompressed_size)\n            return AVERROR_INVALIDDATA;\n        bytestream2_skip(&gb, lo_size);\n    }\n\n    if (ac_size > 0) {\n        unsigned long dest_len = ac_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);\n        if (!td->ac_data)\n            return AVERROR(ENOMEM);\n\n        switch (ac_compression) {\n        case 0:\n            ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);\n            if (ret < 0)\n                return ret;\n            break;\n        case 1:\n            if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||\n                dest_len != ac_count * 2LL)\n                return AVERROR_INVALIDDATA;\n            break;\n        default:\n            return AVERROR_INVALIDDATA;\n        }\n\n        bytestream2_skip(&gb, ac_size);\n    }\n\n    {\n        unsigned long dest_len = dc_count * 2LL;\n        GetByteContext agb = gb;\n\n        if (dc_count != dc_w * dc_h * 3)\n            return AVERROR_INVALIDDATA;\n\n        av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);\n        if (!td->dc_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||\n            (dest_len != dc_count * 2LL))\n            return AVERROR_INVALIDDATA;\n\n        s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);\n        s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);\n\n        bytestream2_skip(&gb, dc_size);\n    }\n\n    if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {\n        unsigned long dest_len = rle_usize;\n\n        av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);\n        if (!td->rle_data)\n            return AVERROR(ENOMEM);\n\n        av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);\n        if (!td->rle_raw_data)\n            return AVERROR(ENOMEM);\n\n        if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||\n            (dest_len != rle_usize))\n            return AVERROR_INVALIDDATA;\n\n        ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);\n        if (ret < 0)\n            return ret;\n        bytestream2_skip(&gb, rle_csize);\n    }\n\n    bytestream2_init(&agb, td->ac_data, ac_count * 2);\n\n    for (int y = 0; y < td->ysize; y += 8) {\n        for (int x = 0; x < td->xsize; x += 8) {\n            memset(td->block, 0, sizeof(td->block));\n\n            for (int j = 0; j < 3; j++) {\n                float *block = td->block[j];\n                const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;\n                uint16_t *dc = (uint16_t *)td->dc_data;\n                union av_intfloat32 dc_val;\n\n                dc_val.i = half2float(dc[idx], s->mantissatable,\n                                      s->exponenttable, s->offsettable);\n\n                block[0] = dc_val.f;\n                ac_uncompress(s, &agb, block);\n                dct_inverse(block);\n            }\n\n            {\n                const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;\n                const int o = s->nb_channels == 4;\n                float *bo = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;\n                float *go = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;\n                float *ro = ((float *)td->uncompressed_data) +\n                    y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;\n                float *yb = td->block[0];\n                float *ub = td->block[1];\n                float *vb = td->block[2];\n\n                for (int yy = 0; yy < 8; yy++) {\n                    for (int xx = 0; xx < 8; xx++) {\n                        const int idx = xx + yy * 8;\n\n                        convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);\n\n                        bo[xx] = to_linear(bo[xx], scale);\n                        go[xx] = to_linear(go[xx], scale);\n                        ro[xx] = to_linear(ro[xx], scale);\n                    }\n\n                    bo += td->xsize * s->nb_channels;\n                    go += td->xsize * s->nb_channels;\n                    ro += td->xsize * s->nb_channels;\n                }\n            }\n        }\n    }\n\n    if (s->nb_channels < 4)\n        return 0;\n\n    for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {\n        uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;\n        uint8_t *ai0 = td->rle_raw_data + y * td->xsize;\n        uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;\n\n        for (int x = 0; x < td->xsize; x++) {\n            uint16_t ha = ai0[x] | (ai1[x] << 8);\n\n            ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);\n        }\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -72,11 +72,11 @@\n         bytestream2_skip(&gb, ac_size);\n     }\n \n-    if (dc_size > 0) {\n+    {\n         unsigned long dest_len = dc_count * 2LL;\n         GetByteContext agb = gb;\n \n-        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)\n+        if (dc_count != dc_w * dc_h * 3)\n             return AVERROR_INVALIDDATA;\n \n         av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (dc_size > 0) {",
                "        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)"
            ],
            "added_lines": [
                "    {",
                "        if (dc_count != dc_w * dc_h * 3)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-38072",
        "func_name": "admesh/stl_fix_normal_directions",
        "description": "An improper array index validation vulnerability exists in the stl_fix_normal_directions functionality of ADMesh Master Commit 767a105 and v0.98.4. A specially-crafted stl file can lead to a heap buffer overflow. An attacker can provide a malicious file to trigger this vulnerability.",
        "git_url": "https://github.com/admesh/admesh/commit/5fab257268a0ee6f832c18d72af89810a29fbd5f",
        "commit_title": "Check the neighbor_index in stl_check_normal_vector",
        "commit_text": " \r Fixes #60",
        "func_before": "void\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}",
        "func": "void\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,7 +56,8 @@\n         }\n       }\n       /* If this edge of the facet is connected: */\n-      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n+      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n+         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n         /* If we haven't fixed this facet yet, add it to the list: */\n         if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n           /* Add node to beginning of list. */",
        "diff_line_info": {
            "deleted_lines": [
                "      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {"
            ],
            "added_lines": [
                "      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&",
                "         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2008",
        "func_name": "torvalds/linux/udmabuf_vm_fault",
        "description": "A flaw was found in the Linux kernel's udmabuf device driver. The specific flaw exists within a fault handler. The issue results from the lack of proper validation of user-supplied data, which can result in a memory access past the end of an array. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel.",
        "git_url": "https://github.com/torvalds/linux/commit/05b252cccb2e5c3f56119d25de684b4f810ba40a",
        "commit_title": "udmabuf: add back sanity check",
        "commit_text": " Check vm_fault->pgoff before using it.  When we removed the warning, we also removed the check.  Suggested-by: Linus Torvalds <torvalds@linuxfoundation.org>",
        "func_before": "static vm_fault_t udmabuf_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct udmabuf *ubuf = vma->vm_private_data;\n\n\tvmf->page = ubuf->pages[vmf->pgoff];\n\tget_page(vmf->page);\n\treturn 0;\n}",
        "func": "static vm_fault_t udmabuf_vm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct udmabuf *ubuf = vma->vm_private_data;\n\tpgoff_t pgoff = vmf->pgoff;\n\n\tif (pgoff >= ubuf->pagecount)\n\t\treturn VM_FAULT_SIGBUS;\n\tvmf->page = ubuf->pages[pgoff];\n\tget_page(vmf->page);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,11 @@\n {\n \tstruct vm_area_struct *vma = vmf->vma;\n \tstruct udmabuf *ubuf = vma->vm_private_data;\n+\tpgoff_t pgoff = vmf->pgoff;\n \n-\tvmf->page = ubuf->pages[vmf->pgoff];\n+\tif (pgoff >= ubuf->pagecount)\n+\t\treturn VM_FAULT_SIGBUS;\n+\tvmf->page = ubuf->pages[pgoff];\n \tget_page(vmf->page);\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tvmf->page = ubuf->pages[vmf->pgoff];"
            ],
            "added_lines": [
                "\tpgoff_t pgoff = vmf->pgoff;",
                "\tif (pgoff >= ubuf->pagecount)",
                "\t\treturn VM_FAULT_SIGBUS;",
                "\tvmf->page = ubuf->pages[pgoff];"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10663",
        "func_name": "torvalds/linux/sanity_check_ckpt",
        "description": "The sanity_check_ckpt function in fs/f2fs/super.c in the Linux kernel before 4.12.4 does not validate the blkoff and segno arrays, which allows local users to gain privileges via unspecified vectors.",
        "git_url": "https://github.com/torvalds/linux/commit/15d3042a937c13f5d9244241c7a9c8416ff6e82a",
        "commit_title": "f2fs: sanity check checkpoint segno and blkoff",
        "commit_text": " Make sure segno and blkoff read from raw image are valid.  Cc: stable@vger.kernel.org [Jaegeuk Kim: adjust minor coding style]",
        "func_before": "int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned int ovp_segments, reserved_segments;\n\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\n\tovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\treserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\n\tif (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||\n\t\t\tovp_segments == 0 || reserved_segments == 0)) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR,\n\t\t\t\"Wrong layout: check mkfs.f2fs version\");\n\t\treturn 1;\n\t}\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned int ovp_segments, reserved_segments;\n\tunsigned int main_segs, blocks_per_seg;\n\tint i;\n\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\n\tovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\treserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\n\tif (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||\n\t\t\tovp_segments == 0 || reserved_segments == 0)) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR,\n\t\t\t\"Wrong layout: check mkfs.f2fs version\");\n\t\treturn 1;\n\t}\n\n\tmain_segs = le32_to_cpu(raw_super->segment_count_main);\n\tblocks_per_seg = sbi->blocks_per_seg;\n\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tif (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||\n\t\t\tle16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)\n\t\t\treturn 1;\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tif (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||\n\t\t\tle16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)\n\t\t\treturn 1;\n\t}\n\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n \tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n \tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n \tunsigned int ovp_segments, reserved_segments;\n+\tunsigned int main_segs, blocks_per_seg;\n+\tint i;\n \n \ttotal = le32_to_cpu(raw_super->segment_count);\n \tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n@@ -25,6 +27,20 @@\n \t\treturn 1;\n \t}\n \n+\tmain_segs = le32_to_cpu(raw_super->segment_count_main);\n+\tblocks_per_seg = sbi->blocks_per_seg;\n+\n+\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n+\t\tif (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||\n+\t\t\tle16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)\n+\t\t\treturn 1;\n+\t}\n+\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n+\t\tif (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||\n+\t\t\tle16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)\n+\t\t\treturn 1;\n+\t}\n+\n \tif (unlikely(f2fs_cp_error(sbi))) {\n \t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n \t\treturn 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tunsigned int main_segs, blocks_per_seg;",
                "\tint i;",
                "\tmain_segs = le32_to_cpu(raw_super->segment_count_main);",
                "\tblocks_per_seg = sbi->blocks_per_seg;",
                "",
                "\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {",
                "\t\tif (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||",
                "\t\t\tle16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)",
                "\t\t\treturn 1;",
                "\t}",
                "\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {",
                "\t\tif (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||",
                "\t\t\tle16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)",
                "\t\t\treturn 1;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3080",
        "func_name": "torvalds/linux/gdth_read_event",
        "description": "Array index error in the gdth_read_event function in drivers/scsi/gdth.c in the Linux kernel before 2.6.32-rc8 allows local users to cause a denial of service or possibly gain privileges via a negative event index in an IOCTL request.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=690e744869f3262855b83b4fb59199cf142765b0",
        "commit_title": "A negative offset could be used to index before the event buffer and",
        "commit_text": "lead to a security breach.  Cc: Stable Tree <stable@kernel.org> ",
        "func_before": "static int gdth_read_event(gdth_ha_str *ha, int handle, gdth_evt_str *estr)\n{\n    gdth_evt_str *e;\n    int eindex;\n    ulong flags;\n\n    TRACE2((\"gdth_read_event() handle %d\\n\", handle));\n    spin_lock_irqsave(&ha->smp_lock, flags);\n    if (handle == -1)\n        eindex = eoldidx;\n    else\n        eindex = handle;\n    estr->event_source = 0;\n\n    if (eindex >= MAX_EVENTS) {\n        spin_unlock_irqrestore(&ha->smp_lock, flags);\n        return eindex;\n    }\n    e = &ebuffer[eindex];\n    if (e->event_source != 0) {\n        if (eindex != elastidx) {\n            if (++eindex == MAX_EVENTS)\n                eindex = 0;\n        } else {\n            eindex = -1;\n        }\n        memcpy(estr, e, sizeof(gdth_evt_str));\n    }\n    spin_unlock_irqrestore(&ha->smp_lock, flags);\n    return eindex;\n}",
        "func": "static int gdth_read_event(gdth_ha_str *ha, int handle, gdth_evt_str *estr)\n{\n    gdth_evt_str *e;\n    int eindex;\n    ulong flags;\n\n    TRACE2((\"gdth_read_event() handle %d\\n\", handle));\n    spin_lock_irqsave(&ha->smp_lock, flags);\n    if (handle == -1)\n        eindex = eoldidx;\n    else\n        eindex = handle;\n    estr->event_source = 0;\n\n    if (eindex < 0 || eindex >= MAX_EVENTS) {\n        spin_unlock_irqrestore(&ha->smp_lock, flags);\n        return eindex;\n    }\n    e = &ebuffer[eindex];\n    if (e->event_source != 0) {\n        if (eindex != elastidx) {\n            if (++eindex == MAX_EVENTS)\n                eindex = 0;\n        } else {\n            eindex = -1;\n        }\n        memcpy(estr, e, sizeof(gdth_evt_str));\n    }\n    spin_unlock_irqrestore(&ha->smp_lock, flags);\n    return eindex;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n         eindex = handle;\n     estr->event_source = 0;\n \n-    if (eindex >= MAX_EVENTS) {\n+    if (eindex < 0 || eindex >= MAX_EVENTS) {\n         spin_unlock_irqrestore(&ha->smp_lock, flags);\n         return eindex;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (eindex >= MAX_EVENTS) {"
            ],
            "added_lines": [
                "    if (eindex < 0 || eindex >= MAX_EVENTS) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-46152",
        "func_name": "OP-TEE/optee_os/cleanup_shm_refs",
        "description": "OP-TEE Trusted OS is the secure side implementation of OP-TEE project, a Trusted Execution Environment. Versions prior to 3.19.0, contain an Improper Validation of Array Index vulnerability. The function `cleanup_shm_refs()` is called by both `entry_invoke_command()` and `entry_open_session()`. The commands `OPTEE_MSG_CMD_OPEN_SESSION` and `OPTEE_MSG_CMD_INVOKE_COMMAND` can be executed from the normal world via an OP-TEE SMC. This function is not validating the `num_params` argument, which is only limited to `OPTEE_MSG_MAX_NUM_PARAMS` (127) in the function `get_cmd_buffer()`. Therefore, an attacker in the normal world can craft an SMC call that will cause out-of-bounds reading in `cleanup_shm_refs` and potentially freeing of fake-objects in the function `mobj_put()`. A normal-world attacker with permission to execute SMC instructions may exploit this flaw. Maintainers believe this problem permits local privilege escalation from the normal world to the secure world. Version 3.19.0 contains a fix for this issue. There are no known workarounds.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/728616b28df659cf0bdde6e58a471f6ef25d023c",
        "commit_title": "core: tee_entry: fix array out of bounds check in cleanup_shm_refs()",
        "commit_text": " cleanup_shm_refs() can be called with num_params larger than what has been used by copy_in_params(). If num_params is larger than TEE_NUM_PARAMS copy_in_params() will return an error and cleanup_shm_refs() is called to clean up.  This leads to accessing uint64_t saved_attr[TEE_NUM_PARAMS] in entry_invoke_command() or entry_open_session() out of bounds and possibly also the u[TEE_NUM_PARAMS] array in struct tee_ta_param.  So fix this by capping num_params TEE_NUM_PARAMS in cleanup_shm_refs(). ",
        "func_before": "static void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "func": "static void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < MIN((unsigned int)TEE_NUM_PARAMS, num_params); n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n \tsize_t n;\n \n-\tfor (n = 0; n < num_params; n++) {\n+\tfor (n = 0; n < MIN((unsigned int)TEE_NUM_PARAMS, num_params); n++) {\n \t\tswitch (saved_attr[n]) {\n \t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n \t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:",
        "diff_line_info": {
            "deleted_lines": [
                "\tfor (n = 0; n < num_params; n++) {"
            ],
            "added_lines": [
                "\tfor (n = 0; n < MIN((unsigned int)TEE_NUM_PARAMS, num_params); n++) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11489",
        "func_name": "pts/sam2p/in_tga_reader",
        "description": "The DGifDecompressLine function in dgif_lib.c in GIFLIB (possibly version 3.0.x), as later shipped in cgif.c in sam2p 0.49.4, has a heap-based buffer overflow because a certain CrntCode array index is not checked. This will lead to a denial of service or possibly unspecified other impact.",
        "git_url": "https://github.com/pts/sam2p/commit/852244f8df7a862f9bba3946c3ef529e96d0e433",
        "commit_title": "bugfix: fixed free for 2018-07-sam2p-crashes/crash-001.gif in https://github.com/pts/sam2p/issues/37",
        "commit_text": "",
        "func_before": "static Image::Sampled *in_tga_reader(Image::Loader::UFD *ufd, SimBuffer::Flat const&) {\n  Image::Sampled *ret=0;\n  bitmap_type bitmap=tga_load_image(((Filter::UngetFILED*)ufd)->getFILE(/*seekable:*/false));\n  /* Imp: Work without duplicated memory allocation */\n  if (BITMAP_PLANES(bitmap)==1) {\n    Image::Gray *img=new Image::Gray(BITMAP_WIDTH(bitmap), BITMAP_HEIGHT(bitmap), 8);\n    memcpy(img->getRowbeg(), BITMAP_BITS(bitmap), (slen_t)BITMAP_WIDTH(bitmap)*BITMAP_HEIGHT(bitmap));\n    ret=img;\n  } else if (BITMAP_PLANES(bitmap)==3) {\n    Image::RGB *img=new Image::RGB(BITMAP_WIDTH(bitmap), BITMAP_HEIGHT(bitmap), 8);\n    memcpy(img->getRowbeg(), BITMAP_BITS(bitmap), (slen_t)3*BITMAP_WIDTH(bitmap)*BITMAP_HEIGHT(bitmap));\n    ret=img;\n  } else assert(0 && \"invalid TGA depth\");\n  delete [] BITMAP_BITS(bitmap);\n  return ret;\n}",
        "func": "static Image::Sampled *in_tga_reader(Image::Loader::UFD *ufd, SimBuffer::Flat const&) {\n  Image::Sampled *ret=0;\n  bitmap_type bitmap=tga_load_image(((Filter::UngetFILED*)ufd)->getFILE(/*seekable:*/false));\n  /* Imp: Work without duplicated memory allocation */\n  if (BITMAP_PLANES(bitmap)==1) {\n    Image::Gray *img=new Image::Gray(BITMAP_WIDTH(bitmap), BITMAP_HEIGHT(bitmap), 8);\n    memcpy(img->getRowbeg(), BITMAP_BITS(bitmap), (slen_t)BITMAP_WIDTH(bitmap)*BITMAP_HEIGHT(bitmap));\n    ret=img;\n  } else if (BITMAP_PLANES(bitmap)==3) {\n    Image::RGB *img=new Image::RGB(BITMAP_WIDTH(bitmap), BITMAP_HEIGHT(bitmap), 8);\n    memcpy(img->getRowbeg(), BITMAP_BITS(bitmap), (slen_t)3*BITMAP_WIDTH(bitmap)*BITMAP_HEIGHT(bitmap));\n    ret=img;\n  } else assert(0 && \"invalid TGA depth\");\n  free(BITMAP_BITS(bitmap));\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,6 @@\n     memcpy(img->getRowbeg(), BITMAP_BITS(bitmap), (slen_t)3*BITMAP_WIDTH(bitmap)*BITMAP_HEIGHT(bitmap));\n     ret=img;\n   } else assert(0 && \"invalid TGA depth\");\n-  delete [] BITMAP_BITS(bitmap);\n+  free(BITMAP_BITS(bitmap));\n   return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  delete [] BITMAP_BITS(bitmap);"
            ],
            "added_lines": [
                "  free(BITMAP_BITS(bitmap));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11489",
        "func_name": "pts/sam2p/Image::SampledInfo::~SampledInfo",
        "description": "The DGifDecompressLine function in dgif_lib.c in GIFLIB (possibly version 3.0.x), as later shipped in cgif.c in sam2p 0.49.4, has a heap-based buffer overflow because a certain CrntCode array index is not checked. This will lead to a denial of service or possibly unspecified other impact.",
        "git_url": "https://github.com/pts/sam2p/commit/4d3c75c0695b73de8df9dbd2158ebda258937d46",
        "commit_title": "bugfix: fixed delete [] for 2018-07-sam2p-crashes/sample-99 in https://github.com/pts/sam2p/issues/37",
        "commit_text": "",
        "func_before": "Image::SampledInfo::~SampledInfo() {\n  delete img;\n  if (imgs!=NULLP) { Image::Indexed::delete_separated(imgs); delete imgs; }\n}",
        "func": "Image::SampledInfo::~SampledInfo() {\n  delete img;\n  if (imgs!=NULLP) { Image::Indexed::delete_separated(imgs); delete [] imgs; }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n Image::SampledInfo::~SampledInfo() {\n   delete img;\n-  if (imgs!=NULLP) { Image::Indexed::delete_separated(imgs); delete imgs; }\n+  if (imgs!=NULLP) { Image::Indexed::delete_separated(imgs); delete [] imgs; }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (imgs!=NULLP) { Image::Indexed::delete_separated(imgs); delete imgs; }"
            ],
            "added_lines": [
                "  if (imgs!=NULLP) { Image::Indexed::delete_separated(imgs); delete [] imgs; }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11489",
        "func_name": "pts/sam2p/Image::Indexed::separate",
        "description": "The DGifDecompressLine function in dgif_lib.c in GIFLIB (possibly version 3.0.x), as later shipped in cgif.c in sam2p 0.49.4, has a heap-based buffer overflow because a certain CrntCode array index is not checked. This will lead to a denial of service or possibly unspecified other impact.",
        "git_url": "https://github.com/pts/sam2p/commit/af05f34db7c27fbd1931a4aa898e1226623072d5",
        "commit_title": "bugfix: made partial byte generation deterministic in Image::Indexed::separate for 2018-07-sam2p-crashes/sample-100 in https://github.com/pts/sam2p/issues/37",
        "commit_text": "",
        "func_before": "Image::Indexed **Image::Indexed::separate() {\n  assert(getNcols()>=1);\n  unsigned char ncols1=getNcols()-1;\n  signed nncols=getNcols()-(transp==-1 ? 0 : 1);\n  register unsigned char curcol;\n  Indexed **ret=new Indexed*[nncols+1], **curimg=ret;\n  Image::Sampled::dimen_t htc;\n  assert(cpp==1);\n  slen_t wdcpp=wd/* *cpp*/;\n  register unsigned char *p;\n  char *to, *toend;\n  register unsigned int i;\n\n  ret[nncols]=(Indexed*)NULLP;\n  to8();\n  for (curcol=0; curcol<=ncols1; curcol++) {\n    if (transp==(signed int)curcol) continue;\n    curimg[0]=new Indexed(wd, ht, /*ncols:*/2, /*bpc:*/1);\n    memcpy(curimg[0]->headp, headp+3*curcol, 3); /* copy the color value */\n    curimg[0]->setTransp(1);\n    to=curimg[0]->rowbeg; p=(unsigned char*)rowbeg;\n    htc=ht; while (htc--!=0) {\n      toend=to+((wdcpp+7)>>3);\n      while (to!=toend) {\n        i =(*p++!=curcol)<<7; i|=(*p++!=curcol)<<6;\n        i|=(*p++!=curcol)<<5; i|=(*p++!=curcol)<<4;\n        i|=(*p++!=curcol)<<3; i|=(*p++!=curcol)<<2;\n        i|=(*p++!=curcol)<<1; i|=(*p++!=curcol);\n        *to++=i;\n      }\n      if (0!=(wdcpp&7)) p+=(wdcpp&7)-8; /* negative */\n    }\n    curimg++;\n  }\n  assert(curimg==ret+nncols);\n  return ret;\n}",
        "func": "Image::Indexed **Image::Indexed::separate() {\n  assert(getNcols()>=1);\n  unsigned char ncols1=getNcols()-1;\n  signed nncols=getNcols()-(transp==-1 ? 0 : 1);\n  register unsigned char curcol;\n  Indexed **ret=new Indexed*[nncols+1], **curimg=ret;\n  Image::Sampled::dimen_t htc;\n  assert(cpp==1);\n  const slen_t wdcpp=wd/* *cpp*/;\n  register unsigned char *p;\n  char *to, *toend;\n  register unsigned int i;\n\n  ret[nncols]=(Indexed*)NULLP;\n  to8();\n  for (curcol=0; curcol<=ncols1; curcol++) {\n    if (transp==(signed int)curcol) continue;\n    curimg[0]=new Indexed(wd, ht, /*ncols:*/2, /*bpc:*/1);\n    memcpy(curimg[0]->headp, headp+3*curcol, 3); /* copy the color value */\n    curimg[0]->setTransp(1);\n    to=curimg[0]->rowbeg; p=(unsigned char*)rowbeg;\n    htc=ht; while (htc--!=0) {\n      toend=to+(wdcpp>>3);\n      while (to!=toend) {\n        i =(*p++!=curcol)<<7; i|=(*p++!=curcol)<<6;\n        i|=(*p++!=curcol)<<5; i|=(*p++!=curcol)<<4;\n        i|=(*p++!=curcol)<<3; i|=(*p++!=curcol)<<2;\n        i|=(*p++!=curcol)<<1; i|=(*p++!=curcol);\n        *to++=i;\n      }\n      if (0 != (wdcpp & 7)) {\n        i = (*p++ != curcol) << 7;\n        unsigned char j = 6;\n        for (unsigned char *pend = p + (wdcpp & 7) - 1; p != pend; ++p, --j) {\n          i |= (*p != curcol) << j;\n        }\n        *to++ = i;\n      }\n    }\n    curimg++;\n  }\n  assert(curimg==ret+nncols);\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   Indexed **ret=new Indexed*[nncols+1], **curimg=ret;\n   Image::Sampled::dimen_t htc;\n   assert(cpp==1);\n-  slen_t wdcpp=wd/* *cpp*/;\n+  const slen_t wdcpp=wd/* *cpp*/;\n   register unsigned char *p;\n   char *to, *toend;\n   register unsigned int i;\n@@ -20,7 +20,7 @@\n     curimg[0]->setTransp(1);\n     to=curimg[0]->rowbeg; p=(unsigned char*)rowbeg;\n     htc=ht; while (htc--!=0) {\n-      toend=to+((wdcpp+7)>>3);\n+      toend=to+(wdcpp>>3);\n       while (to!=toend) {\n         i =(*p++!=curcol)<<7; i|=(*p++!=curcol)<<6;\n         i|=(*p++!=curcol)<<5; i|=(*p++!=curcol)<<4;\n@@ -28,7 +28,14 @@\n         i|=(*p++!=curcol)<<1; i|=(*p++!=curcol);\n         *to++=i;\n       }\n-      if (0!=(wdcpp&7)) p+=(wdcpp&7)-8; /* negative */\n+      if (0 != (wdcpp & 7)) {\n+        i = (*p++ != curcol) << 7;\n+        unsigned char j = 6;\n+        for (unsigned char *pend = p + (wdcpp & 7) - 1; p != pend; ++p, --j) {\n+          i |= (*p != curcol) << j;\n+        }\n+        *to++ = i;\n+      }\n     }\n     curimg++;\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  slen_t wdcpp=wd/* *cpp*/;",
                "      toend=to+((wdcpp+7)>>3);",
                "      if (0!=(wdcpp&7)) p+=(wdcpp&7)-8; /* negative */"
            ],
            "added_lines": [
                "  const slen_t wdcpp=wd/* *cpp*/;",
                "      toend=to+(wdcpp>>3);",
                "      if (0 != (wdcpp & 7)) {",
                "        i = (*p++ != curcol) << 7;",
                "        unsigned char j = 6;",
                "        for (unsigned char *pend = p + (wdcpp & 7) - 1; p != pend; ++p, --j) {",
                "          i |= (*p != curcol) << j;",
                "        }",
                "        *to++ = i;",
                "      }"
            ]
        }
    }
]