[
    {
        "cve_id": "CVE-2022-2124",
        "func_name": "vim/current_quote",
        "description": "Buffer Over-read in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/2f074f4685897ab7212e25931eeeb0212292829f",
        "commit_title": "patch 8.2.5120: searching for quotes may go over the end of the line",
        "commit_text": " Problem:    Searching for quotes may go over the end of the line. Solution:   Check for running into the NUL.",
        "func_before": "int\ncurrent_quote(\n    oparg_T\t*oap,\n    long\tcount,\n    int\t\tinclude,\t// TRUE == include quote char\n    int\t\tquotechar)\t// Quote character\n{\n    char_u\t*line = ml_get_curline();\n    int\t\tcol_end;\n    int\t\tcol_start = curwin->w_cursor.col;\n    int\t\tinclusive = FALSE;\n    int\t\tvis_empty = TRUE;\t// Visual selection <= 1 char\n    int\t\tvis_bef_curs = FALSE;\t// Visual starts before cursor\n    int\t\tdid_exclusive_adj = FALSE;  // adjusted pos for 'selection'\n    int\t\tinside_quotes = FALSE;\t// Looks like \"i'\" done before\n    int\t\tselected_quote = FALSE;\t// Has quote inside selection\n    int\t\ti;\n    int\t\trestore_vis_bef = FALSE; // restore VIsual on abort\n\n    // When 'selection' is \"exclusive\" move the cursor to where it would be\n    // with 'selection' \"inclusive\", so that the logic is the same for both.\n    // The cursor then is moved forward after adjusting the area.\n    if (VIsual_active)\n    {\n\t// this only works within one line\n\tif (VIsual.lnum != curwin->w_cursor.lnum)\n\t    return FALSE;\n\n\tvis_bef_curs = LT_POS(VIsual, curwin->w_cursor);\n\tvis_empty = EQUAL_POS(VIsual, curwin->w_cursor);\n\tif (*p_sel == 'e')\n\t{\n\t    if (vis_bef_curs)\n\t    {\n\t\tdec_cursor();\n\t\tdid_exclusive_adj = TRUE;\n\t    }\n\t    else if (!vis_empty)\n\t    {\n\t\tdec(&VIsual);\n\t\tdid_exclusive_adj = TRUE;\n\t    }\n\t    vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);\n\t    if (!vis_bef_curs && !vis_empty)\n\t    {\n\t\t// VIsual needs to be the start of Visual selection.\n\t\tpos_T t = curwin->w_cursor;\n\n\t\tcurwin->w_cursor = VIsual;\n\t\tVIsual = t;\n\t\tvis_bef_curs = TRUE;\n\t\trestore_vis_bef = TRUE;\n\t    }\n\t}\n    }\n\n    if (!vis_empty)\n    {\n\t// Check if the existing selection exactly spans the text inside\n\t// quotes.\n\tif (vis_bef_curs)\n\t{\n\t    inside_quotes = VIsual.col > 0\n\t\t\t&& line[VIsual.col - 1] == quotechar\n\t\t\t&& line[curwin->w_cursor.col] != NUL\n\t\t\t&& line[curwin->w_cursor.col + 1] == quotechar;\n\t    i = VIsual.col;\n\t    col_end = curwin->w_cursor.col;\n\t}\n\telse\n\t{\n\t    inside_quotes = curwin->w_cursor.col > 0\n\t\t\t&& line[curwin->w_cursor.col - 1] == quotechar\n\t\t\t&& line[VIsual.col] != NUL\n\t\t\t&& line[VIsual.col + 1] == quotechar;\n\t    i = curwin->w_cursor.col;\n\t    col_end = VIsual.col;\n\t}\n\n\t// Find out if we have a quote in the selection.\n\twhile (i <= col_end)\n\t    if (line[i++] == quotechar)\n\t    {\n\t\tselected_quote = TRUE;\n\t\tbreak;\n\t    }\n    }\n\n    if (!vis_empty && line[col_start] == quotechar)\n    {\n\t// Already selecting something and on a quote character.  Find the\n\t// next quoted string.\n\tif (vis_bef_curs)\n\t{\n\t    // Assume we are on a closing quote: move to after the next\n\t    // opening quote.\n\t    col_start = find_next_quote(line, col_start + 1, quotechar, NULL);\n\t    if (col_start < 0)\n\t\tgoto abort_search;\n\t    col_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (col_end < 0)\n\t    {\n\t\t// We were on a starting quote perhaps?\n\t\tcol_end = col_start;\n\t\tcol_start = curwin->w_cursor.col;\n\t    }\n\t}\n\telse\n\t{\n\t    col_end = find_prev_quote(line, col_start, quotechar, NULL);\n\t    if (line[col_end] != quotechar)\n\t\tgoto abort_search;\n\t    col_start = find_prev_quote(line, col_end, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (line[col_start] != quotechar)\n\t    {\n\t\t// We were on an ending quote perhaps?\n\t\tcol_start = col_end;\n\t\tcol_end = curwin->w_cursor.col;\n\t    }\n\t}\n    }\n    else\n\n    if (line[col_start] == quotechar || !vis_empty)\n    {\n\tint\tfirst_col = col_start;\n\n\tif (!vis_empty)\n\t{\n\t    if (vis_bef_curs)\n\t\tfirst_col = find_next_quote(line, col_start, quotechar, NULL);\n\t    else\n\t\tfirst_col = find_prev_quote(line, col_start, quotechar, NULL);\n\t}\n\n\t// The cursor is on a quote, we don't know if it's the opening or\n\t// closing quote.  Search from the start of the line to find out.\n\t// Also do this when there is a Visual area, a' may leave the cursor\n\t// in between two strings.\n\tcol_start = 0;\n\tfor (;;)\n\t{\n\t    // Find open quote character.\n\t    col_start = find_next_quote(line, col_start, quotechar, NULL);\n\t    if (col_start < 0 || col_start > first_col)\n\t\tgoto abort_search;\n\t    // Find close quote character.\n\t    col_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (col_end < 0)\n\t\tgoto abort_search;\n\t    // If is cursor between start and end quote character, it is\n\t    // target text object.\n\t    if (col_start <= first_col && first_col <= col_end)\n\t\tbreak;\n\t    col_start = col_end + 1;\n\t}\n    }\n    else\n    {\n\t// Search backward for a starting quote.\n\tcol_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe);\n\tif (line[col_start] != quotechar)\n\t{\n\t    // No quote before the cursor, look after the cursor.\n\t    col_start = find_next_quote(line, col_start, quotechar, NULL);\n\t    if (col_start < 0)\n\t\tgoto abort_search;\n\t}\n\n\t// Find close quote character.\n\tcol_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\tif (col_end < 0)\n\t    goto abort_search;\n    }\n\n    // When \"include\" is TRUE, include spaces after closing quote or before\n    // the starting quote.\n    if (include)\n    {\n\tif (VIM_ISWHITE(line[col_end + 1]))\n\t    while (VIM_ISWHITE(line[col_end + 1]))\n\t\t++col_end;\n\telse\n\t    while (col_start > 0 && VIM_ISWHITE(line[col_start - 1]))\n\t\t--col_start;\n    }\n\n    // Set start position.  After vi\" another i\" must include the \".\n    // For v2i\" include the quotes.\n    if (!include && count < 2 && (vis_empty || !inside_quotes))\n\t++col_start;\n    curwin->w_cursor.col = col_start;\n    if (VIsual_active)\n    {\n\t// Set the start of the Visual area when the Visual area was empty, we\n\t// were just inside quotes or the Visual area didn't start at a quote\n\t// and didn't include a quote.\n\tif (vis_empty\n\t\t|| (vis_bef_curs\n\t\t    && !selected_quote\n\t\t    && (inside_quotes\n\t\t\t|| (line[VIsual.col] != quotechar\n\t\t\t    && (VIsual.col == 0\n\t\t\t\t|| line[VIsual.col - 1] != quotechar)))))\n\t{\n\t    VIsual = curwin->w_cursor;\n\t    redraw_curbuf_later(INVERTED);\n\t}\n    }\n    else\n    {\n\toap->start = curwin->w_cursor;\n\toap->motion_type = MCHAR;\n    }\n\n    // Set end position.\n    curwin->w_cursor.col = col_end;\n    if ((include || count > 1 // After vi\" another i\" must include the \".\n\t\t|| (!vis_empty && inside_quotes)\n\t) && inc_cursor() == 2)\n\tinclusive = TRUE;\n    if (VIsual_active)\n    {\n\tif (vis_empty || vis_bef_curs)\n\t{\n\t    // decrement cursor when 'selection' is not exclusive\n\t    if (*p_sel != 'e')\n\t\tdec_cursor();\n\t}\n\telse\n\t{\n\t    // Cursor is at start of Visual area.  Set the end of the Visual\n\t    // area when it was just inside quotes or it didn't end at a\n\t    // quote.\n\t    if (inside_quotes\n\t\t    || (!selected_quote\n\t\t\t&& line[VIsual.col] != quotechar\n\t\t\t&& (line[VIsual.col] == NUL\n\t\t\t    || line[VIsual.col + 1] != quotechar)))\n\t    {\n\t\tdec_cursor();\n\t\tVIsual = curwin->w_cursor;\n\t    }\n\t    curwin->w_cursor.col = col_start;\n\t}\n\tif (VIsual_mode == 'V')\n\t{\n\t    VIsual_mode = 'v';\n\t    redraw_cmdline = TRUE;\t\t// show mode later\n\t}\n    }\n    else\n    {\n\t// Set inclusive and other oap's flags.\n\toap->inclusive = inclusive;\n    }\n\n    return OK;\n\nabort_search:\n    if (VIsual_active && *p_sel == 'e')\n    {\n\tif (did_exclusive_adj)\n\t    inc_cursor();\n\tif (restore_vis_bef)\n\t{\n\t    pos_T t = curwin->w_cursor;\n\n\t    curwin->w_cursor = VIsual;\n\t    VIsual = t;\n\t}\n    }\n    return FALSE;\n}",
        "func": "int\ncurrent_quote(\n    oparg_T\t*oap,\n    long\tcount,\n    int\t\tinclude,\t// TRUE == include quote char\n    int\t\tquotechar)\t// Quote character\n{\n    char_u\t*line = ml_get_curline();\n    int\t\tcol_end;\n    int\t\tcol_start = curwin->w_cursor.col;\n    int\t\tinclusive = FALSE;\n    int\t\tvis_empty = TRUE;\t// Visual selection <= 1 char\n    int\t\tvis_bef_curs = FALSE;\t// Visual starts before cursor\n    int\t\tdid_exclusive_adj = FALSE;  // adjusted pos for 'selection'\n    int\t\tinside_quotes = FALSE;\t// Looks like \"i'\" done before\n    int\t\tselected_quote = FALSE;\t// Has quote inside selection\n    int\t\ti;\n    int\t\trestore_vis_bef = FALSE; // restore VIsual on abort\n\n    // When 'selection' is \"exclusive\" move the cursor to where it would be\n    // with 'selection' \"inclusive\", so that the logic is the same for both.\n    // The cursor then is moved forward after adjusting the area.\n    if (VIsual_active)\n    {\n\t// this only works within one line\n\tif (VIsual.lnum != curwin->w_cursor.lnum)\n\t    return FALSE;\n\n\tvis_bef_curs = LT_POS(VIsual, curwin->w_cursor);\n\tvis_empty = EQUAL_POS(VIsual, curwin->w_cursor);\n\tif (*p_sel == 'e')\n\t{\n\t    if (vis_bef_curs)\n\t    {\n\t\tdec_cursor();\n\t\tdid_exclusive_adj = TRUE;\n\t    }\n\t    else if (!vis_empty)\n\t    {\n\t\tdec(&VIsual);\n\t\tdid_exclusive_adj = TRUE;\n\t    }\n\t    vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);\n\t    if (!vis_bef_curs && !vis_empty)\n\t    {\n\t\t// VIsual needs to be the start of Visual selection.\n\t\tpos_T t = curwin->w_cursor;\n\n\t\tcurwin->w_cursor = VIsual;\n\t\tVIsual = t;\n\t\tvis_bef_curs = TRUE;\n\t\trestore_vis_bef = TRUE;\n\t    }\n\t}\n    }\n\n    if (!vis_empty)\n    {\n\t// Check if the existing selection exactly spans the text inside\n\t// quotes.\n\tif (vis_bef_curs)\n\t{\n\t    inside_quotes = VIsual.col > 0\n\t\t\t&& line[VIsual.col - 1] == quotechar\n\t\t\t&& line[curwin->w_cursor.col] != NUL\n\t\t\t&& line[curwin->w_cursor.col + 1] == quotechar;\n\t    i = VIsual.col;\n\t    col_end = curwin->w_cursor.col;\n\t}\n\telse\n\t{\n\t    inside_quotes = curwin->w_cursor.col > 0\n\t\t\t&& line[curwin->w_cursor.col - 1] == quotechar\n\t\t\t&& line[VIsual.col] != NUL\n\t\t\t&& line[VIsual.col + 1] == quotechar;\n\t    i = curwin->w_cursor.col;\n\t    col_end = VIsual.col;\n\t}\n\n\t// Find out if we have a quote in the selection.\n\twhile (i <= col_end)\n\t{\n\t    // check for going over the end of the line, which can happen if\n\t    // the line was changed after the Visual area was selected.\n\t    if (line[i] == NUL)\n\t\tbreak;\n\t    if (line[i++] == quotechar)\n\t    {\n\t\tselected_quote = TRUE;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (!vis_empty && line[col_start] == quotechar)\n    {\n\t// Already selecting something and on a quote character.  Find the\n\t// next quoted string.\n\tif (vis_bef_curs)\n\t{\n\t    // Assume we are on a closing quote: move to after the next\n\t    // opening quote.\n\t    col_start = find_next_quote(line, col_start + 1, quotechar, NULL);\n\t    if (col_start < 0)\n\t\tgoto abort_search;\n\t    col_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (col_end < 0)\n\t    {\n\t\t// We were on a starting quote perhaps?\n\t\tcol_end = col_start;\n\t\tcol_start = curwin->w_cursor.col;\n\t    }\n\t}\n\telse\n\t{\n\t    col_end = find_prev_quote(line, col_start, quotechar, NULL);\n\t    if (line[col_end] != quotechar)\n\t\tgoto abort_search;\n\t    col_start = find_prev_quote(line, col_end, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (line[col_start] != quotechar)\n\t    {\n\t\t// We were on an ending quote perhaps?\n\t\tcol_start = col_end;\n\t\tcol_end = curwin->w_cursor.col;\n\t    }\n\t}\n    }\n    else\n\n    if (line[col_start] == quotechar || !vis_empty)\n    {\n\tint\tfirst_col = col_start;\n\n\tif (!vis_empty)\n\t{\n\t    if (vis_bef_curs)\n\t\tfirst_col = find_next_quote(line, col_start, quotechar, NULL);\n\t    else\n\t\tfirst_col = find_prev_quote(line, col_start, quotechar, NULL);\n\t}\n\n\t// The cursor is on a quote, we don't know if it's the opening or\n\t// closing quote.  Search from the start of the line to find out.\n\t// Also do this when there is a Visual area, a' may leave the cursor\n\t// in between two strings.\n\tcol_start = 0;\n\tfor (;;)\n\t{\n\t    // Find open quote character.\n\t    col_start = find_next_quote(line, col_start, quotechar, NULL);\n\t    if (col_start < 0 || col_start > first_col)\n\t\tgoto abort_search;\n\t    // Find close quote character.\n\t    col_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\t    if (col_end < 0)\n\t\tgoto abort_search;\n\t    // If is cursor between start and end quote character, it is\n\t    // target text object.\n\t    if (col_start <= first_col && first_col <= col_end)\n\t\tbreak;\n\t    col_start = col_end + 1;\n\t}\n    }\n    else\n    {\n\t// Search backward for a starting quote.\n\tcol_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe);\n\tif (line[col_start] != quotechar)\n\t{\n\t    // No quote before the cursor, look after the cursor.\n\t    col_start = find_next_quote(line, col_start, quotechar, NULL);\n\t    if (col_start < 0)\n\t\tgoto abort_search;\n\t}\n\n\t// Find close quote character.\n\tcol_end = find_next_quote(line, col_start + 1, quotechar,\n\t\t\t\t\t\t\t      curbuf->b_p_qe);\n\tif (col_end < 0)\n\t    goto abort_search;\n    }\n\n    // When \"include\" is TRUE, include spaces after closing quote or before\n    // the starting quote.\n    if (include)\n    {\n\tif (VIM_ISWHITE(line[col_end + 1]))\n\t    while (VIM_ISWHITE(line[col_end + 1]))\n\t\t++col_end;\n\telse\n\t    while (col_start > 0 && VIM_ISWHITE(line[col_start - 1]))\n\t\t--col_start;\n    }\n\n    // Set start position.  After vi\" another i\" must include the \".\n    // For v2i\" include the quotes.\n    if (!include && count < 2 && (vis_empty || !inside_quotes))\n\t++col_start;\n    curwin->w_cursor.col = col_start;\n    if (VIsual_active)\n    {\n\t// Set the start of the Visual area when the Visual area was empty, we\n\t// were just inside quotes or the Visual area didn't start at a quote\n\t// and didn't include a quote.\n\tif (vis_empty\n\t\t|| (vis_bef_curs\n\t\t    && !selected_quote\n\t\t    && (inside_quotes\n\t\t\t|| (line[VIsual.col] != quotechar\n\t\t\t    && (VIsual.col == 0\n\t\t\t\t|| line[VIsual.col - 1] != quotechar)))))\n\t{\n\t    VIsual = curwin->w_cursor;\n\t    redraw_curbuf_later(INVERTED);\n\t}\n    }\n    else\n    {\n\toap->start = curwin->w_cursor;\n\toap->motion_type = MCHAR;\n    }\n\n    // Set end position.\n    curwin->w_cursor.col = col_end;\n    if ((include || count > 1 // After vi\" another i\" must include the \".\n\t\t|| (!vis_empty && inside_quotes)\n\t) && inc_cursor() == 2)\n\tinclusive = TRUE;\n    if (VIsual_active)\n    {\n\tif (vis_empty || vis_bef_curs)\n\t{\n\t    // decrement cursor when 'selection' is not exclusive\n\t    if (*p_sel != 'e')\n\t\tdec_cursor();\n\t}\n\telse\n\t{\n\t    // Cursor is at start of Visual area.  Set the end of the Visual\n\t    // area when it was just inside quotes or it didn't end at a\n\t    // quote.\n\t    if (inside_quotes\n\t\t    || (!selected_quote\n\t\t\t&& line[VIsual.col] != quotechar\n\t\t\t&& (line[VIsual.col] == NUL\n\t\t\t    || line[VIsual.col + 1] != quotechar)))\n\t    {\n\t\tdec_cursor();\n\t\tVIsual = curwin->w_cursor;\n\t    }\n\t    curwin->w_cursor.col = col_start;\n\t}\n\tif (VIsual_mode == 'V')\n\t{\n\t    VIsual_mode = 'v';\n\t    redraw_cmdline = TRUE;\t\t// show mode later\n\t}\n    }\n    else\n    {\n\t// Set inclusive and other oap's flags.\n\toap->inclusive = inclusive;\n    }\n\n    return OK;\n\nabort_search:\n    if (VIsual_active && *p_sel == 'e')\n    {\n\tif (did_exclusive_adj)\n\t    inc_cursor();\n\tif (restore_vis_bef)\n\t{\n\t    pos_T t = curwin->w_cursor;\n\n\t    curwin->w_cursor = VIsual;\n\t    VIsual = t;\n\t}\n    }\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -79,11 +79,17 @@\n \n \t// Find out if we have a quote in the selection.\n \twhile (i <= col_end)\n+\t{\n+\t    // check for going over the end of the line, which can happen if\n+\t    // the line was changed after the Visual area was selected.\n+\t    if (line[i] == NUL)\n+\t\tbreak;\n \t    if (line[i++] == quotechar)\n \t    {\n \t\tselected_quote = TRUE;\n \t\tbreak;\n \t    }\n+\t}\n     }\n \n     if (!vis_empty && line[col_start] == quotechar)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t{",
                "\t    // check for going over the end of the line, which can happen if",
                "\t    // the line was changed after the Visual area was selected.",
                "\t    if (line[i] == NUL)",
                "\t\tbreak;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1720",
        "func_name": "vim/get_visual_text",
        "description": "Buffer Over-read in function grab_file_name in GitHub repository vim/vim prior to 8.2.4956. This vulnerability is capable of crashing the software, memory modification, and possible remote execution.",
        "git_url": "https://github.com/vim/vim/commit/395bd1f6d3edc9f7edb5d1f2d7deaf5a9e3ab93c",
        "commit_title": "patch 8.2.4956: reading past end of line with \"gf\" in Visual block mode",
        "commit_text": " Problem:    Reading past end of line with \"gf\" in Visual block mode. Solution:   Do not include the NUL in the length.",
        "func_before": "int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    // Correct the length to include all bytes of the last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
        "func": "int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,9 +31,16 @@\n \t}\n \tif (**pp == NUL)\n \t    *lenp = 0;\n-\tif (has_mbyte && *lenp > 0)\n-\t    // Correct the length to include all bytes of the last character.\n-\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n+\tif (*lenp > 0)\n+\t{\n+\t    if (has_mbyte)\n+\t\t// Correct the length to include all bytes of the last\n+\t\t// character.\n+\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n+\t    else if ((*pp)[*lenp - 1] == NUL)\n+\t\t// Do not include a trailing NUL.\n+\t\t*lenp -= 1;\n+\t}\n     }\n     reset_VIsual_and_resel();\n     return OK;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (has_mbyte && *lenp > 0)",
                "\t    // Correct the length to include all bytes of the last character.",
                "\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;"
            ],
            "added_lines": [
                "\tif (*lenp > 0)",
                "\t{",
                "\t    if (has_mbyte)",
                "\t\t// Correct the length to include all bytes of the last",
                "\t\t// character.",
                "\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;",
                "\t    else if ((*pp)[*lenp - 1] == NUL)",
                "\t\t// Do not include a trailing NUL.",
                "\t\t*lenp -= 1;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1629",
        "func_name": "vim/find_next_quote",
        "description": "Buffer Over-read in function find_next_quote in GitHub repository vim/vim prior to 8.2.4925. This vulnerabilities are capable of crashing software, Modify Memory, and possible remote execution",
        "git_url": "https://github.com/vim/vim/commit/53a70289c2712808e6d4e88927e03cac01b470dd",
        "commit_title": "patch 8.2.4925: trailing backslash may cause reading past end of line",
        "commit_text": " Problem:    Trailing backslash may cause reading past end of line. Solution:   Check for NUL after backslash.",
        "func_before": "static int\nfind_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t// escape characters, can be NULL\n{\n    int\t\tc;\n\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t    ++col;\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}",
        "func": "static int\nfind_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t// escape characters, can be NULL\n{\n    int\t\tc;\n\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t{\n\t    ++col;\n\t    if (line[col] == NUL)\n\t\treturn -1;\n\t}\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,11 @@\n \tif (c == NUL)\n \t    return -1;\n \telse if (escape != NULL && vim_strchr(escape, c))\n+\t{\n \t    ++col;\n+\t    if (line[col] == NUL)\n+\t\treturn -1;\n+\t}\n \telse if (c == quotechar)\n \t    break;\n \tif (has_mbyte)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t{",
                "\t    if (line[col] == NUL)",
                "\t\treturn -1;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1769",
        "func_name": "vim/get_one_sourceline",
        "description": "Buffer Over-read in GitHub repository vim/vim prior to 8.2.4974.",
        "git_url": "https://github.com/vim/vim/commit/4748c4bd64610cf943a431d215bb1aad51f8d0b4",
        "commit_title": "patch 8.2.4974: \":so\" command may read after end of buffer",
        "commit_text": " Problem:    \":so\" command may read after end of buffer. Solution:   Compute length of text properly.",
        "func_before": "static char_u *\nget_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t}\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}",
        "func": "static char_u *\nget_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t    len = ga.ga_len;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n\t}\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,7 @@\n \t\tbreak;\n \t    buf = (char_u *)ga.ga_data;\n \t    buf[ga.ga_len++] = NUL;\n+\t    len = ga.ga_len;\n \t}\n \telse\n \t{\n@@ -37,8 +38,8 @@\n \t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n \t\t\tsp->fp) == NULL)\n \t\tbreak;\n+\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n \t}\n-\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n #ifdef USE_CRNL\n \t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n \t// CTRL-Z by its own, or after a NL.",
        "diff_line_info": {
            "deleted_lines": [
                "\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);"
            ],
            "added_lines": [
                "\t    len = ga.ga_len;",
                "\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1927",
        "func_name": "vim/parse_cmd_address",
        "description": "Buffer Over-read in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/4d97a565ae8be0d4debba04ebd2ac3e75a0c8010",
        "commit_title": "patch 8.2.5037: cursor position may be invalid after \"0;\" range",
        "commit_text": " Problem:    Cursor position may be invalid after \"0;\" range. Solution:   Check the cursor position when it was set by \";\" in the range.",
        "func_before": "int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    return FAIL;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\treturn FAIL;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    return FAIL;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\treturn FAIL;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\treturn FAIL;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    return OK;\n}",
        "func": "int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n    int\t\tneed_check_cursor = FALSE;\n    int\t\tret = FAIL;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    goto theend;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\tgoto theend;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    goto theend;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly.\n\t\t// Check the cursor position before returning.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t\tneed_check_cursor = TRUE;\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    ret = OK;\n\ntheend:\n    if (need_check_cursor)\n\tcheck_cursor();\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,8 @@\n {\n     int\t\taddress_count = 1;\n     linenr_T\tlnum;\n+    int\t\tneed_check_cursor = FALSE;\n+    int\t\tret = FAIL;\n \n     // Repeat for all ',' or ';' separated addresses.\n     for (;;)\n@@ -13,7 +15,7 @@\n \tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n \t\t\t\t\teap->addr_count == 0, address_count++);\n \tif (eap->cmd == NULL)\t// error detected\n-\t    return FAIL;\n+\t    goto theend;\n \tif (lnum == MAXLNUM)\n \t{\n \t    if (*eap->cmd == '%')   // '%' - all lines\n@@ -58,14 +60,14 @@\n \t\t\t    // there is no Vim command which uses '%' and\n \t\t\t    // ADDR_WINDOWS or ADDR_TABS\n \t\t\t    *errormsg = _(e_invalid_range);\n-\t\t\t    return FAIL;\n+\t\t\t    goto theend;\n \t\t\t}\n \t\t\tbreak;\n \t\t    case ADDR_TABS_RELATIVE:\n \t\t    case ADDR_UNSIGNED:\n \t\t    case ADDR_QUICKFIX:\n \t\t\t*errormsg = _(e_invalid_range);\n-\t\t\treturn FAIL;\n+\t\t\tgoto theend;\n \t\t    case ADDR_ARGUMENTS:\n \t\t\tif (ARGCOUNT == 0)\n \t\t\t    eap->line1 = eap->line2 = 0;\n@@ -97,7 +99,7 @@\n \t\tif (eap->addr_type != ADDR_LINES)\n \t\t{\n \t\t    *errormsg = _(e_invalid_range);\n-\t\t    return FAIL;\n+\t\t    goto theend;\n \t\t}\n \n \t\t++eap->cmd;\n@@ -105,11 +107,11 @@\n \t\t{\n \t\t    fp = getmark('<', FALSE);\n \t\t    if (check_mark(fp) == FAIL)\n-\t\t\treturn FAIL;\n+\t\t\tgoto theend;\n \t\t    eap->line1 = fp->lnum;\n \t\t    fp = getmark('>', FALSE);\n \t\t    if (check_mark(fp) == FAIL)\n-\t\t\treturn FAIL;\n+\t\t\tgoto theend;\n \t\t    eap->line2 = fp->lnum;\n \t\t    ++eap->addr_count;\n \t\t}\n@@ -124,10 +126,13 @@\n \t    if (!eap->skip)\n \t    {\n \t\tcurwin->w_cursor.lnum = eap->line2;\n+\n \t\t// Don't leave the cursor on an illegal line or column, but do\n \t\t// accept zero as address, so 0;/PATTERN/ works correctly.\n+\t\t// Check the cursor position before returning.\n \t\tif (eap->line2 > 0)\n \t\t    check_cursor();\n+\t\tneed_check_cursor = TRUE;\n \t    }\n \t}\n \telse if (*eap->cmd != ',')\n@@ -143,5 +148,10 @@\n \tif (lnum == MAXLNUM)\n \t    eap->addr_count = 0;\n     }\n-    return OK;\n+    ret = OK;\n+\n+theend:\n+    if (need_check_cursor)\n+\tcheck_cursor();\n+    return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t    return FAIL;",
                "\t\t\t    return FAIL;",
                "\t\t\treturn FAIL;",
                "\t\t    return FAIL;",
                "\t\t\treturn FAIL;",
                "\t\t\treturn FAIL;",
                "    return OK;"
            ],
            "added_lines": [
                "    int\t\tneed_check_cursor = FALSE;",
                "    int\t\tret = FAIL;",
                "\t    goto theend;",
                "\t\t\t    goto theend;",
                "\t\t\tgoto theend;",
                "\t\t    goto theend;",
                "\t\t\tgoto theend;",
                "\t\t\tgoto theend;",
                "",
                "\t\t// Check the cursor position before returning.",
                "\t\tneed_check_cursor = TRUE;",
                "    ret = OK;",
                "",
                "theend:",
                "    if (need_check_cursor)",
                "\tcheck_cursor();",
                "    return ret;"
            ]
        }
    }
]