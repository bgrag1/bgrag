[
    {
        "cve_id": "CVE-2012-2143",
        "func_name": "php/php-src/_crypt_extended_r",
        "description": "The crypt_des (aka DES-based crypt) function in FreeBSD before 9.0-RELEASE-p2, as used in PHP, PostgreSQL, and other products, does not process the complete cleartext password if this password contains a 0x80 character, which makes it easier for context-dependent attackers to obtain access via an authentication attempt with an initial substring of the intended password, as demonstrated by a Unicode password.",
        "git_url": "https://github.com/php/php-src/commit/aab49e934de1fff046e659cbec46e3d053b41c34",
        "commit_title": "fix CVE-2012-2143",
        "commit_text": "",
        "func_before": "char *\n_crypt_extended_r(const char *key, const char *setting,\n\tstruct php_crypt_extended_data *data)\n{\n\tint\t\ti;\n\tuint32_t\tcount, salt, l, r0, r1, keybuf[2];\n\tu_char\t\t*p, *q;\n\n\tif (!data->initialized)\n\t\tdes_init_local(data);\n\n\t/*\n\t * Copy the key, shifting each character up by one bit\n\t * and padding with zeros.\n\t */\n\tq = (u_char *) keybuf;\n\twhile (q - (u_char *) keybuf < sizeof(keybuf)) {\n\t\tif ((*q++ = *key << 1))\n\t\t\tkey++;\n\t}\n\tif (des_setkey((u_char *) keybuf, data))\n\t\treturn(NULL);\n\n\tif (*setting == _PASSWORD_EFMT1) {\n\t\t/*\n\t\t * \"new\"-style:\n\t\t *\tsetting - underscore, 4 chars of count, 4 chars of salt\n\t\t *\tkey - unlimited characters\n\t\t */\n\t\tfor (i = 1, count = 0; i < 5; i++) {\n\t\t\tint value = ascii_to_bin(setting[i]);\n\t\t\tif (ascii64[value] != setting[i])\n\t\t\t\treturn(NULL);\n\t\t\tcount |= value << (i - 1) * 6;\n\t\t}\n\t\tif (!count)\n\t\t\treturn(NULL);\n\n\t\tfor (i = 5, salt = 0; i < 9; i++) {\n\t\t\tint value = ascii_to_bin(setting[i]);\n\t\t\tif (ascii64[value] != setting[i])\n\t\t\t\treturn(NULL);\n\t\t\tsalt |= value << (i - 5) * 6;\n\t\t}\n\n\t\twhile (*key) {\n\t\t\t/*\n\t\t\t * Encrypt the key with itself.\n\t\t\t */\n\t\t\tif (des_cipher((u_char *) keybuf, (u_char *) keybuf,\n\t\t\t    0, 1, data))\n\t\t\t\treturn(NULL);\n\t\t\t/*\n\t\t\t * And XOR with the next 8 characters of the key.\n\t\t\t */\n\t\t\tq = (u_char *) keybuf;\n\t\t\twhile (q - (u_char *) keybuf < sizeof(keybuf) && *key)\n\t\t\t\t*q++ ^= *key++ << 1;\n\n\t\t\tif (des_setkey((u_char *) keybuf, data))\n\t\t\t\treturn(NULL);\n\t\t}\n\t\tmemcpy(data->output, setting, 9);\n\t\tdata->output[9] = '\\0';\n\t\tp = (u_char *) data->output + 9;\n\t} else {\n\t\t/*\n\t\t * \"old\"-style:\n\t\t *\tsetting - 2 chars of salt\n\t\t *\tkey - up to 8 characters\n\t\t */\n\t\tcount = 25;\n\n\t\tif (ascii_is_unsafe(setting[0]) || ascii_is_unsafe(setting[1]))\n\t\t\treturn(NULL);\n\n\t\tsalt = (ascii_to_bin(setting[1]) << 6)\n\t\t     |  ascii_to_bin(setting[0]);\n\n\t\tdata->output[0] = setting[0];\n\t\tdata->output[1] = setting[1];\n\t\tp = (u_char *) data->output + 2;\n\t}\n\tsetup_salt(salt, data);\n\t/*\n\t * Do it.\n\t */\n\tif (do_des(0, 0, &r0, &r1, count, data))\n\t\treturn(NULL);\n\t/*\n\t * Now encode the result...\n\t */\n\tl = (r0 >> 8);\n\t*p++ = ascii64[(l >> 18) & 0x3f];\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\n\tl = (r0 << 16) | ((r1 >> 16) & 0xffff);\n\t*p++ = ascii64[(l >> 18) & 0x3f];\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\n\tl = r1 << 2;\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\t*p = 0;\n\n\treturn(data->output);\n}",
        "func": "char *\n_crypt_extended_r(const char *key, const char *setting,\n\tstruct php_crypt_extended_data *data)\n{\n\tint\t\ti;\n\tuint32_t\tcount, salt, l, r0, r1, keybuf[2];\n\tu_char\t\t*p, *q;\n\n\tif (!data->initialized)\n\t\tdes_init_local(data);\n\n\t/*\n\t * Copy the key, shifting each character up by one bit\n\t * and padding with zeros.\n\t */\n\tq = (u_char *) keybuf;\n\twhile (q - (u_char *) keybuf < sizeof(keybuf)) {\n\t\t*q++ = *key << 1;\n\t\tif (*key)\n\t\t\tkey++;\n\t}\n\tif (des_setkey((u_char *) keybuf, data))\n\t\treturn(NULL);\n\n\tif (*setting == _PASSWORD_EFMT1) {\n\t\t/*\n\t\t * \"new\"-style:\n\t\t *\tsetting - underscore, 4 chars of count, 4 chars of salt\n\t\t *\tkey - unlimited characters\n\t\t */\n\t\tfor (i = 1, count = 0; i < 5; i++) {\n\t\t\tint value = ascii_to_bin(setting[i]);\n\t\t\tif (ascii64[value] != setting[i])\n\t\t\t\treturn(NULL);\n\t\t\tcount |= value << (i - 1) * 6;\n\t\t}\n\t\tif (!count)\n\t\t\treturn(NULL);\n\n\t\tfor (i = 5, salt = 0; i < 9; i++) {\n\t\t\tint value = ascii_to_bin(setting[i]);\n\t\t\tif (ascii64[value] != setting[i])\n\t\t\t\treturn(NULL);\n\t\t\tsalt |= value << (i - 5) * 6;\n\t\t}\n\n\t\twhile (*key) {\n\t\t\t/*\n\t\t\t * Encrypt the key with itself.\n\t\t\t */\n\t\t\tif (des_cipher((u_char *) keybuf, (u_char *) keybuf,\n\t\t\t    0, 1, data))\n\t\t\t\treturn(NULL);\n\t\t\t/*\n\t\t\t * And XOR with the next 8 characters of the key.\n\t\t\t */\n\t\t\tq = (u_char *) keybuf;\n\t\t\twhile (q - (u_char *) keybuf < sizeof(keybuf) && *key)\n\t\t\t\t*q++ ^= *key++ << 1;\n\n\t\t\tif (des_setkey((u_char *) keybuf, data))\n\t\t\t\treturn(NULL);\n\t\t}\n\t\tmemcpy(data->output, setting, 9);\n\t\tdata->output[9] = '\\0';\n\t\tp = (u_char *) data->output + 9;\n\t} else {\n\t\t/*\n\t\t * \"old\"-style:\n\t\t *\tsetting - 2 chars of salt\n\t\t *\tkey - up to 8 characters\n\t\t */\n\t\tcount = 25;\n\n\t\tif (ascii_is_unsafe(setting[0]) || ascii_is_unsafe(setting[1]))\n\t\t\treturn(NULL);\n\n\t\tsalt = (ascii_to_bin(setting[1]) << 6)\n\t\t     |  ascii_to_bin(setting[0]);\n\n\t\tdata->output[0] = setting[0];\n\t\tdata->output[1] = setting[1];\n\t\tp = (u_char *) data->output + 2;\n\t}\n\tsetup_salt(salt, data);\n\t/*\n\t * Do it.\n\t */\n\tif (do_des(0, 0, &r0, &r1, count, data))\n\t\treturn(NULL);\n\t/*\n\t * Now encode the result...\n\t */\n\tl = (r0 >> 8);\n\t*p++ = ascii64[(l >> 18) & 0x3f];\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\n\tl = (r0 << 16) | ((r1 >> 16) & 0xffff);\n\t*p++ = ascii64[(l >> 18) & 0x3f];\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\n\tl = r1 << 2;\n\t*p++ = ascii64[(l >> 12) & 0x3f];\n\t*p++ = ascii64[(l >> 6) & 0x3f];\n\t*p++ = ascii64[l & 0x3f];\n\t*p = 0;\n\n\treturn(data->output);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,8 @@\n \t */\n \tq = (u_char *) keybuf;\n \twhile (q - (u_char *) keybuf < sizeof(keybuf)) {\n-\t\tif ((*q++ = *key << 1))\n+\t\t*q++ = *key << 1;\n+\t\tif (*key)\n \t\t\tkey++;\n \t}\n \tif (des_setkey((u_char *) keybuf, data))",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif ((*q++ = *key << 1))"
            ],
            "added_lines": [
                "\t\t*q++ = *key << 1;",
                "\t\tif (*key)"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0166",
        "func_name": "openssl/ASN1_item_verify",
        "description": "OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key.",
        "git_url": "http://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ebc71865f0506a293242bd4aec97cdc7a8ef24b0",
        "commit_title": "",
        "commit_text": "Don't try and verify signatures if key is NULL (CVE-2013-0166) Add additional check to catch this in ASN1_item_verify too. ",
        "func_before": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t     void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type = NULL;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n\n\tint mdnid, pknid;\n\n\tEVP_MD_CTX_init(&ctx);\n\n\t/* Convert signature OID into digest and public key OIDs */\n\tif (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\ttype=EVP_get_digestbynid(mdnid);\n\tif (type == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\n\t/* Check public key OID matches public key type */\n\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\tgoto err;\n\t\t}\n\n\tif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\t\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}",
        "func": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t     void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type = NULL;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n\n\tint mdnid, pknid;\n\n\tif (!pkey)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn -1;\n\t\t}\n\n\tEVP_MD_CTX_init(&ctx);\n\n\t/* Convert signature OID into digest and public key OIDs */\n\tif (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\ttype=EVP_get_digestbynid(mdnid);\n\tif (type == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\n\t/* Check public key OID matches public key type */\n\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\tgoto err;\n\t\t}\n\n\tif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\t\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,12 @@\n \tint ret= -1,inl;\n \n \tint mdnid, pknid;\n+\n+\tif (!pkey)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\n+\t\treturn -1;\n+\t\t}\n \n \tEVP_MD_CTX_init(&ctx);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (!pkey)",
                "\t\t{",
                "\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);",
                "\t\treturn -1;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-0166",
        "func_name": "openssl/OCSP_basic_verify",
        "description": "OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key.",
        "git_url": "http://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ebc71865f0506a293242bd4aec97cdc7a8ef24b0",
        "commit_title": "",
        "commit_text": "Don't try and verify signatures if key is NULL (CVE-2013-0166) Add additional check to catch this in ASN1_item_verify too. ",
        "func_before": "int OCSP_basic_verify(OCSP_BASICRESP *bs, STACK_OF(X509) *certs,\n\t\t\t\tX509_STORE *st, unsigned long flags)\n\t{\n\tX509 *signer, *x;\n\tSTACK_OF(X509) *chain = NULL;\n\tX509_STORE_CTX ctx;\n\tint i, ret = 0;\n\tret = ocsp_find_signer(&signer, bs, certs, st, flags);\n\tif (!ret)\n\t\t{\n\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY, OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);\n\t\tgoto end;\n\t\t}\n\tif ((ret == 2) && (flags & OCSP_TRUSTOTHER))\n\t\tflags |= OCSP_NOVERIFY;\n\tif (!(flags & OCSP_NOSIGS))\n\t\t{\n\t\tEVP_PKEY *skey;\n\t\tskey = X509_get_pubkey(signer);\n\t\tret = OCSP_BASICRESP_verify(bs, skey, 0);\n\t\tEVP_PKEY_free(skey);\n\t\tif(ret <= 0)\n\t\t\t{\n\t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY, OCSP_R_SIGNATURE_FAILURE);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\tif (!(flags & OCSP_NOVERIFY))\n\t\t{\n\t\tint init_res;\n\t\tif(flags & OCSP_NOCHAIN)\n\t\t\tinit_res = X509_STORE_CTX_init(&ctx, st, signer, NULL);\n\t\telse\n\t\t\tinit_res = X509_STORE_CTX_init(&ctx, st, signer, bs->certs);\n\t\tif(!init_res)\n\t\t\t{\n\t\t\tret = -1;\n\t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY,ERR_R_X509_LIB);\n\t\t\tgoto end;\n\t\t\t}\n\n\t\tX509_STORE_CTX_set_purpose(&ctx, X509_PURPOSE_OCSP_HELPER);\n\t\tret = X509_verify_cert(&ctx);\n\t\tchain = X509_STORE_CTX_get1_chain(&ctx);\n\t\tX509_STORE_CTX_cleanup(&ctx);\n                if (ret <= 0)\n\t\t\t{\n\t\t\ti = X509_STORE_CTX_get_error(&ctx);\t\n\t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY,OCSP_R_CERTIFICATE_VERIFY_ERROR);\n\t\t\tERR_add_error_data(2, \"Verify error:\",\n\t\t\t\t\tX509_verify_cert_error_string(i));\n                        goto end;\n                \t}\n\t\tif(flags & OCSP_NOCHECKS)\n\t\t\t{\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t}\n\t\t/* At this point we have a valid certificate chain\n\t\t * need to verify it against the OCSP issuer criteria.\n\t\t */\n\t\tret = ocsp_check_issuer(bs, chain, flags);\n\n\t\t/* If fatal error or valid match then finish */\n\t\tif (ret != 0) goto end;\n\n\t\t/* Easy case: explicitly trusted. Get root CA and\n\t\t * check for explicit trust\n\t\t */\n\t\tif(flags & OCSP_NOEXPLICIT) goto end;\n\n\t\tx = sk_X509_value(chain, sk_X509_num(chain) - 1);\n\t\tif(X509_check_trust(x, NID_OCSP_sign, 0) != X509_TRUST_TRUSTED)\n\t\t\t{\n\t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY,OCSP_R_ROOT_CA_NOT_TRUSTED);\n\t\t\tgoto end;\n\t\t\t}\n\t\tret = 1;\n\t\t}\n\n\n\n\tend:\n\tif(chain) sk_X509_pop_free(chain, X509_free);\n\treturn ret;\n\t}",
        "func": "int OCSP_basic_verify(OCSP_BASICRESP *bs, STACK_OF(X509) *certs,\n\t\t\t\tX509_STORE *st, unsigned long flags)\n\t{\n\tX509 *signer, *x;\n\tSTACK_OF(X509) *chain = NULL;\n\tX509_STORE_CTX ctx;\n\tint i, ret = 0;\n\tret = ocsp_find_signer(&signer, bs, certs, st, flags);\n\tif (!ret)\n\t\t{\n\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY, OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);\n\t\tgoto end;\n\t\t}\n\tif ((ret == 2) && (flags & OCSP_TRUSTOTHER))\n\t\tflags |= OCSP_NOVERIFY;\n\tif (!(flags & OCSP_NOSIGS))\n\t\t{\n\t\tEVP_PKEY *skey;\n\t\tskey = X509_get_pubkey(signer);\n\t\tif (skey)\n\t\t\t{\n\t\t\tret = OCSP_BASICRESP_verify(bs, skey, 0);\n\t\t\tEVP_PKEY_free(skey);\n\t\t\t}\n\t\tif(!skey || ret <= 0)\n\t\t\t{\n\t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY, OCSP_R_SIGNATURE_FAILURE);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\tif (!(flags & OCSP_NOVERIFY))\n\t\t{\n\t\tint init_res;\n\t\tif(flags & OCSP_NOCHAIN)\n\t\t\tinit_res = X509_STORE_CTX_init(&ctx, st, signer, NULL);\n\t\telse\n\t\t\tinit_res = X509_STORE_CTX_init(&ctx, st, signer, bs->certs);\n\t\tif(!init_res)\n\t\t\t{\n\t\t\tret = -1;\n\t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY,ERR_R_X509_LIB);\n\t\t\tgoto end;\n\t\t\t}\n\n\t\tX509_STORE_CTX_set_purpose(&ctx, X509_PURPOSE_OCSP_HELPER);\n\t\tret = X509_verify_cert(&ctx);\n\t\tchain = X509_STORE_CTX_get1_chain(&ctx);\n\t\tX509_STORE_CTX_cleanup(&ctx);\n                if (ret <= 0)\n\t\t\t{\n\t\t\ti = X509_STORE_CTX_get_error(&ctx);\t\n\t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY,OCSP_R_CERTIFICATE_VERIFY_ERROR);\n\t\t\tERR_add_error_data(2, \"Verify error:\",\n\t\t\t\t\tX509_verify_cert_error_string(i));\n                        goto end;\n                \t}\n\t\tif(flags & OCSP_NOCHECKS)\n\t\t\t{\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t}\n\t\t/* At this point we have a valid certificate chain\n\t\t * need to verify it against the OCSP issuer criteria.\n\t\t */\n\t\tret = ocsp_check_issuer(bs, chain, flags);\n\n\t\t/* If fatal error or valid match then finish */\n\t\tif (ret != 0) goto end;\n\n\t\t/* Easy case: explicitly trusted. Get root CA and\n\t\t * check for explicit trust\n\t\t */\n\t\tif(flags & OCSP_NOEXPLICIT) goto end;\n\n\t\tx = sk_X509_value(chain, sk_X509_num(chain) - 1);\n\t\tif(X509_check_trust(x, NID_OCSP_sign, 0) != X509_TRUST_TRUSTED)\n\t\t\t{\n\t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY,OCSP_R_ROOT_CA_NOT_TRUSTED);\n\t\t\tgoto end;\n\t\t\t}\n\t\tret = 1;\n\t\t}\n\n\n\n\tend:\n\tif(chain) sk_X509_pop_free(chain, X509_free);\n\treturn ret;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,9 +17,12 @@\n \t\t{\n \t\tEVP_PKEY *skey;\n \t\tskey = X509_get_pubkey(signer);\n-\t\tret = OCSP_BASICRESP_verify(bs, skey, 0);\n-\t\tEVP_PKEY_free(skey);\n-\t\tif(ret <= 0)\n+\t\tif (skey)\n+\t\t\t{\n+\t\t\tret = OCSP_BASICRESP_verify(bs, skey, 0);\n+\t\t\tEVP_PKEY_free(skey);\n+\t\t\t}\n+\t\tif(!skey || ret <= 0)\n \t\t\t{\n \t\t\tOCSPerr(OCSP_F_OCSP_BASIC_VERIFY, OCSP_R_SIGNATURE_FAILURE);\n \t\t\tgoto end;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tret = OCSP_BASICRESP_verify(bs, skey, 0);",
                "\t\tEVP_PKEY_free(skey);",
                "\t\tif(ret <= 0)"
            ],
            "added_lines": [
                "\t\tif (skey)",
                "\t\t\t{",
                "\t\t\tret = OCSP_BASICRESP_verify(bs, skey, 0);",
                "\t\t\tEVP_PKEY_free(skey);",
                "\t\t\t}",
                "\t\tif(!skey || ret <= 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-5374",
        "func_name": "torvalds/linux/btrfs_mksubvol",
        "description": "The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (extended runtime of kernel code) by creating many different files whose names are associated with the same CRC32C hash value.",
        "git_url": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "commit_title": "Btrfs: fix hash overflow handling",
        "commit_text": " The handling for directory crc hash overflows was fairly obscure, split_leaf returns EOVERFLOW when we try to extend the item and that is supposed to bubble up to userland.  For a while it did so, but along the way we added better handling of errors and forced the FS readonly if we hit IO errors during the directory insertion.  Along the way, we started testing only for EEXIST and the EOVERFLOW case was dropped.  The end result is that we may force the FS readonly if we catch a directory hash bucket overflow.  This fixes a few problem spots.  First I add tests for EOVERFLOW in the places where we can safely just return the error up the chain.  btrfs_rename is harder though, because it tries to insert the new directory item only after it has already unlinked anything the rename was going to overwrite.  Rather than adding very complex logic, I added a helper to test for the hash overflow case early while it is still safe to bail out.  Snapshot and subvolume creation had a similar problem, so they are using the new helper now too. ",
        "func_before": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit **inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(BTRFS_I(dir)->root, dentry,\n\t\t\t\t      name, namelen, async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}",
        "func": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit **inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/*\n\t * even if this name doesn't exist, we may get hash collisions.\n\t * check for them now when we can safely fail\n\t */\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(BTRFS_I(dir)->root, dentry,\n\t\t\t\t      name, namelen, async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,16 @@\n \tif (error)\n \t\tgoto out_dput;\n \n+\t/*\n+\t * even if this name doesn't exist, we may get hash collisions.\n+\t * check for them now when we can safely fail\n+\t */\n+\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n+\t\t\t\t\t       dir->i_ino, name,\n+\t\t\t\t\t       namelen);\n+\tif (error)\n+\t\tgoto out_dput;\n+\n \tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n \n \tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * even if this name doesn't exist, we may get hash collisions.",
                "\t * check for them now when we can safely fail",
                "\t */",
                "\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,",
                "\t\t\t\t\t       dir->i_ino, name,",
                "\t\t\t\t\t       namelen);",
                "\tif (error)",
                "\t\tgoto out_dput;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2012-5374",
        "func_name": "torvalds/linux/btrfs_rename",
        "description": "The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (extended runtime of kernel code) by creating many different files whose names are associated with the same CRC32C hash value.",
        "git_url": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "commit_title": "Btrfs: fix hash overflow handling",
        "commit_text": " The handling for directory crc hash overflows was fairly obscure, split_leaf returns EOVERFLOW when we try to extend the item and that is supposed to bubble up to userland.  For a while it did so, but along the way we added better handling of errors and forced the FS readonly if we hit IO errors during the directory insertion.  Along the way, we started testing only for EEXIST and the EOVERFLOW case was dropped.  The end result is that we may force the FS readonly if we catch a directory hash bucket overflow.  This fixes a few problem spots.  First I add tests for EOVERFLOW in the places where we can safely just return the error up the chain.  btrfs_rename is harder though, because it tries to insert the new directory item only after it has already unlinked anything the rename was going to overwrite.  Rather than adding very complex logic, I added a helper to test for the hash overflow case early while it is still safe to bail out.  Snapshot and subvolume creation had a similar problem, so they are using the new helper now too. ",
        "func_before": "static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = BTRFS_I(old_dir)->root;\n\tstruct btrfs_root *dest = BTRFS_I(new_dir)->root;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct timespec ctime = CURRENT_TIME;\n\tu64 index = 0;\n\tu64 root_objectid;\n\tint ret;\n\tu64 old_ino = btrfs_ino(old_inode);\n\n\tif (btrfs_ino(new_dir) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)\n\t\treturn -EPERM;\n\n\t/* we only allow rename subvolume link between subvolumes */\n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)\n\t\treturn -EXDEV;\n\n\tif (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||\n\t    (new_inode && btrfs_ino(new_inode) == BTRFS_FIRST_FREE_OBJECTID))\n\t\treturn -ENOTEMPTY;\n\n\tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n\t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n\t\treturn -ENOTEMPTY;\n\t/*\n\t * we're using rename to replace one file with another.\n\t * and the replacement file is large.  Start IO on it now so\n\t * we don't add too much work to the end of the transaction\n\t */\n\tif (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size &&\n\t    old_inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)\n\t\tfilemap_flush(old_inode->i_mapping);\n\n\t/* close the racy window with snapshot create/destroy ioctl */\n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\tdown_read(&root->fs_info->subvol_sem);\n\t/*\n\t * We want to reserve the absolute worst case amount of items.  So if\n\t * both inodes are subvols and we need to unlink them then that would\n\t * require 4 item modifications, but if they are both normal inodes it\n\t * would require 5 item modifications, so we'll assume their normal\n\t * inodes.  So 5 * 2 is 10, plus 1 for the new link, so 11 total items\n\t * should cover the worst case number of items we'll modify.\n\t */\n\ttrans = btrfs_start_transaction(root, 20);\n\tif (IS_ERR(trans)) {\n                ret = PTR_ERR(trans);\n                goto out_notrans;\n        }\n\n\tif (dest != root)\n\t\tbtrfs_record_root_in_trans(trans, dest);\n\n\tret = btrfs_set_inode_index(new_dir, &index);\n\tif (ret)\n\t\tgoto out_fail;\n\n\tif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\t/* force full log commit if subvolume involved. */\n\t\troot->fs_info->last_trans_log_full_commit = trans->transid;\n\t} else {\n\t\tret = btrfs_insert_inode_ref(trans, dest,\n\t\t\t\t\t     new_dentry->d_name.name,\n\t\t\t\t\t     new_dentry->d_name.len,\n\t\t\t\t\t     old_ino,\n\t\t\t\t\t     btrfs_ino(new_dir), index);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t\t/*\n\t\t * this is an ugly little race, but the rename is required\n\t\t * to make sure that if we crash, the inode is either at the\n\t\t * old name or the new one.  pinning the log transaction lets\n\t\t * us make sure we don't allow a log commit to come in after\n\t\t * we unlink the name but before we add the new name back in.\n\t\t */\n\t\tbtrfs_pin_log_trans(root);\n\t}\n\t/*\n\t * make sure the inode gets flushed if it is replacing\n\t * something.\n\t */\n\tif (new_inode && new_inode->i_size && S_ISREG(old_inode->i_mode))\n\t\tbtrfs_add_ordered_operation(trans, root, old_inode);\n\n\tinode_inc_iversion(old_dir);\n\tinode_inc_iversion(new_dir);\n\tinode_inc_iversion(old_inode);\n\told_dir->i_ctime = old_dir->i_mtime = ctime;\n\tnew_dir->i_ctime = new_dir->i_mtime = ctime;\n\told_inode->i_ctime = ctime;\n\n\tif (old_dentry->d_parent != new_dentry->d_parent)\n\t\tbtrfs_record_unlink_dir(trans, old_dir, old_inode, 1);\n\n\tif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\troot_objectid = BTRFS_I(old_inode)->root->root_key.objectid;\n\t\tret = btrfs_unlink_subvol(trans, root, old_dir, root_objectid,\n\t\t\t\t\told_dentry->d_name.name,\n\t\t\t\t\told_dentry->d_name.len);\n\t} else {\n\t\tret = __btrfs_unlink_inode(trans, root, old_dir,\n\t\t\t\t\told_dentry->d_inode,\n\t\t\t\t\told_dentry->d_name.name,\n\t\t\t\t\told_dentry->d_name.len);\n\t\tif (!ret)\n\t\t\tret = btrfs_update_inode(trans, root, old_inode);\n\t}\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_fail;\n\t}\n\n\tif (new_inode) {\n\t\tinode_inc_iversion(new_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME;\n\t\tif (unlikely(btrfs_ino(new_inode) ==\n\t\t\t     BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {\n\t\t\troot_objectid = BTRFS_I(new_inode)->location.objectid;\n\t\t\tret = btrfs_unlink_subvol(trans, dest, new_dir,\n\t\t\t\t\t\troot_objectid,\n\t\t\t\t\t\tnew_dentry->d_name.name,\n\t\t\t\t\t\tnew_dentry->d_name.len);\n\t\t\tBUG_ON(new_inode->i_nlink == 0);\n\t\t} else {\n\t\t\tret = btrfs_unlink_inode(trans, dest, new_dir,\n\t\t\t\t\t\t new_dentry->d_inode,\n\t\t\t\t\t\t new_dentry->d_name.name,\n\t\t\t\t\t\t new_dentry->d_name.len);\n\t\t}\n\t\tif (!ret && new_inode->i_nlink == 0) {\n\t\t\tret = btrfs_orphan_add(trans, new_dentry->d_inode);\n\t\t\tBUG_ON(ret);\n\t\t}\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tfixup_inode_flags(new_dir, old_inode);\n\n\tret = btrfs_add_link(trans, new_dir, old_inode,\n\t\t\t     new_dentry->d_name.name,\n\t\t\t     new_dentry->d_name.len, 0, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_fail;\n\t}\n\n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tstruct dentry *parent = new_dentry->d_parent;\n\t\tbtrfs_log_new_name(trans, old_inode, old_dir, parent);\n\t\tbtrfs_end_log_trans(root);\n\t}\nout_fail:\n\tbtrfs_end_transaction(trans, root);\nout_notrans:\n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\tup_read(&root->fs_info->subvol_sem);\n\n\treturn ret;\n}",
        "func": "static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = BTRFS_I(old_dir)->root;\n\tstruct btrfs_root *dest = BTRFS_I(new_dir)->root;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct timespec ctime = CURRENT_TIME;\n\tu64 index = 0;\n\tu64 root_objectid;\n\tint ret;\n\tu64 old_ino = btrfs_ino(old_inode);\n\n\tif (btrfs_ino(new_dir) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)\n\t\treturn -EPERM;\n\n\t/* we only allow rename subvolume link between subvolumes */\n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)\n\t\treturn -EXDEV;\n\n\tif (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||\n\t    (new_inode && btrfs_ino(new_inode) == BTRFS_FIRST_FREE_OBJECTID))\n\t\treturn -ENOTEMPTY;\n\n\tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n\t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n\t\treturn -ENOTEMPTY;\n\n\n\t/* check for collisions, even if the  name isn't there */\n\tret = btrfs_check_dir_item_collision(root, new_dir->i_ino,\n\t\t\t     new_dentry->d_name.name,\n\t\t\t     new_dentry->d_name.len);\n\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\t/* we shouldn't get\n\t\t\t * eexist without a new_inode */\n\t\t\tif (!new_inode) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* maybe -EOVERFLOW */\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = 0;\n\n\t/*\n\t * we're using rename to replace one file with another.\n\t * and the replacement file is large.  Start IO on it now so\n\t * we don't add too much work to the end of the transaction\n\t */\n\tif (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size &&\n\t    old_inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)\n\t\tfilemap_flush(old_inode->i_mapping);\n\n\t/* close the racy window with snapshot create/destroy ioctl */\n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\tdown_read(&root->fs_info->subvol_sem);\n\t/*\n\t * We want to reserve the absolute worst case amount of items.  So if\n\t * both inodes are subvols and we need to unlink them then that would\n\t * require 4 item modifications, but if they are both normal inodes it\n\t * would require 5 item modifications, so we'll assume their normal\n\t * inodes.  So 5 * 2 is 10, plus 1 for the new link, so 11 total items\n\t * should cover the worst case number of items we'll modify.\n\t */\n\ttrans = btrfs_start_transaction(root, 20);\n\tif (IS_ERR(trans)) {\n                ret = PTR_ERR(trans);\n                goto out_notrans;\n        }\n\n\tif (dest != root)\n\t\tbtrfs_record_root_in_trans(trans, dest);\n\n\tret = btrfs_set_inode_index(new_dir, &index);\n\tif (ret)\n\t\tgoto out_fail;\n\n\tif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\t/* force full log commit if subvolume involved. */\n\t\troot->fs_info->last_trans_log_full_commit = trans->transid;\n\t} else {\n\t\tret = btrfs_insert_inode_ref(trans, dest,\n\t\t\t\t\t     new_dentry->d_name.name,\n\t\t\t\t\t     new_dentry->d_name.len,\n\t\t\t\t\t     old_ino,\n\t\t\t\t\t     btrfs_ino(new_dir), index);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t\t/*\n\t\t * this is an ugly little race, but the rename is required\n\t\t * to make sure that if we crash, the inode is either at the\n\t\t * old name or the new one.  pinning the log transaction lets\n\t\t * us make sure we don't allow a log commit to come in after\n\t\t * we unlink the name but before we add the new name back in.\n\t\t */\n\t\tbtrfs_pin_log_trans(root);\n\t}\n\t/*\n\t * make sure the inode gets flushed if it is replacing\n\t * something.\n\t */\n\tif (new_inode && new_inode->i_size && S_ISREG(old_inode->i_mode))\n\t\tbtrfs_add_ordered_operation(trans, root, old_inode);\n\n\tinode_inc_iversion(old_dir);\n\tinode_inc_iversion(new_dir);\n\tinode_inc_iversion(old_inode);\n\told_dir->i_ctime = old_dir->i_mtime = ctime;\n\tnew_dir->i_ctime = new_dir->i_mtime = ctime;\n\told_inode->i_ctime = ctime;\n\n\tif (old_dentry->d_parent != new_dentry->d_parent)\n\t\tbtrfs_record_unlink_dir(trans, old_dir, old_inode, 1);\n\n\tif (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\troot_objectid = BTRFS_I(old_inode)->root->root_key.objectid;\n\t\tret = btrfs_unlink_subvol(trans, root, old_dir, root_objectid,\n\t\t\t\t\told_dentry->d_name.name,\n\t\t\t\t\told_dentry->d_name.len);\n\t} else {\n\t\tret = __btrfs_unlink_inode(trans, root, old_dir,\n\t\t\t\t\told_dentry->d_inode,\n\t\t\t\t\told_dentry->d_name.name,\n\t\t\t\t\told_dentry->d_name.len);\n\t\tif (!ret)\n\t\t\tret = btrfs_update_inode(trans, root, old_inode);\n\t}\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_fail;\n\t}\n\n\tif (new_inode) {\n\t\tinode_inc_iversion(new_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME;\n\t\tif (unlikely(btrfs_ino(new_inode) ==\n\t\t\t     BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {\n\t\t\troot_objectid = BTRFS_I(new_inode)->location.objectid;\n\t\t\tret = btrfs_unlink_subvol(trans, dest, new_dir,\n\t\t\t\t\t\troot_objectid,\n\t\t\t\t\t\tnew_dentry->d_name.name,\n\t\t\t\t\t\tnew_dentry->d_name.len);\n\t\t\tBUG_ON(new_inode->i_nlink == 0);\n\t\t} else {\n\t\t\tret = btrfs_unlink_inode(trans, dest, new_dir,\n\t\t\t\t\t\t new_dentry->d_inode,\n\t\t\t\t\t\t new_dentry->d_name.name,\n\t\t\t\t\t\t new_dentry->d_name.len);\n\t\t}\n\t\tif (!ret && new_inode->i_nlink == 0) {\n\t\t\tret = btrfs_orphan_add(trans, new_dentry->d_inode);\n\t\t\tBUG_ON(ret);\n\t\t}\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tfixup_inode_flags(new_dir, old_inode);\n\n\tret = btrfs_add_link(trans, new_dir, old_inode,\n\t\t\t     new_dentry->d_name.name,\n\t\t\t     new_dentry->d_name.len, 0, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_fail;\n\t}\n\n\tif (old_ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tstruct dentry *parent = new_dentry->d_parent;\n\t\tbtrfs_log_new_name(trans, old_inode, old_dir, parent);\n\t\tbtrfs_end_log_trans(root);\n\t}\nout_fail:\n\tbtrfs_end_transaction(trans, root);\nout_notrans:\n\tif (old_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\tup_read(&root->fs_info->subvol_sem);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,28 @@\n \tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n \t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n \t\treturn -ENOTEMPTY;\n+\n+\n+\t/* check for collisions, even if the  name isn't there */\n+\tret = btrfs_check_dir_item_collision(root, new_dir->i_ino,\n+\t\t\t     new_dentry->d_name.name,\n+\t\t\t     new_dentry->d_name.len);\n+\n+\tif (ret) {\n+\t\tif (ret == -EEXIST) {\n+\t\t\t/* we shouldn't get\n+\t\t\t * eexist without a new_inode */\n+\t\t\tif (!new_inode) {\n+\t\t\t\tWARN_ON(1);\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t/* maybe -EOVERFLOW */\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\tret = 0;\n+\n \t/*\n \t * we're using rename to replace one file with another.\n \t * and the replacement file is large.  Start IO on it now so",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "",
                "\t/* check for collisions, even if the  name isn't there */",
                "\tret = btrfs_check_dir_item_collision(root, new_dir->i_ino,",
                "\t\t\t     new_dentry->d_name.name,",
                "\t\t\t     new_dentry->d_name.len);",
                "",
                "\tif (ret) {",
                "\t\tif (ret == -EEXIST) {",
                "\t\t\t/* we shouldn't get",
                "\t\t\t * eexist without a new_inode */",
                "\t\t\tif (!new_inode) {",
                "\t\t\t\tWARN_ON(1);",
                "\t\t\t\treturn ret;",
                "\t\t\t}",
                "\t\t} else {",
                "\t\t\t/* maybe -EOVERFLOW */",
                "\t\t\treturn ret;",
                "\t\t}",
                "\t}",
                "\tret = 0;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2012-5374",
        "func_name": "torvalds/linux/btrfs_add_link",
        "description": "The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (extended runtime of kernel code) by creating many different files whose names are associated with the same CRC32C hash value.",
        "git_url": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "commit_title": "Btrfs: fix hash overflow handling",
        "commit_text": " The handling for directory crc hash overflows was fairly obscure, split_leaf returns EOVERFLOW when we try to extend the item and that is supposed to bubble up to userland.  For a while it did so, but along the way we added better handling of errors and forced the FS readonly if we hit IO errors during the directory insertion.  Along the way, we started testing only for EEXIST and the EOVERFLOW case was dropped.  The end result is that we may force the FS readonly if we catch a directory hash bucket overflow.  This fixes a few problem spots.  First I add tests for EOVERFLOW in the places where we can safely just return the error up the chain.  btrfs_rename is harder though, because it tries to insert the new directory item only after it has already unlinked anything the rename was going to overwrite.  Rather than adding very complex logic, I added a helper to test for the hash overflow case early while it is still safe to bail out.  Snapshot and subvolume creation had a similar problem, so they are using the new helper now too. ",
        "func_before": "int btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tbtrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}",
        "func": "int btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tbtrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST || ret == -EOVERFLOW)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tret = btrfs_insert_dir_item(trans, root, name, name_len,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    btrfs_inode_type(inode), index);\n-\tif (ret == -EEXIST)\n+\tif (ret == -EEXIST || ret == -EOVERFLOW)\n \t\tgoto fail_dir_item;\n \telse if (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (ret == -EEXIST)"
            ],
            "added_lines": [
                "\tif (ret == -EEXIST || ret == -EOVERFLOW)"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-5374",
        "func_name": "torvalds/linux/create_pending_snapshot",
        "description": "The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (extended runtime of kernel code) by creating many different files whose names are associated with the same CRC32C hash value.",
        "git_url": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "commit_title": "Btrfs: fix hash overflow handling",
        "commit_text": " The handling for directory crc hash overflows was fairly obscure, split_leaf returns EOVERFLOW when we try to extend the item and that is supposed to bubble up to userland.  For a while it did so, but along the way we added better handling of errors and forced the FS readonly if we hit IO errors during the directory insertion.  Along the way, we started testing only for EEXIST and the EOVERFLOW case was dropped.  The end result is that we may force the FS readonly if we catch a directory hash bucket overflow.  This fixes a few problem spots.  First I add tests for EOVERFLOW in the places where we can safely just return the error up the chain.  btrfs_rename is harder though, because it tries to insert the new directory item only after it has already unlinked anything the rename was going to overwrite.  Rather than adding very complex logic, I added a helper to test for the hash overflow case early while it is still safe to bail out.  Snapshot and subvolume creation had a similar problem, so they are using the new helper now too. ",
        "func_before": "static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *parent;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tint ret;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\tuuid_le new_uuid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = pending->error = -ENOMEM;\n\t\tgoto path_alloc_fail;\n\t}\n\n\tnew_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);\n\tif (!new_root_item) {\n\t\tret = pending->error = -ENOMEM;\n\t\tgoto root_item_alloc_fail;\n\t}\n\n\tret = btrfs_find_free_objectid(tree_root, &objectid);\n\tif (ret) {\n\t\tpending->error = ret;\n\t\tgoto no_free_objectid;\n\t}\n\n\tbtrfs_reloc_pre_snapshot(trans, pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tret = btrfs_block_rsv_add(root, &pending->block_rsv,\n\t\t\t\t\t  to_reserve,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\tif (ret) {\n\t\t\tpending->error = ret;\n\t\t\tgoto no_free_objectid;\n\t\t}\n\t}\n\n\tret = btrfs_qgroup_inherit(trans, fs_info, root->root_key.objectid,\n\t\t\t\t   objectid, pending->inherit);\n\tif (ret) {\n\t\tpending->error = ret;\n\t\tgoto no_free_objectid;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\n\tdentry = pending->dentry;\n\tparent = dget_parent(dentry);\n\tparent_inode = parent->d_inode;\n\tparent_root = BTRFS_I(parent_inode)->root;\n\trecord_root_in_trans(trans, parent_root);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(parent_inode, &index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(parent_inode),\n\t\t\t\t\t dentry->d_name.name,\n\t\t\t\t\t dentry->d_name.len, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto fail;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\trecord_root_in_trans(trans, root);\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tnew_root_item->otime.sec = cpu_to_le64(cur_time.tv_sec);\n\tnew_root_item->otime.nsec = cpu_to_le32(cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\tbtrfs_set_root_stransid(new_root_item, 0);\n\tbtrfs_set_root_rtransid(new_root_item, 0);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_set_lock_blocking(old);\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/* see comments in should_cow_block() */\n\troot->force_cow = 1;\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, tree_root, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(parent_inode), index,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, parent_root,\n\t\t\t\t    dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\nfail:\n\tdput(parent);\n\ttrans->block_rsv = rsv;\nno_free_objectid:\n\tkfree(new_root_item);\nroot_item_alloc_fail:\n\tbtrfs_free_path(path);\npath_alloc_fail:\n\tbtrfs_block_rsv_release(root, &pending->block_rsv, (u64)-1);\n\treturn ret;\n}",
        "func": "static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *parent;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tint ret;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\tuuid_le new_uuid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = pending->error = -ENOMEM;\n\t\tgoto path_alloc_fail;\n\t}\n\n\tnew_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);\n\tif (!new_root_item) {\n\t\tret = pending->error = -ENOMEM;\n\t\tgoto root_item_alloc_fail;\n\t}\n\n\tret = btrfs_find_free_objectid(tree_root, &objectid);\n\tif (ret) {\n\t\tpending->error = ret;\n\t\tgoto no_free_objectid;\n\t}\n\n\tbtrfs_reloc_pre_snapshot(trans, pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tret = btrfs_block_rsv_add(root, &pending->block_rsv,\n\t\t\t\t\t  to_reserve,\n\t\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\t\tif (ret) {\n\t\t\tpending->error = ret;\n\t\t\tgoto no_free_objectid;\n\t\t}\n\t}\n\n\tret = btrfs_qgroup_inherit(trans, fs_info, root->root_key.objectid,\n\t\t\t\t   objectid, pending->inherit);\n\tif (ret) {\n\t\tpending->error = ret;\n\t\tgoto no_free_objectid;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\n\tdentry = pending->dentry;\n\tparent = dget_parent(dentry);\n\tparent_inode = parent->d_inode;\n\tparent_root = BTRFS_I(parent_inode)->root;\n\trecord_root_in_trans(trans, parent_root);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(parent_inode, &index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(parent_inode),\n\t\t\t\t\t dentry->d_name.name,\n\t\t\t\t\t dentry->d_name.len, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto fail;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\trecord_root_in_trans(trans, root);\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tnew_root_item->otime.sec = cpu_to_le64(cur_time.tv_sec);\n\tnew_root_item->otime.nsec = cpu_to_le32(cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\tbtrfs_set_root_stransid(new_root_item, 0);\n\tbtrfs_set_root_rtransid(new_root_item, 0);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_set_lock_blocking(old);\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/* see comments in should_cow_block() */\n\troot->force_cow = 1;\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, tree_root, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(parent_inode), index,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, parent_root,\n\t\t\t\t    dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\nfail:\n\tdput(parent);\n\ttrans->block_rsv = rsv;\nno_free_objectid:\n\tkfree(new_root_item);\nroot_item_alloc_fail:\n\tbtrfs_free_path(path);\npath_alloc_fail:\n\tbtrfs_block_rsv_release(root, &pending->block_rsv, (u64)-1);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -204,7 +204,7 @@\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    BTRFS_FT_DIR, index);\n \t/* We have check then name at the beginning, so it is impossible. */\n-\tBUG_ON(ret == -EEXIST);\n+\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n \tif (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n \t\tgoto fail;",
        "diff_line_info": {
            "deleted_lines": [
                "\tBUG_ON(ret == -EEXIST);"
            ],
            "added_lines": [
                "\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_nivaead_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\n\tstrncpy(raead.type, \"nivaead\", sizeof(raead.type));\n\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,8 @@\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);\n+\tstrncpy(raead.type, \"nivaead\", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");",
                "\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);"
            ],
            "added_lines": [
                "\tstrncpy(raead.type, \"nivaead\", sizeof(raead.type));",
                "\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_aead_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t aead->geniv ?: \"<built-in>\");\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\n\tstrncpy(raead.type, \"aead\", sizeof(raead.type));\n\tstrncpy(raead.geniv, aead->geniv ?: \"<built-in>\", sizeof(raead.geniv));\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,8 @@\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n-\t\t aead->geniv ?: \"<built-in>\");\n+\tstrncpy(raead.type, \"aead\", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \"<built-in>\", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");",
                "\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",",
                "\t\t aead->geniv ?: \"<built-in>\");"
            ],
            "added_lines": [
                "\tstrncpy(raead.type, \"aead\", sizeof(raead.type));",
                "\tstrncpy(raead.geniv, aead->geniv ?: \"<built-in>\", sizeof(raead.geniv));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_rng_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\n\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n\n\trrng.seedsize = alg->cra_rng.seedsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\n\tstrncpy(rrng.type, \"rng\", sizeof(rrng.type));\n\n\trrng.seedsize = alg->cra_rng.seedsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n+\tstrncpy(rrng.type, \"rng\", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");"
            ],
            "added_lines": [
                "\tstrncpy(rrng.type, \"rng\", sizeof(rrng.type));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_report_one",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tstrncpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,14 @@\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n \n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -15,8 +17,7 @@\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n-\n+\t\tstrncpy(rl.type, \"larval\", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;",
        "diff_line_info": {
            "deleted_lines": [
                "\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));",
                "\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,",
                "\t       sizeof(ualg->cru_driver_name));",
                "\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),",
                "\t       CRYPTO_MAX_ALG_NAME);",
                "\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");",
                ""
            ],
            "added_lines": [
                "\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));",
                "\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,",
                "\t\tsizeof(ualg->cru_driver_name));",
                "\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),",
                "\t\tsizeof(ualg->cru_module_name));",
                "\tualg->cru_type = 0;",
                "\tualg->cru_mask = 0;",
                "\t\tstrncpy(rl.type, \"larval\", sizeof(rl.type));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_report_comp",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tstrncpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,7 @@\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n-\n+\tstrncpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");",
                ""
            ],
            "added_lines": [
                "\tstrncpy(rcomp.type, \"compression\", sizeof(rcomp.type));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_report_cipher",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tstrncpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n+\tstrncpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");"
            ],
            "added_lines": [
                "\tstrncpy(rcipher.type, \"cipher\", sizeof(rcipher.type));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_givcipher_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"givcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<built-in>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"givcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<built-in>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,9 @@\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"givcipher\");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n-\t\t alg->cra_ablkcipher.geniv ?: \"<built-in>\");\n+\tstrncpy(rblkcipher.type, \"givcipher\", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<built-in>\",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"givcipher\");",
                "\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",",
                "\t\t alg->cra_ablkcipher.geniv ?: \"<built-in>\");"
            ],
            "added_lines": [
                "\tstrncpy(rblkcipher.type, \"givcipher\", sizeof(rblkcipher.type));",
                "\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<built-in>\",",
                "\t\tsizeof(rblkcipher.geniv));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_ablkcipher_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"ablkcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<default>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,9 @@\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n-\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n+\tstrncpy(rblkcipher.type, \"ablkcipher\", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<default>\",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");",
                "\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",",
                "\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");"
            ],
            "added_lines": [
                "\tstrncpy(rblkcipher.type, \"ablkcipher\", sizeof(rblkcipher.type));",
                "\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<default>\",",
                "\t\tsizeof(rblkcipher.geniv));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_shash_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\n\tstrncpy(rhash.type, \"shash\", sizeof(rhash.type));\n\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,8 @@\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n+\tstrncpy(rhash.type, \"shash\", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");"
            ],
            "added_lines": [
                "\tstrncpy(rhash.type, \"shash\", sizeof(rhash.type));",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_pcomp_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tstrncpy(rpcomp.type, \"pcomp\", sizeof(rpcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,7 @@\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n-\n+\tstrncpy(rpcomp.type, \"pcomp\", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");",
                ""
            ],
            "added_lines": [
                "\tstrncpy(rpcomp.type, \"pcomp\", sizeof(rpcomp.type));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_blkcipher_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"blkcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \"<default>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,9 @@\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n-\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n+\tstrncpy(rblkcipher.type, \"blkcipher\", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \"<default>\",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");",
                "\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",",
                "\t\t alg->cra_blkcipher.geniv ?: \"<default>\");"
            ],
            "added_lines": [
                "\tstrncpy(rblkcipher.type, \"blkcipher\", sizeof(rblkcipher.type));",
                "\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \"<default>\",",
                "\t\tsizeof(rblkcipher.geniv));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2546",
        "func_name": "torvalds/linux/crypto_ahash_report",
        "description": "The report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect C library function for copying strings, which allows local users to obtain sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "commit_title": "crypto: user - fix info leaks in report API",
        "commit_text": " Three errors resulting in kernel memory disclosure:  1/ The structures used for the netlink based crypto algorithm report API are located on the stack. As snprintf() does not fill the remainder of the buffer with null bytes, those stack bytes will be disclosed to users of the API. Switch to strncpy() to fix this.  2/ crypto_report_one() does not initialize all field of struct crypto_user_alg. Fix this to fix the heap info leak.  3/ For the module name we should copy only as many bytes as module_name() returns -- not as much as the destination buffer could hold. But the current code does not and therefore copies random data from behind the end of the module name, as the module name is always shorter than CRYPTO_MAX_ALG_NAME.  Also switch to use strncpy() to copy the algorithm's name and driver_name. They are strings, after all.  Cc: Steffen Klassert <steffen.klassert@secunet.com>",
        "func_before": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");\n\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "func": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\n\tstrncpy(rhash.type, \"ahash\", sizeof(rhash.type));\n\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");\n+\tstrncpy(rhash.type, \"ahash\", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");"
            ],
            "added_lines": [
                "\tstrncpy(rhash.type, \"ahash\", sizeof(rhash.type));"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1799",
        "func_name": "GNOME/gnome-online-accounts/http_client_check_response_cb",
        "description": "Gnome Online Accounts (GOA) 3.6.x before 3.6.3 and 3.7.x before 3.7.91, does not properly validate SSL certificates when creating accounts for providers who use the libsoup library, which allows man-in-the-middle attackers to obtain sensitive information such as credentials by sniffing the network.  NOTE: this issue exists because of an incomplete fix for CVE-2013-0240.",
        "git_url": "https://github.com/GNOME/gnome-online-accounts/commit/9cf4bc0ced2c53bcdd36922caa65afc8a167bbd8",
        "commit_title": "Guard against invalid SSL certificates",
        "commit_text": " For providers like Exchange which use libsoup to talk to a HTTPS server it is not enough to warn the user about an invalid certificate. We should make sure that we abort the connection before any credentials have been sent. ",
        "func_before": "static void\nhttp_client_check_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  CheckData *data = user_data;\n  GTlsCertificateFlags cert_flags;\n  gboolean op_res;\n  gboolean using_https;\n\n  error = NULL;\n  op_res = FALSE;\n\n  if (msg->status_code == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (msg->status_code != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   msg->status_code);\n      goto out;\n    }\n\n  if (!data->accept_ssl_errors)\n    {\n      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);\n      if (using_https && cert_flags != 0)\n        {\n          goa_utils_set_error_ssl (&error, cert_flags);\n          goto out;\n        }\n    }\n\n  op_res = TRUE;\n\n out:\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  if (error != NULL)\n    g_simple_async_result_take_error (data->res, error);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (http_client_check_data_free, data);\n}",
        "func": "static void\nhttp_client_check_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  CheckData *data = user_data;\n  gboolean op_res;\n\n  error = NULL;\n  op_res = FALSE;\n\n  /* status == SOUP_STATUS_CANCELLED, if we are being aborted by the\n   * GCancellable or due to an SSL error.\n   */\n  if (msg->status_code == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (msg->status_code != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   msg->status_code);\n      goto out;\n    }\n\n  op_res = TRUE;\n\n out:\n  /* error == NULL, if we are being aborted by the GCancellable or\n   * due to an SSL error.\n   */\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  if (error != NULL)\n    g_simple_async_result_take_error (data->res, error);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (http_client_check_data_free, data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,13 +3,14 @@\n {\n   GError *error;\n   CheckData *data = user_data;\n-  GTlsCertificateFlags cert_flags;\n   gboolean op_res;\n-  gboolean using_https;\n \n   error = NULL;\n   op_res = FALSE;\n \n+  /* status == SOUP_STATUS_CANCELLED, if we are being aborted by the\n+   * GCancellable or due to an SSL error.\n+   */\n   if (msg->status_code == SOUP_STATUS_CANCELLED)\n     goto out;\n   else if (msg->status_code != SOUP_STATUS_OK)\n@@ -22,19 +23,12 @@\n       goto out;\n     }\n \n-  if (!data->accept_ssl_errors)\n-    {\n-      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);\n-      if (using_https && cert_flags != 0)\n-        {\n-          goa_utils_set_error_ssl (&error, cert_flags);\n-          goto out;\n-        }\n-    }\n-\n   op_res = TRUE;\n \n  out:\n+  /* error == NULL, if we are being aborted by the GCancellable or\n+   * due to an SSL error.\n+   */\n   g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n   if (error != NULL)\n     g_simple_async_result_take_error (data->res, error);",
        "diff_line_info": {
            "deleted_lines": [
                "  GTlsCertificateFlags cert_flags;",
                "  gboolean using_https;",
                "  if (!data->accept_ssl_errors)",
                "    {",
                "      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);",
                "      if (using_https && cert_flags != 0)",
                "        {",
                "          goa_utils_set_error_ssl (&error, cert_flags);",
                "          goto out;",
                "        }",
                "    }",
                ""
            ],
            "added_lines": [
                "  /* status == SOUP_STATUS_CANCELLED, if we are being aborted by the",
                "   * GCancellable or due to an SSL error.",
                "   */",
                "  /* error == NULL, if we are being aborted by the GCancellable or",
                "   * due to an SSL error.",
                "   */"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1799",
        "func_name": "GNOME/gnome-online-accounts/goa_http_client_check",
        "description": "Gnome Online Accounts (GOA) 3.6.x before 3.6.3 and 3.7.x before 3.7.91, does not properly validate SSL certificates when creating accounts for providers who use the libsoup library, which allows man-in-the-middle attackers to obtain sensitive information such as credentials by sniffing the network.  NOTE: this issue exists because of an incomplete fix for CVE-2013-0240.",
        "git_url": "https://github.com/GNOME/gnome-online-accounts/commit/9cf4bc0ced2c53bcdd36922caa65afc8a167bbd8",
        "commit_title": "Guard against invalid SSL certificates",
        "commit_text": " For providers like Exchange which use libsoup to talk to a HTTPS server it is not enough to warn the user about an invalid certificate. We should make sure that we abort the connection before any credentials have been sent. ",
        "func_before": "void\ngoa_http_client_check (GoaHttpClient       *client,\n                       const gchar         *uri,\n                       const gchar         *username,\n                       const gchar         *password,\n                       gboolean             accept_ssl_errors,\n                       GCancellable        *cancellable,\n                       GAsyncReadyCallback  callback,\n                       gpointer             user_data)\n{\n  CheckData *data;\n  CheckAuthData *auth;\n\n  g_return_if_fail (GOA_IS_HTTP_CLIENT (client));\n  g_return_if_fail (uri != NULL || uri[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  data = g_slice_new0 (CheckData);\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_http_client_check);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE,\n                                                       SOUP_SESSION_SSL_STRICT, FALSE,\n                                                       SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n\n  data->accept_ssl_errors = accept_ssl_errors;\n\n  data->msg = soup_message_new (SOUP_METHOD_GET, uri);\n  soup_message_headers_append (data->msg->request_headers, \"Connection\", \"close\");\n\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (http_client_check_cancelled_cb),\n                                                    data,\n                                                    NULL);\n      g_simple_async_result_set_check_cancellable (data->res, data->cancellable);\n    }\n\n  auth = g_slice_new0 (CheckAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"authenticate\",\n                         G_CALLBACK (http_client_authenticate),\n                         auth,\n                         http_client_check_auth_data_free,\n                         0);\n\n  soup_session_queue_message (data->session, data->msg, http_client_check_response_cb, data);\n}",
        "func": "void\ngoa_http_client_check (GoaHttpClient       *client,\n                       const gchar         *uri,\n                       const gchar         *username,\n                       const gchar         *password,\n                       gboolean             accept_ssl_errors,\n                       GCancellable        *cancellable,\n                       GAsyncReadyCallback  callback,\n                       gpointer             user_data)\n{\n  CheckData *data;\n  CheckAuthData *auth;\n\n  g_return_if_fail (GOA_IS_HTTP_CLIENT (client));\n  g_return_if_fail (uri != NULL || uri[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  data = g_slice_new0 (CheckData);\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_http_client_check);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE,\n                                                       SOUP_SESSION_SSL_STRICT, FALSE,\n                                                       SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n\n  data->accept_ssl_errors = accept_ssl_errors;\n\n  data->msg = soup_message_new (SOUP_METHOD_GET, uri);\n  soup_message_headers_append (data->msg->request_headers, \"Connection\", \"close\");\n\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (http_client_check_cancelled_cb),\n                                                    data,\n                                                    NULL);\n      g_simple_async_result_set_check_cancellable (data->res, data->cancellable);\n    }\n\n  auth = g_slice_new0 (CheckAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"authenticate\",\n                         G_CALLBACK (http_client_authenticate),\n                         auth,\n                         http_client_check_auth_data_free,\n                         0);\n\n  g_signal_connect (data->session, \"request-started\", G_CALLBACK (http_client_request_started), data);\n  soup_session_queue_message (data->session, data->msg, http_client_check_response_cb, data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,5 +49,6 @@\n                          http_client_check_auth_data_free,\n                          0);\n \n+  g_signal_connect (data->session, \"request-started\", G_CALLBACK (http_client_request_started), data);\n   soup_session_queue_message (data->session, data->msg, http_client_check_response_cb, data);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  g_signal_connect (data->session, \"request-started\", G_CALLBACK (http_client_request_started), data);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1799",
        "func_name": "GNOME/gnome-online-accounts/goa_ews_client_autodiscover",
        "description": "Gnome Online Accounts (GOA) 3.6.x before 3.6.3 and 3.7.x before 3.7.91, does not properly validate SSL certificates when creating accounts for providers who use the libsoup library, which allows man-in-the-middle attackers to obtain sensitive information such as credentials by sniffing the network.  NOTE: this issue exists because of an incomplete fix for CVE-2013-0240.",
        "git_url": "https://github.com/GNOME/gnome-online-accounts/commit/9cf4bc0ced2c53bcdd36922caa65afc8a167bbd8",
        "commit_title": "Guard against invalid SSL certificates",
        "commit_text": " For providers like Exchange which use libsoup to talk to a HTTPS server it is not enough to warn the user about an invalid certificate. We should make sure that we abort the connection before any credentials have been sent. ",
        "func_before": "void\ngoa_ews_client_autodiscover (GoaEwsClient        *client,\n                             const gchar         *email,\n                             const gchar         *password,\n                             const gchar         *username,\n                             const gchar         *server,\n                             gboolean             accept_ssl_errors,\n                             GCancellable        *cancellable,\n                             GAsyncReadyCallback  callback,\n                             gpointer             user_data)\n{\n  AutodiscoverData *data;\n  AutodiscoverAuthData *auth;\n  gchar *url1;\n  gchar *url2;\n  xmlDoc *doc;\n  xmlOutputBuffer *buf;\n\n  g_return_if_fail (GOA_IS_EWS_CLIENT (client));\n  g_return_if_fail (email != NULL || email[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (server != NULL || server[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  doc = ews_client_create_autodiscover_xml (email);\n  buf = xmlAllocOutputBuffer (NULL);\n  xmlNodeDumpOutput (buf, doc, xmlDocGetRootElement (doc), 0, 1, NULL);\n  xmlOutputBufferFlush (buf);\n\n  url1 = g_strdup_printf (\"https://%s/autodiscover/autodiscover.xml\", server);\n  url2 = g_strdup_printf (\"https://autodiscover.%s/autodiscover/autodiscover.xml\", server);\n\n  /* http://msdn.microsoft.com/en-us/library/ee332364.aspx says we are\n   * supposed to try $domain and then autodiscover.$domain. But some\n   * people have broken firewalls on the former which drop packets\n   * instead of rejecting connections, and make the request take ages\n   * to time out. So run both queries in parallel and let the fastest\n   * (successful) one win.\n   */\n  data = g_slice_new0 (AutodiscoverData);\n  data->buf = buf;\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_ews_client_autodiscover);\n  data->msgs[0] = ews_client_create_msg_for_url (url1, buf);\n  data->msgs[1] = ews_client_create_msg_for_url (url2, buf);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE,\n                                                       SOUP_SESSION_SSL_STRICT, FALSE,\n                                                       SOUP_SESSION_USE_NTLM, TRUE,\n                                                       SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n  data->accept_ssl_errors = accept_ssl_errors;\n\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (ews_client_autodiscover_cancelled_cb),\n                                                    data,\n                                                    NULL);\n      g_simple_async_result_set_check_cancellable (data->res, data->cancellable);\n    }\n\n  auth = g_slice_new0 (AutodiscoverAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"authenticate\",\n                         G_CALLBACK (ews_client_authenticate),\n                         auth,\n                         ews_client_autodiscover_auth_data_free,\n                         0);\n\n  soup_session_queue_message (data->session, data->msgs[0], ews_client_autodiscover_response_cb, data);\n  soup_session_queue_message (data->session, data->msgs[1], ews_client_autodiscover_response_cb, data);\n\n  g_free (url2);\n  g_free (url1);\n  xmlFreeDoc (doc);\n}",
        "func": "void\ngoa_ews_client_autodiscover (GoaEwsClient        *client,\n                             const gchar         *email,\n                             const gchar         *password,\n                             const gchar         *username,\n                             const gchar         *server,\n                             gboolean             accept_ssl_errors,\n                             GCancellable        *cancellable,\n                             GAsyncReadyCallback  callback,\n                             gpointer             user_data)\n{\n  AutodiscoverData *data;\n  AutodiscoverAuthData *auth;\n  gchar *url1;\n  gchar *url2;\n  xmlDoc *doc;\n  xmlOutputBuffer *buf;\n\n  g_return_if_fail (GOA_IS_EWS_CLIENT (client));\n  g_return_if_fail (email != NULL || email[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (server != NULL || server[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  doc = ews_client_create_autodiscover_xml (email);\n  buf = xmlAllocOutputBuffer (NULL);\n  xmlNodeDumpOutput (buf, doc, xmlDocGetRootElement (doc), 0, 1, NULL);\n  xmlOutputBufferFlush (buf);\n\n  url1 = g_strdup_printf (\"https://%s/autodiscover/autodiscover.xml\", server);\n  url2 = g_strdup_printf (\"https://autodiscover.%s/autodiscover/autodiscover.xml\", server);\n\n  /* http://msdn.microsoft.com/en-us/library/ee332364.aspx says we are\n   * supposed to try $domain and then autodiscover.$domain. But some\n   * people have broken firewalls on the former which drop packets\n   * instead of rejecting connections, and make the request take ages\n   * to time out. So run both queries in parallel and let the fastest\n   * (successful) one win.\n   */\n  data = g_slice_new0 (AutodiscoverData);\n  data->buf = buf;\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_ews_client_autodiscover);\n  data->msgs[0] = ews_client_create_msg_for_url (url1, buf);\n  data->msgs[1] = ews_client_create_msg_for_url (url2, buf);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE,\n                                                       SOUP_SESSION_SSL_STRICT, FALSE,\n                                                       SOUP_SESSION_USE_NTLM, TRUE,\n                                                       SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n  data->accept_ssl_errors = accept_ssl_errors;\n\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (ews_client_autodiscover_cancelled_cb),\n                                                    data,\n                                                    NULL);\n      g_simple_async_result_set_check_cancellable (data->res, data->cancellable);\n    }\n\n  auth = g_slice_new0 (AutodiscoverAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"authenticate\",\n                         G_CALLBACK (ews_client_authenticate),\n                         auth,\n                         ews_client_autodiscover_auth_data_free,\n                         0);\n\n  g_signal_connect (data->session, \"request-started\", G_CALLBACK (ews_client_request_started), data);\n\n  soup_session_queue_message (data->session, data->msgs[0], ews_client_autodiscover_response_cb, data);\n  soup_session_queue_message (data->session, data->msgs[1], ews_client_autodiscover_response_cb, data);\n\n  g_free (url2);\n  g_free (url1);\n  xmlFreeDoc (doc);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,6 +70,8 @@\n                          ews_client_autodiscover_auth_data_free,\n                          0);\n \n+  g_signal_connect (data->session, \"request-started\", G_CALLBACK (ews_client_request_started), data);\n+\n   soup_session_queue_message (data->session, data->msgs[0], ews_client_autodiscover_response_cb, data);\n   soup_session_queue_message (data->session, data->msgs[1], ews_client_autodiscover_response_cb, data);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  g_signal_connect (data->session, \"request-started\", G_CALLBACK (ews_client_request_started), data);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2013-1799",
        "func_name": "GNOME/gnome-online-accounts/ews_client_autodiscover_response_cb",
        "description": "Gnome Online Accounts (GOA) 3.6.x before 3.6.3 and 3.7.x before 3.7.91, does not properly validate SSL certificates when creating accounts for providers who use the libsoup library, which allows man-in-the-middle attackers to obtain sensitive information such as credentials by sniffing the network.  NOTE: this issue exists because of an incomplete fix for CVE-2013-0240.",
        "git_url": "https://github.com/GNOME/gnome-online-accounts/commit/9cf4bc0ced2c53bcdd36922caa65afc8a167bbd8",
        "commit_title": "Guard against invalid SSL certificates",
        "commit_text": " For providers like Exchange which use libsoup to talk to a HTTPS server it is not enough to warn the user about an invalid certificate. We should make sure that we abort the connection before any credentials have been sent. ",
        "func_before": "static void\news_client_autodiscover_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  AutodiscoverData *data = user_data;\n  GTlsCertificateFlags cert_flags;\n  gboolean op_res;\n  gboolean using_https;\n  guint status;\n  gint idx;\n  gsize size;\n  xmlDoc *doc;\n  xmlNode *node;\n\n  status = msg->status_code;\n  if (status == SOUP_STATUS_NONE)\n    return;\n\n  error = NULL;\n  op_res = FALSE;\n  size = sizeof (data->msgs) / sizeof (data->msgs[0]);\n\n  for (idx = 0; idx < size; idx++)\n    {\n      if (data->msgs[idx] == msg)\n        break;\n    }\n  if (idx == size)\n    return;\n\n  data->msgs[idx] = NULL;\n\n  if (status == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (status != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   status);\n      goto out;\n    }\n\n  if (!data->accept_ssl_errors)\n    {\n      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);\n      if (using_https && cert_flags != 0)\n        {\n          goa_utils_set_error_ssl (&error, cert_flags);\n          goto out;\n        }\n    }\n\n  soup_buffer_free (soup_message_body_flatten (SOUP_MESSAGE (msg)->response_body));\n  g_debug (\"The response headers\");\n  g_debug (\"===================\");\n  g_debug (\"%s\", SOUP_MESSAGE (msg)->response_body->data);\n\n  doc = xmlReadMemory (msg->response_body->data, msg->response_body->length, \"autodiscover.xml\", NULL, 0);\n  if (doc == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to parse autodiscover response XML\"));\n      goto out;\n    }\n\n  node = xmlDocGetRootElement (doc);\n  if (g_strcmp0 ((gchar *) node->name, \"Autodiscover\"))\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Autodiscover element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Response\"))\n        break;\n    }\n  if (node == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Response element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Account\"))\n        break;\n    }\n  if (node == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Account element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Protocol\"))\n        {\n          op_res = ews_client_autodiscover_parse_protocol (node);\n          break;\n        }\n    }\n  if (!op_res)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific*/\n                   _(\"Failed to find ASUrl and OABUrl in autodiscover response\"));\n      goto out;\n    }\n\n  for (idx = 0; idx < size; idx++)\n    {\n      if (data->msgs[idx] != NULL)\n        {\n          /* Since we are cancelling from the same thread that we queued the\n           * message, the callback (ie. this function) will be invoked before\n           * soup_session_cancel_message returns.\n           */\n          soup_session_cancel_message (data->session, data->msgs[idx], SOUP_STATUS_NONE);\n          data->msgs[idx] = NULL;\n        }\n    }\n\n out:\n  /* error == NULL, if we are being aborted by the GCancellable */\n  if (!op_res)\n    {\n      for (idx = 0; idx < size; idx++)\n        {\n          if (data->msgs[idx] != NULL)\n            {\n              /* There's another request outstanding.\n               * Hope that it has better luck.\n               */\n              g_clear_error (&error);\n              return;\n            }\n        }\n      if (error != NULL)\n        g_simple_async_result_take_error (data->res, error);\n    }\n\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (ews_client_autodiscover_data_free, data);\n}",
        "func": "static void\news_client_autodiscover_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  AutodiscoverData *data = user_data;\n  gboolean op_res;\n  guint status;\n  gint idx;\n  gsize size;\n  xmlDoc *doc;\n  xmlNode *node;\n\n  status = msg->status_code;\n  if (status == SOUP_STATUS_NONE)\n    return;\n\n  error = NULL;\n  op_res = FALSE;\n  size = sizeof (data->msgs) / sizeof (data->msgs[0]);\n\n  for (idx = 0; idx < size; idx++)\n    {\n      if (data->msgs[idx] == msg)\n        break;\n    }\n  if (idx == size)\n    return;\n\n  data->msgs[idx] = NULL;\n\n  /* status == SOUP_STATUS_CANCELLED, if we are being aborted by the\n   * GCancellable or due to an SSL error.\n   */\n  if (status == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (status != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   status);\n      goto out;\n    }\n\n  soup_buffer_free (soup_message_body_flatten (SOUP_MESSAGE (msg)->response_body));\n  g_debug (\"The response headers\");\n  g_debug (\"===================\");\n  g_debug (\"%s\", SOUP_MESSAGE (msg)->response_body->data);\n\n  doc = xmlReadMemory (msg->response_body->data, msg->response_body->length, \"autodiscover.xml\", NULL, 0);\n  if (doc == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to parse autodiscover response XML\"));\n      goto out;\n    }\n\n  node = xmlDocGetRootElement (doc);\n  if (g_strcmp0 ((gchar *) node->name, \"Autodiscover\"))\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Autodiscover element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Response\"))\n        break;\n    }\n  if (node == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Response element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Account\"))\n        break;\n    }\n  if (node == NULL)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Failed to find Account element\"));\n      goto out;\n    }\n\n  for (node = node->children; node; node = node->next)\n    {\n      if (ews_client_check_node (node, \"Protocol\"))\n        {\n          op_res = ews_client_autodiscover_parse_protocol (node);\n          break;\n        }\n    }\n  if (!op_res)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific*/\n                   _(\"Failed to find ASUrl and OABUrl in autodiscover response\"));\n      goto out;\n    }\n\n  for (idx = 0; idx < size; idx++)\n    {\n      if (data->msgs[idx] != NULL)\n        {\n          /* Since we are cancelling from the same thread that we queued the\n           * message, the callback (ie. this function) will be invoked before\n           * soup_session_cancel_message returns.\n           */\n          soup_session_cancel_message (data->session, data->msgs[idx], SOUP_STATUS_NONE);\n          data->msgs[idx] = NULL;\n        }\n    }\n\n out:\n  /* error == NULL, if we are being aborted by the GCancellable or\n   * due to an SSL error.\n   */\n  if (!op_res)\n    {\n      for (idx = 0; idx < size; idx++)\n        {\n          if (data->msgs[idx] != NULL)\n            {\n              /* There's another request outstanding.\n               * Hope that it has better luck.\n               */\n              g_clear_error (&error);\n              return;\n            }\n        }\n      if (error != NULL)\n        g_simple_async_result_take_error (data->res, error);\n    }\n\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (ews_client_autodiscover_data_free, data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,7 @@\n {\n   GError *error;\n   AutodiscoverData *data = user_data;\n-  GTlsCertificateFlags cert_flags;\n   gboolean op_res;\n-  gboolean using_https;\n   guint status;\n   gint idx;\n   gsize size;\n@@ -30,6 +28,9 @@\n \n   data->msgs[idx] = NULL;\n \n+  /* status == SOUP_STATUS_CANCELLED, if we are being aborted by the\n+   * GCancellable or due to an SSL error.\n+   */\n   if (status == SOUP_STATUS_CANCELLED)\n     goto out;\n   else if (status != SOUP_STATUS_OK)\n@@ -40,16 +41,6 @@\n                    _(\"Code: %u - Unexpected response from server\"),\n                    status);\n       goto out;\n-    }\n-\n-  if (!data->accept_ssl_errors)\n-    {\n-      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);\n-      if (using_https && cert_flags != 0)\n-        {\n-          goa_utils_set_error_ssl (&error, cert_flags);\n-          goto out;\n-        }\n     }\n \n   soup_buffer_free (soup_message_body_flatten (SOUP_MESSAGE (msg)->response_body));\n@@ -136,7 +127,9 @@\n     }\n \n  out:\n-  /* error == NULL, if we are being aborted by the GCancellable */\n+  /* error == NULL, if we are being aborted by the GCancellable or\n+   * due to an SSL error.\n+   */\n   if (!op_res)\n     {\n       for (idx = 0; idx < size; idx++)",
        "diff_line_info": {
            "deleted_lines": [
                "  GTlsCertificateFlags cert_flags;",
                "  gboolean using_https;",
                "    }",
                "",
                "  if (!data->accept_ssl_errors)",
                "    {",
                "      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);",
                "      if (using_https && cert_flags != 0)",
                "        {",
                "          goa_utils_set_error_ssl (&error, cert_flags);",
                "          goto out;",
                "        }",
                "  /* error == NULL, if we are being aborted by the GCancellable */"
            ],
            "added_lines": [
                "  /* status == SOUP_STATUS_CANCELLED, if we are being aborted by the",
                "   * GCancellable or due to an SSL error.",
                "   */",
                "  /* error == NULL, if we are being aborted by the GCancellable or",
                "   * due to an SSL error.",
                "   */"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4350",
        "func_name": "torvalds/linux/sctp_v6_get_dst",
        "description": "The IPv6 SCTP implementation in net/sctp/ipv6.c in the Linux kernel through 3.11.1 uses data structures and function calls that do not trigger an intended configuration of IPsec encryption, which allows remote attackers to obtain sensitive information by sniffing the network.",
        "git_url": "https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7",
        "commit_title": "net: sctp: fix ipv6 ipsec encryption bug in sctp_v6_xmit",
        "commit_text": " Alan Chester reported an issue with IPv6 on SCTP that IPsec traffic is not being encrypted, whereas on IPv4 it is. Setting up an AH + ESP transport does not seem to have the desired effect:  SCTP + IPv4:    22:14:20.809645 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 116)     192.168.0.2 > 192.168.0.5: AH(spi=0x00000042,sumlen=16,seq=0x1): ESP(spi=0x00000044,seq=0x1), length 72   22:14:20.813270 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 340)     192.168.0.5 > 192.168.0.2: AH(spi=0x00000043,sumlen=16,seq=0x1):  SCTP + IPv6:    22:31:19.215029 IP6 (class 0x02, hlim 64, next-header SCTP (132) payload length: 364)     fe80::222:15ff:fe87:7fc.3333 > fe80::92e6:baff:fe0d:5a54.36767: sctp     1) [INIT ACK] [init tag: 747759530] [rwnd: 62464] [OS: 10] [MIS: 10]  Moreover, Alan says:    This problem was seen with both Racoon and Racoon2. Other people have seen   this with OpenSwan. When IPsec is configured to encrypt all upper layer   protocols the SCTP connection does not initialize. After using Wireshark to   follow packets, this is because the SCTP packet leaves Box A unencrypted and   Box B believes all upper layer protocols are to be encrypted so it drops   this packet, causing the SCTP connection to fail to initialize. When IPsec   is configured to encrypt just SCTP, the SCTP packets are observed unencrypted.  In fact, using `socat sctp6-listen:3333 -` on one end and transferring \"plaintext\" string on the other end, results in cleartext on the wire where SCTP eventually does not report any errors, thus in the latter case that Alan reports, the non-paranoid user might think he's communicating over an encrypted transport on SCTP although he's not (tcpdump ... -X):    ...   0x0030: 5d70 8e1a 0003 001a 177d eb6c 0000 0000  ]p.......}.l....   0x0040: 0000 0000 706c 6169 6e74 6578 740a 0000  ....plaintext...  Only in /proc/net/xfrm_stat we can see XfrmInTmplMismatch increasing on the receiver side. Initial follow-up analysis from Alan's bug report was done by Alexey Dobriyan. Also thanks to Vlad Yasevich for feedback on this.  SCTP has its own implementation of sctp_v6_xmit() not calling inet6_csk_xmit(). This has the implication that it probably never really got updated along with changes in inet6_csk_xmit() and therefore does not seem to invoke xfrm handlers.  SCTP's IPv4 xmit however, properly calls ip_queue_xmit() to do the work. Since a call to inet6_csk_xmit() would solve this problem, but result in unecessary route lookups, let us just use the cached flowi6 instead that we got through sctp_v6_get_dst(). Since all SCTP packets are being sent through sctp_packet_transmit(), we do the route lookup / flow caching in sctp_transport_route(), hold it in tp->dst and skb_dst_set() right after that. If we would alter fl6->daddr in sctp_v6_xmit() to np->opt->srcrt, we possibly could run into the same effect of not having xfrm layer pick it up, hence, use fl6_update_dst() in sctp_v6_get_dst() instead to get the correct source routed dst entry, which we assign to the skb.  Also source address routing example from 625034113 (\"sctp: fix sctp to work with ipv6 source address routing\") still works with this patch! Nevertheless, in RFC5095 it is actually 'recommended' to not use that anyway due to traffic amplification [1]. So it seems we're not supposed to do that anyway in sctp_v6_xmit(). Moreover, if we overwrite the flow destination here, the lower IPv6 layer will be unable to put the correct destination address into IP header, as routing header is added in ipv6_push_nfrag_opts() but then probably with wrong final destination. Things aside, result of this patch is that we do not have any XfrmInTmplMismatch increase plus on the wire with this patch it now looks like:  SCTP + IPv6:    08:17:47.074080 IP6 2620:52:0:102f:7a2b:cbff:fe27:1b0a > 2620:52:0:102f:213:72ff:fe32:7eba:     AH(spi=0x00005fb4,seq=0x1): ESP(spi=0x00005fb5,seq=0x1), length 72   08:17:47.074264 IP6 2620:52:0:102f:213:72ff:fe32:7eba > 2620:52:0:102f:7a2b:cbff:fe27:1b0a:     AH(spi=0x00003d54,seq=0x1): ESP(spi=0x00003d55,seq=0x1), length 296  This fixes Kernel Bugzilla 24412. This security issue seems to be present since 2.6.18 kernels. Lets just hope some big passive adversary in the wild didn't have its fun with that. lksctp-tools IPv6 regression test suite passes as well with this patch.   [1] http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf  Cc: Steffen Klassert <steffen.klassert@secunet.com> Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>",
        "func_before": "static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n\t\t\t    struct flowi *fl, struct sock *sk)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_sockaddr_entry *laddr;\n\tunion sctp_addr *baddr = NULL;\n\tunion sctp_addr *daddr = &t->ipaddr;\n\tunion sctp_addr dst_saddr;\n\t__u8 matchlen = 0;\n\t__u8 bmatchlen;\n\tsctp_scope_t scope;\n\n\tmemset(fl6, 0, sizeof(struct flowi6));\n\tfl6->daddr = daddr->v6.sin6_addr;\n\tfl6->fl6_dport = daddr->v6.sin6_port;\n\tfl6->flowi6_proto = IPPROTO_SCTP;\n\tif (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6->flowi6_oif = daddr->v6.sin6_scope_id;\n\n\tpr_debug(\"%s: dst=%pI6 \", __func__, &fl6->daddr);\n\n\tif (asoc)\n\t\tfl6->fl6_sport = htons(asoc->base.bind_addr.port);\n\n\tif (saddr) {\n\t\tfl6->saddr = saddr->v6.sin6_addr;\n\t\tfl6->fl6_sport = saddr->v6.sin6_port;\n\n\t\tpr_debug(\"src=%pI6 - \", &fl6->saddr);\n\t}\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);\n\tif (!asoc || saddr)\n\t\tgoto out;\n\n\tbp = &asoc->base.bind_addr;\n\tscope = sctp_scope(daddr);\n\t/* ip6_dst_lookup has filled in the fl6->saddr for us.  Check\n\t * to see if we can use it.\n\t */\n\tif (!IS_ERR(dst)) {\n\t\t/* Walk through the bind address list and look for a bind\n\t\t * address that matches the source address of the returned dst.\n\t\t */\n\t\tsctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\t\tif (!laddr->valid || (laddr->state != SCTP_ADDR_SRC))\n\t\t\t\tcontinue;\n\n\t\t\t/* Do not compare against v4 addrs */\n\t\t\tif ((laddr->a.sa.sa_family == AF_INET6) &&\n\t\t\t    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\t/* None of the bound addresses match the source address of the\n\t\t * dst. So release it.\n\t\t */\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\n\t/* Walk through the bind address list and try to get the\n\t * best source address for a given destination.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tif (!laddr->valid)\n\t\t\tcontinue;\n\t\tif ((laddr->state == SCTP_ADDR_SRC) &&\n\t\t    (laddr->a.sa.sa_family == AF_INET6) &&\n\t\t    (scope <= sctp_scope(&laddr->a))) {\n\t\t\tbmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);\n\t\t\tif (!baddr || (matchlen < bmatchlen)) {\n\t\t\t\tbaddr = &laddr->a;\n\t\t\t\tmatchlen = bmatchlen;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (baddr) {\n\t\tfl6->saddr = baddr->v6.sin6_addr;\n\t\tfl6->fl6_sport = baddr->v6.sin6_port;\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);\n\t}\n\nout:\n\tif (!IS_ERR_OR_NULL(dst)) {\n\t\tstruct rt6_info *rt;\n\n\t\trt = (struct rt6_info *)dst;\n\t\tt->dst = dst;\n\t\tt->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;\n\t\tpr_debug(\"rt6_dst:%pI6 rt6_src:%pI6\\n\", &rt->rt6i_dst.addr,\n\t\t\t &fl6->saddr);\n\t} else {\n\t\tt->dst = NULL;\n\n\t\tpr_debug(\"no route\\n\");\n\t}\n}",
        "func": "static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n\t\t\t    struct flowi *fl, struct sock *sk)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sctp_bind_addr *bp;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sctp_sockaddr_entry *laddr;\n\tunion sctp_addr *baddr = NULL;\n\tunion sctp_addr *daddr = &t->ipaddr;\n\tunion sctp_addr dst_saddr;\n\tstruct in6_addr *final_p, final;\n\t__u8 matchlen = 0;\n\t__u8 bmatchlen;\n\tsctp_scope_t scope;\n\n\tmemset(fl6, 0, sizeof(struct flowi6));\n\tfl6->daddr = daddr->v6.sin6_addr;\n\tfl6->fl6_dport = daddr->v6.sin6_port;\n\tfl6->flowi6_proto = IPPROTO_SCTP;\n\tif (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6->flowi6_oif = daddr->v6.sin6_scope_id;\n\n\tpr_debug(\"%s: dst=%pI6 \", __func__, &fl6->daddr);\n\n\tif (asoc)\n\t\tfl6->fl6_sport = htons(asoc->base.bind_addr.port);\n\n\tif (saddr) {\n\t\tfl6->saddr = saddr->v6.sin6_addr;\n\t\tfl6->fl6_sport = saddr->v6.sin6_port;\n\n\t\tpr_debug(\"src=%pI6 - \", &fl6->saddr);\n\t}\n\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);\n\tif (!asoc || saddr)\n\t\tgoto out;\n\n\tbp = &asoc->base.bind_addr;\n\tscope = sctp_scope(daddr);\n\t/* ip6_dst_lookup has filled in the fl6->saddr for us.  Check\n\t * to see if we can use it.\n\t */\n\tif (!IS_ERR(dst)) {\n\t\t/* Walk through the bind address list and look for a bind\n\t\t * address that matches the source address of the returned dst.\n\t\t */\n\t\tsctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\t\tif (!laddr->valid || (laddr->state != SCTP_ADDR_SRC))\n\t\t\t\tcontinue;\n\n\t\t\t/* Do not compare against v4 addrs */\n\t\t\tif ((laddr->a.sa.sa_family == AF_INET6) &&\n\t\t\t    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\t/* None of the bound addresses match the source address of the\n\t\t * dst. So release it.\n\t\t */\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\n\t/* Walk through the bind address list and try to get the\n\t * best source address for a given destination.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tif (!laddr->valid)\n\t\t\tcontinue;\n\t\tif ((laddr->state == SCTP_ADDR_SRC) &&\n\t\t    (laddr->a.sa.sa_family == AF_INET6) &&\n\t\t    (scope <= sctp_scope(&laddr->a))) {\n\t\t\tbmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);\n\t\t\tif (!baddr || (matchlen < bmatchlen)) {\n\t\t\t\tbaddr = &laddr->a;\n\t\t\t\tmatchlen = bmatchlen;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (baddr) {\n\t\tfl6->saddr = baddr->v6.sin6_addr;\n\t\tfl6->fl6_sport = baddr->v6.sin6_port;\n\t\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);\n\t}\n\nout:\n\tif (!IS_ERR_OR_NULL(dst)) {\n\t\tstruct rt6_info *rt;\n\n\t\trt = (struct rt6_info *)dst;\n\t\tt->dst = dst;\n\t\tt->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;\n\t\tpr_debug(\"rt6_dst:%pI6 rt6_src:%pI6\\n\", &rt->rt6i_dst.addr,\n\t\t\t &fl6->saddr);\n\t} else {\n\t\tt->dst = NULL;\n\n\t\tpr_debug(\"no route\\n\");\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,10 +5,12 @@\n \tstruct dst_entry *dst = NULL;\n \tstruct flowi6 *fl6 = &fl->u.ip6;\n \tstruct sctp_bind_addr *bp;\n+\tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct sctp_sockaddr_entry *laddr;\n \tunion sctp_addr *baddr = NULL;\n \tunion sctp_addr *daddr = &t->ipaddr;\n \tunion sctp_addr dst_saddr;\n+\tstruct in6_addr *final_p, final;\n \t__u8 matchlen = 0;\n \t__u8 bmatchlen;\n \tsctp_scope_t scope;\n@@ -32,7 +34,8 @@\n \t\tpr_debug(\"src=%pI6 - \", &fl6->saddr);\n \t}\n \n-\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);\n+\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);\n \tif (!asoc || saddr)\n \t\tgoto out;\n \n@@ -84,10 +87,12 @@\n \t\t}\n \t}\n \trcu_read_unlock();\n+\n \tif (baddr) {\n \t\tfl6->saddr = baddr->v6.sin6_addr;\n \t\tfl6->fl6_sport = baddr->v6.sin6_port;\n-\t\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);\n+\t\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);\n \t}\n \n out:",
        "diff_line_info": {
            "deleted_lines": [
                "\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);",
                "\t\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);"
            ],
            "added_lines": [
                "\tstruct ipv6_pinfo *np = inet6_sk(sk);",
                "\tstruct in6_addr *final_p, final;",
                "\tfinal_p = fl6_update_dst(fl6, np->opt, &final);",
                "\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);",
                "",
                "\t\tfinal_p = fl6_update_dst(fl6, np->opt, &final);",
                "\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4350",
        "func_name": "torvalds/linux/sctp_v6_xmit",
        "description": "The IPv6 SCTP implementation in net/sctp/ipv6.c in the Linux kernel through 3.11.1 uses data structures and function calls that do not trigger an intended configuration of IPsec encryption, which allows remote attackers to obtain sensitive information by sniffing the network.",
        "git_url": "https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7",
        "commit_title": "net: sctp: fix ipv6 ipsec encryption bug in sctp_v6_xmit",
        "commit_text": " Alan Chester reported an issue with IPv6 on SCTP that IPsec traffic is not being encrypted, whereas on IPv4 it is. Setting up an AH + ESP transport does not seem to have the desired effect:  SCTP + IPv4:    22:14:20.809645 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 116)     192.168.0.2 > 192.168.0.5: AH(spi=0x00000042,sumlen=16,seq=0x1): ESP(spi=0x00000044,seq=0x1), length 72   22:14:20.813270 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 340)     192.168.0.5 > 192.168.0.2: AH(spi=0x00000043,sumlen=16,seq=0x1):  SCTP + IPv6:    22:31:19.215029 IP6 (class 0x02, hlim 64, next-header SCTP (132) payload length: 364)     fe80::222:15ff:fe87:7fc.3333 > fe80::92e6:baff:fe0d:5a54.36767: sctp     1) [INIT ACK] [init tag: 747759530] [rwnd: 62464] [OS: 10] [MIS: 10]  Moreover, Alan says:    This problem was seen with both Racoon and Racoon2. Other people have seen   this with OpenSwan. When IPsec is configured to encrypt all upper layer   protocols the SCTP connection does not initialize. After using Wireshark to   follow packets, this is because the SCTP packet leaves Box A unencrypted and   Box B believes all upper layer protocols are to be encrypted so it drops   this packet, causing the SCTP connection to fail to initialize. When IPsec   is configured to encrypt just SCTP, the SCTP packets are observed unencrypted.  In fact, using `socat sctp6-listen:3333 -` on one end and transferring \"plaintext\" string on the other end, results in cleartext on the wire where SCTP eventually does not report any errors, thus in the latter case that Alan reports, the non-paranoid user might think he's communicating over an encrypted transport on SCTP although he's not (tcpdump ... -X):    ...   0x0030: 5d70 8e1a 0003 001a 177d eb6c 0000 0000  ]p.......}.l....   0x0040: 0000 0000 706c 6169 6e74 6578 740a 0000  ....plaintext...  Only in /proc/net/xfrm_stat we can see XfrmInTmplMismatch increasing on the receiver side. Initial follow-up analysis from Alan's bug report was done by Alexey Dobriyan. Also thanks to Vlad Yasevich for feedback on this.  SCTP has its own implementation of sctp_v6_xmit() not calling inet6_csk_xmit(). This has the implication that it probably never really got updated along with changes in inet6_csk_xmit() and therefore does not seem to invoke xfrm handlers.  SCTP's IPv4 xmit however, properly calls ip_queue_xmit() to do the work. Since a call to inet6_csk_xmit() would solve this problem, but result in unecessary route lookups, let us just use the cached flowi6 instead that we got through sctp_v6_get_dst(). Since all SCTP packets are being sent through sctp_packet_transmit(), we do the route lookup / flow caching in sctp_transport_route(), hold it in tp->dst and skb_dst_set() right after that. If we would alter fl6->daddr in sctp_v6_xmit() to np->opt->srcrt, we possibly could run into the same effect of not having xfrm layer pick it up, hence, use fl6_update_dst() in sctp_v6_get_dst() instead to get the correct source routed dst entry, which we assign to the skb.  Also source address routing example from 625034113 (\"sctp: fix sctp to work with ipv6 source address routing\") still works with this patch! Nevertheless, in RFC5095 it is actually 'recommended' to not use that anyway due to traffic amplification [1]. So it seems we're not supposed to do that anyway in sctp_v6_xmit(). Moreover, if we overwrite the flow destination here, the lower IPv6 layer will be unable to put the correct destination address into IP header, as routing header is added in ipv6_push_nfrag_opts() but then probably with wrong final destination. Things aside, result of this patch is that we do not have any XfrmInTmplMismatch increase plus on the wire with this patch it now looks like:  SCTP + IPv6:    08:17:47.074080 IP6 2620:52:0:102f:7a2b:cbff:fe27:1b0a > 2620:52:0:102f:213:72ff:fe32:7eba:     AH(spi=0x00005fb4,seq=0x1): ESP(spi=0x00005fb5,seq=0x1), length 72   08:17:47.074264 IP6 2620:52:0:102f:213:72ff:fe32:7eba > 2620:52:0:102f:7a2b:cbff:fe27:1b0a:     AH(spi=0x00003d54,seq=0x1): ESP(spi=0x00003d55,seq=0x1), length 296  This fixes Kernel Bugzilla 24412. This security issue seems to be present since 2.6.18 kernels. Lets just hope some big passive adversary in the wild didn't have its fun with that. lksctp-tools IPv6 regression test suite passes as well with this patch.   [1] http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf  Cc: Steffen Klassert <steffen.klassert@secunet.com> Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>",
        "func_before": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\n\t/* Fill in the dest address from the route entry passed with the skb\n\t * and the source address from the transport.\n\t */\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n\n\tfl6.flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n\telse\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (np->opt && np->opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n\t\tfl6.daddr = *rt0->addr;\n\t}\n\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n}",
        "func": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &transport->fl.u.ip6;\n\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6->saddr, &fl6->daddr);\n\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\n\treturn ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,37 +2,17 @@\n {\n \tstruct sock *sk = skb->sk;\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n-\tstruct flowi6 fl6;\n-\n-\tmemset(&fl6, 0, sizeof(fl6));\n-\n-\tfl6.flowi6_proto = sk->sk_protocol;\n-\n-\t/* Fill in the dest address from the route entry passed with the skb\n-\t * and the source address from the transport.\n-\t */\n-\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n-\tfl6.saddr = transport->saddr.v6.sin6_addr;\n-\n-\tfl6.flowlabel = np->flow_label;\n-\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n-\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n-\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n-\telse\n-\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n-\n-\tif (np->opt && np->opt->srcrt) {\n-\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n-\t\tfl6.daddr = *rt0->addr;\n-\t}\n+\tstruct flowi6 *fl6 = &transport->fl.u.ip6;\n \n \tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n-\t\t skb->len, &fl6.saddr, &fl6.daddr);\n+\t\t skb->len, &fl6->saddr, &fl6->daddr);\n \n-\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n+\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n \n \tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n \t\tskb->local_df = 1;\n \n-\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n+\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n+\n+\treturn ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct flowi6 fl6;",
                "",
                "\tmemset(&fl6, 0, sizeof(fl6));",
                "",
                "\tfl6.flowi6_proto = sk->sk_protocol;",
                "",
                "\t/* Fill in the dest address from the route entry passed with the skb",
                "\t * and the source address from the transport.",
                "\t */",
                "\tfl6.daddr = transport->ipaddr.v6.sin6_addr;",
                "\tfl6.saddr = transport->saddr.v6.sin6_addr;",
                "",
                "\tfl6.flowlabel = np->flow_label;",
                "\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);",
                "\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)",
                "\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;",
                "\telse",
                "\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;",
                "",
                "\tif (np->opt && np->opt->srcrt) {",
                "\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;",
                "\t\tfl6.daddr = *rt0->addr;",
                "\t}",
                "\t\t skb->len, &fl6.saddr, &fl6.daddr);",
                "\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);",
                "\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);"
            ],
            "added_lines": [
                "\tstruct flowi6 *fl6 = &transport->fl.u.ip6;",
                "\t\t skb->len, &fl6->saddr, &fl6->daddr);",
                "\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);",
                "\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);",
                "",
                "\treturn ip6_xmit(sk, skb, fl6, np->opt, np->tclass);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6628",
        "func_name": "chromium/SSLClientSocketNSS::Core::OwnAuthCertHandler",
        "description": "net/socket/ssl_client_socket_nss.cc in the TLS implementation in Google Chrome before 31.0.1650.48 does not ensure that a server's X.509 certificate is the same during renegotiation as it was before renegotiation, which might allow remote web servers to interfere with trust relationships by renegotiating a session.",
        "git_url": "https://github.com/chromium/chromium/commit/8dd1631f2aa8512be172e3d94a209d241baeb36d",
        "commit_title": "Do not allow the server certificate to change in a renegotiation.",
        "commit_text": "  ",
        "func_before": "SECStatus SSLClientSocketNSS::Core::OwnAuthCertHandler(\n    void* arg,\n    PRFileDesc* socket,\n    PRBool checksig,\n    PRBool is_server) {\n  Core* core = reinterpret_cast<Core*>(arg);\n  if (!core->handshake_callback_called_) {\n    // Only need to turn off False Start in the initial handshake. Also, it is\n    // unsafe to call SSL_OptionSet in a renegotiation because the \"first\n    // handshake\" lock isn't already held, which will result in an assertion\n    // failure in the ssl_Get1stHandshakeLock call in SSL_OptionSet.\n    PRBool negotiated_extension;\n    SECStatus rv = SSL_HandshakeNegotiatedExtension(socket,\n                                                    ssl_app_layer_protocol_xtn,\n                                                    &negotiated_extension);\n    if (rv != SECSuccess || !negotiated_extension) {\n      rv = SSL_HandshakeNegotiatedExtension(socket,\n                                            ssl_next_proto_nego_xtn,\n                                            &negotiated_extension);\n    }\n    if (rv != SECSuccess || !negotiated_extension) {\n      // If the server doesn't support NPN or ALPN, then we don't do False\n      // Start with it.\n      SSL_OptionSet(socket, SSL_ENABLE_FALSE_START, PR_FALSE);\n    }\n  }\n\n  // Tell NSS to not verify the certificate.\n  return SECSuccess;\n}",
        "func": "SECStatus SSLClientSocketNSS::Core::OwnAuthCertHandler(\n    void* arg,\n    PRFileDesc* socket,\n    PRBool checksig,\n    PRBool is_server) {\n  Core* core = reinterpret_cast<Core*>(arg);\n  if (!core->handshake_callback_called_) {\n    // Only need to turn off False Start in the initial handshake. Also, it is\n    // unsafe to call SSL_OptionSet in a renegotiation because the \"first\n    // handshake\" lock isn't already held, which will result in an assertion\n    // failure in the ssl_Get1stHandshakeLock call in SSL_OptionSet.\n    PRBool negotiated_extension;\n    SECStatus rv = SSL_HandshakeNegotiatedExtension(socket,\n                                                    ssl_app_layer_protocol_xtn,\n                                                    &negotiated_extension);\n    if (rv != SECSuccess || !negotiated_extension) {\n      rv = SSL_HandshakeNegotiatedExtension(socket,\n                                            ssl_next_proto_nego_xtn,\n                                            &negotiated_extension);\n    }\n    if (rv != SECSuccess || !negotiated_extension) {\n      // If the server doesn't support NPN or ALPN, then we don't do False\n      // Start with it.\n      SSL_OptionSet(socket, SSL_ENABLE_FALSE_START, PR_FALSE);\n    }\n  } else {\n    // Disallow the server certificate to change in a renegotiation.\n    CERTCertificate* old_cert = core->nss_handshake_state_.server_cert_chain[0];\n    CERTCertificate* new_cert = SSL_PeerCertificate(socket);\n    if (new_cert->derCert.len != old_cert->derCert.len ||\n        memcmp(new_cert->derCert.data, old_cert->derCert.data,\n               new_cert->derCert.len) != 0) {\n      // NSS doesn't have an error code that indicates the server certificate\n      // changed. Borrow SSL_ERROR_WRONG_CERTIFICATE (which NSS isn't using)\n      // for this purpose.\n      PORT_SetError(SSL_ERROR_WRONG_CERTIFICATE);\n      return SECFailure;\n    }\n  }\n\n  // Tell NSS to not verify the certificate.\n  return SECSuccess;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,19 @@\n       // Start with it.\n       SSL_OptionSet(socket, SSL_ENABLE_FALSE_START, PR_FALSE);\n     }\n+  } else {\n+    // Disallow the server certificate to change in a renegotiation.\n+    CERTCertificate* old_cert = core->nss_handshake_state_.server_cert_chain[0];\n+    CERTCertificate* new_cert = SSL_PeerCertificate(socket);\n+    if (new_cert->derCert.len != old_cert->derCert.len ||\n+        memcmp(new_cert->derCert.data, old_cert->derCert.data,\n+               new_cert->derCert.len) != 0) {\n+      // NSS doesn't have an error code that indicates the server certificate\n+      // changed. Borrow SSL_ERROR_WRONG_CERTIFICATE (which NSS isn't using)\n+      // for this purpose.\n+      PORT_SetError(SSL_ERROR_WRONG_CERTIFICATE);\n+      return SECFailure;\n+    }\n   }\n \n   // Tell NSS to not verify the certificate.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  } else {",
                "    // Disallow the server certificate to change in a renegotiation.",
                "    CERTCertificate* old_cert = core->nss_handshake_state_.server_cert_chain[0];",
                "    CERTCertificate* new_cert = SSL_PeerCertificate(socket);",
                "    if (new_cert->derCert.len != old_cert->derCert.len ||",
                "        memcmp(new_cert->derCert.data, old_cert->derCert.data,",
                "               new_cert->derCert.len) != 0) {",
                "      // NSS doesn't have an error code that indicates the server certificate",
                "      // changed. Borrow SSL_ERROR_WRONG_CERTIFICATE (which NSS isn't using)",
                "      // for this purpose.",
                "      PORT_SetError(SSL_ERROR_WRONG_CERTIFICATE);",
                "      return SECFailure;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6628",
        "func_name": "chromium/MapNSSError",
        "description": "net/socket/ssl_client_socket_nss.cc in the TLS implementation in Google Chrome before 31.0.1650.48 does not ensure that a server's X.509 certificate is the same during renegotiation as it was before renegotiation, which might allow remote web servers to interfere with trust relationships by renegotiating a session.",
        "git_url": "https://github.com/chromium/chromium/commit/8dd1631f2aa8512be172e3d94a209d241baeb36d",
        "commit_title": "Do not allow the server certificate to change in a renegotiation.",
        "commit_text": "  ",
        "func_before": "int MapNSSError(PRErrorCode err) {\n  // TODO(port): fill this out as we learn what's important\n  switch (err) {\n    case PR_WOULD_BLOCK_ERROR:\n      return ERR_IO_PENDING;\n    case PR_ADDRESS_NOT_SUPPORTED_ERROR:  // For connect.\n    case PR_NO_ACCESS_RIGHTS_ERROR:\n      return ERR_ACCESS_DENIED;\n    case PR_IO_TIMEOUT_ERROR:\n      return ERR_TIMED_OUT;\n    case PR_CONNECT_RESET_ERROR:\n      return ERR_CONNECTION_RESET;\n    case PR_CONNECT_ABORTED_ERROR:\n      return ERR_CONNECTION_ABORTED;\n    case PR_CONNECT_REFUSED_ERROR:\n      return ERR_CONNECTION_REFUSED;\n    case PR_NOT_CONNECTED_ERROR:\n      return ERR_SOCKET_NOT_CONNECTED;\n    case PR_HOST_UNREACHABLE_ERROR:\n    case PR_NETWORK_UNREACHABLE_ERROR:\n      return ERR_ADDRESS_UNREACHABLE;\n    case PR_ADDRESS_NOT_AVAILABLE_ERROR:\n      return ERR_ADDRESS_INVALID;\n    case PR_INVALID_ARGUMENT_ERROR:\n      return ERR_INVALID_ARGUMENT;\n    case PR_END_OF_FILE_ERROR:\n      return ERR_CONNECTION_CLOSED;\n    case PR_NOT_IMPLEMENTED_ERROR:\n      return ERR_NOT_IMPLEMENTED;\n\n    case SEC_ERROR_LIBRARY_FAILURE:\n      return ERR_UNEXPECTED;\n    case SEC_ERROR_INVALID_ARGS:\n      return ERR_INVALID_ARGUMENT;\n    case SEC_ERROR_NO_MEMORY:\n      return ERR_OUT_OF_MEMORY;\n    case SEC_ERROR_NO_KEY:\n      return ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY;\n    case SEC_ERROR_INVALID_KEY:\n    case SSL_ERROR_SIGN_HASHES_FAILURE:\n      LOG(ERROR) << \"ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED: NSS error \" << err\n                 << \", OS error \" << PR_GetOSError();\n      return ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;\n    // A handshake (initial or renegotiation) may fail because some signature\n    // (for example, the signature in the ServerKeyExchange message for an\n    // ephemeral Diffie-Hellman cipher suite) is invalid.\n    case SEC_ERROR_BAD_SIGNATURE:\n      return ERR_SSL_PROTOCOL_ERROR;\n\n    case SSL_ERROR_SSL_DISABLED:\n      return ERR_NO_SSL_VERSIONS_ENABLED;\n    case SSL_ERROR_NO_CYPHER_OVERLAP:\n    case SSL_ERROR_PROTOCOL_VERSION_ALERT:\n    case SSL_ERROR_UNSUPPORTED_VERSION:\n      return ERR_SSL_VERSION_OR_CIPHER_MISMATCH;\n    case SSL_ERROR_HANDSHAKE_FAILURE_ALERT:\n    case SSL_ERROR_HANDSHAKE_UNEXPECTED_ALERT:\n    case SSL_ERROR_ILLEGAL_PARAMETER_ALERT:\n      return ERR_SSL_PROTOCOL_ERROR;\n    case SSL_ERROR_DECOMPRESSION_FAILURE_ALERT:\n      return ERR_SSL_DECOMPRESSION_FAILURE_ALERT;\n    case SSL_ERROR_BAD_MAC_ALERT:\n      return ERR_SSL_BAD_RECORD_MAC_ALERT;\n    case SSL_ERROR_DECRYPT_ERROR_ALERT:\n      return ERR_SSL_DECRYPT_ERROR_ALERT;\n    case SSL_ERROR_UNSAFE_NEGOTIATION:\n      return ERR_SSL_UNSAFE_NEGOTIATION;\n    case SSL_ERROR_WEAK_SERVER_EPHEMERAL_DH_KEY:\n      return ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY;\n    case SSL_ERROR_HANDSHAKE_NOT_COMPLETED:\n      return ERR_SSL_HANDSHAKE_NOT_COMPLETED;\n    case SEC_ERROR_BAD_KEY:\n    case SSL_ERROR_EXTRACT_PUBLIC_KEY_FAILURE:\n    // TODO(wtc): the following errors may also occur in contexts unrelated\n    // to the peer's public key.  We should add new error codes for them, or\n    // map them to ERR_SSL_BAD_PEER_PUBLIC_KEY only in the right context.\n    // General unsupported/unknown key algorithm error.\n    case SEC_ERROR_UNSUPPORTED_KEYALG:\n    // General DER decoding errors.\n    case SEC_ERROR_BAD_DER:\n    case SEC_ERROR_EXTRA_INPUT:\n      return ERR_SSL_BAD_PEER_PUBLIC_KEY;\n\n    default: {\n      if (IS_SSL_ERROR(err)) {\n        LOG(WARNING) << \"Unknown SSL error \" << err\n                     << \" mapped to net::ERR_SSL_PROTOCOL_ERROR\";\n        return ERR_SSL_PROTOCOL_ERROR;\n      }\n      LOG(WARNING) << \"Unknown error \" << err << \" mapped to net::ERR_FAILED\";\n      return ERR_FAILED;\n    }\n  }\n}",
        "func": "int MapNSSError(PRErrorCode err) {\n  // TODO(port): fill this out as we learn what's important\n  switch (err) {\n    case PR_WOULD_BLOCK_ERROR:\n      return ERR_IO_PENDING;\n    case PR_ADDRESS_NOT_SUPPORTED_ERROR:  // For connect.\n    case PR_NO_ACCESS_RIGHTS_ERROR:\n      return ERR_ACCESS_DENIED;\n    case PR_IO_TIMEOUT_ERROR:\n      return ERR_TIMED_OUT;\n    case PR_CONNECT_RESET_ERROR:\n      return ERR_CONNECTION_RESET;\n    case PR_CONNECT_ABORTED_ERROR:\n      return ERR_CONNECTION_ABORTED;\n    case PR_CONNECT_REFUSED_ERROR:\n      return ERR_CONNECTION_REFUSED;\n    case PR_NOT_CONNECTED_ERROR:\n      return ERR_SOCKET_NOT_CONNECTED;\n    case PR_HOST_UNREACHABLE_ERROR:\n    case PR_NETWORK_UNREACHABLE_ERROR:\n      return ERR_ADDRESS_UNREACHABLE;\n    case PR_ADDRESS_NOT_AVAILABLE_ERROR:\n      return ERR_ADDRESS_INVALID;\n    case PR_INVALID_ARGUMENT_ERROR:\n      return ERR_INVALID_ARGUMENT;\n    case PR_END_OF_FILE_ERROR:\n      return ERR_CONNECTION_CLOSED;\n    case PR_NOT_IMPLEMENTED_ERROR:\n      return ERR_NOT_IMPLEMENTED;\n\n    case SEC_ERROR_LIBRARY_FAILURE:\n      return ERR_UNEXPECTED;\n    case SEC_ERROR_INVALID_ARGS:\n      return ERR_INVALID_ARGUMENT;\n    case SEC_ERROR_NO_MEMORY:\n      return ERR_OUT_OF_MEMORY;\n    case SEC_ERROR_NO_KEY:\n      return ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY;\n    case SEC_ERROR_INVALID_KEY:\n    case SSL_ERROR_SIGN_HASHES_FAILURE:\n      LOG(ERROR) << \"ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED: NSS error \" << err\n                 << \", OS error \" << PR_GetOSError();\n      return ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;\n    // A handshake (initial or renegotiation) may fail because some signature\n    // (for example, the signature in the ServerKeyExchange message for an\n    // ephemeral Diffie-Hellman cipher suite) is invalid.\n    case SEC_ERROR_BAD_SIGNATURE:\n      return ERR_SSL_PROTOCOL_ERROR;\n\n    case SSL_ERROR_SSL_DISABLED:\n      return ERR_NO_SSL_VERSIONS_ENABLED;\n    case SSL_ERROR_NO_CYPHER_OVERLAP:\n    case SSL_ERROR_PROTOCOL_VERSION_ALERT:\n    case SSL_ERROR_UNSUPPORTED_VERSION:\n      return ERR_SSL_VERSION_OR_CIPHER_MISMATCH;\n    case SSL_ERROR_HANDSHAKE_FAILURE_ALERT:\n    case SSL_ERROR_HANDSHAKE_UNEXPECTED_ALERT:\n    case SSL_ERROR_ILLEGAL_PARAMETER_ALERT:\n      return ERR_SSL_PROTOCOL_ERROR;\n    case SSL_ERROR_DECOMPRESSION_FAILURE_ALERT:\n      return ERR_SSL_DECOMPRESSION_FAILURE_ALERT;\n    case SSL_ERROR_BAD_MAC_ALERT:\n      return ERR_SSL_BAD_RECORD_MAC_ALERT;\n    case SSL_ERROR_DECRYPT_ERROR_ALERT:\n      return ERR_SSL_DECRYPT_ERROR_ALERT;\n    case SSL_ERROR_UNSAFE_NEGOTIATION:\n      return ERR_SSL_UNSAFE_NEGOTIATION;\n    case SSL_ERROR_WEAK_SERVER_EPHEMERAL_DH_KEY:\n      return ERR_SSL_WEAK_SERVER_EPHEMERAL_DH_KEY;\n    case SSL_ERROR_HANDSHAKE_NOT_COMPLETED:\n      return ERR_SSL_HANDSHAKE_NOT_COMPLETED;\n    case SEC_ERROR_BAD_KEY:\n    case SSL_ERROR_EXTRACT_PUBLIC_KEY_FAILURE:\n    // TODO(wtc): the following errors may also occur in contexts unrelated\n    // to the peer's public key.  We should add new error codes for them, or\n    // map them to ERR_SSL_BAD_PEER_PUBLIC_KEY only in the right context.\n    // General unsupported/unknown key algorithm error.\n    case SEC_ERROR_UNSUPPORTED_KEYALG:\n    // General DER decoding errors.\n    case SEC_ERROR_BAD_DER:\n    case SEC_ERROR_EXTRA_INPUT:\n      return ERR_SSL_BAD_PEER_PUBLIC_KEY;\n    // During renegotiation, the server presented a different certificate than\n    // was used earlier.\n    case SSL_ERROR_WRONG_CERTIFICATE:\n      return ERR_SSL_SERVER_CERT_CHANGED;\n\n    default: {\n      if (IS_SSL_ERROR(err)) {\n        LOG(WARNING) << \"Unknown SSL error \" << err\n                     << \" mapped to net::ERR_SSL_PROTOCOL_ERROR\";\n        return ERR_SSL_PROTOCOL_ERROR;\n      }\n      LOG(WARNING) << \"Unknown error \" << err << \" mapped to net::ERR_FAILED\";\n      return ERR_FAILED;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,6 +80,10 @@\n     case SEC_ERROR_BAD_DER:\n     case SEC_ERROR_EXTRA_INPUT:\n       return ERR_SSL_BAD_PEER_PUBLIC_KEY;\n+    // During renegotiation, the server presented a different certificate than\n+    // was used earlier.\n+    case SSL_ERROR_WRONG_CERTIFICATE:\n+      return ERR_SSL_SERVER_CERT_CHANGED;\n \n     default: {\n       if (IS_SSL_ERROR(err)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // During renegotiation, the server presented a different certificate than",
                "    // was used earlier.",
                "    case SSL_ERROR_WRONG_CERTIFICATE:",
                "      return ERR_SSL_SERVER_CERT_CHANGED;"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6449",
        "func_name": "openssl/ssl_get_algorithm2",
        "description": "The ssl_get_algorithm2 function in ssl/s3_lib.c in OpenSSL before 1.0.2 obtains a certain version number from an incorrect data structure, which allows remote attackers to cause a denial of service (daemon crash) via crafted traffic from a TLS 1.2 client.",
        "git_url": "http://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ca989269a2876bae79393bd54c3e72d49975fc75",
        "commit_title": "",
        "commit_text": "Use version in SSL_METHOD not SSL structure.  When deciding whether to use TLS 1.2 PRF and record hash algorithms use the version number in the corresponding SSL_METHOD structure instead of the SSL structure. The SSL structure version is sometimes inaccurate. Note: OpenSSL 1.0.2 and later effectively do this already. (CVE-2013-6449) ",
        "func_before": "long ssl_get_algorithm2(SSL *s)\n\t{\n\tlong alg2 = s->s3->tmp.new_cipher->algorithm2;\n\tif (TLS1_get_version(s) >= TLS1_2_VERSION &&\n\t    alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n\t\treturn SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n\treturn alg2;\n\t}",
        "func": "long ssl_get_algorithm2(SSL *s)\n\t{\n\tlong alg2 = s->s3->tmp.new_cipher->algorithm2;\n\tif (s->method->version == TLS1_2_VERSION &&\n\t    alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n\t\treturn SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n\treturn alg2;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n long ssl_get_algorithm2(SSL *s)\n \t{\n \tlong alg2 = s->s3->tmp.new_cipher->algorithm2;\n-\tif (TLS1_get_version(s) >= TLS1_2_VERSION &&\n+\tif (s->method->version == TLS1_2_VERSION &&\n \t    alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n \t\treturn SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n \treturn alg2;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (TLS1_get_version(s) >= TLS1_2_VERSION &&"
            ],
            "added_lines": [
                "\tif (s->method->version == TLS1_2_VERSION &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2179",
        "func_name": "xorg/app/xdm/Verify",
        "description": "X.Org xdm 1.1.10, 1.1.11, and possibly other versions, when performing authentication using certain implementations of the crypt API function that can return NULL, allows remote attackers to cause a denial of service (NULL pointer dereference and crash) by attempting to log into an account whose password field contains invalid characters, as demonstrated using the crypt function from glibc 2.17 and later with (1) the \"!\" character in the salt portion of a password field or (2) a password that has been encrypted using DES or MD5 in FIPS-140 mode.",
        "git_url": "http://cgit.freedesktop.org/xorg/app/xdm/commit/?id=8d1eb5c74413e4c9a21f689fc106949b121c0117",
        "commit_title": "Starting with glibc 2.17 (eglibc 2.17), crypt() fails with EINVAL",
        "commit_text": "(w/ NULL return) if the salt violates specifications. Additionally, on FIPS-140 enabled Linux systems, DES/MD5-encrypted passwords passed to crypt() fail with EPERM (w/ NULL return).  If using glibc's crypt(), check return value to avoid a possible NULL pointer dereference.  ",
        "func_before": "_X_INTERNAL\nint\nVerify (struct display *d, struct greet_info *greet, struct verify_info *verify)\n{\n\tstruct passwd\t*p;\n\tlogin_cap_t\t*lc;\n\tauth_session_t\t*as;\n\tchar\t\t*style, *shell, *home, *s, **argv;\n\tchar\t\tpath[MAXPATHLEN];\n\tint\t\tauthok;\n\n\t/* User may have specified an authentication style. */\n\tif ((style = strchr(greet->name, ':')) != NULL)\n\t\t*style++ = '\\0';\n\n\tDebug (\"Verify %s, style %s ...\\n\", greet->name,\n\t    style ? style : \"default\");\n\n\tp = getpwnam (greet->name);\n\tendpwent();\n\n\tif (!p || strlen (greet->name) == 0) {\n\t\tDebug(\"getpwnam() failed.\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n\tif ((lc = login_getclass(p->pw_class)) == NULL) {\n\t\tDebug(\"login_getclass() failed.\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\tif ((style = login_getstyle(lc, style, \"xdm\")) == NULL) {\n\t\tDebug(\"login_getstyle() failed.\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\tif ((as = auth_open()) == NULL) {\n\t\tDebug(\"auth_open() failed.\\n\");\n\t\tlogin_close(lc);\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\tif (auth_setoption(as, \"login\", \"yes\") == -1) {\n\t\tDebug(\"auth_setoption() failed.\\n\");\n\t\tlogin_close(lc);\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n\t/* Set up state for no challenge, just check a response. */\n\tauth_setstate(as, 0);\n\tauth_setdata(as, \"\", 1);\n\tauth_setdata(as, greet->password, strlen(greet->password) + 1);\n\n\t/* Build path of the auth script and call it */\n\tsnprintf(path, sizeof(path), _PATH_AUTHPROG \"%s\", style);\n\tauth_call(as, path, style, \"-s\", \"response\", greet->name,\n\t\t  lc->lc_class, (void *)NULL);\n\tauthok = auth_getstate(as);\n\n\tif ((authok & AUTH_ALLOW) == 0) {\n\t\tDebug(\"password verify failed\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\tauth_close(as);\n\t\tlogin_close(lc);\n\t\treturn 0;\n\t}\n\t/* Run the approval script */\n\tif (!auth_approval(as, lc, greet->name, \"auth-xdm\")) {\n\t\tDebug(\"login not approved\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\tauth_close(as);\n\t\tlogin_close(lc);\n\t\treturn 0;\n\t}\n\tauth_close(as);\n\tlogin_close(lc);\n\t/* Check empty passwords against allowNullPasswd */\n\tif (!greet->allow_null_passwd && strlen(greet->password) == 0) {\n\t\tDebug(\"empty password not allowed\\n\");\n\t\treturn 0;\n\t}\n\t/* Only accept root logins if allowRootLogin resource is set */\n\tif (p->pw_uid == 0 && !greet->allow_root_login) {\n\t\tDebug(\"root logins not allowed\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Shell must be in /etc/shells\n\t */\n\tfor (;;) {\n\t\ts = getusershell();\n\t\tif (s == NULL) {\n\t\t\t/* did not found the shell in /etc/shells\n\t\t\t   -> failure */\n\t\t\tDebug(\"shell not in /etc/shells\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\tendusershell();\n\t\t\treturn 0;\n\t\t}\n\t\tif (strcmp(s, p->pw_shell) == 0) {\n\t\t\t/* found the shell in /etc/shells */\n\t\t\tendusershell();\n\t\t\tbreak;\n\t\t}\n\t}\n#elif defined(USESECUREWARE) /* !USE_BSDAUTH */\n/*\n * This is a global variable and will be referenced in at least session.c\n */\nstruct smp_user_info *userp = 0;\n\n_X_INTERNAL\nint\nVerify (struct display *d, struct greet_info *greet, struct verify_info *verify)\n{\n  int ret, pwtries = 0, nis, delay;\n  char *reason = 0;\n  struct passwd\t*p;\n  char *shell, *home, **argv;\n\n  Debug (\"Verify %s ...\\n\", greet->name);\n\n  p = getpwnam (greet->name);\n  endpwent();\n\n  if (!p || strlen (greet->name) == 0) {\n    LogError (\"getpwnam() failed.\\n\");\n    bzero(greet->password, strlen(greet->password));\n    return 0;\n  }\n\n  ret = smp_check_user (SMP_LOGIN, greet->name, 0, 0, &userp, &pwtries,\n    &reason, &nis, &delay);\n  if (ret != SMP_RETIRED && userp->retired)\n    ret = userp->result = SMP_RETIRED;\n  Debug (\"smp_check_user returns %d\\n\", ret);\n\n  switch (ret) {\n    case SMP_FAIL:\n      Debug (\"Out of memory in smp_check_user\\n\");\n      goto smp_fail;\n    case SMP_EXTFAIL:\n      Debug (\"SMP_EXTFAIL: %s\", reason);\n      goto smp_fail;\n    case SMP_NOTAUTH:\n      Debug (\"Not authorized\\n\");\n      goto smp_fail;\n    case SMP_TERMLOCK:\n      Debug (\"Terminal is locked!\\n\");\n      goto smp_fail;\n    case SMP_ACCTLOCK:\n      Debug (\"Account is locked\\n\");\n      goto smp_fail;\n    case SMP_RETIRED:\n      Debug (\"Account is retired\\n\");\n      goto smp_fail;\n    case SMP_OVERRIDE:\n      Debug (\"On override device ... proceeding\\n\");\n      break;\n    case SMP_NULLPW:\n      Debug (\"NULL password entry\\n\");\n      if (!greet->allow_null_passwd) {\n        goto smp_fail;\n      }\n      break;\n    case SMP_BADUSER:\n      Debug (\"User not found in protected password database\\n\");\n      goto smp_fail;\n    case SMP_PWREQ:\n      Debug (\"Password change required\\n\");\n      goto smp_fail;\n    case SMP_HASPW:\n      break;\n    default:\n      Debug (\"Unhandled smp_check_user return %d\\n\", ret);\nsmp_fail:\n      sleep(delay);\n      smp_audit_fail (userp, 0);\n      bzero(greet->password, strlen(greet->password));\n      return 0;\n      break;\n  }\n\n  if (ret != SMP_NULLPW) {\n    /*\n     * If we require a password, check it.\n     */\n    ret = smp_check_pw (greet->password, userp, &reason);\n    switch (ret) {\n      case SMP_CANCHANGE:\n      case SMP_CANTCHANGE:\n      case SMP_OVERRIDE:\n        break;\n      default:\n        goto smp_fail;\n    }\n  }\n#else /* !USE_BSDAUTH && !USESECUREWARE */\n_X_INTERNAL\nint\nVerify (struct display *d, struct greet_info *greet, struct verify_info *verify)\n{\n\tstruct passwd\t*p;\n# ifndef USE_PAM\n#  ifdef HAVE_GETSPNAM\n\tstruct spwd\t*sp;\n#  endif\n\tchar\t\t*user_pass = NULL;\n# endif\n# ifdef __OpenBSD__\n\tchar            *s;\n\tstruct timeval  tp;\n# endif\n\tchar\t\t*shell, *home;\n\tchar\t\t**argv;\n\n\tDebug (\"Verify %s ...\\n\", greet->name);\n\n\tp = getpwnam (greet->name);\n\tendpwent();\n\n\tif (!p || strlen (greet->name) == 0) {\n\t\tDebug (\"getpwnam() failed.\\n\");\n\t\tif (greet->password != NULL)\n\t\t    bzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Only accept root logins if allowRootLogin resource is not false\n\t */\n\tif ((p->pw_uid == 0) && !greet->allow_root_login) {\n\t\tDebug(\"root logins not allowed\\n\");\n\t\tif (greet->password != NULL)\n\t\t    bzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n# if defined(sun) && defined(SVR4)\n\t/* Solaris: If CONSOLE is set to /dev/console in /etc/default/login,\n\t   then root can only login on system console */\n\n#  define SOLARIS_LOGIN_DEFAULTS \"/etc/default/login\"\n\n\tif (p->pw_uid == 0) {\n\t    char *console = NULL, *tmp = NULL;\n\t    FILE *fs;\n\n\t    if ((fs= fopen(SOLARIS_LOGIN_DEFAULTS, \"r\")) != NULL)\n\t    {\n\t\tchar str[120];\n\t\twhile (!feof(fs))\n\t\t{\n\t\t    fgets(str, 120, fs);\n\t\t    if(str[0] == '#' || strlen(str) < 8)\n\t\t\tcontinue;\n\t\t    if((tmp = strstr(str, \"CONSOLE=\")) != NULL)\n\t\t\tconsole = strdup((tmp+8));\n\t\t}\n\t\tfclose(fs);\n                if ( console != NULL &&\n\t\t  (strncmp(console, \"/dev/console\", 12) == 0) &&\n\t\t  (strncmp(d->name,\":0\",2) != 0) )\n\t\t{\n                        Debug(\"Not on system console\\n\");\n\t\t\tif (greet->password != NULL)\n\t\t\t    bzero(greet->password, strlen(greet->password));\n\t\t\tfree(console);\n\t                return 0;\n                }\n\t\tfree(console);\n\t    }\n\t    else\n\t    {\n\t\tDebug(\"Could not open %s\\n\", SOLARIS_LOGIN_DEFAULTS);\n\t    }\n\t}\n# endif\n\n# ifndef USE_PAM /* PAM authentication happened in GreetUser already */\n#  ifdef linux\n\tif (!strcmp(p->pw_passwd, \"!\") || !strcmp(p->pw_passwd, \"*\")) {\n\t    Debug (\"The account is locked, no login allowed.\\n\");\n\t    bzero(greet->password, strlen(greet->password));\n\t    return 0;\n\t}\n#  endif\n\tuser_pass = p->pw_passwd;\n#  ifdef KERBEROS\n\tif(strcmp(greet->name, \"root\") != 0){\n\t\tchar name[ANAME_SZ];\n\t\tchar realm[REALM_SZ];\n\t\tchar *q;\n\t\tint ret;\n\n\t\tif(krb_get_lrealm(realm, 1)){\n\t\t\tDebug (\"Can't get Kerberos realm.\\n\");\n\t\t} else {\n\n\t\t    snprintf(krbtkfile, sizeof(krbktfile), \"%s.%s\",\n\t\t\t     TKT_ROOT, d->name);\n\t\t    krb_set_tkt_string(krbtkfile);\n\t\t    unlink(krbtkfile);\n\n\t\t    ret = krb_verify_user(greet->name, \"\", realm,\n\t\t\t\t      greet->password, 1, \"rcmd\");\n\n\t\t    if(ret == KSUCCESS){\n\t\t\t    chown(krbtkfile, p->pw_uid, p->pw_gid);\n\t\t\t    Debug(\"kerberos verify succeeded\\n\");\n\t\t\t    if (k_hasafs()) {\n\t\t\t\t    if (k_setpag() == -1)\n\t\t\t\t\t    LogError (\"setpag() failed for %s\\n\",\n\t\t\t\t\t\t      greet->name);\n\n\t\t\t\t    if((ret = k_afsklog(NULL, NULL)) != KSUCCESS)\n\t\t\t\t\t    LogError(\"Warning %s\\n\",\n\t\t\t\t\t\t     krb_get_err_text(ret));\n\t\t\t    }\n\t\t\t    goto done;\n\t\t    } else if(ret != KDC_PR_UNKNOWN && ret != SKDC_CANT){\n\t\t\t    /* failure */\n\t\t\t    Debug(\"kerberos verify failure %d\\n\", ret);\n\t\t\t    krbtkfile[0] = '\\0';\n\t\t    }\n\t\t}\n\t}\n#  endif\n#  ifdef HAVE_GETSPNAM\n\terrno = 0;\n\tsp = getspnam(greet->name);\n\tif (sp == NULL) {\n\t    Debug (\"getspnam() failed: %s\\n\", _SysErrorMsg (errno));\n\t} else {\n\t    user_pass = sp->sp_pwdp;\n\t}\n#   ifndef QNX4\n\tendspent();\n#   endif  /* QNX4 doesn't need endspent() to end shadow passwd ops */\n#  endif /* HAVE_GETSPNAM */\n#  if defined(ultrix) || defined(__ultrix__)\n\tif (authenticate_user(p, greet->password, NULL) < 0)\n#  else\n\tif (strcmp (crypt (greet->password, user_pass), user_pass))\n#  endif\n\t{\n\t\tif(!greet->allow_null_passwd || strlen(p->pw_passwd) > 0) {\n\t\t\tDebug (\"password verify failed\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\treturn 0;\n\t\t} /* else: null passwd okay */\n\t}\n#  ifdef KERBEROS\ndone:\n#  endif\n\t/*\n\t * Only accept root logins if allowRootLogin resource is set\n\t */\n\tif ((p->pw_uid == 0) && !greet->allow_root_login) {\n\t\tDebug(\"root logins not allowed\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n#  ifdef __OpenBSD__\n\t/*\n\t * Shell must be in /etc/shells\n\t */\n\tfor (;;) {\n\t\ts = getusershell();\n\t\tif (s == NULL) {\n\t\t\t/* did not found the shell in /etc/shells\n\t\t\t   -> failure */\n\t\t\tDebug(\"shell not in /etc/shells\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\tendusershell();\n\t\t\treturn 0;\n\t\t}\n\t\tif (strcmp(s, p->pw_shell) == 0) {\n\t\t\t/* found the shell in /etc/shells */\n\t\t\tendusershell();\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Test for expired password\n\t */\n\tif (p->pw_change || p->pw_expire)\n\t\t(void)gettimeofday(&tp, (struct timezone *)NULL);\n\tif (p->pw_change) {\n\t\tif (tp.tv_sec >= p->pw_change) {\n\t\t\tDebug(\"Password has expired.\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (p->pw_expire) {\n\t\tif (tp.tv_sec >= p->pw_expire) {\n\t\t\tDebug(\"account has expired.\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\treturn 0;\n\t\t}\n\t}\n#  endif /* __OpenBSD__ */\n\tbzero(user_pass, strlen(user_pass)); /* in case shadow password */\n\n# endif /* USE_PAM */\n#endif /* USE_BSDAUTH */\n\n\tDebug (\"verify succeeded\\n\");\n\t/* The password is passed to StartClient() for use by user-based\n\t   authorization schemes.  It is zeroed there. */\n\tverify->uid = p->pw_uid;\n\tverify->gid = p->pw_gid;\n\thome = p->pw_dir;\n\tshell = p->pw_shell;\n\targv = NULL;\n\tif (d->session)\n\t\targv = parseArgs (argv, d->session);\n\tif (greet->string)\n\t\targv = parseArgs (argv, greet->string);\n\tif (!argv)\n\t\targv = parseArgs (argv, \"xsession\");\n\tverify->argv = argv;\n\tverify->userEnviron = userEnv (d, p->pw_uid == 0,\n\t\t\t\t       greet->name, home, shell);\n\tDebug (\"user environment:\\n\");\n\tprintEnv (verify->userEnviron);\n\tverify->systemEnviron = systemEnv (d, greet->name, home);\n\tDebug (\"system environment:\\n\");\n\tprintEnv (verify->systemEnviron);\n\tDebug (\"end of environments\\n\");\n\treturn 1;\n}",
        "func": "_X_INTERNAL\nint\nVerify (struct display *d, struct greet_info *greet, struct verify_info *verify)\n{\n\tstruct passwd\t*p;\n\tlogin_cap_t\t*lc;\n\tauth_session_t\t*as;\n\tchar\t\t*style, *shell, *home, *s, **argv;\n\tchar\t\tpath[MAXPATHLEN];\n\tint\t\tauthok;\n\n\t/* User may have specified an authentication style. */\n\tif ((style = strchr(greet->name, ':')) != NULL)\n\t\t*style++ = '\\0';\n\n\tDebug (\"Verify %s, style %s ...\\n\", greet->name,\n\t    style ? style : \"default\");\n\n\tp = getpwnam (greet->name);\n\tendpwent();\n\n\tif (!p || strlen (greet->name) == 0) {\n\t\tDebug(\"getpwnam() failed.\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n\tif ((lc = login_getclass(p->pw_class)) == NULL) {\n\t\tDebug(\"login_getclass() failed.\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\tif ((style = login_getstyle(lc, style, \"xdm\")) == NULL) {\n\t\tDebug(\"login_getstyle() failed.\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\tif ((as = auth_open()) == NULL) {\n\t\tDebug(\"auth_open() failed.\\n\");\n\t\tlogin_close(lc);\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\tif (auth_setoption(as, \"login\", \"yes\") == -1) {\n\t\tDebug(\"auth_setoption() failed.\\n\");\n\t\tlogin_close(lc);\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n\t/* Set up state for no challenge, just check a response. */\n\tauth_setstate(as, 0);\n\tauth_setdata(as, \"\", 1);\n\tauth_setdata(as, greet->password, strlen(greet->password) + 1);\n\n\t/* Build path of the auth script and call it */\n\tsnprintf(path, sizeof(path), _PATH_AUTHPROG \"%s\", style);\n\tauth_call(as, path, style, \"-s\", \"response\", greet->name,\n\t\t  lc->lc_class, (void *)NULL);\n\tauthok = auth_getstate(as);\n\n\tif ((authok & AUTH_ALLOW) == 0) {\n\t\tDebug(\"password verify failed\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\tauth_close(as);\n\t\tlogin_close(lc);\n\t\treturn 0;\n\t}\n\t/* Run the approval script */\n\tif (!auth_approval(as, lc, greet->name, \"auth-xdm\")) {\n\t\tDebug(\"login not approved\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\tauth_close(as);\n\t\tlogin_close(lc);\n\t\treturn 0;\n\t}\n\tauth_close(as);\n\tlogin_close(lc);\n\t/* Check empty passwords against allowNullPasswd */\n\tif (!greet->allow_null_passwd && strlen(greet->password) == 0) {\n\t\tDebug(\"empty password not allowed\\n\");\n\t\treturn 0;\n\t}\n\t/* Only accept root logins if allowRootLogin resource is set */\n\tif (p->pw_uid == 0 && !greet->allow_root_login) {\n\t\tDebug(\"root logins not allowed\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Shell must be in /etc/shells\n\t */\n\tfor (;;) {\n\t\ts = getusershell();\n\t\tif (s == NULL) {\n\t\t\t/* did not found the shell in /etc/shells\n\t\t\t   -> failure */\n\t\t\tDebug(\"shell not in /etc/shells\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\tendusershell();\n\t\t\treturn 0;\n\t\t}\n\t\tif (strcmp(s, p->pw_shell) == 0) {\n\t\t\t/* found the shell in /etc/shells */\n\t\t\tendusershell();\n\t\t\tbreak;\n\t\t}\n\t}\n#elif defined(USESECUREWARE) /* !USE_BSDAUTH */\n/*\n * This is a global variable and will be referenced in at least session.c\n */\nstruct smp_user_info *userp = 0;\n\n_X_INTERNAL\nint\nVerify (struct display *d, struct greet_info *greet, struct verify_info *verify)\n{\n  int ret, pwtries = 0, nis, delay;\n  char *reason = 0;\n  struct passwd\t*p;\n  char *shell, *home, **argv;\n\n  Debug (\"Verify %s ...\\n\", greet->name);\n\n  p = getpwnam (greet->name);\n  endpwent();\n\n  if (!p || strlen (greet->name) == 0) {\n    LogError (\"getpwnam() failed.\\n\");\n    bzero(greet->password, strlen(greet->password));\n    return 0;\n  }\n\n  ret = smp_check_user (SMP_LOGIN, greet->name, 0, 0, &userp, &pwtries,\n    &reason, &nis, &delay);\n  if (ret != SMP_RETIRED && userp->retired)\n    ret = userp->result = SMP_RETIRED;\n  Debug (\"smp_check_user returns %d\\n\", ret);\n\n  switch (ret) {\n    case SMP_FAIL:\n      Debug (\"Out of memory in smp_check_user\\n\");\n      goto smp_fail;\n    case SMP_EXTFAIL:\n      Debug (\"SMP_EXTFAIL: %s\", reason);\n      goto smp_fail;\n    case SMP_NOTAUTH:\n      Debug (\"Not authorized\\n\");\n      goto smp_fail;\n    case SMP_TERMLOCK:\n      Debug (\"Terminal is locked!\\n\");\n      goto smp_fail;\n    case SMP_ACCTLOCK:\n      Debug (\"Account is locked\\n\");\n      goto smp_fail;\n    case SMP_RETIRED:\n      Debug (\"Account is retired\\n\");\n      goto smp_fail;\n    case SMP_OVERRIDE:\n      Debug (\"On override device ... proceeding\\n\");\n      break;\n    case SMP_NULLPW:\n      Debug (\"NULL password entry\\n\");\n      if (!greet->allow_null_passwd) {\n        goto smp_fail;\n      }\n      break;\n    case SMP_BADUSER:\n      Debug (\"User not found in protected password database\\n\");\n      goto smp_fail;\n    case SMP_PWREQ:\n      Debug (\"Password change required\\n\");\n      goto smp_fail;\n    case SMP_HASPW:\n      break;\n    default:\n      Debug (\"Unhandled smp_check_user return %d\\n\", ret);\nsmp_fail:\n      sleep(delay);\n      smp_audit_fail (userp, 0);\n      bzero(greet->password, strlen(greet->password));\n      return 0;\n      break;\n  }\n\n  if (ret != SMP_NULLPW) {\n    /*\n     * If we require a password, check it.\n     */\n    ret = smp_check_pw (greet->password, userp, &reason);\n    switch (ret) {\n      case SMP_CANCHANGE:\n      case SMP_CANTCHANGE:\n      case SMP_OVERRIDE:\n        break;\n      default:\n        goto smp_fail;\n    }\n  }\n#else /* !USE_BSDAUTH && !USESECUREWARE */\n_X_INTERNAL\nint\nVerify (struct display *d, struct greet_info *greet, struct verify_info *verify)\n{\n\tstruct passwd\t*p;\n# ifndef USE_PAM\n#  ifdef HAVE_GETSPNAM\n\tstruct spwd\t*sp;\n#  endif\n\tchar\t\t*user_pass = NULL;\n\tchar\t\t*crypted_pass = NULL;\n# endif\n# ifdef __OpenBSD__\n\tchar            *s;\n\tstruct timeval  tp;\n# endif\n\tchar\t\t*shell, *home;\n\tchar\t\t**argv;\n\n\tDebug (\"Verify %s ...\\n\", greet->name);\n\n\tp = getpwnam (greet->name);\n\tendpwent();\n\n\tif (!p || strlen (greet->name) == 0) {\n\t\tDebug (\"getpwnam() failed.\\n\");\n\t\tif (greet->password != NULL)\n\t\t    bzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Only accept root logins if allowRootLogin resource is not false\n\t */\n\tif ((p->pw_uid == 0) && !greet->allow_root_login) {\n\t\tDebug(\"root logins not allowed\\n\");\n\t\tif (greet->password != NULL)\n\t\t    bzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n\n# if defined(sun) && defined(SVR4)\n\t/* Solaris: If CONSOLE is set to /dev/console in /etc/default/login,\n\t   then root can only login on system console */\n\n#  define SOLARIS_LOGIN_DEFAULTS \"/etc/default/login\"\n\n\tif (p->pw_uid == 0) {\n\t    char *console = NULL, *tmp = NULL;\n\t    FILE *fs;\n\n\t    if ((fs= fopen(SOLARIS_LOGIN_DEFAULTS, \"r\")) != NULL)\n\t    {\n\t\tchar str[120];\n\t\twhile (!feof(fs))\n\t\t{\n\t\t    fgets(str, 120, fs);\n\t\t    if(str[0] == '#' || strlen(str) < 8)\n\t\t\tcontinue;\n\t\t    if((tmp = strstr(str, \"CONSOLE=\")) != NULL)\n\t\t\tconsole = strdup((tmp+8));\n\t\t}\n\t\tfclose(fs);\n                if ( console != NULL &&\n\t\t  (strncmp(console, \"/dev/console\", 12) == 0) &&\n\t\t  (strncmp(d->name,\":0\",2) != 0) )\n\t\t{\n                        Debug(\"Not on system console\\n\");\n\t\t\tif (greet->password != NULL)\n\t\t\t    bzero(greet->password, strlen(greet->password));\n\t\t\tfree(console);\n\t                return 0;\n                }\n\t\tfree(console);\n\t    }\n\t    else\n\t    {\n\t\tDebug(\"Could not open %s\\n\", SOLARIS_LOGIN_DEFAULTS);\n\t    }\n\t}\n# endif\n\n# ifndef USE_PAM /* PAM authentication happened in GreetUser already */\n#  ifdef linux\n\tif (!strcmp(p->pw_passwd, \"!\") || !strcmp(p->pw_passwd, \"*\")) {\n\t    Debug (\"The account is locked, no login allowed.\\n\");\n\t    bzero(greet->password, strlen(greet->password));\n\t    return 0;\n\t}\n#  endif\n\tuser_pass = p->pw_passwd;\n#  ifdef KERBEROS\n\tif(strcmp(greet->name, \"root\") != 0){\n\t\tchar name[ANAME_SZ];\n\t\tchar realm[REALM_SZ];\n\t\tchar *q;\n\t\tint ret;\n\n\t\tif(krb_get_lrealm(realm, 1)){\n\t\t\tDebug (\"Can't get Kerberos realm.\\n\");\n\t\t} else {\n\n\t\t    snprintf(krbtkfile, sizeof(krbktfile), \"%s.%s\",\n\t\t\t     TKT_ROOT, d->name);\n\t\t    krb_set_tkt_string(krbtkfile);\n\t\t    unlink(krbtkfile);\n\n\t\t    ret = krb_verify_user(greet->name, \"\", realm,\n\t\t\t\t      greet->password, 1, \"rcmd\");\n\n\t\t    if(ret == KSUCCESS){\n\t\t\t    chown(krbtkfile, p->pw_uid, p->pw_gid);\n\t\t\t    Debug(\"kerberos verify succeeded\\n\");\n\t\t\t    if (k_hasafs()) {\n\t\t\t\t    if (k_setpag() == -1)\n\t\t\t\t\t    LogError (\"setpag() failed for %s\\n\",\n\t\t\t\t\t\t      greet->name);\n\n\t\t\t\t    if((ret = k_afsklog(NULL, NULL)) != KSUCCESS)\n\t\t\t\t\t    LogError(\"Warning %s\\n\",\n\t\t\t\t\t\t     krb_get_err_text(ret));\n\t\t\t    }\n\t\t\t    goto done;\n\t\t    } else if(ret != KDC_PR_UNKNOWN && ret != SKDC_CANT){\n\t\t\t    /* failure */\n\t\t\t    Debug(\"kerberos verify failure %d\\n\", ret);\n\t\t\t    krbtkfile[0] = '\\0';\n\t\t    }\n\t\t}\n\t}\n#  endif\n#  ifdef HAVE_GETSPNAM\n\terrno = 0;\n\tsp = getspnam(greet->name);\n\tif (sp == NULL) {\n\t    Debug (\"getspnam() failed: %s\\n\", _SysErrorMsg (errno));\n\t} else {\n\t    user_pass = sp->sp_pwdp;\n\t}\n#   ifndef QNX4\n\tendspent();\n#   endif  /* QNX4 doesn't need endspent() to end shadow passwd ops */\n#  endif /* HAVE_GETSPNAM */\n#  if defined(ultrix) || defined(__ultrix__)\n\tif (authenticate_user(p, greet->password, NULL) < 0)\n#  else\n\tcrypted_pass = crypt (greet->password, user_pass);\n\tif ((crypted_pass == NULL)\n\t    || (strcmp (crypted_pass, user_pass)))\n#  endif\n\t{\n\t\tif(!greet->allow_null_passwd || strlen(p->pw_passwd) > 0) {\n\t\t\tDebug (\"password verify failed\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\treturn 0;\n\t\t} /* else: null passwd okay */\n\t}\n#  ifdef KERBEROS\ndone:\n#  endif\n\t/*\n\t * Only accept root logins if allowRootLogin resource is set\n\t */\n\tif ((p->pw_uid == 0) && !greet->allow_root_login) {\n\t\tDebug(\"root logins not allowed\\n\");\n\t\tbzero(greet->password, strlen(greet->password));\n\t\treturn 0;\n\t}\n#  ifdef __OpenBSD__\n\t/*\n\t * Shell must be in /etc/shells\n\t */\n\tfor (;;) {\n\t\ts = getusershell();\n\t\tif (s == NULL) {\n\t\t\t/* did not found the shell in /etc/shells\n\t\t\t   -> failure */\n\t\t\tDebug(\"shell not in /etc/shells\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\tendusershell();\n\t\t\treturn 0;\n\t\t}\n\t\tif (strcmp(s, p->pw_shell) == 0) {\n\t\t\t/* found the shell in /etc/shells */\n\t\t\tendusershell();\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Test for expired password\n\t */\n\tif (p->pw_change || p->pw_expire)\n\t\t(void)gettimeofday(&tp, (struct timezone *)NULL);\n\tif (p->pw_change) {\n\t\tif (tp.tv_sec >= p->pw_change) {\n\t\t\tDebug(\"Password has expired.\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (p->pw_expire) {\n\t\tif (tp.tv_sec >= p->pw_expire) {\n\t\t\tDebug(\"account has expired.\\n\");\n\t\t\tbzero(greet->password, strlen(greet->password));\n\t\t\treturn 0;\n\t\t}\n\t}\n#  endif /* __OpenBSD__ */\n\tbzero(user_pass, strlen(user_pass)); /* in case shadow password */\n\n# endif /* USE_PAM */\n#endif /* USE_BSDAUTH */\n\n\tDebug (\"verify succeeded\\n\");\n\t/* The password is passed to StartClient() for use by user-based\n\t   authorization schemes.  It is zeroed there. */\n\tverify->uid = p->pw_uid;\n\tverify->gid = p->pw_gid;\n\thome = p->pw_dir;\n\tshell = p->pw_shell;\n\targv = NULL;\n\tif (d->session)\n\t\targv = parseArgs (argv, d->session);\n\tif (greet->string)\n\t\targv = parseArgs (argv, greet->string);\n\tif (!argv)\n\t\targv = parseArgs (argv, \"xsession\");\n\tverify->argv = argv;\n\tverify->userEnviron = userEnv (d, p->pw_uid == 0,\n\t\t\t\t       greet->name, home, shell);\n\tDebug (\"user environment:\\n\");\n\tprintEnv (verify->userEnviron);\n\tverify->systemEnviron = systemEnv (d, greet->name, home);\n\tDebug (\"system environment:\\n\");\n\tprintEnv (verify->systemEnviron);\n\tDebug (\"end of environments\\n\");\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -210,6 +210,7 @@\n \tstruct spwd\t*sp;\n #  endif\n \tchar\t\t*user_pass = NULL;\n+\tchar\t\t*crypted_pass = NULL;\n # endif\n # ifdef __OpenBSD__\n \tchar            *s;\n@@ -345,7 +346,9 @@\n #  if defined(ultrix) || defined(__ultrix__)\n \tif (authenticate_user(p, greet->password, NULL) < 0)\n #  else\n-\tif (strcmp (crypt (greet->password, user_pass), user_pass))\n+\tcrypted_pass = crypt (greet->password, user_pass);\n+\tif ((crypted_pass == NULL)\n+\t    || (strcmp (crypted_pass, user_pass)))\n #  endif\n \t{\n \t\tif(!greet->allow_null_passwd || strlen(p->pw_passwd) > 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (strcmp (crypt (greet->password, user_pass), user_pass))"
            ],
            "added_lines": [
                "\tchar\t\t*crypted_pass = NULL;",
                "\tcrypted_pass = crypt (greet->password, user_pass);",
                "\tif ((crypted_pass == NULL)",
                "\t    || (strcmp (crypted_pass, user_pass)))"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6450",
        "func_name": "openssl/tls1_change_cipher_state",
        "description": "The DTLS retransmission implementation in OpenSSL 1.0.0 before 1.0.0l and 1.0.1 before 1.0.1f does not properly maintain data structures for digest and encryption contexts, which might allow man-in-the-middle attackers to trigger the use of a different context and cause a denial of service (application crash) by interfering with packet delivery, related to ssl/d1_both.c and ssl/t1_enc.c.",
        "git_url": "http://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=34628967f1e65dc8f34e000f0f5518e21afbfc7b",
        "commit_title": "",
        "commit_text": "Fix DTLS retransmission from previous session.  For DTLS we might need to retransmit messages from the previous session so keep a copy of write context in DTLS retransmission buffers instead of replacing it after sending CCS. CVE-2013-6450. ",
        "func_before": "int tls1_change_cipher_state(SSL *s, int which)\n\t{\n\tstatic const unsigned char empty[]=\"\";\n\tunsigned char *p,*mac_secret;\n\tunsigned char *exp_label;\n\tunsigned char tmp1[EVP_MAX_KEY_LENGTH];\n\tunsigned char tmp2[EVP_MAX_KEY_LENGTH];\n\tunsigned char iv1[EVP_MAX_IV_LENGTH*2];\n\tunsigned char iv2[EVP_MAX_IV_LENGTH*2];\n\tunsigned char *ms,*key,*iv;\n\tint client_write;\n\tEVP_CIPHER_CTX *dd;\n\tconst EVP_CIPHER *c;\n#ifndef OPENSSL_NO_COMP\n\tconst SSL_COMP *comp;\n#endif\n\tconst EVP_MD *m;\n\tint mac_type;\n\tint *mac_secret_size;\n\tEVP_MD_CTX *mac_ctx;\n\tEVP_PKEY *mac_key;\n\tint is_export,n,i,j,k,exp_label_len,cl;\n\tint reuse_dd = 0;\n\n\tis_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\n\tc=s->s3->tmp.new_sym_enc;\n\tm=s->s3->tmp.new_hash;\n\tmac_type = s->s3->tmp.new_mac_pkey_type;\n#ifndef OPENSSL_NO_COMP\n\tcomp=s->s3->tmp.new_compression;\n#endif\n\n#ifdef KSSL_DEBUG\n\tprintf(\"tls1_change_cipher_state(which= %d) w/\\n\", which);\n\tprintf(\"\\talg= %ld/%ld, comp= %p\\n\",\n\t       s->s3->tmp.new_cipher->algorithm_mkey,\n\t       s->s3->tmp.new_cipher->algorithm_auth,\n\t       comp);\n\tprintf(\"\\tevp_cipher == %p ==? &d_cbc_ede_cipher3\\n\", c);\n\tprintf(\"\\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\\n\",\n                c->nid,c->block_size,c->key_len,c->iv_len);\n\tprintf(\"\\tkey_block: len= %d, data= \", s->s3->tmp.key_block_length);\n\t{\n        int i;\n        for (i=0; i<s->s3->tmp.key_block_length; i++)\n\t\tprintf(\"%02x\", s->s3->tmp.key_block[i]);  printf(\"\\n\");\n        }\n#endif\t/* KSSL_DEBUG */\n\n\tif (which & SSL3_CC_READ)\n\t\t{\n\t\tif (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n\t\t\ts->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;\n\t\telse\n\t\t\ts->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;\n\n\t\tif (s->enc_read_ctx != NULL)\n\t\t\treuse_dd = 1;\n\t\telse if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\n\t\t\tgoto err;\n\t\telse\n\t\t\t/* make sure it's intialized in case we exit later with an error */\n\t\t\tEVP_CIPHER_CTX_init(s->enc_read_ctx);\n\t\tdd= s->enc_read_ctx;\n\t\tmac_ctx=ssl_replace_hash(&s->read_hash,NULL);\n#ifndef OPENSSL_NO_COMP\n\t\tif (s->expand != NULL)\n\t\t\t{\n\t\t\tCOMP_CTX_free(s->expand);\n\t\t\ts->expand=NULL;\n\t\t\t}\n\t\tif (comp != NULL)\n\t\t\t{\n\t\t\ts->expand=COMP_CTX_new(comp->method);\n\t\t\tif (s->expand == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\n\t\t\t\tgoto err2;\n\t\t\t\t}\n\t\t\tif (s->s3->rrec.comp == NULL)\n\t\t\t\ts->s3->rrec.comp=(unsigned char *)\n\t\t\t\t\tOPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);\n\t\t\tif (s->s3->rrec.comp == NULL)\n\t\t\t\tgoto err;\n\t\t\t}\n#endif\n\t\t/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */\n \t\tif (s->version != DTLS1_VERSION)\n\t\t\tmemset(&(s->s3->read_sequence[0]),0,8);\n\t\tmac_secret= &(s->s3->read_mac_secret[0]);\n\t\tmac_secret_size=&(s->s3->read_mac_secret_size);\n\t\t}\n\telse\n\t\t{\n\t\tif (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n\t\t\ts->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\n\t\t\telse\n\t\t\ts->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;\n\t\tif (s->enc_write_ctx != NULL)\n\t\t\treuse_dd = 1;\n\t\telse if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\n\t\t\tgoto err;\n\t\telse\n\t\t\t/* make sure it's intialized in case we exit later with an error */\n\t\t\tEVP_CIPHER_CTX_init(s->enc_write_ctx);\n\t\tdd= s->enc_write_ctx;\n\t\tmac_ctx = ssl_replace_hash(&s->write_hash,NULL);\n#ifndef OPENSSL_NO_COMP\n\t\tif (s->compress != NULL)\n\t\t\t{\n\t\t\tCOMP_CTX_free(s->compress);\n\t\t\ts->compress=NULL;\n\t\t\t}\n\t\tif (comp != NULL)\n\t\t\t{\n\t\t\ts->compress=COMP_CTX_new(comp->method);\n\t\t\tif (s->compress == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\n\t\t\t\tgoto err2;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */\n \t\tif (s->version != DTLS1_VERSION)\n\t\t\tmemset(&(s->s3->write_sequence[0]),0,8);\n\t\tmac_secret= &(s->s3->write_mac_secret[0]);\n\t\tmac_secret_size = &(s->s3->write_mac_secret_size);\n\t\t}\n\n\tif (reuse_dd)\n\t\tEVP_CIPHER_CTX_cleanup(dd);\n\n\tp=s->s3->tmp.key_block;\n\ti=*mac_secret_size=s->s3->tmp.new_mac_secret_size;\n\n\tcl=EVP_CIPHER_key_length(c);\n\tj=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\n\t               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\n\t/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */\n\t/* If GCM mode only part of IV comes from PRF */\n\tif (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n\t\tk = EVP_GCM_TLS_FIXED_IV_LEN;\n\telse\n\t\tk=EVP_CIPHER_iv_length(c);\n\tif (\t(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\n\t\t(which == SSL3_CHANGE_CIPHER_SERVER_READ))\n\t\t{\n\t\tms=  &(p[ 0]); n=i+i;\n\t\tkey= &(p[ n]); n+=j+j;\n\t\tiv=  &(p[ n]); n+=k+k;\n\t\texp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;\n\t\texp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;\n\t\tclient_write=1;\n\t\t}\n\telse\n\t\t{\n\t\tn=i;\n\t\tms=  &(p[ n]); n+=i+j;\n\t\tkey= &(p[ n]); n+=j+k;\n\t\tiv=  &(p[ n]); n+=k;\n\t\texp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;\n\t\texp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;\n\t\tclient_write=0;\n\t\t}\n\n\tif (n > s->s3->tmp.key_block_length)\n\t\t{\n\t\tSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);\n\t\tgoto err2;\n\t\t}\n\n\tmemcpy(mac_secret,ms,i);\n\n\tif (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))\n\t\t{\n\t\tmac_key = EVP_PKEY_new_mac_key(mac_type, NULL,\n\t\t\t\tmac_secret,*mac_secret_size);\n\t\tEVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);\n\t\tEVP_PKEY_free(mac_key);\n\t\t}\n#ifdef TLS_DEBUG\nprintf(\"which = %04X\\nmac key=\",which);\n{ int z; for (z=0; z<i; z++) printf(\"%02X%c\",ms[z],((z+1)%16)?' ':'\\n'); }\n#endif\n\tif (is_export)\n\t\t{\n\t\t/* In here I set both the read and write key/iv to the\n\t\t * same value since only the correct one will be used :-).\n\t\t */\n\t\tif (!tls1_PRF(ssl_get_algorithm2(s),\n\t\t\t\texp_label,exp_label_len,\n\t\t\t\ts->s3->client_random,SSL3_RANDOM_SIZE,\n\t\t\t\ts->s3->server_random,SSL3_RANDOM_SIZE,\n\t\t\t\tNULL,0,NULL,0,\n\t\t\t\tkey,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))\n\t\t\tgoto err2;\n\t\tkey=tmp1;\n\n\t\tif (k > 0)\n\t\t\t{\n\t\t\tif (!tls1_PRF(ssl_get_algorithm2(s),\n\t\t\t\t\tTLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,\n\t\t\t\t\ts->s3->client_random,SSL3_RANDOM_SIZE,\n\t\t\t\t\ts->s3->server_random,SSL3_RANDOM_SIZE,\n\t\t\t\t\tNULL,0,NULL,0,\n\t\t\t\t\tempty,0,iv1,iv2,k*2))\n\t\t\t\tgoto err2;\n\t\t\tif (client_write)\n\t\t\t\tiv=iv1;\n\t\t\telse\n\t\t\t\tiv= &(iv1[k]);\n\t\t\t}\n\t\t}\n\n\ts->session->key_arg_length=0;\n#ifdef KSSL_DEBUG\n\t{\n        int i;\n\tprintf(\"EVP_CipherInit_ex(dd,c,key=,iv=,which)\\n\");\n\tprintf(\"\\tkey= \"); for (i=0; i<c->key_len; i++) printf(\"%02x\", key[i]);\n\tprintf(\"\\n\");\n\tprintf(\"\\t iv= \"); for (i=0; i<c->iv_len; i++) printf(\"%02x\", iv[i]);\n\tprintf(\"\\n\");\n\t}\n#endif\t/* KSSL_DEBUG */\n\n\tif (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n\t\t{\n\t\tEVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));\n\t\tEVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);\n\t\t}\n\telse\t\n\t\tEVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));\n\n\t/* Needed for \"composite\" AEADs, such as RC4-HMAC-MD5 */\n\tif ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)\n\t\tEVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,\n\t\t\t\t*mac_secret_size,mac_secret);\n\n#ifdef TLS_DEBUG\nprintf(\"which = %04X\\nkey=\",which);\n{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(\"%02X%c\",key[z],((z+1)%16)?' ':'\\n'); }\nprintf(\"\\niv=\");\n{ int z; for (z=0; z<k; z++) printf(\"%02X%c\",iv[z],((z+1)%16)?' ':'\\n'); }\nprintf(\"\\n\");\n#endif\n\n\tOPENSSL_cleanse(tmp1,sizeof(tmp1));\n\tOPENSSL_cleanse(tmp2,sizeof(tmp1));\n\tOPENSSL_cleanse(iv1,sizeof(iv1));\n\tOPENSSL_cleanse(iv2,sizeof(iv2));\n\treturn(1);\nerr:\n\tSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);\nerr2:\n\treturn(0);\n\t}",
        "func": "int tls1_change_cipher_state(SSL *s, int which)\n\t{\n\tstatic const unsigned char empty[]=\"\";\n\tunsigned char *p,*mac_secret;\n\tunsigned char *exp_label;\n\tunsigned char tmp1[EVP_MAX_KEY_LENGTH];\n\tunsigned char tmp2[EVP_MAX_KEY_LENGTH];\n\tunsigned char iv1[EVP_MAX_IV_LENGTH*2];\n\tunsigned char iv2[EVP_MAX_IV_LENGTH*2];\n\tunsigned char *ms,*key,*iv;\n\tint client_write;\n\tEVP_CIPHER_CTX *dd;\n\tconst EVP_CIPHER *c;\n#ifndef OPENSSL_NO_COMP\n\tconst SSL_COMP *comp;\n#endif\n\tconst EVP_MD *m;\n\tint mac_type;\n\tint *mac_secret_size;\n\tEVP_MD_CTX *mac_ctx;\n\tEVP_PKEY *mac_key;\n\tint is_export,n,i,j,k,exp_label_len,cl;\n\tint reuse_dd = 0;\n\n\tis_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\n\tc=s->s3->tmp.new_sym_enc;\n\tm=s->s3->tmp.new_hash;\n\tmac_type = s->s3->tmp.new_mac_pkey_type;\n#ifndef OPENSSL_NO_COMP\n\tcomp=s->s3->tmp.new_compression;\n#endif\n\n#ifdef KSSL_DEBUG\n\tprintf(\"tls1_change_cipher_state(which= %d) w/\\n\", which);\n\tprintf(\"\\talg= %ld/%ld, comp= %p\\n\",\n\t       s->s3->tmp.new_cipher->algorithm_mkey,\n\t       s->s3->tmp.new_cipher->algorithm_auth,\n\t       comp);\n\tprintf(\"\\tevp_cipher == %p ==? &d_cbc_ede_cipher3\\n\", c);\n\tprintf(\"\\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\\n\",\n                c->nid,c->block_size,c->key_len,c->iv_len);\n\tprintf(\"\\tkey_block: len= %d, data= \", s->s3->tmp.key_block_length);\n\t{\n        int i;\n        for (i=0; i<s->s3->tmp.key_block_length; i++)\n\t\tprintf(\"%02x\", s->s3->tmp.key_block[i]);  printf(\"\\n\");\n        }\n#endif\t/* KSSL_DEBUG */\n\n\tif (which & SSL3_CC_READ)\n\t\t{\n\t\tif (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n\t\t\ts->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;\n\t\telse\n\t\t\ts->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;\n\n\t\tif (s->enc_read_ctx != NULL)\n\t\t\treuse_dd = 1;\n\t\telse if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\n\t\t\tgoto err;\n\t\telse\n\t\t\t/* make sure it's intialized in case we exit later with an error */\n\t\t\tEVP_CIPHER_CTX_init(s->enc_read_ctx);\n\t\tdd= s->enc_read_ctx;\n\t\tmac_ctx=ssl_replace_hash(&s->read_hash,NULL);\n#ifndef OPENSSL_NO_COMP\n\t\tif (s->expand != NULL)\n\t\t\t{\n\t\t\tCOMP_CTX_free(s->expand);\n\t\t\ts->expand=NULL;\n\t\t\t}\n\t\tif (comp != NULL)\n\t\t\t{\n\t\t\ts->expand=COMP_CTX_new(comp->method);\n\t\t\tif (s->expand == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\n\t\t\t\tgoto err2;\n\t\t\t\t}\n\t\t\tif (s->s3->rrec.comp == NULL)\n\t\t\t\ts->s3->rrec.comp=(unsigned char *)\n\t\t\t\t\tOPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);\n\t\t\tif (s->s3->rrec.comp == NULL)\n\t\t\t\tgoto err;\n\t\t\t}\n#endif\n\t\t/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */\n \t\tif (s->version != DTLS1_VERSION)\n\t\t\tmemset(&(s->s3->read_sequence[0]),0,8);\n\t\tmac_secret= &(s->s3->read_mac_secret[0]);\n\t\tmac_secret_size=&(s->s3->read_mac_secret_size);\n\t\t}\n\telse\n\t\t{\n\t\tif (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n\t\t\ts->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\n\t\t\telse\n\t\t\ts->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;\n\t\tif (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))\n\t\t\treuse_dd = 1;\n\t\telse if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)\n\t\t\tgoto err;\n\t\tdd= s->enc_write_ctx;\n\t\tif (SSL_IS_DTLS(s))\n\t\t\t{\n\t\t\tmac_ctx = EVP_MD_CTX_create();\n\t\t\tif (!mac_ctx)\n\t\t\t\tgoto err;\n\t\t\ts->write_hash = mac_ctx;\n\t\t\t}\n\t\telse\n\t\t\tmac_ctx = ssl_replace_hash(&s->write_hash,NULL);\n#ifndef OPENSSL_NO_COMP\n\t\tif (s->compress != NULL)\n\t\t\t{\n\t\t\tCOMP_CTX_free(s->compress);\n\t\t\ts->compress=NULL;\n\t\t\t}\n\t\tif (comp != NULL)\n\t\t\t{\n\t\t\ts->compress=COMP_CTX_new(comp->method);\n\t\t\tif (s->compress == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\n\t\t\t\tgoto err2;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */\n \t\tif (s->version != DTLS1_VERSION)\n\t\t\tmemset(&(s->s3->write_sequence[0]),0,8);\n\t\tmac_secret= &(s->s3->write_mac_secret[0]);\n\t\tmac_secret_size = &(s->s3->write_mac_secret_size);\n\t\t}\n\n\tif (reuse_dd)\n\t\tEVP_CIPHER_CTX_cleanup(dd);\n\n\tp=s->s3->tmp.key_block;\n\ti=*mac_secret_size=s->s3->tmp.new_mac_secret_size;\n\n\tcl=EVP_CIPHER_key_length(c);\n\tj=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\n\t               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\n\t/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */\n\t/* If GCM mode only part of IV comes from PRF */\n\tif (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n\t\tk = EVP_GCM_TLS_FIXED_IV_LEN;\n\telse\n\t\tk=EVP_CIPHER_iv_length(c);\n\tif (\t(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\n\t\t(which == SSL3_CHANGE_CIPHER_SERVER_READ))\n\t\t{\n\t\tms=  &(p[ 0]); n=i+i;\n\t\tkey= &(p[ n]); n+=j+j;\n\t\tiv=  &(p[ n]); n+=k+k;\n\t\texp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;\n\t\texp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;\n\t\tclient_write=1;\n\t\t}\n\telse\n\t\t{\n\t\tn=i;\n\t\tms=  &(p[ n]); n+=i+j;\n\t\tkey= &(p[ n]); n+=j+k;\n\t\tiv=  &(p[ n]); n+=k;\n\t\texp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;\n\t\texp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;\n\t\tclient_write=0;\n\t\t}\n\n\tif (n > s->s3->tmp.key_block_length)\n\t\t{\n\t\tSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);\n\t\tgoto err2;\n\t\t}\n\n\tmemcpy(mac_secret,ms,i);\n\n\tif (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))\n\t\t{\n\t\tmac_key = EVP_PKEY_new_mac_key(mac_type, NULL,\n\t\t\t\tmac_secret,*mac_secret_size);\n\t\tEVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);\n\t\tEVP_PKEY_free(mac_key);\n\t\t}\n#ifdef TLS_DEBUG\nprintf(\"which = %04X\\nmac key=\",which);\n{ int z; for (z=0; z<i; z++) printf(\"%02X%c\",ms[z],((z+1)%16)?' ':'\\n'); }\n#endif\n\tif (is_export)\n\t\t{\n\t\t/* In here I set both the read and write key/iv to the\n\t\t * same value since only the correct one will be used :-).\n\t\t */\n\t\tif (!tls1_PRF(ssl_get_algorithm2(s),\n\t\t\t\texp_label,exp_label_len,\n\t\t\t\ts->s3->client_random,SSL3_RANDOM_SIZE,\n\t\t\t\ts->s3->server_random,SSL3_RANDOM_SIZE,\n\t\t\t\tNULL,0,NULL,0,\n\t\t\t\tkey,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))\n\t\t\tgoto err2;\n\t\tkey=tmp1;\n\n\t\tif (k > 0)\n\t\t\t{\n\t\t\tif (!tls1_PRF(ssl_get_algorithm2(s),\n\t\t\t\t\tTLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,\n\t\t\t\t\ts->s3->client_random,SSL3_RANDOM_SIZE,\n\t\t\t\t\ts->s3->server_random,SSL3_RANDOM_SIZE,\n\t\t\t\t\tNULL,0,NULL,0,\n\t\t\t\t\tempty,0,iv1,iv2,k*2))\n\t\t\t\tgoto err2;\n\t\t\tif (client_write)\n\t\t\t\tiv=iv1;\n\t\t\telse\n\t\t\t\tiv= &(iv1[k]);\n\t\t\t}\n\t\t}\n\n\ts->session->key_arg_length=0;\n#ifdef KSSL_DEBUG\n\t{\n        int i;\n\tprintf(\"EVP_CipherInit_ex(dd,c,key=,iv=,which)\\n\");\n\tprintf(\"\\tkey= \"); for (i=0; i<c->key_len; i++) printf(\"%02x\", key[i]);\n\tprintf(\"\\n\");\n\tprintf(\"\\t iv= \"); for (i=0; i<c->iv_len; i++) printf(\"%02x\", iv[i]);\n\tprintf(\"\\n\");\n\t}\n#endif\t/* KSSL_DEBUG */\n\n\tif (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\n\t\t{\n\t\tEVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));\n\t\tEVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);\n\t\t}\n\telse\t\n\t\tEVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));\n\n\t/* Needed for \"composite\" AEADs, such as RC4-HMAC-MD5 */\n\tif ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)\n\t\tEVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,\n\t\t\t\t*mac_secret_size,mac_secret);\n\n#ifdef TLS_DEBUG\nprintf(\"which = %04X\\nkey=\",which);\n{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(\"%02X%c\",key[z],((z+1)%16)?' ':'\\n'); }\nprintf(\"\\niv=\");\n{ int z; for (z=0; z<k; z++) printf(\"%02X%c\",iv[z],((z+1)%16)?' ':'\\n'); }\nprintf(\"\\n\");\n#endif\n\n\tOPENSSL_cleanse(tmp1,sizeof(tmp1));\n\tOPENSSL_cleanse(tmp2,sizeof(tmp1));\n\tOPENSSL_cleanse(iv1,sizeof(iv1));\n\tOPENSSL_cleanse(iv2,sizeof(iv2));\n\treturn(1);\nerr:\n\tSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);\nerr2:\n\treturn(0);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,15 +96,20 @@\n \t\t\ts->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\n \t\t\telse\n \t\t\ts->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;\n-\t\tif (s->enc_write_ctx != NULL)\n+\t\tif (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))\n \t\t\treuse_dd = 1;\n-\t\telse if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\n+\t\telse if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)\n \t\t\tgoto err;\n+\t\tdd= s->enc_write_ctx;\n+\t\tif (SSL_IS_DTLS(s))\n+\t\t\t{\n+\t\t\tmac_ctx = EVP_MD_CTX_create();\n+\t\t\tif (!mac_ctx)\n+\t\t\t\tgoto err;\n+\t\t\ts->write_hash = mac_ctx;\n+\t\t\t}\n \t\telse\n-\t\t\t/* make sure it's intialized in case we exit later with an error */\n-\t\t\tEVP_CIPHER_CTX_init(s->enc_write_ctx);\n-\t\tdd= s->enc_write_ctx;\n-\t\tmac_ctx = ssl_replace_hash(&s->write_hash,NULL);\n+\t\t\tmac_ctx = ssl_replace_hash(&s->write_hash,NULL);\n #ifndef OPENSSL_NO_COMP\n \t\tif (s->compress != NULL)\n \t\t\t{",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (s->enc_write_ctx != NULL)",
                "\t\telse if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)",
                "\t\t\t/* make sure it's intialized in case we exit later with an error */",
                "\t\t\tEVP_CIPHER_CTX_init(s->enc_write_ctx);",
                "\t\tdd= s->enc_write_ctx;",
                "\t\tmac_ctx = ssl_replace_hash(&s->write_hash,NULL);"
            ],
            "added_lines": [
                "\t\tif (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))",
                "\t\telse if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)",
                "\t\tdd= s->enc_write_ctx;",
                "\t\tif (SSL_IS_DTLS(s))",
                "\t\t\t{",
                "\t\t\tmac_ctx = EVP_MD_CTX_create();",
                "\t\t\tif (!mac_ctx)",
                "\t\t\t\tgoto err;",
                "\t\t\ts->write_hash = mac_ctx;",
                "\t\t\t}",
                "\t\t\tmac_ctx = ssl_replace_hash(&s->write_hash,NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6450",
        "func_name": "openssl/dtls1_hm_fragment_free",
        "description": "The DTLS retransmission implementation in OpenSSL 1.0.0 before 1.0.0l and 1.0.1 before 1.0.1f does not properly maintain data structures for digest and encryption contexts, which might allow man-in-the-middle attackers to trigger the use of a different context and cause a denial of service (application crash) by interfering with packet delivery, related to ssl/d1_both.c and ssl/t1_enc.c.",
        "git_url": "http://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=34628967f1e65dc8f34e000f0f5518e21afbfc7b",
        "commit_title": "",
        "commit_text": "Fix DTLS retransmission from previous session.  For DTLS we might need to retransmit messages from the previous session so keep a copy of write context in DTLS retransmission buffers instead of replacing it after sending CCS. CVE-2013-6450. ",
        "func_before": "static void\ndtls1_hm_fragment_free(hm_fragment *frag)\n\t{\n\tif (frag->fragment) OPENSSL_free(frag->fragment);\n\tif (frag->reassembly) OPENSSL_free(frag->reassembly);\n\tOPENSSL_free(frag);\n\t}",
        "func": "static void\ndtls1_hm_fragment_free(hm_fragment *frag)\n\t{\n\n\tif (frag->msg_header.is_ccs)\n\t\t{\n\t\tEVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);\n\t\tEVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);\n\t\t}\n\tif (frag->fragment) OPENSSL_free(frag->fragment);\n\tif (frag->reassembly) OPENSSL_free(frag->reassembly);\n\tOPENSSL_free(frag);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,12 @@\n static void\n dtls1_hm_fragment_free(hm_fragment *frag)\n \t{\n+\n+\tif (frag->msg_header.is_ccs)\n+\t\t{\n+\t\tEVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);\n+\t\tEVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);\n+\t\t}\n \tif (frag->fragment) OPENSSL_free(frag->fragment);\n \tif (frag->reassembly) OPENSSL_free(frag->reassembly);\n \tOPENSSL_free(frag);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (frag->msg_header.is_ccs)",
                "\t\t{",
                "\t\tEVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);",
                "\t\tEVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6401",
        "func_name": "akheron/jansson/hashtable_get",
        "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
        "git_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
        "commit_title": "CVE-2013-6401: Change hash function, randomize hashes",
        "commit_text": " Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing and testing.",
        "func_before": "void *hashtable_get(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return pair->value;\n}",
        "func": "void *hashtable_get(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return pair->value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)",
        "diff_line_info": {
            "deleted_lines": [
                "    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];"
            ],
            "added_lines": [
                "    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6401",
        "func_name": "akheron/jansson/hashtable_iter_at",
        "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
        "git_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
        "commit_title": "CVE-2013-6401: Change hash function, randomize hashes",
        "commit_text": " Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing and testing.",
        "func_before": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return &pair->list;\n}",
        "func": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return &pair->list;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)",
        "diff_line_info": {
            "deleted_lines": [
                "    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];"
            ],
            "added_lines": [
                "    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6401",
        "func_name": "akheron/jansson/hashtable_set",
        "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
        "git_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
        "commit_title": "CVE-2013-6401: Change hash function, randomize hashes",
        "commit_text": " Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing and testing.",
        "func_before": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t hash, index;\n\n    /* rehash if the load ratio exceeds 1 */\n    if(hashtable->size >= num_buckets(hashtable))\n        if(hashtable_do_rehash(hashtable))\n            return -1;\n\n    hash = hash_str(key);\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n\n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        /* offsetof(...) returns the size of pair_t without the last,\n           flexible member. This way, the correct amount is\n           allocated. */\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n\n        insert_to_bucket(hashtable, bucket, &pair->list);\n\n        hashtable->size++;\n    }\n    return 0;\n}",
        "func": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t hash, index;\n\n    /* rehash if the load ratio exceeds 1 */\n    if(hashtable->size >= hashsize(hashtable->order))\n        if(hashtable_do_rehash(hashtable))\n            return -1;\n\n    hash = hash_str(key);\n    index = hash & hashmask(hashtable->order);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n\n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        /* offsetof(...) returns the size of pair_t without the last,\n           flexible member. This way, the correct amount is\n           allocated. */\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n\n        insert_to_bucket(hashtable, bucket, &pair->list);\n\n        hashtable->size++;\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,12 +7,12 @@\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if(hashtable->size >= num_buckets(hashtable))",
                "    index = hash % num_buckets(hashtable);"
            ],
            "added_lines": [
                "    if(hashtable->size >= hashsize(hashtable->order))",
                "    index = hash & hashmask(hashtable->order);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6401",
        "func_name": "akheron/jansson/hashtable_init",
        "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
        "git_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
        "commit_title": "CVE-2013-6401: Change hash function, randomize hashes",
        "commit_text": " Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing and testing.",
        "func_before": "int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable->size = 0;\n    hashtable->num_buckets = 0;  /* index to primes[] */\n    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    list_init(&hashtable->list);\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    return 0;\n}",
        "func": "int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable->size = 0;\n    hashtable->order = 3;\n    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    list_init(&hashtable->list);\n\n    for(i = 0; i < hashsize(hashtable->order); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,14 +3,14 @@\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;",
        "diff_line_info": {
            "deleted_lines": [
                "    hashtable->num_buckets = 0;  /* index to primes[] */",
                "    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));",
                "    for(i = 0; i < num_buckets(hashtable); i++)"
            ],
            "added_lines": [
                "    hashtable->order = 3;",
                "    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));",
                "    for(i = 0; i < hashsize(hashtable->order); i++)"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6401",
        "func_name": "akheron/jansson/hashtable_do_rehash",
        "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
        "git_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
        "commit_title": "CVE-2013-6401: Change hash function, randomize hashes",
        "commit_text": " Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing and testing.",
        "func_before": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n\n    jsonp_free(hashtable->buckets);\n\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n\n    return 0;\n}",
        "func": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n\n    jsonp_free(hashtable->buckets);\n\n    hashtable->order++;\n    new_size = hashsize(hashtable->order);\n\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    for(i = 0; i < hashsize(hashtable->order); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,14 @@\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;",
        "diff_line_info": {
            "deleted_lines": [
                "    hashtable->num_buckets++;",
                "    new_size = num_buckets(hashtable);",
                "    for(i = 0; i < num_buckets(hashtable); i++)"
            ],
            "added_lines": [
                "    hashtable->order++;",
                "    new_size = hashsize(hashtable->order);",
                "    for(i = 0; i < hashsize(hashtable->order); i++)"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6401",
        "func_name": "akheron/jansson/hashtable_do_del",
        "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
        "git_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
        "commit_title": "CVE-2013-6401: Change hash function, randomize hashes",
        "commit_text": " Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing and testing.",
        "func_before": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n\n    list_remove(&pair->list);\n    json_decref(pair->value);\n\n    jsonp_free(pair);\n    hashtable->size--;\n\n    return 0;\n}",
        "func": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n\n    index = hash & hashmask(hashtable->order);\n    bucket = &hashtable->buckets[index];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n\n    list_remove(&pair->list);\n    json_decref(pair->value);\n\n    jsonp_free(pair);\n    hashtable->size--;\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);",
        "diff_line_info": {
            "deleted_lines": [
                "    index = hash % num_buckets(hashtable);"
            ],
            "added_lines": [
                "    index = hash & hashmask(hashtable->order);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6401",
        "func_name": "akheron/jansson/hashtable_clear",
        "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
        "git_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
        "commit_title": "CVE-2013-6401: Change hash function, randomize hashes",
        "commit_text": " Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing and testing.",
        "func_before": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable_do_clear(hashtable);\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}",
        "func": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable_do_clear(hashtable);\n\n    for(i = 0; i < hashsize(hashtable->order); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;",
        "diff_line_info": {
            "deleted_lines": [
                "    for(i = 0; i < num_buckets(hashtable); i++)"
            ],
            "added_lines": [
                "    for(i = 0; i < hashsize(hashtable->order); i++)"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6401",
        "func_name": "akheron/jansson/json_object",
        "description": "Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",
        "git_url": "https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4",
        "commit_title": "CVE-2013-6401: Change hash function, randomize hashes",
        "commit_text": " Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing and testing.",
        "func_before": "json_t *json_object(void)\n{\n    json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n    if(!object)\n        return NULL;\n    json_init(&object->json, JSON_OBJECT);\n\n    if(hashtable_init(&object->hashtable))\n    {\n        jsonp_free(object);\n        return NULL;\n    }\n\n    object->serial = 0;\n    object->visited = 0;\n\n    return &object->json;\n}",
        "func": "json_t *json_object(void)\n{\n    json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n    if(!object)\n        return NULL;\n\n    if (!hashtable_seed) {\n        /* Autoseed */\n        json_object_seed(0);\n    }\n\n    json_init(&object->json, JSON_OBJECT);\n\n    if(hashtable_init(&object->hashtable))\n    {\n        jsonp_free(object);\n        return NULL;\n    }\n\n    object->serial = 0;\n    object->visited = 0;\n\n    return &object->json;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,12 @@\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!hashtable_seed) {",
                "        /* Autoseed */",
                "        json_object_seed(0);",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2014-0076",
        "func_name": "openssl/ec_GF2m_montgomery_point_multiply",
        "description": "The Montgomery ladder implementation in OpenSSL through 1.0.0l does not ensure that certain swap operations have a constant-time behavior, which makes it easier for local users to obtain ECDSA nonces via a FLUSH+RELOAD cache side-channel attack.",
        "git_url": "http://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2198be3483259de374f91e57d247d0fc667aef29",
        "commit_title": "",
        "commit_text": "Fix for CVE-2014-0076  Fix for the attack described in the paper \"Recovering OpenSSL ECDSA Nonces Using the FLUSH+RELOAD Cache Side-channel Attack\" by Yuval Yarom and Naomi Benger. Details can be obtained from: http://eprint.iacr.org/2014/140  Thanks to Yuval Yarom and Naomi Benger for discovering this flaw and to Yuval Yarom for supplying a fix. ",
        "func_before": "static int ec_GF2m_montgomery_point_multiply(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\n\tconst EC_POINT *point, BN_CTX *ctx)\n\t{\n\tBIGNUM *x1, *x2, *z1, *z2;\n\tint ret = 0, i;\n\tBN_ULONG mask,word;\n\n\tif (r == point)\n\t\t{\n\t\tECerr(EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY, EC_R_INVALID_ARGUMENT);\n\t\treturn 0;\n\t\t}\n\t\n\t/* if result should be point at infinity */\n\tif ((scalar == NULL) || BN_is_zero(scalar) || (point == NULL) || \n\t\tEC_POINT_is_at_infinity(group, point))\n\t\t{\n\t\treturn EC_POINT_set_to_infinity(group, r);\n\t\t}\n\n\t/* only support affine coordinates */\n\tif (!point->Z_is_one) return 0;\n\n\t/* Since point_multiply is static we can guarantee that ctx != NULL. */\n\tBN_CTX_start(ctx);\n\tx1 = BN_CTX_get(ctx);\n\tz1 = BN_CTX_get(ctx);\n\tif (z1 == NULL) goto err;\n\n\tx2 = &r->X;\n\tz2 = &r->Y;\n\n\tif (!BN_GF2m_mod_arr(x1, &point->X, group->poly)) goto err; /* x1 = x */\n\tif (!BN_one(z1)) goto err; /* z1 = 1 */\n\tif (!group->meth->field_sqr(group, z2, x1, ctx)) goto err; /* z2 = x1^2 = x^2 */\n\tif (!group->meth->field_sqr(group, x2, z2, ctx)) goto err;\n\tif (!BN_GF2m_add(x2, x2, &group->b)) goto err; /* x2 = x^4 + b */\n\n\t/* find top most bit and go one past it */\n\ti = scalar->top - 1;\n\tmask = BN_TBIT;\n\tword = scalar->d[i];\n\twhile (!(word & mask)) mask >>= 1;\n\tmask >>= 1;\n\t/* if top most bit was at word break, go to next word */\n\tif (!mask) \n\t\t{\n\t\ti--;\n\t\tmask = BN_TBIT;\n\t\t}\n\n\tfor (; i >= 0; i--)\n\t\t{\n\t\tword = scalar->d[i];\n\t\twhile (mask)\n\t\t\t{\n\t\t\tif (word & mask)\n\t\t\t\t{\n\t\t\t\tif (!gf2m_Madd(group, &point->X, x1, z1, x2, z2, ctx)) goto err;\n\t\t\t\tif (!gf2m_Mdouble(group, x2, z2, ctx)) goto err;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx)) goto err;\n\t\t\t\tif (!gf2m_Mdouble(group, x1, z1, ctx)) goto err;\n\t\t\t\t}\n\t\t\tmask >>= 1;\n\t\t\t}\n\t\tmask = BN_TBIT;\n\t\t}\n\n\t/* convert out of \"projective\" coordinates */\n\ti = gf2m_Mxy(group, &point->X, &point->Y, x1, z1, x2, z2, ctx);\n\tif (i == 0) goto err;\n\telse if (i == 1) \n\t\t{\n\t\tif (!EC_POINT_set_to_infinity(group, r)) goto err;\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_one(&r->Z)) goto err;\n\t\tr->Z_is_one = 1;\n\t\t}\n\n\t/* GF(2^m) field elements should always have BIGNUM::neg = 0 */\n\tBN_set_negative(&r->X, 0);\n\tBN_set_negative(&r->Y, 0);\n\n\tret = 1;\n\n err:\n\tBN_CTX_end(ctx);\n\treturn ret;\n\t}",
        "func": "static int ec_GF2m_montgomery_point_multiply(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\n\tconst EC_POINT *point, BN_CTX *ctx)\n\t{\n\tBIGNUM *x1, *x2, *z1, *z2;\n\tint ret = 0, i;\n\tBN_ULONG mask,word;\n\n\tif (r == point)\n\t\t{\n\t\tECerr(EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY, EC_R_INVALID_ARGUMENT);\n\t\treturn 0;\n\t\t}\n\t\n\t/* if result should be point at infinity */\n\tif ((scalar == NULL) || BN_is_zero(scalar) || (point == NULL) || \n\t\tEC_POINT_is_at_infinity(group, point))\n\t\t{\n\t\treturn EC_POINT_set_to_infinity(group, r);\n\t\t}\n\n\t/* only support affine coordinates */\n\tif (!point->Z_is_one) return 0;\n\n\t/* Since point_multiply is static we can guarantee that ctx != NULL. */\n\tBN_CTX_start(ctx);\n\tx1 = BN_CTX_get(ctx);\n\tz1 = BN_CTX_get(ctx);\n\tif (z1 == NULL) goto err;\n\n\tx2 = &r->X;\n\tz2 = &r->Y;\n\n\tbn_wexpand(x1, group->field.top);\n\tbn_wexpand(z1, group->field.top);\n\tbn_wexpand(x2, group->field.top);\n\tbn_wexpand(z2, group->field.top);\n\n\tif (!BN_GF2m_mod_arr(x1, &point->X, group->poly)) goto err; /* x1 = x */\n\tif (!BN_one(z1)) goto err; /* z1 = 1 */\n\tif (!group->meth->field_sqr(group, z2, x1, ctx)) goto err; /* z2 = x1^2 = x^2 */\n\tif (!group->meth->field_sqr(group, x2, z2, ctx)) goto err;\n\tif (!BN_GF2m_add(x2, x2, &group->b)) goto err; /* x2 = x^4 + b */\n\n\t/* find top most bit and go one past it */\n\ti = scalar->top - 1;\n\tmask = BN_TBIT;\n\tword = scalar->d[i];\n\twhile (!(word & mask)) mask >>= 1;\n\tmask >>= 1;\n\t/* if top most bit was at word break, go to next word */\n\tif (!mask) \n\t\t{\n\t\ti--;\n\t\tmask = BN_TBIT;\n\t\t}\n\n\tfor (; i >= 0; i--)\n\t\t{\n\t\tword = scalar->d[i];\n\t\twhile (mask)\n\t\t\t{\n\t\t\tBN_consttime_swap(word & mask, x1, x2, group->field.top);\n\t\t\tBN_consttime_swap(word & mask, z1, z2, group->field.top);\n\t\t\tif (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx)) goto err;\n\t\t\tif (!gf2m_Mdouble(group, x1, z1, ctx)) goto err;\n\t\t\tBN_consttime_swap(word & mask, x1, x2, group->field.top);\n\t\t\tBN_consttime_swap(word & mask, z1, z2, group->field.top);\n\t\t\tmask >>= 1;\n\t\t\t}\n\t\tmask = BN_TBIT;\n\t\t}\n\n\t/* convert out of \"projective\" coordinates */\n\ti = gf2m_Mxy(group, &point->X, &point->Y, x1, z1, x2, z2, ctx);\n\tif (i == 0) goto err;\n\telse if (i == 1) \n\t\t{\n\t\tif (!EC_POINT_set_to_infinity(group, r)) goto err;\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_one(&r->Z)) goto err;\n\t\tr->Z_is_one = 1;\n\t\t}\n\n\t/* GF(2^m) field elements should always have BIGNUM::neg = 0 */\n\tBN_set_negative(&r->X, 0);\n\tBN_set_negative(&r->Y, 0);\n\n\tret = 1;\n\n err:\n\tBN_CTX_end(ctx);\n\treturn ret;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,11 @@\n \tx2 = &r->X;\n \tz2 = &r->Y;\n \n+\tbn_wexpand(x1, group->field.top);\n+\tbn_wexpand(z1, group->field.top);\n+\tbn_wexpand(x2, group->field.top);\n+\tbn_wexpand(z2, group->field.top);\n+\n \tif (!BN_GF2m_mod_arr(x1, &point->X, group->poly)) goto err; /* x1 = x */\n \tif (!BN_one(z1)) goto err; /* z1 = 1 */\n \tif (!group->meth->field_sqr(group, z2, x1, ctx)) goto err; /* z2 = x1^2 = x^2 */\n@@ -54,16 +59,12 @@\n \t\tword = scalar->d[i];\n \t\twhile (mask)\n \t\t\t{\n-\t\t\tif (word & mask)\n-\t\t\t\t{\n-\t\t\t\tif (!gf2m_Madd(group, &point->X, x1, z1, x2, z2, ctx)) goto err;\n-\t\t\t\tif (!gf2m_Mdouble(group, x2, z2, ctx)) goto err;\n-\t\t\t\t}\n-\t\t\telse\n-\t\t\t\t{\n-\t\t\t\tif (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx)) goto err;\n-\t\t\t\tif (!gf2m_Mdouble(group, x1, z1, ctx)) goto err;\n-\t\t\t\t}\n+\t\t\tBN_consttime_swap(word & mask, x1, x2, group->field.top);\n+\t\t\tBN_consttime_swap(word & mask, z1, z2, group->field.top);\n+\t\t\tif (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx)) goto err;\n+\t\t\tif (!gf2m_Mdouble(group, x1, z1, ctx)) goto err;\n+\t\t\tBN_consttime_swap(word & mask, x1, x2, group->field.top);\n+\t\t\tBN_consttime_swap(word & mask, z1, z2, group->field.top);\n \t\t\tmask >>= 1;\n \t\t\t}\n \t\tmask = BN_TBIT;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (word & mask)",
                "\t\t\t\t{",
                "\t\t\t\tif (!gf2m_Madd(group, &point->X, x1, z1, x2, z2, ctx)) goto err;",
                "\t\t\t\tif (!gf2m_Mdouble(group, x2, z2, ctx)) goto err;",
                "\t\t\t\t}",
                "\t\t\telse",
                "\t\t\t\t{",
                "\t\t\t\tif (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx)) goto err;",
                "\t\t\t\tif (!gf2m_Mdouble(group, x1, z1, ctx)) goto err;",
                "\t\t\t\t}"
            ],
            "added_lines": [
                "\tbn_wexpand(x1, group->field.top);",
                "\tbn_wexpand(z1, group->field.top);",
                "\tbn_wexpand(x2, group->field.top);",
                "\tbn_wexpand(z2, group->field.top);",
                "",
                "\t\t\tBN_consttime_swap(word & mask, x1, x2, group->field.top);",
                "\t\t\tBN_consttime_swap(word & mask, z1, z2, group->field.top);",
                "\t\t\tif (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx)) goto err;",
                "\t\t\tif (!gf2m_Mdouble(group, x1, z1, ctx)) goto err;",
                "\t\t\tBN_consttime_swap(word & mask, x1, x2, group->field.top);",
                "\t\t\tBN_consttime_swap(word & mask, z1, z2, group->field.top);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6370",
        "func_name": "json-c/lh_char_hash",
        "description": "Buffer overflow in the printbuf APIs in json-c before 0.12 allows remote attackers to cause a denial of service via unspecified vectors.",
        "git_url": "https://github.com/json-c/json-c/commit/64e36901a0614bf64a19bc3396469c66dcd0b015",
        "commit_title": "Patch to address the following issues:",
        "commit_text": " * CVE-2013-6371: hash collision denial of service * CVE-2013-6370: buffer overflow if size_t is larger than int",
        "func_before": "unsigned long lh_char_hash(const void *k)\n{\n\tunsigned int h = 0;\n\tconst char* data = (const char*)k;\n \n\twhile( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;\n\n\treturn h;\n}",
        "func": "unsigned long lh_char_hash(const void *k)\n{\n\tstatic volatile int random_seed = -1;\n\n\tif (random_seed == -1) {\n\t\tint seed;\n\t\t/* we can't use -1 as it is the unitialized sentinel */\n\t\twhile ((seed = json_c_get_random_seed()) == -1);\n#if defined __GNUC__\n\t\t__sync_val_compare_and_swap(&random_seed, -1, seed);\n#elif defined _MSC_VER\n\t\tInterlockedCompareExchange(&random_seed, seed, -1);\n#else\n#warning \"racy random seed initializtion if used by multiple threads\"\n\t\trandom_seed = seed; /* potentially racy */\n#endif\n\t}\n\n\treturn hashlittle((const char*)k, strlen((const char*)k), random_seed); \n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,20 @@\n unsigned long lh_char_hash(const void *k)\n {\n-\tunsigned int h = 0;\n-\tconst char* data = (const char*)k;\n- \n-\twhile( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;\n+\tstatic volatile int random_seed = -1;\n \n-\treturn h;\n+\tif (random_seed == -1) {\n+\t\tint seed;\n+\t\t/* we can't use -1 as it is the unitialized sentinel */\n+\t\twhile ((seed = json_c_get_random_seed()) == -1);\n+#if defined __GNUC__\n+\t\t__sync_val_compare_and_swap(&random_seed, -1, seed);\n+#elif defined _MSC_VER\n+\t\tInterlockedCompareExchange(&random_seed, seed, -1);\n+#else\n+#warning \"racy random seed initializtion if used by multiple threads\"\n+\t\trandom_seed = seed; /* potentially racy */\n+#endif\n+\t}\n+\n+\treturn hashlittle((const char*)k, strlen((const char*)k), random_seed); \n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned int h = 0;",
                "\tconst char* data = (const char*)k;",
                " ",
                "\twhile( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;",
                "\treturn h;"
            ],
            "added_lines": [
                "\tstatic volatile int random_seed = -1;",
                "\tif (random_seed == -1) {",
                "\t\tint seed;",
                "\t\t/* we can't use -1 as it is the unitialized sentinel */",
                "\t\twhile ((seed = json_c_get_random_seed()) == -1);",
                "#if defined __GNUC__",
                "\t\t__sync_val_compare_and_swap(&random_seed, -1, seed);",
                "#elif defined _MSC_VER",
                "\t\tInterlockedCompareExchange(&random_seed, seed, -1);",
                "#else",
                "#warning \"racy random seed initializtion if used by multiple threads\"",
                "\t\trandom_seed = seed; /* potentially racy */",
                "#endif",
                "\t}",
                "",
                "\treturn hashlittle((const char*)k, strlen((const char*)k), random_seed); "
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6370",
        "func_name": "json-c/json_tokener_parse_ex",
        "description": "Buffer overflow in the printbuf APIs in json-c before 0.12 allows remote attackers to cause a denial of service via unspecified vectors.",
        "git_url": "https://github.com/json-c/json-c/commit/64e36901a0614bf64a19bc3396469c66dcd0b015",
        "commit_title": "Patch to address the following issues:",
        "commit_text": " * CVE-2013-6371: hash collision denial of service * CVE-2013-6370: buffer overflow if size_t is larger than int",
        "func_before": "struct json_object* json_tokener_parse_ex(struct json_tokener *tok,\n\t\t\t\t\t  const char *str, int len)\n{\n  struct json_object *obj = NULL;\n  char c = '\\1';\n#ifdef HAVE_SETLOCALE\n  char *oldlocale=NULL, *tmplocale;\n\n  tmplocale = setlocale(LC_NUMERIC, NULL);\n  if (tmplocale) oldlocale = strdup(tmplocale);\n  setlocale(LC_NUMERIC, \"C\");\n#endif\n\n  tok->char_offset = 0;\n  tok->err = json_tokener_success;\n\n  while (PEEK_CHAR(c, tok)) {\n\n  redo_char:\n    switch(state) {\n\n    case json_tokener_state_eatws:\n      /* Advance until we change state */\n      while (isspace((int)c)) {\n\tif ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))\n\t  goto out;\n      }\n      if(c == '/' && !(tok->flags & JSON_TOKENER_STRICT)) {\n\tprintbuf_reset(tok->pb);\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tstate = json_tokener_state_comment_start;\n      } else {\n\tstate = saved_state;\n\tgoto redo_char;\n      }\n      break;\n\n    case json_tokener_state_start:\n      switch(c) {\n      case '{':\n\tstate = json_tokener_state_eatws;\n\tsaved_state = json_tokener_state_object_field_start;\n\tcurrent = json_object_new_object();\n\tbreak;\n      case '[':\n\tstate = json_tokener_state_eatws;\n\tsaved_state = json_tokener_state_array;\n\tcurrent = json_object_new_array();\n\tbreak;\n      case 'I':\n      case 'i':\n\tstate = json_tokener_state_inf;\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n      case 'N':\n      case 'n':\n\tstate = json_tokener_state_null; // or NaN\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n      case '\\'':\n        if (tok->flags & JSON_TOKENER_STRICT) {\n            /* in STRICT mode only double-quote are allowed */\n            tok->err = json_tokener_error_parse_unexpected;\n            goto out;\n        }\n      case '\"':\n\tstate = json_tokener_state_string;\n\tprintbuf_reset(tok->pb);\n\ttok->quote_char = c;\n\tbreak;\n      case 'T':\n      case 't':\n      case 'F':\n      case 'f':\n\tstate = json_tokener_state_boolean;\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n#if defined(__GNUC__)\n\t  case '0' ... '9':\n#else\n\t  case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n#endif\n      case '-':\n\tstate = json_tokener_state_number;\n\tprintbuf_reset(tok->pb);\n\ttok->is_double = 0;\n\tgoto redo_char;\n      default:\n\ttok->err = json_tokener_error_parse_unexpected;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_finish:\n      if(tok->depth == 0) goto out;\n      obj = json_object_get(current);\n      json_tokener_reset_level(tok, tok->depth);\n      tok->depth--;\n      goto redo_char;\n\n    case json_tokener_state_inf: /* aka starts with 'i' */\n      {\n\tint size;\n\tint size_inf;\n\tint is_negative = 0;\n\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize = json_min(tok->st_pos+1, json_null_str_len);\n\tsize_inf = json_min(tok->st_pos+1, json_inf_str_len);\n\tchar *infbuf = tok->pb->buf;\n\tif (*infbuf == '-')\n\t{\n\t\tinfbuf++;\n\t\tis_negative = 1;\n\t}\n\tif ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t          strncasecmp(json_inf_str, infbuf, size_inf) == 0) ||\n\t         (strncmp(json_inf_str, infbuf, size_inf) == 0)\n\t        )\n\t{\n\t\tif (tok->st_pos == json_inf_str_len)\n\t\t{\n\t\t\tcurrent = json_object_new_double(is_negative ? -INFINITY : INFINITY); \n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t} else {\n\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\tgoto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n    case json_tokener_state_null: /* aka starts with 'n' */\n      {\n\tint size;\n\tint size_nan;\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize = json_min(tok->st_pos+1, json_null_str_len);\n\tsize_nan = json_min(tok->st_pos+1, json_nan_str_len);\n\tif((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_null_str, tok->pb->buf, size) == 0)\n\t  || (strncmp(json_null_str, tok->pb->buf, size) == 0)\n\t  ) {\n\t  if (tok->st_pos == json_null_str_len) {\n\t    current = NULL;\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t}\n\telse if ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||\n\t         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0)\n\t        )\n\t{\n\t\tif (tok->st_pos == json_nan_str_len)\n\t\t{\n\t\t\tcurrent = json_object_new_double(NAN);\n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t} else {\n\t  tok->err = json_tokener_error_parse_null;\n\t  goto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n\n    case json_tokener_state_comment_start:\n      if(c == '*') {\n\tstate = json_tokener_state_comment;\n      } else if(c == '/') {\n\tstate = json_tokener_state_comment_eol;\n      } else {\n\ttok->err = json_tokener_error_parse_comment;\n\tgoto out;\n      }\n      printbuf_memappend_fast(tok->pb, &c, 1);\n      break;\n\n    case json_tokener_state_comment:\n              {\n          /* Advance until we change state */\n          const char *case_start = str;\n          while(c != '*') {\n            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n              printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n              goto out;\n            }\n          }\n          printbuf_memappend_fast(tok->pb, case_start, 1+str-case_start);\n          state = json_tokener_state_comment_end;\n        }\n            break;\n\n    case json_tokener_state_comment_eol:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(c != '\\n') {\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n\tprintbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\tstate = json_tokener_state_eatws;\n      }\n      break;\n\n    case json_tokener_state_comment_end:\n      printbuf_memappend_fast(tok->pb, &c, 1);\n      if(c == '/') {\n\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\tstate = json_tokener_state_eatws;\n      } else {\n\tstate = json_tokener_state_comment;\n      }\n      break;\n\n    case json_tokener_state_string:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(1) {\n\t  if(c == tok->quote_char) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    current = json_object_new_string_len(tok->pb->buf, tok->pb->bpos);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    break;\n\t  } else if(c == '\\\\') {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    saved_state = json_tokener_state_string;\n\t    state = json_tokener_state_string_escape;\n\t    break;\n\t  }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_string_escape:\n      switch(c) {\n      case '\"':\n      case '\\\\':\n      case '/':\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tstate = saved_state;\n\tbreak;\n      case 'b':\n      case 'n':\n      case 'r':\n      case 't':\n      case 'f':\n\tif(c == 'b') printbuf_memappend_fast(tok->pb, \"\\b\", 1);\n\telse if(c == 'n') printbuf_memappend_fast(tok->pb, \"\\n\", 1);\n\telse if(c == 'r') printbuf_memappend_fast(tok->pb, \"\\r\", 1);\n\telse if(c == 't') printbuf_memappend_fast(tok->pb, \"\\t\", 1);\n\telse if(c == 'f') printbuf_memappend_fast(tok->pb, \"\\f\", 1);\n\tstate = saved_state;\n\tbreak;\n      case 'u':\n\ttok->ucs_char = 0;\n\ttok->st_pos = 0;\n\tstate = json_tokener_state_escape_unicode;\n\tbreak;\n      default:\n\ttok->err = json_tokener_error_parse_string;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_escape_unicode:\n\t{\n          unsigned int got_hi_surrogate = 0;\n\n\t  /* Handle a 4-byte sequence, or two sequences if a surrogate pair */\n\t  while(1) {\n\t    if(strchr(json_hex_chars, c)) {\n\t      tok->ucs_char += ((unsigned int)hexdigit(c) << ((3-tok->st_pos++)*4));\n\t      if(tok->st_pos == 4) {\n\t\tunsigned char unescaped_utf[4];\n\n                if (got_hi_surrogate) {\n\t\t  if (IS_LOW_SURROGATE(tok->ucs_char)) {\n                    /* Recalculate the ucs_char, then fall thru to process normally */\n                    tok->ucs_char = DECODE_SURROGATE_PAIR(got_hi_surrogate, tok->ucs_char);\n                  } else {\n                    /* Hi surrogate was not followed by a low surrogate */\n                    /* Replace the hi and process the rest normally */\n\t\t    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                  }\n                  got_hi_surrogate = 0;\n                }\n\n\t\tif (tok->ucs_char < 0x80) {\n\t\t  unescaped_utf[0] = tok->ucs_char;\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 1);\n\t\t} else if (tok->ucs_char < 0x800) {\n\t\t  unescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);\n\t\t  unescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 2);\n\t\t} else if (IS_HIGH_SURROGATE(tok->ucs_char)) {\n                  /* Got a high surrogate.  Remember it and look for the\n                   * the beginning of another sequence, which should be the\n                   * low surrogate.\n                   */\n                  got_hi_surrogate = tok->ucs_char;\n                  /* Not at end, and the next two chars should be \"\\u\" */\n                  if ((tok->char_offset+1 != len) &&\n                      (tok->char_offset+2 != len) &&\n                      (str[1] == '\\\\') &&\n                      (str[2] == 'u'))\n                  {\n                /* Advance through the 16 bit surrogate, and move on to the\n                 * next sequence. The next step is to process the following\n                 * characters.\n                 */\n\t            if( !ADVANCE_CHAR(str, tok) || !ADVANCE_CHAR(str, tok) ) {\n                    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                }\n                    /* Advance to the first char of the next sequence and\n                     * continue processing with the next sequence.\n                     */\n\t            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t              printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n\t              goto out;\n                    }\n\t            tok->ucs_char = 0;\n                    tok->st_pos = 0;\n                    continue; /* other json_tokener_state_escape_unicode */\n                  } else {\n                    /* Got a high surrogate without another sequence following\n                     * it.  Put a replacement char in for the hi surrogate\n                     * and pretend we finished.\n                     */\n\t\t    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                  }\n\t\t} else if (IS_LOW_SURROGATE(tok->ucs_char)) {\n                  /* Got a low surrogate not preceded by a high */\n\t\t  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                } else if (tok->ucs_char < 0x10000) {\n\t\t  unescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);\n\t\t  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t  unescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 3);\n\t\t} else if (tok->ucs_char < 0x110000) {\n\t\t  unescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);\n\t\t  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);\n\t\t  unescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t  unescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 4);\n\t\t} else {\n                  /* Don't know what we got--insert the replacement char */\n\t\t  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                }\n\t\tstate = saved_state;\n\t\tbreak;\n\t      }\n\t    } else {\n\t      tok->err = json_tokener_error_parse_string;\n\t      goto out;\n\t    }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n            if (got_hi_surrogate) /* Clean up any pending chars */\n\t      printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_boolean:\n      {\n\tint size1, size2;\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize1 = json_min(tok->st_pos+1, json_true_str_len);\n\tsize2 = json_min(tok->st_pos+1, json_false_str_len);\n\tif((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_true_str, tok->pb->buf, size1) == 0)\n\t  || (strncmp(json_true_str, tok->pb->buf, size1) == 0)\n\t  ) {\n\t  if(tok->st_pos == json_true_str_len) {\n\t    current = json_object_new_boolean(1);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t} else if((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_false_str, tok->pb->buf, size2) == 0)\n\t  || (strncmp(json_false_str, tok->pb->buf, size2) == 0)) {\n\t  if(tok->st_pos == json_false_str_len) {\n\t    current = json_object_new_boolean(0);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t} else {\n\t  tok->err = json_tokener_error_parse_boolean;\n\t  goto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n\n    case json_tokener_state_number:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\tint case_len=0;\n\twhile(c && strchr(json_number_chars, c)) {\n\t  ++case_len;\n\t  if(c == '.' || c == 'e' || c == 'E')\n\t    tok->is_double = 1;\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, case_len);\n\t    goto out;\n\t  }\n\t}\n        if (case_len>0)\n          printbuf_memappend_fast(tok->pb, case_start, case_len);\n\n\t// Check for -Infinity\n\tif (tok->pb->buf[0] == '-' && case_len == 1 &&\n\t    (c == 'i' || c == 'I'))\n\t{\n\t\tstate = json_tokener_state_inf;\n\t\tgoto redo_char;\n\t}\n      }\n      {\n\tint64_t num64;\n\tdouble  numd;\n\tif (!tok->is_double && json_parse_int64(tok->pb->buf, &num64) == 0) {\n\t\tif (num64 && tok->pb->buf[0]=='0' && (tok->flags & JSON_TOKENER_STRICT)) {\n\t\t\t/* in strict mode, number must not start with 0 */\n\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\tgoto out;\n\t\t}\n\t\tcurrent = json_object_new_int64(num64);\n\t}\n\telse if(tok->is_double && json_parse_double(tok->pb->buf, &numd) == 0)\n\t{\n          current = json_object_new_double_s(numd, tok->pb->buf);\n        } else {\n          tok->err = json_tokener_error_parse_number;\n          goto out;\n        }\n        saved_state = json_tokener_state_finish;\n        state = json_tokener_state_eatws;\n        goto redo_char;\n      }\n      break;\n\n    case json_tokener_state_array_after_sep:\n    case json_tokener_state_array:\n      if(c == ']') {\n\t\tif (state == json_tokener_state_array_after_sep &&\n\t\t\t(tok->flags & JSON_TOKENER_STRICT))\n\t\t{\n\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\tgoto out;\n\t\t}\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else {\n\tif(tok->depth >= tok->max_depth-1) {\n\t  tok->err = json_tokener_error_depth;\n\t  goto out;\n\t}\n\tstate = json_tokener_state_array_add;\n\ttok->depth++;\n\tjson_tokener_reset_level(tok, tok->depth);\n\tgoto redo_char;\n      }\n      break;\n\n    case json_tokener_state_array_add:\n      json_object_array_add(current, obj);\n      saved_state = json_tokener_state_array_sep;\n      state = json_tokener_state_eatws;\n      goto redo_char;\n\n    case json_tokener_state_array_sep:\n      if(c == ']') {\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if(c == ',') {\n\tsaved_state = json_tokener_state_array_after_sep;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_array;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_field_start:\n    case json_tokener_state_object_field_start_after_sep:\n      if(c == '}') {\n\t\tif (state == json_tokener_state_object_field_start_after_sep &&\n\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t{\n\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\tgoto out;\n\t\t}\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if (c == '\"' || c == '\\'') {\n\ttok->quote_char = c;\n\tprintbuf_reset(tok->pb);\n\tstate = json_tokener_state_object_field;\n      } else {\n\ttok->err = json_tokener_error_parse_object_key_name;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_field:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(1) {\n\t  if(c == tok->quote_char) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    obj_field_name = strdup(tok->pb->buf);\n\t    saved_state = json_tokener_state_object_field_end;\n\t    state = json_tokener_state_eatws;\n\t    break;\n\t  } else if(c == '\\\\') {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    saved_state = json_tokener_state_object_field;\n\t    state = json_tokener_state_string_escape;\n\t    break;\n\t  }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_object_field_end:\n      if(c == ':') {\n\tsaved_state = json_tokener_state_object_value;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_object_key_sep;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_value:\n      if(tok->depth >= tok->max_depth-1) {\n\ttok->err = json_tokener_error_depth;\n\tgoto out;\n      }\n      state = json_tokener_state_object_value_add;\n      tok->depth++;\n      json_tokener_reset_level(tok, tok->depth);\n      goto redo_char;\n\n    case json_tokener_state_object_value_add:\n      json_object_object_add(current, obj_field_name, obj);\n      free(obj_field_name);\n      obj_field_name = NULL;\n      saved_state = json_tokener_state_object_sep;\n      state = json_tokener_state_eatws;\n      goto redo_char;\n\n    case json_tokener_state_object_sep:\n      if(c == '}') {\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if(c == ',') {\n\tsaved_state = json_tokener_state_object_field_start_after_sep;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_object_value_sep;\n\tgoto out;\n      }\n      break;\n\n    }\n    if (!ADVANCE_CHAR(str, tok))\n      goto out;\n  } /* while(POP_CHAR) */\n\n out:\n  if (c &&\n     (state == json_tokener_state_finish) &&\n     (tok->depth == 0) &&\n     (tok->flags & JSON_TOKENER_STRICT)) {\n      /* unexpected char after JSON data */\n      tok->err = json_tokener_error_parse_unexpected;\n  }\n  if (!c) { /* We hit an eof char (0) */\n    if(state != json_tokener_state_finish &&\n       saved_state != json_tokener_state_finish)\n      tok->err = json_tokener_error_parse_eof;\n  }\n\n#ifdef HAVE_SETLOCALE\n  setlocale(LC_NUMERIC, oldlocale);\n  if (oldlocale) free(oldlocale);\n#endif\n\n  if (tok->err == json_tokener_success)\n  {\n    json_object *ret = json_object_get(current);\n\tint ii;\n\n\t/* Partially reset, so we parse additional objects on subsequent calls. */\n    for(ii = tok->depth; ii >= 0; ii--)\n      json_tokener_reset_level(tok, ii);\n    return ret;\n  }\n\n  MC_DEBUG(\"json_tokener_parse_ex: error %s at offset %d\\n\",\n\t   json_tokener_errors[tok->err], tok->char_offset);\n  return NULL;\n}",
        "func": "struct json_object* json_tokener_parse_ex(struct json_tokener *tok,\n\t\t\t\t\t  const char *str, int len)\n{\n  struct json_object *obj = NULL;\n  char c = '\\1';\n#ifdef HAVE_SETLOCALE\n  char *oldlocale=NULL, *tmplocale;\n\n  tmplocale = setlocale(LC_NUMERIC, NULL);\n  if (tmplocale) oldlocale = strdup(tmplocale);\n  setlocale(LC_NUMERIC, \"C\");\n#endif\n\n  tok->char_offset = 0;\n  tok->err = json_tokener_success;\n\n  /* this interface is presently not 64-bit clean due to the int len argument\n     and the internal printbuf interface that takes 32-bit int len arguments\n     so the function limits the maximum string size to INT32_MAX (2GB).\n     If the function is called with len == -1 then strlen is called to check\n     the string length is less than INT32_MAX (2GB) */\n  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {\n    tok->err = json_tokener_error_size;\n    return NULL;\n  }\n\n  while (PEEK_CHAR(c, tok)) {\n\n  redo_char:\n    switch(state) {\n\n    case json_tokener_state_eatws:\n      /* Advance until we change state */\n      while (isspace((int)c)) {\n\tif ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))\n\t  goto out;\n      }\n      if(c == '/' && !(tok->flags & JSON_TOKENER_STRICT)) {\n\tprintbuf_reset(tok->pb);\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tstate = json_tokener_state_comment_start;\n      } else {\n\tstate = saved_state;\n\tgoto redo_char;\n      }\n      break;\n\n    case json_tokener_state_start:\n      switch(c) {\n      case '{':\n\tstate = json_tokener_state_eatws;\n\tsaved_state = json_tokener_state_object_field_start;\n\tcurrent = json_object_new_object();\n\tbreak;\n      case '[':\n\tstate = json_tokener_state_eatws;\n\tsaved_state = json_tokener_state_array;\n\tcurrent = json_object_new_array();\n\tbreak;\n      case 'I':\n      case 'i':\n\tstate = json_tokener_state_inf;\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n      case 'N':\n      case 'n':\n\tstate = json_tokener_state_null; // or NaN\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n      case '\\'':\n        if (tok->flags & JSON_TOKENER_STRICT) {\n            /* in STRICT mode only double-quote are allowed */\n            tok->err = json_tokener_error_parse_unexpected;\n            goto out;\n        }\n      case '\"':\n\tstate = json_tokener_state_string;\n\tprintbuf_reset(tok->pb);\n\ttok->quote_char = c;\n\tbreak;\n      case 'T':\n      case 't':\n      case 'F':\n      case 'f':\n\tstate = json_tokener_state_boolean;\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n#if defined(__GNUC__)\n\t  case '0' ... '9':\n#else\n\t  case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n#endif\n      case '-':\n\tstate = json_tokener_state_number;\n\tprintbuf_reset(tok->pb);\n\ttok->is_double = 0;\n\tgoto redo_char;\n      default:\n\ttok->err = json_tokener_error_parse_unexpected;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_finish:\n      if(tok->depth == 0) goto out;\n      obj = json_object_get(current);\n      json_tokener_reset_level(tok, tok->depth);\n      tok->depth--;\n      goto redo_char;\n\n    case json_tokener_state_inf: /* aka starts with 'i' */\n      {\n\tint size;\n\tint size_inf;\n\tint is_negative = 0;\n\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize = json_min(tok->st_pos+1, json_null_str_len);\n\tsize_inf = json_min(tok->st_pos+1, json_inf_str_len);\n\tchar *infbuf = tok->pb->buf;\n\tif (*infbuf == '-')\n\t{\n\t\tinfbuf++;\n\t\tis_negative = 1;\n\t}\n\tif ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t          strncasecmp(json_inf_str, infbuf, size_inf) == 0) ||\n\t         (strncmp(json_inf_str, infbuf, size_inf) == 0)\n\t        )\n\t{\n\t\tif (tok->st_pos == json_inf_str_len)\n\t\t{\n\t\t\tcurrent = json_object_new_double(is_negative ? -INFINITY : INFINITY); \n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t} else {\n\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\tgoto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n    case json_tokener_state_null: /* aka starts with 'n' */\n      {\n\tint size;\n\tint size_nan;\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize = json_min(tok->st_pos+1, json_null_str_len);\n\tsize_nan = json_min(tok->st_pos+1, json_nan_str_len);\n\tif((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_null_str, tok->pb->buf, size) == 0)\n\t  || (strncmp(json_null_str, tok->pb->buf, size) == 0)\n\t  ) {\n\t  if (tok->st_pos == json_null_str_len) {\n\t    current = NULL;\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t}\n\telse if ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||\n\t         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0)\n\t        )\n\t{\n\t\tif (tok->st_pos == json_nan_str_len)\n\t\t{\n\t\t\tcurrent = json_object_new_double(NAN);\n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t} else {\n\t  tok->err = json_tokener_error_parse_null;\n\t  goto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n\n    case json_tokener_state_comment_start:\n      if(c == '*') {\n\tstate = json_tokener_state_comment;\n      } else if(c == '/') {\n\tstate = json_tokener_state_comment_eol;\n      } else {\n\ttok->err = json_tokener_error_parse_comment;\n\tgoto out;\n      }\n      printbuf_memappend_fast(tok->pb, &c, 1);\n      break;\n\n    case json_tokener_state_comment:\n              {\n          /* Advance until we change state */\n          const char *case_start = str;\n          while(c != '*') {\n            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n              printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n              goto out;\n            }\n          }\n          printbuf_memappend_fast(tok->pb, case_start, 1+str-case_start);\n          state = json_tokener_state_comment_end;\n        }\n            break;\n\n    case json_tokener_state_comment_eol:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(c != '\\n') {\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n\tprintbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\tstate = json_tokener_state_eatws;\n      }\n      break;\n\n    case json_tokener_state_comment_end:\n      printbuf_memappend_fast(tok->pb, &c, 1);\n      if(c == '/') {\n\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\tstate = json_tokener_state_eatws;\n      } else {\n\tstate = json_tokener_state_comment;\n      }\n      break;\n\n    case json_tokener_state_string:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(1) {\n\t  if(c == tok->quote_char) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    current = json_object_new_string_len(tok->pb->buf, tok->pb->bpos);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    break;\n\t  } else if(c == '\\\\') {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    saved_state = json_tokener_state_string;\n\t    state = json_tokener_state_string_escape;\n\t    break;\n\t  }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_string_escape:\n      switch(c) {\n      case '\"':\n      case '\\\\':\n      case '/':\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tstate = saved_state;\n\tbreak;\n      case 'b':\n      case 'n':\n      case 'r':\n      case 't':\n      case 'f':\n\tif(c == 'b') printbuf_memappend_fast(tok->pb, \"\\b\", 1);\n\telse if(c == 'n') printbuf_memappend_fast(tok->pb, \"\\n\", 1);\n\telse if(c == 'r') printbuf_memappend_fast(tok->pb, \"\\r\", 1);\n\telse if(c == 't') printbuf_memappend_fast(tok->pb, \"\\t\", 1);\n\telse if(c == 'f') printbuf_memappend_fast(tok->pb, \"\\f\", 1);\n\tstate = saved_state;\n\tbreak;\n      case 'u':\n\ttok->ucs_char = 0;\n\ttok->st_pos = 0;\n\tstate = json_tokener_state_escape_unicode;\n\tbreak;\n      default:\n\ttok->err = json_tokener_error_parse_string;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_escape_unicode:\n\t{\n          unsigned int got_hi_surrogate = 0;\n\n\t  /* Handle a 4-byte sequence, or two sequences if a surrogate pair */\n\t  while(1) {\n\t    if(strchr(json_hex_chars, c)) {\n\t      tok->ucs_char += ((unsigned int)hexdigit(c) << ((3-tok->st_pos++)*4));\n\t      if(tok->st_pos == 4) {\n\t\tunsigned char unescaped_utf[4];\n\n                if (got_hi_surrogate) {\n\t\t  if (IS_LOW_SURROGATE(tok->ucs_char)) {\n                    /* Recalculate the ucs_char, then fall thru to process normally */\n                    tok->ucs_char = DECODE_SURROGATE_PAIR(got_hi_surrogate, tok->ucs_char);\n                  } else {\n                    /* Hi surrogate was not followed by a low surrogate */\n                    /* Replace the hi and process the rest normally */\n\t\t    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                  }\n                  got_hi_surrogate = 0;\n                }\n\n\t\tif (tok->ucs_char < 0x80) {\n\t\t  unescaped_utf[0] = tok->ucs_char;\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 1);\n\t\t} else if (tok->ucs_char < 0x800) {\n\t\t  unescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);\n\t\t  unescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 2);\n\t\t} else if (IS_HIGH_SURROGATE(tok->ucs_char)) {\n                  /* Got a high surrogate.  Remember it and look for the\n                   * the beginning of another sequence, which should be the\n                   * low surrogate.\n                   */\n                  got_hi_surrogate = tok->ucs_char;\n                  /* Not at end, and the next two chars should be \"\\u\" */\n                  if ((tok->char_offset+1 != len) &&\n                      (tok->char_offset+2 != len) &&\n                      (str[1] == '\\\\') &&\n                      (str[2] == 'u'))\n                  {\n                /* Advance through the 16 bit surrogate, and move on to the\n                 * next sequence. The next step is to process the following\n                 * characters.\n                 */\n\t            if( !ADVANCE_CHAR(str, tok) || !ADVANCE_CHAR(str, tok) ) {\n                    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                }\n                    /* Advance to the first char of the next sequence and\n                     * continue processing with the next sequence.\n                     */\n\t            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t              printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n\t              goto out;\n                    }\n\t            tok->ucs_char = 0;\n                    tok->st_pos = 0;\n                    continue; /* other json_tokener_state_escape_unicode */\n                  } else {\n                    /* Got a high surrogate without another sequence following\n                     * it.  Put a replacement char in for the hi surrogate\n                     * and pretend we finished.\n                     */\n\t\t    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                  }\n\t\t} else if (IS_LOW_SURROGATE(tok->ucs_char)) {\n                  /* Got a low surrogate not preceded by a high */\n\t\t  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                } else if (tok->ucs_char < 0x10000) {\n\t\t  unescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);\n\t\t  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t  unescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 3);\n\t\t} else if (tok->ucs_char < 0x110000) {\n\t\t  unescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);\n\t\t  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);\n\t\t  unescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t  unescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 4);\n\t\t} else {\n                  /* Don't know what we got--insert the replacement char */\n\t\t  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                }\n\t\tstate = saved_state;\n\t\tbreak;\n\t      }\n\t    } else {\n\t      tok->err = json_tokener_error_parse_string;\n\t      goto out;\n\t    }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n            if (got_hi_surrogate) /* Clean up any pending chars */\n\t      printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_boolean:\n      {\n\tint size1, size2;\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize1 = json_min(tok->st_pos+1, json_true_str_len);\n\tsize2 = json_min(tok->st_pos+1, json_false_str_len);\n\tif((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_true_str, tok->pb->buf, size1) == 0)\n\t  || (strncmp(json_true_str, tok->pb->buf, size1) == 0)\n\t  ) {\n\t  if(tok->st_pos == json_true_str_len) {\n\t    current = json_object_new_boolean(1);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t} else if((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_false_str, tok->pb->buf, size2) == 0)\n\t  || (strncmp(json_false_str, tok->pb->buf, size2) == 0)) {\n\t  if(tok->st_pos == json_false_str_len) {\n\t    current = json_object_new_boolean(0);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t} else {\n\t  tok->err = json_tokener_error_parse_boolean;\n\t  goto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n\n    case json_tokener_state_number:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\tint case_len=0;\n\twhile(c && strchr(json_number_chars, c)) {\n\t  ++case_len;\n\t  if(c == '.' || c == 'e' || c == 'E')\n\t    tok->is_double = 1;\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, case_len);\n\t    goto out;\n\t  }\n\t}\n        if (case_len>0)\n          printbuf_memappend_fast(tok->pb, case_start, case_len);\n\n\t// Check for -Infinity\n\tif (tok->pb->buf[0] == '-' && case_len == 1 &&\n\t    (c == 'i' || c == 'I'))\n\t{\n\t\tstate = json_tokener_state_inf;\n\t\tgoto redo_char;\n\t}\n      }\n      {\n\tint64_t num64;\n\tdouble  numd;\n\tif (!tok->is_double && json_parse_int64(tok->pb->buf, &num64) == 0) {\n\t\tif (num64 && tok->pb->buf[0]=='0' && (tok->flags & JSON_TOKENER_STRICT)) {\n\t\t\t/* in strict mode, number must not start with 0 */\n\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\tgoto out;\n\t\t}\n\t\tcurrent = json_object_new_int64(num64);\n\t}\n\telse if(tok->is_double && json_parse_double(tok->pb->buf, &numd) == 0)\n\t{\n          current = json_object_new_double_s(numd, tok->pb->buf);\n        } else {\n          tok->err = json_tokener_error_parse_number;\n          goto out;\n        }\n        saved_state = json_tokener_state_finish;\n        state = json_tokener_state_eatws;\n        goto redo_char;\n      }\n      break;\n\n    case json_tokener_state_array_after_sep:\n    case json_tokener_state_array:\n      if(c == ']') {\n\t\tif (state == json_tokener_state_array_after_sep &&\n\t\t\t(tok->flags & JSON_TOKENER_STRICT))\n\t\t{\n\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\tgoto out;\n\t\t}\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else {\n\tif(tok->depth >= tok->max_depth-1) {\n\t  tok->err = json_tokener_error_depth;\n\t  goto out;\n\t}\n\tstate = json_tokener_state_array_add;\n\ttok->depth++;\n\tjson_tokener_reset_level(tok, tok->depth);\n\tgoto redo_char;\n      }\n      break;\n\n    case json_tokener_state_array_add:\n      json_object_array_add(current, obj);\n      saved_state = json_tokener_state_array_sep;\n      state = json_tokener_state_eatws;\n      goto redo_char;\n\n    case json_tokener_state_array_sep:\n      if(c == ']') {\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if(c == ',') {\n\tsaved_state = json_tokener_state_array_after_sep;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_array;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_field_start:\n    case json_tokener_state_object_field_start_after_sep:\n      if(c == '}') {\n\t\tif (state == json_tokener_state_object_field_start_after_sep &&\n\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t{\n\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\tgoto out;\n\t\t}\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if (c == '\"' || c == '\\'') {\n\ttok->quote_char = c;\n\tprintbuf_reset(tok->pb);\n\tstate = json_tokener_state_object_field;\n      } else {\n\ttok->err = json_tokener_error_parse_object_key_name;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_field:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(1) {\n\t  if(c == tok->quote_char) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    obj_field_name = strdup(tok->pb->buf);\n\t    saved_state = json_tokener_state_object_field_end;\n\t    state = json_tokener_state_eatws;\n\t    break;\n\t  } else if(c == '\\\\') {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    saved_state = json_tokener_state_object_field;\n\t    state = json_tokener_state_string_escape;\n\t    break;\n\t  }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_object_field_end:\n      if(c == ':') {\n\tsaved_state = json_tokener_state_object_value;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_object_key_sep;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_value:\n      if(tok->depth >= tok->max_depth-1) {\n\ttok->err = json_tokener_error_depth;\n\tgoto out;\n      }\n      state = json_tokener_state_object_value_add;\n      tok->depth++;\n      json_tokener_reset_level(tok, tok->depth);\n      goto redo_char;\n\n    case json_tokener_state_object_value_add:\n      json_object_object_add(current, obj_field_name, obj);\n      free(obj_field_name);\n      obj_field_name = NULL;\n      saved_state = json_tokener_state_object_sep;\n      state = json_tokener_state_eatws;\n      goto redo_char;\n\n    case json_tokener_state_object_sep:\n      if(c == '}') {\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if(c == ',') {\n\tsaved_state = json_tokener_state_object_field_start_after_sep;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_object_value_sep;\n\tgoto out;\n      }\n      break;\n\n    }\n    if (!ADVANCE_CHAR(str, tok))\n      goto out;\n  } /* while(POP_CHAR) */\n\n out:\n  if (c &&\n     (state == json_tokener_state_finish) &&\n     (tok->depth == 0) &&\n     (tok->flags & JSON_TOKENER_STRICT)) {\n      /* unexpected char after JSON data */\n      tok->err = json_tokener_error_parse_unexpected;\n  }\n  if (!c) { /* We hit an eof char (0) */\n    if(state != json_tokener_state_finish &&\n       saved_state != json_tokener_state_finish)\n      tok->err = json_tokener_error_parse_eof;\n  }\n\n#ifdef HAVE_SETLOCALE\n  setlocale(LC_NUMERIC, oldlocale);\n  if (oldlocale) free(oldlocale);\n#endif\n\n  if (tok->err == json_tokener_success)\n  {\n    json_object *ret = json_object_get(current);\n\tint ii;\n\n\t/* Partially reset, so we parse additional objects on subsequent calls. */\n    for(ii = tok->depth; ii >= 0; ii--)\n      json_tokener_reset_level(tok, ii);\n    return ret;\n  }\n\n  MC_DEBUG(\"json_tokener_parse_ex: error %s at offset %d\\n\",\n\t   json_tokener_errors[tok->err], tok->char_offset);\n  return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,16 @@\n \n   tok->char_offset = 0;\n   tok->err = json_tokener_success;\n+\n+  /* this interface is presently not 64-bit clean due to the int len argument\n+     and the internal printbuf interface that takes 32-bit int len arguments\n+     so the function limits the maximum string size to INT32_MAX (2GB).\n+     If the function is called with len == -1 then strlen is called to check\n+     the string length is less than INT32_MAX (2GB) */\n+  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {\n+    tok->err = json_tokener_error_size;\n+    return NULL;\n+  }\n \n   while (PEEK_CHAR(c, tok)) {\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  /* this interface is presently not 64-bit clean due to the int len argument",
                "     and the internal printbuf interface that takes 32-bit int len arguments",
                "     so the function limits the maximum string size to INT32_MAX (2GB).",
                "     If the function is called with len == -1 then strlen is called to check",
                "     the string length is less than INT32_MAX (2GB) */",
                "  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {",
                "    tok->err = json_tokener_error_size;",
                "    return NULL;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7449",
        "func_name": "hexchat/ssl_do_connect",
        "description": "The ssl_do_connect function in common/server.c in HexChat before 2.10.2, XChat, and XChat-GNOME does not verify that the server hostname matches a domain name in the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",
        "git_url": "https://github.com/hexchat/hexchat/commit/c9b63f7f9be01692b03fa15275135a4910a7e02d",
        "commit_title": "ssl: Validate hostnames",
        "commit_text": " Closes #524",
        "func_before": "static int\nssl_do_connect (server * serv)\n{\n\tchar buf[128];\n\n\tg_sess = serv->server_session;\n\tif (SSL_connect (serv->ssl) <= 0)\n\t{\n\t\tchar err_buf[128];\n\t\tint err;\n\n\t\tg_sess = NULL;\n\t\tif ((err = ERR_get_error ()) > 0)\n\t\t{\n\t\t\tERR_error_string (err, err_buf);\n\t\t\tsnprintf (buf, sizeof (buf), \"(%d) %s\", err, err_buf);\n\t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,\n\t\t\t\t\t\t\t NULL, NULL, 0);\n\n\t\t\tif (ERR_GET_REASON (err) == SSL_R_WRONG_VERSION_NUMBER)\n\t\t\t\tPrintText (serv->server_session, _(\"Are you sure this is a SSL capable server and port?\\n\"));\n\n\t\t\tserver_cleanup (serv);\n\n\t\t\tif (prefs.hex_net_auto_reconnectonfail)\n\t\t\t\tauto_reconnect (serv, FALSE, -1);\n\n\t\t\treturn (0);\t\t\t\t  /* remove it (0) */\n\t\t}\n\t}\n\tg_sess = NULL;\n\n\tif (SSL_is_init_finished (serv->ssl))\n\t{\n\t\tstruct cert_info cert_info;\n\t\tstruct chiper_info *chiper_info;\n\t\tint verify_error;\n\t\tint i;\n\n\t\tif (!_SSL_get_cert_info (&cert_info, serv->ssl))\n\t\t{\n\t\t\tsnprintf (buf, sizeof (buf), \"* Certification info:\");\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\tsnprintf (buf, sizeof (buf), \"  Subject:\");\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\tfor (i = 0; cert_info.subject_word[i]; i++)\n\t\t\t{\n\t\t\t\tsnprintf (buf, sizeof (buf), \"    %s\", cert_info.subject_word[i]);\n\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t\t NULL, 0);\n\t\t\t}\n\t\t\tsnprintf (buf, sizeof (buf), \"  Issuer:\");\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\tfor (i = 0; cert_info.issuer_word[i]; i++)\n\t\t\t{\n\t\t\t\tsnprintf (buf, sizeof (buf), \"    %s\", cert_info.issuer_word[i]);\n\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t\t NULL, 0);\n\t\t\t}\n\t\t\tsnprintf (buf, sizeof (buf), \"  Public key algorithm: %s (%d bits)\",\n\t\t\t\t\t\t cert_info.algorithm, cert_info.algorithm_bits);\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\t/*if (cert_info.rsa_tmp_bits)\n\t\t\t{\n\t\t\t\tsnprintf (buf, sizeof (buf),\n\t\t\t\t\t\t\t \"  Public key algorithm uses ephemeral key with %d bits\",\n\t\t\t\t\t\t\t cert_info.rsa_tmp_bits);\n\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t\t NULL, 0);\n\t\t\t}*/\n\t\t\tsnprintf (buf, sizeof (buf), \"  Sign algorithm %s\",\n\t\t\t\t\t\t cert_info.sign_algorithm/*, cert_info.sign_algorithm_bits*/);\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\tsnprintf (buf, sizeof (buf), \"  Valid since %s to %s\",\n\t\t\t\t\t\t cert_info.notbefore, cert_info.notafter);\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t} else\n\t\t{\n\t\t\tsnprintf (buf, sizeof (buf), \" * No Certificate\");\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t}\n\n\t\tchiper_info = _SSL_get_cipher_info (serv->ssl);\t/* static buffer */\n\t\tsnprintf (buf, sizeof (buf), \"* Cipher info:\");\n\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,\n\t\t\t\t\t\t 0);\n\t\tsnprintf (buf, sizeof (buf), \"  Version: %s, cipher %s (%u bits)\",\n\t\t\t\t\t chiper_info->version, chiper_info->chiper,\n\t\t\t\t\t chiper_info->chiper_bits);\n\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,\n\t\t\t\t\t\t 0);\n\n\t\tverify_error = SSL_get_verify_result (serv->ssl);\n\t\tswitch (verify_error)\n\t\t{\n\t\tcase X509_V_OK:\n\t\t\t/* snprintf (buf, sizeof (buf), \"* Verify OK (?)\"); */\n\t\t\t/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */\n\t\t\tbreak;\n\t\tcase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n\t\tcase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\n\t\tcase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n\t\tcase X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\n\t\tcase X509_V_ERR_CERT_HAS_EXPIRED:\n\t\t\tif (serv->accept_invalid_cert)\n\t\t\t{\n\t\t\t\tsnprintf (buf, sizeof (buf), \"* Verify E: %s.? (%d) -- Ignored\",\n\t\t\t\t\t\t\t X509_verify_cert_error_string (verify_error),\n\t\t\t\t\t\t\t verify_error);\n\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t\t NULL, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tsnprintf (buf, sizeof (buf), \"%s.? (%d)\",\n\t\t\t\t\t\t X509_verify_cert_error_string (verify_error),\n\t\t\t\t\t\t verify_error);\n\t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\n\t\t\tserver_cleanup (serv);\n\n\t\t\treturn (0);\n\t\t}\n\n\t\tserver_stopconnecting (serv);\n\n\t\t/* activate gtk poll */\n\t\tserver_connected (serv);\n\n\t\treturn (0);\t\t\t\t\t  /* remove it (0) */\n\t} else\n\t{\n\t\tif (serv->ssl->session && serv->ssl->session->time + SSLTMOUT < time (NULL))\n\t\t{\n\t\t\tsnprintf (buf, sizeof (buf), \"SSL handshake timed out\");\n\t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,\n\t\t\t\t\t\t\t NULL, NULL, 0);\n\t\t\tserver_cleanup (serv); /* ->connecting = FALSE */\n\n\t\t\tif (prefs.hex_net_auto_reconnectonfail)\n\t\t\t\tauto_reconnect (serv, FALSE, -1);\n\n\t\t\treturn (0);\t\t\t\t  /* remove it (0) */\n\t\t}\n\n\t\treturn (1);\t\t\t\t\t  /* call it more (1) */\n\t}\n}",
        "func": "static int\nssl_do_connect (server * serv)\n{\n\tchar buf[128];\n\n\tg_sess = serv->server_session;\n\tif (SSL_connect (serv->ssl) <= 0)\n\t{\n\t\tchar err_buf[128];\n\t\tint err;\n\n\t\tg_sess = NULL;\n\t\tif ((err = ERR_get_error ()) > 0)\n\t\t{\n\t\t\tERR_error_string (err, err_buf);\n\t\t\tsnprintf (buf, sizeof (buf), \"(%d) %s\", err, err_buf);\n\t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,\n\t\t\t\t\t\t\t NULL, NULL, 0);\n\n\t\t\tif (ERR_GET_REASON (err) == SSL_R_WRONG_VERSION_NUMBER)\n\t\t\t\tPrintText (serv->server_session, _(\"Are you sure this is a SSL capable server and port?\\n\"));\n\n\t\t\tserver_cleanup (serv);\n\n\t\t\tif (prefs.hex_net_auto_reconnectonfail)\n\t\t\t\tauto_reconnect (serv, FALSE, -1);\n\n\t\t\treturn (0);\t\t\t\t  /* remove it (0) */\n\t\t}\n\t}\n\tg_sess = NULL;\n\n\tif (SSL_is_init_finished (serv->ssl))\n\t{\n\t\tstruct cert_info cert_info;\n\t\tstruct chiper_info *chiper_info;\n\t\tint verify_error;\n\t\tint i;\n\n\t\tif (!_SSL_get_cert_info (&cert_info, serv->ssl))\n\t\t{\n\t\t\tsnprintf (buf, sizeof (buf), \"* Certification info:\");\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\tsnprintf (buf, sizeof (buf), \"  Subject:\");\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\tfor (i = 0; cert_info.subject_word[i]; i++)\n\t\t\t{\n\t\t\t\tsnprintf (buf, sizeof (buf), \"    %s\", cert_info.subject_word[i]);\n\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t\t NULL, 0);\n\t\t\t}\n\t\t\tsnprintf (buf, sizeof (buf), \"  Issuer:\");\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\tfor (i = 0; cert_info.issuer_word[i]; i++)\n\t\t\t{\n\t\t\t\tsnprintf (buf, sizeof (buf), \"    %s\", cert_info.issuer_word[i]);\n\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t\t NULL, 0);\n\t\t\t}\n\t\t\tsnprintf (buf, sizeof (buf), \"  Public key algorithm: %s (%d bits)\",\n\t\t\t\t\t\t cert_info.algorithm, cert_info.algorithm_bits);\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\t/*if (cert_info.rsa_tmp_bits)\n\t\t\t{\n\t\t\t\tsnprintf (buf, sizeof (buf),\n\t\t\t\t\t\t\t \"  Public key algorithm uses ephemeral key with %d bits\",\n\t\t\t\t\t\t\t cert_info.rsa_tmp_bits);\n\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t\t NULL, 0);\n\t\t\t}*/\n\t\t\tsnprintf (buf, sizeof (buf), \"  Sign algorithm %s\",\n\t\t\t\t\t\t cert_info.sign_algorithm/*, cert_info.sign_algorithm_bits*/);\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t\tsnprintf (buf, sizeof (buf), \"  Valid since %s to %s\",\n\t\t\t\t\t\t cert_info.notbefore, cert_info.notafter);\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t} else\n\t\t{\n\t\t\tsnprintf (buf, sizeof (buf), \" * No Certificate\");\n\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\t\t}\n\n\t\tchiper_info = _SSL_get_cipher_info (serv->ssl);\t/* static buffer */\n\t\tsnprintf (buf, sizeof (buf), \"* Cipher info:\");\n\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,\n\t\t\t\t\t\t 0);\n\t\tsnprintf (buf, sizeof (buf), \"  Version: %s, cipher %s (%u bits)\",\n\t\t\t\t\t chiper_info->version, chiper_info->chiper,\n\t\t\t\t\t chiper_info->chiper_bits);\n\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,\n\t\t\t\t\t\t 0);\n\n\t\tverify_error = SSL_get_verify_result (serv->ssl);\n\t\tswitch (verify_error)\n\t\t{\n\t\tcase X509_V_OK:\n\t\t\t{\n\t\t\t\tX509 *cert = SSL_get_peer_certificate (serv->ssl);\n\t\t\t\tint hostname_err;\n\t\t\t\tif ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf (buf, sizeof (buf), \"* Verify E: Failed to validate hostname? (%d)%s\",\n\t\t\t\t\t\t\t hostname_err, serv->accept_invalid_cert ? \" -- Ignored\" : \"\");\n\t\t\t\t\tif (serv->accept_invalid_cert)\n\t\t\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto conn_fail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* snprintf (buf, sizeof (buf), \"* Verify OK (?)\"); */\n\t\t\t/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */\n\t\tcase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n\t\tcase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\n\t\tcase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n\t\tcase X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\n\t\tcase X509_V_ERR_CERT_HAS_EXPIRED:\n\t\t\tif (serv->accept_invalid_cert)\n\t\t\t{\n\t\t\t\tsnprintf (buf, sizeof (buf), \"* Verify E: %s.? (%d) -- Ignored\",\n\t\t\t\t\t\t\t X509_verify_cert_error_string (verify_error),\n\t\t\t\t\t\t\t verify_error);\n\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t\t NULL, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tsnprintf (buf, sizeof (buf), \"%s.? (%d)\",\n\t\t\t\t\t\t X509_verify_cert_error_string (verify_error),\n\t\t\t\t\t\t verify_error);\nconn_fail:\n\t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,\n\t\t\t\t\t\t\t NULL, 0);\n\n\t\t\tserver_cleanup (serv);\n\n\t\t\treturn (0);\n\t\t}\n\n\t\tserver_stopconnecting (serv);\n\n\t\t/* activate gtk poll */\n\t\tserver_connected (serv);\n\n\t\treturn (0);\t\t\t\t\t  /* remove it (0) */\n\t} else\n\t{\n\t\tif (serv->ssl->session && serv->ssl->session->time + SSLTMOUT < time (NULL))\n\t\t{\n\t\t\tsnprintf (buf, sizeof (buf), \"SSL handshake timed out\");\n\t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,\n\t\t\t\t\t\t\t NULL, NULL, 0);\n\t\t\tserver_cleanup (serv); /* ->connecting = FALSE */\n\n\t\t\tif (prefs.hex_net_auto_reconnectonfail)\n\t\t\t\tauto_reconnect (serv, FALSE, -1);\n\n\t\t\treturn (0);\t\t\t\t  /* remove it (0) */\n\t\t}\n\n\t\treturn (1);\t\t\t\t\t  /* call it more (1) */\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -101,9 +101,22 @@\n \t\tswitch (verify_error)\n \t\t{\n \t\tcase X509_V_OK:\n+\t\t\t{\n+\t\t\t\tX509 *cert = SSL_get_peer_certificate (serv->ssl);\n+\t\t\t\tint hostname_err;\n+\t\t\t\tif ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)\n+\t\t\t\t{\n+\t\t\t\t\tsnprintf (buf, sizeof (buf), \"* Verify E: Failed to validate hostname? (%d)%s\",\n+\t\t\t\t\t\t\t hostname_err, serv->accept_invalid_cert ? \" -- Ignored\" : \"\");\n+\t\t\t\t\tif (serv->accept_invalid_cert)\n+\t\t\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tgoto conn_fail;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\t/* snprintf (buf, sizeof (buf), \"* Verify OK (?)\"); */\n \t\t\t/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */\n-\t\t\tbreak;\n \t\tcase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n \t\tcase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\n \t\tcase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n@@ -122,6 +135,7 @@\n \t\t\tsnprintf (buf, sizeof (buf), \"%s.? (%d)\",\n \t\t\t\t\t\t X509_verify_cert_error_string (verify_error),\n \t\t\t\t\t\t verify_error);\n+conn_fail:\n \t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,\n \t\t\t\t\t\t\t NULL, 0);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tbreak;"
            ],
            "added_lines": [
                "\t\t\t{",
                "\t\t\t\tX509 *cert = SSL_get_peer_certificate (serv->ssl);",
                "\t\t\t\tint hostname_err;",
                "\t\t\t\tif ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)",
                "\t\t\t\t{",
                "\t\t\t\t\tsnprintf (buf, sizeof (buf), \"* Verify E: Failed to validate hostname? (%d)%s\",",
                "\t\t\t\t\t\t\t hostname_err, serv->accept_invalid_cert ? \" -- Ignored\" : \"\");",
                "\t\t\t\t\tif (serv->accept_invalid_cert)",
                "\t\t\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);",
                "\t\t\t\t\telse",
                "\t\t\t\t\t\tgoto conn_fail;",
                "\t\t\t\t}",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "conn_fail:"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2053",
        "func_name": "torvalds/linux/asn1_ber_decoder",
        "description": "The asn1_ber_decoder function in lib/asn1_decoder.c in the Linux kernel before 4.3 allows attackers to cause a denial of service (panic) via an ASN.1 BER file that lacks a public key, leading to mishandling by the public_key_verify_signature function in crypto/asymmetric_keys/public_key.c.",
        "git_url": "https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f",
        "commit_title": "ASN.1: Fix non-match detection failure on data overrun",
        "commit_text": " If the ASN.1 decoder is asked to parse a sequence of objects, non-optional matches get skipped if there's no more data to be had rather than a data-overrun error being reported.  This is due to the code segment that decides whether to skip optional matches (ie. matches that could get ignored because an element is marked OPTIONAL in the grammar) due to a lack of data also skips non-optional elements if the data pointer has reached the end of the buffer.  This can be tested with the data decoder for the new RSA akcipher algorithm that takes three non-optional integers.  Currently, it skips the last integer if there is insufficient data.  Without the fix, #defining DEBUG in asn1_decoder.c will show something like:  \tnext_op: pc=0/13 dp=0/270 C=0 J=0 \t- match? 30 30 00 \t- TAG: 30 266 CONS \tnext_op: pc=2/13 dp=4/270 C=1 J=0 \t- match? 02 02 00 \t- TAG: 02 257 \t- LEAF: 257 \tnext_op: pc=5/13 dp=265/270 C=1 J=0 \t- match? 02 02 00 \t- TAG: 02 3 \t- LEAF: 3 \tnext_op: pc=8/13 dp=270/270 C=1 J=0 \tnext_op: pc=11/13 dp=270/270 C=1 J=0 \t- end cons t=4 dp=270 l=270/270  The next_op line for pc=8/13 should be followed by a match line.  This is not exploitable for X.509 certificates by means of shortening the message and fixing up the ASN.1 CONS tags because:   (1) The relevant records being built up are cleared before use.   (2) If the message is shortened sufficiently to remove the public key, the      ASN.1 parse of the RSA key will fail quickly due to a lack of data.   (3) Extracted signature data is either turned into MPIs (which cope with a      0 length) or is simpler integers specifying algoritms and suchlike      (which can validly be 0); and   (4) The AKID and SKID extensions are optional and their removal is handled      without risking passing a NULL to asymmetric_key_generate_id().   (5) If the certificate is truncated sufficiently to remove the subject,      issuer or serialNumber then the ASN.1 decoder will fail with a 'Cons      stack underflow' return.  This is not exploitable for PKCS#7 messages by means of removal of elements from such a message from the tail end of a sequence:   (1) Any shortened X.509 certs embedded in the PKCS#7 message are survivable      as detailed above.   (2) The message digest content isn't used if it shows a NULL pointer,      similarly, the authattrs aren't used if that shows a NULL pointer.   (3) A missing signature results in a NULL MPI - which the MPI routines deal      with.   (4) If data is NULL, it is expected that the message has detached content and      that is handled appropriately.   (5) If the serialNumber is excised, the unconditional action associated      with it will pick up the containing SEQUENCE instead, so no NULL      pointer will be seen here.       If both the issuer and the serialNumber are excised, the ASN.1 decode      will fail with an 'Unexpected tag' return.       In either case, there's no way to get to asymmetric_key_generate_id()      with a NULL pointer.   (6) Other fields are decoded to simple integers.  Shortening the message      to omit an algorithm ID field will cause checks on this to fail early      in the verification process.   This can also be tested by snipping objects off of the end of the ASN.1 stream such that mandatory tags are removed - or even from the end of internal SEQUENCEs.  If any mandatory tag is missing, the error EBADMSG *should* be produced.  Without this patch ERANGE or ENOPKG might be produced or the parse may apparently succeed, perhaps with ENOKEY or EKEYREJECTED being produced later, depending on what gets snipped.  Just snipping off the final BIT_STRING or OCTET_STRING from either sample should be a start since both are mandatory and neither will cause an EBADMSG without the patches ",
        "func_before": "int asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04 /* Last tag matched */\n#define FLAG_CONS\t\t0x20 /* Corresponds to CONS bit in the opcode tag\n\t\t\t\t      * - ie. whether or not we are going to parse\n\t\t\t\t      *   a compound type.\n\t\t\t\t      */\n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t/* If this command is meant to match a tag, then do that before\n\t * evaluating the command.\n\t */\n\tif (op <= ASN1_OP__MATCHES_TAG) {\n\t\tunsigned char tmp;\n\n\t\t/* Skip conditional matches if possible */\n\t\tif ((op & ASN1_OP_MATCH__COND &&\n\t\t     flags & FLAG_MATCHED) ||\n\t\t    dp == datalen) {\n\t\t\tflags &= ~FLAG_LAST_MATCHED;\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t/* Extract a tag from the data */\n\t\tif (unlikely(dp >= datalen - 1))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t/* Extract the tag from the machine\n\t\t\t * - Either CONS or PRIM are permitted in the data if\n\t\t\t *   CONS is not set in the op stream, otherwise CONS\n\t\t\t *   is mandatory.\n\t\t\t */\n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t/* Determine whether the tag matched */\n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t/* All odd-numbered tags are MATCH_OR_SKIP. */\n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t/* Indefinite length */\n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(dp >= datalen - n))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t/* For expected compound forms, we stack the positions\n\t\t\t * of the start and end of the data.\n\t\t\t */\n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t/* Decide how to handle the operation */\n\tswitch (op) {\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\t\tret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tskip_data:\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &dp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t/* Indefinite length - check for the EOC. */\n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Shouldn't reach here */\n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}",
        "func": "int asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04 /* Last tag matched */\n#define FLAG_CONS\t\t0x20 /* Corresponds to CONS bit in the opcode tag\n\t\t\t\t      * - ie. whether or not we are going to parse\n\t\t\t\t      *   a compound type.\n\t\t\t\t      */\n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t/* If this command is meant to match a tag, then do that before\n\t * evaluating the command.\n\t */\n\tif (op <= ASN1_OP__MATCHES_TAG) {\n\t\tunsigned char tmp;\n\n\t\t/* Skip conditional matches if possible */\n\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||\n\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {\n\t\t\tflags &= ~FLAG_LAST_MATCHED;\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t/* Extract a tag from the data */\n\t\tif (unlikely(dp >= datalen - 1))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t/* Extract the tag from the machine\n\t\t\t * - Either CONS or PRIM are permitted in the data if\n\t\t\t *   CONS is not set in the op stream, otherwise CONS\n\t\t\t *   is mandatory.\n\t\t\t */\n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t/* Determine whether the tag matched */\n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t/* All odd-numbered tags are MATCH_OR_SKIP. */\n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t/* Indefinite length */\n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(dp >= datalen - n))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t/* For expected compound forms, we stack the positions\n\t\t\t * of the start and end of the data.\n\t\t\t */\n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t/* Decide how to handle the operation */\n\tswitch (op) {\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\t\tret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tskip_data:\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &dp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t/* Indefinite length - check for the EOC. */\n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Shouldn't reach here */\n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,9 +47,8 @@\n \t\tunsigned char tmp;\n \n \t\t/* Skip conditional matches if possible */\n-\t\tif ((op & ASN1_OP_MATCH__COND &&\n-\t\t     flags & FLAG_MATCHED) ||\n-\t\t    dp == datalen) {\n+\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||\n+\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {\n \t\t\tflags &= ~FLAG_LAST_MATCHED;\n \t\t\tpc += asn1_op_lengths[op];\n \t\t\tgoto next_op;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif ((op & ASN1_OP_MATCH__COND &&",
                "\t\t     flags & FLAG_MATCHED) ||",
                "\t\t    dp == datalen) {"
            ],
            "added_lines": [
                "\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||",
                "\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2000-1254",
        "func_name": "openssl/RSA_generate_key",
        "description": "crypto/rsa/rsa_gen.c in OpenSSL before 0.9.6 mishandles C bitwise-shift operations that exceed the size of an expression, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging improper RSA key generation on 64-bit HP-UX platforms.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=db82b8f9bd432a59aea8e1014694e15fc457c2bb",
        "commit_title": "",
        "commit_text": "Bug fix for 64 bit HP-UX.  Submitted by: Karsten Spang <ks@bellesystems.com> ",
        "func_before": "RSA *RSA_generate_key(int bits, unsigned long e_value,\n\t     void (*callback)(int,int,void *), void *cb_arg)\n\t{\n\tRSA *rsa=NULL;\n\tBIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;\n\tint bitsp,bitsq,ok= -1,n=0,i;\n\tBN_CTX *ctx=NULL,*ctx2=NULL;\n\n\tctx=BN_CTX_new();\n\tif (ctx == NULL) goto err;\n\tctx2=BN_CTX_new();\n\tif (ctx2 == NULL) goto err;\n\tBN_CTX_start(ctx);\n\tr0 = BN_CTX_get(ctx);\n\tr1 = BN_CTX_get(ctx);\n\tr2 = BN_CTX_get(ctx);\n\tr3 = BN_CTX_get(ctx);\n\tif (r3 == NULL) goto err;\n\n\tbitsp=(bits+1)/2;\n\tbitsq=bits-bitsp;\n\trsa=RSA_new();\n\tif (rsa == NULL) goto err;\n\n\t/* set e */ \n\trsa->e=BN_new();\n\tif (rsa->e == NULL) goto err;\n\n#if 1\n\t/* The problem is when building with 8, 16, or 32 BN_ULONG,\n\t * unsigned long can be larger */\n\tfor (i=0; i<sizeof(unsigned long)*8; i++)\n\t\t{\n\t\tif (e_value & (1<<i))\n\t\t\tBN_set_bit(rsa->e,i);\n\t\t}\n#else\n\tif (!BN_set_word(rsa->e,e_value)) goto err;\n#endif\n\n\t/* generate p and q */\n\tfor (;;)\n\t\t{\n\t\trsa->p=BN_generate_prime(NULL,bitsp,0,NULL,NULL,callback,cb_arg);\n\t\tif (rsa->p == NULL) goto err;\n\t\tif (!BN_sub(r2,rsa->p,BN_value_one())) goto err;\n\t\tif (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;\n\t\tif (BN_is_one(r1)) break;\n\t\tif (callback != NULL) callback(2,n++,cb_arg);\n\t\tBN_free(rsa->p);\n\t\t}\n\tif (callback != NULL) callback(3,0,cb_arg);\n\tfor (;;)\n\t\t{\n\t\trsa->q=BN_generate_prime(NULL,bitsq,0,NULL,NULL,callback,cb_arg);\n\t\tif (rsa->q == NULL) goto err;\n\t\tif (!BN_sub(r2,rsa->q,BN_value_one())) goto err;\n\t\tif (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;\n\t\tif (BN_is_one(r1) && (BN_cmp(rsa->p,rsa->q) != 0))\n\t\t\tbreak;\n\t\tif (callback != NULL) callback(2,n++,cb_arg);\n\t\tBN_free(rsa->q);\n\t\t}\n\tif (callback != NULL) callback(3,1,cb_arg);\n\tif (BN_cmp(rsa->p,rsa->q) < 0)\n\t\t{\n\t\ttmp=rsa->p;\n\t\trsa->p=rsa->q;\n\t\trsa->q=tmp;\n\t\t}\n\n\t/* calculate n */\n\trsa->n=BN_new();\n\tif (rsa->n == NULL) goto err;\n\tif (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;\n\n\t/* calculate d */\n\tif (!BN_sub(r1,rsa->p,BN_value_one())) goto err;\t/* p-1 */\n\tif (!BN_sub(r2,rsa->q,BN_value_one())) goto err;\t/* q-1 */\n\tif (!BN_mul(r0,r1,r2,ctx)) goto err;\t/* (p-1)(q-1) */\n\n/* should not be needed, since gcd(p-1,e) == 1 and gcd(q-1,e) == 1 */\n/*\tfor (;;)\n\t\t{\n\t\tif (!BN_gcd(r3,r0,rsa->e,ctx)) goto err;\n\t\tif (BN_is_one(r3)) break;\n\n\t\tif (1)\n\t\t\t{\n\t\t\tif (!BN_add_word(rsa->e,2L)) goto err;\n\t\t\tcontinue;\n\t\t\t}\n\t\tRSAerr(RSA_F_RSA_GENERATE_KEY,RSA_R_BAD_E_VALUE);\n\t\tgoto err;\n\t\t}\n*/\n\trsa->d=BN_mod_inverse(NULL,rsa->e,r0,ctx2);\t/* d */\n\tif (rsa->d == NULL) goto err;\n\n\t/* calculate d mod (p-1) */\n\trsa->dmp1=BN_new();\n\tif (rsa->dmp1 == NULL) goto err;\n\tif (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;\n\n\t/* calculate d mod (q-1) */\n\trsa->dmq1=BN_new();\n\tif (rsa->dmq1 == NULL) goto err;\n\tif (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;\n\n\t/* calculate inverse of q mod p */\n\trsa->iqmp=BN_mod_inverse(NULL,rsa->q,rsa->p,ctx2);\n\tif (rsa->iqmp == NULL) goto err;\n\n\tok=1;\nerr:\n\tif (ok == -1)\n\t\t{\n\t\tRSAerr(RSA_F_RSA_GENERATE_KEY,ERR_LIB_BN);\n\t\tok=0;\n\t\t}\n\tBN_CTX_end(ctx);\n\tBN_CTX_free(ctx);\n\tBN_CTX_free(ctx2);\n\t\n\tif (!ok)\n\t\t{\n\t\tif (rsa != NULL) RSA_free(rsa);\n\t\treturn(NULL);\n\t\t}\n\telse\n\t\treturn(rsa);\n\t}",
        "func": "RSA *RSA_generate_key(int bits, unsigned long e_value,\n\t     void (*callback)(int,int,void *), void *cb_arg)\n\t{\n\tRSA *rsa=NULL;\n\tBIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;\n\tint bitsp,bitsq,ok= -1,n=0,i;\n\tBN_CTX *ctx=NULL,*ctx2=NULL;\n\n\tctx=BN_CTX_new();\n\tif (ctx == NULL) goto err;\n\tctx2=BN_CTX_new();\n\tif (ctx2 == NULL) goto err;\n\tBN_CTX_start(ctx);\n\tr0 = BN_CTX_get(ctx);\n\tr1 = BN_CTX_get(ctx);\n\tr2 = BN_CTX_get(ctx);\n\tr3 = BN_CTX_get(ctx);\n\tif (r3 == NULL) goto err;\n\n\tbitsp=(bits+1)/2;\n\tbitsq=bits-bitsp;\n\trsa=RSA_new();\n\tif (rsa == NULL) goto err;\n\n\t/* set e */ \n\trsa->e=BN_new();\n\tif (rsa->e == NULL) goto err;\n\n#if 1\n\t/* The problem is when building with 8, 16, or 32 BN_ULONG,\n\t * unsigned long can be larger */\n\tfor (i=0; i<sizeof(unsigned long)*8; i++)\n\t\t{\n\t\tif (e_value & (1UL<<i))\n\t\t\tBN_set_bit(rsa->e,i);\n\t\t}\n#else\n\tif (!BN_set_word(rsa->e,e_value)) goto err;\n#endif\n\n\t/* generate p and q */\n\tfor (;;)\n\t\t{\n\t\trsa->p=BN_generate_prime(NULL,bitsp,0,NULL,NULL,callback,cb_arg);\n\t\tif (rsa->p == NULL) goto err;\n\t\tif (!BN_sub(r2,rsa->p,BN_value_one())) goto err;\n\t\tif (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;\n\t\tif (BN_is_one(r1)) break;\n\t\tif (callback != NULL) callback(2,n++,cb_arg);\n\t\tBN_free(rsa->p);\n\t\t}\n\tif (callback != NULL) callback(3,0,cb_arg);\n\tfor (;;)\n\t\t{\n\t\trsa->q=BN_generate_prime(NULL,bitsq,0,NULL,NULL,callback,cb_arg);\n\t\tif (rsa->q == NULL) goto err;\n\t\tif (!BN_sub(r2,rsa->q,BN_value_one())) goto err;\n\t\tif (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;\n\t\tif (BN_is_one(r1) && (BN_cmp(rsa->p,rsa->q) != 0))\n\t\t\tbreak;\n\t\tif (callback != NULL) callback(2,n++,cb_arg);\n\t\tBN_free(rsa->q);\n\t\t}\n\tif (callback != NULL) callback(3,1,cb_arg);\n\tif (BN_cmp(rsa->p,rsa->q) < 0)\n\t\t{\n\t\ttmp=rsa->p;\n\t\trsa->p=rsa->q;\n\t\trsa->q=tmp;\n\t\t}\n\n\t/* calculate n */\n\trsa->n=BN_new();\n\tif (rsa->n == NULL) goto err;\n\tif (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;\n\n\t/* calculate d */\n\tif (!BN_sub(r1,rsa->p,BN_value_one())) goto err;\t/* p-1 */\n\tif (!BN_sub(r2,rsa->q,BN_value_one())) goto err;\t/* q-1 */\n\tif (!BN_mul(r0,r1,r2,ctx)) goto err;\t/* (p-1)(q-1) */\n\n/* should not be needed, since gcd(p-1,e) == 1 and gcd(q-1,e) == 1 */\n/*\tfor (;;)\n\t\t{\n\t\tif (!BN_gcd(r3,r0,rsa->e,ctx)) goto err;\n\t\tif (BN_is_one(r3)) break;\n\n\t\tif (1)\n\t\t\t{\n\t\t\tif (!BN_add_word(rsa->e,2L)) goto err;\n\t\t\tcontinue;\n\t\t\t}\n\t\tRSAerr(RSA_F_RSA_GENERATE_KEY,RSA_R_BAD_E_VALUE);\n\t\tgoto err;\n\t\t}\n*/\n\trsa->d=BN_mod_inverse(NULL,rsa->e,r0,ctx2);\t/* d */\n\tif (rsa->d == NULL) goto err;\n\n\t/* calculate d mod (p-1) */\n\trsa->dmp1=BN_new();\n\tif (rsa->dmp1 == NULL) goto err;\n\tif (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;\n\n\t/* calculate d mod (q-1) */\n\trsa->dmq1=BN_new();\n\tif (rsa->dmq1 == NULL) goto err;\n\tif (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;\n\n\t/* calculate inverse of q mod p */\n\trsa->iqmp=BN_mod_inverse(NULL,rsa->q,rsa->p,ctx2);\n\tif (rsa->iqmp == NULL) goto err;\n\n\tok=1;\nerr:\n\tif (ok == -1)\n\t\t{\n\t\tRSAerr(RSA_F_RSA_GENERATE_KEY,ERR_LIB_BN);\n\t\tok=0;\n\t\t}\n\tBN_CTX_end(ctx);\n\tBN_CTX_free(ctx);\n\tBN_CTX_free(ctx2);\n\t\n\tif (!ok)\n\t\t{\n\t\tif (rsa != NULL) RSA_free(rsa);\n\t\treturn(NULL);\n\t\t}\n\telse\n\t\treturn(rsa);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \t * unsigned long can be larger */\n \tfor (i=0; i<sizeof(unsigned long)*8; i++)\n \t\t{\n-\t\tif (e_value & (1<<i))\n+\t\tif (e_value & (1UL<<i))\n \t\t\tBN_set_bit(rsa->e,i);\n \t\t}\n #else",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (e_value & (1<<i))"
            ],
            "added_lines": [
                "\t\tif (e_value & (1UL<<i))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2107",
        "func_name": "openssl/aesni_cbc_hmac_sha256_cipher",
        "description": "The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=68595c0c2886e7942a14f98c17a55a88afb6c292",
        "commit_title": "",
        "commit_text": "Check that we have enough padding characters.  CVE-2016-2107  MR: #2572 ",
        "func_before": "static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,\n                                        unsigned char *out,\n                                        const unsigned char *in, size_t len)\n{\n    EVP_AES_HMAC_SHA256 *key = data(ctx);\n    unsigned int l;\n    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and\n                                                * later */\n        sha_off = 0;\n#  if defined(STITCHED_CALL)\n    size_t aes_off = 0, blocks;\n\n    sha_off = SHA256_CBLOCK - key->md.num;\n#  endif\n\n    key->payload_length = NO_PAYLOAD_LENGTH;\n\n    if (len % AES_BLOCK_SIZE)\n        return 0;\n\n    if (ctx->encrypt) {\n        if (plen == NO_PAYLOAD_LENGTH)\n            plen = len;\n        else if (len !=\n                 ((plen + SHA256_DIGEST_LENGTH +\n                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))\n            return 0;\n        else if (key->aux.tls_ver >= TLS1_1_VERSION)\n            iv = AES_BLOCK_SIZE;\n\n#  if defined(STITCHED_CALL)\n        /*\n         * Assembly stitch handles AVX-capable processors, but its\n         * performance is not optimal on AMD Jaguar, ~40% worse, for\n         * unknown reasons. Incidentally processor in question supports\n         * AVX, but not AMD-specific XOP extension, which can be used\n         * to identify it and avoid stitch invocation. So that after we\n         * establish that current CPU supports AVX, we even see if it's\n         * either even XOP-capable Bulldozer-based or GenuineIntel one.\n         */\n        if (OPENSSL_ia32cap_P[1] & (1 << (60 - 32)) && /* AVX? */\n            ((OPENSSL_ia32cap_P[1] & (1 << (43 - 32))) /* XOP? */\n             | (OPENSSL_ia32cap_P[0] & (1<<30))) &&    /* \"Intel CPU\"? */\n            plen > (sha_off + iv) &&\n            (blocks = (plen - (sha_off + iv)) / SHA256_CBLOCK)) {\n            SHA256_Update(&key->md, in + iv, sha_off);\n\n            (void)aesni_cbc_sha256_enc(in, out, blocks, &key->ks,\n                                       ctx->iv, &key->md, in + iv + sha_off);\n            blocks *= SHA256_CBLOCK;\n            aes_off += blocks;\n            sha_off += blocks;\n            key->md.Nh += blocks >> 29;\n            key->md.Nl += blocks <<= 3;\n            if (key->md.Nl < (unsigned int)blocks)\n                key->md.Nh++;\n        } else {\n            sha_off = 0;\n        }\n#  endif\n        sha_off += iv;\n        SHA256_Update(&key->md, in + sha_off, plen - sha_off);\n\n        if (plen != len) {      /* \"TLS\" mode of operation */\n            if (in != out)\n                memcpy(out + aes_off, in + aes_off, plen - aes_off);\n\n            /* calculate HMAC and append it to payload */\n            SHA256_Final(out + plen, &key->md);\n            key->md = key->tail;\n            SHA256_Update(&key->md, out + plen, SHA256_DIGEST_LENGTH);\n            SHA256_Final(out + plen, &key->md);\n\n            /* pad the payload|hmac */\n            plen += SHA256_DIGEST_LENGTH;\n            for (l = len - plen - 1; plen < len; plen++)\n                out[plen] = l;\n            /* encrypt HMAC|padding at once */\n            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,\n                              &key->ks, ctx->iv, 1);\n        } else {\n            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,\n                              &key->ks, ctx->iv, 1);\n        }\n    } else {\n        union {\n            unsigned int u[SHA256_DIGEST_LENGTH / sizeof(unsigned int)];\n            unsigned char c[64 + SHA256_DIGEST_LENGTH];\n        } mac, *pmac;\n\n        /* arrange cache line alignment */\n        pmac = (void *)(((size_t)mac.c + 63) & ((size_t)0 - 64));\n\n        /* decrypt HMAC|padding at once */\n        aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\n\n        if (plen != NO_PAYLOAD_LENGTH) { /* \"TLS\" mode of operation */\n            size_t inp_len, mask, j, i;\n            unsigned int res, maxpad, pad, bitlen;\n            int ret = 1;\n            union {\n                unsigned int u[SHA_LBLOCK];\n                unsigned char c[SHA256_CBLOCK];\n            } *data = (void *)key->md.data;\n\n            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])\n                >= TLS1_1_VERSION)\n                iv = AES_BLOCK_SIZE;\n\n            if (len < (iv + SHA256_DIGEST_LENGTH + 1))\n                return 0;\n\n            /* omit explicit iv */\n            out += iv;\n            len -= iv;\n\n            /* figure out payload length */\n            pad = out[len - 1];\n            maxpad = len - (SHA256_DIGEST_LENGTH + 1);\n            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);\n            maxpad &= 255;\n\n            inp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);\n            mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));\n            inp_len &= mask;\n            ret &= (int)mask;\n\n            key->aux.tls_aad[plen - 2] = inp_len >> 8;\n            key->aux.tls_aad[plen - 1] = inp_len;\n\n            /* calculate HMAC */\n            key->md = key->head;\n            SHA256_Update(&key->md, key->aux.tls_aad, plen);\n\n#  if 1\n            len -= SHA256_DIGEST_LENGTH; /* amend mac */\n            if (len >= (256 + SHA256_CBLOCK)) {\n                j = (len - (256 + SHA256_CBLOCK)) & (0 - SHA256_CBLOCK);\n                j += SHA256_CBLOCK - key->md.num;\n                SHA256_Update(&key->md, out, j);\n                out += j;\n                len -= j;\n                inp_len -= j;\n            }\n\n            /* but pretend as if we hashed padded payload */\n            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */\n#   ifdef BSWAP4\n            bitlen = BSWAP4(bitlen);\n#   else\n            mac.c[0] = 0;\n            mac.c[1] = (unsigned char)(bitlen >> 16);\n            mac.c[2] = (unsigned char)(bitlen >> 8);\n            mac.c[3] = (unsigned char)bitlen;\n            bitlen = mac.u[0];\n#   endif\n\n            pmac->u[0] = 0;\n            pmac->u[1] = 0;\n            pmac->u[2] = 0;\n            pmac->u[3] = 0;\n            pmac->u[4] = 0;\n            pmac->u[5] = 0;\n            pmac->u[6] = 0;\n            pmac->u[7] = 0;\n\n            for (res = key->md.num, j = 0; j < len; j++) {\n                size_t c = out[j];\n                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);\n                c &= mask;\n                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));\n                data->c[res++] = (unsigned char)c;\n\n                if (res != SHA256_CBLOCK)\n                    continue;\n\n                /* j is not incremented yet */\n                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));\n                data->u[SHA_LBLOCK - 1] |= bitlen & mask;\n                sha256_block_data_order(&key->md, data, 1);\n                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));\n                pmac->u[0] |= key->md.h[0] & mask;\n                pmac->u[1] |= key->md.h[1] & mask;\n                pmac->u[2] |= key->md.h[2] & mask;\n                pmac->u[3] |= key->md.h[3] & mask;\n                pmac->u[4] |= key->md.h[4] & mask;\n                pmac->u[5] |= key->md.h[5] & mask;\n                pmac->u[6] |= key->md.h[6] & mask;\n                pmac->u[7] |= key->md.h[7] & mask;\n                res = 0;\n            }\n\n            for (i = res; i < SHA256_CBLOCK; i++, j++)\n                data->c[i] = 0;\n\n            if (res > SHA256_CBLOCK - 8) {\n                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));\n                data->u[SHA_LBLOCK - 1] |= bitlen & mask;\n                sha256_block_data_order(&key->md, data, 1);\n                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\n                pmac->u[0] |= key->md.h[0] & mask;\n                pmac->u[1] |= key->md.h[1] & mask;\n                pmac->u[2] |= key->md.h[2] & mask;\n                pmac->u[3] |= key->md.h[3] & mask;\n                pmac->u[4] |= key->md.h[4] & mask;\n                pmac->u[5] |= key->md.h[5] & mask;\n                pmac->u[6] |= key->md.h[6] & mask;\n                pmac->u[7] |= key->md.h[7] & mask;\n\n                memset(data, 0, SHA256_CBLOCK);\n                j += 64;\n            }\n            data->u[SHA_LBLOCK - 1] = bitlen;\n            sha256_block_data_order(&key->md, data, 1);\n            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\n            pmac->u[0] |= key->md.h[0] & mask;\n            pmac->u[1] |= key->md.h[1] & mask;\n            pmac->u[2] |= key->md.h[2] & mask;\n            pmac->u[3] |= key->md.h[3] & mask;\n            pmac->u[4] |= key->md.h[4] & mask;\n            pmac->u[5] |= key->md.h[5] & mask;\n            pmac->u[6] |= key->md.h[6] & mask;\n            pmac->u[7] |= key->md.h[7] & mask;\n\n#   ifdef BSWAP4\n            pmac->u[0] = BSWAP4(pmac->u[0]);\n            pmac->u[1] = BSWAP4(pmac->u[1]);\n            pmac->u[2] = BSWAP4(pmac->u[2]);\n            pmac->u[3] = BSWAP4(pmac->u[3]);\n            pmac->u[4] = BSWAP4(pmac->u[4]);\n            pmac->u[5] = BSWAP4(pmac->u[5]);\n            pmac->u[6] = BSWAP4(pmac->u[6]);\n            pmac->u[7] = BSWAP4(pmac->u[7]);\n#   else\n            for (i = 0; i < 8; i++) {\n                res = pmac->u[i];\n                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);\n                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);\n                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);\n                pmac->c[4 * i + 3] = (unsigned char)res;\n            }\n#   endif\n            len += SHA256_DIGEST_LENGTH;\n#  else\n            SHA256_Update(&key->md, out, inp_len);\n            res = key->md.num;\n            SHA256_Final(pmac->c, &key->md);\n\n            {\n                unsigned int inp_blocks, pad_blocks;\n\n                /* but pretend as if we hashed padded payload */\n                inp_blocks =\n                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\n                res += (unsigned int)(len - inp_len);\n                pad_blocks = res / SHA256_CBLOCK;\n                res %= SHA256_CBLOCK;\n                pad_blocks +=\n                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\n                for (; inp_blocks < pad_blocks; inp_blocks++)\n                    sha1_block_data_order(&key->md, data, 1);\n            }\n#  endif\n            key->md = key->tail;\n            SHA256_Update(&key->md, pmac->c, SHA256_DIGEST_LENGTH);\n            SHA256_Final(pmac->c, &key->md);\n\n            /* verify HMAC */\n            out += inp_len;\n            len -= inp_len;\n#  if 1\n            {\n                unsigned char *p =\n                    out + len - 1 - maxpad - SHA256_DIGEST_LENGTH;\n                size_t off = out - p;\n                unsigned int c, cmask;\n\n                maxpad += SHA256_DIGEST_LENGTH;\n                for (res = 0, i = 0, j = 0; j < maxpad; j++) {\n                    c = p[j];\n                    cmask =\n                        ((int)(j - off - SHA256_DIGEST_LENGTH)) >>\n                        (sizeof(int) * 8 - 1);\n                    res |= (c ^ pad) & ~cmask; /* ... and padding */\n                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);\n                    res |= (c ^ pmac->c[i]) & cmask;\n                    i += 1 & cmask;\n                }\n                maxpad -= SHA256_DIGEST_LENGTH;\n\n                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\n                ret &= (int)~res;\n            }\n#  else\n            for (res = 0, i = 0; i < SHA256_DIGEST_LENGTH; i++)\n                res |= out[i] ^ pmac->c[i];\n            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\n            ret &= (int)~res;\n\n            /* verify padding */\n            pad = (pad & ~res) | (maxpad & res);\n            out = out + len - 1 - pad;\n            for (res = 0, i = 0; i < pad; i++)\n                res |= out[i] ^ pad;\n\n            res = (0 - res) >> (sizeof(res) * 8 - 1);\n            ret &= (int)~res;\n#  endif\n            return ret;\n        } else {\n            SHA256_Update(&key->md, out, len);\n        }\n    }\n\n    return 1;\n}",
        "func": "static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,\n                                        unsigned char *out,\n                                        const unsigned char *in, size_t len)\n{\n    EVP_AES_HMAC_SHA256 *key = data(ctx);\n    unsigned int l;\n    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and\n                                                * later */\n        sha_off = 0;\n#  if defined(STITCHED_CALL)\n    size_t aes_off = 0, blocks;\n\n    sha_off = SHA256_CBLOCK - key->md.num;\n#  endif\n\n    key->payload_length = NO_PAYLOAD_LENGTH;\n\n    if (len % AES_BLOCK_SIZE)\n        return 0;\n\n    if (ctx->encrypt) {\n        if (plen == NO_PAYLOAD_LENGTH)\n            plen = len;\n        else if (len !=\n                 ((plen + SHA256_DIGEST_LENGTH +\n                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))\n            return 0;\n        else if (key->aux.tls_ver >= TLS1_1_VERSION)\n            iv = AES_BLOCK_SIZE;\n\n#  if defined(STITCHED_CALL)\n        /*\n         * Assembly stitch handles AVX-capable processors, but its\n         * performance is not optimal on AMD Jaguar, ~40% worse, for\n         * unknown reasons. Incidentally processor in question supports\n         * AVX, but not AMD-specific XOP extension, which can be used\n         * to identify it and avoid stitch invocation. So that after we\n         * establish that current CPU supports AVX, we even see if it's\n         * either even XOP-capable Bulldozer-based or GenuineIntel one.\n         */\n        if (OPENSSL_ia32cap_P[1] & (1 << (60 - 32)) && /* AVX? */\n            ((OPENSSL_ia32cap_P[1] & (1 << (43 - 32))) /* XOP? */\n             | (OPENSSL_ia32cap_P[0] & (1<<30))) &&    /* \"Intel CPU\"? */\n            plen > (sha_off + iv) &&\n            (blocks = (plen - (sha_off + iv)) / SHA256_CBLOCK)) {\n            SHA256_Update(&key->md, in + iv, sha_off);\n\n            (void)aesni_cbc_sha256_enc(in, out, blocks, &key->ks,\n                                       ctx->iv, &key->md, in + iv + sha_off);\n            blocks *= SHA256_CBLOCK;\n            aes_off += blocks;\n            sha_off += blocks;\n            key->md.Nh += blocks >> 29;\n            key->md.Nl += blocks <<= 3;\n            if (key->md.Nl < (unsigned int)blocks)\n                key->md.Nh++;\n        } else {\n            sha_off = 0;\n        }\n#  endif\n        sha_off += iv;\n        SHA256_Update(&key->md, in + sha_off, plen - sha_off);\n\n        if (plen != len) {      /* \"TLS\" mode of operation */\n            if (in != out)\n                memcpy(out + aes_off, in + aes_off, plen - aes_off);\n\n            /* calculate HMAC and append it to payload */\n            SHA256_Final(out + plen, &key->md);\n            key->md = key->tail;\n            SHA256_Update(&key->md, out + plen, SHA256_DIGEST_LENGTH);\n            SHA256_Final(out + plen, &key->md);\n\n            /* pad the payload|hmac */\n            plen += SHA256_DIGEST_LENGTH;\n            for (l = len - plen - 1; plen < len; plen++)\n                out[plen] = l;\n            /* encrypt HMAC|padding at once */\n            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,\n                              &key->ks, ctx->iv, 1);\n        } else {\n            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,\n                              &key->ks, ctx->iv, 1);\n        }\n    } else {\n        union {\n            unsigned int u[SHA256_DIGEST_LENGTH / sizeof(unsigned int)];\n            unsigned char c[64 + SHA256_DIGEST_LENGTH];\n        } mac, *pmac;\n\n        /* arrange cache line alignment */\n        pmac = (void *)(((size_t)mac.c + 63) & ((size_t)0 - 64));\n\n        /* decrypt HMAC|padding at once */\n        aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\n\n        if (plen != NO_PAYLOAD_LENGTH) { /* \"TLS\" mode of operation */\n            size_t inp_len, mask, j, i;\n            unsigned int res, maxpad, pad, bitlen;\n            int ret = 1;\n            union {\n                unsigned int u[SHA_LBLOCK];\n                unsigned char c[SHA256_CBLOCK];\n            } *data = (void *)key->md.data;\n\n            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])\n                >= TLS1_1_VERSION)\n                iv = AES_BLOCK_SIZE;\n\n            if (len < (iv + SHA256_DIGEST_LENGTH + 1))\n                return 0;\n\n            /* omit explicit iv */\n            out += iv;\n            len -= iv;\n\n            /* figure out payload length */\n            pad = out[len - 1];\n            maxpad = len - (SHA256_DIGEST_LENGTH + 1);\n            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);\n            maxpad &= 255;\n\n            ret &= constant_time_ge(maxpad, pad);\n\n            inp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);\n            mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));\n            inp_len &= mask;\n            ret &= (int)mask;\n\n            key->aux.tls_aad[plen - 2] = inp_len >> 8;\n            key->aux.tls_aad[plen - 1] = inp_len;\n\n            /* calculate HMAC */\n            key->md = key->head;\n            SHA256_Update(&key->md, key->aux.tls_aad, plen);\n\n#  if 1\n            len -= SHA256_DIGEST_LENGTH; /* amend mac */\n            if (len >= (256 + SHA256_CBLOCK)) {\n                j = (len - (256 + SHA256_CBLOCK)) & (0 - SHA256_CBLOCK);\n                j += SHA256_CBLOCK - key->md.num;\n                SHA256_Update(&key->md, out, j);\n                out += j;\n                len -= j;\n                inp_len -= j;\n            }\n\n            /* but pretend as if we hashed padded payload */\n            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */\n#   ifdef BSWAP4\n            bitlen = BSWAP4(bitlen);\n#   else\n            mac.c[0] = 0;\n            mac.c[1] = (unsigned char)(bitlen >> 16);\n            mac.c[2] = (unsigned char)(bitlen >> 8);\n            mac.c[3] = (unsigned char)bitlen;\n            bitlen = mac.u[0];\n#   endif\n\n            pmac->u[0] = 0;\n            pmac->u[1] = 0;\n            pmac->u[2] = 0;\n            pmac->u[3] = 0;\n            pmac->u[4] = 0;\n            pmac->u[5] = 0;\n            pmac->u[6] = 0;\n            pmac->u[7] = 0;\n\n            for (res = key->md.num, j = 0; j < len; j++) {\n                size_t c = out[j];\n                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);\n                c &= mask;\n                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));\n                data->c[res++] = (unsigned char)c;\n\n                if (res != SHA256_CBLOCK)\n                    continue;\n\n                /* j is not incremented yet */\n                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));\n                data->u[SHA_LBLOCK - 1] |= bitlen & mask;\n                sha256_block_data_order(&key->md, data, 1);\n                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));\n                pmac->u[0] |= key->md.h[0] & mask;\n                pmac->u[1] |= key->md.h[1] & mask;\n                pmac->u[2] |= key->md.h[2] & mask;\n                pmac->u[3] |= key->md.h[3] & mask;\n                pmac->u[4] |= key->md.h[4] & mask;\n                pmac->u[5] |= key->md.h[5] & mask;\n                pmac->u[6] |= key->md.h[6] & mask;\n                pmac->u[7] |= key->md.h[7] & mask;\n                res = 0;\n            }\n\n            for (i = res; i < SHA256_CBLOCK; i++, j++)\n                data->c[i] = 0;\n\n            if (res > SHA256_CBLOCK - 8) {\n                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));\n                data->u[SHA_LBLOCK - 1] |= bitlen & mask;\n                sha256_block_data_order(&key->md, data, 1);\n                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\n                pmac->u[0] |= key->md.h[0] & mask;\n                pmac->u[1] |= key->md.h[1] & mask;\n                pmac->u[2] |= key->md.h[2] & mask;\n                pmac->u[3] |= key->md.h[3] & mask;\n                pmac->u[4] |= key->md.h[4] & mask;\n                pmac->u[5] |= key->md.h[5] & mask;\n                pmac->u[6] |= key->md.h[6] & mask;\n                pmac->u[7] |= key->md.h[7] & mask;\n\n                memset(data, 0, SHA256_CBLOCK);\n                j += 64;\n            }\n            data->u[SHA_LBLOCK - 1] = bitlen;\n            sha256_block_data_order(&key->md, data, 1);\n            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\n            pmac->u[0] |= key->md.h[0] & mask;\n            pmac->u[1] |= key->md.h[1] & mask;\n            pmac->u[2] |= key->md.h[2] & mask;\n            pmac->u[3] |= key->md.h[3] & mask;\n            pmac->u[4] |= key->md.h[4] & mask;\n            pmac->u[5] |= key->md.h[5] & mask;\n            pmac->u[6] |= key->md.h[6] & mask;\n            pmac->u[7] |= key->md.h[7] & mask;\n\n#   ifdef BSWAP4\n            pmac->u[0] = BSWAP4(pmac->u[0]);\n            pmac->u[1] = BSWAP4(pmac->u[1]);\n            pmac->u[2] = BSWAP4(pmac->u[2]);\n            pmac->u[3] = BSWAP4(pmac->u[3]);\n            pmac->u[4] = BSWAP4(pmac->u[4]);\n            pmac->u[5] = BSWAP4(pmac->u[5]);\n            pmac->u[6] = BSWAP4(pmac->u[6]);\n            pmac->u[7] = BSWAP4(pmac->u[7]);\n#   else\n            for (i = 0; i < 8; i++) {\n                res = pmac->u[i];\n                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);\n                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);\n                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);\n                pmac->c[4 * i + 3] = (unsigned char)res;\n            }\n#   endif\n            len += SHA256_DIGEST_LENGTH;\n#  else\n            SHA256_Update(&key->md, out, inp_len);\n            res = key->md.num;\n            SHA256_Final(pmac->c, &key->md);\n\n            {\n                unsigned int inp_blocks, pad_blocks;\n\n                /* but pretend as if we hashed padded payload */\n                inp_blocks =\n                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\n                res += (unsigned int)(len - inp_len);\n                pad_blocks = res / SHA256_CBLOCK;\n                res %= SHA256_CBLOCK;\n                pad_blocks +=\n                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\n                for (; inp_blocks < pad_blocks; inp_blocks++)\n                    sha1_block_data_order(&key->md, data, 1);\n            }\n#  endif\n            key->md = key->tail;\n            SHA256_Update(&key->md, pmac->c, SHA256_DIGEST_LENGTH);\n            SHA256_Final(pmac->c, &key->md);\n\n            /* verify HMAC */\n            out += inp_len;\n            len -= inp_len;\n#  if 1\n            {\n                unsigned char *p =\n                    out + len - 1 - maxpad - SHA256_DIGEST_LENGTH;\n                size_t off = out - p;\n                unsigned int c, cmask;\n\n                maxpad += SHA256_DIGEST_LENGTH;\n                for (res = 0, i = 0, j = 0; j < maxpad; j++) {\n                    c = p[j];\n                    cmask =\n                        ((int)(j - off - SHA256_DIGEST_LENGTH)) >>\n                        (sizeof(int) * 8 - 1);\n                    res |= (c ^ pad) & ~cmask; /* ... and padding */\n                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);\n                    res |= (c ^ pmac->c[i]) & cmask;\n                    i += 1 & cmask;\n                }\n                maxpad -= SHA256_DIGEST_LENGTH;\n\n                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\n                ret &= (int)~res;\n            }\n#  else\n            for (res = 0, i = 0; i < SHA256_DIGEST_LENGTH; i++)\n                res |= out[i] ^ pmac->c[i];\n            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\n            ret &= (int)~res;\n\n            /* verify padding */\n            pad = (pad & ~res) | (maxpad & res);\n            out = out + len - 1 - pad;\n            for (res = 0, i = 0; i < pad; i++)\n                res |= out[i] ^ pad;\n\n            res = (0 - res) >> (sizeof(res) * 8 - 1);\n            ret &= (int)~res;\n#  endif\n            return ret;\n        } else {\n            SHA256_Update(&key->md, out, len);\n        }\n    }\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -120,6 +120,8 @@\n             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);\n             maxpad &= 255;\n \n+            ret &= constant_time_ge(maxpad, pad);\n+\n             inp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);\n             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));\n             inp_len &= mask;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            ret &= constant_time_ge(maxpad, pad);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2107",
        "func_name": "openssl/aesni_cbc_hmac_sha1_cipher",
        "description": "The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=68595c0c2886e7942a14f98c17a55a88afb6c292",
        "commit_title": "",
        "commit_text": "Check that we have enough padding characters.  CVE-2016-2107  MR: #2572 ",
        "func_before": "static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                      const unsigned char *in, size_t len)\n{\n    EVP_AES_HMAC_SHA1 *key = data(ctx);\n    unsigned int l;\n    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and\n                                                * later */\n        sha_off = 0;\n#  if defined(STITCHED_CALL)\n    size_t aes_off = 0, blocks;\n\n    sha_off = SHA_CBLOCK - key->md.num;\n#  endif\n\n    key->payload_length = NO_PAYLOAD_LENGTH;\n\n    if (len % AES_BLOCK_SIZE)\n        return 0;\n\n    if (ctx->encrypt) {\n        if (plen == NO_PAYLOAD_LENGTH)\n            plen = len;\n        else if (len !=\n                 ((plen + SHA_DIGEST_LENGTH +\n                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))\n            return 0;\n        else if (key->aux.tls_ver >= TLS1_1_VERSION)\n            iv = AES_BLOCK_SIZE;\n\n#  if defined(STITCHED_CALL)\n        if (plen > (sha_off + iv)\n            && (blocks = (plen - (sha_off + iv)) / SHA_CBLOCK)) {\n            SHA1_Update(&key->md, in + iv, sha_off);\n\n            aesni_cbc_sha1_enc(in, out, blocks, &key->ks,\n                               ctx->iv, &key->md, in + iv + sha_off);\n            blocks *= SHA_CBLOCK;\n            aes_off += blocks;\n            sha_off += blocks;\n            key->md.Nh += blocks >> 29;\n            key->md.Nl += blocks <<= 3;\n            if (key->md.Nl < (unsigned int)blocks)\n                key->md.Nh++;\n        } else {\n            sha_off = 0;\n        }\n#  endif\n        sha_off += iv;\n        SHA1_Update(&key->md, in + sha_off, plen - sha_off);\n\n        if (plen != len) {      /* \"TLS\" mode of operation */\n            if (in != out)\n                memcpy(out + aes_off, in + aes_off, plen - aes_off);\n\n            /* calculate HMAC and append it to payload */\n            SHA1_Final(out + plen, &key->md);\n            key->md = key->tail;\n            SHA1_Update(&key->md, out + plen, SHA_DIGEST_LENGTH);\n            SHA1_Final(out + plen, &key->md);\n\n            /* pad the payload|hmac */\n            plen += SHA_DIGEST_LENGTH;\n            for (l = len - plen - 1; plen < len; plen++)\n                out[plen] = l;\n            /* encrypt HMAC|padding at once */\n            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,\n                              &key->ks, ctx->iv, 1);\n        } else {\n            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,\n                              &key->ks, ctx->iv, 1);\n        }\n    } else {\n        union {\n            unsigned int u[SHA_DIGEST_LENGTH / sizeof(unsigned int)];\n            unsigned char c[32 + SHA_DIGEST_LENGTH];\n        } mac, *pmac;\n\n        /* arrange cache line alignment */\n        pmac = (void *)(((size_t)mac.c + 31) & ((size_t)0 - 32));\n\n        if (plen != NO_PAYLOAD_LENGTH) { /* \"TLS\" mode of operation */\n            size_t inp_len, mask, j, i;\n            unsigned int res, maxpad, pad, bitlen;\n            int ret = 1;\n            union {\n                unsigned int u[SHA_LBLOCK];\n                unsigned char c[SHA_CBLOCK];\n            } *data = (void *)key->md.data;\n#  if defined(STITCHED_DECRYPT_CALL)\n            unsigned char tail_iv[AES_BLOCK_SIZE];\n            int stitch = 0;\n#  endif\n\n            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])\n                >= TLS1_1_VERSION) {\n                if (len < (AES_BLOCK_SIZE + SHA_DIGEST_LENGTH + 1))\n                    return 0;\n\n                /* omit explicit iv */\n                memcpy(ctx->iv, in, AES_BLOCK_SIZE);\n                in += AES_BLOCK_SIZE;\n                out += AES_BLOCK_SIZE;\n                len -= AES_BLOCK_SIZE;\n            } else if (len < (SHA_DIGEST_LENGTH + 1))\n                return 0;\n\n#  if defined(STITCHED_DECRYPT_CALL)\n            if (len >= 1024 && ctx->key_len == 32) {\n                /* decrypt last block */\n                memcpy(tail_iv, in + len - 2 * AES_BLOCK_SIZE,\n                       AES_BLOCK_SIZE);\n                aesni_cbc_encrypt(in + len - AES_BLOCK_SIZE,\n                                  out + len - AES_BLOCK_SIZE, AES_BLOCK_SIZE,\n                                  &key->ks, tail_iv, 0);\n                stitch = 1;\n            } else\n#  endif\n                /* decrypt HMAC|padding at once */\n                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\n\n            /* figure out payload length */\n            pad = out[len - 1];\n            maxpad = len - (SHA_DIGEST_LENGTH + 1);\n            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);\n            maxpad &= 255;\n\n            inp_len = len - (SHA_DIGEST_LENGTH + pad + 1);\n            mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));\n            inp_len &= mask;\n            ret &= (int)mask;\n\n            key->aux.tls_aad[plen - 2] = inp_len >> 8;\n            key->aux.tls_aad[plen - 1] = inp_len;\n\n            /* calculate HMAC */\n            key->md = key->head;\n            SHA1_Update(&key->md, key->aux.tls_aad, plen);\n\n#  if defined(STITCHED_DECRYPT_CALL)\n            if (stitch) {\n                blocks = (len - (256 + 32 + SHA_CBLOCK)) / SHA_CBLOCK;\n                aes_off = len - AES_BLOCK_SIZE - blocks * SHA_CBLOCK;\n                sha_off = SHA_CBLOCK - plen;\n\n                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);\n\n                SHA1_Update(&key->md, out, sha_off);\n                aesni256_cbc_sha1_dec(in + aes_off,\n                                      out + aes_off, blocks, &key->ks,\n                                      ctx->iv, &key->md, out + sha_off);\n\n                sha_off += blocks *= SHA_CBLOCK;\n                out += sha_off;\n                len -= sha_off;\n                inp_len -= sha_off;\n\n                key->md.Nl += (blocks << 3); /* at most 18 bits */\n                memcpy(ctx->iv, tail_iv, AES_BLOCK_SIZE);\n            }\n#  endif\n\n#  if 1\n            len -= SHA_DIGEST_LENGTH; /* amend mac */\n            if (len >= (256 + SHA_CBLOCK)) {\n                j = (len - (256 + SHA_CBLOCK)) & (0 - SHA_CBLOCK);\n                j += SHA_CBLOCK - key->md.num;\n                SHA1_Update(&key->md, out, j);\n                out += j;\n                len -= j;\n                inp_len -= j;\n            }\n\n            /* but pretend as if we hashed padded payload */\n            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */\n#   ifdef BSWAP4\n            bitlen = BSWAP4(bitlen);\n#   else\n            mac.c[0] = 0;\n            mac.c[1] = (unsigned char)(bitlen >> 16);\n            mac.c[2] = (unsigned char)(bitlen >> 8);\n            mac.c[3] = (unsigned char)bitlen;\n            bitlen = mac.u[0];\n#   endif\n\n            pmac->u[0] = 0;\n            pmac->u[1] = 0;\n            pmac->u[2] = 0;\n            pmac->u[3] = 0;\n            pmac->u[4] = 0;\n\n            for (res = key->md.num, j = 0; j < len; j++) {\n                size_t c = out[j];\n                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);\n                c &= mask;\n                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));\n                data->c[res++] = (unsigned char)c;\n\n                if (res != SHA_CBLOCK)\n                    continue;\n\n                /* j is not incremented yet */\n                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));\n                data->u[SHA_LBLOCK - 1] |= bitlen & mask;\n                sha1_block_data_order(&key->md, data, 1);\n                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));\n                pmac->u[0] |= key->md.h0 & mask;\n                pmac->u[1] |= key->md.h1 & mask;\n                pmac->u[2] |= key->md.h2 & mask;\n                pmac->u[3] |= key->md.h3 & mask;\n                pmac->u[4] |= key->md.h4 & mask;\n                res = 0;\n            }\n\n            for (i = res; i < SHA_CBLOCK; i++, j++)\n                data->c[i] = 0;\n\n            if (res > SHA_CBLOCK - 8) {\n                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));\n                data->u[SHA_LBLOCK - 1] |= bitlen & mask;\n                sha1_block_data_order(&key->md, data, 1);\n                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\n                pmac->u[0] |= key->md.h0 & mask;\n                pmac->u[1] |= key->md.h1 & mask;\n                pmac->u[2] |= key->md.h2 & mask;\n                pmac->u[3] |= key->md.h3 & mask;\n                pmac->u[4] |= key->md.h4 & mask;\n\n                memset(data, 0, SHA_CBLOCK);\n                j += 64;\n            }\n            data->u[SHA_LBLOCK - 1] = bitlen;\n            sha1_block_data_order(&key->md, data, 1);\n            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\n            pmac->u[0] |= key->md.h0 & mask;\n            pmac->u[1] |= key->md.h1 & mask;\n            pmac->u[2] |= key->md.h2 & mask;\n            pmac->u[3] |= key->md.h3 & mask;\n            pmac->u[4] |= key->md.h4 & mask;\n\n#   ifdef BSWAP4\n            pmac->u[0] = BSWAP4(pmac->u[0]);\n            pmac->u[1] = BSWAP4(pmac->u[1]);\n            pmac->u[2] = BSWAP4(pmac->u[2]);\n            pmac->u[3] = BSWAP4(pmac->u[3]);\n            pmac->u[4] = BSWAP4(pmac->u[4]);\n#   else\n            for (i = 0; i < 5; i++) {\n                res = pmac->u[i];\n                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);\n                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);\n                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);\n                pmac->c[4 * i + 3] = (unsigned char)res;\n            }\n#   endif\n            len += SHA_DIGEST_LENGTH;\n#  else\n            SHA1_Update(&key->md, out, inp_len);\n            res = key->md.num;\n            SHA1_Final(pmac->c, &key->md);\n\n            {\n                unsigned int inp_blocks, pad_blocks;\n\n                /* but pretend as if we hashed padded payload */\n                inp_blocks =\n                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\n                res += (unsigned int)(len - inp_len);\n                pad_blocks = res / SHA_CBLOCK;\n                res %= SHA_CBLOCK;\n                pad_blocks +=\n                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\n                for (; inp_blocks < pad_blocks; inp_blocks++)\n                    sha1_block_data_order(&key->md, data, 1);\n            }\n#  endif\n            key->md = key->tail;\n            SHA1_Update(&key->md, pmac->c, SHA_DIGEST_LENGTH);\n            SHA1_Final(pmac->c, &key->md);\n\n            /* verify HMAC */\n            out += inp_len;\n            len -= inp_len;\n#  if 1\n            {\n                unsigned char *p = out + len - 1 - maxpad - SHA_DIGEST_LENGTH;\n                size_t off = out - p;\n                unsigned int c, cmask;\n\n                maxpad += SHA_DIGEST_LENGTH;\n                for (res = 0, i = 0, j = 0; j < maxpad; j++) {\n                    c = p[j];\n                    cmask =\n                        ((int)(j - off - SHA_DIGEST_LENGTH)) >> (sizeof(int) *\n                                                                 8 - 1);\n                    res |= (c ^ pad) & ~cmask; /* ... and padding */\n                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);\n                    res |= (c ^ pmac->c[i]) & cmask;\n                    i += 1 & cmask;\n                }\n                maxpad -= SHA_DIGEST_LENGTH;\n\n                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\n                ret &= (int)~res;\n            }\n#  else\n            for (res = 0, i = 0; i < SHA_DIGEST_LENGTH; i++)\n                res |= out[i] ^ pmac->c[i];\n            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\n            ret &= (int)~res;\n\n            /* verify padding */\n            pad = (pad & ~res) | (maxpad & res);\n            out = out + len - 1 - pad;\n            for (res = 0, i = 0; i < pad; i++)\n                res |= out[i] ^ pad;\n\n            res = (0 - res) >> (sizeof(res) * 8 - 1);\n            ret &= (int)~res;\n#  endif\n            return ret;\n        } else {\n#  if defined(STITCHED_DECRYPT_CALL)\n            if (len >= 1024 && ctx->key_len == 32) {\n                if (sha_off %= SHA_CBLOCK)\n                    blocks = (len - 3 * SHA_CBLOCK) / SHA_CBLOCK;\n                else\n                    blocks = (len - 2 * SHA_CBLOCK) / SHA_CBLOCK;\n                aes_off = len - blocks * SHA_CBLOCK;\n\n                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);\n                SHA1_Update(&key->md, out, sha_off);\n                aesni256_cbc_sha1_dec(in + aes_off,\n                                      out + aes_off, blocks, &key->ks,\n                                      ctx->iv, &key->md, out + sha_off);\n\n                sha_off += blocks *= SHA_CBLOCK;\n                out += sha_off;\n                len -= sha_off;\n\n                key->md.Nh += blocks >> 29;\n                key->md.Nl += blocks <<= 3;\n                if (key->md.Nl < (unsigned int)blocks)\n                    key->md.Nh++;\n            } else\n#  endif\n                /* decrypt HMAC|padding at once */\n                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\n\n            SHA1_Update(&key->md, out, len);\n        }\n    }\n\n    return 1;\n}",
        "func": "static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                                      const unsigned char *in, size_t len)\n{\n    EVP_AES_HMAC_SHA1 *key = data(ctx);\n    unsigned int l;\n    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and\n                                                * later */\n        sha_off = 0;\n#  if defined(STITCHED_CALL)\n    size_t aes_off = 0, blocks;\n\n    sha_off = SHA_CBLOCK - key->md.num;\n#  endif\n\n    key->payload_length = NO_PAYLOAD_LENGTH;\n\n    if (len % AES_BLOCK_SIZE)\n        return 0;\n\n    if (ctx->encrypt) {\n        if (plen == NO_PAYLOAD_LENGTH)\n            plen = len;\n        else if (len !=\n                 ((plen + SHA_DIGEST_LENGTH +\n                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))\n            return 0;\n        else if (key->aux.tls_ver >= TLS1_1_VERSION)\n            iv = AES_BLOCK_SIZE;\n\n#  if defined(STITCHED_CALL)\n        if (plen > (sha_off + iv)\n            && (blocks = (plen - (sha_off + iv)) / SHA_CBLOCK)) {\n            SHA1_Update(&key->md, in + iv, sha_off);\n\n            aesni_cbc_sha1_enc(in, out, blocks, &key->ks,\n                               ctx->iv, &key->md, in + iv + sha_off);\n            blocks *= SHA_CBLOCK;\n            aes_off += blocks;\n            sha_off += blocks;\n            key->md.Nh += blocks >> 29;\n            key->md.Nl += blocks <<= 3;\n            if (key->md.Nl < (unsigned int)blocks)\n                key->md.Nh++;\n        } else {\n            sha_off = 0;\n        }\n#  endif\n        sha_off += iv;\n        SHA1_Update(&key->md, in + sha_off, plen - sha_off);\n\n        if (plen != len) {      /* \"TLS\" mode of operation */\n            if (in != out)\n                memcpy(out + aes_off, in + aes_off, plen - aes_off);\n\n            /* calculate HMAC and append it to payload */\n            SHA1_Final(out + plen, &key->md);\n            key->md = key->tail;\n            SHA1_Update(&key->md, out + plen, SHA_DIGEST_LENGTH);\n            SHA1_Final(out + plen, &key->md);\n\n            /* pad the payload|hmac */\n            plen += SHA_DIGEST_LENGTH;\n            for (l = len - plen - 1; plen < len; plen++)\n                out[plen] = l;\n            /* encrypt HMAC|padding at once */\n            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,\n                              &key->ks, ctx->iv, 1);\n        } else {\n            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,\n                              &key->ks, ctx->iv, 1);\n        }\n    } else {\n        union {\n            unsigned int u[SHA_DIGEST_LENGTH / sizeof(unsigned int)];\n            unsigned char c[32 + SHA_DIGEST_LENGTH];\n        } mac, *pmac;\n\n        /* arrange cache line alignment */\n        pmac = (void *)(((size_t)mac.c + 31) & ((size_t)0 - 32));\n\n        if (plen != NO_PAYLOAD_LENGTH) { /* \"TLS\" mode of operation */\n            size_t inp_len, mask, j, i;\n            unsigned int res, maxpad, pad, bitlen;\n            int ret = 1;\n            union {\n                unsigned int u[SHA_LBLOCK];\n                unsigned char c[SHA_CBLOCK];\n            } *data = (void *)key->md.data;\n#  if defined(STITCHED_DECRYPT_CALL)\n            unsigned char tail_iv[AES_BLOCK_SIZE];\n            int stitch = 0;\n#  endif\n\n            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])\n                >= TLS1_1_VERSION) {\n                if (len < (AES_BLOCK_SIZE + SHA_DIGEST_LENGTH + 1))\n                    return 0;\n\n                /* omit explicit iv */\n                memcpy(ctx->iv, in, AES_BLOCK_SIZE);\n                in += AES_BLOCK_SIZE;\n                out += AES_BLOCK_SIZE;\n                len -= AES_BLOCK_SIZE;\n            } else if (len < (SHA_DIGEST_LENGTH + 1))\n                return 0;\n\n#  if defined(STITCHED_DECRYPT_CALL)\n            if (len >= 1024 && ctx->key_len == 32) {\n                /* decrypt last block */\n                memcpy(tail_iv, in + len - 2 * AES_BLOCK_SIZE,\n                       AES_BLOCK_SIZE);\n                aesni_cbc_encrypt(in + len - AES_BLOCK_SIZE,\n                                  out + len - AES_BLOCK_SIZE, AES_BLOCK_SIZE,\n                                  &key->ks, tail_iv, 0);\n                stitch = 1;\n            } else\n#  endif\n                /* decrypt HMAC|padding at once */\n                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\n\n            /* figure out payload length */\n            pad = out[len - 1];\n            maxpad = len - (SHA_DIGEST_LENGTH + 1);\n            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);\n            maxpad &= 255;\n\n            ret &= constant_time_ge(maxpad, pad);\n\n            inp_len = len - (SHA_DIGEST_LENGTH + pad + 1);\n            mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));\n            inp_len &= mask;\n            ret &= (int)mask;\n\n            key->aux.tls_aad[plen - 2] = inp_len >> 8;\n            key->aux.tls_aad[plen - 1] = inp_len;\n\n            /* calculate HMAC */\n            key->md = key->head;\n            SHA1_Update(&key->md, key->aux.tls_aad, plen);\n\n#  if defined(STITCHED_DECRYPT_CALL)\n            if (stitch) {\n                blocks = (len - (256 + 32 + SHA_CBLOCK)) / SHA_CBLOCK;\n                aes_off = len - AES_BLOCK_SIZE - blocks * SHA_CBLOCK;\n                sha_off = SHA_CBLOCK - plen;\n\n                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);\n\n                SHA1_Update(&key->md, out, sha_off);\n                aesni256_cbc_sha1_dec(in + aes_off,\n                                      out + aes_off, blocks, &key->ks,\n                                      ctx->iv, &key->md, out + sha_off);\n\n                sha_off += blocks *= SHA_CBLOCK;\n                out += sha_off;\n                len -= sha_off;\n                inp_len -= sha_off;\n\n                key->md.Nl += (blocks << 3); /* at most 18 bits */\n                memcpy(ctx->iv, tail_iv, AES_BLOCK_SIZE);\n            }\n#  endif\n\n#  if 1\n            len -= SHA_DIGEST_LENGTH; /* amend mac */\n            if (len >= (256 + SHA_CBLOCK)) {\n                j = (len - (256 + SHA_CBLOCK)) & (0 - SHA_CBLOCK);\n                j += SHA_CBLOCK - key->md.num;\n                SHA1_Update(&key->md, out, j);\n                out += j;\n                len -= j;\n                inp_len -= j;\n            }\n\n            /* but pretend as if we hashed padded payload */\n            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */\n#   ifdef BSWAP4\n            bitlen = BSWAP4(bitlen);\n#   else\n            mac.c[0] = 0;\n            mac.c[1] = (unsigned char)(bitlen >> 16);\n            mac.c[2] = (unsigned char)(bitlen >> 8);\n            mac.c[3] = (unsigned char)bitlen;\n            bitlen = mac.u[0];\n#   endif\n\n            pmac->u[0] = 0;\n            pmac->u[1] = 0;\n            pmac->u[2] = 0;\n            pmac->u[3] = 0;\n            pmac->u[4] = 0;\n\n            for (res = key->md.num, j = 0; j < len; j++) {\n                size_t c = out[j];\n                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);\n                c &= mask;\n                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));\n                data->c[res++] = (unsigned char)c;\n\n                if (res != SHA_CBLOCK)\n                    continue;\n\n                /* j is not incremented yet */\n                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));\n                data->u[SHA_LBLOCK - 1] |= bitlen & mask;\n                sha1_block_data_order(&key->md, data, 1);\n                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));\n                pmac->u[0] |= key->md.h0 & mask;\n                pmac->u[1] |= key->md.h1 & mask;\n                pmac->u[2] |= key->md.h2 & mask;\n                pmac->u[3] |= key->md.h3 & mask;\n                pmac->u[4] |= key->md.h4 & mask;\n                res = 0;\n            }\n\n            for (i = res; i < SHA_CBLOCK; i++, j++)\n                data->c[i] = 0;\n\n            if (res > SHA_CBLOCK - 8) {\n                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));\n                data->u[SHA_LBLOCK - 1] |= bitlen & mask;\n                sha1_block_data_order(&key->md, data, 1);\n                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\n                pmac->u[0] |= key->md.h0 & mask;\n                pmac->u[1] |= key->md.h1 & mask;\n                pmac->u[2] |= key->md.h2 & mask;\n                pmac->u[3] |= key->md.h3 & mask;\n                pmac->u[4] |= key->md.h4 & mask;\n\n                memset(data, 0, SHA_CBLOCK);\n                j += 64;\n            }\n            data->u[SHA_LBLOCK - 1] = bitlen;\n            sha1_block_data_order(&key->md, data, 1);\n            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\n            pmac->u[0] |= key->md.h0 & mask;\n            pmac->u[1] |= key->md.h1 & mask;\n            pmac->u[2] |= key->md.h2 & mask;\n            pmac->u[3] |= key->md.h3 & mask;\n            pmac->u[4] |= key->md.h4 & mask;\n\n#   ifdef BSWAP4\n            pmac->u[0] = BSWAP4(pmac->u[0]);\n            pmac->u[1] = BSWAP4(pmac->u[1]);\n            pmac->u[2] = BSWAP4(pmac->u[2]);\n            pmac->u[3] = BSWAP4(pmac->u[3]);\n            pmac->u[4] = BSWAP4(pmac->u[4]);\n#   else\n            for (i = 0; i < 5; i++) {\n                res = pmac->u[i];\n                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);\n                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);\n                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);\n                pmac->c[4 * i + 3] = (unsigned char)res;\n            }\n#   endif\n            len += SHA_DIGEST_LENGTH;\n#  else\n            SHA1_Update(&key->md, out, inp_len);\n            res = key->md.num;\n            SHA1_Final(pmac->c, &key->md);\n\n            {\n                unsigned int inp_blocks, pad_blocks;\n\n                /* but pretend as if we hashed padded payload */\n                inp_blocks =\n                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\n                res += (unsigned int)(len - inp_len);\n                pad_blocks = res / SHA_CBLOCK;\n                res %= SHA_CBLOCK;\n                pad_blocks +=\n                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\n                for (; inp_blocks < pad_blocks; inp_blocks++)\n                    sha1_block_data_order(&key->md, data, 1);\n            }\n#  endif\n            key->md = key->tail;\n            SHA1_Update(&key->md, pmac->c, SHA_DIGEST_LENGTH);\n            SHA1_Final(pmac->c, &key->md);\n\n            /* verify HMAC */\n            out += inp_len;\n            len -= inp_len;\n#  if 1\n            {\n                unsigned char *p = out + len - 1 - maxpad - SHA_DIGEST_LENGTH;\n                size_t off = out - p;\n                unsigned int c, cmask;\n\n                maxpad += SHA_DIGEST_LENGTH;\n                for (res = 0, i = 0, j = 0; j < maxpad; j++) {\n                    c = p[j];\n                    cmask =\n                        ((int)(j - off - SHA_DIGEST_LENGTH)) >> (sizeof(int) *\n                                                                 8 - 1);\n                    res |= (c ^ pad) & ~cmask; /* ... and padding */\n                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);\n                    res |= (c ^ pmac->c[i]) & cmask;\n                    i += 1 & cmask;\n                }\n                maxpad -= SHA_DIGEST_LENGTH;\n\n                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\n                ret &= (int)~res;\n            }\n#  else\n            for (res = 0, i = 0; i < SHA_DIGEST_LENGTH; i++)\n                res |= out[i] ^ pmac->c[i];\n            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\n            ret &= (int)~res;\n\n            /* verify padding */\n            pad = (pad & ~res) | (maxpad & res);\n            out = out + len - 1 - pad;\n            for (res = 0, i = 0; i < pad; i++)\n                res |= out[i] ^ pad;\n\n            res = (0 - res) >> (sizeof(res) * 8 - 1);\n            ret &= (int)~res;\n#  endif\n            return ret;\n        } else {\n#  if defined(STITCHED_DECRYPT_CALL)\n            if (len >= 1024 && ctx->key_len == 32) {\n                if (sha_off %= SHA_CBLOCK)\n                    blocks = (len - 3 * SHA_CBLOCK) / SHA_CBLOCK;\n                else\n                    blocks = (len - 2 * SHA_CBLOCK) / SHA_CBLOCK;\n                aes_off = len - blocks * SHA_CBLOCK;\n\n                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);\n                SHA1_Update(&key->md, out, sha_off);\n                aesni256_cbc_sha1_dec(in + aes_off,\n                                      out + aes_off, blocks, &key->ks,\n                                      ctx->iv, &key->md, out + sha_off);\n\n                sha_off += blocks *= SHA_CBLOCK;\n                out += sha_off;\n                len -= sha_off;\n\n                key->md.Nh += blocks >> 29;\n                key->md.Nl += blocks <<= 3;\n                if (key->md.Nl < (unsigned int)blocks)\n                    key->md.Nh++;\n            } else\n#  endif\n                /* decrypt HMAC|padding at once */\n                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\n\n            SHA1_Update(&key->md, out, len);\n        }\n    }\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,6 +124,8 @@\n             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);\n             maxpad &= 255;\n \n+            ret &= constant_time_ge(maxpad, pad);\n+\n             inp_len = len - (SHA_DIGEST_LENGTH + pad + 1);\n             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));\n             inp_len &= mask;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            ret &= constant_time_ge(maxpad, pad);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16870",
        "func_name": "wolfSSL/wolfssl/Hmac_UpdateFinal_CT",
        "description": "It was found that wolfssl before 3.15.7 is vulnerable to a new variant of the Bleichenbacher attack to perform downgrade attacks against TLS. This may lead to leakage of sensible data.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/ab03f9291b040269ae21d33b9f01529ed8311728",
        "commit_title": "Make RsaUnPad constant time when Block Type 2 message",
        "commit_text": "",
        "func_before": "static int Hmac_UpdateFinal_CT(Hmac* hmac, byte* digest, const byte* in,\n                               word32 sz, byte* header)\n{\n    byte lenBytes[8];\n    int  i, j, k;\n    int  blockBits, blockMask;\n    int  realLen, lastBlockLen, macLen, extraLen, eocIndex;\n    int  blocks, safeBlocks, lenBlock, eocBlock;\n    int  maxLen;\n    int  blockSz, padSz;\n    int  ret;\n    byte extraBlock;\n\n    switch (hmac->macType) {\n    #ifndef NO_SHA\n        case WC_SHA:\n            blockSz = WC_SHA_BLOCK_SIZE;\n            blockBits = 6;\n            macLen = WC_SHA_DIGEST_SIZE;\n            padSz = WC_SHA_BLOCK_SIZE - WC_SHA_PAD_SIZE + 1;\n            break;\n    #endif /* !NO_SHA */\n\n    #ifndef NO_SHA256\n        case WC_SHA256:\n            blockSz = WC_SHA256_BLOCK_SIZE;\n            blockBits = 6;\n            macLen = WC_SHA256_DIGEST_SIZE;\n            padSz = WC_SHA256_BLOCK_SIZE - WC_SHA256_PAD_SIZE + 1;\n            break;\n    #endif /* !NO_SHA256 */\n\n    #ifdef WOLFSSL_SHA384\n        case WC_SHA384:\n            blockSz = WC_SHA384_BLOCK_SIZE;\n            blockBits = 7;\n            macLen = WC_SHA384_DIGEST_SIZE;\n            padSz = WC_SHA384_BLOCK_SIZE - WC_SHA384_PAD_SIZE + 1;\n            break;\n    #endif /* WOLFSSL_SHA384 */\n\n    #ifdef WOLFSSL_SHA512\n        case WC_SHA512:\n            blockSz = WC_SHA512_BLOCK_SIZE;\n            blockBits = 7;\n            macLen = WC_SHA512_DIGEST_SIZE;\n            padSz = WC_SHA512_BLOCK_SIZE - WC_SHA512_PAD_SIZE + 1;\n            break;\n    #endif /* WOLFSSL_SHA512 */\n\n        default:\n            return BAD_FUNC_ARG;\n    }\n    blockMask = blockSz - 1;\n\n    /* Size of data to HMAC if padding length byte is zero. */\n    maxLen = WOLFSSL_TLS_HMAC_INNER_SZ + sz - 1 - macLen;\n    /* Complete data (including padding) has block for EOC and/or length. */\n    extraBlock = ctSetLTE((maxLen + padSz) & blockMask, padSz);\n    /* Total number of blocks for data including padding. */\n    blocks = ((maxLen + blockSz - 1) >> blockBits) + extraBlock;\n    /* Up to last 6 blocks can be hashed safely. */\n    safeBlocks = blocks - 6;\n\n    /* Length of message data. */\n    realLen = maxLen - in[sz - 1];\n    /* Number of message bytes in last block. */\n    lastBlockLen = realLen & blockMask;\n    /* Number of padding bytes in last block. */\n    extraLen = ((blockSz * 2 - padSz - lastBlockLen) & blockMask) + 1;\n    /* Number of blocks to create for hash. */\n    lenBlock = (realLen + extraLen) >> blockBits;\n    /* Block containing EOC byte. */\n    eocBlock = realLen >> blockBits;\n    /* Index of EOC byte in block. */\n    eocIndex = realLen & blockMask;\n\n    /* Add length of hmac's ipad to total length. */\n    realLen += blockSz;\n    /* Length as bits - 8 bytes bigendian. */\n    c32toa(realLen >> ((sizeof(word32) * 8) - 3), lenBytes);\n    c32toa(realLen << 3, lenBytes + sizeof(word32));\n\n    ret = Hmac_HashUpdate(hmac, (unsigned char*)hmac->ipad, blockSz);\n    if (ret != 0)\n        return ret;\n\n    XMEMSET(hmac->innerHash, 0, macLen);\n\n    if (safeBlocks > 0) {\n        ret = Hmac_HashUpdate(hmac, header, WOLFSSL_TLS_HMAC_INNER_SZ);\n        if (ret != 0)\n            return ret;\n        ret = Hmac_HashUpdate(hmac, in, safeBlocks * blockSz -\n                                                     WOLFSSL_TLS_HMAC_INNER_SZ);\n        if (ret != 0)\n            return ret;\n    }\n    else\n        safeBlocks = 0;\n\n    XMEMSET(digest, 0, macLen);\n    k = safeBlocks * blockSz;\n    for (i = safeBlocks; i < blocks; i++) {\n        unsigned char hashBlock[WC_MAX_BLOCK_SIZE];\n        unsigned char isEocBlock = ctMaskEq(i, eocBlock);\n        unsigned char isOutBlock = ctMaskEq(i, lenBlock);\n\n        for (j = 0; j < blockSz; j++, k++) {\n            unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock;\n            unsigned char pastEoc = ctMaskGT(j, eocIndex) & isEocBlock;\n            unsigned char b = 0;\n\n            if (k < WOLFSSL_TLS_HMAC_INNER_SZ)\n                b = header[k];\n            else if (k < maxLen)\n                b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ];\n\n            b = ctMaskSel(atEoc, b, 0x80);\n            b &= (unsigned char)~(word32)pastEoc;\n            b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock;\n\n            if (j >= blockSz - 8) {\n                b = ctMaskSel(isOutBlock, b, lenBytes[j - (blockSz - 8)]);\n            }\n\n            hashBlock[j] = b;\n        }\n\n        ret = Hmac_HashUpdate(hmac, hashBlock, blockSz);\n        if (ret != 0)\n            return ret;\n        ret = Hmac_HashFinalRaw(hmac, hashBlock);\n        if (ret != 0)\n            return ret;\n        for (j = 0; j < macLen; j++)\n            ((unsigned char*)hmac->innerHash)[j] |= hashBlock[j] & isOutBlock;\n    }\n\n    ret = Hmac_OuterHash(hmac, digest);\n\n    return ret;\n}",
        "func": "static int Hmac_UpdateFinal_CT(Hmac* hmac, byte* digest, const byte* in,\n                               word32 sz, byte* header)\n{\n    byte lenBytes[8];\n    int  i, j, k;\n    int  blockBits, blockMask;\n    int  realLen, lastBlockLen, macLen, extraLen, eocIndex;\n    int  blocks, safeBlocks, lenBlock, eocBlock;\n    int  maxLen;\n    int  blockSz, padSz;\n    int  ret;\n    byte extraBlock;\n\n    switch (hmac->macType) {\n    #ifndef NO_SHA\n        case WC_SHA:\n            blockSz = WC_SHA_BLOCK_SIZE;\n            blockBits = 6;\n            macLen = WC_SHA_DIGEST_SIZE;\n            padSz = WC_SHA_BLOCK_SIZE - WC_SHA_PAD_SIZE + 1;\n            break;\n    #endif /* !NO_SHA */\n\n    #ifndef NO_SHA256\n        case WC_SHA256:\n            blockSz = WC_SHA256_BLOCK_SIZE;\n            blockBits = 6;\n            macLen = WC_SHA256_DIGEST_SIZE;\n            padSz = WC_SHA256_BLOCK_SIZE - WC_SHA256_PAD_SIZE + 1;\n            break;\n    #endif /* !NO_SHA256 */\n\n    #ifdef WOLFSSL_SHA384\n        case WC_SHA384:\n            blockSz = WC_SHA384_BLOCK_SIZE;\n            blockBits = 7;\n            macLen = WC_SHA384_DIGEST_SIZE;\n            padSz = WC_SHA384_BLOCK_SIZE - WC_SHA384_PAD_SIZE + 1;\n            break;\n    #endif /* WOLFSSL_SHA384 */\n\n    #ifdef WOLFSSL_SHA512\n        case WC_SHA512:\n            blockSz = WC_SHA512_BLOCK_SIZE;\n            blockBits = 7;\n            macLen = WC_SHA512_DIGEST_SIZE;\n            padSz = WC_SHA512_BLOCK_SIZE - WC_SHA512_PAD_SIZE + 1;\n            break;\n    #endif /* WOLFSSL_SHA512 */\n\n        default:\n            return BAD_FUNC_ARG;\n    }\n    blockMask = blockSz - 1;\n\n    /* Size of data to HMAC if padding length byte is zero. */\n    maxLen = WOLFSSL_TLS_HMAC_INNER_SZ + sz - 1 - macLen;\n    /* Complete data (including padding) has block for EOC and/or length. */\n    extraBlock = ctSetLTE((maxLen + padSz) & blockMask, padSz);\n    /* Total number of blocks for data including padding. */\n    blocks = ((maxLen + blockSz - 1) >> blockBits) + extraBlock;\n    /* Up to last 6 blocks can be hashed safely. */\n    safeBlocks = blocks - 6;\n\n    /* Length of message data. */\n    realLen = maxLen - in[sz - 1];\n    /* Number of message bytes in last block. */\n    lastBlockLen = realLen & blockMask;\n    /* Number of padding bytes in last block. */\n    extraLen = ((blockSz * 2 - padSz - lastBlockLen) & blockMask) + 1;\n    /* Number of blocks to create for hash. */\n    lenBlock = (realLen + extraLen) >> blockBits;\n    /* Block containing EOC byte. */\n    eocBlock = realLen >> blockBits;\n    /* Index of EOC byte in block. */\n    eocIndex = realLen & blockMask;\n\n    /* Add length of hmac's ipad to total length. */\n    realLen += blockSz;\n    /* Length as bits - 8 bytes bigendian. */\n    c32toa(realLen >> ((sizeof(word32) * 8) - 3), lenBytes);\n    c32toa(realLen << 3, lenBytes + sizeof(word32));\n\n    ret = Hmac_HashUpdate(hmac, (unsigned char*)hmac->ipad, blockSz);\n    if (ret != 0)\n        return ret;\n\n    XMEMSET(hmac->innerHash, 0, macLen);\n\n    if (safeBlocks > 0) {\n        ret = Hmac_HashUpdate(hmac, header, WOLFSSL_TLS_HMAC_INNER_SZ);\n        if (ret != 0)\n            return ret;\n        ret = Hmac_HashUpdate(hmac, in, safeBlocks * blockSz -\n                                                     WOLFSSL_TLS_HMAC_INNER_SZ);\n        if (ret != 0)\n            return ret;\n    }\n    else\n        safeBlocks = 0;\n\n    XMEMSET(digest, 0, macLen);\n    k = safeBlocks * blockSz;\n    for (i = safeBlocks; i < blocks; i++) {\n        unsigned char hashBlock[WC_MAX_BLOCK_SIZE];\n        unsigned char isEocBlock = ctMaskEq(i, eocBlock);\n        unsigned char isOutBlock = ctMaskEq(i, lenBlock);\n\n        for (j = 0; j < blockSz; j++, k++) {\n            unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock;\n            unsigned char pastEoc = ctMaskGT(j, eocIndex) & isEocBlock;\n            unsigned char b = 0;\n\n            if (k < WOLFSSL_TLS_HMAC_INNER_SZ)\n                b = header[k];\n            else if (k < maxLen)\n                b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ];\n\n            b = ctMaskSel(atEoc, 0x80, b);\n            b &= (unsigned char)~(word32)pastEoc;\n            b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock;\n\n            if (j >= blockSz - 8) {\n                b = ctMaskSel(isOutBlock, lenBytes[j - (blockSz - 8)], b);\n            }\n\n            hashBlock[j] = b;\n        }\n\n        ret = Hmac_HashUpdate(hmac, hashBlock, blockSz);\n        if (ret != 0)\n            return ret;\n        ret = Hmac_HashFinalRaw(hmac, hashBlock);\n        if (ret != 0)\n            return ret;\n        for (j = 0; j < macLen; j++)\n            ((unsigned char*)hmac->innerHash)[j] |= hashBlock[j] & isOutBlock;\n    }\n\n    ret = Hmac_OuterHash(hmac, digest);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -116,12 +116,12 @@\n             else if (k < maxLen)\n                 b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ];\n \n-            b = ctMaskSel(atEoc, b, 0x80);\n+            b = ctMaskSel(atEoc, 0x80, b);\n             b &= (unsigned char)~(word32)pastEoc;\n             b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock;\n \n             if (j >= blockSz - 8) {\n-                b = ctMaskSel(isOutBlock, b, lenBytes[j - (blockSz - 8)]);\n+                b = ctMaskSel(isOutBlock, lenBytes[j - (blockSz - 8)], b);\n             }\n \n             hashBlock[j] = b;",
        "diff_line_info": {
            "deleted_lines": [
                "            b = ctMaskSel(atEoc, b, 0x80);",
                "                b = ctMaskSel(isOutBlock, b, lenBytes[j - (blockSz - 8)]);"
            ],
            "added_lines": [
                "            b = ctMaskSel(atEoc, 0x80, b);",
                "                b = ctMaskSel(isOutBlock, lenBytes[j - (blockSz - 8)], b);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7948",
        "func_name": "chromium/AppCacheUpdateJob::URLFetcher::OnResponseStarted",
        "description": "The AppCacheUpdateJob::URLFetcher::OnResponseStarted function in content/browser/appcache/appcache_update_job.cc in Google Chrome before 40.0.2214.91 proceeds with AppCache caching for SSL sessions even if there is an X.509 certificate error, which allows man-in-the-middle attackers to spoof HTML5 application content via a crafted certificate.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c65cc9c7b1afe7f53bb18707bc711dc32ddffad0",
        "commit_title": "Do not AppCache responses with SSL cert errors unless running with the --ignore-certificate-errors flag.",
        "commit_text": "   ",
        "func_before": "void AppCacheUpdateJob::URLFetcher::OnResponseStarted(\n    net::URLRequest *request) {\n  DCHECK(request == request_);\n  int response_code = -1;\n  if (request->status().is_success()) {\n    response_code = request->GetResponseCode();\n    job_->MadeProgress();\n  }\n\n  if ((response_code / 100) != 2) {\n    if (response_code > 0)\n      result_ = SERVER_ERROR;\n    else\n      result_ = NETWORK_ERROR;\n    OnResponseCompleted();\n    return;\n  }\n\n  if (url_.SchemeIsSecure()) {\n    // Do not cache content with cert errors.\n    // Also, we willfully violate the HTML5 spec at this point in order\n    // to support the appcaching of cross-origin HTTPS resources.\n    // We've opted for a milder constraint and allow caching unless\n    // the resource has a \"no-store\" header. A spec change has been\n    // requested on the whatwg list.\n    // See http://code.google.com/p/chromium/issues/detail?id=69594\n    // TODO(michaeln): Consider doing this for cross-origin HTTP too.\n    if (net::IsCertStatusError(request->ssl_info().cert_status) ||\n        (url_.GetOrigin() != job_->manifest_url_.GetOrigin() &&\n            request->response_headers()->\n                HasHeaderValue(\"cache-control\", \"no-store\"))) {\n      DCHECK_EQ(-1, redirect_response_code_);\n      request->Cancel();\n      result_ = SECURITY_ERROR;\n      OnResponseCompleted();\n      return;\n    }\n  }\n\n  // Write response info to storage for URL fetches. Wait for async write\n  // completion before reading any response data.\n  if (fetch_type_ == URL_FETCH || fetch_type_ == MASTER_ENTRY_FETCH) {\n    response_writer_.reset(job_->CreateResponseWriter());\n    scoped_refptr<HttpResponseInfoIOBuffer> io_buffer(\n        new HttpResponseInfoIOBuffer(\n            new net::HttpResponseInfo(request->response_info())));\n    response_writer_->WriteInfo(\n        io_buffer.get(),\n        base::Bind(&URLFetcher::OnWriteComplete, base::Unretained(this)));\n  } else {\n    ReadResponseData();\n  }\n}",
        "func": "void AppCacheUpdateJob::URLFetcher::OnResponseStarted(\n    net::URLRequest *request) {\n  DCHECK(request == request_);\n  int response_code = -1;\n  if (request->status().is_success()) {\n    response_code = request->GetResponseCode();\n    job_->MadeProgress();\n  }\n\n  if ((response_code / 100) != 2) {\n    if (response_code > 0)\n      result_ = SERVER_ERROR;\n    else\n      result_ = NETWORK_ERROR;\n    OnResponseCompleted();\n    return;\n  }\n\n  if (url_.SchemeIsSecure()) {\n    // Do not cache content with cert errors.\n    // Also, we willfully violate the HTML5 spec at this point in order\n    // to support the appcaching of cross-origin HTTPS resources.\n    // We've opted for a milder constraint and allow caching unless\n    // the resource has a \"no-store\" header. A spec change has been\n    // requested on the whatwg list.\n    // See http://code.google.com/p/chromium/issues/detail?id=69594\n    // TODO(michaeln): Consider doing this for cross-origin HTTP too.\n    const net::HttpNetworkSession::Params* session_params =\n        request->context()->GetNetworkSessionParams();\n    bool ignore_cert_errors = session_params &&\n                              session_params->ignore_certificate_errors;\n    if ((net::IsCertStatusError(request->ssl_info().cert_status) &&\n            !ignore_cert_errors) ||\n        (url_.GetOrigin() != job_->manifest_url_.GetOrigin() &&\n            request->response_headers()->\n                HasHeaderValue(\"cache-control\", \"no-store\"))) {\n      DCHECK_EQ(-1, redirect_response_code_);\n      request->Cancel();\n      result_ = SECURITY_ERROR;\n      OnResponseCompleted();\n      return;\n    }\n  }\n\n  // Write response info to storage for URL fetches. Wait for async write\n  // completion before reading any response data.\n  if (fetch_type_ == URL_FETCH || fetch_type_ == MASTER_ENTRY_FETCH) {\n    response_writer_.reset(job_->CreateResponseWriter());\n    scoped_refptr<HttpResponseInfoIOBuffer> io_buffer(\n        new HttpResponseInfoIOBuffer(\n            new net::HttpResponseInfo(request->response_info())));\n    response_writer_->WriteInfo(\n        io_buffer.get(),\n        base::Bind(&URLFetcher::OnWriteComplete, base::Unretained(this)));\n  } else {\n    ReadResponseData();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,12 @@\n     // requested on the whatwg list.\n     // See http://code.google.com/p/chromium/issues/detail?id=69594\n     // TODO(michaeln): Consider doing this for cross-origin HTTP too.\n-    if (net::IsCertStatusError(request->ssl_info().cert_status) ||\n+    const net::HttpNetworkSession::Params* session_params =\n+        request->context()->GetNetworkSessionParams();\n+    bool ignore_cert_errors = session_params &&\n+                              session_params->ignore_certificate_errors;\n+    if ((net::IsCertStatusError(request->ssl_info().cert_status) &&\n+            !ignore_cert_errors) ||\n         (url_.GetOrigin() != job_->manifest_url_.GetOrigin() &&\n             request->response_headers()->\n                 HasHeaderValue(\"cache-control\", \"no-store\"))) {",
        "diff_line_info": {
            "deleted_lines": [
                "    if (net::IsCertStatusError(request->ssl_info().cert_status) ||"
            ],
            "added_lines": [
                "    const net::HttpNetworkSession::Params* session_params =",
                "        request->context()->GetNetworkSessionParams();",
                "    bool ignore_cert_errors = session_params &&",
                "                              session_params->ignore_certificate_errors;",
                "    if ((net::IsCertStatusError(request->ssl_info().cert_status) &&",
                "            !ignore_cert_errors) ||"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7948",
        "func_name": "chromium/AppCacheUpdateJob::URLFetcher::OnResponseStarted",
        "description": "The AppCacheUpdateJob::URLFetcher::OnResponseStarted function in content/browser/appcache/appcache_update_job.cc in Google Chrome before 40.0.2214.91 proceeds with AppCache caching for SSL sessions even if there is an X.509 certificate error, which allows man-in-the-middle attackers to spoof HTML5 application content via a crafted certificate.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/3ec982d993b769efc893d4f3a0fa28eea95b69d0",
        "commit_title": "Do not AppCache responses with SSL cert errors.",
        "commit_text": "   ",
        "func_before": "void AppCacheUpdateJob::URLFetcher::OnResponseStarted(\n    net::URLRequest *request) {\n  DCHECK(request == request_);\n  int response_code = -1;\n  if (request->status().is_success()) {\n    response_code = request->GetResponseCode();\n    job_->MadeProgress();\n  }\n  if ((response_code / 100) == 2) {\n\n    // See http://code.google.com/p/chromium/issues/detail?id=69594\n    // We willfully violate the HTML5 spec at this point in order\n    // to support the appcaching of cross-origin HTTPS resources.\n    // We've opted for a milder constraint and allow caching unless\n    // the resource has a \"no-store\" header. A spec change has been\n    // requested on the whatwg list.\n    // TODO(michaeln): Consider doing this for cross-origin HTTP resources too.\n    if (url_.SchemeIsSecure() &&\n        url_.GetOrigin() != job_->manifest_url_.GetOrigin()) {\n      if (request->response_headers()->\n              HasHeaderValue(\"cache-control\", \"no-store\")) {\n        DCHECK_EQ(-1, redirect_response_code_);\n        request->Cancel();\n        result_ = SERVER_ERROR;  // Not the best match?\n        OnResponseCompleted();\n        return;\n      }\n    }\n\n    // Write response info to storage for URL fetches. Wait for async write\n    // completion before reading any response data.\n    if (fetch_type_ == URL_FETCH || fetch_type_ == MASTER_ENTRY_FETCH) {\n      response_writer_.reset(job_->CreateResponseWriter());\n      scoped_refptr<HttpResponseInfoIOBuffer> io_buffer(\n          new HttpResponseInfoIOBuffer(\n              new net::HttpResponseInfo(request->response_info())));\n      response_writer_->WriteInfo(\n          io_buffer.get(),\n          base::Bind(&URLFetcher::OnWriteComplete, base::Unretained(this)));\n    } else {\n      ReadResponseData();\n    }\n  } else {\n    if (response_code > 0)\n      result_ = SERVER_ERROR;\n    else\n      result_ = NETWORK_ERROR;\n    OnResponseCompleted();\n  }\n}",
        "func": "void AppCacheUpdateJob::URLFetcher::OnResponseStarted(\n    net::URLRequest *request) {\n  DCHECK(request == request_);\n  int response_code = -1;\n  if (request->status().is_success()) {\n    response_code = request->GetResponseCode();\n    job_->MadeProgress();\n  }\n\n  if ((response_code / 100) != 2) {\n    if (response_code > 0)\n      result_ = SERVER_ERROR;\n    else\n      result_ = NETWORK_ERROR;\n    OnResponseCompleted();\n    return;\n  }\n\n  if (url_.SchemeIsSecure()) {\n    // Do not cache content with cert errors.\n    // Also, we willfully violate the HTML5 spec at this point in order\n    // to support the appcaching of cross-origin HTTPS resources.\n    // We've opted for a milder constraint and allow caching unless\n    // the resource has a \"no-store\" header. A spec change has been\n    // requested on the whatwg list.\n    // See http://code.google.com/p/chromium/issues/detail?id=69594\n    // TODO(michaeln): Consider doing this for cross-origin HTTP too.\n    if (net::IsCertStatusError(request->ssl_info().cert_status) ||\n        (url_.GetOrigin() != job_->manifest_url_.GetOrigin() &&\n            request->response_headers()->\n                HasHeaderValue(\"cache-control\", \"no-store\"))) {\n      DCHECK_EQ(-1, redirect_response_code_);\n      request->Cancel();\n      result_ = SECURITY_ERROR;\n      OnResponseCompleted();\n      return;\n    }\n  }\n\n  // Write response info to storage for URL fetches. Wait for async write\n  // completion before reading any response data.\n  if (fetch_type_ == URL_FETCH || fetch_type_ == MASTER_ENTRY_FETCH) {\n    response_writer_.reset(job_->CreateResponseWriter());\n    scoped_refptr<HttpResponseInfoIOBuffer> io_buffer(\n        new HttpResponseInfoIOBuffer(\n            new net::HttpResponseInfo(request->response_info())));\n    response_writer_->WriteInfo(\n        io_buffer.get(),\n        base::Bind(&URLFetcher::OnWriteComplete, base::Unretained(this)));\n  } else {\n    ReadResponseData();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,45 +6,48 @@\n     response_code = request->GetResponseCode();\n     job_->MadeProgress();\n   }\n-  if ((response_code / 100) == 2) {\n \n-    // See http://code.google.com/p/chromium/issues/detail?id=69594\n-    // We willfully violate the HTML5 spec at this point in order\n-    // to support the appcaching of cross-origin HTTPS resources.\n-    // We've opted for a milder constraint and allow caching unless\n-    // the resource has a \"no-store\" header. A spec change has been\n-    // requested on the whatwg list.\n-    // TODO(michaeln): Consider doing this for cross-origin HTTP resources too.\n-    if (url_.SchemeIsSecure() &&\n-        url_.GetOrigin() != job_->manifest_url_.GetOrigin()) {\n-      if (request->response_headers()->\n-              HasHeaderValue(\"cache-control\", \"no-store\")) {\n-        DCHECK_EQ(-1, redirect_response_code_);\n-        request->Cancel();\n-        result_ = SERVER_ERROR;  // Not the best match?\n-        OnResponseCompleted();\n-        return;\n-      }\n-    }\n-\n-    // Write response info to storage for URL fetches. Wait for async write\n-    // completion before reading any response data.\n-    if (fetch_type_ == URL_FETCH || fetch_type_ == MASTER_ENTRY_FETCH) {\n-      response_writer_.reset(job_->CreateResponseWriter());\n-      scoped_refptr<HttpResponseInfoIOBuffer> io_buffer(\n-          new HttpResponseInfoIOBuffer(\n-              new net::HttpResponseInfo(request->response_info())));\n-      response_writer_->WriteInfo(\n-          io_buffer.get(),\n-          base::Bind(&URLFetcher::OnWriteComplete, base::Unretained(this)));\n-    } else {\n-      ReadResponseData();\n-    }\n-  } else {\n+  if ((response_code / 100) != 2) {\n     if (response_code > 0)\n       result_ = SERVER_ERROR;\n     else\n       result_ = NETWORK_ERROR;\n     OnResponseCompleted();\n+    return;\n+  }\n+\n+  if (url_.SchemeIsSecure()) {\n+    // Do not cache content with cert errors.\n+    // Also, we willfully violate the HTML5 spec at this point in order\n+    // to support the appcaching of cross-origin HTTPS resources.\n+    // We've opted for a milder constraint and allow caching unless\n+    // the resource has a \"no-store\" header. A spec change has been\n+    // requested on the whatwg list.\n+    // See http://code.google.com/p/chromium/issues/detail?id=69594\n+    // TODO(michaeln): Consider doing this for cross-origin HTTP too.\n+    if (net::IsCertStatusError(request->ssl_info().cert_status) ||\n+        (url_.GetOrigin() != job_->manifest_url_.GetOrigin() &&\n+            request->response_headers()->\n+                HasHeaderValue(\"cache-control\", \"no-store\"))) {\n+      DCHECK_EQ(-1, redirect_response_code_);\n+      request->Cancel();\n+      result_ = SECURITY_ERROR;\n+      OnResponseCompleted();\n+      return;\n+    }\n+  }\n+\n+  // Write response info to storage for URL fetches. Wait for async write\n+  // completion before reading any response data.\n+  if (fetch_type_ == URL_FETCH || fetch_type_ == MASTER_ENTRY_FETCH) {\n+    response_writer_.reset(job_->CreateResponseWriter());\n+    scoped_refptr<HttpResponseInfoIOBuffer> io_buffer(\n+        new HttpResponseInfoIOBuffer(\n+            new net::HttpResponseInfo(request->response_info())));\n+    response_writer_->WriteInfo(\n+        io_buffer.get(),\n+        base::Bind(&URLFetcher::OnWriteComplete, base::Unretained(this)));\n+  } else {\n+    ReadResponseData();\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if ((response_code / 100) == 2) {",
                "    // See http://code.google.com/p/chromium/issues/detail?id=69594",
                "    // We willfully violate the HTML5 spec at this point in order",
                "    // to support the appcaching of cross-origin HTTPS resources.",
                "    // We've opted for a milder constraint and allow caching unless",
                "    // the resource has a \"no-store\" header. A spec change has been",
                "    // requested on the whatwg list.",
                "    // TODO(michaeln): Consider doing this for cross-origin HTTP resources too.",
                "    if (url_.SchemeIsSecure() &&",
                "        url_.GetOrigin() != job_->manifest_url_.GetOrigin()) {",
                "      if (request->response_headers()->",
                "              HasHeaderValue(\"cache-control\", \"no-store\")) {",
                "        DCHECK_EQ(-1, redirect_response_code_);",
                "        request->Cancel();",
                "        result_ = SERVER_ERROR;  // Not the best match?",
                "        OnResponseCompleted();",
                "        return;",
                "      }",
                "    }",
                "",
                "    // Write response info to storage for URL fetches. Wait for async write",
                "    // completion before reading any response data.",
                "    if (fetch_type_ == URL_FETCH || fetch_type_ == MASTER_ENTRY_FETCH) {",
                "      response_writer_.reset(job_->CreateResponseWriter());",
                "      scoped_refptr<HttpResponseInfoIOBuffer> io_buffer(",
                "          new HttpResponseInfoIOBuffer(",
                "              new net::HttpResponseInfo(request->response_info())));",
                "      response_writer_->WriteInfo(",
                "          io_buffer.get(),",
                "          base::Bind(&URLFetcher::OnWriteComplete, base::Unretained(this)));",
                "    } else {",
                "      ReadResponseData();",
                "    }",
                "  } else {"
            ],
            "added_lines": [
                "  if ((response_code / 100) != 2) {",
                "    return;",
                "  }",
                "",
                "  if (url_.SchemeIsSecure()) {",
                "    // Do not cache content with cert errors.",
                "    // Also, we willfully violate the HTML5 spec at this point in order",
                "    // to support the appcaching of cross-origin HTTPS resources.",
                "    // We've opted for a milder constraint and allow caching unless",
                "    // the resource has a \"no-store\" header. A spec change has been",
                "    // requested on the whatwg list.",
                "    // See http://code.google.com/p/chromium/issues/detail?id=69594",
                "    // TODO(michaeln): Consider doing this for cross-origin HTTP too.",
                "    if (net::IsCertStatusError(request->ssl_info().cert_status) ||",
                "        (url_.GetOrigin() != job_->manifest_url_.GetOrigin() &&",
                "            request->response_headers()->",
                "                HasHeaderValue(\"cache-control\", \"no-store\"))) {",
                "      DCHECK_EQ(-1, redirect_response_code_);",
                "      request->Cancel();",
                "      result_ = SECURITY_ERROR;",
                "      OnResponseCompleted();",
                "      return;",
                "    }",
                "  }",
                "",
                "  // Write response info to storage for URL fetches. Wait for async write",
                "  // completion before reading any response data.",
                "  if (fetch_type_ == URL_FETCH || fetch_type_ == MASTER_ENTRY_FETCH) {",
                "    response_writer_.reset(job_->CreateResponseWriter());",
                "    scoped_refptr<HttpResponseInfoIOBuffer> io_buffer(",
                "        new HttpResponseInfoIOBuffer(",
                "            new net::HttpResponseInfo(request->response_info())));",
                "    response_writer_->WriteInfo(",
                "        io_buffer.get(),",
                "        base::Bind(&URLFetcher::OnWriteComplete, base::Unretained(this)));",
                "  } else {",
                "    ReadResponseData();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0285",
        "func_name": "openssl/ssl3_client_hello",
        "description": "The ssl3_client_hello function in s3_clnt.c in OpenSSL 1.0.2 before 1.0.2a does not ensure that the PRNG is seeded before proceeding with a handshake, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by sniffing the network and then conducting a brute-force attack.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=e1b568dd2462f7cacf98f3d117936c34e2849a6b",
        "commit_title": "",
        "commit_text": "Prevent handshake with unseeded PRNG  Fix security issue where under certain conditions a client can complete a handshake with an unseeded PRNG. The conditions are: - Client is on a platform where the PRNG has not been seeded, and the user has not seeded manually - A protocol specific client method version has been used (i.e. not SSL_client_methodv23) - A ciphersuite is used that does not require additional random data from the PRNG beyond the initial ClientHello client random (e.g. PSK-RC4-SHA)  If the handshake succeeds then the client random that has been used will have been generated from a PRNG with insufficient entropy and therefore the output may be predictable.  For example using the following command with an unseeded openssl will succeed on an unpatched platform:  openssl s_client -psk 1a2b3c4d -tls1_2 -cipher PSK-RC4-SHA  CVE-2015-0285  ",
        "func_before": "int ssl3_client_hello(SSL *s)\n{\n    unsigned char *buf;\n    unsigned char *p, *d;\n    int i;\n    unsigned long l;\n    int al = 0;\n#ifndef OPENSSL_NO_COMP\n    int j;\n    SSL_COMP *comp;\n#endif\n\n    buf = (unsigned char *)s->init_buf->data;\n    if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {\n        SSL_SESSION *sess = s->session;\n        if ((sess == NULL) ||\n            (sess->ssl_version != s->version) ||\n            !sess->session_id_length || (sess->not_resumable)) {\n            if (!ssl_get_new_session(s, 0))\n                goto err;\n        }\n        if (s->method->version == DTLS_ANY_VERSION) {\n            /* Determine which DTLS version to use */\n            int options = s->options;\n            /* If DTLS 1.2 disabled correct the version number */\n            if (options & SSL_OP_NO_DTLSv1_2) {\n                if (tls1_suiteb(s)) {\n                    SSLerr(SSL_F_SSL3_CLIENT_HELLO,\n                           SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n                    goto err;\n                }\n                /*\n                 * Disabling all versions is silly: return an error.\n                 */\n                if (options & SSL_OP_NO_DTLSv1) {\n                    SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_WRONG_SSL_VERSION);\n                    goto err;\n                }\n                /*\n                 * Update method so we don't use any DTLS 1.2 features.\n                 */\n                s->method = DTLSv1_client_method();\n                s->version = DTLS1_VERSION;\n            } else {\n                /*\n                 * We only support one version: update method\n                 */\n                if (options & SSL_OP_NO_DTLSv1)\n                    s->method = DTLSv1_2_client_method();\n                s->version = DTLS1_2_VERSION;\n            }\n            s->client_version = s->version;\n        }\n        /* else use the pre-loaded session */\n\n        p = s->s3->client_random;\n\n        /*\n         * for DTLS if client_random is initialized, reuse it, we are\n         * required to use same upon reply to HelloVerify\n         */\n        if (SSL_IS_DTLS(s)) {\n            size_t idx;\n            i = 1;\n            for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {\n                if (p[idx]) {\n                    i = 0;\n                    break;\n                }\n            }\n        } else\n            i = 1;\n\n        if (i)\n            ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random));\n\n        /* Do the message type and length last */\n        d = p = ssl_handshake_start(s);\n\n        /*-\n         * version indicates the negotiated version: for example from\n         * an SSLv2/v3 compatible client hello). The client_version\n         * field is the maximum version we permit and it is also\n         * used in RSA encrypted premaster secrets. Some servers can\n         * choke if we initially report a higher version then\n         * renegotiate to a lower one in the premaster secret. This\n         * didn't happen with TLS 1.0 as most servers supported it\n         * but it can with TLS 1.1 or later if the server only supports\n         * 1.0.\n         *\n         * Possible scenario with previous logic:\n         *      1. Client hello indicates TLS 1.2\n         *      2. Server hello says TLS 1.0\n         *      3. RSA encrypted premaster secret uses 1.2.\n         *      4. Handhaked proceeds using TLS 1.0.\n         *      5. Server sends hello request to renegotiate.\n         *      6. Client hello indicates TLS v1.0 as we now\n         *         know that is maximum server supports.\n         *      7. Server chokes on RSA encrypted premaster secret\n         *         containing version 1.0.\n         *\n         * For interoperability it should be OK to always use the\n         * maximum version we support in client hello and then rely\n         * on the checking of version to ensure the servers isn't\n         * being inconsistent: for example initially negotiating with\n         * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n         * client_version in client hello and not resetting it to\n         * the negotiated version.\n         */\n        *(p++) = s->client_version >> 8;\n        *(p++) = s->client_version & 0xff;\n\n        /* Random stuff */\n        memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);\n        p += SSL3_RANDOM_SIZE;\n\n        /* Session ID */\n        if (s->new_session)\n            i = 0;\n        else\n            i = s->session->session_id_length;\n        *(p++) = i;\n        if (i != 0) {\n            if (i > (int)sizeof(s->session->session_id)) {\n                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            memcpy(p, s->session->session_id, i);\n            p += i;\n        }\n\n        /* cookie stuff for DTLS */\n        if (SSL_IS_DTLS(s)) {\n            if (s->d1->cookie_len > sizeof(s->d1->cookie)) {\n                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            *(p++) = s->d1->cookie_len;\n            memcpy(p, s->d1->cookie, s->d1->cookie_len);\n            p += s->d1->cookie_len;\n        }\n\n        /* Ciphers supported */\n        i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);\n            goto err;\n        }\n#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH\n        /*\n         * Some servers hang if client hello > 256 bytes as hack workaround\n         * chop number of supported ciphers to keep it well below this if we\n         * use TLS v1.2\n         */\n        if (TLS1_get_version(s) >= TLS1_2_VERSION\n            && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)\n            i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;\n#endif\n        s2n(i, p);\n        p += i;\n\n        /* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n        *(p++) = 1;\n#else\n\n        if (!ssl_allow_compression(s) || !s->ctx->comp_methods)\n            j = 0;\n        else\n            j = sk_SSL_COMP_num(s->ctx->comp_methods);\n        *(p++) = 1 + j;\n        for (i = 0; i < j; i++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);\n            *(p++) = comp->id;\n        }\n#endif\n        *(p++) = 0;             /* Add the NULL method */\n\n#ifndef OPENSSL_NO_TLSEXT\n        /* TLS extensions */\n        if (ssl_prepare_clienthello_tlsext(s) <= 0) {\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n            goto err;\n        }\n        if ((p =\n             ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,\n                                        &al)) == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, al);\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n#endif\n\n        l = p - d;\n        ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);\n        s->state = SSL3_ST_CW_CLNT_HELLO_B;\n    }\n\n    /* SSL3_ST_CW_CLNT_HELLO_B */\n    return ssl_do_write(s);\n err:\n    return (-1);\n}",
        "func": "int ssl3_client_hello(SSL *s)\n{\n    unsigned char *buf;\n    unsigned char *p, *d;\n    int i;\n    unsigned long l;\n    int al = 0;\n#ifndef OPENSSL_NO_COMP\n    int j;\n    SSL_COMP *comp;\n#endif\n\n    buf = (unsigned char *)s->init_buf->data;\n    if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {\n        SSL_SESSION *sess = s->session;\n        if ((sess == NULL) ||\n            (sess->ssl_version != s->version) ||\n            !sess->session_id_length || (sess->not_resumable)) {\n            if (!ssl_get_new_session(s, 0))\n                goto err;\n        }\n        if (s->method->version == DTLS_ANY_VERSION) {\n            /* Determine which DTLS version to use */\n            int options = s->options;\n            /* If DTLS 1.2 disabled correct the version number */\n            if (options & SSL_OP_NO_DTLSv1_2) {\n                if (tls1_suiteb(s)) {\n                    SSLerr(SSL_F_SSL3_CLIENT_HELLO,\n                           SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n                    goto err;\n                }\n                /*\n                 * Disabling all versions is silly: return an error.\n                 */\n                if (options & SSL_OP_NO_DTLSv1) {\n                    SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_WRONG_SSL_VERSION);\n                    goto err;\n                }\n                /*\n                 * Update method so we don't use any DTLS 1.2 features.\n                 */\n                s->method = DTLSv1_client_method();\n                s->version = DTLS1_VERSION;\n            } else {\n                /*\n                 * We only support one version: update method\n                 */\n                if (options & SSL_OP_NO_DTLSv1)\n                    s->method = DTLSv1_2_client_method();\n                s->version = DTLS1_2_VERSION;\n            }\n            s->client_version = s->version;\n        }\n        /* else use the pre-loaded session */\n\n        p = s->s3->client_random;\n\n        /*\n         * for DTLS if client_random is initialized, reuse it, we are\n         * required to use same upon reply to HelloVerify\n         */\n        if (SSL_IS_DTLS(s)) {\n            size_t idx;\n            i = 1;\n            for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {\n                if (p[idx]) {\n                    i = 0;\n                    break;\n                }\n            }\n        } else\n            i = 1;\n\n        if (i && ssl_fill_hello_random(s, 0, p,\n                                       sizeof(s->s3->client_random)) <= 0)\n            goto err;\n\n        /* Do the message type and length last */\n        d = p = ssl_handshake_start(s);\n\n        /*-\n         * version indicates the negotiated version: for example from\n         * an SSLv2/v3 compatible client hello). The client_version\n         * field is the maximum version we permit and it is also\n         * used in RSA encrypted premaster secrets. Some servers can\n         * choke if we initially report a higher version then\n         * renegotiate to a lower one in the premaster secret. This\n         * didn't happen with TLS 1.0 as most servers supported it\n         * but it can with TLS 1.1 or later if the server only supports\n         * 1.0.\n         *\n         * Possible scenario with previous logic:\n         *      1. Client hello indicates TLS 1.2\n         *      2. Server hello says TLS 1.0\n         *      3. RSA encrypted premaster secret uses 1.2.\n         *      4. Handhaked proceeds using TLS 1.0.\n         *      5. Server sends hello request to renegotiate.\n         *      6. Client hello indicates TLS v1.0 as we now\n         *         know that is maximum server supports.\n         *      7. Server chokes on RSA encrypted premaster secret\n         *         containing version 1.0.\n         *\n         * For interoperability it should be OK to always use the\n         * maximum version we support in client hello and then rely\n         * on the checking of version to ensure the servers isn't\n         * being inconsistent: for example initially negotiating with\n         * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n         * client_version in client hello and not resetting it to\n         * the negotiated version.\n         */\n        *(p++) = s->client_version >> 8;\n        *(p++) = s->client_version & 0xff;\n\n        /* Random stuff */\n        memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);\n        p += SSL3_RANDOM_SIZE;\n\n        /* Session ID */\n        if (s->new_session)\n            i = 0;\n        else\n            i = s->session->session_id_length;\n        *(p++) = i;\n        if (i != 0) {\n            if (i > (int)sizeof(s->session->session_id)) {\n                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            memcpy(p, s->session->session_id, i);\n            p += i;\n        }\n\n        /* cookie stuff for DTLS */\n        if (SSL_IS_DTLS(s)) {\n            if (s->d1->cookie_len > sizeof(s->d1->cookie)) {\n                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            *(p++) = s->d1->cookie_len;\n            memcpy(p, s->d1->cookie, s->d1->cookie_len);\n            p += s->d1->cookie_len;\n        }\n\n        /* Ciphers supported */\n        i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);\n        if (i == 0) {\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);\n            goto err;\n        }\n#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH\n        /*\n         * Some servers hang if client hello > 256 bytes as hack workaround\n         * chop number of supported ciphers to keep it well below this if we\n         * use TLS v1.2\n         */\n        if (TLS1_get_version(s) >= TLS1_2_VERSION\n            && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)\n            i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;\n#endif\n        s2n(i, p);\n        p += i;\n\n        /* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n        *(p++) = 1;\n#else\n\n        if (!ssl_allow_compression(s) || !s->ctx->comp_methods)\n            j = 0;\n        else\n            j = sk_SSL_COMP_num(s->ctx->comp_methods);\n        *(p++) = 1 + j;\n        for (i = 0; i < j; i++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);\n            *(p++) = comp->id;\n        }\n#endif\n        *(p++) = 0;             /* Add the NULL method */\n\n#ifndef OPENSSL_NO_TLSEXT\n        /* TLS extensions */\n        if (ssl_prepare_clienthello_tlsext(s) <= 0) {\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n            goto err;\n        }\n        if ((p =\n             ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,\n                                        &al)) == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, al);\n            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n#endif\n\n        l = p - d;\n        ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);\n        s->state = SSL3_ST_CW_CLNT_HELLO_B;\n    }\n\n    /* SSL3_ST_CW_CLNT_HELLO_B */\n    return ssl_do_write(s);\n err:\n    return (-1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,8 +71,9 @@\n         } else\n             i = 1;\n \n-        if (i)\n-            ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random));\n+        if (i && ssl_fill_hello_random(s, 0, p,\n+                                       sizeof(s->s3->client_random)) <= 0)\n+            goto err;\n \n         /* Do the message type and length last */\n         d = p = ssl_handshake_start(s);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (i)",
                "            ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random));"
            ],
            "added_lines": [
                "        if (i && ssl_fill_hello_random(s, 0, p,",
                "                                       sizeof(s->s3->client_random)) <= 0)",
                "            goto err;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1618",
        "func_name": "chromium/TestingPlatformSupport::cryptographicallyRandomValues",
        "description": "Blink, as used in Google Chrome before 48.0.2564.82, does not ensure that a proper cryptographicallyRandomValues random number generator is used, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/0d151e09e13a704e9738ea913d117df7282e6c7d",
        "commit_title": "Add assertions that the empty Platform::cryptographicallyRandomValues() overrides are not being used.",
        "commit_text": " These implementations are not safe and look scary if not accompanied by an assertion. Also one of the comments was incorrect.    ",
        "func_before": "void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n{\n}",
        "func": "void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n{\n    RELEASE_ASSERT_NOT_REACHED();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,4 @@\n void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n+    RELEASE_ASSERT_NOT_REACHED();\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    RELEASE_ASSERT_NOT_REACHED();"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1618",
        "func_name": "chromium/main",
        "description": "Blink, as used in Google Chrome before 48.0.2564.82, does not ensure that a proper cryptographicallyRandomValues random number generator is used, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/0d151e09e13a704e9738ea913d117df7282e6c7d",
        "commit_title": "Add assertions that the empty Platform::cryptographicallyRandomValues() overrides are not being used.",
        "commit_text": " These implementations are not safe and look scary if not accompanied by an assertion. Also one of the comments was incorrect.    ",
        "func_before": "int main(int argc, char* argv[])\n{\n    char* name = argv[0];\n\n    // If the platform supports color correction, allow it to be controlled.\n\n    bool applyColorCorrection = false;\n\n#if USE(QCMSLIB)\n    if (argc >= 2 && strcmp(argv[1], \"--color-correct\") == 0)\n        applyColorCorrection = (--argc, ++argv, true);\n\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s [--color-correct] file [iterations] [packetSize]\\n\", name);\n        exit(1);\n    }\n#else\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s file [iterations] [packetSize]\\n\", name);\n        exit(1);\n    }\n#endif\n\n    // Control decode bench iterations and packet size.\n\n    size_t iterations = 1;\n    if (argc >= 3) {\n        char* end = 0;\n        iterations = strtol(argv[2], &end, 10);\n        if (*end != '\\0' || !iterations) {\n            fprintf(stderr, \"Second argument should be number of iterations. \"\n                \"The default is 1. You supplied %s\\n\", argv[2]);\n            exit(1);\n        }\n    }\n\n    size_t packetSize = 0;\n    if (argc >= 4) {\n        char* end = 0;\n        packetSize = strtol(argv[3], &end, 10);\n        if (*end != '\\0') {\n            fprintf(stderr, \"Third argument should be packet size. Default is \"\n                \"0, meaning to decode the entire image in one packet. You \"\n                \"supplied %s\\n\", argv[3]);\n            exit(1);\n        }\n    }\n\n    // Create a web platform without V8.\n\n    class WebPlatform : public blink::Platform {\n    public:\n        const unsigned char* getTraceCategoryEnabledFlag(const char*) override\n        {\n            return reinterpret_cast<const unsigned char *>(\"nope-none-nada\");\n        }\n\n        void cryptographicallyRandomValues(unsigned char*, size_t) override\n        {\n            // Do nothing: make blink::Platform use the default crypto-randoms.\n        }\n\n        void screenColorProfile(WebVector<char>* profile) override\n        {\n            getScreenColorProfile(profile); // Returns a whacked color profile.\n        }\n    };\n\n    blink::initializeWithoutV8(new WebPlatform());\n\n    // Set image decoding Platform options.\n\n#if USE(QCMSLIB)\n    ImageDecoder::qcmsOutputDeviceProfile(); // Initialize screen colorProfile.\n#endif\n\n    // Read entire file content to data.\n\n    RefPtr<SharedBuffer> data = readFile(argv[1]);\n    if (!data.get() || !data->size()) {\n        fprintf(stderr, \"Error reading image data from [%s]\\n\", argv[1]);\n        exit(2);\n    }\n\n    // Consolidate the SharedBuffer data segments into one, contiguous block of memory.\n    data->data();\n\n    // Image decode bench for iterations.\n\n    double totalTime = 0.0;\n\n    for (size_t i = 0; i < iterations; ++i) {\n        double startTime = getCurrentTime();\n        bool decoded = decodeImageData(data.get(), applyColorCorrection, packetSize);\n        double elapsedTime = getCurrentTime() - startTime;\n        totalTime += elapsedTime;\n        if (!decoded) {\n            fprintf(stderr, \"Image decode failed [%s]\\n\", argv[1]);\n            exit(3);\n        }\n    }\n\n    // Results to stdout.\n\n    double averageTime = totalTime / static_cast<double>(iterations);\n    printf(\"%f %f\\n\", totalTime, averageTime);\n    return 0;\n}",
        "func": "int main(int argc, char* argv[])\n{\n    char* name = argv[0];\n\n    // If the platform supports color correction, allow it to be controlled.\n\n    bool applyColorCorrection = false;\n\n#if USE(QCMSLIB)\n    if (argc >= 2 && strcmp(argv[1], \"--color-correct\") == 0)\n        applyColorCorrection = (--argc, ++argv, true);\n\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s [--color-correct] file [iterations] [packetSize]\\n\", name);\n        exit(1);\n    }\n#else\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s file [iterations] [packetSize]\\n\", name);\n        exit(1);\n    }\n#endif\n\n    // Control decode bench iterations and packet size.\n\n    size_t iterations = 1;\n    if (argc >= 3) {\n        char* end = 0;\n        iterations = strtol(argv[2], &end, 10);\n        if (*end != '\\0' || !iterations) {\n            fprintf(stderr, \"Second argument should be number of iterations. \"\n                \"The default is 1. You supplied %s\\n\", argv[2]);\n            exit(1);\n        }\n    }\n\n    size_t packetSize = 0;\n    if (argc >= 4) {\n        char* end = 0;\n        packetSize = strtol(argv[3], &end, 10);\n        if (*end != '\\0') {\n            fprintf(stderr, \"Third argument should be packet size. Default is \"\n                \"0, meaning to decode the entire image in one packet. You \"\n                \"supplied %s\\n\", argv[3]);\n            exit(1);\n        }\n    }\n\n    // Create a web platform without V8.\n\n    class WebPlatform : public blink::Platform {\n    public:\n        const unsigned char* getTraceCategoryEnabledFlag(const char*) override\n        {\n            return reinterpret_cast<const unsigned char *>(\"nope-none-nada\");\n        }\n\n        void cryptographicallyRandomValues(unsigned char*, size_t) override\n        {\n            RELEASE_ASSERT_NOT_REACHED();\n        }\n\n        void screenColorProfile(WebVector<char>* profile) override\n        {\n            getScreenColorProfile(profile); // Returns a whacked color profile.\n        }\n    };\n\n    blink::initializeWithoutV8(new WebPlatform());\n\n    // Set image decoding Platform options.\n\n#if USE(QCMSLIB)\n    ImageDecoder::qcmsOutputDeviceProfile(); // Initialize screen colorProfile.\n#endif\n\n    // Read entire file content to data.\n\n    RefPtr<SharedBuffer> data = readFile(argv[1]);\n    if (!data.get() || !data->size()) {\n        fprintf(stderr, \"Error reading image data from [%s]\\n\", argv[1]);\n        exit(2);\n    }\n\n    // Consolidate the SharedBuffer data segments into one, contiguous block of memory.\n    data->data();\n\n    // Image decode bench for iterations.\n\n    double totalTime = 0.0;\n\n    for (size_t i = 0; i < iterations; ++i) {\n        double startTime = getCurrentTime();\n        bool decoded = decodeImageData(data.get(), applyColorCorrection, packetSize);\n        double elapsedTime = getCurrentTime() - startTime;\n        totalTime += elapsedTime;\n        if (!decoded) {\n            fprintf(stderr, \"Image decode failed [%s]\\n\", argv[1]);\n            exit(3);\n        }\n    }\n\n    // Results to stdout.\n\n    double averageTime = totalTime / static_cast<double>(iterations);\n    printf(\"%f %f\\n\", totalTime, averageTime);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,7 +57,7 @@\n \n         void cryptographicallyRandomValues(unsigned char*, size_t) override\n         {\n-            // Do nothing: make blink::Platform use the default crypto-randoms.\n+            RELEASE_ASSERT_NOT_REACHED();\n         }\n \n         void screenColorProfile(WebVector<char>* profile) override",
        "diff_line_info": {
            "deleted_lines": [
                "            // Do nothing: make blink::Platform use the default crypto-randoms."
            ],
            "added_lines": [
                "            RELEASE_ASSERT_NOT_REACHED();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3197",
        "func_name": "openssl/get_client_master_key",
        "description": "ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=d81a1600588b726c2bdccda7efad3cc7a87d6245",
        "commit_title": "",
        "commit_text": "Better SSLv2 cipher-suite enforcement  Based on patch by: Nimrod Aviram <nimrod.aviram@gmail.com>  CVE-2015-3197  ",
        "func_before": "static int get_client_master_key(SSL *s)\n{\n    int is_export, i, n, keya;\n    unsigned int num_encrypted_key_bytes, key_length;\n    unsigned long len;\n    unsigned char *p;\n    const SSL_CIPHER *cp;\n    const EVP_CIPHER *c;\n    const EVP_MD *md;\n    unsigned char rand_premaster_secret[SSL_MAX_MASTER_KEY_LENGTH];\n    unsigned char decrypt_good;\n    size_t j;\n\n    p = (unsigned char *)s->init_buf->data;\n    if (s->state == SSL2_ST_GET_CLIENT_MASTER_KEY_A) {\n        i = ssl2_read(s, (char *)&(p[s->init_num]), 10 - s->init_num);\n\n        if (i < (10 - s->init_num))\n            return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));\n        s->init_num = 10;\n\n        if (*(p++) != SSL2_MT_CLIENT_MASTER_KEY) {\n            if (p[-1] != SSL2_MT_ERROR) {\n                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,\n                       SSL_R_READ_WRONG_PACKET_TYPE);\n            } else\n                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_PEER_ERROR);\n            return (-1);\n        }\n\n        cp = ssl2_get_cipher_by_char(p);\n        if (cp == NULL) {\n            ssl2_return_error(s, SSL2_PE_NO_CIPHER);\n            SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);\n            return (-1);\n        }\n        s->session->cipher = cp;\n\n        p += 3;\n        n2s(p, i);\n        s->s2->tmp.clear = i;\n        n2s(p, i);\n        s->s2->tmp.enc = i;\n        n2s(p, i);\n        if (i > SSL_MAX_KEY_ARG_LENGTH) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_KEY_ARG_TOO_LONG);\n            return -1;\n        }\n        s->session->key_arg_length = i;\n        s->state = SSL2_ST_GET_CLIENT_MASTER_KEY_B;\n    }\n\n    /* SSL2_ST_GET_CLIENT_MASTER_KEY_B */\n    p = (unsigned char *)s->init_buf->data;\n    if (s->init_buf->length < SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n    keya = s->session->key_arg_length;\n    len =\n        10 + (unsigned long)s->s2->tmp.clear + (unsigned long)s->s2->tmp.enc +\n        (unsigned long)keya;\n    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_MESSAGE_TOO_LONG);\n        return -1;\n    }\n    n = (int)len - s->init_num;\n    i = ssl2_read(s, (char *)&(p[s->init_num]), n);\n    if (i != n)\n        return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));\n    if (s->msg_callback) {\n        /* CLIENT-MASTER-KEY */\n        s->msg_callback(0, s->version, 0, p, (size_t)len, s,\n                        s->msg_callback_arg);\n    }\n    p += 10;\n\n    memcpy(s->session->key_arg, &(p[s->s2->tmp.clear + s->s2->tmp.enc]),\n           (unsigned int)keya);\n\n    if (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_PRIVATEKEY);\n        return (-1);\n    }\n\n    is_export = SSL_C_IS_EXPORT(s->session->cipher);\n\n    if (!ssl_cipher_get_evp(s->session, &c, &md, NULL, NULL, NULL)) {\n        ssl2_return_error(s, SSL2_PE_NO_CIPHER);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,\n               SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\n        return (0);\n    }\n\n    /*\n     * The format of the CLIENT-MASTER-KEY message is\n     * 1 byte message type\n     * 3 bytes cipher\n     * 2-byte clear key length (stored in s->s2->tmp.clear)\n     * 2-byte encrypted key length (stored in s->s2->tmp.enc)\n     * 2-byte key args length (IV etc)\n     * clear key\n     * encrypted key\n     * key args\n     *\n     * If the cipher is an export cipher, then the encrypted key bytes\n     * are a fixed portion of the total key (5 or 8 bytes). The size of\n     * this portion is in |num_encrypted_key_bytes|. If the cipher is not an\n     * export cipher, then the entire key material is encrypted (i.e., clear\n     * key length must be zero).\n     */\n    key_length = (unsigned int)EVP_CIPHER_key_length(c);\n    if (key_length > SSL_MAX_MASTER_KEY_LENGTH) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    if (s->session->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC) {\n        is_export = 1;\n        num_encrypted_key_bytes = 8;\n    } else if (is_export) {\n        num_encrypted_key_bytes = 5;\n    } else {\n        num_encrypted_key_bytes = key_length;\n    }\n\n    if (s->s2->tmp.clear + num_encrypted_key_bytes != key_length) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_BAD_LENGTH);\n        return -1;\n    }\n    /*\n     * The encrypted blob must decrypt to the encrypted portion of the key.\n     * Decryption can't be expanding, so if we don't have enough encrypted\n     * bytes to fit the key in the buffer, stop now.\n     */\n    if (s->s2->tmp.enc < num_encrypted_key_bytes) {\n        ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_LENGTH_TOO_SHORT);\n        return -1;\n    }\n\n    /*\n     * We must not leak whether a decryption failure occurs because of\n     * Bleichenbacher's attack on PKCS #1 v1.5 RSA padding (see RFC 2246,\n     * section 7.4.7.1). The code follows that advice of the TLS RFC and\n     * generates a random premaster secret for the case that the decrypt\n     * fails. See https://tools.ietf.org/html/rfc5246#section-7.4.7.1\n     */\n\n    /*\n     * should be RAND_bytes, but we cannot work around a failure.\n     */\n    if (RAND_pseudo_bytes(rand_premaster_secret,\n                          (int)num_encrypted_key_bytes) <= 0)\n        return 0;\n\n    i = ssl_rsa_private_decrypt(s->cert, s->s2->tmp.enc,\n                                &(p[s->s2->tmp.clear]),\n                                &(p[s->s2->tmp.clear]),\n                                (s->s2->ssl2_rollback) ? RSA_SSLV23_PADDING :\n                                RSA_PKCS1_PADDING);\n    ERR_clear_error();\n    /*\n     * If a bad decrypt, continue with protocol but with a random master\n     * secret (Bleichenbacher attack)\n     */\n    decrypt_good = constant_time_eq_int_8(i, (int)num_encrypted_key_bytes);\n    for (j = 0; j < num_encrypted_key_bytes; j++) {\n        p[s->s2->tmp.clear + j] =\n                constant_time_select_8(decrypt_good, p[s->s2->tmp.clear + j],\n                                       rand_premaster_secret[j]);\n    }\n\n    s->session->master_key_length = (int)key_length;\n    memcpy(s->session->master_key, p, key_length);\n    OPENSSL_cleanse(p, key_length);\n\n    return 1;\n}",
        "func": "static int get_client_master_key(SSL *s)\n{\n    int is_export, i, n, keya;\n    unsigned int num_encrypted_key_bytes, key_length;\n    unsigned long len;\n    unsigned char *p;\n    const SSL_CIPHER *cp;\n    const EVP_CIPHER *c;\n    const EVP_MD *md;\n    unsigned char rand_premaster_secret[SSL_MAX_MASTER_KEY_LENGTH];\n    unsigned char decrypt_good;\n    size_t j;\n\n    p = (unsigned char *)s->init_buf->data;\n    if (s->state == SSL2_ST_GET_CLIENT_MASTER_KEY_A) {\n        i = ssl2_read(s, (char *)&(p[s->init_num]), 10 - s->init_num);\n\n        if (i < (10 - s->init_num))\n            return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));\n        s->init_num = 10;\n\n        if (*(p++) != SSL2_MT_CLIENT_MASTER_KEY) {\n            if (p[-1] != SSL2_MT_ERROR) {\n                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,\n                       SSL_R_READ_WRONG_PACKET_TYPE);\n            } else\n                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_PEER_ERROR);\n            return (-1);\n        }\n\n        cp = ssl2_get_cipher_by_char(p);\n        if (cp == NULL || sk_SSL_CIPHER_find(s->session->ciphers, cp) < 0) {\n            ssl2_return_error(s, SSL2_PE_NO_CIPHER);\n            SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);\n            return (-1);\n        }\n        s->session->cipher = cp;\n\n        p += 3;\n        n2s(p, i);\n        s->s2->tmp.clear = i;\n        n2s(p, i);\n        s->s2->tmp.enc = i;\n        n2s(p, i);\n        if (i > SSL_MAX_KEY_ARG_LENGTH) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_KEY_ARG_TOO_LONG);\n            return -1;\n        }\n        s->session->key_arg_length = i;\n        s->state = SSL2_ST_GET_CLIENT_MASTER_KEY_B;\n    }\n\n    /* SSL2_ST_GET_CLIENT_MASTER_KEY_B */\n    p = (unsigned char *)s->init_buf->data;\n    if (s->init_buf->length < SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n    keya = s->session->key_arg_length;\n    len =\n        10 + (unsigned long)s->s2->tmp.clear + (unsigned long)s->s2->tmp.enc +\n        (unsigned long)keya;\n    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_MESSAGE_TOO_LONG);\n        return -1;\n    }\n    n = (int)len - s->init_num;\n    i = ssl2_read(s, (char *)&(p[s->init_num]), n);\n    if (i != n)\n        return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));\n    if (s->msg_callback) {\n        /* CLIENT-MASTER-KEY */\n        s->msg_callback(0, s->version, 0, p, (size_t)len, s,\n                        s->msg_callback_arg);\n    }\n    p += 10;\n\n    memcpy(s->session->key_arg, &(p[s->s2->tmp.clear + s->s2->tmp.enc]),\n           (unsigned int)keya);\n\n    if (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_PRIVATEKEY);\n        return (-1);\n    }\n\n    is_export = SSL_C_IS_EXPORT(s->session->cipher);\n\n    if (!ssl_cipher_get_evp(s->session, &c, &md, NULL, NULL, NULL)) {\n        ssl2_return_error(s, SSL2_PE_NO_CIPHER);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,\n               SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\n        return (0);\n    }\n\n    /*\n     * The format of the CLIENT-MASTER-KEY message is\n     * 1 byte message type\n     * 3 bytes cipher\n     * 2-byte clear key length (stored in s->s2->tmp.clear)\n     * 2-byte encrypted key length (stored in s->s2->tmp.enc)\n     * 2-byte key args length (IV etc)\n     * clear key\n     * encrypted key\n     * key args\n     *\n     * If the cipher is an export cipher, then the encrypted key bytes\n     * are a fixed portion of the total key (5 or 8 bytes). The size of\n     * this portion is in |num_encrypted_key_bytes|. If the cipher is not an\n     * export cipher, then the entire key material is encrypted (i.e., clear\n     * key length must be zero).\n     */\n    key_length = (unsigned int)EVP_CIPHER_key_length(c);\n    if (key_length > SSL_MAX_MASTER_KEY_LENGTH) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    if (s->session->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC) {\n        is_export = 1;\n        num_encrypted_key_bytes = 8;\n    } else if (is_export) {\n        num_encrypted_key_bytes = 5;\n    } else {\n        num_encrypted_key_bytes = key_length;\n    }\n\n    if (s->s2->tmp.clear + num_encrypted_key_bytes != key_length) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_BAD_LENGTH);\n        return -1;\n    }\n    /*\n     * The encrypted blob must decrypt to the encrypted portion of the key.\n     * Decryption can't be expanding, so if we don't have enough encrypted\n     * bytes to fit the key in the buffer, stop now.\n     */\n    if (s->s2->tmp.enc < num_encrypted_key_bytes) {\n        ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_LENGTH_TOO_SHORT);\n        return -1;\n    }\n\n    /*\n     * We must not leak whether a decryption failure occurs because of\n     * Bleichenbacher's attack on PKCS #1 v1.5 RSA padding (see RFC 2246,\n     * section 7.4.7.1). The code follows that advice of the TLS RFC and\n     * generates a random premaster secret for the case that the decrypt\n     * fails. See https://tools.ietf.org/html/rfc5246#section-7.4.7.1\n     */\n\n    /*\n     * should be RAND_bytes, but we cannot work around a failure.\n     */\n    if (RAND_pseudo_bytes(rand_premaster_secret,\n                          (int)num_encrypted_key_bytes) <= 0)\n        return 0;\n\n    i = ssl_rsa_private_decrypt(s->cert, s->s2->tmp.enc,\n                                &(p[s->s2->tmp.clear]),\n                                &(p[s->s2->tmp.clear]),\n                                (s->s2->ssl2_rollback) ? RSA_SSLV23_PADDING :\n                                RSA_PKCS1_PADDING);\n    ERR_clear_error();\n    /*\n     * If a bad decrypt, continue with protocol but with a random master\n     * secret (Bleichenbacher attack)\n     */\n    decrypt_good = constant_time_eq_int_8(i, (int)num_encrypted_key_bytes);\n    for (j = 0; j < num_encrypted_key_bytes; j++) {\n        p[s->s2->tmp.clear + j] =\n                constant_time_select_8(decrypt_good, p[s->s2->tmp.clear + j],\n                                       rand_premaster_secret[j]);\n    }\n\n    s->session->master_key_length = (int)key_length;\n    memcpy(s->session->master_key, p, key_length);\n    OPENSSL_cleanse(p, key_length);\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n         }\n \n         cp = ssl2_get_cipher_by_char(p);\n-        if (cp == NULL) {\n+        if (cp == NULL || sk_SSL_CIPHER_find(s->session->ciphers, cp) < 0) {\n             ssl2_return_error(s, SSL2_PE_NO_CIPHER);\n             SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);\n             return (-1);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (cp == NULL) {"
            ],
            "added_lines": [
                "        if (cp == NULL || sk_SSL_CIPHER_find(s->session->ciphers, cp) < 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3197",
        "func_name": "openssl/get_client_hello",
        "description": "ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=d81a1600588b726c2bdccda7efad3cc7a87d6245",
        "commit_title": "",
        "commit_text": "Better SSLv2 cipher-suite enforcement  Based on patch by: Nimrod Aviram <nimrod.aviram@gmail.com>  CVE-2015-3197  ",
        "func_before": "static int get_client_hello(SSL *s)\n{\n    int i, n;\n    unsigned long len;\n    unsigned char *p;\n    STACK_OF(SSL_CIPHER) *cs;   /* a stack of SSL_CIPHERS */\n    STACK_OF(SSL_CIPHER) *cl;   /* the ones we want to use */\n    STACK_OF(SSL_CIPHER) *prio, *allow;\n    int z;\n\n    /*\n     * This is a bit of a hack to check for the correct packet type the first\n     * time round.\n     */\n    if (s->state == SSL2_ST_GET_CLIENT_HELLO_A) {\n        s->first_packet = 1;\n        s->state = SSL2_ST_GET_CLIENT_HELLO_B;\n    }\n\n    p = (unsigned char *)s->init_buf->data;\n    if (s->state == SSL2_ST_GET_CLIENT_HELLO_B) {\n        i = ssl2_read(s, (char *)&(p[s->init_num]), 9 - s->init_num);\n        if (i < (9 - s->init_num))\n            return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));\n        s->init_num = 9;\n\n        if (*(p++) != SSL2_MT_CLIENT_HELLO) {\n            if (p[-1] != SSL2_MT_ERROR) {\n                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_READ_WRONG_PACKET_TYPE);\n            } else\n                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_PEER_ERROR);\n            return (-1);\n        }\n        n2s(p, i);\n        if (i < s->version)\n            s->version = i;\n        n2s(p, i);\n        s->s2->tmp.cipher_spec_length = i;\n        n2s(p, i);\n        s->s2->tmp.session_id_length = i;\n        if ((i < 0) || (i > SSL_MAX_SSL_SESSION_ID_LENGTH)) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);\n            return -1;\n        }\n        n2s(p, i);\n        s->s2->challenge_length = i;\n        if ((i < SSL2_MIN_CHALLENGE_LENGTH) ||\n            (i > SSL2_MAX_CHALLENGE_LENGTH)) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_INVALID_CHALLENGE_LENGTH);\n            return (-1);\n        }\n        s->state = SSL2_ST_GET_CLIENT_HELLO_C;\n    }\n\n    /* SSL2_ST_GET_CLIENT_HELLO_C */\n    p = (unsigned char *)s->init_buf->data;\n    len =\n        9 + (unsigned long)s->s2->tmp.cipher_spec_length +\n        (unsigned long)s->s2->challenge_length +\n        (unsigned long)s->s2->tmp.session_id_length;\n    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_MESSAGE_TOO_LONG);\n        return -1;\n    }\n    n = (int)len - s->init_num;\n    i = ssl2_read(s, (char *)&(p[s->init_num]), n);\n    if (i != n)\n        return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));\n    if (s->msg_callback) {\n        /* CLIENT-HELLO */\n        s->msg_callback(0, s->version, 0, p, (size_t)len, s,\n                        s->msg_callback_arg);\n    }\n    p += 9;\n\n    /*\n     * get session-id before cipher stuff so we can get out session structure\n     * if it is cached\n     */\n    /* session-id */\n    if ((s->s2->tmp.session_id_length != 0) &&\n        (s->s2->tmp.session_id_length != SSL2_SSL_SESSION_ID_LENGTH)) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_BAD_SSL_SESSION_ID_LENGTH);\n        return (-1);\n    }\n\n    if (s->s2->tmp.session_id_length == 0) {\n        if (!ssl_get_new_session(s, 1)) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            return (-1);\n        }\n    } else {\n        i = ssl_get_prev_session(s, &(p[s->s2->tmp.cipher_spec_length]),\n                                 s->s2->tmp.session_id_length, NULL);\n        if (i == 1) {           /* previous session */\n            s->hit = 1;\n        } else if (i == -1) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            return (-1);\n        } else {\n            if (s->cert == NULL) {\n                ssl2_return_error(s, SSL2_PE_NO_CERTIFICATE);\n                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CERTIFICATE_SET);\n                return (-1);\n            }\n\n            if (!ssl_get_new_session(s, 1)) {\n                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n                return (-1);\n            }\n        }\n    }\n\n    if (!s->hit) {\n        cs = ssl_bytes_to_cipher_list(s, p, s->s2->tmp.cipher_spec_length,\n                                      &s->session->ciphers);\n        if (cs == NULL)\n            goto mem_err;\n\n        cl = SSL_get_ciphers(s);\n\n        if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) {\n            prio = sk_SSL_CIPHER_dup(cl);\n            if (prio == NULL)\n                goto mem_err;\n            allow = cs;\n        } else {\n            prio = cs;\n            allow = cl;\n        }\n        for (z = 0; z < sk_SSL_CIPHER_num(prio); z++) {\n            if (sk_SSL_CIPHER_find(allow, sk_SSL_CIPHER_value(prio, z)) < 0) {\n                (void)sk_SSL_CIPHER_delete(prio, z);\n                z--;\n            }\n        }\n        if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) {\n            sk_SSL_CIPHER_free(s->session->ciphers);\n            s->session->ciphers = prio;\n        }\n        /*\n         * s->session->ciphers should now have a list of ciphers that are on\n         * both the client and server. This list is ordered by the order the\n         * client sent the ciphers or in the order of the server's preference\n         * if SSL_OP_CIPHER_SERVER_PREFERENCE was set.\n         */\n    }\n    p += s->s2->tmp.cipher_spec_length;\n    /* done cipher selection */\n\n    /* session id extracted already */\n    p += s->s2->tmp.session_id_length;\n\n    /* challenge */\n    if (s->s2->challenge_length > sizeof s->s2->challenge) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n    memcpy(s->s2->challenge, p, (unsigned int)s->s2->challenge_length);\n    return (1);\n mem_err:\n    SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_MALLOC_FAILURE);\n    return (0);\n}",
        "func": "static int get_client_hello(SSL *s)\n{\n    int i, n;\n    unsigned long len;\n    unsigned char *p;\n    STACK_OF(SSL_CIPHER) *cs;   /* a stack of SSL_CIPHERS */\n    STACK_OF(SSL_CIPHER) *cl;   /* the ones we want to use */\n    STACK_OF(SSL_CIPHER) *prio, *allow;\n    int z;\n\n    /*\n     * This is a bit of a hack to check for the correct packet type the first\n     * time round.\n     */\n    if (s->state == SSL2_ST_GET_CLIENT_HELLO_A) {\n        s->first_packet = 1;\n        s->state = SSL2_ST_GET_CLIENT_HELLO_B;\n    }\n\n    p = (unsigned char *)s->init_buf->data;\n    if (s->state == SSL2_ST_GET_CLIENT_HELLO_B) {\n        i = ssl2_read(s, (char *)&(p[s->init_num]), 9 - s->init_num);\n        if (i < (9 - s->init_num))\n            return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));\n        s->init_num = 9;\n\n        if (*(p++) != SSL2_MT_CLIENT_HELLO) {\n            if (p[-1] != SSL2_MT_ERROR) {\n                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_READ_WRONG_PACKET_TYPE);\n            } else\n                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_PEER_ERROR);\n            return (-1);\n        }\n        n2s(p, i);\n        if (i < s->version)\n            s->version = i;\n        n2s(p, i);\n        s->s2->tmp.cipher_spec_length = i;\n        n2s(p, i);\n        s->s2->tmp.session_id_length = i;\n        if ((i < 0) || (i > SSL_MAX_SSL_SESSION_ID_LENGTH)) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);\n            return -1;\n        }\n        n2s(p, i);\n        s->s2->challenge_length = i;\n        if ((i < SSL2_MIN_CHALLENGE_LENGTH) ||\n            (i > SSL2_MAX_CHALLENGE_LENGTH)) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_INVALID_CHALLENGE_LENGTH);\n            return (-1);\n        }\n        s->state = SSL2_ST_GET_CLIENT_HELLO_C;\n    }\n\n    /* SSL2_ST_GET_CLIENT_HELLO_C */\n    p = (unsigned char *)s->init_buf->data;\n    len =\n        9 + (unsigned long)s->s2->tmp.cipher_spec_length +\n        (unsigned long)s->s2->challenge_length +\n        (unsigned long)s->s2->tmp.session_id_length;\n    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_MESSAGE_TOO_LONG);\n        return -1;\n    }\n    n = (int)len - s->init_num;\n    i = ssl2_read(s, (char *)&(p[s->init_num]), n);\n    if (i != n)\n        return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));\n    if (s->msg_callback) {\n        /* CLIENT-HELLO */\n        s->msg_callback(0, s->version, 0, p, (size_t)len, s,\n                        s->msg_callback_arg);\n    }\n    p += 9;\n\n    /*\n     * get session-id before cipher stuff so we can get out session structure\n     * if it is cached\n     */\n    /* session-id */\n    if ((s->s2->tmp.session_id_length != 0) &&\n        (s->s2->tmp.session_id_length != SSL2_SSL_SESSION_ID_LENGTH)) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_BAD_SSL_SESSION_ID_LENGTH);\n        return (-1);\n    }\n\n    if (s->s2->tmp.session_id_length == 0) {\n        if (!ssl_get_new_session(s, 1)) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            return (-1);\n        }\n    } else {\n        i = ssl_get_prev_session(s, &(p[s->s2->tmp.cipher_spec_length]),\n                                 s->s2->tmp.session_id_length, NULL);\n        if (i == 1) {           /* previous session */\n            s->hit = 1;\n        } else if (i == -1) {\n            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n            return (-1);\n        } else {\n            if (s->cert == NULL) {\n                ssl2_return_error(s, SSL2_PE_NO_CERTIFICATE);\n                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CERTIFICATE_SET);\n                return (-1);\n            }\n\n            if (!ssl_get_new_session(s, 1)) {\n                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n                return (-1);\n            }\n        }\n    }\n\n    if (!s->hit) {\n        cs = ssl_bytes_to_cipher_list(s, p, s->s2->tmp.cipher_spec_length,\n                                      &s->session->ciphers);\n        if (cs == NULL)\n            goto mem_err;\n\n        cl = SSL_get_ciphers(s);\n\n        if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) {\n            prio = sk_SSL_CIPHER_dup(cl);\n            if (prio == NULL)\n                goto mem_err;\n            allow = cs;\n        } else {\n            prio = cs;\n            allow = cl;\n        }\n\n        /* Generate list of SSLv2 ciphers shared between client and server */\n        for (z = 0; z < sk_SSL_CIPHER_num(prio); z++) {\n            const SSL_CIPHER *cp = sk_SSL_CIPHER_value(prio, z);\n            if ((cp->algorithm_ssl & SSL_SSLV2) == 0 ||\n                sk_SSL_CIPHER_find(allow, cp) < 0) {\n                (void)sk_SSL_CIPHER_delete(prio, z);\n                z--;\n            }\n        }\n        if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) {\n            sk_SSL_CIPHER_free(s->session->ciphers);\n            s->session->ciphers = prio;\n        }\n\n        /* Make sure we have at least one cipher in common */\n        if (sk_SSL_CIPHER_num(s->session->ciphers) == 0) {\n            ssl2_return_error(s, SSL2_PE_NO_CIPHER);\n            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CIPHER_MATCH);\n            return -1;\n        }\n        /*\n         * s->session->ciphers should now have a list of ciphers that are on\n         * both the client and server. This list is ordered by the order the\n         * client sent the ciphers or in the order of the server's preference\n         * if SSL_OP_CIPHER_SERVER_PREFERENCE was set.\n         */\n    }\n    p += s->s2->tmp.cipher_spec_length;\n    /* done cipher selection */\n\n    /* session id extracted already */\n    p += s->s2->tmp.session_id_length;\n\n    /* challenge */\n    if (s->s2->challenge_length > sizeof s->s2->challenge) {\n        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n        SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n    memcpy(s->s2->challenge, p, (unsigned int)s->s2->challenge_length);\n    return (1);\n mem_err:\n    SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_MALLOC_FAILURE);\n    return (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -133,8 +133,12 @@\n             prio = cs;\n             allow = cl;\n         }\n+\n+        /* Generate list of SSLv2 ciphers shared between client and server */\n         for (z = 0; z < sk_SSL_CIPHER_num(prio); z++) {\n-            if (sk_SSL_CIPHER_find(allow, sk_SSL_CIPHER_value(prio, z)) < 0) {\n+            const SSL_CIPHER *cp = sk_SSL_CIPHER_value(prio, z);\n+            if ((cp->algorithm_ssl & SSL_SSLV2) == 0 ||\n+                sk_SSL_CIPHER_find(allow, cp) < 0) {\n                 (void)sk_SSL_CIPHER_delete(prio, z);\n                 z--;\n             }\n@@ -142,6 +146,13 @@\n         if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) {\n             sk_SSL_CIPHER_free(s->session->ciphers);\n             s->session->ciphers = prio;\n+        }\n+\n+        /* Make sure we have at least one cipher in common */\n+        if (sk_SSL_CIPHER_num(s->session->ciphers) == 0) {\n+            ssl2_return_error(s, SSL2_PE_NO_CIPHER);\n+            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CIPHER_MATCH);\n+            return -1;\n         }\n         /*\n          * s->session->ciphers should now have a list of ciphers that are on",
        "diff_line_info": {
            "deleted_lines": [
                "            if (sk_SSL_CIPHER_find(allow, sk_SSL_CIPHER_value(prio, z)) < 0) {"
            ],
            "added_lines": [
                "",
                "        /* Generate list of SSLv2 ciphers shared between client and server */",
                "            const SSL_CIPHER *cp = sk_SSL_CIPHER_value(prio, z);",
                "            if ((cp->algorithm_ssl & SSL_SSLV2) == 0 ||",
                "                sk_SSL_CIPHER_find(allow, cp) < 0) {",
                "        }",
                "",
                "        /* Make sure we have at least one cipher in common */",
                "        if (sk_SSL_CIPHER_num(s->session->ciphers) == 0) {",
                "            ssl2_return_error(s, SSL2_PE_NO_CIPHER);",
                "            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CIPHER_MATCH);",
                "            return -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-3568",
        "func_name": "openssl/ssl23_get_server_hello",
        "description": "OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=26a59d9b46574e457870197dffa802871b4c8fc7",
        "commit_title": "",
        "commit_text": "Fix no-ssl3 configuration option  CVE-2014-3568  ",
        "func_before": "static int ssl23_get_server_hello(SSL *s)\n\t{\n\tchar buf[8];\n\tunsigned char *p;\n\tint i;\n\tint n;\n\n\tn=ssl23_read_bytes(s,7);\n\n\tif (n != 7) return(n);\n\tp=s->packet;\n\n\tmemcpy(buf,p,n);\n\n\tif ((p[0] & 0x80) && (p[2] == SSL2_MT_SERVER_HELLO) &&\n\t\t(p[5] == 0x00) && (p[6] == 0x02))\n\t\t{\n#ifdef OPENSSL_NO_SSL2\n\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\tgoto err;\n#else\n\t\t/* we are talking sslv2 */\n\t\t/* we need to clean up the SSLv3 setup and put in the\n\t\t * sslv2 stuff. */\n\t\tint ch_len;\n\n\t\tif (s->options & SSL_OP_NO_SSLv2)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (s->s2 == NULL)\n\t\t\t{\n\t\t\tif (!ssl2_new(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n\t\t\tssl2_clear(s);\n\n\t\tif (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)\n\t\t\tch_len=SSL2_CHALLENGE_LENGTH;\n\t\telse\n\t\t\tch_len=SSL2_MAX_CHALLENGE_LENGTH;\n\n\t\t/* write out sslv2 challenge */\n\t\t/* Note that ch_len must be <= SSL3_RANDOM_SIZE (32), because\n\t\t   it is one of SSL2_MAX_CHALLENGE_LENGTH (32) or\n\t\t   SSL2_MAX_CHALLENGE_LENGTH (16), but leave the check in for\n\t\t   futurproofing */\n\t\ti=(SSL3_RANDOM_SIZE < ch_len)\n\t\t\t?SSL3_RANDOM_SIZE:ch_len;\n\t\ts->s2->challenge_length=i;\n\t\tmemcpy(s->s2->challenge,\n\t\t\t&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);\n\n\t\tif (s->s3 != NULL) ssl3_free(s);\n\n\t\tif (!BUF_MEM_grow_clean(s->init_buf,\n\t\t\tSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\ts->state=SSL2_ST_GET_SERVER_HELLO_A;\n\t\tif (!(s->client_version == SSL2_VERSION))\n\t\t\t/* use special padding (SSL 3.0 draft/RFC 2246, App. E.2) */\n\t\t\ts->s2->ssl2_rollback=1;\n\n\t\t/* setup the 7 bytes we have read so we get them from\n\t\t * the sslv2 buffer */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\ts->packet= &(s->s2->rbuf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s2->rbuf_left=n;\n\t\ts->s2->rbuf_offs=0;\n\n\t\t/* we have already written one */\n\t\ts->s2->write_sequence=1;\n\n\t\ts->method=SSLv2_client_method();\n\t\ts->handshake_func=s->method->ssl_connect;\n#endif\n\t\t}\n\telse if (p[1] == SSL3_VERSION_MAJOR &&\n\t         p[2] <= TLS1_2_VERSION_MINOR &&\n\t         ((p[0] == SSL3_RT_HANDSHAKE && p[5] == SSL3_MT_SERVER_HELLO) ||\n\t          (p[0] == SSL3_RT_ALERT && p[3] == 0 && p[4] == 2)))\n\t\t{\n\t\t/* we have sslv3 or tls1 (server hello or alert) */\n\n\t\tif ((p[2] == SSL3_VERSION_MINOR) &&\n\t\t\t!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t{\n#ifdef OPENSSL_FIPS\n\t\t\tif(FIPS_mode())\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,\n\t\t\t\t\tSSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n#endif\n\t\t\ts->version=SSL3_VERSION;\n\t\t\ts->method=SSLv3_client_method();\n\t\t\t}\n\t\telse if ((p[2] == TLS1_VERSION_MINOR) &&\n\t\t\t!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t{\n\t\t\ts->version=TLS1_VERSION;\n\t\t\ts->method=TLSv1_client_method();\n\t\t\t}\n\t\telse if ((p[2] == TLS1_1_VERSION_MINOR) &&\n\t\t\t!(s->options & SSL_OP_NO_TLSv1_1))\n\t\t\t{\n\t\t\ts->version=TLS1_1_VERSION;\n\t\t\ts->method=TLSv1_1_client_method();\n\t\t\t}\n\t\telse if ((p[2] == TLS1_2_VERSION_MINOR) &&\n\t\t\t!(s->options & SSL_OP_NO_TLSv1_2))\n\t\t\t{\n\t\t\ts->version=TLS1_2_VERSION;\n\t\t\ts->method=TLSv1_2_client_method();\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* ensure that TLS_MAX_VERSION is up-to-date */\n\t\tOPENSSL_assert(s->version <= TLS_MAX_VERSION);\n\n\t\tif (p[0] == SSL3_RT_ALERT && p[5] != SSL3_AL_WARNING)\n\t\t\t{\n\t\t\t/* fatal alert */\n\n\t\t\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\t\t\tint j;\n\n\t\t\tif (s->info_callback != NULL)\n\t\t\t\tcb=s->info_callback;\n\t\t\telse if (s->ctx->info_callback != NULL)\n\t\t\t\tcb=s->ctx->info_callback;\n \n\t\t\ti=p[5];\n\t\t\tif (cb != NULL)\n\t\t\t\t{\n\t\t\t\tj=(i<<8)|p[6];\n\t\t\t\tcb(s,SSL_CB_READ_ALERT,j);\n\t\t\t\t}\n\t\t\t\n\t\t\tif (s->msg_callback)\n\t\t\t\ts->msg_callback(0, s->version, SSL3_RT_ALERT, p+5, 2, s, s->msg_callback_arg);\n\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_AD_REASON_OFFSET+p[6]);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (!ssl_init_wbio_buffer(s,1)) goto err;\n\n\t\t/* we are in this state */\n\t\ts->state=SSL3_ST_CR_SRVR_HELLO_A;\n\n\t\t/* put the 7 bytes we have read into the input buffer\n\t\t * for SSLv3 */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\tif (s->s3->rbuf.buf == NULL)\n\t\t\tif (!ssl3_setup_read_buffer(s))\n\t\t\t\tgoto err;\n\t\ts->packet= &(s->s3->rbuf.buf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s3->rbuf.left=n;\n\t\ts->s3->rbuf.offset=0;\n\n\t\ts->handshake_func=s->method->ssl_connect;\n\t\t}\n\telse\n\t\t{\n\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNKNOWN_PROTOCOL);\n\t\tgoto err;\n\t\t}\n\ts->init_num=0;\n\n\t/* Since, if we are sending a ssl23 client hello, we are not\n\t * reusing a session-id */\n\tif (!ssl_get_new_session(s,0))\n\t\tgoto err;\n\n\treturn(SSL_connect(s));\nerr:\n\treturn(-1);\n\t}",
        "func": "static int ssl23_get_server_hello(SSL *s)\n\t{\n\tchar buf[8];\n\tunsigned char *p;\n\tint i;\n\tint n;\n\n\tn=ssl23_read_bytes(s,7);\n\n\tif (n != 7) return(n);\n\tp=s->packet;\n\n\tmemcpy(buf,p,n);\n\n\tif ((p[0] & 0x80) && (p[2] == SSL2_MT_SERVER_HELLO) &&\n\t\t(p[5] == 0x00) && (p[6] == 0x02))\n\t\t{\n#ifdef OPENSSL_NO_SSL2\n\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\tgoto err;\n#else\n\t\t/* we are talking sslv2 */\n\t\t/* we need to clean up the SSLv3 setup and put in the\n\t\t * sslv2 stuff. */\n\t\tint ch_len;\n\n\t\tif (s->options & SSL_OP_NO_SSLv2)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (s->s2 == NULL)\n\t\t\t{\n\t\t\tif (!ssl2_new(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n\t\t\tssl2_clear(s);\n\n\t\tif (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)\n\t\t\tch_len=SSL2_CHALLENGE_LENGTH;\n\t\telse\n\t\t\tch_len=SSL2_MAX_CHALLENGE_LENGTH;\n\n\t\t/* write out sslv2 challenge */\n\t\t/* Note that ch_len must be <= SSL3_RANDOM_SIZE (32), because\n\t\t   it is one of SSL2_MAX_CHALLENGE_LENGTH (32) or\n\t\t   SSL2_MAX_CHALLENGE_LENGTH (16), but leave the check in for\n\t\t   futurproofing */\n\t\ti=(SSL3_RANDOM_SIZE < ch_len)\n\t\t\t?SSL3_RANDOM_SIZE:ch_len;\n\t\ts->s2->challenge_length=i;\n\t\tmemcpy(s->s2->challenge,\n\t\t\t&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);\n\n\t\tif (s->s3 != NULL) ssl3_free(s);\n\n\t\tif (!BUF_MEM_grow_clean(s->init_buf,\n\t\t\tSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\ts->state=SSL2_ST_GET_SERVER_HELLO_A;\n\t\tif (!(s->client_version == SSL2_VERSION))\n\t\t\t/* use special padding (SSL 3.0 draft/RFC 2246, App. E.2) */\n\t\t\ts->s2->ssl2_rollback=1;\n\n\t\t/* setup the 7 bytes we have read so we get them from\n\t\t * the sslv2 buffer */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\ts->packet= &(s->s2->rbuf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s2->rbuf_left=n;\n\t\ts->s2->rbuf_offs=0;\n\n\t\t/* we have already written one */\n\t\ts->s2->write_sequence=1;\n\n\t\ts->method=SSLv2_client_method();\n\t\ts->handshake_func=s->method->ssl_connect;\n#endif\n\t\t}\n\telse if (p[1] == SSL3_VERSION_MAJOR &&\n\t         p[2] <= TLS1_2_VERSION_MINOR &&\n\t         ((p[0] == SSL3_RT_HANDSHAKE && p[5] == SSL3_MT_SERVER_HELLO) ||\n\t          (p[0] == SSL3_RT_ALERT && p[3] == 0 && p[4] == 2)))\n\t\t{\n\t\t/* we have sslv3 or tls1 (server hello or alert) */\n\n#ifndef OPENSSL_NO_SSL3\n\t\tif ((p[2] == SSL3_VERSION_MINOR) &&\n\t\t\t!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t{\n#ifdef OPENSSL_FIPS\n\t\t\tif(FIPS_mode())\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,\n\t\t\t\t\tSSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n#endif\n\t\t\ts->version=SSL3_VERSION;\n\t\t\ts->method=SSLv3_client_method();\n\t\t\t}\n\t\telse\n#endif\n\t\tif ((p[2] == TLS1_VERSION_MINOR) &&\n\t\t\t!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t{\n\t\t\ts->version=TLS1_VERSION;\n\t\t\ts->method=TLSv1_client_method();\n\t\t\t}\n\t\telse if ((p[2] == TLS1_1_VERSION_MINOR) &&\n\t\t\t!(s->options & SSL_OP_NO_TLSv1_1))\n\t\t\t{\n\t\t\ts->version=TLS1_1_VERSION;\n\t\t\ts->method=TLSv1_1_client_method();\n\t\t\t}\n\t\telse if ((p[2] == TLS1_2_VERSION_MINOR) &&\n\t\t\t!(s->options & SSL_OP_NO_TLSv1_2))\n\t\t\t{\n\t\t\ts->version=TLS1_2_VERSION;\n\t\t\ts->method=TLSv1_2_client_method();\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* ensure that TLS_MAX_VERSION is up-to-date */\n\t\tOPENSSL_assert(s->version <= TLS_MAX_VERSION);\n\n\t\tif (p[0] == SSL3_RT_ALERT && p[5] != SSL3_AL_WARNING)\n\t\t\t{\n\t\t\t/* fatal alert */\n\n\t\t\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\t\t\tint j;\n\n\t\t\tif (s->info_callback != NULL)\n\t\t\t\tcb=s->info_callback;\n\t\t\telse if (s->ctx->info_callback != NULL)\n\t\t\t\tcb=s->ctx->info_callback;\n \n\t\t\ti=p[5];\n\t\t\tif (cb != NULL)\n\t\t\t\t{\n\t\t\t\tj=(i<<8)|p[6];\n\t\t\t\tcb(s,SSL_CB_READ_ALERT,j);\n\t\t\t\t}\n\t\t\t\n\t\t\tif (s->msg_callback)\n\t\t\t\ts->msg_callback(0, s->version, SSL3_RT_ALERT, p+5, 2, s, s->msg_callback_arg);\n\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_AD_REASON_OFFSET+p[6]);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (!ssl_init_wbio_buffer(s,1)) goto err;\n\n\t\t/* we are in this state */\n\t\ts->state=SSL3_ST_CR_SRVR_HELLO_A;\n\n\t\t/* put the 7 bytes we have read into the input buffer\n\t\t * for SSLv3 */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\tif (s->s3->rbuf.buf == NULL)\n\t\t\tif (!ssl3_setup_read_buffer(s))\n\t\t\t\tgoto err;\n\t\ts->packet= &(s->s3->rbuf.buf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s3->rbuf.left=n;\n\t\ts->s3->rbuf.offset=0;\n\n\t\ts->handshake_func=s->method->ssl_connect;\n\t\t}\n\telse\n\t\t{\n\t\tSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNKNOWN_PROTOCOL);\n\t\tgoto err;\n\t\t}\n\ts->init_num=0;\n\n\t/* Since, if we are sending a ssl23 client hello, we are not\n\t * reusing a session-id */\n\tif (!ssl_get_new_session(s,0))\n\t\tgoto err;\n\n\treturn(SSL_connect(s));\nerr:\n\treturn(-1);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,6 +90,7 @@\n \t\t{\n \t\t/* we have sslv3 or tls1 (server hello or alert) */\n \n+#ifndef OPENSSL_NO_SSL3\n \t\tif ((p[2] == SSL3_VERSION_MINOR) &&\n \t\t\t!(s->options & SSL_OP_NO_SSLv3))\n \t\t\t{\n@@ -104,7 +105,9 @@\n \t\t\ts->version=SSL3_VERSION;\n \t\t\ts->method=SSLv3_client_method();\n \t\t\t}\n-\t\telse if ((p[2] == TLS1_VERSION_MINOR) &&\n+\t\telse\n+#endif\n+\t\tif ((p[2] == TLS1_VERSION_MINOR) &&\n \t\t\t!(s->options & SSL_OP_NO_TLSv1))\n \t\t\t{\n \t\t\ts->version=TLS1_VERSION;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\telse if ((p[2] == TLS1_VERSION_MINOR) &&"
            ],
            "added_lines": [
                "#ifndef OPENSSL_NO_SSL3",
                "\t\telse",
                "#endif",
                "\t\tif ((p[2] == TLS1_VERSION_MINOR) &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-3568",
        "func_name": "openssl/ssl23_get_client_method",
        "description": "OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=26a59d9b46574e457870197dffa802871b4c8fc7",
        "commit_title": "",
        "commit_text": "Fix no-ssl3 configuration option  CVE-2014-3568  ",
        "func_before": "static const SSL_METHOD *ssl23_get_client_method(int ver)\n\t{\n#ifndef OPENSSL_NO_SSL2\n\tif (ver == SSL2_VERSION)\n\t\treturn(SSLv2_client_method());\n#endif\n\tif (ver == SSL3_VERSION)\n\t\treturn(SSLv3_client_method());\n\telse if (ver == TLS1_VERSION)\n\t\treturn(TLSv1_client_method());\n\telse if (ver == TLS1_1_VERSION)\n\t\treturn(TLSv1_1_client_method());\n\telse if (ver == TLS1_2_VERSION)\n\t\treturn(TLSv1_2_client_method());\n\telse\n\t\treturn(NULL);\n\t}",
        "func": "static const SSL_METHOD *ssl23_get_client_method(int ver)\n\t{\n#ifndef OPENSSL_NO_SSL2\n\tif (ver == SSL2_VERSION)\n\t\treturn(SSLv2_client_method());\n#endif\n#ifndef OPENSSL_NO_SSL3\n\tif (ver == SSL3_VERSION)\n\t\treturn(SSLv3_client_method());\n#endif\n\tif (ver == TLS1_VERSION)\n\t\treturn(TLSv1_client_method());\n\telse if (ver == TLS1_1_VERSION)\n\t\treturn(TLSv1_1_client_method());\n\telse if (ver == TLS1_2_VERSION)\n\t\treturn(TLSv1_2_client_method());\n\telse\n\t\treturn(NULL);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,11 @@\n \tif (ver == SSL2_VERSION)\n \t\treturn(SSLv2_client_method());\n #endif\n+#ifndef OPENSSL_NO_SSL3\n \tif (ver == SSL3_VERSION)\n \t\treturn(SSLv3_client_method());\n-\telse if (ver == TLS1_VERSION)\n+#endif\n+\tif (ver == TLS1_VERSION)\n \t\treturn(TLSv1_client_method());\n \telse if (ver == TLS1_1_VERSION)\n \t\treturn(TLSv1_1_client_method());",
        "diff_line_info": {
            "deleted_lines": [
                "\telse if (ver == TLS1_VERSION)"
            ],
            "added_lines": [
                "#ifndef OPENSSL_NO_SSL3",
                "#endif",
                "\tif (ver == TLS1_VERSION)"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-3568",
        "func_name": "openssl/ssl23_get_client_hello",
        "description": "OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=26a59d9b46574e457870197dffa802871b4c8fc7",
        "commit_title": "",
        "commit_text": "Fix no-ssl3 configuration option  CVE-2014-3568  ",
        "func_before": "int ssl23_get_client_hello(SSL *s)\n\t{\n\tchar buf_space[11]; /* Request this many bytes in initial read.\n\t                     * We can detect SSL 3.0/TLS 1.0 Client Hellos\n\t                     * ('type == 3') correctly only when the following\n\t                     * is in a single record, which is not guaranteed by\n\t                     * the protocol specification:\n\t                     * Byte  Content\n\t                     *  0     type            \\\n\t                     *  1/2   version          > record header\n\t                     *  3/4   length          /\n\t                     *  5     msg_type        \\\n\t                     *  6-8   length           > Client Hello message\n\t                     *  9/10  client_version  /\n\t                     */\n\tchar *buf= &(buf_space[0]);\n\tunsigned char *p,*d,*d_len,*dd;\n\tunsigned int i;\n\tunsigned int csl,sil,cl;\n\tint n=0,j;\n\tint type=0;\n\tint v[2];\n\n\tif (s->state ==\tSSL23_ST_SR_CLNT_HELLO_A)\n\t\t{\n\t\t/* read the initial header */\n\t\tv[0]=v[1]=0;\n\n\t\tif (!ssl3_setup_buffers(s)) goto err;\n\n\t\tn=ssl23_read_bytes(s, sizeof buf_space);\n\t\tif (n != sizeof buf_space) return(n); /* n == -1 || n == 0 */\n\n\t\tp=s->packet;\n\n\t\tmemcpy(buf,p,n);\n\n\t\tif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\n\t\t\t{\n\t\t\t/*\n\t\t\t * SSLv2 header\n\t\t\t */\n\t\t\tif ((p[3] == 0x00) && (p[4] == 0x02))\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv2 */\n\t\t\t\tif (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\t\t\t\t}\n\t\t\telse if (p[3] == SSL3_VERSION_MAJOR)\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv3/TLSv1 */\n\t\t\t\tif (p[4] >= TLS1_VERSION_MINOR)\n\t\t\t\t\t{\n\t\t\t\t\tif (p[4] >= TLS1_2_VERSION_MINOR &&\n\t\t\t\t\t   !(s->options & SSL_OP_NO_TLSv1_2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=TLS1_2_VERSION;\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (p[4] >= TLS1_1_VERSION_MINOR &&\n\t\t\t\t\t   !(s->options & SSL_OP_NO_TLSv1_1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=TLS1_1_VERSION;\n\t\t\t\t\t\t/* type=2; */ /* done later to survive restarts */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\t\t/* type=2; */ /* done later to survive restarts */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\t\t/* type=2; */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttype=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\t/* type=2; */\n\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\n\t\t\t\t}\n\t\t\t}\n\t\telse if ((p[0] == SSL3_RT_HANDSHAKE) &&\n\t\t\t (p[1] == SSL3_VERSION_MAJOR) &&\n\t\t\t (p[5] == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t ((p[3] == 0 && p[4] < 5 /* silly record length? */)\n\t\t\t\t|| (p[9] >= p[1])))\n\t\t\t{\n\t\t\t/*\n\t\t\t * SSLv3 or tls1 header\n\t\t\t */\n\t\t\t\n\t\t\tv[0]=p[1]; /* major version (= SSL3_VERSION_MAJOR) */\n\t\t\t/* We must look at client_version inside the Client Hello message\n\t\t\t * to get the correct minor version.\n\t\t\t * However if we have only a pathologically small fragment of the\n\t\t\t * Client Hello message, this would be difficult, and we'd have\n\t\t\t * to read more records to find out.\n\t\t\t * No known SSL 3.0 client fragments ClientHello like this,\n\t\t\t * so we simply reject such connections to avoid\n\t\t\t * protocol version downgrade attacks. */\n\t\t\tif (p[3] == 0 && p[4] < 6)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t/* if major version number > 3 set minor to a value\n\t\t\t * which will use the highest version 3 we support.\n\t\t\t * If TLS 2.0 ever appears we will need to revise\n\t\t\t * this....\n\t\t\t */\n\t\t\tif (p[9] > SSL3_VERSION_MAJOR)\n\t\t\t\tv[1]=0xff;\n\t\t\telse\n\t\t\t\tv[1]=p[10]; /* minor version according to client_version */\n\t\t\tif (v[1] >= TLS1_VERSION_MINOR)\n\t\t\t\t{\n\t\t\t\tif (v[1] >= TLS1_2_VERSION_MINOR &&\n\t\t\t\t\t!(s->options & SSL_OP_NO_TLSv1_2))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=TLS1_2_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (v[1] >= TLS1_1_VERSION_MINOR &&\n\t\t\t\t\t!(s->options & SSL_OP_NO_TLSv1_1))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=TLS1_1_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* client requests SSL 3.0 */\n\t\t\t\tif (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t{\n\t\t\t\t\t/* we won't be able to use TLS of course,\n\t\t\t\t\t * but this will send an appropriate alert */\n\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\n\t\t\t (strncmp(\"POST \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"HEAD \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"PUT \", (char *)p,4) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\telse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t/* ensure that TLS_MAX_VERSION is up-to-date */\n\tOPENSSL_assert(s->version <= TLS_MAX_VERSION);\n\n#ifdef OPENSSL_FIPS\n\tif (FIPS_mode() && (s->version < TLS1_VERSION))\n\t\t{\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,\n\t\t\t\t\tSSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\n\t\tgoto err;\n\t\t}\n#endif\n\n\tif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\n\t\t{\n\t\t/* we have SSLv3/TLSv1 in an SSLv2 header\n\t\t * (other cases skip this state) */\n\n\t\ttype=2;\n\t\tp=s->packet;\n\t\tv[0] = p[3]; /* == SSL3_VERSION_MAJOR */\n\t\tv[1] = p[4];\n\n\t\t/* An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2\n\t\t * header is sent directly on the wire, not wrapped as a TLS\n\t\t * record. It's format is:\n\t\t * Byte  Content\n\t\t * 0-1   msg_length\n\t\t * 2     msg_type\n\t\t * 3-4   version\n\t\t * 5-6   cipher_spec_length\n\t\t * 7-8   session_id_length\n\t\t * 9-10  challenge_length\n\t\t * ...   ...\n\t\t */\n\t\tn=((p[0]&0x7f)<<8)|p[1];\n\t\tif (n > (1024*4))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (n < 9)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tj=ssl23_read_bytes(s,n+2);\n\t\t/* We previously read 11 bytes, so if j > 0, we must have\n\t\t * j == n+2 == s->packet_length. We have at least 11 valid\n\t\t * packet bytes. */\n\t\tif (j <= 0) return(j);\n\n\t\tssl3_finish_mac(s, s->packet+2, s->packet_length-2);\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */\n\n\t\tp=s->packet;\n\t\tp+=5;\n\t\tn2s(p,csl);\n\t\tn2s(p,sil);\n\t\tn2s(p,cl);\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tif ((csl+sil+cl+11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format\n\t\t                                          * Client Hello, can we? Error condition should be\n\t\t                                          * '>' otherweise */\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* record header: msg_type ... */\n\t\t*(d++) = SSL3_MT_CLIENT_HELLO;\n\t\t/* ... and length (actual value will be written later) */\n\t\td_len = d;\n\t\td += 3;\n\n\t\t/* client_version */\n\t\t*(d++) = SSL3_VERSION_MAJOR; /* == v[0] */\n\t\t*(d++) = v[1];\n\n\t\t/* lets populate the random area */\n\t\t/* get the challenge_length */\n\t\ti=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\n\t\tmemset(d,0,SSL3_RANDOM_SIZE);\n\t\tmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\n\t\td+=SSL3_RANDOM_SIZE;\n\n\t\t/* no session-id reuse */\n\t\t*(d++)=0;\n\n\t\t/* ciphers */\n\t\tj=0;\n\t\tdd=d;\n\t\td+=2;\n\t\tfor (i=0; i<csl; i+=3)\n\t\t\t{\n\t\t\tif (p[i] != 0) continue;\n\t\t\t*(d++)=p[i+1];\n\t\t\t*(d++)=p[i+2];\n\t\t\tj+=2;\n\t\t\t}\n\t\ts2n(j,dd);\n\n\t\t/* COMPRESSION */\n\t\t*(d++)=1;\n\t\t*(d++)=0;\n\t\t\n#if 0\n                /* copy any remaining data with may be extensions */\n\t        p = p+csl+sil+cl;\n\t\twhile (p <  s->packet+s->packet_length)\n\t\t\t{\n\t\t\t*(d++)=*(p++);\n\t\t\t}\n#endif\n\n\t\ti = (d-(unsigned char *)s->init_buf->data) - 4;\n\t\tl2n3((long)i, d_len);\n\n\t\t/* get the data reused from the init_buf */\n\t\ts->s3->tmp.reuse_message=1;\n\t\ts->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\n\t\ts->s3->tmp.message_size=i;\n\t\t}\n\n\t/* imaginary new state (for program structure): */\n\t/* s->state = SSL23_SR_CLNT_HELLO_C */\n\n\tif (type == 1)\n\t\t{\n#ifdef OPENSSL_NO_SSL2\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\tgoto err;\n#else\n\t\t/* we are talking sslv2 */\n\t\t/* we need to clean up the SSLv3/TLSv1 setup and put in the\n\t\t * sslv2 stuff. */\n\n\t\tif (s->s2 == NULL)\n\t\t\t{\n\t\t\tif (!ssl2_new(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n\t\t\tssl2_clear(s);\n\n\t\tif (s->s3 != NULL) ssl3_free(s);\n\n\t\tif (!BUF_MEM_grow_clean(s->init_buf,\n\t\t\tSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n\t\t\t{\n\t\t\tgoto err;\n\t\t\t}\n\n\t\ts->state=SSL2_ST_GET_CLIENT_HELLO_A;\n\t\tif (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)\n\t\t\ts->s2->ssl2_rollback=0;\n\t\telse\n\t\t\t/* reject SSL 2.0 session if client supports SSL 3.0 or TLS 1.0\n\t\t\t * (SSL 3.0 draft/RFC 2246, App. E.2) */\n\t\t\ts->s2->ssl2_rollback=1;\n\n\t\t/* setup the n bytes we have read so we get them from\n\t\t * the sslv2 buffer */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\ts->packet= &(s->s2->rbuf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s2->rbuf_left=n;\n\t\ts->s2->rbuf_offs=0;\n\n\t\ts->method=SSLv2_server_method();\n\t\ts->handshake_func=s->method->ssl_accept;\n#endif\n\t\t}\n\n\tif ((type == 2) || (type == 3))\n\t\t{\n\t\t/* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */\n\n\t\tif (!ssl_init_wbio_buffer(s,1)) goto err;\n\n\t\t/* we are in this state */\n\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\n\t\tif (type == 3)\n\t\t\t{\n\t\t\t/* put the 'n' bytes we have read into the input buffer\n\t\t\t * for SSLv3 */\n\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\ts->packet_length=n;\n\t\t\tif (s->s3->rbuf.buf == NULL)\n\t\t\t\tif (!ssl3_setup_read_buffer(s))\n\t\t\t\t\tgoto err;\n\n\t\t\ts->packet= &(s->s3->rbuf.buf[0]);\n\t\t\tmemcpy(s->packet,buf,n);\n\t\t\ts->s3->rbuf.left=n;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ts->packet_length=0;\n\t\t\ts->s3->rbuf.left=0;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\t\tif (s->version == TLS1_2_VERSION)\n\t\t\ts->method = TLSv1_2_server_method();\n\t\telse if (s->version == TLS1_1_VERSION)\n\t\t\ts->method = TLSv1_1_server_method();\n\t\telse if (s->version == TLS1_VERSION)\n\t\t\ts->method = TLSv1_server_method();\n\t\telse\n\t\t\ts->method = SSLv3_server_method();\n#if 0 /* ssl3_get_client_hello does this */\n\t\ts->client_version=(v[0]<<8)|v[1];\n#endif\n\t\ts->handshake_func=s->method->ssl_accept;\n\t\t}\n\t\n\tif ((type < 1) || (type > 3))\n\t\t{\n\t\t/* bad, very bad */\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\n\t\tgoto err;\n\t\t}\n\ts->init_num=0;\n\n\tif (buf != buf_space) OPENSSL_free(buf);\n\treturn(SSL_accept(s));\nerr:\n\tif (buf != buf_space) OPENSSL_free(buf);\n\treturn(-1);\n\t}",
        "func": "int ssl23_get_client_hello(SSL *s)\n\t{\n\tchar buf_space[11]; /* Request this many bytes in initial read.\n\t                     * We can detect SSL 3.0/TLS 1.0 Client Hellos\n\t                     * ('type == 3') correctly only when the following\n\t                     * is in a single record, which is not guaranteed by\n\t                     * the protocol specification:\n\t                     * Byte  Content\n\t                     *  0     type            \\\n\t                     *  1/2   version          > record header\n\t                     *  3/4   length          /\n\t                     *  5     msg_type        \\\n\t                     *  6-8   length           > Client Hello message\n\t                     *  9/10  client_version  /\n\t                     */\n\tchar *buf= &(buf_space[0]);\n\tunsigned char *p,*d,*d_len,*dd;\n\tunsigned int i;\n\tunsigned int csl,sil,cl;\n\tint n=0,j;\n\tint type=0;\n\tint v[2];\n\n\tif (s->state ==\tSSL23_ST_SR_CLNT_HELLO_A)\n\t\t{\n\t\t/* read the initial header */\n\t\tv[0]=v[1]=0;\n\n\t\tif (!ssl3_setup_buffers(s)) goto err;\n\n\t\tn=ssl23_read_bytes(s, sizeof buf_space);\n\t\tif (n != sizeof buf_space) return(n); /* n == -1 || n == 0 */\n\n\t\tp=s->packet;\n\n\t\tmemcpy(buf,p,n);\n\n\t\tif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\n\t\t\t{\n\t\t\t/*\n\t\t\t * SSLv2 header\n\t\t\t */\n\t\t\tif ((p[3] == 0x00) && (p[4] == 0x02))\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv2 */\n\t\t\t\tif (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\t\t\t\t}\n\t\t\telse if (p[3] == SSL3_VERSION_MAJOR)\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv3/TLSv1 */\n\t\t\t\tif (p[4] >= TLS1_VERSION_MINOR)\n\t\t\t\t\t{\n\t\t\t\t\tif (p[4] >= TLS1_2_VERSION_MINOR &&\n\t\t\t\t\t   !(s->options & SSL_OP_NO_TLSv1_2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=TLS1_2_VERSION;\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (p[4] >= TLS1_1_VERSION_MINOR &&\n\t\t\t\t\t   !(s->options & SSL_OP_NO_TLSv1_1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=TLS1_1_VERSION;\n\t\t\t\t\t\t/* type=2; */ /* done later to survive restarts */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\t\t/* type=2; */ /* done later to survive restarts */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\t\t/* type=2; */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttype=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\t/* type=2; */\n\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\n\t\t\t\t}\n\t\t\t}\n\t\telse if ((p[0] == SSL3_RT_HANDSHAKE) &&\n\t\t\t (p[1] == SSL3_VERSION_MAJOR) &&\n\t\t\t (p[5] == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t ((p[3] == 0 && p[4] < 5 /* silly record length? */)\n\t\t\t\t|| (p[9] >= p[1])))\n\t\t\t{\n\t\t\t/*\n\t\t\t * SSLv3 or tls1 header\n\t\t\t */\n\t\t\t\n\t\t\tv[0]=p[1]; /* major version (= SSL3_VERSION_MAJOR) */\n\t\t\t/* We must look at client_version inside the Client Hello message\n\t\t\t * to get the correct minor version.\n\t\t\t * However if we have only a pathologically small fragment of the\n\t\t\t * Client Hello message, this would be difficult, and we'd have\n\t\t\t * to read more records to find out.\n\t\t\t * No known SSL 3.0 client fragments ClientHello like this,\n\t\t\t * so we simply reject such connections to avoid\n\t\t\t * protocol version downgrade attacks. */\n\t\t\tif (p[3] == 0 && p[4] < 6)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t/* if major version number > 3 set minor to a value\n\t\t\t * which will use the highest version 3 we support.\n\t\t\t * If TLS 2.0 ever appears we will need to revise\n\t\t\t * this....\n\t\t\t */\n\t\t\tif (p[9] > SSL3_VERSION_MAJOR)\n\t\t\t\tv[1]=0xff;\n\t\t\telse\n\t\t\t\tv[1]=p[10]; /* minor version according to client_version */\n\t\t\tif (v[1] >= TLS1_VERSION_MINOR)\n\t\t\t\t{\n\t\t\t\tif (v[1] >= TLS1_2_VERSION_MINOR &&\n\t\t\t\t\t!(s->options & SSL_OP_NO_TLSv1_2))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=TLS1_2_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (v[1] >= TLS1_1_VERSION_MINOR &&\n\t\t\t\t\t!(s->options & SSL_OP_NO_TLSv1_1))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=TLS1_1_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* client requests SSL 3.0 */\n\t\t\t\tif (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\ts->version=SSL3_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t{\n\t\t\t\t\t/* we won't be able to use TLS of course,\n\t\t\t\t\t * but this will send an appropriate alert */\n\t\t\t\t\ts->version=TLS1_VERSION;\n\t\t\t\t\ttype=3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\n\t\t\t (strncmp(\"POST \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"HEAD \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"PUT \", (char *)p,4) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\telse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t/* ensure that TLS_MAX_VERSION is up-to-date */\n\tOPENSSL_assert(s->version <= TLS_MAX_VERSION);\n\n#ifdef OPENSSL_FIPS\n\tif (FIPS_mode() && (s->version < TLS1_VERSION))\n\t\t{\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,\n\t\t\t\t\tSSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\n\t\tgoto err;\n\t\t}\n#endif\n\n\tif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\n\t\t{\n\t\t/* we have SSLv3/TLSv1 in an SSLv2 header\n\t\t * (other cases skip this state) */\n\n\t\ttype=2;\n\t\tp=s->packet;\n\t\tv[0] = p[3]; /* == SSL3_VERSION_MAJOR */\n\t\tv[1] = p[4];\n\n\t\t/* An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2\n\t\t * header is sent directly on the wire, not wrapped as a TLS\n\t\t * record. It's format is:\n\t\t * Byte  Content\n\t\t * 0-1   msg_length\n\t\t * 2     msg_type\n\t\t * 3-4   version\n\t\t * 5-6   cipher_spec_length\n\t\t * 7-8   session_id_length\n\t\t * 9-10  challenge_length\n\t\t * ...   ...\n\t\t */\n\t\tn=((p[0]&0x7f)<<8)|p[1];\n\t\tif (n > (1024*4))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (n < 9)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tj=ssl23_read_bytes(s,n+2);\n\t\t/* We previously read 11 bytes, so if j > 0, we must have\n\t\t * j == n+2 == s->packet_length. We have at least 11 valid\n\t\t * packet bytes. */\n\t\tif (j <= 0) return(j);\n\n\t\tssl3_finish_mac(s, s->packet+2, s->packet_length-2);\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */\n\n\t\tp=s->packet;\n\t\tp+=5;\n\t\tn2s(p,csl);\n\t\tn2s(p,sil);\n\t\tn2s(p,cl);\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tif ((csl+sil+cl+11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format\n\t\t                                          * Client Hello, can we? Error condition should be\n\t\t                                          * '>' otherweise */\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* record header: msg_type ... */\n\t\t*(d++) = SSL3_MT_CLIENT_HELLO;\n\t\t/* ... and length (actual value will be written later) */\n\t\td_len = d;\n\t\td += 3;\n\n\t\t/* client_version */\n\t\t*(d++) = SSL3_VERSION_MAJOR; /* == v[0] */\n\t\t*(d++) = v[1];\n\n\t\t/* lets populate the random area */\n\t\t/* get the challenge_length */\n\t\ti=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\n\t\tmemset(d,0,SSL3_RANDOM_SIZE);\n\t\tmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\n\t\td+=SSL3_RANDOM_SIZE;\n\n\t\t/* no session-id reuse */\n\t\t*(d++)=0;\n\n\t\t/* ciphers */\n\t\tj=0;\n\t\tdd=d;\n\t\td+=2;\n\t\tfor (i=0; i<csl; i+=3)\n\t\t\t{\n\t\t\tif (p[i] != 0) continue;\n\t\t\t*(d++)=p[i+1];\n\t\t\t*(d++)=p[i+2];\n\t\t\tj+=2;\n\t\t\t}\n\t\ts2n(j,dd);\n\n\t\t/* COMPRESSION */\n\t\t*(d++)=1;\n\t\t*(d++)=0;\n\t\t\n#if 0\n                /* copy any remaining data with may be extensions */\n\t        p = p+csl+sil+cl;\n\t\twhile (p <  s->packet+s->packet_length)\n\t\t\t{\n\t\t\t*(d++)=*(p++);\n\t\t\t}\n#endif\n\n\t\ti = (d-(unsigned char *)s->init_buf->data) - 4;\n\t\tl2n3((long)i, d_len);\n\n\t\t/* get the data reused from the init_buf */\n\t\ts->s3->tmp.reuse_message=1;\n\t\ts->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\n\t\ts->s3->tmp.message_size=i;\n\t\t}\n\n\t/* imaginary new state (for program structure): */\n\t/* s->state = SSL23_SR_CLNT_HELLO_C */\n\n\tif (type == 1)\n\t\t{\n#ifdef OPENSSL_NO_SSL2\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\tgoto err;\n#else\n\t\t/* we are talking sslv2 */\n\t\t/* we need to clean up the SSLv3/TLSv1 setup and put in the\n\t\t * sslv2 stuff. */\n\n\t\tif (s->s2 == NULL)\n\t\t\t{\n\t\t\tif (!ssl2_new(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n\t\t\tssl2_clear(s);\n\n\t\tif (s->s3 != NULL) ssl3_free(s);\n\n\t\tif (!BUF_MEM_grow_clean(s->init_buf,\n\t\t\tSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n\t\t\t{\n\t\t\tgoto err;\n\t\t\t}\n\n\t\ts->state=SSL2_ST_GET_CLIENT_HELLO_A;\n\t\tif (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)\n\t\t\ts->s2->ssl2_rollback=0;\n\t\telse\n\t\t\t/* reject SSL 2.0 session if client supports SSL 3.0 or TLS 1.0\n\t\t\t * (SSL 3.0 draft/RFC 2246, App. E.2) */\n\t\t\ts->s2->ssl2_rollback=1;\n\n\t\t/* setup the n bytes we have read so we get them from\n\t\t * the sslv2 buffer */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\ts->packet= &(s->s2->rbuf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s2->rbuf_left=n;\n\t\ts->s2->rbuf_offs=0;\n\n\t\ts->method=SSLv2_server_method();\n\t\ts->handshake_func=s->method->ssl_accept;\n#endif\n\t\t}\n\n\tif ((type == 2) || (type == 3))\n\t\t{\n\t\t/* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */\n                s->method = ssl23_get_server_method(s->version);\n\t\tif (s->method == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (!ssl_init_wbio_buffer(s,1)) goto err;\n\n\t\t/* we are in this state */\n\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\n\t\tif (type == 3)\n\t\t\t{\n\t\t\t/* put the 'n' bytes we have read into the input buffer\n\t\t\t * for SSLv3 */\n\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\ts->packet_length=n;\n\t\t\tif (s->s3->rbuf.buf == NULL)\n\t\t\t\tif (!ssl3_setup_read_buffer(s))\n\t\t\t\t\tgoto err;\n\n\t\t\ts->packet= &(s->s3->rbuf.buf[0]);\n\t\t\tmemcpy(s->packet,buf,n);\n\t\t\ts->s3->rbuf.left=n;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ts->packet_length=0;\n\t\t\ts->s3->rbuf.left=0;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n#if 0 /* ssl3_get_client_hello does this */\n\t\ts->client_version=(v[0]<<8)|v[1];\n#endif\n\t\ts->handshake_func=s->method->ssl_accept;\n\t\t}\n\t\n\tif ((type < 1) || (type > 3))\n\t\t{\n\t\t/* bad, very bad */\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\n\t\tgoto err;\n\t\t}\n\ts->init_num=0;\n\n\tif (buf != buf_space) OPENSSL_free(buf);\n\treturn(SSL_accept(s));\nerr:\n\tif (buf != buf_space) OPENSSL_free(buf);\n\treturn(-1);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -363,6 +363,12 @@\n \tif ((type == 2) || (type == 3))\n \t\t{\n \t\t/* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */\n+                s->method = ssl23_get_server_method(s->version);\n+\t\tif (s->method == NULL)\n+\t\t\t{\n+\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\n+\t\t\tgoto err;\n+\t\t\t}\n \n \t\tif (!ssl_init_wbio_buffer(s,1)) goto err;\n \n@@ -390,14 +396,6 @@\n \t\t\ts->s3->rbuf.left=0;\n \t\t\ts->s3->rbuf.offset=0;\n \t\t\t}\n-\t\tif (s->version == TLS1_2_VERSION)\n-\t\t\ts->method = TLSv1_2_server_method();\n-\t\telse if (s->version == TLS1_1_VERSION)\n-\t\t\ts->method = TLSv1_1_server_method();\n-\t\telse if (s->version == TLS1_VERSION)\n-\t\t\ts->method = TLSv1_server_method();\n-\t\telse\n-\t\t\ts->method = SSLv3_server_method();\n #if 0 /* ssl3_get_client_hello does this */\n \t\ts->client_version=(v[0]<<8)|v[1];\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (s->version == TLS1_2_VERSION)",
                "\t\t\ts->method = TLSv1_2_server_method();",
                "\t\telse if (s->version == TLS1_1_VERSION)",
                "\t\t\ts->method = TLSv1_1_server_method();",
                "\t\telse if (s->version == TLS1_VERSION)",
                "\t\t\ts->method = TLSv1_server_method();",
                "\t\telse",
                "\t\t\ts->method = SSLv3_server_method();"
            ],
            "added_lines": [
                "                s->method = ssl23_get_server_method(s->version);",
                "\t\tif (s->method == NULL)",
                "\t\t\t{",
                "\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);",
                "\t\t\tgoto err;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-3568",
        "func_name": "openssl/ssl23_get_server_method",
        "description": "OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=26a59d9b46574e457870197dffa802871b4c8fc7",
        "commit_title": "",
        "commit_text": "Fix no-ssl3 configuration option  CVE-2014-3568  ",
        "func_before": "static const SSL_METHOD *ssl23_get_server_method(int ver)\n\t{\n#ifndef OPENSSL_NO_SSL2\n\tif (ver == SSL2_VERSION)\n\t\treturn(SSLv2_server_method());\n#endif\n\tif (ver == SSL3_VERSION)\n\t\treturn(SSLv3_server_method());\n\telse if (ver == TLS1_VERSION)\n\t\treturn(TLSv1_server_method());\n\telse if (ver == TLS1_1_VERSION)\n\t\treturn(TLSv1_1_server_method());\n\telse if (ver == TLS1_2_VERSION)\n\t\treturn(TLSv1_2_server_method());\n\telse\n\t\treturn(NULL);\n\t}",
        "func": "static const SSL_METHOD *ssl23_get_server_method(int ver)\n\t{\n#ifndef OPENSSL_NO_SSL2\n\tif (ver == SSL2_VERSION)\n\t\treturn(SSLv2_server_method());\n#endif\n#ifndef OPENSSL_NO_SSL3\n\tif (ver == SSL3_VERSION)\n\t\treturn(SSLv3_server_method());\n#endif\n\tif (ver == TLS1_VERSION)\n\t\treturn(TLSv1_server_method());\n\telse if (ver == TLS1_1_VERSION)\n\t\treturn(TLSv1_1_server_method());\n\telse if (ver == TLS1_2_VERSION)\n\t\treturn(TLSv1_2_server_method());\n\telse\n\t\treturn(NULL);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,11 @@\n \tif (ver == SSL2_VERSION)\n \t\treturn(SSLv2_server_method());\n #endif\n+#ifndef OPENSSL_NO_SSL3\n \tif (ver == SSL3_VERSION)\n \t\treturn(SSLv3_server_method());\n-\telse if (ver == TLS1_VERSION)\n+#endif\n+\tif (ver == TLS1_VERSION)\n \t\treturn(TLSv1_server_method());\n \telse if (ver == TLS1_1_VERSION)\n \t\treturn(TLSv1_1_server_method());",
        "diff_line_info": {
            "deleted_lines": [
                "\telse if (ver == TLS1_VERSION)"
            ],
            "added_lines": [
                "#ifndef OPENSSL_NO_SSL3",
                "#endif",
                "\tif (ver == TLS1_VERSION)"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-5386",
        "func_name": "facebook/hhvm/HHVM_FUNCTION",
        "description": "The mcrypt_create_iv function in hphp/runtime/ext/mcrypt/ext_mcrypt.cpp in Facebook HipHop Virtual Machine (HHVM) before 3.3.0 does not seed the random number generator, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging the use of a single initialization vector.",
        "git_url": "https://github.com/facebook/hhvm/commit/ab6fdeb84fb090b48606b6f7933028cfe7bf3a5e",
        "commit_title": "Fix mcrypt_create_iv(..., MCRYPT_RAND) to auto-seed RNG",
        "commit_text": " Summary: Without seeding the random number generator, we'll always get the same IV, and that reduces the security of this function.  Fortunately, f_rand() has all of that logic for auto-seeding and selection of a suitable initial seed built-in.  Realistically, using MCRYPT_RAND should be deprecated. I'm going to wait on PHP Internals to make a decision on https://wiki.php.net/rfc/deprecate_mcrypt_rand before adding that warning however, so that our test suite remains consistent.  Credit: Theodore R. Smith of PHP Experts, Inc. <theodorephpexperts.pro>  Closes #3496  Reviewed By: @ptarjan  Differential Revision: D1502435",
        "func_before": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source /* = 0 */) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}",
        "func": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source /* = 0 */) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      // Use userspace rand() function because it handles auto-seeding\n      iv[--size] = (char)f_rand(0, 255);\n    }\n  }\n  return String(iv, n, AttachString);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,8 @@\n   } else {\n     n = size;\n     while (size) {\n-      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n+      // Use userspace rand() function because it handles auto-seeding\n+      iv[--size] = (char)f_rand(0, 255);\n     }\n   }\n   return String(iv, n, AttachString);",
        "diff_line_info": {
            "deleted_lines": [
                "      iv[--size] = (char)(255.0 * rand() / RAND_MAX);"
            ],
            "added_lines": [
                "      // Use userspace rand() function because it handles auto-seeding",
                "      iv[--size] = (char)f_rand(0, 255);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-3570",
        "func_name": "openssl/bn_sqr_comba8",
        "description": "The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",
        "git_url": "https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0",
        "commit_title": "Fix for CVE-2014-3570 (with minor bn_asm.c revamp).",
        "commit_text": "",
        "func_before": "void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t,tt;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tsqr_add_c2(a,4,0,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,5,0,c3,c1,c2);\n\tsqr_add_c2(a,4,1,c3,c1,c2);\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tsqr_add_c2(a,4,2,c1,c2,c3);\n\tsqr_add_c2(a,5,1,c1,c2,c3);\n\tsqr_add_c2(a,6,0,c1,c2,c3);\n\tr[6]=c1;\n\tc1=0;\n\tsqr_add_c2(a,7,0,c2,c3,c1);\n\tsqr_add_c2(a,6,1,c2,c3,c1);\n\tsqr_add_c2(a,5,2,c2,c3,c1);\n\tsqr_add_c2(a,4,3,c2,c3,c1);\n\tr[7]=c2;\n\tc2=0;\n\tsqr_add_c(a,4,c3,c1,c2);\n\tsqr_add_c2(a,5,3,c3,c1,c2);\n\tsqr_add_c2(a,6,2,c3,c1,c2);\n\tsqr_add_c2(a,7,1,c3,c1,c2);\n\tr[8]=c3;\n\tc3=0;\n\tsqr_add_c2(a,7,2,c1,c2,c3);\n\tsqr_add_c2(a,6,3,c1,c2,c3);\n\tsqr_add_c2(a,5,4,c1,c2,c3);\n\tr[9]=c1;\n\tc1=0;\n\tsqr_add_c(a,5,c2,c3,c1);\n\tsqr_add_c2(a,6,4,c2,c3,c1);\n\tsqr_add_c2(a,7,3,c2,c3,c1);\n\tr[10]=c2;\n\tc2=0;\n\tsqr_add_c2(a,7,4,c3,c1,c2);\n\tsqr_add_c2(a,6,5,c3,c1,c2);\n\tr[11]=c3;\n\tc3=0;\n\tsqr_add_c(a,6,c1,c2,c3);\n\tsqr_add_c2(a,7,5,c1,c2,c3);\n\tr[12]=c1;\n\tc1=0;\n\tsqr_add_c2(a,7,6,c2,c3,c1);\n\tr[13]=c2;\n\tc2=0;\n\tsqr_add_c(a,7,c3,c1,c2);\n\tr[14]=c3;\n\tr[15]=c1;\n\t}",
        "func": "void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tsqr_add_c2(a,4,0,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,5,0,c3,c1,c2);\n\tsqr_add_c2(a,4,1,c3,c1,c2);\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tsqr_add_c2(a,4,2,c1,c2,c3);\n\tsqr_add_c2(a,5,1,c1,c2,c3);\n\tsqr_add_c2(a,6,0,c1,c2,c3);\n\tr[6]=c1;\n\tc1=0;\n\tsqr_add_c2(a,7,0,c2,c3,c1);\n\tsqr_add_c2(a,6,1,c2,c3,c1);\n\tsqr_add_c2(a,5,2,c2,c3,c1);\n\tsqr_add_c2(a,4,3,c2,c3,c1);\n\tr[7]=c2;\n\tc2=0;\n\tsqr_add_c(a,4,c3,c1,c2);\n\tsqr_add_c2(a,5,3,c3,c1,c2);\n\tsqr_add_c2(a,6,2,c3,c1,c2);\n\tsqr_add_c2(a,7,1,c3,c1,c2);\n\tr[8]=c3;\n\tc3=0;\n\tsqr_add_c2(a,7,2,c1,c2,c3);\n\tsqr_add_c2(a,6,3,c1,c2,c3);\n\tsqr_add_c2(a,5,4,c1,c2,c3);\n\tr[9]=c1;\n\tc1=0;\n\tsqr_add_c(a,5,c2,c3,c1);\n\tsqr_add_c2(a,6,4,c2,c3,c1);\n\tsqr_add_c2(a,7,3,c2,c3,c1);\n\tr[10]=c2;\n\tc2=0;\n\tsqr_add_c2(a,7,4,c3,c1,c2);\n\tsqr_add_c2(a,6,5,c3,c1,c2);\n\tr[11]=c3;\n\tc3=0;\n\tsqr_add_c(a,6,c1,c2,c3);\n\tsqr_add_c2(a,7,5,c1,c2,c3);\n\tr[12]=c1;\n\tc1=0;\n\tsqr_add_c2(a,7,6,c2,c3,c1);\n\tr[13]=c2;\n\tc2=0;\n\tsqr_add_c(a,7,c3,c1,c2);\n\tr[14]=c3;\n\tr[15]=c1;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,5 @@\n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef BN_LLONG",
                "\tBN_ULLONG t,tt;",
                "#else",
                "\tBN_ULONG bl,bh;",
                "#endif",
                "\tBN_ULONG t1,t2;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2014-3570",
        "func_name": "openssl/bn_mul_comba8",
        "description": "The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",
        "git_url": "https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0",
        "commit_title": "Fix for CVE-2014-3570 (with minor bn_asm.c revamp).",
        "commit_text": "",
        "func_before": "void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[4],b[0],c2,c3,c1);\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tmul_add_c(a[0],b[4],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[0],b[5],c3,c1,c2);\n\tmul_add_c(a[1],b[4],c3,c1,c2);\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tmul_add_c(a[4],b[1],c3,c1,c2);\n\tmul_add_c(a[5],b[0],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[6],b[0],c1,c2,c3);\n\tmul_add_c(a[5],b[1],c1,c2,c3);\n\tmul_add_c(a[4],b[2],c1,c2,c3);\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tmul_add_c(a[2],b[4],c1,c2,c3);\n\tmul_add_c(a[1],b[5],c1,c2,c3);\n\tmul_add_c(a[0],b[6],c1,c2,c3);\n\tr[6]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[7],c2,c3,c1);\n\tmul_add_c(a[1],b[6],c2,c3,c1);\n\tmul_add_c(a[2],b[5],c2,c3,c1);\n\tmul_add_c(a[3],b[4],c2,c3,c1);\n\tmul_add_c(a[4],b[3],c2,c3,c1);\n\tmul_add_c(a[5],b[2],c2,c3,c1);\n\tmul_add_c(a[6],b[1],c2,c3,c1);\n\tmul_add_c(a[7],b[0],c2,c3,c1);\n\tr[7]=c2;\n\tc2=0;\n\tmul_add_c(a[7],b[1],c3,c1,c2);\n\tmul_add_c(a[6],b[2],c3,c1,c2);\n\tmul_add_c(a[5],b[3],c3,c1,c2);\n\tmul_add_c(a[4],b[4],c3,c1,c2);\n\tmul_add_c(a[3],b[5],c3,c1,c2);\n\tmul_add_c(a[2],b[6],c3,c1,c2);\n\tmul_add_c(a[1],b[7],c3,c1,c2);\n\tr[8]=c3;\n\tc3=0;\n\tmul_add_c(a[2],b[7],c1,c2,c3);\n\tmul_add_c(a[3],b[6],c1,c2,c3);\n\tmul_add_c(a[4],b[5],c1,c2,c3);\n\tmul_add_c(a[5],b[4],c1,c2,c3);\n\tmul_add_c(a[6],b[3],c1,c2,c3);\n\tmul_add_c(a[7],b[2],c1,c2,c3);\n\tr[9]=c1;\n\tc1=0;\n\tmul_add_c(a[7],b[3],c2,c3,c1);\n\tmul_add_c(a[6],b[4],c2,c3,c1);\n\tmul_add_c(a[5],b[5],c2,c3,c1);\n\tmul_add_c(a[4],b[6],c2,c3,c1);\n\tmul_add_c(a[3],b[7],c2,c3,c1);\n\tr[10]=c2;\n\tc2=0;\n\tmul_add_c(a[4],b[7],c3,c1,c2);\n\tmul_add_c(a[5],b[6],c3,c1,c2);\n\tmul_add_c(a[6],b[5],c3,c1,c2);\n\tmul_add_c(a[7],b[4],c3,c1,c2);\n\tr[11]=c3;\n\tc3=0;\n\tmul_add_c(a[7],b[5],c1,c2,c3);\n\tmul_add_c(a[6],b[6],c1,c2,c3);\n\tmul_add_c(a[5],b[7],c1,c2,c3);\n\tr[12]=c1;\n\tc1=0;\n\tmul_add_c(a[6],b[7],c2,c3,c1);\n\tmul_add_c(a[7],b[6],c2,c3,c1);\n\tr[13]=c2;\n\tc2=0;\n\tmul_add_c(a[7],b[7],c3,c1,c2);\n\tr[14]=c3;\n\tr[15]=c1;\n\t}",
        "func": "void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[4],b[0],c2,c3,c1);\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tmul_add_c(a[0],b[4],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[0],b[5],c3,c1,c2);\n\tmul_add_c(a[1],b[4],c3,c1,c2);\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tmul_add_c(a[4],b[1],c3,c1,c2);\n\tmul_add_c(a[5],b[0],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[6],b[0],c1,c2,c3);\n\tmul_add_c(a[5],b[1],c1,c2,c3);\n\tmul_add_c(a[4],b[2],c1,c2,c3);\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tmul_add_c(a[2],b[4],c1,c2,c3);\n\tmul_add_c(a[1],b[5],c1,c2,c3);\n\tmul_add_c(a[0],b[6],c1,c2,c3);\n\tr[6]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[7],c2,c3,c1);\n\tmul_add_c(a[1],b[6],c2,c3,c1);\n\tmul_add_c(a[2],b[5],c2,c3,c1);\n\tmul_add_c(a[3],b[4],c2,c3,c1);\n\tmul_add_c(a[4],b[3],c2,c3,c1);\n\tmul_add_c(a[5],b[2],c2,c3,c1);\n\tmul_add_c(a[6],b[1],c2,c3,c1);\n\tmul_add_c(a[7],b[0],c2,c3,c1);\n\tr[7]=c2;\n\tc2=0;\n\tmul_add_c(a[7],b[1],c3,c1,c2);\n\tmul_add_c(a[6],b[2],c3,c1,c2);\n\tmul_add_c(a[5],b[3],c3,c1,c2);\n\tmul_add_c(a[4],b[4],c3,c1,c2);\n\tmul_add_c(a[3],b[5],c3,c1,c2);\n\tmul_add_c(a[2],b[6],c3,c1,c2);\n\tmul_add_c(a[1],b[7],c3,c1,c2);\n\tr[8]=c3;\n\tc3=0;\n\tmul_add_c(a[2],b[7],c1,c2,c3);\n\tmul_add_c(a[3],b[6],c1,c2,c3);\n\tmul_add_c(a[4],b[5],c1,c2,c3);\n\tmul_add_c(a[5],b[4],c1,c2,c3);\n\tmul_add_c(a[6],b[3],c1,c2,c3);\n\tmul_add_c(a[7],b[2],c1,c2,c3);\n\tr[9]=c1;\n\tc1=0;\n\tmul_add_c(a[7],b[3],c2,c3,c1);\n\tmul_add_c(a[6],b[4],c2,c3,c1);\n\tmul_add_c(a[5],b[5],c2,c3,c1);\n\tmul_add_c(a[4],b[6],c2,c3,c1);\n\tmul_add_c(a[3],b[7],c2,c3,c1);\n\tr[10]=c2;\n\tc2=0;\n\tmul_add_c(a[4],b[7],c3,c1,c2);\n\tmul_add_c(a[5],b[6],c3,c1,c2);\n\tmul_add_c(a[6],b[5],c3,c1,c2);\n\tmul_add_c(a[7],b[4],c3,c1,c2);\n\tr[11]=c3;\n\tc3=0;\n\tmul_add_c(a[7],b[5],c1,c2,c3);\n\tmul_add_c(a[6],b[6],c1,c2,c3);\n\tmul_add_c(a[5],b[7],c1,c2,c3);\n\tr[12]=c1;\n\tc1=0;\n\tmul_add_c(a[6],b[7],c2,c3,c1);\n\tmul_add_c(a[7],b[6],c2,c3,c1);\n\tr[13]=c2;\n\tc2=0;\n\tmul_add_c(a[7],b[7],c3,c1,c2);\n\tr[14]=c3;\n\tr[15]=c1;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,5 @@\n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef BN_LLONG",
                "\tBN_ULLONG t;",
                "#else",
                "\tBN_ULONG bl,bh;",
                "#endif",
                "\tBN_ULONG t1,t2;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2014-3570",
        "func_name": "openssl/bn_mul_comba4",
        "description": "The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",
        "git_url": "https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0",
        "commit_title": "Fix for CVE-2014-3570 (with minor bn_asm.c revamp).",
        "commit_text": "",
        "func_before": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}",
        "func": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,5 @@\n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef BN_LLONG",
                "\tBN_ULLONG t;",
                "#else",
                "\tBN_ULONG bl,bh;",
                "#endif",
                "\tBN_ULONG t1,t2;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2014-3570",
        "func_name": "openssl/bn_sqr_comba4",
        "description": "The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",
        "git_url": "https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0",
        "commit_title": "Fix for CVE-2014-3570 (with minor bn_asm.c revamp).",
        "commit_text": "",
        "func_before": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t,tt;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}",
        "func": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,5 @@\n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef BN_LLONG",
                "\tBN_ULLONG t,tt;",
                "#else",
                "\tBN_ULONG bl,bh;",
                "#endif",
                "\tBN_ULONG t1,t2;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2014-3572",
        "func_name": "openssl/ssl3_get_key_exchange",
        "description": "The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct ECDHE-to-ECDH downgrade attacks and trigger a loss of forward secrecy by omitting the ServerKeyExchange message.",
        "git_url": "https://github.com/openssl/openssl/commit/b15f8769644b00ef7283521593360b7b2135cb63",
        "commit_title": "ECDH downgrade bug fix.",
        "commit_text": " Fix bug where an OpenSSL client would accept a handshake using an ephemeral ECDH ciphersuites with the server key exchange message omitted.  Thanks to Karthikeyan Bhargavan for reporting this issue.  CVE-2014-3572",
        "func_before": "int ssl3_get_key_exchange(SSL *s)\n\t{\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\n#endif\n\tEVP_MD_CTX md_ctx;\n\tunsigned char *param,*p;\n\tint al,j,ok;\n\tlong i,param_len,n,alg_k,alg_a;\n\tEVP_PKEY *pkey=NULL;\n\tconst EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n\tRSA *rsa=NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n\tDH *dh=NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *ecdh = NULL;\n\tBN_CTX *bn_ctx = NULL;\n\tEC_POINT *srvr_ecpoint = NULL;\n\tint curve_nid = 0;\n\tint encoded_pt_len = 0;\n#endif\n\n\t/* use same message size as in ssl3_get_certificate_request()\n\t * as ServerKeyExchange message may be skipped */\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_KEY_EXCH_A,\n\t\tSSL3_ST_CR_KEY_EXCH_B,\n\t\t-1,\n\t\ts->max_cert_list,\n\t\t&ok);\n\tif (!ok) return((int)n);\n\n\tif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n\t\t{\n#ifndef OPENSSL_NO_PSK\n\t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n\t\t   omitted if no identity hint is sent. Set\n\t\t   session->sess_cert anyway to avoid problems\n\t\t   later.*/\n\t\tif (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)\n\t\t\t{\n\t\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t\tif (s->ctx->psk_identity_hint)\n\t\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\t\ts->ctx->psk_identity_hint = NULL;\n\t\t\t}\n#endif\n\t\ts->s3->tmp.reuse_message=1;\n\t\treturn(1);\n\t\t}\n\n\tparam=p=(unsigned char *)s->init_msg;\n\tif (s->session->sess_cert != NULL)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n\t\t\t{\n\t\t\tRSA_free(s->session->sess_cert->peer_rsa_tmp);\n\t\t\ts->session->sess_cert->peer_rsa_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\tif (s->session->sess_cert->peer_dh_tmp)\n\t\t\t{\n\t\t\tDH_free(s->session->sess_cert->peer_dh_tmp);\n\t\t\ts->session->sess_cert->peer_dh_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDH\n\t\tif (s->session->sess_cert->peer_ecdh_tmp)\n\t\t\t{\n\t\t\tEC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n\t\t\ts->session->sess_cert->peer_ecdh_tmp=NULL;\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t}\n\n\t/* Total length of the parameters including the length prefix */\n\tparam_len=0;\n\n\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n\talg_a=s->s3->tmp.new_cipher->algorithm_auth;\n\tEVP_MD_CTX_init(&md_ctx);\n\n\tal=SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n\tif (alg_k & SSL_kPSK)\n\t\t{\n\t\tchar tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\t/* Store PSK identity hint for later use, hint is used\n\t\t * in ssl3_send_client_key_exchange.  Assume that the\n\t\t * maximum length of a PSK identity hint can be as\n\t\t * long as the maximum length of a PSK identity. */\n\t\tif (i > PSK_MAX_IDENTITY_LEN)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_DATA_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\t/* If received PSK identity hint contains NULL\n\t\t * characters, the hint is truncated from the first\n\t\t * NULL. p may not be ending with NULL, so create a\n\t\t * NULL-terminated string. */\n\t\tmemcpy(tmp_id_hint, p, i);\n\t\tmemset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);\n\t\tif (s->ctx->psk_identity_hint != NULL)\n\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\ts->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);\n\t\tif (s->ctx->psk_identity_hint == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n\t\t\tgoto f_err;\n\t\t\t}\t   \n\n\t\tp+=i;\n\t\tn-=param_len;\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n\tif (alg_k & SSL_kSRP)\n\t\t{\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (1 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 1;\n\n\t\ti = (unsigned int)(p[0]);\n\t\tp++;\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!srp_verify_server_param(s, &al))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n/* We must check if there is a certificate */\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_SRP */\n#ifndef OPENSSL_NO_RSA\n\tif (alg_k & SSL_kRSA)\n\t\t{\n\t\tif ((rsa=RSA_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->n=BN_bin2bn(p,i,rsa->n)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->e=BN_bin2bn(p,i,rsa->e)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\t/* this should be because we are using an export cipher */\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->session->sess_cert->peer_rsa_tmp=rsa;\n\t\trsa=NULL;\n\t\t}\n#else /* OPENSSL_NO_RSA */\n\tif (0)\n\t\t;\n#endif\n#ifndef OPENSSL_NO_DH\n\telse if (alg_k & SSL_kDHE)\n\t\t{\n\t\tif ((dh=DH_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->p=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->pub_key=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!ssl_security(s, SSL_SECOP_TMP_DH,\n\t\t\t\t\t\tDH_security_bits(dh), 0, dh))\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t/* else anonymous DH, so no certificate or pkey. */\n\n\t\ts->session->sess_cert->peer_dh_tmp=dh;\n\t\tdh=NULL;\n\t\t}\n\telse if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n\telse if (alg_k & SSL_kECDHE)\n\t\t{\n\t\tEC_GROUP *ngroup;\n\t\tconst EC_GROUP *group;\n\n\t\tif ((ecdh=EC_KEY_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Extract elliptic curve parameters and the\n\t\t * server's ephemeral ECDH public key.\n\t\t * Keep accumulating lengths of various components in\n\t\t * param_len and make sure it never exceeds n.\n\t\t */\n\n\t\t/* XXX: For now we only support named (not generic) curves\n\t\t * and the ECParameters in this case is just three bytes. We\n\t\t * also need one byte for the length of the encoded point\n\t\t */\n\t\tparam_len=4;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Check curve is one of our preferences, if not server has\n\t\t * sent an invalid curve. ECParameters is 3 bytes.\n\t\t */\n\t\tif (!tls1_check_curve(s, p, 3))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) \n\t\t\t{\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tngroup = EC_GROUP_new_by_curve_name(curve_nid);\n\t\tif (ngroup == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (EC_KEY_set_group(ecdh, ngroup) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tEC_GROUP_free(ngroup);\n\n\t\tgroup = EC_KEY_get0_group(ecdh);\n\n\t\tif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n\t\t    (EC_GROUP_get_degree(group) > 163))\n\t\t\t{\n\t\t\tal=SSL_AD_EXPORT_RESTRICTION;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tp+=3;\n\n\t\t/* Next, get the encoded ECPoint */\n\t\tif (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n\t\t    ((bn_ctx = BN_CTX_new()) == NULL))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tencoded_pt_len = *p;  /* length of encoded point */\n\t\tp+=1;\n\n\t\tif ((encoded_pt_len > n - param_len) ||\n\t\t    (EC_POINT_oct2point(group, srvr_ecpoint, \n\t\t\tp, encoded_pt_len, bn_ctx) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += encoded_pt_len;\n\n\t\tn-=param_len;\n\t\tp+=encoded_pt_len;\n\n\t\t/* The ECC/TLS specification does not mention\n\t\t * the use of DSA to sign ECParameters in the server\n\t\t * key exchange message. We do support RSA and ECDSA.\n\t\t */\n\t\tif (0) ;\n#ifndef OPENSSL_NO_RSA\n\t\telse if (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\telse if (alg_a & SSL_aECDSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n#endif\n\t\t/* else anonymous ECDH, so no certificate or pkey. */\n\t\tEC_KEY_set_public_key(ecdh, srvr_ecpoint);\n\t\ts->session->sess_cert->peer_ecdh_tmp=ecdh;\n\t\tecdh=NULL;\n\t\tBN_CTX_free(bn_ctx);\n\t\tbn_ctx = NULL;\n\t\tEC_POINT_free(srvr_ecpoint);\n\t\tsrvr_ecpoint = NULL;\n\t\t}\n\telse if (alg_k)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\n\n\t/* p points to the next byte, there are 'n' bytes left */\n\n\t/* if it was signed, check the signature */\n\tif (pkey != NULL)\n\t\t{\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv;\n\t\t\tif (2 > n)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\trv = tls12_check_peer_sigalg(&md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\tgoto err;\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\telse\n\t\t\tmd = EVP_sha1();\n\n\t\tif (2 > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tj=EVP_PKEY_size(pkey);\n\n\t\t/* Check signature length. If n is 0 then signature is empty */\n\t\tif ((i != n) || (n > j) || (n <= 0))\n\t\t\t{\n\t\t\t/* wrong packet length */\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint num;\n\t\t\tunsigned int size;\n\n\t\t\tj=0;\n\t\t\tq=md_buf;\n\t\t\tfor (num=2; num > 0; num--)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_set_flags(&md_ctx,\n\t\t\t\t\tEVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n\t\t\t\tEVP_DigestInit_ex(&md_ctx,(num == 2)\n\t\t\t\t\t?s->ctx->md5:s->ctx->sha1, NULL);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,param,param_len);\n\t\t\t\tEVP_DigestFinal_ex(&md_ctx,q,&size);\n\t\t\t\tq+=size;\n\t\t\t\tj+=size;\n\t\t\t\t}\n\t\t\ti=RSA_verify(NID_md5_sha1, md_buf, j, p, n,\n\t\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\t\tif (i < 0)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n\t\t\tEVP_VerifyInit_ex(&md_ctx, md, NULL);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,param,param_len);\n\t\t\tif (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\t/* aNULL, aSRP or kPSK do not need public keys */\n\t\tif (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))\n\t\t\t{\n\t\t\t/* Might be wrong key type, check it */\n\t\t\tif (ssl3_check_cert_and_algorithm(s))\n\t\t\t\t/* Otherwise this shouldn't happen */\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t/* still data left over */\n\t\tif (n != 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\tEVP_PKEY_free(pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\tEVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n\tif (dh != NULL)\n\t\tDH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tEC_POINT_free(srvr_ecpoint);\n\tif (ecdh != NULL)\n\t\tEC_KEY_free(ecdh);\n#endif\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(-1);\n\t}",
        "func": "int ssl3_get_key_exchange(SSL *s)\n\t{\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\n#endif\n\tEVP_MD_CTX md_ctx;\n\tunsigned char *param,*p;\n\tint al,j,ok;\n\tlong i,param_len,n,alg_k,alg_a;\n\tEVP_PKEY *pkey=NULL;\n\tconst EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n\tRSA *rsa=NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n\tDH *dh=NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *ecdh = NULL;\n\tBN_CTX *bn_ctx = NULL;\n\tEC_POINT *srvr_ecpoint = NULL;\n\tint curve_nid = 0;\n\tint encoded_pt_len = 0;\n#endif\n\n\tEVP_MD_CTX_init(&md_ctx);\n\n\t/* use same message size as in ssl3_get_certificate_request()\n\t * as ServerKeyExchange message may be skipped */\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_KEY_EXCH_A,\n\t\tSSL3_ST_CR_KEY_EXCH_B,\n\t\t-1,\n\t\ts->max_cert_list,\n\t\t&ok);\n\tif (!ok) return((int)n);\n\n\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n\n\tif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n\t\t{\n\t\t/*\n\t\t * Can't skip server key exchange if this is an ephemeral\n\t\t * ciphersuite.\n\t\t */\n\t\tif (alg_k & (SSL_kDHE|SSL_kECDHE))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tal = SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifndef OPENSSL_NO_PSK\n\t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n\t\t   omitted if no identity hint is sent. Set\n\t\t   session->sess_cert anyway to avoid problems\n\t\t   later.*/\n\t\tif (alg_k & SSL_kPSK)\n\t\t\t{\n\t\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t\tif (s->ctx->psk_identity_hint)\n\t\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\t\ts->ctx->psk_identity_hint = NULL;\n\t\t\t}\n#endif\n\t\ts->s3->tmp.reuse_message=1;\n\t\treturn(1);\n\t\t}\n\n\tparam=p=(unsigned char *)s->init_msg;\n\tif (s->session->sess_cert != NULL)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n\t\t\t{\n\t\t\tRSA_free(s->session->sess_cert->peer_rsa_tmp);\n\t\t\ts->session->sess_cert->peer_rsa_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\tif (s->session->sess_cert->peer_dh_tmp)\n\t\t\t{\n\t\t\tDH_free(s->session->sess_cert->peer_dh_tmp);\n\t\t\ts->session->sess_cert->peer_dh_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDH\n\t\tif (s->session->sess_cert->peer_ecdh_tmp)\n\t\t\t{\n\t\t\tEC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n\t\t\ts->session->sess_cert->peer_ecdh_tmp=NULL;\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t}\n\n\t/* Total length of the parameters including the length prefix */\n\tparam_len=0;\n\n\talg_a=s->s3->tmp.new_cipher->algorithm_auth;\n\n\tal=SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n\tif (alg_k & SSL_kPSK)\n\t\t{\n\t\tchar tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\t/* Store PSK identity hint for later use, hint is used\n\t\t * in ssl3_send_client_key_exchange.  Assume that the\n\t\t * maximum length of a PSK identity hint can be as\n\t\t * long as the maximum length of a PSK identity. */\n\t\tif (i > PSK_MAX_IDENTITY_LEN)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_DATA_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\t/* If received PSK identity hint contains NULL\n\t\t * characters, the hint is truncated from the first\n\t\t * NULL. p may not be ending with NULL, so create a\n\t\t * NULL-terminated string. */\n\t\tmemcpy(tmp_id_hint, p, i);\n\t\tmemset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);\n\t\tif (s->ctx->psk_identity_hint != NULL)\n\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\ts->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);\n\t\tif (s->ctx->psk_identity_hint == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n\t\t\tgoto f_err;\n\t\t\t}\t   \n\n\t\tp+=i;\n\t\tn-=param_len;\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n\tif (alg_k & SSL_kSRP)\n\t\t{\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (1 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 1;\n\n\t\ti = (unsigned int)(p[0]);\n\t\tp++;\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!srp_verify_server_param(s, &al))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n/* We must check if there is a certificate */\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_SRP */\n#ifndef OPENSSL_NO_RSA\n\tif (alg_k & SSL_kRSA)\n\t\t{\n\t\tif ((rsa=RSA_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->n=BN_bin2bn(p,i,rsa->n)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->e=BN_bin2bn(p,i,rsa->e)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\t/* this should be because we are using an export cipher */\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->session->sess_cert->peer_rsa_tmp=rsa;\n\t\trsa=NULL;\n\t\t}\n#else /* OPENSSL_NO_RSA */\n\tif (0)\n\t\t;\n#endif\n#ifndef OPENSSL_NO_DH\n\telse if (alg_k & SSL_kDHE)\n\t\t{\n\t\tif ((dh=DH_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->p=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->pub_key=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!ssl_security(s, SSL_SECOP_TMP_DH,\n\t\t\t\t\t\tDH_security_bits(dh), 0, dh))\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t/* else anonymous DH, so no certificate or pkey. */\n\n\t\ts->session->sess_cert->peer_dh_tmp=dh;\n\t\tdh=NULL;\n\t\t}\n\telse if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n\telse if (alg_k & SSL_kECDHE)\n\t\t{\n\t\tEC_GROUP *ngroup;\n\t\tconst EC_GROUP *group;\n\n\t\tif ((ecdh=EC_KEY_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Extract elliptic curve parameters and the\n\t\t * server's ephemeral ECDH public key.\n\t\t * Keep accumulating lengths of various components in\n\t\t * param_len and make sure it never exceeds n.\n\t\t */\n\n\t\t/* XXX: For now we only support named (not generic) curves\n\t\t * and the ECParameters in this case is just three bytes. We\n\t\t * also need one byte for the length of the encoded point\n\t\t */\n\t\tparam_len=4;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Check curve is one of our preferences, if not server has\n\t\t * sent an invalid curve. ECParameters is 3 bytes.\n\t\t */\n\t\tif (!tls1_check_curve(s, p, 3))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) \n\t\t\t{\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tngroup = EC_GROUP_new_by_curve_name(curve_nid);\n\t\tif (ngroup == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (EC_KEY_set_group(ecdh, ngroup) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tEC_GROUP_free(ngroup);\n\n\t\tgroup = EC_KEY_get0_group(ecdh);\n\n\t\tif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n\t\t    (EC_GROUP_get_degree(group) > 163))\n\t\t\t{\n\t\t\tal=SSL_AD_EXPORT_RESTRICTION;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tp+=3;\n\n\t\t/* Next, get the encoded ECPoint */\n\t\tif (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n\t\t    ((bn_ctx = BN_CTX_new()) == NULL))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tencoded_pt_len = *p;  /* length of encoded point */\n\t\tp+=1;\n\n\t\tif ((encoded_pt_len > n - param_len) ||\n\t\t    (EC_POINT_oct2point(group, srvr_ecpoint, \n\t\t\tp, encoded_pt_len, bn_ctx) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += encoded_pt_len;\n\n\t\tn-=param_len;\n\t\tp+=encoded_pt_len;\n\n\t\t/* The ECC/TLS specification does not mention\n\t\t * the use of DSA to sign ECParameters in the server\n\t\t * key exchange message. We do support RSA and ECDSA.\n\t\t */\n\t\tif (0) ;\n#ifndef OPENSSL_NO_RSA\n\t\telse if (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\telse if (alg_a & SSL_aECDSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n#endif\n\t\t/* else anonymous ECDH, so no certificate or pkey. */\n\t\tEC_KEY_set_public_key(ecdh, srvr_ecpoint);\n\t\ts->session->sess_cert->peer_ecdh_tmp=ecdh;\n\t\tecdh=NULL;\n\t\tBN_CTX_free(bn_ctx);\n\t\tbn_ctx = NULL;\n\t\tEC_POINT_free(srvr_ecpoint);\n\t\tsrvr_ecpoint = NULL;\n\t\t}\n\telse if (alg_k)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\n\n\t/* p points to the next byte, there are 'n' bytes left */\n\n\t/* if it was signed, check the signature */\n\tif (pkey != NULL)\n\t\t{\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv;\n\t\t\tif (2 > n)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\trv = tls12_check_peer_sigalg(&md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\tgoto err;\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\telse\n\t\t\tmd = EVP_sha1();\n\n\t\tif (2 > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tj=EVP_PKEY_size(pkey);\n\n\t\t/* Check signature length. If n is 0 then signature is empty */\n\t\tif ((i != n) || (n > j) || (n <= 0))\n\t\t\t{\n\t\t\t/* wrong packet length */\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint num;\n\t\t\tunsigned int size;\n\n\t\t\tj=0;\n\t\t\tq=md_buf;\n\t\t\tfor (num=2; num > 0; num--)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_set_flags(&md_ctx,\n\t\t\t\t\tEVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n\t\t\t\tEVP_DigestInit_ex(&md_ctx,(num == 2)\n\t\t\t\t\t?s->ctx->md5:s->ctx->sha1, NULL);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,param,param_len);\n\t\t\t\tEVP_DigestFinal_ex(&md_ctx,q,&size);\n\t\t\t\tq+=size;\n\t\t\t\tj+=size;\n\t\t\t\t}\n\t\t\ti=RSA_verify(NID_md5_sha1, md_buf, j, p, n,\n\t\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\t\tif (i < 0)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n\t\t\tEVP_VerifyInit_ex(&md_ctx, md, NULL);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,param,param_len);\n\t\t\tif (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\t/* aNULL, aSRP or kPSK do not need public keys */\n\t\tif (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))\n\t\t\t{\n\t\t\t/* Might be wrong key type, check it */\n\t\t\tif (ssl3_check_cert_and_algorithm(s))\n\t\t\t\t/* Otherwise this shouldn't happen */\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t/* still data left over */\n\t\tif (n != 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\tEVP_PKEY_free(pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\tEVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n\tif (dh != NULL)\n\t\tDH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tEC_POINT_free(srvr_ecpoint);\n\tif (ecdh != NULL)\n\t\tEC_KEY_free(ecdh);\n#endif\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(-1);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,8 @@\n \tint curve_nid = 0;\n \tint encoded_pt_len = 0;\n #endif\n+\n+\tEVP_MD_CTX_init(&md_ctx);\n \n \t/* use same message size as in ssl3_get_certificate_request()\n \t * as ServerKeyExchange message may be skipped */\n@@ -33,14 +35,26 @@\n \t\t&ok);\n \tif (!ok) return((int)n);\n \n+\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n+\n \tif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n \t\t{\n+\t\t/*\n+\t\t * Can't skip server key exchange if this is an ephemeral\n+\t\t * ciphersuite.\n+\t\t */\n+\t\tif (alg_k & (SSL_kDHE|SSL_kECDHE))\n+\t\t\t{\n+\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n+\t\t\tal = SSL_AD_UNEXPECTED_MESSAGE;\n+\t\t\tgoto f_err;\n+\t\t\t}\n #ifndef OPENSSL_NO_PSK\n \t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n \t\t   omitted if no identity hint is sent. Set\n \t\t   session->sess_cert anyway to avoid problems\n \t\t   later.*/\n-\t\tif (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)\n+\t\tif (alg_k & SSL_kPSK)\n \t\t\t{\n \t\t\ts->session->sess_cert=ssl_sess_cert_new();\n \t\t\tif (s->ctx->psk_identity_hint)\n@@ -85,9 +99,7 @@\n \t/* Total length of the parameters including the length prefix */\n \tparam_len=0;\n \n-\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n \talg_a=s->s3->tmp.new_cipher->algorithm_auth;\n-\tEVP_MD_CTX_init(&md_ctx);\n \n \tal=SSL_AD_DECODE_ERROR;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)",
                "\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;",
                "\tEVP_MD_CTX_init(&md_ctx);"
            ],
            "added_lines": [
                "",
                "\tEVP_MD_CTX_init(&md_ctx);",
                "\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;",
                "",
                "\t\t/*",
                "\t\t * Can't skip server key exchange if this is an ephemeral",
                "\t\t * ciphersuite.",
                "\t\t */",
                "\t\tif (alg_k & (SSL_kDHE|SSL_kECDHE))",
                "\t\t\t{",
                "\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);",
                "\t\t\tal = SSL_AD_UNEXPECTED_MESSAGE;",
                "\t\t\tgoto f_err;",
                "\t\t\t}",
                "\t\tif (alg_k & SSL_kPSK)"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8275",
        "func_name": "openssl/X509_verify",
        "description": "OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",
        "git_url": "https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e",
        "commit_title": "Fix various certificate fingerprint issues.",
        "commit_text": " By using non-DER or invalid encodings outside the signed portion of a certificate the fingerprint can be changed without breaking the signature. Although no details of the signed portion of the certificate can be changed this can cause problems with some applications: e.g. those using the certificate fingerprint for blacklists.  1. Reject signatures with non zero unused bits.  If the BIT STRING containing the signature has non zero unused bits reject the signature. All current signature algorithms require zero unused bits.  2. Check certificate algorithm consistency.  Check the AlgorithmIdentifier inside TBS matches the one in the certificate signature. NB: this will result in signature failure errors for some broken certificates.  3. Check DSA/ECDSA signatures use DER.  Reencode DSA/ECDSA signatures and compare with the original received signature. Return an error if there is a mismatch.  This will reject various cases including garbage after signature (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS program for discovering this case) and use of BER or invalid ASN.1 INTEGERs (negative or with leading zeroes).  CVE-2014-8275",
        "func_before": "int X509_verify(X509 *a, EVP_PKEY *r)\n\t{\n\treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n\t\ta->signature,a->cert_info,r));\n\t}",
        "func": "int X509_verify(X509 *a, EVP_PKEY *r)\n\t{\n\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\n\t\treturn 0;\n\treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n\t\ta->signature,a->cert_info,r));\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n int X509_verify(X509 *a, EVP_PKEY *r)\n \t{\n+\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\n+\t\treturn 0;\n \treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n \t\ta->signature,a->cert_info,r));\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))",
                "\t\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8275",
        "func_name": "openssl/DSA_verify",
        "description": "OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",
        "git_url": "https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e",
        "commit_title": "Fix various certificate fingerprint issues.",
        "commit_text": " By using non-DER or invalid encodings outside the signed portion of a certificate the fingerprint can be changed without breaking the signature. Although no details of the signed portion of the certificate can be changed this can cause problems with some applications: e.g. those using the certificate fingerprint for blacklists.  1. Reject signatures with non zero unused bits.  If the BIT STRING containing the signature has non zero unused bits reject the signature. All current signature algorithms require zero unused bits.  2. Check certificate algorithm consistency.  Check the AlgorithmIdentifier inside TBS matches the one in the certificate signature. NB: this will result in signature failure errors for some broken certificates.  3. Check DSA/ECDSA signatures use DER.  Reencode DSA/ECDSA signatures and compare with the original received signature. Return an error if there is a mismatch.  This will reject various cases including garbage after signature (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS program for discovering this case) and use of BER or invalid ASN.1 INTEGERs (negative or with leading zeroes).  CVE-2014-8275",
        "func_before": "int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}",
        "func": "int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tconst unsigned char *p = sigbuf;\n\tunsigned char *der = NULL;\n\tint derlen = -1;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n\t/* Ensure signature uses DER and doesn't have trailing garbage */\n\tderlen = i2d_DSA_SIG(s, &der);\n\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n\t\tgoto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tif (derlen > 0)\n\t\t{\n\t\tOPENSSL_cleanse(der, derlen);\n\t\tOPENSSL_free(der);\n\t\t}\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,13 +2,25 @@\n \t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n \t{\n \tDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = DSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n+\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_DSA_SIG(s, &der);\n+\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=DSA_do_verify(dgst,dgst_len,s,dsa);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tDSA_SIG_free(s);\n \treturn(ret);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;"
            ],
            "added_lines": [
                "\tconst unsigned char *p = sigbuf;",
                "\tunsigned char *der = NULL;",
                "\tint derlen = -1;",
                "\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;",
                "\t/* Ensure signature uses DER and doesn't have trailing garbage */",
                "\tderlen = i2d_DSA_SIG(s, &der);",
                "\tif (derlen != siglen || memcmp(sigbuf, der, derlen))",
                "\t\tgoto err;",
                "\tif (derlen > 0)",
                "\t\t{",
                "\t\tOPENSSL_cleanse(der, derlen);",
                "\t\tOPENSSL_free(der);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8275",
        "func_name": "openssl/ASN1_item_verify",
        "description": "OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",
        "git_url": "https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e",
        "commit_title": "Fix various certificate fingerprint issues.",
        "commit_text": " By using non-DER or invalid encodings outside the signed portion of a certificate the fingerprint can be changed without breaking the signature. Although no details of the signed portion of the certificate can be changed this can cause problems with some applications: e.g. those using the certificate fingerprint for blacklists.  1. Reject signatures with non zero unused bits.  If the BIT STRING containing the signature has non zero unused bits reject the signature. All current signature algorithms require zero unused bits.  2. Check certificate algorithm consistency.  Check the AlgorithmIdentifier inside TBS matches the one in the certificate signature. NB: this will result in signature failure errors for some broken certificates.  3. Check DSA/ECDSA signatures use DER.  Reencode DSA/ECDSA signatures and compare with the original received signature. Return an error if there is a mismatch.  This will reject various cases including garbage after signature (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS program for discovering this case) and use of BER or invalid ASN.1 INTEGERs (negative or with leading zeroes).  CVE-2014-8275",
        "func_before": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n\t\tASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n\n\tint mdnid, pknid;\n\n\tif (!pkey)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn -1;\n\t\t}\n\n\tEVP_MD_CTX_init(&ctx);\n\n\t/* Convert signature OID into digest and public key OIDs */\n\tif (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\tif (mdnid == NID_undef)\n\t\t{\n\t\tif (!pkey->ameth || !pkey->ameth->item_verify)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\t\tret = pkey->ameth->item_verify(&ctx, it, asn, a,\n\t\t\t\t\t\t\tsignature, pkey);\n\t\t/* Return value of 2 means carry on, anything else means we\n\t\t * exit straight away: either a fatal error of the underlying\n\t\t * verification routine handles all verification.\n\t\t */\n\t\tif (ret != 2)\n\t\t\tgoto err;\n\t\tret = -1;\n\t\t}\n\telse\n\t\t{\n\t\tconst EVP_MD *type;\n\t\ttype=EVP_get_digestbynid(mdnid);\n\t\tif (type == NULL)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Check public key OID matches public key type */\n\t\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\t\tret=0;\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t}\n\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\t\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (!ret)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tgoto err;\n\t\t}\n\tret = -1;\n\n\tif (EVP_DigestVerifyFinal(&ctx,signature->data,\n\t\t\t(size_t)signature->length) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}",
        "func": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n\t\tASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n\n\tint mdnid, pknid;\n\n\tif (!pkey)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn -1;\n\t\t}\n\n\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n\t\treturn -1;\n\t\t}\n\n\tEVP_MD_CTX_init(&ctx);\n\n\t/* Convert signature OID into digest and public key OIDs */\n\tif (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\tif (mdnid == NID_undef)\n\t\t{\n\t\tif (!pkey->ameth || !pkey->ameth->item_verify)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\t\tret = pkey->ameth->item_verify(&ctx, it, asn, a,\n\t\t\t\t\t\t\tsignature, pkey);\n\t\t/* Return value of 2 means carry on, anything else means we\n\t\t * exit straight away: either a fatal error of the underlying\n\t\t * verification routine handles all verification.\n\t\t */\n\t\tif (ret != 2)\n\t\t\tgoto err;\n\t\tret = -1;\n\t\t}\n\telse\n\t\t{\n\t\tconst EVP_MD *type;\n\t\ttype=EVP_get_digestbynid(mdnid);\n\t\tif (type == NULL)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Check public key OID matches public key type */\n\t\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\t\tret=0;\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t}\n\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\t\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (!ret)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tgoto err;\n\t\t}\n\tret = -1;\n\n\tif (EVP_DigestVerifyFinal(&ctx,signature->data,\n\t\t\t(size_t)signature->length) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,12 @@\n \tif (!pkey)\n \t\t{\n \t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\n+\t\treturn -1;\n+\t\t}\n+\n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n \t\treturn -1;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\treturn -1;",
                "\t\t}",
                "",
                "\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)",
                "\t\t{",
                "\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8275",
        "func_name": "openssl/ASN1_verify",
        "description": "OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",
        "git_url": "https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e",
        "commit_title": "Fix various certificate fingerprint issues.",
        "commit_text": " By using non-DER or invalid encodings outside the signed portion of a certificate the fingerprint can be changed without breaking the signature. Although no details of the signed portion of the certificate can be changed this can cause problems with some applications: e.g. those using the certificate fingerprint for blacklists.  1. Reject signatures with non zero unused bits.  If the BIT STRING containing the signature has non zero unused bits reject the signature. All current signature algorithms require zero unused bits.  2. Check certificate algorithm consistency.  Check the AlgorithmIdentifier inside TBS matches the one in the certificate signature. NB: this will result in signature failure errors for some broken certificates.  3. Check DSA/ECDSA signatures use DER.  Reencode DSA/ECDSA signatures and compare with the original received signature. Return an error if there is a mismatch.  This will reject various cases including garbage after signature (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS program for discovering this case) and use of BER or invalid ASN.1 INTEGERs (negative or with leading zeroes).  CVE-2014-8275",
        "func_before": "int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t\tchar *data, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type;\n\tunsigned char *p,*buf_in=NULL;\n\tint ret= -1,i,inl;\n\n\tEVP_MD_CTX_init(&ctx);\n\ti=OBJ_obj2nid(a->algorithm);\n\ttype=EVP_get_digestbyname(OBJ_nid2sn(i));\n\tif (type == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\t\n\tinl=i2d(data,NULL);\n\tbuf_in=OPENSSL_malloc((unsigned int)inl);\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tp=buf_in;\n\n\ti2d(data,&p);\n\tret=\n\t\tEVP_VerifyInit_ex(&ctx,type, NULL)\n\t\t&& EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (!ret)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);\n\t\tgoto err;\n\t\t}\n\tret = -1;\n\n\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}",
        "func": "int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t\tchar *data, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type;\n\tunsigned char *p,*buf_in=NULL;\n\tint ret= -1,i,inl;\n\n\tEVP_MD_CTX_init(&ctx);\n\ti=OBJ_obj2nid(a->algorithm);\n\ttype=EVP_get_digestbyname(OBJ_nid2sn(i));\n\tif (type == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\n\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n\t\tgoto err;\n\t\t}\n\t\n\tinl=i2d(data,NULL);\n\tbuf_in=OPENSSL_malloc((unsigned int)inl);\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tp=buf_in;\n\n\ti2d(data,&p);\n\tret=\n\t\tEVP_VerifyInit_ex(&ctx,type, NULL)\n\t\t&& EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (!ret)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);\n\t\tgoto err;\n\t\t}\n\tret = -1;\n\n\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,12 @@\n \tif (type == NULL)\n \t\t{\n \t\tASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n+\t\tgoto err;\n+\t\t}\n+\n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n \t\tgoto err;\n \t\t}\n \t",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tgoto err;",
                "\t\t}",
                "",
                "\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)",
                "\t\t{",
                "\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8275",
        "func_name": "openssl/ECDSA_verify",
        "description": "OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",
        "git_url": "https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e",
        "commit_title": "Fix various certificate fingerprint issues.",
        "commit_text": " By using non-DER or invalid encodings outside the signed portion of a certificate the fingerprint can be changed without breaking the signature. Although no details of the signed portion of the certificate can be changed this can cause problems with some applications: e.g. those using the certificate fingerprint for blacklists.  1. Reject signatures with non zero unused bits.  If the BIT STRING containing the signature has non zero unused bits reject the signature. All current signature algorithms require zero unused bits.  2. Check certificate algorithm consistency.  Check the AlgorithmIdentifier inside TBS matches the one in the certificate signature. NB: this will result in signature failure errors for some broken certificates.  3. Check DSA/ECDSA signatures use DER.  Reencode DSA/ECDSA signatures and compare with the original received signature. Return an error if there is a mismatch.  This will reject various cases including garbage after signature (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS program for discovering this case) and use of BER or invalid ASN.1 INTEGERs (negative or with leading zeroes).  CVE-2014-8275",
        "func_before": "int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n \t{\n\tECDSA_SIG *s;\n\tint ret=-1;\n\n\ts = ECDSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n\tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\nerr:\n\tECDSA_SIG_free(s);\n\treturn(ret);\n\t}",
        "func": "int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n \t{\n\tECDSA_SIG *s;\n\tconst unsigned char *p = sigbuf;\n\tunsigned char *der = NULL;\n\tint derlen = -1;\n\tint ret=-1;\n\n\ts = ECDSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;\n\t/* Ensure signature uses DER and doesn't have trailing garbage */\n\tderlen = i2d_ECDSA_SIG(s, &der);\n\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))\n\t\tgoto err;\n\tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\nerr:\n\tif (derlen > 0)\n\t\t{\n\t\tOPENSSL_cleanse(der, derlen);\n\t\tOPENSSL_free(der);\n\t\t}\n\tECDSA_SIG_free(s);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,13 +2,25 @@\n \t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n  \t{\n \tECDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = ECDSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n+\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_ECDSA_SIG(s, &der);\n+\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tECDSA_SIG_free(s);\n \treturn(ret);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;"
            ],
            "added_lines": [
                "\tconst unsigned char *p = sigbuf;",
                "\tunsigned char *der = NULL;",
                "\tint derlen = -1;",
                "\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;",
                "\t/* Ensure signature uses DER and doesn't have trailing garbage */",
                "\tderlen = i2d_ECDSA_SIG(s, &der);",
                "\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))",
                "\t\tgoto err;",
                "\tif (derlen > 0)",
                "\t\t{",
                "\t\tOPENSSL_cleanse(der, derlen);",
                "\t\tOPENSSL_free(der);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8275",
        "func_name": "openssl/ASN1_item_verify",
        "description": "OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",
        "git_url": "https://github.com/openssl/openssl/commit/cb62ab4b17818fe66d2fed0a7fe71969131c811b",
        "commit_title": "use correct function name",
        "commit_text": "",
        "func_before": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n\t\tASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n\n\tint mdnid, pknid;\n\n\tif (!pkey)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn -1;\n\t\t}\n\n\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n\t\treturn -1;\n\t\t}\n\n\tEVP_MD_CTX_init(&ctx);\n\n\t/* Convert signature OID into digest and public key OIDs */\n\tif (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\tif (mdnid == NID_undef)\n\t\t{\n\t\tif (!pkey->ameth || !pkey->ameth->item_verify)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\t\tret = pkey->ameth->item_verify(&ctx, it, asn, a,\n\t\t\t\t\t\t\tsignature, pkey);\n\t\t/* Return value of 2 means carry on, anything else means we\n\t\t * exit straight away: either a fatal error of the underlying\n\t\t * verification routine handles all verification.\n\t\t */\n\t\tif (ret != 2)\n\t\t\tgoto err;\n\t\tret = -1;\n\t\t}\n\telse\n\t\t{\n\t\tconst EVP_MD *type;\n\t\ttype=EVP_get_digestbynid(mdnid);\n\t\tif (type == NULL)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Check public key OID matches public key type */\n\t\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\t\tret=0;\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t}\n\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\t\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (!ret)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tgoto err;\n\t\t}\n\tret = -1;\n\n\tif (EVP_DigestVerifyFinal(&ctx,signature->data,\n\t\t\t(size_t)signature->length) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}",
        "func": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n\t\tASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n\n\tint mdnid, pknid;\n\n\tif (!pkey)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn -1;\n\t\t}\n\n\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n\t\treturn -1;\n\t\t}\n\n\tEVP_MD_CTX_init(&ctx);\n\n\t/* Convert signature OID into digest and public key OIDs */\n\tif (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\tif (mdnid == NID_undef)\n\t\t{\n\t\tif (!pkey->ameth || !pkey->ameth->item_verify)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\t\tret = pkey->ameth->item_verify(&ctx, it, asn, a,\n\t\t\t\t\t\t\tsignature, pkey);\n\t\t/* Return value of 2 means carry on, anything else means we\n\t\t * exit straight away: either a fatal error of the underlying\n\t\t * verification routine handles all verification.\n\t\t */\n\t\tif (ret != 2)\n\t\t\tgoto err;\n\t\tret = -1;\n\t\t}\n\telse\n\t\t{\n\t\tconst EVP_MD *type;\n\t\ttype=EVP_get_digestbynid(mdnid);\n\t\tif (type == NULL)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Check public key OID matches public key type */\n\t\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\t\tret=0;\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t}\n\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\t\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (!ret)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tgoto err;\n\t\t}\n\tret = -1;\n\n\tif (EVP_DigestVerifyFinal(&ctx,signature->data,\n\t\t\t(size_t)signature->length) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \n \tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n \t\t{\n-\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n \t\treturn -1;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);"
            ],
            "added_lines": [
                "\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0204",
        "func_name": "openssl/dtls1_accept",
        "description": "The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the \"FREAK\" issue.  NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.",
        "git_url": "https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0",
        "commit_title": "Only allow ephemeral RSA keys in export ciphersuites.",
        "commit_text": " OpenSSL clients would tolerate temporary RSA keys in non-export ciphersuites. It also had an option SSL_OP_EPHEMERAL_RSA which enabled this server side. Remove both options as they are a protocol violation.  Thanks to Karthikeyan Bhargavan for reporting this issue. (CVE-2015-0204)",
        "func_before": "int dtls1_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tunsigned long alg_k;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\tint listen;\n#ifndef OPENSSL_NO_SCTP\n\tunsigned char sctpauthkey[64];\n\tchar labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];\n#endif\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\t\n\tlisten = s->d1->listen;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\ts->d1->listen = listen;\n#ifndef OPENSSL_NO_SCTP\n\t/* Notify SCTP BIO socket to enter handshake\n\t * mode and prevent stream identifier other\n\t * than 0. Will be ignored if no SCTP is used.\n\t */\n\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);\n#endif\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\tdtls1_stop_timer(s);\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_DTLS1_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tBUF_MEM_free(buf);\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->d1->change_cipher_spec_ok = 0;\n\t\t\t/* Should have been reset by ssl3_get_finished, too. */\n\t\t\ts->s3->change_cipher_spec = 0;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t * ...but not with SCTP :-)\n\t\t\t\t */\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (!BIO_dgram_is_sctp(SSL_get_wbio(s)))\n#endif\n\t\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tdtls1_clear_record_buffer(s);\n\t\t\tdtls1_start_timer(s);\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_get_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tdtls1_stop_timer(s);\n\n\t\t\tif (ret == 1 && (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))\n\t\t\t\ts->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A;\n\t\t\telse\n\t\t\t\ts->state = SSL3_ST_SW_SRVR_HELLO_A;\n\n\t\t\ts->init_num=0;\n\n\t\t\t/* Reflect ClientHello sequence to remain stateless while listening */\n\t\t\tif (listen)\n\t\t\t\t{\n\t\t\t\tmemcpy(s->s3->write_sequence, s->s3->read_sequence, sizeof(s->s3->write_sequence));\n\t\t\t\t}\n\n\t\t\t/* If we're just listening, stop here */\n\t\t\tif (listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)\n\t\t\t\t{\n\t\t\t\tret = 2;\n\t\t\t\ts->d1->listen = 0;\n\t\t\t\t/* Set expected sequence numbers\n\t\t\t\t * to continue the handshake.\n\t\t\t\t */\n\t\t\t\ts->d1->handshake_read_seq = 2;\n\t\t\t\ts->d1->handshake_write_seq = 1;\n\t\t\t\ts->d1->next_handshake_write_seq = 1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:\n\t\tcase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:\n\n\t\t\tret = dtls1_send_hello_verify_request(s);\n\t\t\tif ( ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;\n\n\t\t\t/* HelloVerifyRequest resets Finished MAC */\n\t\t\tif (s->version != DTLS1_BAD_VER)\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\t\t\t\n#ifndef OPENSSL_NO_SCTP\n\t\tcase DTLS1_SCTP_ST_SR_READ_SOCK:\n\t\t\t\n\t\t\tif (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))\t\t\n\t\t\t\t{\n\t\t\t\ts->s3->in_read_app_data=2;\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n\t\t\t\n\t\tcase DTLS1_SCTP_ST_SW_WRITE_SOCK:\n\t\t\tret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));\n\t\t\tif (ret < 0) goto end;\n\t\t\t\n\t\t\tif (ret == 0)\n\t\t\t\t{\n\t\t\t\tif (s->d1->next_state != SSL_ST_OK)\n\t\t\t\t\t{\n\t\t\t\t\ts->s3->in_read_app_data=2;\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\ts->state=s->d1->next_state;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\ts->renegotiate = 2;\n\t\t\tdtls1_start_timer(s);\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\t{\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\t/* Add new shared key for SCTP-Auth,\n\t\t\t\t * will be ignored if no SCTP used.\n\t\t\t\t */\n\t\t\t\tsnprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),\n\t\t\t\t         DTLS1_SCTP_AUTH_LABEL);\n\n\t\t\t\tSSL_export_keying_material(s, sctpauthkey,\n\t\t\t\t                           sizeof(sctpauthkey), labelbuffer,\n\t\t\t\t                           sizeof(labelbuffer), NULL, 0, 0);\n\t\t\t\t\n\t\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,\n                         sizeof(sctpauthkey), sctpauthkey);\n#endif\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or normal PSK */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\tdtls1_start_timer(s);\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n#ifndef OPENSSL_NO_KRB5\n\t\t\t\t&& !(alg_k & SSL_kKRB5)\n#endif /* OPENSSL_NO_KRB5 */\n\t\t\t\t)\n\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n\t\t\t\t * even when forbidden by protocol specs\n\t\t\t\t * (handshake may fail as clients are not required to\n\t\t\t\t * be able to handle this) */\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\t\t\t/* only send if a DH key exchange or\n\t\t\t * RSA but we have a sign only certificate */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n\t\t\t    || (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd))\n\t\t\t    || (alg_k & SSL_kECDHE)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tdtls1_start_timer(s);\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\t\ts->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tdtls1_start_timer(s);\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\t\ts->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;\n\t\t\t\t\t}\n#endif\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->next_state = s->s3->tmp.next_state;\n\t\t\t\t\ts->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;\n\t\t\t\t\t}\n#endif\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tdtls1_start_timer(s);\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\t/* If the write error was fatal, stop trying */\n\t\t\t\tif (!BIO_should_retry(s->wbio))\n\t\t\t\t\t{\n\t\t\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t{\n\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t/* Add new shared key for SCTP-Auth,\n\t\t\t * will be ignored if no SCTP used.\n\t\t\t */\n\t\t\tsnprintf((char *) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),\n\t\t\t         DTLS1_SCTP_AUTH_LABEL);\n\n\t\t\tSSL_export_keying_material(s, sctpauthkey,\n\t\t\t                           sizeof(sctpauthkey), labelbuffer,\n\t\t\t                           sizeof(labelbuffer), NULL, 0, 0);\n\n\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,\n\t\t\t         sizeof(sctpauthkey), sctpauthkey);\n#endif\n\n\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t */\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (SSL_USE_SIGALGS(s))\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For sigalgs freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_DTLS1_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified */ \n\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t\tNID_md5,\n\t\t\t\t\t&(s->s3->tmp.cert_verify_md[0]));\n\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t\tNID_sha1,\n\t\t\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\t\t\t/*\n\t\t\t * This *should* be the first time we enable CCS, but be\n\t\t\t * extra careful about surrounding code changes. We need\n\t\t\t * to set this here because we don't know if we're\n\t\t\t * expecting a CertificateVerify or not.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->d1->change_cipher_spec_ok = 1;\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SCTP\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&\n\t\t\t    state == SSL_ST_RENEGOTIATE)\n\t\t\t\ts->state=DTLS1_SCTP_ST_SR_READ_SOCK;\n\t\t\telse\n#endif\t\t\t\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\t/*\n\t\t\t * Enable CCS for resumed handshakes.\n\t\t\t * In a full handshake, we end up here through\n\t\t\t * SSL3_ST_SR_CERT_VRFY_B, so change_cipher_spec_ok was\n\t\t\t * already set. Receiving a CCS clears the flag, so make\n\t\t\t * sure not to re-enable it to ban duplicates.\n\t\t\t * s->s3->change_cipher_spec is set when a CCS is\n\t\t\t * processed in d1_pkt.c, and remains set until\n\t\t\t * the client's Finished message is read.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->d1->change_cipher_spec_ok = 1;\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tdtls1_stop_timer(s);\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=dtls1_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\n#ifndef OPENSSL_NO_SCTP\n\t\t\tif (!s->hit)\n\t\t\t\t{\n\t\t\t\t/* Change to new shared key of SCTP-Auth,\n\t\t\t\t * will be ignored if no SCTP used.\n\t\t\t\t */\n\t\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);\n\t\t\t\t}\n#endif\n\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tdtls1_reset_seq_numbers(s, SSL3_CC_WRITE);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\t/* Change to new shared key of SCTP-Auth,\n\t\t\t\t * will be ignored if no SCTP used.\n\t\t\t\t */\n\t\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->next_state = s->s3->tmp.next_state;\n\t\t\t\t\ts->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n#if 0\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n#endif\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=dtls1_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\n\t\t\t/* done handshaking, next message is client hello */\n\t\t\ts->d1->handshake_read_seq = 0;\n\t\t\t/* next message is server hello */\n\t\t\ts->d1->handshake_write_seq = 0;\n\t\t\ts->d1->next_handshake_write_seq = 0;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\ts->in_handshake--;\n#ifndef OPENSSL_NO_SCTP\n\t\t/* Notify SCTP BIO socket to leave handshake\n\t\t * mode and prevent stream identifier other\n\t\t * than 0. Will be ignored if no SCTP is used.\n\t\t */\n\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);\n#endif\n\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\treturn(ret);\n\t}",
        "func": "int dtls1_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tunsigned long alg_k;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\tint listen;\n#ifndef OPENSSL_NO_SCTP\n\tunsigned char sctpauthkey[64];\n\tchar labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];\n#endif\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\t\n\tlisten = s->d1->listen;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\ts->d1->listen = listen;\n#ifndef OPENSSL_NO_SCTP\n\t/* Notify SCTP BIO socket to enter handshake\n\t * mode and prevent stream identifier other\n\t * than 0. Will be ignored if no SCTP is used.\n\t */\n\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);\n#endif\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\tdtls1_stop_timer(s);\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_DTLS1_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tBUF_MEM_free(buf);\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->d1->change_cipher_spec_ok = 0;\n\t\t\t/* Should have been reset by ssl3_get_finished, too. */\n\t\t\ts->s3->change_cipher_spec = 0;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t * ...but not with SCTP :-)\n\t\t\t\t */\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (!BIO_dgram_is_sctp(SSL_get_wbio(s)))\n#endif\n\t\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tdtls1_clear_record_buffer(s);\n\t\t\tdtls1_start_timer(s);\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_get_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tdtls1_stop_timer(s);\n\n\t\t\tif (ret == 1 && (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))\n\t\t\t\ts->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A;\n\t\t\telse\n\t\t\t\ts->state = SSL3_ST_SW_SRVR_HELLO_A;\n\n\t\t\ts->init_num=0;\n\n\t\t\t/* Reflect ClientHello sequence to remain stateless while listening */\n\t\t\tif (listen)\n\t\t\t\t{\n\t\t\t\tmemcpy(s->s3->write_sequence, s->s3->read_sequence, sizeof(s->s3->write_sequence));\n\t\t\t\t}\n\n\t\t\t/* If we're just listening, stop here */\n\t\t\tif (listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)\n\t\t\t\t{\n\t\t\t\tret = 2;\n\t\t\t\ts->d1->listen = 0;\n\t\t\t\t/* Set expected sequence numbers\n\t\t\t\t * to continue the handshake.\n\t\t\t\t */\n\t\t\t\ts->d1->handshake_read_seq = 2;\n\t\t\t\ts->d1->handshake_write_seq = 1;\n\t\t\t\ts->d1->next_handshake_write_seq = 1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:\n\t\tcase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:\n\n\t\t\tret = dtls1_send_hello_verify_request(s);\n\t\t\tif ( ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;\n\n\t\t\t/* HelloVerifyRequest resets Finished MAC */\n\t\t\tif (s->version != DTLS1_BAD_VER)\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\t\t\t\n#ifndef OPENSSL_NO_SCTP\n\t\tcase DTLS1_SCTP_ST_SR_READ_SOCK:\n\t\t\t\n\t\t\tif (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))\t\t\n\t\t\t\t{\n\t\t\t\ts->s3->in_read_app_data=2;\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n\t\t\t\n\t\tcase DTLS1_SCTP_ST_SW_WRITE_SOCK:\n\t\t\tret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));\n\t\t\tif (ret < 0) goto end;\n\t\t\t\n\t\t\tif (ret == 0)\n\t\t\t\t{\n\t\t\t\tif (s->d1->next_state != SSL_ST_OK)\n\t\t\t\t\t{\n\t\t\t\t\ts->s3->in_read_app_data=2;\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\ts->state=s->d1->next_state;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\ts->renegotiate = 2;\n\t\t\tdtls1_start_timer(s);\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\t{\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\t/* Add new shared key for SCTP-Auth,\n\t\t\t\t * will be ignored if no SCTP used.\n\t\t\t\t */\n\t\t\t\tsnprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),\n\t\t\t\t         DTLS1_SCTP_AUTH_LABEL);\n\n\t\t\t\tSSL_export_keying_material(s, sctpauthkey,\n\t\t\t\t                           sizeof(sctpauthkey), labelbuffer,\n\t\t\t\t                           sizeof(labelbuffer), NULL, 0, 0);\n\t\t\t\t\n\t\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,\n                         sizeof(sctpauthkey), sctpauthkey);\n#endif\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or normal PSK */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\tdtls1_start_timer(s);\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/*\n\t\t\t * clear this, it may get reset by\n\t\t\t * send_server_key_exchange\n\t\t\t */\n\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\t\t\t/* only send if a DH key exchange or\n\t\t\t * RSA but we have a sign only certificate */\n\t\t\tif (\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n\t\t\t    || (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd))\n\t\t\t    || (alg_k & SSL_kECDHE)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tdtls1_start_timer(s);\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\t\ts->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tdtls1_start_timer(s);\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\t\ts->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;\n\t\t\t\t\t}\n#endif\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->next_state = s->s3->tmp.next_state;\n\t\t\t\t\ts->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;\n\t\t\t\t\t}\n#endif\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tdtls1_start_timer(s);\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\t/* If the write error was fatal, stop trying */\n\t\t\t\tif (!BIO_should_retry(s->wbio))\n\t\t\t\t\t{\n\t\t\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t{\n\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t/* Add new shared key for SCTP-Auth,\n\t\t\t * will be ignored if no SCTP used.\n\t\t\t */\n\t\t\tsnprintf((char *) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),\n\t\t\t         DTLS1_SCTP_AUTH_LABEL);\n\n\t\t\tSSL_export_keying_material(s, sctpauthkey,\n\t\t\t                           sizeof(sctpauthkey), labelbuffer,\n\t\t\t                           sizeof(labelbuffer), NULL, 0, 0);\n\n\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,\n\t\t\t         sizeof(sctpauthkey), sctpauthkey);\n#endif\n\n\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t */\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (SSL_USE_SIGALGS(s))\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For sigalgs freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_DTLS1_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified */ \n\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t\tNID_md5,\n\t\t\t\t\t&(s->s3->tmp.cert_verify_md[0]));\n\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t\tNID_sha1,\n\t\t\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\t\t\t/*\n\t\t\t * This *should* be the first time we enable CCS, but be\n\t\t\t * extra careful about surrounding code changes. We need\n\t\t\t * to set this here because we don't know if we're\n\t\t\t * expecting a CertificateVerify or not.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->d1->change_cipher_spec_ok = 1;\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SCTP\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&\n\t\t\t    state == SSL_ST_RENEGOTIATE)\n\t\t\t\ts->state=DTLS1_SCTP_ST_SR_READ_SOCK;\n\t\t\telse\n#endif\t\t\t\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\t/*\n\t\t\t * Enable CCS for resumed handshakes.\n\t\t\t * In a full handshake, we end up here through\n\t\t\t * SSL3_ST_SR_CERT_VRFY_B, so change_cipher_spec_ok was\n\t\t\t * already set. Receiving a CCS clears the flag, so make\n\t\t\t * sure not to re-enable it to ban duplicates.\n\t\t\t * s->s3->change_cipher_spec is set when a CCS is\n\t\t\t * processed in d1_pkt.c, and remains set until\n\t\t\t * the client's Finished message is read.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->d1->change_cipher_spec_ok = 1;\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tdtls1_stop_timer(s);\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=dtls1_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\n#ifndef OPENSSL_NO_SCTP\n\t\t\tif (!s->hit)\n\t\t\t\t{\n\t\t\t\t/* Change to new shared key of SCTP-Auth,\n\t\t\t\t * will be ignored if no SCTP used.\n\t\t\t\t */\n\t\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);\n\t\t\t\t}\n#endif\n\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tdtls1_reset_seq_numbers(s, SSL3_CC_WRITE);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\t/* Change to new shared key of SCTP-Auth,\n\t\t\t\t * will be ignored if no SCTP used.\n\t\t\t\t */\n\t\t\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->next_state = s->s3->tmp.next_state;\n\t\t\t\t\ts->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n#if 0\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n#endif\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=dtls1_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\n\t\t\t/* done handshaking, next message is client hello */\n\t\t\ts->d1->handshake_read_seq = 0;\n\t\t\t/* next message is server hello */\n\t\t\ts->d1->handshake_write_seq = 0;\n\t\t\ts->d1->next_handshake_write_seq = 0;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\ts->in_handshake--;\n#ifndef OPENSSL_NO_SCTP\n\t\t/* Notify SCTP BIO socket to leave handshake\n\t\t * mode and prevent stream identifier other\n\t\t * than 0. Will be ignored if no SCTP is used.\n\t\t */\n\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);\n#endif\n\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -310,24 +310,15 @@\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \t\t\t/* only send if a DH key exchange or\n \t\t\t * RSA but we have a sign only certificate */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t/* clear this, it may get reset by",
                "\t\t\t * send_server_key_exchange */",
                "\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)",
                "#ifndef OPENSSL_NO_KRB5",
                "\t\t\t\t&& !(alg_k & SSL_kKRB5)",
                "#endif /* OPENSSL_NO_KRB5 */",
                "\t\t\t\t)",
                "\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key",
                "\t\t\t\t * even when forbidden by protocol specs",
                "\t\t\t\t * (handshake may fail as clients are not required to",
                "\t\t\t\t * be able to handle this) */",
                "\t\t\t\ts->s3->tmp.use_rsa_tmp=1;",
                "\t\t\telse",
                "\t\t\t\ts->s3->tmp.use_rsa_tmp=0;",
                "\t\t\tif (s->s3->tmp.use_rsa_tmp"
            ],
            "added_lines": [
                "\t\t\t/*",
                "\t\t\t * clear this, it may get reset by",
                "\t\t\t * send_server_key_exchange",
                "\t\t\t */",
                "\t\t\ts->s3->tmp.use_rsa_tmp=0;",
                "\t\t\tif ("
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0204",
        "func_name": "openssl/ssl3_accept",
        "description": "The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the \"FREAK\" issue.  NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.",
        "git_url": "https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0",
        "commit_title": "Only allow ephemeral RSA keys in export ciphersuites.",
        "commit_text": " OpenSSL clients would tolerate temporary RSA keys in non-export ciphersuites. It also had an option SSL_OP_EPHEMERAL_RSA which enabled this server side. Remove both options as they are a protocol violation.  Thanks to Karthikeyan Bhargavan for reporting this issue. (CVE-2015-0204)",
        "func_before": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long alg_k,Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\tif (!ssl_security(s, SSL_SECOP_VERSION, 0,\n\t\t\t\t\t\t\ts->version, NULL))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_VERSION_TOO_LOW);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tBUF_MEM_free(buf);\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY;\n\t\t\ts->s3->flags &= ~SSL3_FLAGS_CCS_OK;\n\t\t\t/* Should have been reset by ssl3_get_finished, too. */\n\t\t\ts->s3->change_cipher_spec = 0;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t */\n\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\t\t\t\t\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse if (!s->s3->send_connection_binding &&\n\t\t\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\t\t{\n\t\t\t\t/* Server attempting to renegotiate with\n\t\t\t\t * client that doesn't support secure\n\t\t\t\t * renegotiation.\n\t\t\t\t */\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\tret=ssl3_get_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SRP\n\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_D;\n\t\tcase SSL3_ST_SR_CLNT_HELLO_D:\n\t\t\t{\n\t\t\tint al;\n\t\t\tif ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)\n\t\t\t\t\t{\n\t\t\t\t\t/* callback indicates firther work to be done */\n\t\t\t\t\ts->rwstate=SSL_X509_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\tif (ret != SSL_ERROR_NONE)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\t\n\t\t\t\t/* This is not really an error but the only means to\n                                   for a client to detect whether srp is supported. */\n \t\t\t\t   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) \t\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);\t\t\t\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\t\n\t\t\t\t}\n\t\t\t}\n#endif\t\t\n\t\t\t\n\t\t\ts->renegotiate = 2;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\t\t}\n#else\n\t\t\tif (s->hit)\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\telse\n\t\t\t\t\ts->state = SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num = 0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or anon ECDH, */\n\t\t\t/* normal PSK or KRB5 or SRP */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL|SSL_aKRB5|SSL_aSRP))\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n#ifndef OPENSSL_NO_KRB5\n\t\t\t\t&& !(alg_k & SSL_kKRB5)\n#endif /* OPENSSL_NO_KRB5 */\n\t\t\t\t)\n\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n\t\t\t\t * even when forbidden by protocol specs\n\t\t\t\t * (handshake may fail as clients are not required to\n\t\t\t\t * be able to handle this) */\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate\n\t\t\t *\n\t\t\t * PSK: may send PSK identity hints\n\t\t\t *\n\t\t\t * For ECC ciphersuites, we send a serverKeyExchange\n\t\t\t * message only if the cipher suite is either\n\t\t\t * ECDH-anon or ECDHE. In other cases, the\n\t\t\t * server certificate contains the server's\n\t\t\t * public key for key exchange.\n\t\t\t */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n#ifndef OPENSSL_NO_SRP\n\t\t\t    /* SRP: send ServerKeyExchange */\n\t\t\t    || (alg_k & SSL_kSRP)\n#endif\n\t\t\t    || (alg_k & SSL_kDHE)\n\t\t\t    || (alg_k & SSL_kECDHE)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) ||\n\t\t\t\t/* don't request certificate for SRP auth */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aSRP)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\n\t\t\t/* This code originally checked to see if\n\t\t\t * any data was pending using BIO_CTRL_INFO\n\t\t\t * and then flushed. This caused problems\n\t\t\t * as documented in PR#1939. The proposed\n\t\t\t * fix doesn't completely resolve this issue\n\t\t\t * as buggy implementations of BIO_CTRL_PENDING\n\t\t\t * still exist. So instead we just flush\n\t\t\t * unconditionally.\n\t\t\t */\n\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t{\n\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t * Also for GOST ciphersuites when\n\t\t\t\t * the client uses its key from the certificate\n\t\t\t\t * for key exchange.\n\t\t\t\t */\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (SSL_USE_SIGALGS(s))\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For sigalgs freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tint offset=0;\n\t\t\t\tint dgst_num;\n\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified\n\t\t\t\t * FIXME - digest processing for CertificateVerify\n\t\t\t\t * should be generalized. But it is next step\n\t\t\t\t */\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\tfor (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)\t\n\t\t\t\t\tif (s->s3->handshake_dgst[dgst_num]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tint dgst_size;\n\n\t\t\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));\n\t\t\t\t\t\tdgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);\n\t\t\t\t\t\tif (dgst_size < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\toffset+=dgst_size;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\t\t\t/*\n\t\t\t * This *should* be the first time we enable CCS, but be\n\t\t\t * extra careful about surrounding code changes. We need\n\t\t\t * to set this here because we don't know if we're\n\t\t\t * expecting a CertificateVerify or not.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_SR_NEXT_PROTO_A:\n\t\tcase SSL3_ST_SR_NEXT_PROTO_B:\n\t\t\t/*\n\t\t\t * Enable CCS for resumed handshakes with NPN.\n\t\t\t * In a full handshake with NPN, we end up here through\n\t\t\t * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was\n\t\t\t * already set. Receiving a CCS clears the flag, so make\n\t\t\t * sure not to re-enable it to ban duplicates.\n\t\t\t * s->s3->change_cipher_spec is set when a CCS is\n\t\t\t * processed in s3_pkt.c, and remains set until\n\t\t\t * the client's Finished message is read.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\n\t\t\tret=ssl3_get_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->init_num = 0;\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\t/*\n\t\t\t * Enable CCS for resumed handshakes without NPN.\n\t\t\t * In a full handshake, we end up here through\n\t\t\t * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was\n\t\t\t * already set. Receiving a CCS clears the flag, so make\n\t\t\t * sure not to re-enable it to ban duplicates.\n\t\t\t * s->s3->change_cipher_spec is set when a CCS is\n\t\t\t * processed in s3_pkt.c, and remains set until\n\t\t\t * the client's Finished message is read.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\t{\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=ssl3_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\ts->in_handshake--;\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\treturn(ret);\n\t}",
        "func": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long alg_k,Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\tif (!ssl_security(s, SSL_SECOP_VERSION, 0,\n\t\t\t\t\t\t\ts->version, NULL))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_VERSION_TOO_LOW);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tBUF_MEM_free(buf);\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY;\n\t\t\ts->s3->flags &= ~SSL3_FLAGS_CCS_OK;\n\t\t\t/* Should have been reset by ssl3_get_finished, too. */\n\t\t\ts->s3->change_cipher_spec = 0;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t */\n\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\t\t\t\t\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse if (!s->s3->send_connection_binding &&\n\t\t\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\t\t{\n\t\t\t\t/* Server attempting to renegotiate with\n\t\t\t\t * client that doesn't support secure\n\t\t\t\t * renegotiation.\n\t\t\t\t */\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\tret=ssl3_get_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SRP\n\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_D;\n\t\tcase SSL3_ST_SR_CLNT_HELLO_D:\n\t\t\t{\n\t\t\tint al;\n\t\t\tif ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)\n\t\t\t\t\t{\n\t\t\t\t\t/* callback indicates firther work to be done */\n\t\t\t\t\ts->rwstate=SSL_X509_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\tif (ret != SSL_ERROR_NONE)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\t\n\t\t\t\t/* This is not really an error but the only means to\n                                   for a client to detect whether srp is supported. */\n \t\t\t\t   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) \t\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);\t\t\t\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\t\n\t\t\t\t}\n\t\t\t}\n#endif\t\t\n\t\t\t\n\t\t\ts->renegotiate = 2;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\t\t}\n#else\n\t\t\tif (s->hit)\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\telse\n\t\t\t\t\ts->state = SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num = 0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or anon ECDH, */\n\t\t\t/* normal PSK or KRB5 or SRP */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL|SSL_aKRB5|SSL_aSRP))\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/*\n\t\t\t * clear this, it may get reset by\n\t\t\t * send_server_key_exchange\n\t\t\t */\n\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate\n\t\t\t *\n\t\t\t * PSK: may send PSK identity hints\n\t\t\t *\n\t\t\t * For ECC ciphersuites, we send a serverKeyExchange\n\t\t\t * message only if the cipher suite is either\n\t\t\t * ECDH-anon or ECDHE. In other cases, the\n\t\t\t * server certificate contains the server's\n\t\t\t * public key for key exchange.\n\t\t\t */\n\t\t\tif (\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n#ifndef OPENSSL_NO_SRP\n\t\t\t    /* SRP: send ServerKeyExchange */\n\t\t\t    || (alg_k & SSL_kSRP)\n#endif\n\t\t\t    || (alg_k & SSL_kDHE)\n\t\t\t    || (alg_k & SSL_kECDHE)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) ||\n\t\t\t\t/* don't request certificate for SRP auth */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aSRP)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\n\t\t\t/* This code originally checked to see if\n\t\t\t * any data was pending using BIO_CTRL_INFO\n\t\t\t * and then flushed. This caused problems\n\t\t\t * as documented in PR#1939. The proposed\n\t\t\t * fix doesn't completely resolve this issue\n\t\t\t * as buggy implementations of BIO_CTRL_PENDING\n\t\t\t * still exist. So instead we just flush\n\t\t\t * unconditionally.\n\t\t\t */\n\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t{\n\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t * Also for GOST ciphersuites when\n\t\t\t\t * the client uses its key from the certificate\n\t\t\t\t * for key exchange.\n\t\t\t\t */\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (SSL_USE_SIGALGS(s))\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For sigalgs freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tint offset=0;\n\t\t\t\tint dgst_num;\n\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified\n\t\t\t\t * FIXME - digest processing for CertificateVerify\n\t\t\t\t * should be generalized. But it is next step\n\t\t\t\t */\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\tfor (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)\t\n\t\t\t\t\tif (s->s3->handshake_dgst[dgst_num]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tint dgst_size;\n\n\t\t\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));\n\t\t\t\t\t\tdgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);\n\t\t\t\t\t\tif (dgst_size < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\toffset+=dgst_size;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\t\t\t/*\n\t\t\t * This *should* be the first time we enable CCS, but be\n\t\t\t * extra careful about surrounding code changes. We need\n\t\t\t * to set this here because we don't know if we're\n\t\t\t * expecting a CertificateVerify or not.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_SR_NEXT_PROTO_A:\n\t\tcase SSL3_ST_SR_NEXT_PROTO_B:\n\t\t\t/*\n\t\t\t * Enable CCS for resumed handshakes with NPN.\n\t\t\t * In a full handshake with NPN, we end up here through\n\t\t\t * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was\n\t\t\t * already set. Receiving a CCS clears the flag, so make\n\t\t\t * sure not to re-enable it to ban duplicates.\n\t\t\t * s->s3->change_cipher_spec is set when a CCS is\n\t\t\t * processed in s3_pkt.c, and remains set until\n\t\t\t * the client's Finished message is read.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\n\t\t\tret=ssl3_get_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->init_num = 0;\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\t/*\n\t\t\t * Enable CCS for resumed handshakes without NPN.\n\t\t\t * In a full handshake, we end up here through\n\t\t\t * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was\n\t\t\t * already set. Receiving a CCS clears the flag, so make\n\t\t\t * sure not to re-enable it to ban duplicates.\n\t\t\t * s->s3->change_cipher_spec is set when a CCS is\n\t\t\t * processed in s3_pkt.c, and remains set until\n\t\t\t * the client's Finished message is read.\n\t\t\t */\n\t\t\tif (!s->s3->change_cipher_spec)\n\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\t{\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=ssl3_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\ts->in_handshake--;\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -238,20 +238,11 @@\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \n \t\t\t/* only send if a DH key exchange, fortezza or\n@@ -265,7 +256,7 @@\n \t\t\t * server certificate contains the server's\n \t\t\t * public key for key exchange.\n \t\t\t */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t/* clear this, it may get reset by",
                "\t\t\t * send_server_key_exchange */",
                "\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)",
                "#ifndef OPENSSL_NO_KRB5",
                "\t\t\t\t&& !(alg_k & SSL_kKRB5)",
                "#endif /* OPENSSL_NO_KRB5 */",
                "\t\t\t\t)",
                "\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key",
                "\t\t\t\t * even when forbidden by protocol specs",
                "\t\t\t\t * (handshake may fail as clients are not required to",
                "\t\t\t\t * be able to handle this) */",
                "\t\t\t\ts->s3->tmp.use_rsa_tmp=1;",
                "\t\t\telse",
                "\t\t\t\ts->s3->tmp.use_rsa_tmp=0;",
                "\t\t\tif (s->s3->tmp.use_rsa_tmp"
            ],
            "added_lines": [
                "\t\t\t/*",
                "\t\t\t * clear this, it may get reset by",
                "\t\t\t * send_server_key_exchange",
                "\t\t\t */",
                "\t\t\ts->s3->tmp.use_rsa_tmp=0;",
                "\t\t\tif ("
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0204",
        "func_name": "openssl/ssl3_get_key_exchange",
        "description": "The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the \"FREAK\" issue.  NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.",
        "git_url": "https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0",
        "commit_title": "Only allow ephemeral RSA keys in export ciphersuites.",
        "commit_text": " OpenSSL clients would tolerate temporary RSA keys in non-export ciphersuites. It also had an option SSL_OP_EPHEMERAL_RSA which enabled this server side. Remove both options as they are a protocol violation.  Thanks to Karthikeyan Bhargavan for reporting this issue. (CVE-2015-0204)",
        "func_before": "int ssl3_get_key_exchange(SSL *s)\n\t{\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\n#endif\n\tEVP_MD_CTX md_ctx;\n\tunsigned char *param,*p;\n\tint al,j,ok;\n\tlong i,param_len,n,alg_k,alg_a;\n\tEVP_PKEY *pkey=NULL;\n\tconst EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n\tRSA *rsa=NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n\tDH *dh=NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *ecdh = NULL;\n\tBN_CTX *bn_ctx = NULL;\n\tEC_POINT *srvr_ecpoint = NULL;\n\tint curve_nid = 0;\n\tint encoded_pt_len = 0;\n#endif\n\n\tEVP_MD_CTX_init(&md_ctx);\n\n\t/* use same message size as in ssl3_get_certificate_request()\n\t * as ServerKeyExchange message may be skipped */\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_KEY_EXCH_A,\n\t\tSSL3_ST_CR_KEY_EXCH_B,\n\t\t-1,\n\t\ts->max_cert_list,\n\t\t&ok);\n\tif (!ok) return((int)n);\n\n\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n\n\tif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n\t\t{\n\t\t/*\n\t\t * Can't skip server key exchange if this is an ephemeral\n\t\t * ciphersuite.\n\t\t */\n\t\tif (alg_k & (SSL_kDHE|SSL_kECDHE))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tal = SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifndef OPENSSL_NO_PSK\n\t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n\t\t   omitted if no identity hint is sent. Set\n\t\t   session->sess_cert anyway to avoid problems\n\t\t   later.*/\n\t\tif (alg_k & SSL_kPSK)\n\t\t\t{\n\t\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t\tif (s->ctx->psk_identity_hint)\n\t\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\t\ts->ctx->psk_identity_hint = NULL;\n\t\t\t}\n#endif\n\t\ts->s3->tmp.reuse_message=1;\n\t\treturn(1);\n\t\t}\n\n\tparam=p=(unsigned char *)s->init_msg;\n\tif (s->session->sess_cert != NULL)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n\t\t\t{\n\t\t\tRSA_free(s->session->sess_cert->peer_rsa_tmp);\n\t\t\ts->session->sess_cert->peer_rsa_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\tif (s->session->sess_cert->peer_dh_tmp)\n\t\t\t{\n\t\t\tDH_free(s->session->sess_cert->peer_dh_tmp);\n\t\t\ts->session->sess_cert->peer_dh_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDH\n\t\tif (s->session->sess_cert->peer_ecdh_tmp)\n\t\t\t{\n\t\t\tEC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n\t\t\ts->session->sess_cert->peer_ecdh_tmp=NULL;\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t}\n\n\t/* Total length of the parameters including the length prefix */\n\tparam_len=0;\n\n\talg_a=s->s3->tmp.new_cipher->algorithm_auth;\n\n\tal=SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n\tif (alg_k & SSL_kPSK)\n\t\t{\n\t\tchar tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\t/* Store PSK identity hint for later use, hint is used\n\t\t * in ssl3_send_client_key_exchange.  Assume that the\n\t\t * maximum length of a PSK identity hint can be as\n\t\t * long as the maximum length of a PSK identity. */\n\t\tif (i > PSK_MAX_IDENTITY_LEN)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_DATA_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\t/* If received PSK identity hint contains NULL\n\t\t * characters, the hint is truncated from the first\n\t\t * NULL. p may not be ending with NULL, so create a\n\t\t * NULL-terminated string. */\n\t\tmemcpy(tmp_id_hint, p, i);\n\t\tmemset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);\n\t\tif (s->ctx->psk_identity_hint != NULL)\n\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\ts->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);\n\t\tif (s->ctx->psk_identity_hint == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n\t\t\tgoto f_err;\n\t\t\t}\t   \n\n\t\tp+=i;\n\t\tn-=param_len;\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n\tif (alg_k & SSL_kSRP)\n\t\t{\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (1 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 1;\n\n\t\ti = (unsigned int)(p[0]);\n\t\tp++;\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!srp_verify_server_param(s, &al))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n/* We must check if there is a certificate */\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_SRP */\n#ifndef OPENSSL_NO_RSA\n\tif (alg_k & SSL_kRSA)\n\t\t{\n\t\tif ((rsa=RSA_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->n=BN_bin2bn(p,i,rsa->n)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->e=BN_bin2bn(p,i,rsa->e)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\t/* this should be because we are using an export cipher */\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->session->sess_cert->peer_rsa_tmp=rsa;\n\t\trsa=NULL;\n\t\t}\n#else /* OPENSSL_NO_RSA */\n\tif (0)\n\t\t;\n#endif\n#ifndef OPENSSL_NO_DH\n\telse if (alg_k & SSL_kDHE)\n\t\t{\n\t\tif ((dh=DH_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->p=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->pub_key=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!ssl_security(s, SSL_SECOP_TMP_DH,\n\t\t\t\t\t\tDH_security_bits(dh), 0, dh))\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t/* else anonymous DH, so no certificate or pkey. */\n\n\t\ts->session->sess_cert->peer_dh_tmp=dh;\n\t\tdh=NULL;\n\t\t}\n\telse if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n\telse if (alg_k & SSL_kECDHE)\n\t\t{\n\t\tEC_GROUP *ngroup;\n\t\tconst EC_GROUP *group;\n\n\t\tif ((ecdh=EC_KEY_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Extract elliptic curve parameters and the\n\t\t * server's ephemeral ECDH public key.\n\t\t * Keep accumulating lengths of various components in\n\t\t * param_len and make sure it never exceeds n.\n\t\t */\n\n\t\t/* XXX: For now we only support named (not generic) curves\n\t\t * and the ECParameters in this case is just three bytes. We\n\t\t * also need one byte for the length of the encoded point\n\t\t */\n\t\tparam_len=4;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Check curve is one of our preferences, if not server has\n\t\t * sent an invalid curve. ECParameters is 3 bytes.\n\t\t */\n\t\tif (!tls1_check_curve(s, p, 3))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) \n\t\t\t{\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tngroup = EC_GROUP_new_by_curve_name(curve_nid);\n\t\tif (ngroup == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (EC_KEY_set_group(ecdh, ngroup) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tEC_GROUP_free(ngroup);\n\n\t\tgroup = EC_KEY_get0_group(ecdh);\n\n\t\tif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n\t\t    (EC_GROUP_get_degree(group) > 163))\n\t\t\t{\n\t\t\tal=SSL_AD_EXPORT_RESTRICTION;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tp+=3;\n\n\t\t/* Next, get the encoded ECPoint */\n\t\tif (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n\t\t    ((bn_ctx = BN_CTX_new()) == NULL))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tencoded_pt_len = *p;  /* length of encoded point */\n\t\tp+=1;\n\n\t\tif ((encoded_pt_len > n - param_len) ||\n\t\t    (EC_POINT_oct2point(group, srvr_ecpoint, \n\t\t\tp, encoded_pt_len, bn_ctx) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += encoded_pt_len;\n\n\t\tn-=param_len;\n\t\tp+=encoded_pt_len;\n\n\t\t/* The ECC/TLS specification does not mention\n\t\t * the use of DSA to sign ECParameters in the server\n\t\t * key exchange message. We do support RSA and ECDSA.\n\t\t */\n\t\tif (0) ;\n#ifndef OPENSSL_NO_RSA\n\t\telse if (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\telse if (alg_a & SSL_aECDSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n#endif\n\t\t/* else anonymous ECDH, so no certificate or pkey. */\n\t\tEC_KEY_set_public_key(ecdh, srvr_ecpoint);\n\t\ts->session->sess_cert->peer_ecdh_tmp=ecdh;\n\t\tecdh=NULL;\n\t\tBN_CTX_free(bn_ctx);\n\t\tbn_ctx = NULL;\n\t\tEC_POINT_free(srvr_ecpoint);\n\t\tsrvr_ecpoint = NULL;\n\t\t}\n\telse if (alg_k)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\n\n\t/* p points to the next byte, there are 'n' bytes left */\n\n\t/* if it was signed, check the signature */\n\tif (pkey != NULL)\n\t\t{\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv;\n\t\t\tif (2 > n)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\trv = tls12_check_peer_sigalg(&md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\tgoto err;\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\telse\n\t\t\tmd = EVP_sha1();\n\n\t\tif (2 > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tj=EVP_PKEY_size(pkey);\n\n\t\t/* Check signature length. If n is 0 then signature is empty */\n\t\tif ((i != n) || (n > j) || (n <= 0))\n\t\t\t{\n\t\t\t/* wrong packet length */\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint num;\n\t\t\tunsigned int size;\n\n\t\t\tj=0;\n\t\t\tq=md_buf;\n\t\t\tfor (num=2; num > 0; num--)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_set_flags(&md_ctx,\n\t\t\t\t\tEVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n\t\t\t\tEVP_DigestInit_ex(&md_ctx,(num == 2)\n\t\t\t\t\t?s->ctx->md5:s->ctx->sha1, NULL);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,param,param_len);\n\t\t\t\tEVP_DigestFinal_ex(&md_ctx,q,&size);\n\t\t\t\tq+=size;\n\t\t\t\tj+=size;\n\t\t\t\t}\n\t\t\ti=RSA_verify(NID_md5_sha1, md_buf, j, p, n,\n\t\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\t\tif (i < 0)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n\t\t\tEVP_VerifyInit_ex(&md_ctx, md, NULL);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,param,param_len);\n\t\t\tif (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\t/* aNULL, aSRP or kPSK do not need public keys */\n\t\tif (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))\n\t\t\t{\n\t\t\t/* Might be wrong key type, check it */\n\t\t\tif (ssl3_check_cert_and_algorithm(s))\n\t\t\t\t/* Otherwise this shouldn't happen */\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t/* still data left over */\n\t\tif (n != 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\tEVP_PKEY_free(pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\tEVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n\tif (dh != NULL)\n\t\tDH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tEC_POINT_free(srvr_ecpoint);\n\tif (ecdh != NULL)\n\t\tEC_KEY_free(ecdh);\n#endif\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(-1);\n\t}",
        "func": "int ssl3_get_key_exchange(SSL *s)\n\t{\n#ifndef OPENSSL_NO_RSA\n\tunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\n#endif\n\tEVP_MD_CTX md_ctx;\n\tunsigned char *param,*p;\n\tint al,j,ok;\n\tlong i,param_len,n,alg_k,alg_a;\n\tEVP_PKEY *pkey=NULL;\n\tconst EVP_MD *md = NULL;\n#ifndef OPENSSL_NO_RSA\n\tRSA *rsa=NULL;\n#endif\n#ifndef OPENSSL_NO_DH\n\tDH *dh=NULL;\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tEC_KEY *ecdh = NULL;\n\tBN_CTX *bn_ctx = NULL;\n\tEC_POINT *srvr_ecpoint = NULL;\n\tint curve_nid = 0;\n\tint encoded_pt_len = 0;\n#endif\n\n\tEVP_MD_CTX_init(&md_ctx);\n\n\t/* use same message size as in ssl3_get_certificate_request()\n\t * as ServerKeyExchange message may be skipped */\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_KEY_EXCH_A,\n\t\tSSL3_ST_CR_KEY_EXCH_B,\n\t\t-1,\n\t\ts->max_cert_list,\n\t\t&ok);\n\tif (!ok) return((int)n);\n\n\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n\n\tif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n\t\t{\n\t\t/*\n\t\t * Can't skip server key exchange if this is an ephemeral\n\t\t * ciphersuite.\n\t\t */\n\t\tif (alg_k & (SSL_kDHE|SSL_kECDHE))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tal = SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifndef OPENSSL_NO_PSK\n\t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n\t\t   omitted if no identity hint is sent. Set\n\t\t   session->sess_cert anyway to avoid problems\n\t\t   later.*/\n\t\tif (alg_k & SSL_kPSK)\n\t\t\t{\n\t\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t\tif (s->ctx->psk_identity_hint)\n\t\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\t\ts->ctx->psk_identity_hint = NULL;\n\t\t\t}\n#endif\n\t\ts->s3->tmp.reuse_message=1;\n\t\treturn(1);\n\t\t}\n\n\tparam=p=(unsigned char *)s->init_msg;\n\tif (s->session->sess_cert != NULL)\n\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n\t\t\t{\n\t\t\tRSA_free(s->session->sess_cert->peer_rsa_tmp);\n\t\t\ts->session->sess_cert->peer_rsa_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_DH\n\t\tif (s->session->sess_cert->peer_dh_tmp)\n\t\t\t{\n\t\t\tDH_free(s->session->sess_cert->peer_dh_tmp);\n\t\t\ts->session->sess_cert->peer_dh_tmp=NULL;\n\t\t\t}\n#endif\n#ifndef OPENSSL_NO_ECDH\n\t\tif (s->session->sess_cert->peer_ecdh_tmp)\n\t\t\t{\n\t\t\tEC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\n\t\t\ts->session->sess_cert->peer_ecdh_tmp=NULL;\n\t\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\ts->session->sess_cert=ssl_sess_cert_new();\n\t\t}\n\n\t/* Total length of the parameters including the length prefix */\n\tparam_len=0;\n\n\talg_a=s->s3->tmp.new_cipher->algorithm_auth;\n\n\tal=SSL_AD_DECODE_ERROR;\n\n#ifndef OPENSSL_NO_PSK\n\tif (alg_k & SSL_kPSK)\n\t\t{\n\t\tchar tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\t/* Store PSK identity hint for later use, hint is used\n\t\t * in ssl3_send_client_key_exchange.  Assume that the\n\t\t * maximum length of a PSK identity hint can be as\n\t\t * long as the maximum length of a PSK identity. */\n\t\tif (i > PSK_MAX_IDENTITY_LEN)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_DATA_LENGTH_TOO_LONG);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\t/* If received PSK identity hint contains NULL\n\t\t * characters, the hint is truncated from the first\n\t\t * NULL. p may not be ending with NULL, so create a\n\t\t * NULL-terminated string. */\n\t\tmemcpy(tmp_id_hint, p, i);\n\t\tmemset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);\n\t\tif (s->ctx->psk_identity_hint != NULL)\n\t\t\tOPENSSL_free(s->ctx->psk_identity_hint);\n\t\ts->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);\n\t\tif (s->ctx->psk_identity_hint == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n\t\t\tgoto f_err;\n\t\t\t}\t   \n\n\t\tp+=i;\n\t\tn-=param_len;\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_PSK */\n#ifndef OPENSSL_NO_SRP\n\tif (alg_k & SSL_kSRP)\n\t\t{\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\n\t\tif (1 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 1;\n\n\t\ti = (unsigned int)(p[0]);\n\t\tp++;\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!srp_verify_server_param(s, &al))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n/* We must check if there is a certificate */\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t}\n\telse\n#endif /* !OPENSSL_NO_SRP */\n#ifndef OPENSSL_NO_RSA\n\tif (alg_k & SSL_kRSA)\n\t\t{\n\t\t/* Temporary RSA keys only allowed in export ciphersuites */\n\t\tif (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif ((rsa=RSA_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->n=BN_bin2bn(p,i,rsa->n)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(rsa->e=BN_bin2bn(p,i,rsa->e)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\t/* this should be because we are using an export cipher */\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->session->sess_cert->peer_rsa_tmp=rsa;\n\t\trsa=NULL;\n\t\t}\n#else /* OPENSSL_NO_RSA */\n\tif (0)\n\t\t;\n#endif\n#ifndef OPENSSL_NO_DH\n\telse if (alg_k & SSL_kDHE)\n\t\t{\n\t\tif ((dh=DH_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tparam_len = 2;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->p=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->g=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\n\t\tif (2 > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += 2;\n\n\t\tn2s(p,i);\n\n\t\tif (i > n - param_len)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += i;\n\n\t\tif (!(dh->pub_key=BN_bin2bn(p,i,NULL)))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp+=i;\n\t\tn-=param_len;\n\n\t\tif (!ssl_security(s, SSL_SECOP_TMP_DH,\n\t\t\t\t\t\tDH_security_bits(dh), 0, dh))\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#else\n\t\tif (0)\n\t\t\t;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\telse if (alg_a & SSL_aDSS)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\n#endif\n\t\t/* else anonymous DH, so no certificate or pkey. */\n\n\t\ts->session->sess_cert->peer_dh_tmp=dh;\n\t\tdh=NULL;\n\t\t}\n\telse if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\n\telse if (alg_k & SSL_kECDHE)\n\t\t{\n\t\tEC_GROUP *ngroup;\n\t\tconst EC_GROUP *group;\n\n\t\tif ((ecdh=EC_KEY_new()) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Extract elliptic curve parameters and the\n\t\t * server's ephemeral ECDH public key.\n\t\t * Keep accumulating lengths of various components in\n\t\t * param_len and make sure it never exceeds n.\n\t\t */\n\n\t\t/* XXX: For now we only support named (not generic) curves\n\t\t * and the ECParameters in this case is just three bytes. We\n\t\t * also need one byte for the length of the encoded point\n\t\t */\n\t\tparam_len=4;\n\t\tif (param_len > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Check curve is one of our preferences, if not server has\n\t\t * sent an invalid curve. ECParameters is 3 bytes.\n\t\t */\n\t\tif (!tls1_check_curve(s, p, 3))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) \n\t\t\t{\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tngroup = EC_GROUP_new_by_curve_name(curve_nid);\n\t\tif (ngroup == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (EC_KEY_set_group(ecdh, ngroup) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tEC_GROUP_free(ngroup);\n\n\t\tgroup = EC_KEY_get0_group(ecdh);\n\n\t\tif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\n\t\t    (EC_GROUP_get_degree(group) > 163))\n\t\t\t{\n\t\t\tal=SSL_AD_EXPORT_RESTRICTION;\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tp+=3;\n\n\t\t/* Next, get the encoded ECPoint */\n\t\tif (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\n\t\t    ((bn_ctx = BN_CTX_new()) == NULL))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tencoded_pt_len = *p;  /* length of encoded point */\n\t\tp+=1;\n\n\t\tif ((encoded_pt_len > n - param_len) ||\n\t\t    (EC_POINT_oct2point(group, srvr_ecpoint, \n\t\t\tp, encoded_pt_len, bn_ctx) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tparam_len += encoded_pt_len;\n\n\t\tn-=param_len;\n\t\tp+=encoded_pt_len;\n\n\t\t/* The ECC/TLS specification does not mention\n\t\t * the use of DSA to sign ECParameters in the server\n\t\t * key exchange message. We do support RSA and ECDSA.\n\t\t */\n\t\tif (0) ;\n#ifndef OPENSSL_NO_RSA\n\t\telse if (alg_a & SSL_aRSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\telse if (alg_a & SSL_aECDSA)\n\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n#endif\n\t\t/* else anonymous ECDH, so no certificate or pkey. */\n\t\tEC_KEY_set_public_key(ecdh, srvr_ecpoint);\n\t\ts->session->sess_cert->peer_ecdh_tmp=ecdh;\n\t\tecdh=NULL;\n\t\tBN_CTX_free(bn_ctx);\n\t\tbn_ctx = NULL;\n\t\tEC_POINT_free(srvr_ecpoint);\n\t\tsrvr_ecpoint = NULL;\n\t\t}\n\telse if (alg_k)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\tgoto f_err;\n\t\t}\n#endif /* !OPENSSL_NO_ECDH */\n\n\n\t/* p points to the next byte, there are 'n' bytes left */\n\n\t/* if it was signed, check the signature */\n\tif (pkey != NULL)\n\t\t{\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv;\n\t\t\tif (2 > n)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\trv = tls12_check_peer_sigalg(&md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\tgoto err;\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\telse\n\t\t\tmd = EVP_sha1();\n\n\t\tif (2 > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,\n\t\t\t\tSSL_R_LENGTH_TOO_SHORT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tj=EVP_PKEY_size(pkey);\n\n\t\t/* Check signature length. If n is 0 then signature is empty */\n\t\tif ((i != n) || (n > j) || (n <= 0))\n\t\t\t{\n\t\t\t/* wrong packet length */\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\n\t\t\tgoto f_err;\n\t\t\t}\n\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint num;\n\t\t\tunsigned int size;\n\n\t\t\tj=0;\n\t\t\tq=md_buf;\n\t\t\tfor (num=2; num > 0; num--)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_set_flags(&md_ctx,\n\t\t\t\t\tEVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n\t\t\t\tEVP_DigestInit_ex(&md_ctx,(num == 2)\n\t\t\t\t\t?s->ctx->md5:s->ctx->sha1, NULL);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\t\tEVP_DigestUpdate(&md_ctx,param,param_len);\n\t\t\t\tEVP_DigestFinal_ex(&md_ctx,q,&size);\n\t\t\t\tq+=size;\n\t\t\t\tj+=size;\n\t\t\t\t}\n\t\t\ti=RSA_verify(NID_md5_sha1, md_buf, j, p, n,\n\t\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\t\tif (i < 0)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n#endif\n\t\t\t{\n\t\t\tEVP_VerifyInit_ex(&md_ctx, md, NULL);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\n\t\t\tEVP_VerifyUpdate(&md_ctx,param,param_len);\n\t\t\tif (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\t/* bad signature */\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\t/* aNULL, aSRP or kPSK do not need public keys */\n\t\tif (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))\n\t\t\t{\n\t\t\t/* Might be wrong key type, check it */\n\t\t\tif (ssl3_check_cert_and_algorithm(s))\n\t\t\t\t/* Otherwise this shouldn't happen */\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t/* still data left over */\n\t\tif (n != 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\tEVP_PKEY_free(pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\tEVP_PKEY_free(pkey);\n#ifndef OPENSSL_NO_RSA\n\tif (rsa != NULL)\n\t\tRSA_free(rsa);\n#endif\n#ifndef OPENSSL_NO_DH\n\tif (dh != NULL)\n\t\tDH_free(dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tBN_CTX_free(bn_ctx);\n\tEC_POINT_free(srvr_ecpoint);\n\tif (ecdh != NULL)\n\t\tEC_KEY_free(ecdh);\n#endif\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\treturn(-1);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -283,6 +283,13 @@\n #ifndef OPENSSL_NO_RSA\n \tif (alg_k & SSL_kRSA)\n \t\t{\n+\t\t/* Temporary RSA keys only allowed in export ciphersuites */\n+\t\tif (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))\n+\t\t\t{\n+\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n+\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);\n+\t\t\tgoto f_err;\n+\t\t\t}\n \t\tif ((rsa=RSA_new()) == NULL)\n \t\t\t{\n \t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/* Temporary RSA keys only allowed in export ciphersuites */",
                "\t\tif (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))",
                "\t\t\t{",
                "\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;",
                "\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);",
                "\t\t\tgoto f_err;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0205",
        "func_name": "openssl/ssl3_get_cert_verify",
        "description": "The ssl3_get_cert_verify function in s3_srvr.c in OpenSSL 1.0.0 before 1.0.0p and 1.0.1 before 1.0.1k accepts client authentication with a Diffie-Hellman (DH) certificate without requiring a CertificateVerify message, which allows remote attackers to obtain access without knowledge of a private key via crafted TLS Handshake Protocol traffic to a server that recognizes a Certification Authority with DH support.",
        "git_url": "https://github.com/openssl/openssl/commit/1421e0c584ae9120ca1b88098f13d6d2e90b83a3",
        "commit_title": "Unauthenticated DH client certificate fix.",
        "commit_text": " Fix to prevent use of DH client certificates without sending certificate verify message.  If we've used a client certificate to generate the premaster secret ssl3_get_client_key_exchange returns 2 and ssl3_get_cert_verify is never called.  We can only skip the certificate verify message in ssl3_get_cert_verify if the client didn't send a certificate.  Thanks to Karthikeyan Bhargavan for reporting this issue. CVE-2015-0205",
        "func_before": "int ssl3_get_cert_verify(SSL *s)\n\t{\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char *p;\n\tint al,ok,ret=0;\n\tlong n;\n\tint type=0,i,j;\n\tX509 *peer;\n\tconst EVP_MD *md = NULL;\n\tEVP_MD_CTX mctx;\n\tEVP_MD_CTX_init(&mctx);\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_SR_CERT_VRFY_A,\n\t\tSSL3_ST_SR_CERT_VRFY_B,\n\t\t-1,\n\t\tSSL3_RT_MAX_PLAIN_LENGTH,\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tif (s->session->peer != NULL)\n\t\t{\n\t\tpeer=s->session->peer;\n\t\tpkey=X509_get_pubkey(peer);\n\t\ttype=X509_certificate_type(peer,pkey);\n\t\t}\n\telse\n\t\t{\n\t\tpeer=NULL;\n\t\tpkey=NULL;\n\t\t}\n\n\tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n\t\t{\n\t\ts->s3->tmp.reuse_message=1;\n\t\tif ((peer != NULL) && (type & EVP_PKT_SIGN))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tret=1;\n\t\tgoto end;\n\t\t}\n\n\tif (peer == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\tif (!(type & EVP_PKT_SIGN))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tgoto f_err;\n\t\t}\n\n\tif (s->s3->change_cipher_spec)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\t/* we now have a signature that we need to verify */\n\tp=(unsigned char *)s->init_msg;\n\t/* Check for broken implementations of GOST ciphersuites */\n\t/* If key is GOST and n is exactly 64, it is bare\n\t * signature without length field */\n\tif (n==64 && (pkey->type==NID_id_GostR3410_94 ||\n\t\tpkey->type == NID_id_GostR3410_2001) )\n\t\t{\n\t\ti=64;\n\t\t} \n\telse \n\t\t{\t\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv = tls12_check_peer_sigalg(&md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_DECODE_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tif (i > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n    \t}\n\tj=EVP_PKEY_size(pkey);\n\tif ((i > j) || (n > j) || (n <= 0))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tgoto f_err;\n\t\t}\n\n\tif (SSL_USE_SIGALGS(s))\n\t\t{\n\t\tlong hdatalen = 0;\n\t\tvoid *hdata;\n\t\thdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n\t\tif (hdatalen <= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifdef SSL_DEBUG\n\t\tfprintf(stderr, \"Using TLS 1.2 with client verify alg %s\\n\",\n\t\t\t\t\t\t\tEVP_MD_name(md));\n#endif\n\t\tif (!EVP_VerifyInit_ex(&mctx, md, NULL)\n\t\t\t|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#ifndef OPENSSL_NO_RSA \n\tif (pkey->type == EVP_PKEY_RSA)\n\t\t{\n\t\ti=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,\n\t\t\tMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, \n\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t{\n\t\tj=DSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t{\n\t\tj=ECDSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t    SSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n\tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)\n\t\t{   unsigned char signature[64];\n\t\t\tint idx;\n\t\t\tEVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\t\tEVP_PKEY_verify_init(pctx);\n\t\t\tif (i!=64) {\n\t\t\t\tfprintf(stderr,\"GOST signature length is %d\",i);\n\t\t\t}\t\n\t\t\tfor (idx=0;idx<64;idx++) {\n\t\t\t\tsignature[63-idx]=p[idx];\n\t\t\t}\t\n\t\t\tj=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);\n\t\t\tEVP_PKEY_CTX_free(pctx);\n\t\t\tif (j<=0) \n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t\t\tSSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\t\n\t\t}\n\telse\t\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\tal=SSL_AD_UNSUPPORTED_CERTIFICATE;\n\t\tgoto f_err;\n\t\t}\n\n\n\tret=1;\n\tif (0)\n\t\t{\nf_err:\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\t}\nend:\n\tif (s->s3->handshake_buffer)\n\t\t{\n\t\tBIO_free(s->s3->handshake_buffer);\n\t\ts->s3->handshake_buffer = NULL;\n\t\ts->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t}\n\tEVP_MD_CTX_cleanup(&mctx);\n\tEVP_PKEY_free(pkey);\n\treturn(ret);\n\t}",
        "func": "int ssl3_get_cert_verify(SSL *s)\n\t{\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char *p;\n\tint al,ok,ret=0;\n\tlong n;\n\tint type=0,i,j;\n\tX509 *peer;\n\tconst EVP_MD *md = NULL;\n\tEVP_MD_CTX mctx;\n\tEVP_MD_CTX_init(&mctx);\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_SR_CERT_VRFY_A,\n\t\tSSL3_ST_SR_CERT_VRFY_B,\n\t\t-1,\n\t\tSSL3_RT_MAX_PLAIN_LENGTH,\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tif (s->session->peer != NULL)\n\t\t{\n\t\tpeer=s->session->peer;\n\t\tpkey=X509_get_pubkey(peer);\n\t\ttype=X509_certificate_type(peer,pkey);\n\t\t}\n\telse\n\t\t{\n\t\tpeer=NULL;\n\t\tpkey=NULL;\n\t\t}\n\n\tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n\t\t{\n\t\ts->s3->tmp.reuse_message=1;\n\t\tif (peer != NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tret=1;\n\t\tgoto end;\n\t\t}\n\n\tif (peer == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\tif (!(type & EVP_PKT_SIGN))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tgoto f_err;\n\t\t}\n\n\tif (s->s3->change_cipher_spec)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\t/* we now have a signature that we need to verify */\n\tp=(unsigned char *)s->init_msg;\n\t/* Check for broken implementations of GOST ciphersuites */\n\t/* If key is GOST and n is exactly 64, it is bare\n\t * signature without length field */\n\tif (n==64 && (pkey->type==NID_id_GostR3410_94 ||\n\t\tpkey->type == NID_id_GostR3410_2001) )\n\t\t{\n\t\ti=64;\n\t\t} \n\telse \n\t\t{\t\n\t\tif (SSL_USE_SIGALGS(s))\n\t\t\t{\n\t\t\tint rv = tls12_check_peer_sigalg(&md, s, p, pkey);\n\t\t\tif (rv == -1)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\telse if (rv == 0)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_DECODE_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tif (i > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n    \t}\n\tj=EVP_PKEY_size(pkey);\n\tif ((i > j) || (n > j) || (n <= 0))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tgoto f_err;\n\t\t}\n\n\tif (SSL_USE_SIGALGS(s))\n\t\t{\n\t\tlong hdatalen = 0;\n\t\tvoid *hdata;\n\t\thdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n\t\tif (hdatalen <= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifdef SSL_DEBUG\n\t\tfprintf(stderr, \"Using TLS 1.2 with client verify alg %s\\n\",\n\t\t\t\t\t\t\tEVP_MD_name(md));\n#endif\n\t\tif (!EVP_VerifyInit_ex(&mctx, md, NULL)\n\t\t\t|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#ifndef OPENSSL_NO_RSA \n\tif (pkey->type == EVP_PKEY_RSA)\n\t\t{\n\t\ti=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,\n\t\t\tMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, \n\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t{\n\t\tj=DSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t{\n\t\tj=ECDSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t    SSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n\tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)\n\t\t{   unsigned char signature[64];\n\t\t\tint idx;\n\t\t\tEVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\t\tEVP_PKEY_verify_init(pctx);\n\t\t\tif (i!=64) {\n\t\t\t\tfprintf(stderr,\"GOST signature length is %d\",i);\n\t\t\t}\t\n\t\t\tfor (idx=0;idx<64;idx++) {\n\t\t\t\tsignature[63-idx]=p[idx];\n\t\t\t}\t\n\t\t\tj=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);\n\t\t\tEVP_PKEY_CTX_free(pctx);\n\t\t\tif (j<=0) \n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t\t\tSSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\t\n\t\t}\n\telse\t\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\tal=SSL_AD_UNSUPPORTED_CERTIFICATE;\n\t\tgoto f_err;\n\t\t}\n\n\n\tret=1;\n\tif (0)\n\t\t{\nf_err:\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\t}\nend:\n\tif (s->s3->handshake_buffer)\n\t\t{\n\t\tBIO_free(s->s3->handshake_buffer);\n\t\ts->s3->handshake_buffer = NULL;\n\t\ts->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t}\n\tEVP_MD_CTX_cleanup(&mctx);\n\tEVP_PKEY_free(pkey);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,7 @@\n \tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n \t\t{\n \t\ts->s3->tmp.reuse_message=1;\n-\t\tif ((peer != NULL) && (type & EVP_PKT_SIGN))\n+\t\tif (peer != NULL)\n \t\t\t{\n \t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif ((peer != NULL) && (type & EVP_PKT_SIGN))"
            ],
            "added_lines": [
                "\t\tif (peer != NULL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3624",
        "func_name": "torvalds/linux/get_instantiation_keyring",
        "description": "The get_instantiation_keyring function in security/keys/keyctl.c in the KEYS subsystem in the Linux kernel before 2.6.32-rc5 does not properly maintain the reference count of a keyring, which allows local users to gain privileges or cause a denial of service (OOPS) via vectors involving calls to this function without specifying a keyring by ID, as demonstrated by a series of keyctl request2 and keyctl list commands.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=21279cfa107af07ef985539ac0de2152b9cba5f5",
        "commit_title": "The destination keyring specified to request_key() and co. is made available to",
        "commit_text": "the process that instantiates the key (the slave process started by /sbin/request-key typically).  This is passed in the request_key_auth struct as the dest_keyring member.  keyctl_instantiate_key and keyctl_negate_key() call get_instantiation_keyring() to get the keyring to attach the newly constructed key to at the end of instantiation.  This may be given a specific keyring into which a link will be made later, or it may be asked to find the keyring passed to request_key().  In the former case, it returns a keyring with the refcount incremented by lookup_user_key(); in the latter case, it returns the keyring from the request_key_auth struct - and does _not_ increment the refcount.  The latter case will eventually result in an oops when the keyring prematurely runs out of references and gets destroyed.  The effect may take some time to show up as the key is destroyed lazily.  To fix this, the keyring returned by get_instantiation_keyring() must always have its refcount incremented, no matter where it comes from.  This can be tested by setting /etc/request-key.conf to:  #OP\tTYPE\tDESCRIPTION\tCALLOUT INFO\tPROGRAM ARG1 ARG2 ARG3 ... #======\t=======\t===============\t===============\t=============================== create  *\ttest:*\t\t*\t\t|/bin/false %u %g %d %{user:_display} negate\t*\t*\t\t*\t\t/bin/keyctl negate %k 10 @u  and then doing:  \tkeyctl add user _display aaaaaaaa @u         while keyctl request2 user test:x test:x @u &&         keyctl list @u;         do                 keyctl request2 user test:x test:x @u;                 sleep 31;                 keyctl list @u;         done  which will oops eventually.  Changing the negate line to have @u rather than %S at the end is important as that forces the latter case by passing a special keyring ID rather than an actual keyring ID.  ",
        "func_before": "static long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = rka->dest_keyring;\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}",
        "func": "static long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n \t/* otherwise specify the destination keyring recorded in the\n \t * authorisation key (any KEY_SPEC_*_KEYRING) */\n \tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n-\t\t*_dest_keyring = rka->dest_keyring;\n+\t\t*_dest_keyring = key_get(rka->dest_keyring);\n \t\treturn 0;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t*_dest_keyring = rka->dest_keyring;"
            ],
            "added_lines": [
                "\t\t*_dest_keyring = key_get(rka->dest_keyring);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-1573",
        "func_name": "gnutls/_gnutls_ciphertext2compressed",
        "description": "gnutls_cipher.c in libgnutls in GnuTLS before 2.12.17 and 3.x before 3.0.15 does not properly handle data encrypted with a block cipher, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) via a crafted record, as demonstrated by a crafted GenericBlockCipher structure.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=422214868061370aeeb0ac9cd0f021a5c350a57d",
        "commit_title": "",
        "commit_text": "better check decrypted data. ",
        "func_before": "int\n_gnutls_ciphertext2compressed (gnutls_session_t session,\n                               opaque * compress_data,\n                               int compress_size,\n                               gnutls_datum_t ciphertext, uint8_t type,\n                               record_parameters_st * params)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  opaque preamble[PREAMBLE_SIZE];\n  int preamble_size;\n  int ver = gnutls_protocol_get_version (session);\n  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (_gnutls_version_has_explicit_iv\n          (session->security_parameters.version))\n        {\n          ciphertext.size -= blocksize;\n          ciphertext.data += blocksize;\n\n          if (ciphertext.size == 0)\n            {\n              gnutls_assert ();\n              return GNUTLS_E_DECRYPTION_FAILED;\n            }\n        }\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */\n\n      if ((int) pad > (int) ciphertext.size - hash_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext.size, hash_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)\n        for (i = 2; i < pad; i++)\n          {\n            if (ciphertext.data[ciphertext.size - i] !=\n                ciphertext.data[ciphertext.size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (params->mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      digest_hd_st td;\n\n      ret = mac_init (&td, params->mac_algorithm,\n                      params->read.mac_secret.data,\n                      params->read.mac_secret.size, ver);\n\n      if (ret < 0)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_INTERNAL_ERROR;\n        }\n\n      preamble_size =\n        make_preamble (UINT64DATA\n                       (params->read.sequence_number), type,\n                       c_length, ver, preamble);\n      mac_hash (&td, preamble, preamble_size, ver);\n      if (length > 0)\n        mac_hash (&td, ciphertext.data, length, ver);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    {\n      gnutls_assert ();\n      return pad_failed;\n    }\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
        "func": "int\n_gnutls_ciphertext2compressed (gnutls_session_t session,\n                               opaque * compress_data,\n                               int compress_size,\n                               gnutls_datum_t ciphertext, uint8_t type,\n                               record_parameters_st * params)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  opaque preamble[PREAMBLE_SIZE];\n  int preamble_size;\n  int ver = gnutls_protocol_get_version (session);\n  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state,\n                                   ciphertext.data, ciphertext.size)) < 0)\n        {\n          gnutls_assert ();\n          return ret;\n        }\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (_gnutls_version_has_explicit_iv\n          (session->security_parameters.version))\n        {\n          ciphertext.size -= blocksize;\n          ciphertext.data += blocksize;\n        }\n\n      if (ciphertext.size < hash_size)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_DECRYPTION_FAILED;\n        }\n      pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */\n\n      if ((int) pad > (int) ciphertext.size - hash_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext.size, hash_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n        }\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)\n        for (i = 2; i < pad; i++)\n          {\n            if (ciphertext.data[ciphertext.size - i] !=\n                ciphertext.data[ciphertext.size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (params->mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      digest_hd_st td;\n\n      ret = mac_init (&td, params->mac_algorithm,\n                      params->read.mac_secret.data,\n                      params->read.mac_secret.size, ver);\n\n      if (ret < 0)\n        {\n          gnutls_assert ();\n          return GNUTLS_E_INTERNAL_ERROR;\n        }\n\n      preamble_size =\n        make_preamble (UINT64DATA\n                       (params->read.sequence_number), type,\n                       c_length, ver, preamble);\n      mac_hash (&td, preamble, preamble_size, ver);\n      if (length > 0)\n        mac_hash (&td, ciphertext.data, length, ver);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    {\n      gnutls_assert ();\n      return pad_failed;\n    }\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,14 +57,13 @@\n         {\n           ciphertext.size -= blocksize;\n           ciphertext.data += blocksize;\n-\n-          if (ciphertext.size == 0)\n-            {\n-              gnutls_assert ();\n-              return GNUTLS_E_DECRYPTION_FAILED;\n-            }\n         }\n \n+      if (ciphertext.size < hash_size)\n+        {\n+          gnutls_assert ();\n+          return GNUTLS_E_DECRYPTION_FAILED;\n+        }\n       pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */\n \n       if ((int) pad > (int) ciphertext.size - hash_size)",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "          if (ciphertext.size == 0)",
                "            {",
                "              gnutls_assert ();",
                "              return GNUTLS_E_DECRYPTION_FAILED;",
                "            }"
            ],
            "added_lines": [
                "      if (ciphertext.size < hash_size)",
                "        {",
                "          gnutls_assert ();",
                "          return GNUTLS_E_DECRYPTION_FAILED;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-1573",
        "func_name": "gnutls/ciphertext_to_compressed",
        "description": "gnutls_cipher.c in libgnutls in GnuTLS before 2.12.17 and 3.x before 3.0.15 does not properly handle data encrypted with a block cipher, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) via a crafted record, as demonstrated by a crafted GenericBlockCipher structure.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=b495740f2ff66550ca9395b3fda3ea32c3acb185",
        "commit_title": "",
        "commit_text": "changes in packet parsing. ",
        "func_before": "static int\nciphertext_to_compressed (gnutls_session_t session,\n                          gnutls_datum_t *ciphertext, \n                          uint8_t * compress_data,\n                          int compress_size,\n                          uint8_t type, record_parameters_st * params, \n                          uint64* sequence)\n{\n  uint8_t tag[MAX_HASH_SIZE];\n  uint8_t pad;\n  int length, length_to_decrypt;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t preamble[MAX_PREAMBLE_SIZE];\n  unsigned int preamble_size;\n  unsigned int ver = gnutls_protocol_get_version (session);\n  unsigned int tag_size = _gnutls_auth_cipher_tag_len (&params->read.cipher_state);\n  unsigned int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      /* The way AEAD ciphers are defined in RFC5246, it allows\n       * only stream ciphers.\n       */\n      if (explicit_iv && _gnutls_auth_cipher_is_aead(&params->read.cipher_state))\n        {\n          uint8_t nonce[blocksize];\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->read.IV.data == NULL || params->read.IV.size != 4)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n          \n          if (ciphertext->size < tag_size+AEAD_EXPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n          memcpy(nonce, params->read.IV.data, AEAD_IMPLICIT_DATA_SIZE);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], ciphertext->data, AEAD_EXPLICIT_DATA_SIZE);\n          \n          _gnutls_auth_cipher_setiv(&params->read.cipher_state, nonce, AEAD_EXPLICIT_DATA_SIZE+AEAD_IMPLICIT_DATA_SIZE);\n\n          ciphertext->data += AEAD_EXPLICIT_DATA_SIZE;\n          ciphertext->size -= AEAD_EXPLICIT_DATA_SIZE;\n          \n          length_to_decrypt = ciphertext->size - tag_size;\n        }\n      else\n        {\n          if (ciphertext->size < tag_size)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n  \n          length_to_decrypt = ciphertext->size;\n        }\n\n      length = ciphertext->size - tag_size;\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      if ((ret =\n           _gnutls_auth_cipher_decrypt2 (&params->read.cipher_state,\n             ciphertext->data, length_to_decrypt,\n             ciphertext->data, ciphertext->size)) < 0)\n        return gnutls_assert_val(ret);\n\n      break;\n    case CIPHER_BLOCK:\n      if (ciphertext->size < MAX(blocksize, tag_size) || (ciphertext->size % blocksize != 0))\n        return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n      /* ignore the IV in TLS 1.1+\n       */\n      if (explicit_iv)\n        {\n          _gnutls_auth_cipher_setiv(&params->read.cipher_state,\n            ciphertext->data, blocksize);\n\n          ciphertext->size -= blocksize;\n          ciphertext->data += blocksize;\n\n          if (ciphertext->size == 0)\n            {\n              gnutls_assert ();\n              return GNUTLS_E_DECRYPTION_FAILED;\n            }\n        }\n\n      /* we don't use the auth_cipher interface here, since\n       * TLS with block ciphers is impossible to be used under such\n       * an API. (the length of plaintext is required to calculate\n       * auth_data, but it is not available before decryption).\n       */\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state.cipher,\n             ciphertext->data, ciphertext->size)) < 0)\n        return gnutls_assert_val(ret);\n\n      pad = ciphertext->data[ciphertext->size - 1] + 1;   /* pad */\n\n      if ((int) pad > (int) ciphertext->size - tag_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext->size, tag_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          pad %= blocksize;\n        }\n\n      length = ciphertext->size - tag_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver != GNUTLS_SSL3)\n        for (i = 2; i < pad; i++)\n          {\n            if (ciphertext->data[ciphertext->size - i] !=\n                ciphertext->data[ciphertext->size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n\n      if (length < 0)\n        {\n          /* Setting a proper length to prevent timing differences in\n           * processing of records with invalid encryption.\n           */\n          length = ciphertext->size - tag_size;\n        }\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, ciphertext->data, length);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      break;\n    default:\n      return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  ret = _gnutls_auth_cipher_tag(&params->read.cipher_state, tag, tag_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  /* HMAC was not the same. \n   */\n  if (memcmp (tag, &ciphertext->data[length], tag_size) != 0 || pad_failed != 0)\n    return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    return gnutls_assert_val(GNUTLS_E_DECOMPRESSION_FAILED);\n\n  if (compress_data != ciphertext->data)\n    memcpy (compress_data, ciphertext->data, length);\n\n  return length;\n}",
        "func": "static int\nciphertext_to_compressed (gnutls_session_t session,\n                          gnutls_datum_t *ciphertext, \n                          uint8_t * compress_data,\n                          int compress_size,\n                          uint8_t type, record_parameters_st * params, \n                          uint64* sequence)\n{\n  uint8_t tag[MAX_HASH_SIZE];\n  uint8_t pad;\n  int length, length_to_decrypt;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t preamble[MAX_PREAMBLE_SIZE];\n  unsigned int preamble_size;\n  unsigned int ver = gnutls_protocol_get_version (session);\n  unsigned int tag_size = _gnutls_auth_cipher_tag_len (&params->read.cipher_state);\n  unsigned int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n\n  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      /* The way AEAD ciphers are defined in RFC5246, it allows\n       * only stream ciphers.\n       */\n      if (explicit_iv && _gnutls_auth_cipher_is_aead(&params->read.cipher_state))\n        {\n          uint8_t nonce[blocksize];\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->read.IV.data == NULL || params->read.IV.size != 4)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n          \n          if (ciphertext->size < tag_size+AEAD_EXPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n          memcpy(nonce, params->read.IV.data, AEAD_IMPLICIT_DATA_SIZE);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], ciphertext->data, AEAD_EXPLICIT_DATA_SIZE);\n          \n          _gnutls_auth_cipher_setiv(&params->read.cipher_state, nonce, AEAD_EXPLICIT_DATA_SIZE+AEAD_IMPLICIT_DATA_SIZE);\n\n          ciphertext->data += AEAD_EXPLICIT_DATA_SIZE;\n          ciphertext->size -= AEAD_EXPLICIT_DATA_SIZE;\n          \n          length_to_decrypt = ciphertext->size - tag_size;\n        }\n      else\n        {\n          if (ciphertext->size < tag_size)\n            return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n  \n          length_to_decrypt = ciphertext->size;\n        }\n\n      length = ciphertext->size - tag_size;\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      if ((ret =\n           _gnutls_auth_cipher_decrypt2 (&params->read.cipher_state,\n             ciphertext->data, length_to_decrypt,\n             ciphertext->data, ciphertext->size)) < 0)\n        return gnutls_assert_val(ret);\n\n      break;\n    case CIPHER_BLOCK:\n      if (ciphertext->size < blocksize || (ciphertext->size % blocksize != 0))\n        return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n\n      /* ignore the IV in TLS 1.1+\n       */\n      if (explicit_iv)\n        {\n          _gnutls_auth_cipher_setiv(&params->read.cipher_state,\n            ciphertext->data, blocksize);\n\n          ciphertext->size -= blocksize;\n          ciphertext->data += blocksize;\n        }\n\n      if (ciphertext->size < tag_size)\n        return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n\n      /* we don't use the auth_cipher interface here, since\n       * TLS with block ciphers is impossible to be used under such\n       * an API. (the length of plaintext is required to calculate\n       * auth_data, but it is not available before decryption).\n       */\n      if ((ret =\n           _gnutls_cipher_decrypt (&params->read.cipher_state.cipher,\n             ciphertext->data, ciphertext->size)) < 0)\n        return gnutls_assert_val(ret);\n\n      pad = ciphertext->data[ciphertext->size - 1] + 1;   /* pad */\n\n\n      if ((int) pad > (int) ciphertext->size - tag_size)\n        {\n          gnutls_assert ();\n          _gnutls_record_log\n            (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n             session, pad, ciphertext->size, tag_size);\n          /* We do not fail here. We check below for the\n           * the pad_failed. If zero means success.\n           */\n          pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          pad %= blocksize;\n        }\n\n      length = ciphertext->size - tag_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver != GNUTLS_SSL3)\n        for (i = 2; i < pad; i++)\n          {\n            if (ciphertext->data[ciphertext->size - i] !=\n                ciphertext->data[ciphertext->size - 1])\n              pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n          }\n\n      if (length < 0)\n        {\n          /* Setting a proper length to prevent timing differences in\n           * processing of records with invalid encryption.\n           */\n          length = ciphertext->size - tag_size;\n        }\n\n      /* Pass the type, version, length and compressed through\n       * MAC.\n       */\n      preamble_size =\n        make_preamble (UINT64DATA(*sequence), type,\n                       length, ver, preamble);\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, ciphertext->data, length);\n      if (ret < 0)\n        return gnutls_assert_val(ret);\n\n      break;\n    default:\n      return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  ret = _gnutls_auth_cipher_tag(&params->read.cipher_state, tag, tag_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  /* HMAC was not the same. \n   */\n  if (memcmp (tag, &ciphertext->data[length], tag_size) != 0 || pad_failed != 0)\n    return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    return gnutls_assert_val(GNUTLS_E_DECOMPRESSION_FAILED);\n\n  if (compress_data != ciphertext->data)\n    memcpy (compress_data, ciphertext->data, length);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,7 +77,7 @@\n \n       break;\n     case CIPHER_BLOCK:\n-      if (ciphertext->size < MAX(blocksize, tag_size) || (ciphertext->size % blocksize != 0))\n+      if (ciphertext->size < blocksize || (ciphertext->size % blocksize != 0))\n         return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n \n       /* ignore the IV in TLS 1.1+\n@@ -89,13 +89,10 @@\n \n           ciphertext->size -= blocksize;\n           ciphertext->data += blocksize;\n+        }\n \n-          if (ciphertext->size == 0)\n-            {\n-              gnutls_assert ();\n-              return GNUTLS_E_DECRYPTION_FAILED;\n-            }\n-        }\n+      if (ciphertext->size < tag_size)\n+        return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n \n       /* we don't use the auth_cipher interface here, since\n        * TLS with block ciphers is impossible to be used under such\n@@ -108,6 +105,7 @@\n         return gnutls_assert_val(ret);\n \n       pad = ciphertext->data[ciphertext->size - 1] + 1;   /* pad */\n+\n \n       if ((int) pad > (int) ciphertext->size - tag_size)\n         {",
        "diff_line_info": {
            "deleted_lines": [
                "      if (ciphertext->size < MAX(blocksize, tag_size) || (ciphertext->size % blocksize != 0))",
                "          if (ciphertext->size == 0)",
                "            {",
                "              gnutls_assert ();",
                "              return GNUTLS_E_DECRYPTION_FAILED;",
                "            }",
                "        }"
            ],
            "added_lines": [
                "      if (ciphertext->size < blocksize || (ciphertext->size % blocksize != 0))",
                "        }",
                "      if (ciphertext->size < tag_size)",
                "        return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2012-1573",
        "func_name": "gnutls/compressed_to_ciphertext",
        "description": "gnutls_cipher.c in libgnutls in GnuTLS before 2.12.17 and 3.x before 3.0.15 does not properly handle data encrypted with a block cipher, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) via a crafted record, as demonstrated by a crafted GenericBlockCipher structure.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=b495740f2ff66550ca9395b3fda3ea32c3acb185",
        "commit_title": "",
        "commit_text": "changes in packet parsing. ",
        "func_before": "static int\ncompressed_to_ciphertext (gnutls_session_t session,\n                               uint8_t * cipher_data, int cipher_size,\n                               gnutls_datum_t *compressed,\n                               content_type_t type, \n                               record_parameters_st * params)\n{\n  uint8_t * tag_ptr = NULL;\n  uint8_t pad;\n  int length, length_to_encrypt, ret;\n  uint8_t preamble[MAX_PREAMBLE_SIZE];\n  int preamble_size;\n  int tag_size = _gnutls_auth_cipher_tag_len (&params->write.cipher_state);\n  int blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n  unsigned block_algo =\n    _gnutls_cipher_is_block (params->cipher_algorithm);\n  uint8_t *data_ptr;\n  int ver = gnutls_protocol_get_version (session);\n  int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n  int auth_cipher = _gnutls_auth_cipher_is_aead(&params->write.cipher_state);\n  int random_pad;\n  \n  /* We don't use long padding if requested or if we are in DTLS.\n   */\n  if (session->internals.priorities.no_padding == 0 && (!IS_DTLS(session)))\n    random_pad = 1;\n  else\n    random_pad = 0;\n  \n  _gnutls_hard_log(\"ENC[%p]: cipher: %s, MAC: %s, Epoch: %u\\n\",\n    session, gnutls_cipher_get_name(params->cipher_algorithm), gnutls_mac_get_name(params->mac_algorithm),\n    (unsigned int)params->epoch);\n\n  preamble_size =\n    make_preamble (UINT64DATA\n                   (params->write.sequence_number),\n                   type, compressed->size, ver, preamble);\n\n  /* Calculate the encrypted length (padding etc.)\n   */\n  length_to_encrypt = length =\n    calc_enc_length (session, compressed->size, tag_size, &pad,\n                     random_pad, block_algo, auth_cipher, blocksize);\n  if (length < 0)\n    {\n      return gnutls_assert_val(length);\n    }\n\n  /* copy the encrypted data to cipher_data.\n   */\n  if (cipher_size < length)\n    {\n      return gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n    }\n\n  data_ptr = cipher_data;\n\n  if (explicit_iv)\n    {\n\n      if (block_algo == CIPHER_BLOCK)\n        {\n          /* copy the random IV.\n           */\n          ret = _gnutls_rnd (GNUTLS_RND_NONCE, data_ptr, blocksize);\n          if (ret < 0)\n            return gnutls_assert_val(ret);\n\n          _gnutls_auth_cipher_setiv(&params->write.cipher_state, data_ptr, blocksize);\n\n          data_ptr += blocksize;\n          cipher_data += blocksize;\n          length_to_encrypt -= blocksize;\n        }\n      else if (auth_cipher)\n        {\n          uint8_t nonce[blocksize];\n\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->write.IV.data == NULL || params->write.IV.size != AEAD_IMPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n\n          /* Instead of generating a new nonce on every packet, we use the\n           * write.sequence_number (It is a MAY on RFC 5288).\n           */\n          memcpy(nonce, params->write.IV.data, params->write.IV.size);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], UINT64DATA(params->write.sequence_number), 8);\n\n          _gnutls_auth_cipher_setiv(&params->write.cipher_state, nonce, AEAD_IMPLICIT_DATA_SIZE+AEAD_EXPLICIT_DATA_SIZE);\n\n          /* copy the explicit part */\n          memcpy(data_ptr, &nonce[AEAD_IMPLICIT_DATA_SIZE], AEAD_EXPLICIT_DATA_SIZE);\n\n          data_ptr += AEAD_EXPLICIT_DATA_SIZE;\n          cipher_data += AEAD_EXPLICIT_DATA_SIZE;\n          /* In AEAD ciphers we don't encrypt the tag \n           */\n          length_to_encrypt -= AEAD_EXPLICIT_DATA_SIZE + tag_size;\n        }\n    }\n  else\n    {\n      /* AEAD ciphers have an explicit IV. Shouldn't be used otherwise.\n       */\n      if (auth_cipher) return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  memcpy (data_ptr, compressed->data, compressed->size);\n  data_ptr += compressed->size;\n\n  if (tag_size > 0)\n    {\n      tag_ptr = data_ptr;\n      data_ptr += tag_size;\n    }\n  if (block_algo == CIPHER_BLOCK && pad > 0)\n    {\n      memset (data_ptr, pad - 1, pad);\n    }\n\n  /* add the authenticate data */\n  ret = _gnutls_auth_cipher_add_auth(&params->write.cipher_state, preamble, preamble_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* Actual encryption (inplace).\n   */\n  ret =\n    _gnutls_auth_cipher_encrypt2_tag (&params->write.cipher_state,\n        cipher_data, length_to_encrypt, \n        cipher_data, cipher_size,\n        tag_ptr, tag_size, compressed->size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  return length;\n}",
        "func": "static int\ncompressed_to_ciphertext (gnutls_session_t session,\n                               uint8_t * cipher_data, int cipher_size,\n                               gnutls_datum_t *compressed,\n                               content_type_t type, \n                               record_parameters_st * params)\n{\n  uint8_t * tag_ptr = NULL;\n  uint8_t pad;\n  int length, length_to_encrypt, ret;\n  uint8_t preamble[MAX_PREAMBLE_SIZE];\n  int preamble_size;\n  int tag_size = _gnutls_auth_cipher_tag_len (&params->write.cipher_state);\n  int blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n  unsigned block_algo =\n    _gnutls_cipher_is_block (params->cipher_algorithm);\n  uint8_t *data_ptr;\n  int ver = gnutls_protocol_get_version (session);\n  int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n  int auth_cipher = _gnutls_auth_cipher_is_aead(&params->write.cipher_state);\n  int random_pad;\n  \n  /* We don't use long padding if requested or if we are in DTLS.\n   */\n  if (session->internals.priorities.no_padding == 0 && (!IS_DTLS(session)))\n    random_pad = 1;\n  else\n    random_pad = 0;\n  \n  _gnutls_hard_log(\"ENC[%p]: cipher: %s, MAC: %s, Epoch: %u\\n\",\n    session, gnutls_cipher_get_name(params->cipher_algorithm), gnutls_mac_get_name(params->mac_algorithm),\n    (unsigned int)params->epoch);\n\n  preamble_size =\n    make_preamble (UINT64DATA\n                   (params->write.sequence_number),\n                   type, compressed->size, ver, preamble);\n\n  /* Calculate the encrypted length (padding etc.)\n   */\n  length_to_encrypt = length =\n    calc_enc_length (session, compressed->size, tag_size, &pad,\n                     random_pad, block_algo, auth_cipher, blocksize);\n  if (length < 0)\n    {\n      return gnutls_assert_val(length);\n    }\n\n  /* copy the encrypted data to cipher_data.\n   */\n  if (cipher_size < length)\n    {\n      return gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n    }\n\n  data_ptr = cipher_data;\n\n  if (explicit_iv)\n    {\n\n      if (block_algo == CIPHER_BLOCK)\n        {\n          /* copy the random IV.\n           */\n          ret = _gnutls_rnd (GNUTLS_RND_NONCE, data_ptr, blocksize);\n          if (ret < 0)\n            return gnutls_assert_val(ret);\n \n          _gnutls_auth_cipher_setiv(&params->write.cipher_state, data_ptr, blocksize);\n\n          data_ptr += blocksize;\n          cipher_data += blocksize;\n          length_to_encrypt -= blocksize;\n        }\n      else if (auth_cipher)\n        {\n          uint8_t nonce[blocksize];\n\n          /* Values in AEAD are pretty fixed in TLS 1.2 for 128-bit block\n           */\n          if (params->write.IV.data == NULL || params->write.IV.size != AEAD_IMPLICIT_DATA_SIZE)\n            return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n\n          /* Instead of generating a new nonce on every packet, we use the\n           * write.sequence_number (It is a MAY on RFC 5288).\n           */\n          memcpy(nonce, params->write.IV.data, params->write.IV.size);\n          memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], UINT64DATA(params->write.sequence_number), 8);\n\n          _gnutls_auth_cipher_setiv(&params->write.cipher_state, nonce, AEAD_IMPLICIT_DATA_SIZE+AEAD_EXPLICIT_DATA_SIZE);\n\n          /* copy the explicit part */\n          memcpy(data_ptr, &nonce[AEAD_IMPLICIT_DATA_SIZE], AEAD_EXPLICIT_DATA_SIZE);\n\n          data_ptr += AEAD_EXPLICIT_DATA_SIZE;\n          cipher_data += AEAD_EXPLICIT_DATA_SIZE;\n          /* In AEAD ciphers we don't encrypt the tag \n           */\n          length_to_encrypt -= AEAD_EXPLICIT_DATA_SIZE + tag_size;\n        }\n    }\n  else\n    {\n      /* AEAD ciphers have an explicit IV. Shouldn't be used otherwise.\n       */\n      if (auth_cipher) return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n    }\n\n  memcpy (data_ptr, compressed->data, compressed->size);\n  data_ptr += compressed->size;\n\n  if (tag_size > 0)\n    {\n      tag_ptr = data_ptr;\n      data_ptr += tag_size;\n    }\n  if (block_algo == CIPHER_BLOCK && pad > 0)\n    {\n      memset (data_ptr, pad - 1, pad);\n    }\n\n  /* add the authenticate data */\n  ret = _gnutls_auth_cipher_add_auth(&params->write.cipher_state, preamble, preamble_size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  /* Actual encryption (inplace).\n   */\n  ret =\n    _gnutls_auth_cipher_encrypt2_tag (&params->write.cipher_state,\n        cipher_data, length_to_encrypt, \n        cipher_data, cipher_size,\n        tag_ptr, tag_size, compressed->size);\n  if (ret < 0)\n    return gnutls_assert_val(ret);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,7 +65,7 @@\n           ret = _gnutls_rnd (GNUTLS_RND_NONCE, data_ptr, blocksize);\n           if (ret < 0)\n             return gnutls_assert_val(ret);\n-\n+ \n           _gnutls_auth_cipher_setiv(&params->write.cipher_state, data_ptr, blocksize);\n \n           data_ptr += blocksize;",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                " "
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0863",
        "func_name": "mumble-voip/mumble/Database::Database",
        "description": "Mumble 1.2.3 and earlier uses world-readable permissions for .local/share/data/Mumble/.mumble.sqlite files in home directories, which might allow local users to obtain a cleartext password and configuration data by reading a file.",
        "git_url": "https://github.com/mumble-voip/mumble/commit/5632c35d6759f5e13a7dfe78e4ee6403ff6a8e3e",
        "commit_title": "Explicitly remove file permissions for settings and DB",
        "commit_text": "",
        "func_before": "Database::Database() {\n\tQSqlDatabase db = QSqlDatabase::addDatabase(QLatin1String(\"QSQLITE\"));\n\tQSettings qs;\n\tQStringList datapaths;\n\tint i;\n\n\tdatapaths << g.qdBasePath.absolutePath();\n\tdatapaths << QDesktopServices::storageLocation(QDesktopServices::DataLocation);\n#if defined(Q_OS_UNIX) && ! defined(Q_OS_MAC)\n\tdatapaths << QDir::homePath() + QLatin1String(\"/.config/Mumble\");\n#endif\n\tdatapaths << QDir::homePath();\n\tdatapaths << QDir::currentPath();\n\tdatapaths << qApp->applicationDirPath();\n\tdatapaths << qs.value(QLatin1String(\"InstPath\")).toString();\n\tbool found = false;\n\n\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n\t\tif (!datapaths[i].isEmpty()) {\n\t\t\tQFile f(datapaths[i] + QLatin1String(\"/mumble.sqlite\"));\n\t\t\tif (f.exists()) {\n\t\t\t\tdb.setDatabaseName(f.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\n\t\t\tQFile f2(datapaths[i] + QLatin1String(\"/.mumble.sqlite\"));\n\t\t\tif (f2.exists()) {\n\t\t\t\tdb.setDatabaseName(f2.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! found) {\n\t\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n\t\t\tif (!datapaths[i].isEmpty()) {\n\t\t\t\tQDir::root().mkpath(datapaths[i]);\n#ifdef Q_OS_WIN\n\t\t\t\tQFile f(datapaths[i] + QLatin1String(\"/mumble.sqlite\"));\n#else\n\t\t\t\tQFile f(datapaths[i] + QLatin1String(\"/.mumble.sqlite\"));\n#endif\n\t\t\t\tdb.setDatabaseName(f.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! found) {\n\t\tQMessageBox::critical(NULL, QLatin1String(\"Mumble\"), tr(\"Mumble failed to initialize a database in any\\nof the possible locations.\"), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n\t\tqFatal(\"Database: Failed initialization\");\n\t}\n\n\tQFileInfo fi(db.databaseName());\n\n\tif (! fi.isWritable()) {\n\t\tQMessageBox::critical(NULL, QLatin1String(\"Mumble\"), tr(\"The database '%1' is read-only. Mumble cannot store server settings (i.e. SSL certificates) until you fix this problem.\").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n\t\tqWarning(\"Database: Database is read-only\");\n\t}\n\n\tQSqlQuery query;\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `servers` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hostname` TEXT, `port` INTEGER DEFAULT \" MUMTEXT(DEFAULT_MUMBLE_PORT) \", `username` TEXT, `password` TEXT)\"));\n\tquery.exec(QLatin1String(\"ALTER TABLE `servers` ADD COLUMN `url` TEXT\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `comments` (`who` TEXT, `comment` BLOB, `seen` DATE)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `comments_comment` ON `comments`(`who`, `comment`)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `comments_seen` ON `comments`(`seen`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `blobs` (`hash` TEXT, `data` BLOB, `seen` DATE)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `blobs_hash` ON `blobs`(`hash`)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `blobs_seen` ON `blobs`(`seen`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `tokens` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB, `token` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `tokens_host_port` ON `tokens`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `shortcut` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB, `shortcut` BLOB, `target` BLOB, `suppress` INTEGER)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `shortcut_host_port` ON `shortcut`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `udp` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `udp_host_port` ON `udp`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `cert` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hostname` TEXT, `port` INTEGER, `digest` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `cert_host_port` ON `cert`(`hostname`,`port`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `friends` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hash` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `friends_name` ON `friends`(`name`)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `friends_hash` ON `friends`(`hash`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `muted` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hash` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `muted_hash` ON `muted`(`hash`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `pingcache` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hostname` TEXT, `port` INTEGER, `ping` INTEGER)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `pingcache_host_port` ON `pingcache`(`hostname`,`port`)\"));\n\n\tquery.exec(QLatin1String(\"DELETE FROM `comments` WHERE `seen` < datetime('now', '-1 years')\"));\n\tquery.exec(QLatin1String(\"DELETE FROM `blobs` WHERE `seen` < datetime('now', '-1 months')\"));\n\n\tquery.exec(QLatin1String(\"VACUUM\"));\n\n\tquery.exec(QLatin1String(\"PRAGMA synchronous = OFF\"));\n\tquery.exec(QLatin1String(\"PRAGMA journal_mode = TRUNCATE\"));\n\n\tquery.exec(QLatin1String(\"SELECT sqlite_version()\"));\n\twhile (query.next())\n\t\tqWarning() << \"Database SQLite:\" << query.value(0).toString();\n}",
        "func": "Database::Database() {\n\tQSqlDatabase db = QSqlDatabase::addDatabase(QLatin1String(\"QSQLITE\"));\n\tQSettings qs;\n\tQStringList datapaths;\n\tint i;\n\n\tdatapaths << g.qdBasePath.absolutePath();\n\tdatapaths << QDesktopServices::storageLocation(QDesktopServices::DataLocation);\n#if defined(Q_OS_UNIX) && ! defined(Q_OS_MAC)\n\tdatapaths << QDir::homePath() + QLatin1String(\"/.config/Mumble\");\n#endif\n\tdatapaths << QDir::homePath();\n\tdatapaths << QDir::currentPath();\n\tdatapaths << qApp->applicationDirPath();\n\tdatapaths << qs.value(QLatin1String(\"InstPath\")).toString();\n\tbool found = false;\n\n\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n\t\tif (!datapaths[i].isEmpty()) {\n\t\t\tQFile f(datapaths[i] + QLatin1String(\"/mumble.sqlite\"));\n\t\t\tif (f.exists()) {\n\t\t\t\tdb.setDatabaseName(f.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\n\t\t\tQFile f2(datapaths[i] + QLatin1String(\"/.mumble.sqlite\"));\n\t\t\tif (f2.exists()) {\n\t\t\t\tdb.setDatabaseName(f2.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! found) {\n\t\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n\t\t\tif (!datapaths[i].isEmpty()) {\n\t\t\t\tQDir::root().mkpath(datapaths[i]);\n#ifdef Q_OS_WIN\n\t\t\t\tQFile f(datapaths[i] + QLatin1String(\"/mumble.sqlite\"));\n#else\n\t\t\t\tQFile f(datapaths[i] + QLatin1String(\"/.mumble.sqlite\"));\n#endif\n\t\t\t\tdb.setDatabaseName(f.fileName());\n\t\t\t\tfound = db.open();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! found) {\n\t\tQMessageBox::critical(NULL, QLatin1String(\"Mumble\"), tr(\"Mumble failed to initialize a database in any\\nof the possible locations.\"), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n\t\tqFatal(\"Database: Failed initialization\");\n\t}\n\n\tQFileInfo fi(db.databaseName());\n\n\tif (! fi.isWritable()) {\n\t\tQMessageBox::critical(NULL, QLatin1String(\"Mumble\"), tr(\"The database '%1' is read-only. Mumble cannot store server settings (i.e. SSL certificates) until you fix this problem.\").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n\t\tqWarning(\"Database: Database is read-only\");\n\t}\n\n\t{\n\t\tQFile f(db.databaseName());\n\t\tf.setPermissions(f.permissions() & ~(QFile::ReadGroup | QFile::WriteGroup | QFile::ExeGroup | QFile::ReadOther | QFile::WriteOther | QFile::ExeOther));\n\t}\n\n\tQSqlQuery query;\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `servers` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hostname` TEXT, `port` INTEGER DEFAULT \" MUMTEXT(DEFAULT_MUMBLE_PORT) \", `username` TEXT, `password` TEXT)\"));\n\tquery.exec(QLatin1String(\"ALTER TABLE `servers` ADD COLUMN `url` TEXT\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `comments` (`who` TEXT, `comment` BLOB, `seen` DATE)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `comments_comment` ON `comments`(`who`, `comment`)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `comments_seen` ON `comments`(`seen`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `blobs` (`hash` TEXT, `data` BLOB, `seen` DATE)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `blobs_hash` ON `blobs`(`hash`)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `blobs_seen` ON `blobs`(`seen`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `tokens` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB, `token` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `tokens_host_port` ON `tokens`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `shortcut` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB, `shortcut` BLOB, `target` BLOB, `suppress` INTEGER)\"));\n\tquery.exec(QLatin1String(\"CREATE INDEX IF NOT EXISTS `shortcut_host_port` ON `shortcut`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `udp` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `digest` BLOB)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `udp_host_port` ON `udp`(`digest`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `cert` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hostname` TEXT, `port` INTEGER, `digest` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `cert_host_port` ON `cert`(`hostname`,`port`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `friends` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hash` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `friends_name` ON `friends`(`name`)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `friends_hash` ON `friends`(`hash`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `muted` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hash` TEXT)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `muted_hash` ON `muted`(`hash`)\"));\n\n\tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `pingcache` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `hostname` TEXT, `port` INTEGER, `ping` INTEGER)\"));\n\tquery.exec(QLatin1String(\"CREATE UNIQUE INDEX IF NOT EXISTS `pingcache_host_port` ON `pingcache`(`hostname`,`port`)\"));\n\n\tquery.exec(QLatin1String(\"DELETE FROM `comments` WHERE `seen` < datetime('now', '-1 years')\"));\n\tquery.exec(QLatin1String(\"DELETE FROM `blobs` WHERE `seen` < datetime('now', '-1 months')\"));\n\n\tquery.exec(QLatin1String(\"VACUUM\"));\n\n\tquery.exec(QLatin1String(\"PRAGMA synchronous = OFF\"));\n\tquery.exec(QLatin1String(\"PRAGMA journal_mode = TRUNCATE\"));\n\n\tquery.exec(QLatin1String(\"SELECT sqlite_version()\"));\n\twhile (query.next())\n\t\tqWarning() << \"Database SQLite:\" << query.value(0).toString();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,6 +58,11 @@\n \t\tqWarning(\"Database: Database is read-only\");\n \t}\n \n+\t{\n+\t\tQFile f(db.databaseName());\n+\t\tf.setPermissions(f.permissions() & ~(QFile::ReadGroup | QFile::WriteGroup | QFile::ExeGroup | QFile::ReadOther | QFile::WriteOther | QFile::ExeOther));\n+\t}\n+\n \tQSqlQuery query;\n \n \tquery.exec(QLatin1String(\"CREATE TABLE IF NOT EXISTS `servers` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hostname` TEXT, `port` INTEGER DEFAULT \" MUMTEXT(DEFAULT_MUMBLE_PORT) \", `username` TEXT, `password` TEXT)\"));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t{",
                "\t\tQFile f(db.databaseName());",
                "\t\tf.setPermissions(f.permissions() & ~(QFile::ReadGroup | QFile::WriteGroup | QFile::ExeGroup | QFile::ReadOther | QFile::WriteOther | QFile::ExeOther));",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0863",
        "func_name": "mumble-voip/mumble/OverlaySettings::save",
        "description": "Mumble 1.2.3 and earlier uses world-readable permissions for .local/share/data/Mumble/.mumble.sqlite files in home directories, which might allow local users to obtain a cleartext password and configuration data by reading a file.",
        "git_url": "https://github.com/mumble-voip/mumble/commit/5632c35d6759f5e13a7dfe78e4ee6403ff6a8e3e",
        "commit_title": "Explicitly remove file permissions for settings and DB",
        "commit_text": "",
        "func_before": "void OverlaySettings::save(QSettings* settings_ptr) {\n\tOverlaySettings def;\n\n\tSAVELOAD(bEnable, \"enable\");\n\n\tSAVELOAD(osShow, \"show\");\n\tSAVELOAD(bAlwaysSelf, \"alwaysself\");\n\tSAVELOAD(uiActiveTime, \"activetime\");\n\tSAVELOAD(osSort, \"sort\");\n\tSAVELOAD(fX, \"x\");\n\tSAVELOAD(fY, \"y\");\n\tSAVELOAD(fZoom, \"zoom\");\n\tSAVELOAD(uiColumns, \"columns\");\n\n\tsettings_ptr->beginReadArray(QLatin1String(\"states\"));\n\tfor (int i=0; i<4; ++i) {\n\t\tsettings_ptr->setArrayIndex(i);\n\t\tSAVELOAD(qcUserName[i], \"color\");\n\t\tSAVELOAD(fUser[i], \"opacity\");\n\t}\n\tsettings_ptr->endArray();\n\n\tSAVELOAD(qfUserName, \"userfont\");\n\tSAVELOAD(qfChannel, \"channelfont\");\n\tSAVELOAD(qcChannel, \"channelcolor\");\n\tSAVELOAD(qfFps, \"fpsfont\");\n\tSAVELOAD(qcFps, \"fpscolor\");\n\n\tSAVELOAD(fBoxPad, \"padding\");\n\tSAVELOAD(fBoxPenWidth, \"penwidth\");\n\tSAVELOAD(qcBoxPen, \"pencolor\");\n\tSAVELOAD(qcBoxFill, \"fillcolor\");\n\n\tSAVELOAD(bUserName, \"usershow\");\n\tSAVELOAD(bChannel, \"channelshow\");\n\tSAVELOAD(bMutedDeafened, \"mutedshow\");\n\tSAVELOAD(bAvatar, \"avatarshow\");\n\tSAVELOAD(bBox, \"boxshow\");\n\tSAVELOAD(bFps, \"fpsshow\");\n\n\tSAVELOAD(fUserName, \"useropacity\");\n\tSAVELOAD(fChannel, \"channelopacity\");\n\tSAVELOAD(fMutedDeafened, \"mutedopacity\");\n\tSAVELOAD(fAvatar, \"avataropacity\");\n\tSAVELOAD(fFps, \"fpsopacity\");\n\n\tSAVELOAD(qrfUserName, \"userrect\");\n\tSAVELOAD(qrfChannel, \"channelrect\");\n\tSAVELOAD(qrfMutedDeafened, \"mutedrect\");\n\tSAVELOAD(qrfAvatar, \"avatarrect\");\n\tSAVELOAD(qrfFps, \"fpsrect\");\n\n\tSAVEFLAG(qaUserName, \"useralign\");\n\tSAVEFLAG(qaChannel, \"channelalign\");\n\tSAVEFLAG(qaMutedDeafened, \"mutedalign\");\n\tSAVEFLAG(qaAvatar, \"avataralign\");\n\n\tsettings_ptr->setValue(QLatin1String(\"usewhitelist\"), bUseWhitelist);\n\tsettings_ptr->setValue(QLatin1String(\"blacklist\"), qslBlacklist);\n\tsettings_ptr->setValue(QLatin1String(\"whitelist\"), qslWhitelist);\n}",
        "func": "void OverlaySettings::save(QSettings* settings_ptr) {\n\tOverlaySettings def;\n\n\tsettings_ptr->setValue(QLatin1String(\"version\"), QLatin1String(MUMTEXT(MUMBLE_VERSION_STRING)));\n\tsettings_ptr->sync();\n\n#if defined(Q_OS_WIN) || defined(Q_OS_MAC)\n\tif (settings_ptr->format() == QSettings::IniFormat)\n#endif\n        {\n               QFile f(settings_ptr->fileName());\n               f.setPermissions(f.permissions() & ~(QFile::ReadGroup | QFile::WriteGroup | QFile::ExeGroup | QFile::ReadOther | QFile::WriteOther | QFile::ExeOther));\n        }\n\n\tSAVELOAD(bEnable, \"enable\");\n\n\tSAVELOAD(osShow, \"show\");\n\tSAVELOAD(bAlwaysSelf, \"alwaysself\");\n\tSAVELOAD(uiActiveTime, \"activetime\");\n\tSAVELOAD(osSort, \"sort\");\n\tSAVELOAD(fX, \"x\");\n\tSAVELOAD(fY, \"y\");\n\tSAVELOAD(fZoom, \"zoom\");\n\tSAVELOAD(uiColumns, \"columns\");\n\n\tsettings_ptr->beginReadArray(QLatin1String(\"states\"));\n\tfor (int i=0; i<4; ++i) {\n\t\tsettings_ptr->setArrayIndex(i);\n\t\tSAVELOAD(qcUserName[i], \"color\");\n\t\tSAVELOAD(fUser[i], \"opacity\");\n\t}\n\tsettings_ptr->endArray();\n\n\tSAVELOAD(qfUserName, \"userfont\");\n\tSAVELOAD(qfChannel, \"channelfont\");\n\tSAVELOAD(qcChannel, \"channelcolor\");\n\tSAVELOAD(qfFps, \"fpsfont\");\n\tSAVELOAD(qcFps, \"fpscolor\");\n\n\tSAVELOAD(fBoxPad, \"padding\");\n\tSAVELOAD(fBoxPenWidth, \"penwidth\");\n\tSAVELOAD(qcBoxPen, \"pencolor\");\n\tSAVELOAD(qcBoxFill, \"fillcolor\");\n\n\tSAVELOAD(bUserName, \"usershow\");\n\tSAVELOAD(bChannel, \"channelshow\");\n\tSAVELOAD(bMutedDeafened, \"mutedshow\");\n\tSAVELOAD(bAvatar, \"avatarshow\");\n\tSAVELOAD(bBox, \"boxshow\");\n\tSAVELOAD(bFps, \"fpsshow\");\n\n\tSAVELOAD(fUserName, \"useropacity\");\n\tSAVELOAD(fChannel, \"channelopacity\");\n\tSAVELOAD(fMutedDeafened, \"mutedopacity\");\n\tSAVELOAD(fAvatar, \"avataropacity\");\n\tSAVELOAD(fFps, \"fpsopacity\");\n\n\tSAVELOAD(qrfUserName, \"userrect\");\n\tSAVELOAD(qrfChannel, \"channelrect\");\n\tSAVELOAD(qrfMutedDeafened, \"mutedrect\");\n\tSAVELOAD(qrfAvatar, \"avatarrect\");\n\tSAVELOAD(qrfFps, \"fpsrect\");\n\n\tSAVEFLAG(qaUserName, \"useralign\");\n\tSAVEFLAG(qaChannel, \"channelalign\");\n\tSAVEFLAG(qaMutedDeafened, \"mutedalign\");\n\tSAVEFLAG(qaAvatar, \"avataralign\");\n\n\tsettings_ptr->setValue(QLatin1String(\"usewhitelist\"), bUseWhitelist);\n\tsettings_ptr->setValue(QLatin1String(\"blacklist\"), qslBlacklist);\n\tsettings_ptr->setValue(QLatin1String(\"whitelist\"), qslWhitelist);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,16 @@\n void OverlaySettings::save(QSettings* settings_ptr) {\n \tOverlaySettings def;\n+\n+\tsettings_ptr->setValue(QLatin1String(\"version\"), QLatin1String(MUMTEXT(MUMBLE_VERSION_STRING)));\n+\tsettings_ptr->sync();\n+\n+#if defined(Q_OS_WIN) || defined(Q_OS_MAC)\n+\tif (settings_ptr->format() == QSettings::IniFormat)\n+#endif\n+        {\n+               QFile f(settings_ptr->fileName());\n+               f.setPermissions(f.permissions() & ~(QFile::ReadGroup | QFile::WriteGroup | QFile::ExeGroup | QFile::ReadOther | QFile::WriteOther | QFile::ExeOther));\n+        }\n \n \tSAVELOAD(bEnable, \"enable\");\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tsettings_ptr->setValue(QLatin1String(\"version\"), QLatin1String(MUMTEXT(MUMBLE_VERSION_STRING)));",
                "\tsettings_ptr->sync();",
                "",
                "#if defined(Q_OS_WIN) || defined(Q_OS_MAC)",
                "\tif (settings_ptr->format() == QSettings::IniFormat)",
                "#endif",
                "        {",
                "               QFile f(settings_ptr->fileName());",
                "               f.setPermissions(f.permissions() & ~(QFile::ReadGroup | QFile::WriteGroup | QFile::ExeGroup | QFile::ReadOther | QFile::WriteOther | QFile::ExeOther));",
                "        }"
            ]
        }
    }
]