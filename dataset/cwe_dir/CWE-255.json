[
    {
        "cve_id": "CVE-2011-4966",
        "func_name": "alandekok/freeradius-server/unix_getpw",
        "description": "modules/rlm_unix/rlm_unix.c in FreeRADIUS before 2.2.0, when unix mode is enabled for user authentication, does not properly check the password expiration in /etc/shadow, which allows remote authenticated users to authenticate using an expired password.",
        "git_url": "https://github.com/alandekok/freeradius-server/commit/1b1ec5ce75e224bd1755650c18ccdaa6dc53e605",
        "commit_title": "heck for account and password expiration",
        "commit_text": "",
        "func_before": "static int unix_getpw(UNUSED void *instance, REQUEST *request,\n\t\t      VALUE_PAIR **vp_list)\n{\n\tconst char\t*name;\n\tconst char\t*encrypted_pass;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd\t*spwd = NULL;\n#endif\n#ifdef OSFC2\n\tstruct pr_passwd *pr_pw;\n#else\n\tstruct passwd\t*pwd;\n#endif\n#ifdef HAVE_GETUSERSHELL\n\tchar\t\t*shell;\n#endif\n\tVALUE_PAIR\t*vp;\n\n\t/*\n\t *\tWe can only authenticate user requests which HAVE\n\t *\ta User-Name attribute.\n\t */\n\tif (!request->username) {\n\t\treturn RLM_MODULE_NOOP;\n\t}\n\n\tname = (char *)request->username->vp_strvalue;\n\tencrypted_pass = NULL;\n\n#ifdef OSFC2\n\tif ((pr_pw = getprpwnam(name)) == NULL)\n\t\treturn RLM_MODULE_NOTFOUND;\n\tencrypted_pass = pr_pw->ufld.fd_encrypt;\n\n\t/*\n\t *\tCheck if account is locked.\n\t */\n\tif (pr_pw->uflg.fg_lock!=1) {\n\t\tradlog(L_AUTH, \"rlm_unix: [%s]: account locked\", name);\n\t\treturn RLM_MODULE_USERLOCK;\n\t}\n#else /* OSFC2 */\n\tif ((pwd = getpwnam(name)) == NULL) {\n\t\treturn RLM_MODULE_NOTFOUND;\n\t}\n\tencrypted_pass = pwd->pw_passwd;\n#endif /* OSFC2 */\n\n#ifdef HAVE_GETSPNAM\n\t/*\n\t *      See if there is a shadow password.\n\t *\n\t *\tOnly query the _system_ shadow file if the encrypted\n\t *\tpassword from the passwd file is < 10 characters (i.e.\n\t *\ta valid password would never crypt() to it).  This will\n\t *\tprevents users from using NULL password fields as things\n\t *\tstand right now.\n\t */\n\tif ((encrypted_pass == NULL) || (strlen(encrypted_pass) < 10)) {\n\t\tif ((spwd = getspnam(name)) == NULL) {\n\t\t\treturn RLM_MODULE_NOTFOUND;\n\t\t}\n\t\tencrypted_pass = spwd->sp_pwdp;\n\t}\n#endif\t/* HAVE_GETSPNAM */\n\n/*\n *\tThese require 'pwd != NULL', which isn't true on OSFC2\n */\n#ifndef OSFC2\n#ifdef DENY_SHELL\n\t/*\n\t *\tUsers with a particular shell are denied access\n\t */\n\tif (strcmp(pwd->pw_shell, DENY_SHELL) == 0) {\n\t\tradlog_request(L_AUTH, 0, request,\n\t\t\t       \"rlm_unix: [%s]: invalid shell\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#ifdef HAVE_GETUSERSHELL\n\t/*\n\t *\tCheck /etc/shells for a valid shell. If that file\n\t *\tcontains /RADIUSD/ANY/SHELL then any shell will do.\n\t */\n\twhile ((shell = getusershell()) != NULL) {\n\t\tif (strcmp(shell, pwd->pw_shell) == 0 ||\n\t\t    strcmp(shell, \"/RADIUSD/ANY/SHELL\") == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendusershell();\n\tif (shell == NULL) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: invalid shell [%s]\",\n\t\t       name, pwd->pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp / 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t/*\n\t *\tCheck if password has expired.\n\t */\n\tif ((pwd->pw_expire > 0) &&\n\t    (request->timestamp > pwd->pw_expire)) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n\t/*\n\t *\tWe might have a passwordless account.\n\t *\n\t *\tFIXME: Maybe add Auth-Type := Accept?\n\t */\n\tif (encrypted_pass[0] == 0)\n\t\treturn RLM_MODULE_NOOP;\n\n\tvp = pairmake(\"Crypt-Password\", encrypted_pass, T_OP_SET);\n\tif (!vp) return RLM_MODULE_FAIL;\n\n\tpairmove(vp_list, &vp);\n\tpairfree(&vp);\t\t/* might not be NULL; */\n\n\treturn RLM_MODULE_UPDATED;\n}",
        "func": "static int unix_getpw(UNUSED void *instance, REQUEST *request,\n\t\t      VALUE_PAIR **vp_list)\n{\n\tconst char\t*name;\n\tconst char\t*encrypted_pass;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd\t*spwd = NULL;\n#endif\n#ifdef OSFC2\n\tstruct pr_passwd *pr_pw;\n#else\n\tstruct passwd\t*pwd;\n#endif\n#ifdef HAVE_GETUSERSHELL\n\tchar\t\t*shell;\n#endif\n\tVALUE_PAIR\t*vp;\n\n\t/*\n\t *\tWe can only authenticate user requests which HAVE\n\t *\ta User-Name attribute.\n\t */\n\tif (!request->username) {\n\t\treturn RLM_MODULE_NOOP;\n\t}\n\n\tname = (char *)request->username->vp_strvalue;\n\tencrypted_pass = NULL;\n\n#ifdef OSFC2\n\tif ((pr_pw = getprpwnam(name)) == NULL)\n\t\treturn RLM_MODULE_NOTFOUND;\n\tencrypted_pass = pr_pw->ufld.fd_encrypt;\n\n\t/*\n\t *\tCheck if account is locked.\n\t */\n\tif (pr_pw->uflg.fg_lock!=1) {\n\t\tradlog(L_AUTH, \"rlm_unix: [%s]: account locked\", name);\n\t\treturn RLM_MODULE_USERLOCK;\n\t}\n#else /* OSFC2 */\n\tif ((pwd = getpwnam(name)) == NULL) {\n\t\treturn RLM_MODULE_NOTFOUND;\n\t}\n\tencrypted_pass = pwd->pw_passwd;\n#endif /* OSFC2 */\n\n#ifdef HAVE_GETSPNAM\n\t/*\n\t *      See if there is a shadow password.\n\t *\n\t *\tOnly query the _system_ shadow file if the encrypted\n\t *\tpassword from the passwd file is < 10 characters (i.e.\n\t *\ta valid password would never crypt() to it).  This will\n\t *\tprevents users from using NULL password fields as things\n\t *\tstand right now.\n\t */\n\tif ((encrypted_pass == NULL) || (strlen(encrypted_pass) < 10)) {\n\t\tif ((spwd = getspnam(name)) == NULL) {\n\t\t\treturn RLM_MODULE_NOTFOUND;\n\t\t}\n\t\tencrypted_pass = spwd->sp_pwdp;\n\t}\n#endif\t/* HAVE_GETSPNAM */\n\n/*\n *\tThese require 'pwd != NULL', which isn't true on OSFC2\n */\n#ifndef OSFC2\n#ifdef DENY_SHELL\n\t/*\n\t *\tUsers with a particular shell are denied access\n\t */\n\tif (strcmp(pwd->pw_shell, DENY_SHELL) == 0) {\n\t\tradlog_request(L_AUTH, 0, request,\n\t\t\t       \"rlm_unix: [%s]: invalid shell\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#ifdef HAVE_GETUSERSHELL\n\t/*\n\t *\tCheck /etc/shells for a valid shell. If that file\n\t *\tcontains /RADIUSD/ANY/SHELL then any shell will do.\n\t */\n\twhile ((shell = getusershell()) != NULL) {\n\t\tif (strcmp(shell, pwd->pw_shell) == 0 ||\n\t\t    strcmp(shell, \"/RADIUSD/ANY/SHELL\") == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tendusershell();\n\tif (shell == NULL) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: invalid shell [%s]\",\n\t\t       name, pwd->pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd && spwd->sp_lstchg > 0 && spwd->sp_max >= 0 &&\n\t    (request->timestamp / 86400) > (spwd->sp_lstchg + spwd->sp_max)) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n\t/*\n\t *      Check if account has expired.\n\t */\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp / 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: account has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t/*\n\t *\tCheck if password has expired.\n\t */\n\tif ((pwd->pw_expire > 0) &&\n\t    (request->timestamp > pwd->pw_expire)) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n\t/*\n\t *\tWe might have a passwordless account.\n\t *\n\t *\tFIXME: Maybe add Auth-Type := Accept?\n\t */\n\tif (encrypted_pass[0] == 0)\n\t\treturn RLM_MODULE_NOOP;\n\n\tvp = pairmake(\"Crypt-Password\", encrypted_pass, T_OP_SET);\n\tif (!vp) return RLM_MODULE_FAIL;\n\n\tpairmove(vp_list, &vp);\n\tpairfree(&vp);\t\t/* might not be NULL; */\n\n\treturn RLM_MODULE_UPDATED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -103,9 +103,17 @@\n \t/*\n \t *      Check if password has expired.\n \t */\n+\tif (spwd && spwd->sp_lstchg > 0 && spwd->sp_max >= 0 &&\n+\t    (request->timestamp / 86400) > (spwd->sp_lstchg + spwd->sp_max)) {\n+\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n+\t\treturn RLM_MODULE_REJECT;\n+\t}\n+\t/*\n+\t *      Check if account has expired.\n+\t */\n \tif (spwd && spwd->sp_expire > 0 &&\n \t    (request->timestamp / 86400) > spwd->sp_expire) {\n-\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n+\t\tradlog_request(L_AUTH, 0, request, \"[%s]: account has expired\", name);\n \t\treturn RLM_MODULE_REJECT;\n \t}\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);"
            ],
            "added_lines": [
                "\tif (spwd && spwd->sp_lstchg > 0 && spwd->sp_max >= 0 &&",
                "\t    (request->timestamp / 86400) > (spwd->sp_lstchg + spwd->sp_max)) {",
                "\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);",
                "\t\treturn RLM_MODULE_REJECT;",
                "\t}",
                "\t/*",
                "\t *      Check if account has expired.",
                "\t */",
                "\t\tradlog_request(L_AUTH, 0, request, \"[%s]: account has expired\", name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-5351",
        "func_name": "krb5/kadm5_randkey_principal_3",
        "description": "The kadm5_randkey_principal_3 function in lib/kadm5/srv/svr_principal.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13 sends old keys in a response to a -randkey -keepold request, which allows remote authenticated users to forge tickets by leveraging administrative access.",
        "git_url": "https://github.com/krb5/krb5/commit/af0ed4df4dfae762ab5fb605f5a0c8f59cb4f6ca",
        "commit_title": "Return only new keys in randkey [CVE-2014-5351]",
        "commit_text": " In kadmind's randkey operation, if a client specifies the keepold flag, do not include the preserved old keys in the response.  CVE-2014-5351:  An authenticated remote attacker can retrieve the current keys for a service principal when generating a new set of keys for that principal.  The attacker needs to be authenticated as a user who has the elevated privilege for randomizing the keys of other principals.  Normally, when a Kerberos administrator randomizes the keys of a service principal, kadmind returns only the new keys.  This prevents an administrator who lacks legitimate privileged access to a service from forging tickets to authenticate to that service.  If the \"keepold\" flag to the kadmin randkey RPC operation is true, kadmind retains the old keys in the KDC database as intended, but also unexpectedly returns the old keys to the client, which exposes the service to ticket forgery attacks from the administrator.  A mitigating factor is that legitimate clients of the affected service will start failing to authenticate to the service once they begin to receive service tickets encrypted in the new keys.  The affected service will be unable to decrypt the newly issued tickets, possibly alerting the legitimate administrator of the affected service.  CVSSv2: AV:N/AC:H/Au:S/C:P/I:N/A:N/E:POC/RL:OF/RC:C  [tlyu@mit.edu: CVE description and CVSS score]  ticket: 8018 (new) target_version: 1.13 tags: pullup",
        "func_before": "kadm5_ret_t\nkadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, last_pwd;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        new_n_ks_tuple = 1;\n    }\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        ret = decrypt_key_data(handle->context,\n                               kdb->n_key_data, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}",
        "func": "kadm5_ret_t\nkadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, last_pwd, n_new_keys;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        new_n_ks_tuple = 1;\n    }\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        /* Return only the new keys added by krb5_dbe_crk. */\n        n_new_keys = count_new_keys(kdb->n_key_data, kdb->key_data);\n        ret = decrypt_key_data(handle->context, n_new_keys, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n     osa_princ_ent_rec           adb;\n     krb5_int32                  now;\n     kadm5_policy_ent_rec        pol;\n-    int                         ret, last_pwd;\n+    int                         ret, last_pwd, n_new_keys;\n     krb5_boolean                have_pol = FALSE;\n     kadm5_server_handle_t       handle = server_handle;\n     krb5_keyblock               *act_mkey;\n@@ -103,8 +103,9 @@\n     kdb->fail_auth_count = 0;\n \n     if (keyblocks) {\n-        ret = decrypt_key_data(handle->context,\n-                               kdb->n_key_data, kdb->key_data,\n+        /* Return only the new keys added by krb5_dbe_crk. */\n+        n_new_keys = count_new_keys(kdb->n_key_data, kdb->key_data);\n+        ret = decrypt_key_data(handle->context, n_new_keys, kdb->key_data,\n                                keyblocks, n_keys);\n         if (ret)\n             goto done;",
        "diff_line_info": {
            "deleted_lines": [
                "    int                         ret, last_pwd;",
                "        ret = decrypt_key_data(handle->context,",
                "                               kdb->n_key_data, kdb->key_data,"
            ],
            "added_lines": [
                "    int                         ret, last_pwd, n_new_keys;",
                "        /* Return only the new keys added by krb5_dbe_crk. */",
                "        n_new_keys = count_new_keys(kdb->n_key_data, kdb->key_data);",
                "        ret = decrypt_key_data(handle->context, n_new_keys, kdb->key_data,"
            ]
        }
    }
]