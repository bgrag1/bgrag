[
    {
        "cve_id": "CVE-2016-10011",
        "func_name": "openbsd/src/sshkey_load_file",
        "description": "authfile.c in sshd in OpenSSH before 7.4 does not properly consider the effects of realloc on buffer contents, which might allow local users to obtain sensitive private-key information by leveraging access to a privilege-separated child process.",
        "git_url": "https://github.com/openbsd/src/commit/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9",
        "commit_title": "use sshbuf_allocate() to pre-allocate the buffer used for loading",
        "commit_text": "keys. This avoids implicit realloc inside the buffer code, which might theoretically leave fragments of the key on the heap. This doesn't appear to happen in practice for normal sized keys, but was observed for novelty oversize ones. ",
        "func_before": "int\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}",
        "func": "int\nsshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r, dontmax = 0;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t/*\n\t * Pre-allocate the buffer used for the key contents and clamp its\n\t * maximum size. This ensures that key contents are never leaked via\n\t * implicit realloc() in the sshbuf code.\n\t */\n\tif ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {\n\t\tst.st_size = 64*1024; /* 64k should be enough for anyone :) */\n\t\tdontmax = 1;\n\t}\n\tif ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||\n\t    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))\n\t\treturn r;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,13 +4,25 @@\n \tu_char buf[1024];\n \tsize_t len;\n \tstruct stat st;\n-\tint r;\n+\tint r, dontmax = 0;\n \n \tif (fstat(fd, &st) < 0)\n \t\treturn SSH_ERR_SYSTEM_ERROR;\n \tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n \t    st.st_size > MAX_KEY_FILE_SIZE)\n \t\treturn SSH_ERR_INVALID_FORMAT;\n+\t/*\n+\t * Pre-allocate the buffer used for the key contents and clamp its\n+\t * maximum size. This ensures that key contents are never leaked via\n+\t * implicit realloc() in the sshbuf code.\n+\t */\n+\tif ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {\n+\t\tst.st_size = 64*1024; /* 64k should be enough for anyone :) */\n+\t\tdontmax = 1;\n+\t}\n+\tif ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||\n+\t    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))\n+\t\treturn r;\n \tfor (;;) {\n \t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n \t\t\tif (errno == EPIPE)",
        "diff_line_info": {
            "deleted_lines": [
                "\tint r;"
            ],
            "added_lines": [
                "\tint r, dontmax = 0;",
                "\t/*",
                "\t * Pre-allocate the buffer used for the key contents and clamp its",
                "\t * maximum size. This ensures that key contents are never leaked via",
                "\t * implicit realloc() in the sshbuf code.",
                "\t */",
                "\tif ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {",
                "\t\tst.st_size = 64*1024; /* 64k should be enough for anyone :) */",
                "\t\tdontmax = 1;",
                "\t}",
                "\tif ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||",
                "\t    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))",
                "\t\treturn r;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0732",
        "func_name": "openssl/generate_key",
        "description": "During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=3984ef0b72831da8b3ece4745cac4f8575b19098",
        "commit_title": "",
        "commit_text": "Reject excessively large primes in DH key generation.  CVE-2018-0732  (cherry picked from commit 91f7361f47b082ae61ffe1a7b17bb2adf213c7fe)  (Merged from https://github.com/openssl/openssl/pull/6457) ",
        "func_before": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n    unsigned l;\n    BN_CTX *ctx;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else\n        priv_key = dh->priv_key;\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else\n        pub_key = dh->pub_key;\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      CRYPTO_LOCK_DH, dh->p, ctx);\n        if (!mont)\n            goto err;\n    }\n\n    if (generate_new_key) {\n        if (dh->q) {\n            do {\n                if (!BN_rand_range(priv_key, dh->q))\n                    goto err;\n            }\n            while (BN_is_zero(priv_key) || BN_is_one(priv_key));\n        } else {\n            /* secret exponent length */\n            l = dh->length ? dh->length : BN_num_bits(dh->p) - 1;\n            if (!BN_rand(priv_key, l, 0, 0))\n                goto err;\n        }\n    }\n\n    {\n        BIGNUM local_prk;\n        BIGNUM *prk;\n\n        if ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0) {\n            BN_init(&local_prk);\n            prk = &local_prk;\n            BN_with_flags(prk, priv_key, BN_FLG_CONSTTIME);\n        } else\n            prk = priv_key;\n\n        if (!dh->meth->bn_mod_exp(dh, pub_key, dh->g, prk, dh->p, ctx, mont))\n            goto err;\n    }\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    ok = 1;\n err:\n    if (ok != 1)\n        DHerr(DH_F_GENERATE_KEY, ERR_R_BN_LIB);\n\n    if ((pub_key != NULL) && (dh->pub_key == NULL))\n        BN_free(pub_key);\n    if ((priv_key != NULL) && (dh->priv_key == NULL))\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return (ok);\n}",
        "func": "static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n    unsigned l;\n    BN_CTX *ctx = NULL;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    if (BN_num_bits(dh->p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n        DHerr(DH_F_GENERATE_KEY, DH_R_MODULUS_TOO_LARGE);\n        return 0;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else\n        priv_key = dh->priv_key;\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else\n        pub_key = dh->pub_key;\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      CRYPTO_LOCK_DH, dh->p, ctx);\n        if (!mont)\n            goto err;\n    }\n\n    if (generate_new_key) {\n        if (dh->q) {\n            do {\n                if (!BN_rand_range(priv_key, dh->q))\n                    goto err;\n            }\n            while (BN_is_zero(priv_key) || BN_is_one(priv_key));\n        } else {\n            /* secret exponent length */\n            l = dh->length ? dh->length : BN_num_bits(dh->p) - 1;\n            if (!BN_rand(priv_key, l, 0, 0))\n                goto err;\n        }\n    }\n\n    {\n        BIGNUM local_prk;\n        BIGNUM *prk;\n\n        if ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0) {\n            BN_init(&local_prk);\n            prk = &local_prk;\n            BN_with_flags(prk, priv_key, BN_FLG_CONSTTIME);\n        } else\n            prk = priv_key;\n\n        if (!dh->meth->bn_mod_exp(dh, pub_key, dh->g, prk, dh->p, ctx, mont))\n            goto err;\n    }\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    ok = 1;\n err:\n    if (ok != 1)\n        DHerr(DH_F_GENERATE_KEY, ERR_R_BN_LIB);\n\n    if ((pub_key != NULL) && (dh->pub_key == NULL))\n        BN_free(pub_key);\n    if ((priv_key != NULL) && (dh->priv_key == NULL))\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return (ok);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,14 @@\n     int ok = 0;\n     int generate_new_key = 0;\n     unsigned l;\n-    BN_CTX *ctx;\n+    BN_CTX *ctx = NULL;\n     BN_MONT_CTX *mont = NULL;\n     BIGNUM *pub_key = NULL, *priv_key = NULL;\n+\n+    if (BN_num_bits(dh->p) > OPENSSL_DH_MAX_MODULUS_BITS) {\n+        DHerr(DH_F_GENERATE_KEY, DH_R_MODULUS_TOO_LARGE);\n+        return 0;\n+    }\n \n     ctx = BN_CTX_new();\n     if (ctx == NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "    BN_CTX *ctx;"
            ],
            "added_lines": [
                "    BN_CTX *ctx = NULL;",
                "",
                "    if (BN_num_bits(dh->p) > OPENSSL_DH_MAX_MODULUS_BITS) {",
                "        DHerr(DH_F_GENERATE_KEY, DH_R_MODULUS_TOO_LARGE);",
                "        return 0;",
                "    }"
            ]
        }
    }
]